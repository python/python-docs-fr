# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-11-15 18:54+0100\n"
"PO-Revision-Date: 2018-10-04 12:14+0200\n"
"Last-Translator: Julien Palard <julien@palard.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.8.11\n"

#: ../Doc/c-api/arg.rst:6
msgid "Parsing arguments and building values"
msgstr "Analyse des arguments et construction des valeurs"

#: ../Doc/c-api/arg.rst:8
msgid ""
"These functions are useful when creating your own extensions functions and "
"methods.  Additional information and examples are available in :ref:"
"`extending-index`."
msgstr ""
"Ces fonctions sont utiles pour créer vos propres fonctions et méthodes "
"d'extensions. Des informations supplémentaires et des exemples sont "
"disponibles ici: :ref:`extending-index`."

#: ../Doc/c-api/arg.rst:12
msgid ""
"The first three of these functions described, :c:func:`PyArg_ParseTuple`, :c:"
"func:`PyArg_ParseTupleAndKeywords`, and :c:func:`PyArg_Parse`, all use "
"*format strings* which are used to tell the function about the expected "
"arguments.  The format strings use the same syntax for each of these "
"functions."
msgstr ""
"Dans Les trois premières de ces fonctions décrites, :c:func:"
"`PyArg_ParseTuple`, :c:func:`PyArg_ParseTupleAndKeywords`, et :c:func:"
"`PyArg_Parse`, toutes utilisent *des chaînes de format* qui sont utilisées "
"pour indiquer à la fonction les arguments attendus. Les chaînes de format "
"utilise la même syntaxe pour chacune de ces fonctions."

#: ../Doc/c-api/arg.rst:19
msgid "Parsing arguments"
msgstr "Analyse des arguments"

#: ../Doc/c-api/arg.rst:21
msgid ""
"A format string consists of zero or more \"format units.\"  A format unit "
"describes one Python object; it is usually a single character or a "
"parenthesized sequence of format units.  With a few exceptions, a format "
"unit that is not a parenthesized sequence normally corresponds to a single "
"address argument to these functions.  In the following description, the "
"quoted form is the format unit; the entry in (round) parentheses is the "
"Python object type that matches the format unit; and the entry in [square] "
"brackets is the type of the C variable(s) whose address should be passed."
msgstr ""
"Une chaîne de format se compose de zéro ou plusieurs \"unités de format\". "
"Une unité de format décrit un objet Python, elle est généralement composée "
"d'un seul caractère ou d'une séquence d'unités de format entre parenthèses. "
"À quelques exceptions près, une unité de format qui n'est pas une séquence "
"entre parenthèses correspond normalement à un argument d'une seule adresse "
"pour ces fonctions. Dans la description qui suit, la forme entre guillemets "
"est l'unité de format, l'entrée entre parenthèses est le type d'objet Python "
"qui correspond à l'unité de format, et l'entrée entre crochets est le type "
"de la variable C (ou des variables) dont l'adresse doit être donnée."

#: ../Doc/c-api/arg.rst:31
msgid "Strings and buffers"
msgstr "Chaînes et tampons"

#: ../Doc/c-api/arg.rst:33
msgid ""
"These formats allow accessing an object as a contiguous chunk of memory. You "
"don't have to provide raw storage for the returned unicode or bytes area."
msgstr ""
"Ces formats permettent d'accéder à un objet sous forme d'un fragment de "
"mémoire contigüe. Il n'est pas nécessaire d'allouer la mémoire pour "
"l'*unicode* ou le *bytes* renvoyé."

#: ../Doc/c-api/arg.rst:37
msgid ""
"In general, when a format sets a pointer to a buffer, the buffer is managed "
"by the corresponding Python object, and the buffer shares the lifetime of "
"this object.  You won't have to release any memory yourself. The only "
"exceptions are ``es``, ``es#``, ``et`` and ``et#``."
msgstr ""

#: ../Doc/c-api/arg.rst:42
msgid ""
"However, when a :c:type:`Py_buffer` structure gets filled, the underlying "
"buffer is locked so that the caller can subsequently use the buffer even "
"inside a :c:type:`Py_BEGIN_ALLOW_THREADS` block without the risk of mutable "
"data being resized or destroyed.  As a result, **you have to call** :c:func:"
"`PyBuffer_Release` after you have finished processing the data (or in any "
"early abort case)."
msgstr ""
"Néanmoins, quand une structure :c:type:`Py_buffer` est en cours de "
"remplissage, le tampon sous-jacent est verrouillé pour permettre à "
"l'appelant d'utiliser le tampon par la suite, même à l'intérieur d'un bloc :"
"c:type:`Py_BEGIN_ALLOW_THREADS`, sans risques de voir des données muables se "
"faire redimensionner ou supprimer. En conséquence, **il vous appartient "
"d'appeler** :c:func:`PyBuffer_Release` après avoir terminé de traiter les "
"données (ou après une interruption prématurée du traitement de ces données)."

#: ../Doc/c-api/arg.rst:49
msgid "Unless otherwise stated, buffers are not NUL-terminated."
msgstr "Sauf indication contraire, les tampons ne se terminent pas par NUL."

#: ../Doc/c-api/arg.rst:51
msgid ""
"Some formats require a read-only :term:`bytes-like object`, and set a "
"pointer instead of a buffer structure.  They work by checking that the "
"object's :c:member:`PyBufferProcs.bf_releasebuffer` field is ``NULL``, which "
"disallows mutable objects such as :class:`bytearray`."
msgstr ""

#: ../Doc/c-api/arg.rst:58
msgid ""
"For all ``#`` variants of formats (``s#``, ``y#``, etc.), the type of the "
"length argument (int or :c:type:`Py_ssize_t`) is controlled by defining the "
"macro :c:macro:`PY_SSIZE_T_CLEAN` before including :file:`Python.h`.  If the "
"macro was defined, length is a :c:type:`Py_ssize_t` rather than an :c:type:"
"`int`. This behavior will change in a future Python version to only support :"
"c:type:`Py_ssize_t` and drop :c:type:`int` support. It is best to always "
"define :c:macro:`PY_SSIZE_T_CLEAN`."
msgstr ""
"Pour toutes les variantes du marqueur ``#`` (``s#``, ``y#``, etc), le type "
"de l'argument *length* (*int* ou :c:type:`Py_ssize_t`) est contrôlé en "
"définissant la macro :c:macro:`PY_SSIZE_T_CLEAN` avant d'inclure le fichier :"
"file:`Python.h`. Si la macro est définie, la longueur est de type :c:type:"
"`Py_ssize_t` au lieu d'être de type :c:type:`int`. Ce comportement changera "
"dans une future version de Python, qui supportera seulement :c:type:"
"`Py_ssize_t` a la place de :c:type:`int`. Il est préférable de toujours "
"définir :c:macro:`PY_SSIZE_T_CLEAN`."

#: ../Doc/c-api/arg.rst:85
msgid "``s`` (:class:`str`) [const char \\*]"
msgstr "``s`` (:class:`str`) [``const char *``]"

#: ../Doc/c-api/arg.rst:68
msgid ""
"Convert a Unicode object to a C pointer to a character string. A pointer to "
"an existing string is stored in the character pointer variable whose address "
"you pass.  The C string is NUL-terminated. The Python string must not "
"contain embedded null code points; if it does, a :exc:`ValueError` exception "
"is raised. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding. If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""

#: ../Doc/c-api/arg.rst:77
msgid ""
"This format does not accept :term:`bytes-like objects <bytes-like object>`.  "
"If you want to accept filesystem paths and convert them to C character "
"strings, it is preferable to use the ``O&`` format with :c:func:"
"`PyUnicode_FSConverter` as *converter*."
msgstr ""

#: ../Doc/c-api/arg.rst:83 ../Doc/c-api/arg.rst:150
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null code points were "
"encountered in the Python string."
msgstr ""

#: ../Doc/c-api/arg.rst:91
msgid "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"
msgstr "``s*`` (:class:`str` ou :term:`bytes-like object`) [``Py_buffer``]"

#: ../Doc/c-api/arg.rst:88
msgid ""
"This format accepts Unicode objects as well as bytes-like objects. It fills "
"a :c:type:`Py_buffer` structure provided by the caller. In this case the "
"resulting C string may contain embedded NUL bytes. Unicode objects are "
"converted to C strings using ``'utf-8'`` encoding."
msgstr ""

#: ../Doc/c-api/arg.rst:98
msgid ""
"``s#`` (:class:`str`, read-only :term:`bytes-like object`) [const char \\*, "
"int or :c:type:`Py_ssize_t`]"
msgstr ""

#: ../Doc/c-api/arg.rst:94
msgid ""
"Like ``s*``, except that it doesn't accept mutable objects. The result is "
"stored into two C variables, the first one a pointer to a C string, the "
"second one its length. The string may contain embedded null bytes. Unicode "
"objects are converted to C strings using ``'utf-8'`` encoding."
msgstr ""

#: ../Doc/c-api/arg.rst:102 ../Doc/c-api/arg.rst:566
msgid "``z`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``z`` (:class:`str` ou ``None``) [``const char *``]"

#: ../Doc/c-api/arg.rst:101
#, fuzzy
msgid ""
"Like ``s``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``."
msgstr ""
"Comme ``s``, mais l'objet Python peut aussi être ``None``, auquel cas le "
"pointeur C devient *NULL*."

#: ../Doc/c-api/arg.rst:106
msgid ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"
msgstr ""
"``z*`` (:class:`str`, :term:`bytes-like object` ou ``None``) [``Py_buffer``]"

#: ../Doc/c-api/arg.rst:105
#, fuzzy
msgid ""
"Like ``s*``, but the Python object may also be ``None``, in which case the "
"``buf`` member of the :c:type:`Py_buffer` structure is set to ``NULL``."
msgstr ""
"Comme ``u``, mais l'objet Python peut aussi être ``None``, auquel cas le "
"pointeur :c:type:`Py_UNICODE` vaut *NULL*."

#: ../Doc/c-api/arg.rst:110
msgid ""
"``z#`` (:class:`str`, read-only :term:`bytes-like object` or ``None``) "
"[const char \\*, int]"
msgstr ""

#: ../Doc/c-api/arg.rst:109
#, fuzzy
msgid ""
"Like ``s#``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``."
msgstr ""
"Comme ``s#``, mais l'objet Python peut également être ``None``, dans ce cas "
"le pointeur C est définie à *NULL*."

#: ../Doc/c-api/arg.rst:120
msgid "``y`` (read-only :term:`bytes-like object`) [const char \\*]"
msgstr ""

#: ../Doc/c-api/arg.rst:113
msgid ""
"This format converts a bytes-like object to a C pointer to a character "
"string; it does not accept Unicode objects.  The bytes buffer must not "
"contain embedded null bytes; if it does, a :exc:`ValueError` exception is "
"raised."
msgstr ""

#: ../Doc/c-api/arg.rst:118
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null bytes were "
"encountered in the bytes buffer."
msgstr ""

#: ../Doc/c-api/arg.rst:125
msgid "``y*`` (:term:`bytes-like object`) [Py_buffer]"
msgstr "``y*`` (:term:`bytes-like object`) [``Py_buffer``]"

#: ../Doc/c-api/arg.rst:123
msgid ""
"This variant on ``s*`` doesn't accept Unicode objects, only bytes-like "
"objects.  **This is the recommended way to accept binary data.**"
msgstr ""

#: ../Doc/c-api/arg.rst:129
msgid "``y#`` (read-only :term:`bytes-like object`) [const char \\*, int]"
msgstr ""

#: ../Doc/c-api/arg.rst:128
msgid ""
"This variant on ``s#`` doesn't accept Unicode objects, only bytes-like "
"objects."
msgstr ""
"Cette variante de ``s#`` n'accepte pas les objets Unicode, uniquement des "
"objets assimilés à des octets."

#: ../Doc/c-api/arg.rst:134
msgid "``S`` (:class:`bytes`) [PyBytesObject \\*]"
msgstr "``S`` (:class:`bytes`) [``PyBytesObject *``]"

#: ../Doc/c-api/arg.rst:132
msgid ""
"Requires that the Python object is a :class:`bytes` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
"bytes object.  The C variable may also be declared as :c:type:`PyObject\\*`."
msgstr ""

#: ../Doc/c-api/arg.rst:139
msgid "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"
msgstr "``Y`` (:class:`bytearray`) [``PyByteArrayObject *``]"

#: ../Doc/c-api/arg.rst:137
msgid ""
"Requires that the Python object is a :class:`bytearray` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a :"
"class:`bytearray` object. The C variable may also be declared as :c:type:"
"`PyObject\\*`."
msgstr ""

#: ../Doc/c-api/arg.rst:156
msgid "``u`` (:class:`str`) [const Py_UNICODE \\*]"
msgstr "``u`` (:class:`str`) [``const Py_UNICODE *``]"

#: ../Doc/c-api/arg.rst:142
msgid ""
"Convert a Python Unicode object to a C pointer to a NUL-terminated buffer of "
"Unicode characters.  You must pass the address of a :c:type:`Py_UNICODE` "
"pointer variable, which will be filled with the pointer to an existing "
"Unicode buffer.  Please note that the width of a :c:type:`Py_UNICODE` "
"character depends on compilation options (it is either 16 or 32 bits). The "
"Python string must not contain embedded null code points; if it does, a :exc:"
"`ValueError` exception is raised."
msgstr ""

#: ../Doc/c-api/arg.rst:157 ../Doc/c-api/arg.rst:166 ../Doc/c-api/arg.rst:174
#: ../Doc/c-api/arg.rst:182
msgid ""
"Part of the old-style :c:type:`Py_UNICODE` API; please migrate to using :c:"
"func:`PyUnicode_AsWideCharString`."
msgstr ""

#: ../Doc/c-api/arg.rst:165
msgid "``u#`` (:class:`str`) [const Py_UNICODE \\*, int]"
msgstr "``u#`` (:class:`str`) [``const Py_UNICODE *``, ``int``]"

#: ../Doc/c-api/arg.rst:159
msgid ""
"This variant on ``u`` stores into two C variables, the first one a pointer "
"to a Unicode data buffer, the second one its length.  This variant allows "
"null code points."
msgstr ""

#: ../Doc/c-api/arg.rst:173
msgid "``Z`` (:class:`str` or ``None``) [const Py_UNICODE \\*]"
msgstr "``Z`` (:class:`str` ou ``None``) [``const Py_UNICODE *``]"

#: ../Doc/c-api/arg.rst:168
#, fuzzy
msgid ""
"Like ``u``, but the Python object may also be ``None``, in which case the :c:"
"type:`Py_UNICODE` pointer is set to ``NULL``."
msgstr ""
"Comme ``u``, mais l'objet Python peut aussi être ``None``, auquel cas le "
"pointeur :c:type:`Py_UNICODE` vaut *NULL*."

#: ../Doc/c-api/arg.rst:181
msgid "``Z#`` (:class:`str` or ``None``) [const Py_UNICODE \\*, int]"
msgstr "``Z#`` (:class:`str` ou ``None``) [``const Py_UNICODE *``, ``int``]"

#: ../Doc/c-api/arg.rst:176
#, fuzzy
msgid ""
"Like ``u#``, but the Python object may also be ``None``, in which case the :"
"c:type:`Py_UNICODE` pointer is set to ``NULL``."
msgstr ""
"Comme ``u#``, mais l'objet Python peut également être ``None``, auquel cas "
"le pointeur :c:type:`Py_UNICODE` vaut *NULL*."

#: ../Doc/c-api/arg.rst:186
msgid "``U`` (:class:`str`) [PyObject \\*]"
msgstr "``U`` (:class:`str`) [``PyObject *``]"

#: ../Doc/c-api/arg.rst:184
msgid ""
"Requires that the Python object is a Unicode object, without attempting any "
"conversion.  Raises :exc:`TypeError` if the object is not a Unicode object.  "
"The C variable may also be declared as :c:type:`PyObject\\*`."
msgstr ""

#: ../Doc/c-api/arg.rst:192
msgid "``w*`` (read-write :term:`bytes-like object`) [Py_buffer]"
msgstr "``w*`` (lecture-écriture :term:`bytes-like object`) [``Py_buffer``]"

#: ../Doc/c-api/arg.rst:189
msgid ""
"This format accepts any object which implements the read-write buffer "
"interface. It fills a :c:type:`Py_buffer` structure provided by the caller. "
"The buffer may contain embedded null bytes. The caller have to call :c:func:"
"`PyBuffer_Release` when it is done with the buffer."
msgstr ""

#: ../Doc/c-api/arg.rst:209
msgid "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"
msgstr ""

#: ../Doc/c-api/arg.rst:195
msgid ""
"This variant on ``s`` is used for encoding Unicode into a character buffer. "
"It only works for encoded data without embedded NUL bytes."
msgstr ""

#: ../Doc/c-api/arg.rst:198
msgid ""
"This format requires two arguments.  The first is only used as input, and "
"must be a :c:type:`const char\\*` which points to the name of an encoding as "
"a NUL-terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is "
"used. An exception is raised if the named encoding is not known to Python.  "
"The second argument must be a :c:type:`char\\*\\*`; the value of the pointer "
"it references will be set to a buffer with the contents of the argument "
"text. The text will be encoded in the encoding specified by the first "
"argument."
msgstr ""

#: ../Doc/c-api/arg.rst:206
msgid ""
":c:func:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy "
"the encoded data into this buffer and adjust *\\*buffer* to reference the "
"newly allocated storage.  The caller is responsible for calling :c:func:"
"`PyMem_Free` to free the allocated buffer after use."
msgstr ""

#: ../Doc/c-api/arg.rst:214
msgid ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"
msgstr ""

#: ../Doc/c-api/arg.rst:212
msgid ""
"Same as ``es`` except that byte string objects are passed through without "
"recoding them.  Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""

#: ../Doc/c-api/arg.rst:245
msgid ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, int "
"\\*buffer_length]"
msgstr ""

#: ../Doc/c-api/arg.rst:217
msgid ""
"This variant on ``s#`` is used for encoding Unicode into a character buffer. "
"Unlike the ``es`` format, this variant allows input data which contains NUL "
"characters."
msgstr ""

#: ../Doc/c-api/arg.rst:221
msgid ""
"It requires three arguments.  The first is only used as input, and must be "
"a :c:type:`const char\\*` which points to the name of an encoding as a NUL-"
"terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is used. "
"An exception is raised if the named encoding is not known to Python.  The "
"second argument must be a :c:type:`char\\*\\*`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument. "
"The third argument must be a pointer to an integer; the referenced integer "
"will be set to the number of bytes in the output buffer."
msgstr ""

#: ../Doc/c-api/arg.rst:231
msgid "There are two modes of operation:"
msgstr "Il existe deux modes de fonctionnement :"

#: ../Doc/c-api/arg.rst:233
msgid ""
"If *\\*buffer* points a ``NULL`` pointer, the function will allocate a "
"buffer of the needed size, copy the encoded data into this buffer and set *"
"\\*buffer* to reference the newly allocated storage.  The caller is "
"responsible for calling :c:func:`PyMem_Free` to free the allocated buffer "
"after usage."
msgstr ""

#: ../Doc/c-api/arg.rst:238
msgid ""
"If *\\*buffer* points to a non-``NULL`` pointer (an already allocated "
"buffer), :c:func:`PyArg_ParseTuple` will use this location as the buffer and "
"interpret the initial value of *\\*buffer_length* as the buffer size.  It "
"will then copy the encoded data into the buffer and NUL-terminate it.  If "
"the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""

#: ../Doc/c-api/arg.rst:244
msgid ""
"In both cases, *\\*buffer_length* is set to the length of the encoded data "
"without the trailing NUL byte."
msgstr ""
"Dans les deux cas, *\\*buffer_length* est la longueur des données encodées, "
"sans l'octet NUL de fin."

#: ../Doc/c-api/arg.rst:250
msgid ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, int \\*buffer_length]"
msgstr ""

#: ../Doc/c-api/arg.rst:248
msgid ""
"Same as ``es#`` except that byte string objects are passed through without "
"recoding them. Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""

#: ../Doc/c-api/arg.rst:253
msgid "Numbers"
msgstr "Les nombres"

#: ../Doc/c-api/arg.rst:257
msgid "``b`` (:class:`int`) [unsigned char]"
msgstr "``b`` (:class:`int`) [``unsigned char``]"

#: ../Doc/c-api/arg.rst:256
msgid ""
"Convert a nonnegative Python integer to an unsigned tiny int, stored in a C :"
"c:type:`unsigned char`."
msgstr ""
"Convertit un entier Python positif ou nul en un ``unsigned tiny int``, "
"stocké dans un :c:type:`unsigned char` C."

#: ../Doc/c-api/arg.rst:261 ../Doc/c-api/arg.rst:600
msgid "``B`` (:class:`int`) [unsigned char]"
msgstr "``B`` (:class:`int`) [``unsigned char``]"

#: ../Doc/c-api/arg.rst:260
msgid ""
"Convert a Python integer to a tiny int without overflow checking, stored in "
"a C :c:type:`unsigned char`."
msgstr ""
"Convertit un entier Python en un ``tiny int`` sans vérifier le débordement, "
"stocké dans un :c:type:`unsigned char` C."

#: ../Doc/c-api/arg.rst:264 ../Doc/c-api/arg.rst:594
msgid "``h`` (:class:`int`) [short int]"
msgstr "``h`` (:class:`int`) [``short int``]"

#: ../Doc/c-api/arg.rst:264
msgid "Convert a Python integer to a C :c:type:`short int`."
msgstr "Convertit un entier Python en un :c:type:`short int` C."

#: ../Doc/c-api/arg.rst:268 ../Doc/c-api/arg.rst:603
msgid "``H`` (:class:`int`) [unsigned short int]"
msgstr "``H`` (:class:`int`) [``unsigned short int``]"

#: ../Doc/c-api/arg.rst:267
msgid ""
"Convert a Python integer to a C :c:type:`unsigned short int`, without "
"overflow checking."
msgstr ""
"Convertit un entier Python en un :c:type:`unsigned short int` C, sans "
"contrôle de débordement."

#: ../Doc/c-api/arg.rst:271 ../Doc/c-api/arg.rst:588
msgid "``i`` (:class:`int`) [int]"
msgstr "``i`` (:class:`int`) [``int``]"

#: ../Doc/c-api/arg.rst:271
msgid "Convert a Python integer to a plain C :c:type:`int`."
msgstr "Convertit un entier Python en un :c:type:`int` C."

#: ../Doc/c-api/arg.rst:275 ../Doc/c-api/arg.rst:606
msgid "``I`` (:class:`int`) [unsigned int]"
msgstr "``I`` (:class:`int`) [``unsigned int``]"

#: ../Doc/c-api/arg.rst:274
msgid ""
"Convert a Python integer to a C :c:type:`unsigned int`, without overflow "
"checking."
msgstr ""
"Convertit un entier Python en un :c:type:`unsigned int` C, sans contrôle de "
"le débordement."

#: ../Doc/c-api/arg.rst:278 ../Doc/c-api/arg.rst:597
msgid "``l`` (:class:`int`) [long int]"
msgstr "``l`` (:class:`int`) [``long int``]"

#: ../Doc/c-api/arg.rst:278
msgid "Convert a Python integer to a C :c:type:`long int`."
msgstr "Convertit un entier Python en un :c:type:`long int`."

#: ../Doc/c-api/arg.rst:282 ../Doc/c-api/arg.rst:609
msgid "``k`` (:class:`int`) [unsigned long]"
msgstr "``k`` (:class:`int`) [``unsigned long``]"

#: ../Doc/c-api/arg.rst:281
msgid ""
"Convert a Python integer to a C :c:type:`unsigned long` without overflow "
"checking."
msgstr ""
"Convertit un entier Python en un :c:type:`unsigned long` C sans en vérifier "
"le débordement."

#: ../Doc/c-api/arg.rst:285 ../Doc/c-api/arg.rst:612
msgid "``L`` (:class:`int`) [long long]"
msgstr "``L`` (:class:`int`) [``long long``]"

#: ../Doc/c-api/arg.rst:285
#, fuzzy
msgid "Convert a Python integer to a C :c:type:`long long`."
msgstr "Convertit un entier Python en un :c:type:`long int`."

#: ../Doc/c-api/arg.rst:289 ../Doc/c-api/arg.rst:615
msgid "``K`` (:class:`int`) [unsigned long long]"
msgstr "``K`` (:class:`int`) [``unsigned long long``]"

#: ../Doc/c-api/arg.rst:288
#, fuzzy
msgid ""
"Convert a Python integer to a C :c:type:`unsigned long long` without "
"overflow checking."
msgstr ""
"Convertit un entier Python en un :c:type:`unsigned long` C sans en vérifier "
"le débordement."

#: ../Doc/c-api/arg.rst:292 ../Doc/c-api/arg.rst:618
msgid "``n`` (:class:`int`) [Py_ssize_t]"
msgstr "``n`` (:class:`int`) [``Py_ssize_t``]"

#: ../Doc/c-api/arg.rst:292
msgid "Convert a Python integer to a C :c:type:`Py_ssize_t`."
msgstr "Convertit un entier Python en un :c:type:`short int` C."

#: ../Doc/c-api/arg.rst:299
msgid "``c`` (:class:`bytes` or :class:`bytearray` of length 1) [char]"
msgstr "``c`` (:class:`bytes` ou :class:`bytearray` de longueur 1) [``char``]"

#: ../Doc/c-api/arg.rst:295
msgid ""
"Convert a Python byte, represented as a :class:`bytes` or :class:`bytearray` "
"object of length 1, to a C :c:type:`char`."
msgstr ""
"Convertit un *byte* Python, représenté comme un objet :class:`bytes` ou :"
"class:`bytearray` de longueur 1, en un :c:type:`char` C."

#: ../Doc/c-api/arg.rst:298
msgid "Allow :class:`bytearray` objects."
msgstr ""

#: ../Doc/c-api/arg.rst:303 ../Doc/c-api/arg.rst:626
msgid "``C`` (:class:`str` of length 1) [int]"
msgstr "``C`` (:class:`str` de longueur 1) [``int``]"

#: ../Doc/c-api/arg.rst:302
msgid ""
"Convert a Python character, represented as a :class:`str` object of length "
"1, to a C :c:type:`int`."
msgstr ""
"Convertit un caractère Python, représenté comme un objet :class:`str` de "
"longueur 1, en un :c:type:`int` C."

#: ../Doc/c-api/arg.rst:306 ../Doc/c-api/arg.rst:632
msgid "``f`` (:class:`float`) [float]"
msgstr "``f`` (:class:`float`) [``float``]"

#: ../Doc/c-api/arg.rst:306
msgid "Convert a Python floating point number to a C :c:type:`float`."
msgstr "Convertit un nombre flottant Python vers un :c:type:`float`."

#: ../Doc/c-api/arg.rst:309 ../Doc/c-api/arg.rst:629
msgid "``d`` (:class:`float`) [double]"
msgstr "``d`` (:class:`float`) [``double``]"

#: ../Doc/c-api/arg.rst:309
msgid "Convert a Python floating point number to a C :c:type:`double`."
msgstr "Convertit un nombre flottant Python vers un :c:type:`double` C."

#: ../Doc/c-api/arg.rst:312
msgid "``D`` (:class:`complex`) [Py_complex]"
msgstr "``D`` (:class:`complex`) [``Py_complex``]"

#: ../Doc/c-api/arg.rst:312
msgid "Convert a Python complex number to a C :c:type:`Py_complex` structure."
msgstr ""
"Convertit un nombre complexe Python vers une structure :c:type:`Py_complex` "
"C."

#: ../Doc/c-api/arg.rst:315
msgid "Other objects"
msgstr "Autres objets"

#: ../Doc/c-api/arg.rst:320 ../Doc/c-api/arg.rst:643
msgid "``O`` (object) [PyObject \\*]"
msgstr "``O`` (objet) [``PyObject *``]"

#: ../Doc/c-api/arg.rst:318
#, fuzzy
msgid ""
"Store a Python object (without any conversion) in a C object pointer.  The C "
"program thus receives the actual object that was passed.  The object's "
"reference count is not increased.  The pointer stored is not ``NULL``."
msgstr ""
"Stocke un objet Python (sans aucune conversion) en un pointeur sur un objet "
"C. Ainsi, Le programme C reçoit l'objet réel qui a été passé. Le compteur de "
"référence sur l'objet n'est pas incrémenté. Le pointeur stocké n'est pas "
"*NULL*."

#: ../Doc/c-api/arg.rst:327
msgid "``O!`` (object) [*typeobject*, PyObject \\*]"
msgstr "``O!`` (objet) [*typeobject*, ``PyObject *``]"

#: ../Doc/c-api/arg.rst:323
msgid ""
"Store a Python object in a C object pointer.  This is similar to ``O``, but "
"takes two C arguments: the first is the address of a Python type object, the "
"second is the address of the C variable (of type :c:type:`PyObject\\*`) into "
"which the object pointer is stored.  If the Python object does not have the "
"required type, :exc:`TypeError` is raised."
msgstr ""

#: ../Doc/c-api/arg.rst:352 ../Doc/c-api/arg.rst:657
msgid "``O&`` (object) [*converter*, *anything*]"
msgstr "``O&`` (objet) [*converter*, *anything*]"

#: ../Doc/c-api/arg.rst:332
msgid ""
"Convert a Python object to a C variable through a *converter* function.  "
"This takes two arguments: the first is a function, the second is the address "
"of a C variable (of arbitrary type), converted to :c:type:`void \\*`.  The "
"*converter* function in turn is called as follows::"
msgstr ""

#: ../Doc/c-api/arg.rst:339
msgid ""
"where *object* is the Python object to be converted and *address* is the :c:"
"type:`void\\*` argument that was passed to the :c:func:`PyArg_Parse\\*` "
"function. The returned *status* should be ``1`` for a successful conversion "
"and ``0`` if the conversion has failed.  When the conversion fails, the "
"*converter* function should raise an exception and leave the content of "
"*address* unmodified."
msgstr ""

#: ../Doc/c-api/arg.rst:345
msgid ""
"If the *converter* returns ``Py_CLEANUP_SUPPORTED``, it may get called a "
"second time if the argument parsing eventually fails, giving the converter a "
"chance to release any memory that it had already allocated. In this second "
"call, the *object* parameter will be ``NULL``; *address* will have the same "
"value as in the original call."
msgstr ""

#: ../Doc/c-api/arg.rst:351
msgid "``Py_CLEANUP_SUPPORTED`` was added."
msgstr "``Py_CLEANUP_SUPPORTED`` à été ajouté."

#: ../Doc/c-api/arg.rst:361
msgid "``p`` (:class:`bool`) [int]"
msgstr "``p`` (:class:`bool`) [``int``]"

#: ../Doc/c-api/arg.rst:355
msgid ""
"Tests the value passed in for truth (a boolean **p**\\ redicate) and "
"converts the result to its equivalent C true/false integer value. Sets the "
"int to ``1`` if the expression was true and ``0`` if it was false. This "
"accepts any valid Python value.  See :ref:`truth` for more information about "
"how Python tests values for truth."
msgstr ""

#: ../Doc/c-api/arg.rst:366 ../Doc/c-api/arg.rst:660
msgid "``(items)`` (:class:`tuple`) [*matching-items*]"
msgstr "``(items)`` (:class:`tuple`) [*matching-items*]"

#: ../Doc/c-api/arg.rst:364
msgid ""
"The object must be a Python sequence whose length is the number of format "
"units in *items*.  The C arguments must correspond to the individual format "
"units in *items*.  Format units for sequences may be nested."
msgstr ""
"L'objet doit être une séquence Python dont la longueur est le nombre "
"d'unités de formats dans *articles*. Les arguments C doivent correspondre à "
"chaque unité de format particulière dans *articles*. Les unités de formats "
"pour les séquences peuvent être imbriquées."

#: ../Doc/c-api/arg.rst:368
msgid ""
"It is possible to pass \"long\" integers (integers whose value exceeds the "
"platform's :const:`LONG_MAX`) however no proper range checking is done --- "
"the most significant bits are silently truncated when the receiving field is "
"too small to receive the value (actually, the semantics are inherited from "
"downcasts in C --- your mileage may vary)."
msgstr ""

#: ../Doc/c-api/arg.rst:374
msgid ""
"A few other characters have a meaning in a format string.  These may not "
"occur inside nested parentheses.  They are:"
msgstr ""
"Quelques autres caractères ont un sens dans une chaîne de format. On ne doit "
"pas les trouvées dans des parenthèses imbriquées. Ce sont :"

#: ../Doc/c-api/arg.rst:382
msgid "``|``"
msgstr "``|``"

#: ../Doc/c-api/arg.rst:378
msgid ""
"Indicates that the remaining arguments in the Python argument list are "
"optional. The C variables corresponding to optional arguments should be "
"initialized to their default value --- when an optional argument is not "
"specified, :c:func:`PyArg_ParseTuple` does not touch the contents of the "
"corresponding C variable(s)."
msgstr ""

#: ../Doc/c-api/arg.rst:391
msgid "``$``"
msgstr "``$``"

#: ../Doc/c-api/arg.rst:385
msgid ""
":c:func:`PyArg_ParseTupleAndKeywords` only: Indicates that the remaining "
"arguments in the Python argument list are keyword-only.  Currently, all "
"keyword-only arguments must also be optional arguments, so ``|`` must always "
"be specified before ``$`` in the format string."
msgstr ""

#: ../Doc/c-api/arg.rst:396
msgid "``:``"
msgstr ""

#: ../Doc/c-api/arg.rst:394
msgid ""
"The list of format units ends here; the string after the colon is used as "
"the function name in error messages (the \"associated value\" of the "
"exception that :c:func:`PyArg_ParseTuple` raises)."
msgstr ""

#: ../Doc/c-api/arg.rst:401
msgid "``;``"
msgstr ""

#: ../Doc/c-api/arg.rst:399
msgid ""
"The list of format units ends here; the string after the semicolon is used "
"as the error message *instead* of the default error message.  ``:`` and ``;"
"`` mutually exclude each other."
msgstr ""
"La liste des unités de format s'arrête ici ; la chaîne après le point-"
"virgule est utilise comme message d'erreur *au lieu* du message d'erreur par "
"défaut. ``:`` et ``;`` sont mutuellement exclusifs."

#: ../Doc/c-api/arg.rst:403
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr ""
"Notez que n'importe quelles références sur un objet Python qui sont données "
"à l'appelant sont des références *empruntées* ; ne décrémentez pas leur "
"compteur de références !"

#: ../Doc/c-api/arg.rst:406
msgid ""
"Additional arguments passed to these functions must be addresses of "
"variables whose type is determined by the format string; these are used to "
"store values from the input tuple.  There are a few cases, as described in "
"the list of format units above, where these parameters are used as input "
"values; they should match what is specified for the corresponding format "
"unit in that case."
msgstr ""
"Les arguments additionnels qui sont donnés à ces fonctions doivent être des "
"adresses de variables dont le type est déterminé par la chaîne de format. "
"Elles sont utilisées pour stocker les valeurs du n-uplet d'entrée. Il y a "
"quelques cas, comme décrit précédemment dans le liste des unités de formats, "
"où ces paramètres sont utilisés comme valeurs d'entrée. Dans ce cas, ils "
"devraient correspondre à ce qui est spécifié pour l'unité de format "
"correspondante."

#: ../Doc/c-api/arg.rst:412
msgid ""
"For the conversion to succeed, the *arg* object must match the format and "
"the format must be exhausted.  On success, the :c:func:`PyArg_Parse\\*` "
"functions return true, otherwise they return false and raise an appropriate "
"exception. When the :c:func:`PyArg_Parse\\*` functions fail due to "
"conversion failure in one of the format units, the variables at the "
"addresses corresponding to that and the following format units are left "
"untouched."
msgstr ""

#: ../Doc/c-api/arg.rst:421
msgid "API Functions"
msgstr "Fonction de l'API"

#: ../Doc/c-api/arg.rst:425
msgid ""
"Parse the parameters of a function that takes only positional parameters "
"into local variables.  Returns true on success; on failure, it returns false "
"and raises the appropriate exception."
msgstr ""

#: ../Doc/c-api/arg.rst:432
msgid ""
"Identical to :c:func:`PyArg_ParseTuple`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ""

#: ../Doc/c-api/arg.rst:438
msgid ""
"Parse the parameters of a function that takes both positional and keyword "
"parameters into local variables.  The *keywords* argument is a ``NULL``-"
"terminated array of keyword parameter names.  Empty names denote :ref:"
"`positional-only parameters <positional-only_parameter>`. Returns true on "
"success; on failure, it returns false and raises the appropriate exception."
msgstr ""

#: ../Doc/c-api/arg.rst:445
msgid ""
"Added support for :ref:`positional-only parameters <positional-"
"only_parameter>`."
msgstr ""

#: ../Doc/c-api/arg.rst:452
msgid ""
"Identical to :c:func:`PyArg_ParseTupleAndKeywords`, except that it accepts a "
"va_list rather than a variable number of arguments."
msgstr ""

#: ../Doc/c-api/arg.rst:458
msgid ""
"Ensure that the keys in the keywords argument dictionary are strings.  This "
"is only needed if :c:func:`PyArg_ParseTupleAndKeywords` is not used, since "
"the latter already does this check."
msgstr ""

#: ../Doc/c-api/arg.rst:468
msgid ""
"Function used to deconstruct the argument lists of \"old-style\" functions "
"--- these are functions which use the :const:`METH_OLDARGS` parameter "
"parsing method, which has been removed in Python 3.  This is not recommended "
"for use in parameter parsing in new code, and most code in the standard "
"interpreter has been modified to no longer use this for that purpose.  It "
"does remain a convenient way to decompose other tuples, however, and may "
"continue to be used for that purpose."
msgstr ""

#: ../Doc/c-api/arg.rst:479
msgid ""
"A simpler form of parameter retrieval which does not use a format string to "
"specify the types of the arguments.  Functions which use this method to "
"retrieve their parameters should be declared as :const:`METH_VARARGS` in "
"function or method tables.  The tuple containing the actual parameters "
"should be passed as *args*; it must actually be a tuple.  The length of the "
"tuple must be at least *min* and no more than *max*; *min* and *max* may be "
"equal.  Additional arguments must be passed to the function, each of which "
"should be a pointer to a :c:type:`PyObject\\*` variable; these will be "
"filled in with the values from *args*; they will contain borrowed "
"references.  The variables which correspond to optional parameters not given "
"by *args* will not be filled in; these should be initialized by the caller. "
"This function returns true on success and false if *args* is not a tuple or "
"contains the wrong number of elements; an exception will be set if there was "
"a failure."
msgstr ""

#: ../Doc/c-api/arg.rst:493
msgid ""
"This is an example of the use of this function, taken from the sources for "
"the :mod:`_weakref` helper module for weak references::"
msgstr ""

#: ../Doc/c-api/arg.rst:509
msgid ""
"The call to :c:func:`PyArg_UnpackTuple` in this example is entirely "
"equivalent to this call to :c:func:`PyArg_ParseTuple`::"
msgstr ""

#: ../Doc/c-api/arg.rst:517
msgid "Building values"
msgstr "Construction des valeurs"

#: ../Doc/c-api/arg.rst:521
msgid ""
"Create a new value based on a format string similar to those accepted by "
"the :c:func:`PyArg_Parse\\*` family of functions and a sequence of values.  "
"Returns the value or ``NULL`` in the case of an error; an exception will be "
"raised if ``NULL`` is returned."
msgstr ""

#: ../Doc/c-api/arg.rst:526
msgid ""
":c:func:`Py_BuildValue` does not always build a tuple.  It builds a tuple "
"only if its format string contains two or more format units.  If the format "
"string is empty, it returns ``None``; if it contains exactly one format "
"unit, it returns whatever object is described by that format unit.  To force "
"it to return a tuple of size 0 or one, parenthesize the format string."
msgstr ""

#: ../Doc/c-api/arg.rst:532
msgid ""
"When memory buffers are passed as parameters to supply data to build "
"objects, as for the ``s`` and ``s#`` formats, the required data is copied.  "
"Buffers provided by the caller are never referenced by the objects created "
"by :c:func:`Py_BuildValue`.  In other words, if your code invokes :c:func:"
"`malloc` and passes the allocated memory to :c:func:`Py_BuildValue`, your "
"code is responsible for calling :c:func:`free` for that memory once :c:func:"
"`Py_BuildValue` returns."
msgstr ""

#: ../Doc/c-api/arg.rst:540
msgid ""
"In the following description, the quoted form is the format unit; the entry "
"in (round) parentheses is the Python object type that the format unit will "
"return; and the entry in [square] brackets is the type of the C value(s) to "
"be passed."
msgstr ""

#: ../Doc/c-api/arg.rst:544
msgid ""
"The characters space, tab, colon and comma are ignored in format strings "
"(but not within format units such as ``s#``).  This can be used to make long "
"format strings a tad more readable."
msgstr ""

#: ../Doc/c-api/arg.rst:550
msgid "``s`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``s`` (:class:`str` ou ``None``) [``const char *``]"

#: ../Doc/c-api/arg.rst:549
msgid ""
"Convert a null-terminated C string to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, ``None`` is used."
msgstr ""

#: ../Doc/c-api/arg.rst:555
msgid "``s#`` (:class:`str` or ``None``) [const char \\*, int]"
msgstr "``s#`` (:class:`str` ou ``None``) [``const char *``, ``int``]"

#: ../Doc/c-api/arg.rst:553
msgid ""
"Convert a C string and its length to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""

#: ../Doc/c-api/arg.rst:559
msgid "``y`` (:class:`bytes`) [const char \\*]"
msgstr "``y`` (:class:`bytes`) [``const char *``]"

#: ../Doc/c-api/arg.rst:558
msgid ""
"This converts a C string to a Python :class:`bytes` object.  If the C string "
"pointer is ``NULL``, ``None`` is returned."
msgstr ""

#: ../Doc/c-api/arg.rst:563
msgid "``y#`` (:class:`bytes`) [const char \\*, int]"
msgstr "``y#`` (:class:`bytes`) [``const char *, int``]"

#: ../Doc/c-api/arg.rst:562
msgid ""
"This converts a C string and its lengths to a Python object.  If the C "
"string pointer is ``NULL``, ``None`` is returned."
msgstr ""

#: ../Doc/c-api/arg.rst:566 ../Doc/c-api/arg.rst:582
msgid "Same as ``s``."
msgstr ""

#: ../Doc/c-api/arg.rst:569
msgid "``z#`` (:class:`str` or ``None``) [const char \\*, int]"
msgstr "``z#`` (:class:`str` ou ``None``) [``const char *``, ``int``]"

#: ../Doc/c-api/arg.rst:569 ../Doc/c-api/arg.rst:585
msgid "Same as ``s#``."
msgstr ""

#: ../Doc/c-api/arg.rst:574
msgid "``u`` (:class:`str`) [const wchar_t \\*]"
msgstr "``u`` (:class:`str`) [``const wchar_t *``]"

#: ../Doc/c-api/arg.rst:572
msgid ""
"Convert a null-terminated :c:type:`wchar_t` buffer of Unicode (UTF-16 or "
"UCS-4) data to a Python Unicode object.  If the Unicode buffer pointer is "
"``NULL``, ``None`` is returned."
msgstr ""

#: ../Doc/c-api/arg.rst:579
msgid "``u#`` (:class:`str`) [const wchar_t \\*, int]"
msgstr "``u#`` (:class:`str`) [``const wchar_t *``, ``int``]"

#: ../Doc/c-api/arg.rst:577
msgid ""
"Convert a Unicode (UTF-16 or UCS-4) data buffer and its length to a Python "
"Unicode object.   If the Unicode buffer pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""

#: ../Doc/c-api/arg.rst:582
msgid "``U`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``U`` (:class:`str` ou ``None``) [``const char *``]"

#: ../Doc/c-api/arg.rst:585
msgid "``U#`` (:class:`str` or ``None``) [const char \\*, int]"
msgstr "``U#`` (:class:`str` ou ``None``) [``const char *``, ``int``]"

#: ../Doc/c-api/arg.rst:588
#, fuzzy
msgid "Convert a plain C :c:type:`int` to a Python integer object."
msgstr "Convertit un :c:type:`long int` en un *int* Python."

#: ../Doc/c-api/arg.rst:591
msgid "``b`` (:class:`int`) [char]"
msgstr "``b`` (:class:`int`) [``char``]"

#: ../Doc/c-api/arg.rst:591
msgid "Convert a plain C :c:type:`char` to a Python integer object."
msgstr ""

#: ../Doc/c-api/arg.rst:594
msgid "Convert a plain C :c:type:`short int` to a Python integer object."
msgstr ""

#: ../Doc/c-api/arg.rst:597
msgid "Convert a C :c:type:`long int` to a Python integer object."
msgstr "Convertit un :c:type:`long int` en un *int* Python."

#: ../Doc/c-api/arg.rst:600
msgid "Convert a C :c:type:`unsigned char` to a Python integer object."
msgstr ""

#: ../Doc/c-api/arg.rst:603
msgid "Convert a C :c:type:`unsigned short int` to a Python integer object."
msgstr ""

#: ../Doc/c-api/arg.rst:606
#, fuzzy
msgid "Convert a C :c:type:`unsigned int` to a Python integer object."
msgstr "Convertit un :c:type:`long int` en un *int* Python."

#: ../Doc/c-api/arg.rst:609
msgid "Convert a C :c:type:`unsigned long` to a Python integer object."
msgstr ""

#: ../Doc/c-api/arg.rst:612
#, fuzzy
msgid "Convert a C :c:type:`long long` to a Python integer object."
msgstr "Convertit un :c:type:`long int` en un *int* Python."

#: ../Doc/c-api/arg.rst:615
msgid "Convert a C :c:type:`unsigned long long` to a Python integer object."
msgstr ""

#: ../Doc/c-api/arg.rst:618
msgid "Convert a C :c:type:`Py_ssize_t` to a Python integer."
msgstr ""

#: ../Doc/c-api/arg.rst:622
msgid "``c`` (:class:`bytes` of length 1) [char]"
msgstr "``c`` (:class:`bytes` de taille 1) [``char``]"

#: ../Doc/c-api/arg.rst:621
msgid ""
"Convert a C :c:type:`int` representing a byte to a Python :class:`bytes` "
"object of length 1."
msgstr ""

#: ../Doc/c-api/arg.rst:625
msgid ""
"Convert a C :c:type:`int` representing a character to Python :class:`str` "
"object of length 1."
msgstr ""

#: ../Doc/c-api/arg.rst:629
msgid "Convert a C :c:type:`double` to a Python floating point number."
msgstr ""

#: ../Doc/c-api/arg.rst:632
msgid "Convert a C :c:type:`float` to a Python floating point number."
msgstr ""

#: ../Doc/c-api/arg.rst:635
msgid "``D`` (:class:`complex`) [Py_complex \\*]"
msgstr "``D`` (:class:`complex`) [``Py_complex *``]"

#: ../Doc/c-api/arg.rst:635
msgid "Convert a C :c:type:`Py_complex` structure to a Python complex number."
msgstr ""

#: ../Doc/c-api/arg.rst:638
msgid ""
"Pass a Python object untouched (except for its reference count, which is "
"incremented by one).  If the object passed in is a ``NULL`` pointer, it is "
"assumed that this was caused because the call producing the argument found "
"an error and set an exception. Therefore, :c:func:`Py_BuildValue` will "
"return ``NULL`` but won't raise an exception.  If no exception has been "
"raised yet, :exc:`SystemError` is set."
msgstr ""

#: ../Doc/c-api/arg.rst:646
msgid "``S`` (object) [PyObject \\*]"
msgstr "``S`` (objet) [``PyObject *``]"

#: ../Doc/c-api/arg.rst:646
msgid "Same as ``O``."
msgstr ""

#: ../Doc/c-api/arg.rst:651
msgid "``N`` (object) [PyObject \\*]"
msgstr "``N`` (objet) [``PyObject *``]"

#: ../Doc/c-api/arg.rst:649
msgid ""
"Same as ``O``, except it doesn't increment the reference count on the "
"object. Useful when the object is created by a call to an object constructor "
"in the argument list."
msgstr ""

#: ../Doc/c-api/arg.rst:654
msgid ""
"Convert *anything* to a Python object through a *converter* function.  The "
"function is called with *anything* (which should be compatible with :c:type:"
"`void \\*`) as its argument and should return a \"new\" Python object, or "
"``NULL`` if an error occurred."
msgstr ""

#: ../Doc/c-api/arg.rst:660
msgid ""
"Convert a sequence of C values to a Python tuple with the same number of "
"items."
msgstr ""

#: ../Doc/c-api/arg.rst:663
msgid "``[items]`` (:class:`list`) [*matching-items*]"
msgstr "``[items]`` (:class:`list`) [*matching-items*]"

#: ../Doc/c-api/arg.rst:663
msgid ""
"Convert a sequence of C values to a Python list with the same number of "
"items."
msgstr ""

#: ../Doc/c-api/arg.rst:668
msgid "``{items}`` (:class:`dict`) [*matching-items*]"
msgstr "``{items}`` (:class:`dict`) [*matching-items*]"

#: ../Doc/c-api/arg.rst:666
msgid ""
"Convert a sequence of C values to a Python dictionary.  Each pair of "
"consecutive C values adds one item to the dictionary, serving as key and "
"value, respectively."
msgstr ""

#: ../Doc/c-api/arg.rst:670
msgid ""
"If there is an error in the format string, the :exc:`SystemError` exception "
"is set and ``NULL`` returned."
msgstr ""

#: ../Doc/c-api/arg.rst:675
msgid ""
"Identical to :c:func:`Py_BuildValue`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ""

#~ msgid "``s`` (:class:`str` or ``None``) [char \\*]"
#~ msgstr "``s`` (:class:`str` ou ``None``) [char \\*]"

#~ msgid "``z`` (:class:`str` or ``None``) [char \\*]"
#~ msgstr "``z`` (:class:`str` ou ``None``) [char \\*]"

#~ msgid "``u`` (:class:`str`) [wchar_t \\*]"
#~ msgstr "``u`` (:class:`str`) [wchar_t \\*]"

#~ msgid "``U`` (:class:`str` or ``None``) [char \\*]"
#~ msgstr "``U`` (:class:`str` ou ``None``) [char \\*]"
