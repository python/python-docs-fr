# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-18 15:46+0200\n"
"PO-Revision-Date: 2022-10-18 16:05+0200\n"
"Last-Translator: Jean Abou Samra <jean@abou-samra.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.1\n"

#: library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` — Sérialisation d'objets Python"

#: library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**Code source :** :source:`Lib/pickle.py`"

#: library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a :"
"term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"Le module :mod:`pickle` implémente des protocoles binaires de sérialisation "
"et dé-sérialisation d'objets Python. La sérialisation est le procédé par "
"lequel une hiérarchie d'objets Python est convertie en flux d'octets. La "
"désérialisation est l'opération inverse, par laquelle un flux d'octets (à "
"partir d'un :term:`binary file` ou :term:`bytes-like object`) est converti "
"en hiérarchie d'objets. Sérialisation (et *désérialisation*) sont aussi "
"connus sous les termes de *pickling*, de \"*marshalling*\" [#]_ ou encore de "
"\"*flattening*\"."

#: library/pickle.rst:33
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr ""
"Le module ``pickle`` **n'est pas sécurisé**. Ne désérialisez des objets qu'à "
"partir de sources fiables."

#: library/pickle.rst:35
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come "
"from an untrusted source, or that could have been tampered with."
msgstr ""
"Il est possible de produire des données binaires qui **exécutent du code "
"arbitraire lors de leur désérialisation**. Ne désérialisez jamais des "
"données provenant d'une source non fiable, ou qui pourraient avoir été "
"modifiées."

#: library/pickle.rst:39
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not "
"been tampered with."
msgstr ""
"Pensez au module :mod:`hmac` pour signer des données afin de s'assurer "
"qu'elles n'ont pas été modifiées."

#: library/pickle.rst:42
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"Des formats de sérialisation plus sûrs, comme :mod:`json`, peuvent se "
"révéler plus adaptés si vous travaillez sur des données qui ne sont pas "
"fiables. Voir :ref:`comparison-with-json`."

#: library/pickle.rst:47
msgid "Relationship to other Python modules"
msgstr "Relations aux autres modules Python"

#: library/pickle.rst:50
msgid "Comparison with ``marshal``"
msgstr "Comparaison avec ``marshal``"

#: library/pickle.rst:52
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""
"Python possède un module de bas niveau en sérialisation appelé :mod:"
"`marshal`, mais en général il est préférable d'utiliser :mod:`pickle` pour "
"sérialiser des objets Python. :mod:`marshal` existe principalement pour "
"gérer les fichiers Python en :file:`.pyc`."

#: library/pickle.rst:57
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""
"Le module :mod:`pickle` diffère du module :mod:`marshal` sur plusieurs "
"aspects :"

#: library/pickle.rst:59
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
"Le module :mod:`pickle` garde la trace des objets qu'il a déjà sérialisés, "
"pour faire en sorte que les prochaines références à cet objet ne soient pas "
"sérialisées à nouveau. :mod:`marshal` ne le fait pas."

#: library/pickle.rst:63
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"Ça a des implications sur les objets partagés et les objets récursifs. Les "
"objets récursifs sont des objets qui contiennent des références à eux-mêmes. "
"Ceux-ci ne sont pas gérées par marshal : lui donner un objet récursif va le "
"faire planter. Un objet est partagé lorsque que plusieurs références "
"pointent dessus, depuis différents endroits dans la hiérarchie sérialisée. "
"Le module :mod:`pickle` repère ces partages et ne stocke ces objets qu'une "
"seule fois. Les objets partagés restent ainsi partagés, ce qui peut être "
"très important pour les objets muables."

#: library/pickle.rst:72
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` ne peut être utilisé pour la sérialisation et l'instanciation "
"de classes définies par les utilisateurs. :mod:`pickle` peut sauvegarder et "
"restaurer les instances de classes de manière transparente. Cependant la "
"définition de classe doit être importable et lancée dans le même module et "
"de la même manière que lors de son importation."

#: library/pickle.rst:77
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type "
"differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
"Aucune garantie n'est offerte sur la portabilité du format :mod:`marshal` "
"entre différentes versions de Python. Sa fonction première étant la gestion "
"des fichiers :file:`.pyc`, les développeurs se réservent le droit de changer "
"le format de sérialisation de manière non-rétrocompatible si besoin était. "
"Il est garanti que le format :mod:`pickle` restera compatible avec les "
"versions futures de Python, pourvu que vous choisissiez un protocole de "
"sérialisation adapté. De plus, il masque les différences entre les types "
"Python 2 et Python 3, pour le cas où il s'agit de désérialiser en Python 3 "
"des données sérialisées en Python 2."

#: library/pickle.rst:90
msgid "Comparison with ``json``"
msgstr "Comparaison avec ``json``"

#: library/pickle.rst:92
#, fuzzy
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"
msgstr ""
"Il existe des différences fondamentales entre les protocoles de "
"sérialisation définis par ce module et le format `JSON (JavaScript Object "
"Notation) <http://json.org>`_ :"

#: library/pickle.rst:95
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"*pickle* est un format binaire, tandis que JSON est un format textuel "
"(constitué de caractères Unicode et généralement encodé en UTF-8) ;"

#: library/pickle.rst:99
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON peut être lu par une personne, contrairement à *pickle* ;"

#: library/pickle.rst:101
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr ""
"JSON offre l'interopérabilité avec de nombreux outils en dehors de "
"l'écosystème Python, alors que *pickle* est propre à Python ;"

#: library/pickle.rst:104
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing :ref:"
"`specific object APIs <pickle-inst>`);"
msgstr ""
"Par défaut, JSON n'est capable de sérialiser qu'un nombre limité de types "
"natifs Python, et ne prend pas en charge les classes définies par "
"l'utilisateur. Le format *pickle* peut représenter une multitude de types "
"d'objets, dont beaucoup automatiquement, grâce à une utilisation fine des "
"possibilités d'introspection de Python ; on peut traiter les cas les plus "
"complexes en implémentant des :ref:`méthodes de sérialisation propres à une "
"classe <pickle-inst>` ;"

#: library/pickle.rst:110
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr ""
"Contrairement à *pickle*, la désérialisation de données JSON n'ouvre pas en "
"soi une vulnérabilité à l'exécution de code arbitraire."

#: library/pickle.rst:114
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ""
"Le module :mod:`json` de la bibliothèque standard permet la sérialisation et "
"désérialisation au format JSON."

#: library/pickle.rst:121
msgid "Data stream format"
msgstr "Format du flux de données"

#: library/pickle.rst:126
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON or XDR (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""
"Le format de données employé par :mod:`pickle` est propre à Python, avec "
"l'avantage qu'aucune restriction n'est imposée par des standards externes "
"comme JSON ou XDR (qui ne peuvent pas représenter le partage de références). "
"Cependant, cela signifie que des programmes écrits en d'autres langages que "
"Python peuvent échouer à reconstituer les objets sérialisés."

#: library/pickle.rst:131
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"Le format binaire :mod:`pickle` est, par défaut, une représentation assez "
"compacte des objets. Il est possible de :doc:`compresser <archiving>` "
"efficacement les données sérialisées."

#: library/pickle.rst:135
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
"Le module :mod:`pickletools` contient des outils servant à analyser les flux "
"de données générés par :mod:`pickle`. Le code source de :mod:`pickletools` "
"contient des commentaires détaillés sur les *opcodes* employés par les "
"protocoles *pickle*."

#: library/pickle.rst:139
msgid ""
"There are currently 6 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""
"Il existe actuellement 6 protocoles différents pour la sérialisation. Les "
"protocoles portant les numéros les plus grands sont les derniers ajoutés, et "
"nécessitent en conséquence des versions de Python plus récentes."

#: library/pickle.rst:143
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr ""
"Le protocole 0 est le format originel, humainement lisible. Il est "
"rétrocompatible avec les versions les plus anciennes de Python."

#: library/pickle.rst:146
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""
"Le protocole 1 est un ancien format binaire, aussi compatible avec les "
"versions anciennes."

#: library/pickle.rst:149
#, fuzzy
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style classes <new-style class>`.  Refer "
"to :pep:`307` for information about improvements brought by protocol 2."
msgstr ""
"Le protocole 2, introduit en Python 2.3, offre une sérialisation bien plus "
"efficace des :term:`nouvelles classes <new-style class>`. Voir la :pep:`307` "
"au sujet des améliorations apportées par ce protocole."

#: library/pickle.rst:153
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for :"
"class:`bytes` objects and cannot be unpickled by Python 2.x.  This was the "
"default protocol in Python 3.0--3.7."
msgstr ""
"Le protocole 3 a été introduit en Python 3.0. Il gère les objets :class:"
"`bytes`, et ne permet pas la désérialisation par Python 2.x. Il fut le "
"protocole par défaut de Python 3.0 à Python 3.7."

#: library/pickle.rst:157
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  It is the default protocol starting with Python 3.8. Refer "
"to :pep:`3154` for information about improvements brought by protocol 4."
msgstr ""
"Le protocole 4 est apparu en Python 3.4. Il prend en charge les objets de "
"très grande taille ainsi que la sérialisation d'une plus grande variété "
"d'objets, et optimise le format. Il est le protocole par défaut depuis "
"Python 3.8. Voir la :pep:`3154` pour plus d'informations sur les "
"améliorations apportées par le protocole 4."

#: library/pickle.rst:163
msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-band "
"data and speedup for in-band data.  Refer to :pep:`574` for information "
"about improvements brought by protocol 5."
msgstr ""
"Le protocole 5 a été ajouté en Python 3.8 afin de permettre le transfert des "
"données en marge de la sérialisation elle-même. Il a également accéléré les "
"opérations sur les données à sérialiser. Reportez-vous à la :pep:`574` pour "
"les détails relatifs aux améliorations apportées par le protocole 5."

#: library/pickle.rst:168
msgid ""
"Serialization is a more primitive notion than persistence; although :mod:"
"`pickle` reads and writes file objects, it does not handle the issue of "
"naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"La sérialisation est un problème plus simple que la persistance des données "
"en général. Le module :mod:`pickle` lit et écrit des objets fichiers-"
"compatibles, mais ne s'occupe pas du problème de donner un nom à des objets "
"persistants, ni de gérer l'accès par différents processus en parallèle à ces "
"objets. :mod:`pickle` se contente de transformer des objets complexes en "
"flux d'octets, et lire ces flux d'octets par la suite pour reconstruire des "
"objets avec la même structure. Si l'on peut bien sûr écrire les flux "
"d'octets dans un fichier, rien n'empêche de les transférer à travers un "
"réseau, ou bien de les stocker dans une base de données. Voir le module :mod:"
"`shelve` pour une interface simple qui sérialise et désérialise les objets "
"dans des bases de données de style DBM."

#: library/pickle.rst:181
msgid "Module Interface"
msgstr "Interface du module"

#: library/pickle.rst:183
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the :func:"
"`loads` function. However, if you want more control over serialization and "
"de-serialization, you can create a :class:`Pickler` or an :class:`Unpickler` "
"object, respectively."
msgstr ""
"Pour sérialiser un objet, contenant éventuellement d'autres objets, appelez "
"tout simplement la fonction :func:`dumps`. La fonction :func:`loads`, quant "
"à elle, désérialise un flux de données. Pour un contrôle plus fin des "
"opérations de sérialisation ou désérialisation, créez un objet :class:"
"`Pickler` ou :class:`Unpickler`."

#: library/pickle.rst:188
msgid "The :mod:`pickle` module provides the following constants:"
msgstr "Le module :mod:`pickle` définit les constantes suivantes :"

#: library/pickle.rst:193
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions :"
"func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"Entier qui donne la version du :ref:`protocole <pickle-protocols>` le plus "
"récent qui soit disponible. Ce nombre peut être passé comme paramètre "
"*protocol* aux fonctions :func:`dump` et :func:`dumps` ainsi qu'au "
"constructeur de la classe :class:`Pickler`."

#: library/pickle.rst:200
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 4, first introduced in Python 3.4 and incompatible with previous "
"versions."
msgstr ""
"Entier qui donne la version du :ref:`protocole <pickle-protocols>` employé "
"par défaut pour la sérialisation. Il peut être moindre que :data:"
"`HIGHEST_PROTOCOL`. La valeur actuelle est 4, sachant que le protocole "
"correspondant a été introduit en Python 3.4 et n'est pas compatible avec les "
"versions antérieures."

#: library/pickle.rst:207
msgid "The default protocol is 3."
msgstr "Le protocole par défaut est devenu le protocole 3."

#: library/pickle.rst:211
msgid "The default protocol is 4."
msgstr "Le protocole par défaut est devenu le protocole 4."

#: library/pickle.rst:213
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""
"Le module :mod:`pickle` contient quelques fonctions pour faciliter la "
"sérialisation."

#: library/pickle.rst:218
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"Écrit la représentation sérialisée de l'objet *obj* dans l'\\ :term:`objet "
"fichier-compatible <file object>` *file*, qui doit être ouvert. Ceci est "
"l'équivalent de ``Pickle(file, protocol).dump(obj)``."

#: library/pickle.rst:222
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""
"Les arguments *file*, *protocol*, *fix_imports* et *buffer_callback* sont "
"identiques à ceux du constructeur de la classe :class:`Pickler`."

#: library/pickle.rst:236 library/pickle.rst:328
msgid "The *buffer_callback* argument was added."
msgstr "ajout de l'argument *buffer_callback*."

#: library/pickle.rst:230
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""
"Renvoie la représentation sérialisée de *obj* sous forme de :class:`bytes`, "
"au lieu de l'écrire dans un fichier."

#: library/pickle.rst:233
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""
"Les arguments *protocol*, *fix_imports* et *buffer_callback* sont identiques "
"à ceux du constructeur de la classe :class:`Pickler`."

#: library/pickle.rst:241
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"Charge la représentation sérialisée d'un objet depuis l'\\ :term:`objet "
"fichier-compatible <file object>` ouvert *file*, et renvoie l'objet "
"reconstitué obtenu. Ceci est l'équivalent de ``Unpickler(file).load()``."

#: library/pickle.rst:260
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr ""
"La version du protocole utilisée pour la sérialisation est détectée "
"automatiquement, d'où l'absence d'un argument. Les octets situés après la "
"représentation sérialisée de l'objet sont ignorés."

#: library/pickle.rst:249
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Les arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* et "
"*buffers* sont identiques à ceux du constructeur de la classe :class:"
"`Unpickler`."

#: library/pickle.rst:267 library/pickle.rst:429
msgid "The *buffers* argument was added."
msgstr "Ajout de l'argument *buffers*."

#: library/pickle.rst:257
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"Renvoie l'objet reconstitué à partir de la représentation sérialisée *data*, "
"qui doit être fournie sous la forme d'un :term:`bytes-like object`."

#: library/pickle.rst:264
#, fuzzy
msgid ""
"Arguments *fix_imports*, *encoding*, *errors*, *strict* and *buffers* have "
"the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Les arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* et "
"*buffers* sont identiques à ceux du constructeur de la classe :class:"
"`Unpickler`."

#: library/pickle.rst:271
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr "Le module :mod:`pickle` définit trois types d'exceptions :"

#: library/pickle.rst:275
msgid ""
"Common base class for the other pickling exceptions.  It inherits :exc:"
"`Exception`."
msgstr ""
"Classe mère commune aux autres exceptions de sérialisation. Elle hérite de :"
"exc:`Exception`."

#: library/pickle.rst:280
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ""
"Exception levée lorsqu'un objet impossible à sérialiser est rencontré par "
"un :class:`Pickler`. Elle hérite de :exc:`PickleError`."

#: library/pickle.rst:283
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""
"Lisez :ref:`pickle-picklable` pour en savoir plus sur les types d'objets qui "
"peuvent être sérialisés."

#: library/pickle.rst:288
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""
"Exception levée lorsqu'un flux binaire ne peut pas être désérialisé, par "
"exemple s'il est corrompu ou en cas de violation de la sécurité. Elle hérite "
"de :exc:`PickleError`."

#: library/pickle.rst:291
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"Veuillez noter que d'autres exceptions peuvent être levées durant la "
"désérialisation, comme ``AttributeError``, ``EOFError``, ``ImportError`` et "
"``IndexError`` (liste non-exhaustive)."

#: library/pickle.rst:296
msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, :class:"
"`Unpickler` and :class:`PickleBuffer`:"
msgstr ""
"Le module :mod:`pickle` exporte trois classes : :class:`Pickler`, :class:"
"`Unpickler` et :class:`PickleBuffer`."

#: library/pickle.rst:301
msgid "This takes a binary file for writing a pickle data stream."
msgstr ""
"Classe d'objets qui implémentent la sérialisation vers un flux binaire."

#: library/pickle.rst:303
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"L'argument optionnel *protocol* détermine la version du protocole de "
"sérialisation à employer, entre 0 et :data:`HIGHEST_PROTOCOL`. La valeur par "
"défaut est celle de :data:`DEFAULT_PROTOCOL`. Avec un nombre strictement "
"négatif, c'est :data:`HIGHEST_PROTOCOL` qui est utilisé."

#: library/pickle.rst:308
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"L'argument *file* peut être un fichier sur disque ouvert en mode binaire "
"pour l'écriture, une instance de la classe :class:`io.BytesIO`, ou plus "
"généralement un objet quelconque qui possède une méthode ``write()`` "
"acceptant d'être appelée sur un argument unique de type ``bytes``."

#: library/pickle.rst:313
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""
"Si *fix_imports* est vrai et *protocol* est inférieur ou égal à 2, les noms "
"des modules sont reliés par *pickle* aux anciens noms qui avaient cours en "
"Python 2, afin que le flux sérialisé soit lisible aussi bien par Python 2 "
"que Python 3."

#: library/pickle.rst:317
msgid ""
"If *buffer_callback* is None (the default), buffer views are serialized into "
"*file* as part of the pickle stream."
msgstr ""
"Si *buffer_callback* vaut ``None`` (comme par défaut), les vues de tampon "
"sont sérialisées dans *file* avec le reste du flux."

#: library/pickle.rst:320
msgid ""
"If *buffer_callback* is not None, then it can be called any number of times "
"with a buffer view.  If the callback returns a false value (such as None), "
"the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise the buffer is "
"serialized in-band, i.e. inside the pickle stream."
msgstr ""
"Dans le cas où le *buffer_callback* n'est pas ``None``, il doit pouvoir être "
"appelé un nombre quelconque de fois avec une vue d'un tampon. S'il renvoie "
"une valeur évaluée comme fausse (telle que ``None``), le tampon est "
"considéré en marge de la sérialisation (ou « :ref:`hors-bande <pickle-"
"oob>` »), sinon il est sérialisé dans le flux binaire."

#: library/pickle.rst:325
msgid ""
"It is an error if *buffer_callback* is not None and *protocol* is None or "
"smaller than 5."
msgstr ""
"Une erreur se produit si *buffer_callback* vaut autre chose que ``None`` et "
"*protocol* est 4 ou inférieur, ou ``None``."

#: library/pickle.rst:333
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""
"Écrit la représentation sérialisée de l'objet *obj* dans le fichier ouvert "
"passé au constructeur."

#: library/pickle.rst:338
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""
"Ne fait rien par défaut. Cette méthode est destinée à être implémentée par "
"une classe fille."

#: library/pickle.rst:340
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
"Si :meth:`persistent_id` renvoie ``None``, *obj* est sérialisé normalement. "
"Toute autre valeur est reprise par le :class:`Pickler` comme ID persistant "
"pour *obj*. Le sens de cet ID persistant doit être défini par :meth:"
"`Unpickler.persistent_load`. Veuillez noter que la valeur renvoyée par :meth:"
"`persistent_id` ne peut pas porter elle-même d'ID persistant."

#: library/pickle.rst:447
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr "La section :ref:`pickle-persistent` donne des détails et exemples."

#: library/pickle.rst:350
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""
"La table de distribution d'un sérialiseur est un tableau associatif dont les "
"clés sont des classes et les valeurs, des fonctions de réduction. La manière "
"la plus directe de déclarer une fonction de réduction est la fonction :func:"
"`copyreg.pickle`. Une fonction de réduction prend un unique argument, qui "
"doit être de la classe en question, et obéit à la même interface qu'une "
"méthode :meth:`__reduce__`."

#: library/pickle.rst:358
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the :"
"mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a :attr:"
"`dispatch_table` attribute then this will be used as the default dispatch "
"table for instances of that class."
msgstr ""
"Lorsqu'un sérialiseur ne possède pas l'attribut :attr:`dispatch_table`, "
"comme c'est le cas par défaut, il utilise le tableau global du module :mod:"
"`copyreg`. Afin de personnaliser l'opération de sérialisation pour un "
"sérialiseur particulier, on peut affecter à son attribut :attr:"
"`dispatch_table` un objet compatible avec les dictionnaires. Une autre "
"possibilité est de définir l'attribut :attr:`dispatch_table` dans une classe "
"fille de :class:`Pickler`. Sa valeur sera alors utilisée pour toutes les "
"instances de cette classe fille."

#: library/pickle.rst:367
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "Voir :ref:`pickle-dispatch` pour des exemples d'utilisation."

#: library/pickle.rst:373
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`__reduce__` method, and can "
"optionally return ``NotImplemented`` to fallback on :attr:`dispatch_table`-"
"registered reducers to pickle ``obj``."
msgstr ""
"Réducteur spécial, qui peut se définir dans une classe fille de :class:"
"`Pickler`. Cette méthode doit se conformer à l'interface des méthodes :meth:"
"`__reduce__`. Elle prend en général le pas sur les réducteurs contenus dans "
"l'attribut :attr:`dispatch_table`. Cependant, elle peut choisir de renvoyer "
"``NotImplemented`` pour que :attr:`dispatch_table` soit utilisé à la place."

#: library/pickle.rst:379
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr "Voir :ref:`reducer_override` pour un exemple détaillé."

#: library/pickle.rst:385
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""
"Cet attribut est obsolète. Une valeur vraie (« mode rapide ») désactive la "
"mémorisation des objets au fur et à mesure de leur sérialisation, qui permet "
"habituellement de représenter les doublons par une unique référence. Cette "
"option accélère la sérialisation en évitant des *opcodes* PUT superflus. "
"Elle ne doit pas être utilisée sur un objet contenant une référence à lui-"
"même, car le :class:`Pickler` entre alors dans une récursion infinie."

#: library/pickle.rst:391
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""
"Utilisez plutôt :func:`pickletools.optimize` pour obtenir des données "
"sérialisées plus compactes."

#: library/pickle.rst:396
msgid "This takes a binary file for reading a pickle data stream."
msgstr ""
"Les objets de cette classe sont des désérialiseurs, qui lisent un flux de "
"données pour le convertir en objet."

#: library/pickle.rst:398
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr ""
"Il n'y a nul besoin d'argument *protocol*. La version du protocole avec "
"lequel sont encodées les données est déterminée automatiquement."

#: library/pickle.rst:401
msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in the :class:`io."
"BufferedIOBase` interface.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""
"L'argument *file* doit posséder trois méthodes qui proviennent de "
"l'interface de :class:`io.BufferedIOBase`. Ce sont : ``read()``, prenant un "
"entier, ``readinto()``, prenant un tampon, et ``readline()``, sans "
"arguments. *file* peut donc être aussi bien un fichier sur disque ouvert en "
"mode lecture binaire qu'un objet :class:`io.BytesIO`, ou un objet quelconque "
"vérifiant ces critères."

#: library/pickle.rst:408
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these 8-"
"bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances of :class:`~datetime."
"datetime`, :class:`~datetime.date` and :class:`~datetime.time` pickled by "
"Python 2."
msgstr ""
"Les paramètres facultatifs *fix_imports*, *encoding* et *errors* sont dédiés "
"à la compatibilité de la désérialisation avec les flux binaires générés par "
"Python 2. Si *fix_imports* est vrai, *pickle* tente de modifier les anciens "
"noms des modules que l'on trouve en Python 2, pour les remplacer par ceux en "
"usage en Python 3. Les paramètres *encoding* et *errors* contrôlent la façon "
"de décoder les chaînes de caractères 8 bits. Leurs valeurs par défaut "
"respectives sont ``'ASCII'`` et ``'strict'``. *encoding* peut être mis à "
"``'bytes'`` pour lire des chaînes d'octets en tant que *bytes*. Il doit être "
"mis à ``'latin1'`` pour désérialiser des tableaux NumPy ou des instances de :"
"class:`~datetime.datetime`, :class:`~datetime.date` et :class:`~datetime."
"time` sérialisées par Python 2."

#: library/pickle.rst:419
msgid ""
"If *buffers* is None (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the "
"*buffer_callback* argument was None when a :class:`Pickler` was instantiated "
"(or when :func:`dump` or :func:`dumps` was called)."
msgstr ""
"Si *buffers* vaut None (comme par défaut), toutes les données nécessaires à "
"la désérialisation doivent être contenues dans le flux binaire. Ceci "
"signifie que l'argument *buffer_callback* valait None lors de la "
"construction du :class:`Pickler` (ou dans l'appel à :func:`dump` ou :func:"
"`dumps`)."

#: library/pickle.rst:424
msgid ""
"If *buffers* is not None, it should be an iterable of buffer-enabled objects "
"that is consumed each time the pickle stream references an :ref:`out-of-band "
"<pickle-oob>` buffer view.  Such buffers have been given in order to the "
"*buffer_callback* of a Pickler object."
msgstr ""

#: library/pickle.rst:434
msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""
"Lit la représentation sérialisée d'un objet depuis le fichier ouvert passé "
"au constructeur, et reconstitue l'objet qui y est stocké, avec tous les "
"objets qu'il contient. Les octets situés au-delà de la fin de la "
"représentation binaire sont ignorés."

#: library/pickle.rst:441
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "Par défaut, cette méthode lève une exception :exc:`UnpicklingError`."

#: library/pickle.rst:443
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpicklingError` should be raised."
msgstr ""
"Si elle est définie autrement dans une sous-classe, :meth:`persistent_load` "
"doit renvoyer l'objet correspondant à l'ID persistant *pid*. Si celui-ci est "
"invalide, elle doit lever une exception :exc:`UnpicklingError`."

#: library/pickle.rst:451
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"Importe *module* si besoin, et renvoie l'objet du nom *name* qu'il contient. "
"*module* et *name* sont des chaînes de caractères (classe :class:`str`). "
"Contrairement à ce que son nom laisse penser, :meth:`find_class` est "
"également appelée pour trouver les fonctions."

#: library/pickle.rst:456
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr ""
"Les classes filles peuvent redéfinir cette méthode pour restreindre la "
"désérialisation à certains types d'objets ou à d'autres conditions, "
"notamment en vue de réduire les risques de sécurité. Voir :ref:`pickle-"
"restrict` pour plus de détails."

#: library/pickle.rst:460
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""
"Lève un :ref:`événement d'audit <auditing>` ``pickle.find_class`` avec les "
"arguments ``module`` et ``name``."

#: library/pickle.rst:464
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a :ref:"
"`buffer-providing <bufferobjects>` object, such as a :term:`bytes-like "
"object` or a N-dimensional array."
msgstr ""
"Encapsule un objet tampon contenant des données sérialisables. *buffer* doit "
"être un objet prenant en charge le :ref:`protocole tampon <bufferobjects>`, "
"comme un :term:`objet octet-compatible <bytes-like object>` ou un tableau n-"
"dimensionnel."

#: library/pickle.rst:468
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such as :class:"
"`memoryview`."
msgstr ""
"Les objets :class:`PickleBuffer` savent gérer le protocole tampon. Il est "
"donc possible de les passer à d'autres API qui attendent un tampon, comme :"
"class:`memoryview`."

#: library/pickle.rst:472
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5 "
"or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""
"Les objets :class:`PickleBuffer` ne peuvent être sérialisés qu'avec le "
"protocole 5 ou supérieur. Ils sont susceptibles d'être sérialisés :ref:`hors-"
"bande <pickle-oob>`."

#: library/pickle.rst:480
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""
"Renvoie une :class:`memoryview` de l'espace mémoire sous-jacent à ce tampon. "
"La *memoryview* renvoyée est unidimensionnelle et C-contiguë. Elle a le "
"format ``B`` (octets sans signe). :exc:`BufferError` est levée si le tampon "
"n'est ni C-contigu, ni Fortran-contigu."

#: library/pickle.rst:487
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr ""

#: library/pickle.rst:493
msgid "What can be pickled and unpickled?"
msgstr "Quels objets sont sérialisables ?"

#: library/pickle.rst:495
msgid "The following types can be pickled:"
msgstr "Les objets des types suivants peuvent être sérialisés :"

#: library/pickle.rst:497
#, fuzzy
msgid "``None``, ``True``, and ``False``;"
msgstr "``None``, ``True`` et ``False`` ;"

#: library/pickle.rst:499
#, fuzzy
msgid "integers, floating-point numbers, complex numbers;"
msgstr "les entiers, nombres à virgule flottante et nombres complexes ;"

#: library/pickle.rst:501
#, fuzzy
msgid "strings, bytes, bytearrays;"
msgstr "les chaînes de caractères, *bytes* et *bytearrays* ;"

#: library/pickle.rst:503
#, fuzzy
msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects;"
msgstr ""
"les *n*-uplets, listes, ensembles et dictionnaires, à condition que tous les "
"objets qu'ils contiennent soient sérialisables."

#: library/pickle.rst:505
#, fuzzy
msgid ""
"functions (built-in and user-defined) accessible from the top level of a "
"module (using :keyword:`def`, not :keyword:`lambda`);"
msgstr ""
"les fonctions définies au niveau le plus haut dans un module (avec :keyword:"
"`def`, mais pas :keyword:`lambda`) ;"

#: library/pickle.rst:508
#, fuzzy
msgid "classes accessible from the top level of a module;"
msgstr "les classes définies au plus haut niveau dans un module ;"

#: library/pickle.rst:510
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of "
"calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-inst` "
"for details)."
msgstr ""
"les instances de telles classes, à condition que leur :attr:`~object."
"__dict__`, ou la valeur de retour de :meth:`__getstate__`, soit sérialisable "
"(voir :ref:`pickle-inst` pour plus d'informations)."

#: library/pickle.rst:514
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RecursionError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""
"Si vous essayez de sérialiser un objet qui ne peut pas l'être, une exception "
"de type :exc:`PicklingError` est levée. Lorsque cela se produit, il est "
"possible qu'un certain nombre d'octets aient déjà été écrits dans le fichier "
"ou flux. La sérialisation d'une structure de donnée avec de nombreux niveaux "
"d'imbrication peut lever une exception :exc:`RecursionError`. Pour augmenter "
"la limite (avec précaution), voir :func:`sys.setrecursionlimit`."

#: library/pickle.rst:521
#, fuzzy
msgid ""
"Note that functions (built-in and user-defined) are pickled by fully :term:"
"`qualified name`, not by value. [#]_  This means that only the function name "
"is pickled, along with the name of the containing module and classes.  "
"Neither the function's code, nor any of its function attributes are "
"pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"Veuillez noter que les fonctions, natives ou non, sont sérialisées par "
"référence à leur « nom complètement qualifié », et non pas par leur vraie "
"valeur [#]_. La seule information stockée est le nom de la fonction "
"accompagné du nom du module auquel elle appartient. Le code de la fonction "
"n'est pas sérialisé, les attributs de la fonction non plus. Ainsi, le module "
"qui définit la fonction sérialisée doit être disponible dans l'environnement "
"de désérialisation. Il doit contenir l'objet du nom spécifié, sans quoi une "
"exception sera levée [#]_."

#: library/pickle.rst:528
#, fuzzy
msgid ""
"Similarly, classes are pickled by fully qualified name, so the same "
"restrictions in the unpickling environment apply.  Note that none of the "
"class's code or data is pickled, so in the following example the class "
"attribute ``attr`` is not restored in the unpickling environment::"
msgstr ""
"De même, les classes sont sérialisées par leur nom. Les mêmes prérequis sur "
"l'environnement de désérialisation s'appliquent. Le code de la classe et les "
"données qu'elle contient ne sont pas sérialisés. Par exemple, dans ce code, "
"l'attribut ``attr`` ne sera pas restauré à la désérialisation :"

#: library/pickle.rst:538
#, fuzzy
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"at the top level of a module."
msgstr ""
"Cette sérialisation par le nom est la raison pour laquelle les fonctions et "
"classes à sérialiser doivent impérativement être définies au plus haut "
"niveau dans un module."

#: library/pickle.rst:541
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""
"De même, lorsque les instances d'une certaine classe sont sérialisées, seuls "
"les attributs de l'instance sont inclus, mais pas le code de leur classe ni "
"les données qu'elle pourrait contenir. Ceci est intentionnel : vous pouvez "
"corriger des bogues dans une classe ou ajouter des méthodes, et désérialiser "
"malgré tout des objets instanciés avec une version plus ancienne de la "
"classe. Si vous stockez des objets destinés être conservés pendant "
"longtemps, et que leur classe est susceptible de connaître de nombreuses "
"évolutions, il peut s'avérer utile d'associer aux objets un numéro de "
"version afin que des conversions puissent être implémentées dans la méthode :"
"meth:`__setstate__` de la classe."

#: library/pickle.rst:553
msgid "Pickling Class Instances"
msgstr "Sérialisation des instances d'une classe"

#: library/pickle.rst:557
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""
"Dans cette section sont décrits les mécanismes généraux qui s'offrent à vous "
"pour définir, personnaliser et contrôler la manière dont les instances d'une "
"classe sont sérialisées et désérialisées."

#: library/pickle.rst:560
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""
"Dans la plupart des cas, il n'y a besoin de rien pour que les instances "
"d'une classe puissent être sérialisées. Par défaut, *pickle* accède à la "
"classe et aux attributs de l'instance par introspection. Lorsqu'une instance "
"est désérialisée, sa méthode :meth:`__init__` n'est normalement *pas* "
"appelée. Une nouvelle instance est créée sans être initialisée, et ses "
"attributs sont simplement restaurés à partir des valeurs conservées. En "
"d'autres termes, les opérations sont celles qu'effectue le code suivant ::"

#: library/pickle.rst:575
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""
"Les classes peuvent personnaliser le comportement par défaut en définissant "
"des méthodes spéciales :"

#: library/pickle.rst:580
msgid ""
"In protocols 2 and newer, classes that implements the :meth:"
"`__getnewargs_ex__` method can dictate the values passed to the :meth:"
"`__new__` method upon unpickling.  The method must return a pair ``(args, "
"kwargs)`` where *args* is a tuple of positional arguments and *kwargs* a "
"dictionary of named arguments for constructing the object.  Those will be "
"passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"Dans les protocoles 2 et suivants, les classes peuvent personnaliser les "
"valeurs passées à la méthode :meth:`__new__` lors de la désérialisation. "
"Elles le font en définissant une méthode :meth:`__getnewargs_ex__` qui "
"renvoie un couple ``(args, kwargs)``, où *args* est un *n*-uplet des "
"arguments positionnels et *kwargs* un dictionnaire des arguments nommés qui "
"seront passés à :meth:`__new__` — autrement dit, l'appel sera ``classe."
"__new__(*args, **kwargs)``."

#: library/pickle.rst:588
msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"Définissez cette méthode seulement si la méthode :meth:`__new__` de votre "
"classe demande des arguments nommés. Dans le cas contraire, mieux vaut "
"définir :meth:`__getnewargs__` pour préserver la compatibilité avec les "
"protocoles anciens."

#: library/pickle.rst:592
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ""
":meth:`__getnewargs_ex__` est désormais appelée dans les protocoles 2 et 3."

#: library/pickle.rst:598
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"Comme :meth:`__getnewargs_ex__`, mais ne permet que les arguments "
"positionnels. Cette méthode doit renvoyer le *n*-uplet ``args`` des "
"arguments passés à :meth:`__new__` lors de la désérialisation : l'appel sera "
"``classe.__new__(*args)``."

#: library/pickle.rst:602
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""
"Si :meth:`__getnewargs_ex__` est définie, elle prend la priorité et :meth:"
"`__getnewargs__` n'est jamais appelée."

#: library/pickle.rst:605
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of :meth:"
"`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"Auparavant, :meth:`__getnewargs__` était appelée au lieu de :meth:"
"`__getnewargs_ex__` dans les protocoles 2 et 3."

#: library/pickle.rst:612
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the returned "
"object is pickled as the contents for the instance, instead of the contents "
"of the instance's dictionary.  If the :meth:`__getstate__` method is absent, "
"the instance's :attr:`~object.__dict__` is pickled as usual."
msgstr ""
"Des personnalisations plus poussées de la sérialisation sont possibles à "
"l'aide de la méthode :meth:`__getstate__`. Lorsque :meth:`__getstate__` est "
"définie, l'objet qu'elle renvoie (état de l'instance) est sérialisé en lieu "
"et place du :attr:`~object.__dict__`, le dictionnaire des attributs de "
"l'instance."

#: library/pickle.rst:621
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"Lors de la désérialisation, l'état de l'instance est passé à la méthode :"
"meth:`__setstate__`, si elle est définie (l'objet *state* n'a pas besoin "
"d'être un dictionnaire). Si elle ne l'est pas, les attributs de l'objet sont "
"tirés de l'état, qui dans ce cas doit être obligatoirement un dictionnaire."

#: library/pickle.rst:628
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""
"Si :meth:`__getstate__` renvoie une valeur fausse, :meth:`__setstate__` ne "
"sera pas appelée à la désérialisation."

#: library/pickle.rst:632
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""
"Voir :ref:`pickle-state` pour plus d'informations sur :meth:`__getstate__` "
"et :meth:`__setstate__`."

#: library/pickle.rst:637
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, :meth:"
"`__getattribute__`, or :meth:`__setattr__` may be called upon the instance.  "
"In case those methods rely on some internal invariant being true, the type "
"should implement :meth:`__new__` to establish such an invariant, as :meth:"
"`__init__` is not called when unpickling an instance."
msgstr ""
"Lors de la désérialisation, des méthodes comme :meth:`__getattr__`, :meth:"
"`__getattribute__` et :meth:`__setattr__` sont susceptibles d'être appelées "
"sur l'instance. Si ces méthodes reposent sur des invariants internes à "
"l'objet, leur classe doit les initialiser dans la méthode :meth:`__new__`, "
"puisque la méthode :meth:`__init__` n'est pas appelée."

#: library/pickle.rst:646
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""
"Comme nous le verrons, *pickle* ne fait pas directement appel aux méthodes "
"ci-dessus. En réalité, elles font partie du protocole de copie, qui "
"implémente la méthode spéciale :meth:`__reduce__`. Ce protocole constitue "
"une interface unifiée pour l'accès aux données nécessaires à la "
"sérialisation comme à la copie [#]_."

#: library/pickle.rst:652
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs_ex__`, :meth:`__getstate__` and :meth:"
"`__setstate__`) whenever possible.  We will show, however, cases where "
"using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""
"Bien que la méthode :meth:`__reduce__` ouvre davantage de possibilités, elle "
"conduit plus facilement à des erreurs. C'est pourquoi les auteurs de classes "
"sont encouragés à utiliser lorsque c'est possible l'interface de plus haut "
"niveau avec :meth:`__getnewargs_ex__`, :meth:`__getstate__` et :meth:"
"`__state__`. Cependant, il existe des cas où l'on ne peut pas se passer de :"
"meth:`__reduce__`, ou bien elle permet une sérialisation plus efficace."

#: library/pickle.rst:661
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"Voici l'interface de la méthode :meth:`__reduce__`. Elle ne prend aucun "
"argument et renvoie soit une chaîne de caractères, soit (c'est conseillé) un "
"*n*-uplet. On appelle souvent l'objet renvoyé « valeur de réduction »."

#: library/pickle.rst:665
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""

#: library/pickle.rst:670
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""
"Si c'est un *n*-uplet qui est renvoyé, ses éléments sont interprétés dans "
"l'ordre comme suit. Les deux premiers éléments sont obligatoires, les quatre "
"suivants sont facultatifs et peuvent être simplement omis, ou bien mis à "
"``None``. Les éléments sont, dans l'ordre :"

#: library/pickle.rst:676
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr "Un objet appelable qui sera appelé pour créer l'objet initial."

#: library/pickle.rst:679
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""
"Un *n*-uplet d'arguments passés à cet objet appelable. Donnez un *n*-uplet "
"vide si l'objet appelable n'accepte pas d'arguments."

#: library/pickle.rst:682
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`~object.__dict__` attribute."
msgstr ""
"L'état de l'objet, qui sera passé à la méthode :meth:`__setstate__` comme vu "
"précédemment. Si la méthode n'existe pas, cet élément doit être un "
"dictionnaire, et ses éléments compléteront l'attribut :attr:`~object."
"__dict__`."

#: library/pickle.rst:687
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""
"Un itérateur (non pas une séquence). Les éléments qu'il fournit sont ajoutés "
"à l'objet un par un avec la méthode :meth:`append`, ou bien plusieurs à la "
"fois avec la méthode :meth:`extend`. Ceci est principalement utile aux les "
"classes héritant de ``list``, mais peut aussi servir sur d'autres classes, "
"la seule contrainte étant qu'elles implémentent :meth:`append` et :meth:"
"`extend` avec les bonnes signatures (l'une ou l'autre de ces méthodes est "
"utilisée selon la version du protocole *pickle* et le nombre d'éléments à "
"ajouter, c'est pourquoi elles doivent être définies toutes les deux)."

#: library/pickle.rst:696
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"Un itérateur (non pas une séquence). Les éléments qu'il fournit doivent être "
"des couples ``(clé, valeur)``. Ils sont ajoutés dans l'objet par affectation "
"aux clés : ``objet[clé] = valeur``. Ceci est principalement utile aux "
"classes héritant de ``dict``, mais peut servir à d'autres classes à la seule "
"condition qu'elles implémentent la méthode :meth:`__setitem__`."

#: library/pickle.rst:701
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a "
"specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over ``obj``'s :"
"meth:`__setstate__`."
msgstr ""
"Un objet appelable qui puisse recevoir en arguments l'objet et son état. "
"Ceci permet de redéfinir le processus de reconstruction des attributs pour "
"un objet en particulier, outrepassant la méthode :meth:`__setstate__`. Si "
"cet objet appelable est fourni, :meth:`__setstate__` n'est pas appelée."

#: library/pickle.rst:707
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr "ajout du sixième élément."

#: library/pickle.rst:713
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""
"Il est également possible de définir une méthode :meth:`__reduce_ex__`. La "
"seule différence est qu'elle prend la version du protocole en argument. Si "
"elle est définie, elle prend le pas sur :meth:`__reduce__`. De plus, :meth:"
"`__reduce__` devient automatiquement un alias pour sa version étendue. Cette "
"méthode est principalement destinée à renvoyer des valeurs de réduction "
"compatibles avec les versions anciennes de Python."

#: library/pickle.rst:725
msgid "Persistence of External Objects"
msgstr "Persistance d'objets externes"

#: library/pickle.rst:731
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""
"Pour les besoins de la persistance, :mod:`pickle` permet des références à "
"des objets en dehors du flux sérialisé. Ils sont identifiés par un ID "
"persistant. Le protocole 0 requiert que cet ID soit une chaîne de caractères "
"alphanumériques [#]_. Les suivants autorisent un objet quelconque."

#: library/pickle.rst:737
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and :meth:`~Unpickler."
"persistent_load` respectively."
msgstr ""
":mod:`pickle` délègue la résolution des ID à des méthodes définies par "
"l'utilisateur sur les objets sérialiseurs et désérialiseurs, à savoir :meth:"
"`~Pickler.persistent_id` et :meth:`~Unpickler.persistent_load`."

#: library/pickle.rst:742
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"Pour affecter à des objets leurs ID persistants provenant d'une source "
"externe, le sérialiseur doit posséder une méthode :meth:`~Pickler."
"persistent_id` qui prend un objet et renvoie soit ``None``, soit son ID. Si "
"cette méthode renvoie ``None``, l'objet est sérialisé de la manière "
"habituelle. Si un ID est renvoyé, sous forme de chaîne de caractères, c'est "
"cette chaîne qui est sérialisée et elle est marquée de manière spéciale pour "
"être reconnue comme un ID persistant."

#: library/pickle.rst:749
msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`~Unpickler.persistent_load` method that takes a persistent ID object and "
"returns the referenced object."
msgstr ""
"Pour désérialiser des objets identifiés par un ID externe, un désérialiseur "
"doit posséder une méthode :meth:`~Unpickler.persistent_load` qui prend un ID "
"et renvoie l'objet qu'il désigne."

#: library/pickle.rst:753
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""
"Voici un exemple complet qui montre comment sérialiser des objets externes "
"en leur affectant des ID persistants."

#: library/pickle.rst:761
msgid "Dispatch Tables"
msgstr "Tables de distribution"

#: library/pickle.rst:763
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""
"Pour personnaliser la sérialisation d'une classe à un endroit particulier "
"sans affecter le reste du code, on peut créer un sérialiseur avec une table "
"de distribution spécifique."

#: library/pickle.rst:767
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`copyreg.dispatch_table` as a private dispatch table."
msgstr ""
"La table de distribution gérée par le module :mod:`copyreg` est disponible "
"sous le nom :data:`copyreg.dispatch_table`. On peut donc utiliser une copie "
"modifiée de :data:`copyreg.dispatch_table` comme table spécifique à un "
"sérialiseur."

#: library/pickle.rst:772
msgid "For example ::"
msgstr "Par exemple, le code :"

#: library/pickle.rst:779
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""
"crée une instance de la classe :class:`pickle.Pickler` avec une table de "
"distribution propre qui traite la classe ``SomeClass`` de manière "
"spécifique. Le code :"

#: library/pickle.rst:789
#, fuzzy
msgid ""
"does the same but all instances of ``MyPickler`` will by default share the "
"private dispatch table.  On the other hand, the code ::"
msgstr ""
"fait la même chose, mais toutes les instances de ``MyPickler`` partageront "
"par défaut la même table de distribution. L'équivalent avec :mod:`copyreg` "
"serait :"

#: library/pickle.rst:796
msgid ""
"modifies the global dispatch table shared by all users of the :mod:`copyreg` "
"module."
msgstr ""

#: library/pickle.rst:801
msgid "Handling Stateful Objects"
msgstr "Traitement des objets à état"

#: library/pickle.rst:807
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number "
"and line contents each time its :meth:`!readline` method is called. If a :"
"class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:"
"`__setstate__` and :meth:`__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""
"L'exemple suivant illustre comment modifier la sérialisation pour une "
"classe. La classe :class:`TextReader` ouvre un fichier de texte, et sa "
"méthode :meth:`!readline` renvoie le numéro de la ligne suivante et son "
"contenu chaque fois qu'elle est appelée. Si une instance de :class:"
"`TextReader` est sérialisée, tous les attributs *sauf* le fichier ouvert "
"sont enregistrés. Lorsque l'instance est désérialisée, le fichier est "
"rouvert et la lecture reprend là où elle s'était arrêtée. Ceci est "
"implémenté à travers les méthodes :meth:`__setstate__` et :meth:"
"`__getstate__`."

#: library/pickle.rst:853
msgid "A sample usage might be something like this::"
msgstr "Voici un exemple d'utilisation :"

#: library/pickle.rst:867
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr "Réduction personnalisée pour les types, fonctions et autres objets"

#: library/pickle.rst:871
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than "
"the object's type, or we may want to customize the pickling of functions and "
"classes."
msgstr ""
"Parfois, la simple utilisation de :attr:`~Pickler.dispatch_table` n'offre "
"pas assez de flexibilité. On peut vouloir changer la méthode de "
"sérialisation selon d'autres critères que le type de l'objet, ou bien "
"personnaliser la sérialisation des fonctions et des classes."

#: library/pickle.rst:876
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`__reduce__`). It can "
"alternatively return ``NotImplemented`` to fallback to the traditional "
"behavior."
msgstr ""
"Dans ces cas, il est possible d'écrire une méthode :meth:`~Pickler."
"reducer_override` dans une classe fille de :class:`Pickler`. Cette méthode "
"renvoie un *n*-uplet de réduction arbitraire (voir :meth:`__reduce__`). Elle "
"peut aussi renvoyer ``NotImplemented``, auquel cas la méthode habituelle de "
"réduction par table s'applique."

#: library/pickle.rst:881
msgid ""
"If both the :attr:`~Pickler.dispatch_table` and :meth:`~Pickler."
"reducer_override` are defined, then :meth:`~Pickler.reducer_override` method "
"takes priority."
msgstr ""
"Si :attr:`~Pickler.dispatch_table` et :meth:`~Pickler.reducer_override` sont "
"tous les deux définis, :meth:`~Pickler.reducer_override` a la priorité."

#: library/pickle.rst:886
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called "
"for the following objects: ``None``, ``True``, ``False``, and exact "
"instances of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :"
"class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` and :class:"
"`tuple`."
msgstr ""
"Pour des raisons de performance, la méthode :meth:`~Pickler."
"reducer_override` n'est jamais appelée sur ``None``, ``True``, ``False``, "
"ainsi que les instances exactes (pas dérivées) de :class:`int`, :class:"
"`float`, :class:`bytes`, :class:`str`, :class:`dict`, :class:`set`, :class:"
"`frozenset`, :class:`list` et :class:`tuple`."

#: library/pickle.rst:892
msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr "Voici un exemple simple qui implémente la sérialisation d'une classe :"

#: library/pickle.rst:927
msgid "Out-of-band Buffers"
msgstr "Tampons hors-bande"

#: library/pickle.rst:931
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""
"Le module :mod:`pickle` est parfois utilisé pour transférer des quantités "
"énormes de données. Il peut devenir important de réduire les copies de "
"mémoire au minimum pour préserver la performance et diminuer l'usage des "
"ressources matérielles. Cependant, dans son contexte courant d'utilisation, "
"le module :mod:`pickle` effectue des copies depuis et vers le flux de "
"données pour les besoins de la conversion de structures d'objets semblables "
"à des graphes en flux séquentiels d'octets."

#: library/pickle.rst:938
msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""
"Cette contrainte peut être levée si le *producteur* (qui implémente les "
"types d'objets à transférer) et le *consommateur* (qui implémente le système "
"de communication) emploient les possibilités de transfert hors-bande "
"offertes par les protocoles 5 et suivants."

#: library/pickle.rst:944
msgid "Provider API"
msgstr "API des producteurs"

#: library/pickle.rst:946
msgid ""
"The large data objects to be pickled must implement a :meth:`__reduce_ex__` "
"method specialized for protocol 5 and higher, which returns a :class:"
"`PickleBuffer` instance (instead of e.g. a :class:`bytes` object) for any "
"large data."
msgstr ""
"Les objets de grande taille à sérialiser doivent posséder une méthode :meth:"
"`__reduce_ex__` qui, lorsqu'elle est appelée pour le protocole 5 ou plus, "
"renvoie un objet :class:`PickleBuffer` au lieu d'un objet :class:`bytes` dès "
"que la taille le justifie."

#: library/pickle.rst:951
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""
"Les objets :class:`PickleBuffer` ne font que signaler que leur tampon permet "
"le transfert hors-bande. Ils demeurent compatibles avec l'utilisation "
"classique du module :mod:`pickle`. Cependant, les consommateurs peuvent "
"aussi choisir d'indiquer à :mod:`pickle` qu'ils gèrent eux-mêmes ces tampons."

#: library/pickle.rst:958
msgid "Consumer API"
msgstr "API des consommateurs"

#: library/pickle.rst:960
msgid ""
"A communications system can enable custom handling of the :class:"
"`PickleBuffer` objects generated when serializing an object graph."
msgstr ""
"Un système de communication peut gérer de manière spécifique les objets :"
"class:`PickleBuffer` générés lors de la sérialisation d'un réseau d'objets."

#: library/pickle.rst:963
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to :class:"
"`Pickler` (or to the :func:`dump` or :func:`dumps` function), which will be "
"called with each :class:`PickleBuffer` generated while pickling the object "
"graph.  Buffers accumulated by the *buffer_callback* will not see their data "
"copied into the pickle stream, only a cheap marker will be inserted."
msgstr ""
"Du côté de l'expéditeur, il faut passer le paramètre *buffer_callback* à :"
"class:`Pickler` (ou à :func:`dump` ou :func:`dumps`). Le *buffer_callback* "
"sera appelé avec chaque :class:`PickleBuffer` généré lors de la "
"sérialisation du réseau d'objets. Les tampons accumulés par le "
"*buffer_callback* ne verront pas leurs données copiées dans le flux "
"sérialisé. Il leur sera substitué un marqueur léger."

#: library/pickle.rst:970
msgid ""
"On the receiving side, it needs to pass a *buffers* argument to :class:"
"`Unpickler` (or to the :func:`load` or :func:`loads` function), which is an "
"iterable of the buffers which were passed to *buffer_callback*. That "
"iterable should produce buffers in the same order as they were passed to "
"*buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the original :class:"
"`PickleBuffer` objects."
msgstr ""
"Du côté du receveur, il faut passer l'argument *buffers* à :class:"
"`Unpickler` (ou :func:`load` ou bien :func:`loads`). *buffers* est un "
"itérable des tampons passés à *buffer_callback*. Il doit fournir les tampons "
"dans le même ordre que celui dans lequel ils ont été passés à "
"*buffer_callback*. Les tampons fournis constituent la source des données "
"qu'attendent les reconstructeurs des objets dont la sérialisation a abouti "
"aux objets :class:`PickleBuffer`."

#: library/pickle.rst:978
msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr ""
"Entre expéditeur et receveur, le système de communication peut implémenter "
"son propre mécanisme de transfert pour les tampons hors-bande. Parmi les "
"optimisations possibles se trouvent l'utilisation de mémoire partagée et la "
"compression spécifique au type de données."

#: library/pickle.rst:984
msgid "Example"
msgstr "Exemple"

#: library/pickle.rst:986
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr ""
"Voici un exemple trivial où est implémentée une classe fille de :class:"
"`bytearray` capable de sérialisation hors-bande."

#: library/pickle.rst:1010
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr ""
"Lorsqu'il rencontre le bon type, le reconstructeur (la méthode de classe "
"``_reconstruct``) renvoie directement le tampon original. Il s'agit d'une "
"manière simple de simuler l'absence de copie dans cet exemple simpliste."

#: library/pickle.rst:1014
msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr ""
"En tant que consommateur des objets, on peut les sérialiser de la manière "
"classique. La désérialisation conduit alors à une copie."

#: library/pickle.rst:1023
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr ""
"Mais en passant un *buffer_callback* et en donnant les tampons accumulés au "
"désérialiseur, il n'y a plus de copie."

#: library/pickle.rst:1033
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""
"Cet exemple est limité par le fait que :class:`bytearray` effectue sa propre "
"allocation de mémoire. Il n'est pas possible de créer un :class:`bytearray` "
"sur la mémoire d'un autre objet. Cependant, certains types de données que "
"l'on trouve dans des bibliothèques externes, comme les tableaux NumPy, n'ont "
"pas cette limitation. Le passage hors-bande permet alors de n'effectuer "
"aucune copie (ou bien de minimiser le nombre de copies) lors du transfert de "
"données d'un système à l'autre ou d'un processus à l'autre."

#: library/pickle.rst:1040
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ":pep:`574` — Protocole *pickle* 5 avec données hors-bande"

#: library/pickle.rst:1046
msgid "Restricting Globals"
msgstr "Restriction des noms dans l'espace de nommage global"

#: library/pickle.rst:1051
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"Par défaut, la désérialisation importe toutes les classes ou fonctions que "
"demande le flux de données. Dans bien des cas, ce comportement est "
"inacceptable, puisqu'il permet de faire exécuter du code arbitraire dans "
"l'environnement de désérialisation. Observez le résultat de ce flux de "
"données fait-main lorsqu'il est lu :"

#: library/pickle.rst:1061
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"Dans cet exemple, le désérialiseur importe la fonction :func:`os.system` et "
"l'applique à la chaîne de caractères ``\"echo hello world\"``. C'est "
"inoffensif, mais il n'est pas difficile d'imaginer des variantes qui "
"endommageraient le système."

#: library/pickle.rst:1065
msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`Unpickler."
"find_class` is called whenever a global (i.e., a class or a function) is "
"requested.  Thus it is possible to either completely forbid globals or "
"restrict them to a safe subset."
msgstr ""
"C'est pour cette raison qu'il s'avère parfois nécessaire de contrôler ce qui "
"peut être désérialisé. Cela est possible en redéfinissant la méthode :meth:"
"`Unpickler.find_class`. Contrairement à ce que son nom laisse penser, :meth:"
"`Unpickler.find_class` est appelée pour tous les noms à chercher dans "
"l'espace de nommage global, ce qui inclut les classes mais aussi les "
"fonctions. Par ce biais, il est possible d'interdire complètement la "
"résolution des noms globaux ou de la restreindre à un sous-ensemble que l'on "
"considère sûr."

#: library/pickle.rst:1071
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr ""
"Voici un exemple de désérialiseur qui permet seulement la désérialisation "
"d'un petit nombre de classes sûres du module :mod:`builtins`."

#: library/pickle.rst:1100
#, fuzzy
msgid "A sample usage of our unpickler working as intended::"
msgstr ""
"Et voici un exemple d'utilisation montrant que notre désérialiseur "
"fonctionne comme prévu :"

#: library/pickle.rst:1119
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"Comme le montre l'exemple, il faut faire attention aux objets que l'on "
"autorise à être désérialisés. Si la sécurité est une priorité, il peut être "
"sage de se tourner vers des alternatives comme l'API du module :mod:`xmlrpc."
"client`, ou des bibliothèques tierces."

#: library/pickle.rst:1126
msgid "Performance"
msgstr "Performances"

#: library/pickle.rst:1128
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""

#: library/pickle.rst:1136
msgid "Examples"
msgstr "Exemples"

#: library/pickle.rst:1138
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""
"Dans les cas les plus simples, utilisez les fonctions :func:`dump` et :func:"
"`load`."

#: library/pickle.rst:1154
msgid "The following example reads the resulting pickled data. ::"
msgstr "Le code suivant lit les données qui viennent d'être sérialisées :"

#: library/pickle.rst:1171
msgid "Module :mod:`copyreg`"
msgstr "Module :mod:`copyreg`"

#: library/pickle.rst:1171
msgid "Pickle interface constructor registration for extension types."
msgstr ""
"Enregistre les fonctions de sérialisation pour les types définis par "
"l'utilisateur."

#: library/pickle.rst:1174
msgid "Module :mod:`pickletools`"
msgstr "Module :mod:`pickletools`"

#: library/pickle.rst:1174
msgid "Tools for working with and analyzing pickled data."
msgstr "Outils pour travailler sur les données sérialisées et les analyser."

#: library/pickle.rst:1177
msgid "Module :mod:`shelve`"
msgstr "Module :mod:`shelve`"

#: library/pickle.rst:1177
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "Bases de données indexées (module fondé sur :mod:`pickle`)."

#: library/pickle.rst:1180
msgid "Module :mod:`copy`"
msgstr "Module :mod:`copy`"

#: library/pickle.rst:1180
msgid "Shallow and deep object copying."
msgstr "Copie superficielle ou récursive d'objets."

#: library/pickle.rst:1182
msgid "Module :mod:`marshal`"
msgstr "Module :mod:`marshal`"

#: library/pickle.rst:1183
msgid "High-performance serialization of built-in types."
msgstr "Sérialisation haute-performance des types natifs."

#: library/pickle.rst:1187
msgid "Footnotes"
msgstr "Notes"

#: library/pickle.rst:1188
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "À ne pas confondre avec ce que fait le module :mod:`marshal`."

#: library/pickle.rst:1190
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"C'est la raison pour laquelle les fonctions :keyword:`lambda` ne peuvent pas "
"être sérialisées : elles partagent toutes le même nom, à savoir ``<lambda>``."

#: library/pickle.rst:1193
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""
"L'exception levée est généralement de type :exc:`ImportError` ou :exc:"
"`AttributeError`, mais ce n'est pas systématique."

#: library/pickle.rst:1196
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""
"Le module :mod:`copy` fait appel à ce protocole pour les opérations de copie "
"superficielle comme récursive."

#: library/pickle.rst:1199
#, fuzzy
msgid ""
"The limitation on alphanumeric characters is due to the fact that persistent "
"IDs in protocol 0 are delimited by the newline character.  Therefore if any "
"kind of newline characters occurs in persistent IDs, the resulting pickled "
"data will become unreadable."
msgstr ""
"La restriction aux caractères alphanumériques est due au fait que, dans le "
"protocole 0, les ID persistants sont délimités par des retours à la ligne. "
"Si un quelconque retour à la ligne apparaissait dans ces ID, le flux binaire "
"deviendrait illisible."

#~ msgid "built-in functions defined at the top level of a module"
#~ msgstr "les fonctions natives définies au plus haut niveau dans un module ;"
