# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2019-05-28 20:19+0200\n"
"Last-Translator: Jules Lasne <jules.lasne@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.3\n"

#: library/cmath.rst:2
#, fuzzy
msgid ":mod:`!cmath` --- Mathematical functions for complex numbers"
msgstr "Fonctions mathématiques pour nombres complexes — :mod:`cmath`"

#: library/cmath.rst:9
#, fuzzy
msgid ""
"This module provides access to mathematical functions for complex numbers.  "
"The functions in this module accept integers, floating-point numbers or "
"complex numbers as arguments. They will also accept any Python object that "
"has either a :meth:`~object.__complex__` or a :meth:`~object.__float__` "
"method: these methods are used to convert the object to a complex or "
"floating-point number, respectively, and the function is then applied to the "
"result of the conversion."
msgstr ""
"Ce module fournit l'accès aux fonctions mathématiques pour les nombres "
"complexes. Les fonctions de ce module acceptent les entiers, les nombres "
"flottants ou les nombres complexes comme arguments. Elles acceptent "
"également tout objet Python ayant une méthode :meth:`__complex__` "
"(respectivement :meth:`__float__`) : cette méthode est utilisée pour "
"convertir l’objet en nombre complexe (respectivement un nombre flottant) et "
"la fonction est ensuite appliquée sur le résultat de la conversion."

#: library/cmath.rst:18
msgid ""
"For functions involving branch cuts, we have the problem of deciding how to "
"define those functions on the cut itself. Following Kahan's \"Branch cuts "
"for complex elementary functions\" paper, as well as Annex G of C99 and "
"later C standards, we use the sign of zero to distinguish one side of the "
"branch cut from the other: for a branch cut along (a portion of) the real "
"axis we look at the sign of the imaginary part, while for a branch cut along "
"the imaginary axis we look at the sign of the real part."
msgstr ""

#: library/cmath.rst:26
msgid ""
"For example, the :func:`cmath.sqrt` function has a branch cut along the "
"negative real axis. An argument of ``complex(-2.0, -0.0)`` is treated as "
"though it lies *below* the branch cut, and so gives a result on the negative "
"imaginary axis::"
msgstr ""

#: library/cmath.rst:31
msgid ""
">>> cmath.sqrt(complex(-2.0, -0.0))\n"
"-1.4142135623730951j"
msgstr ""

#: library/cmath.rst:34
msgid ""
"But an argument of ``complex(-2.0, 0.0)`` is treated as though it lies above "
"the branch cut::"
msgstr ""

#: library/cmath.rst:37
msgid ""
">>> cmath.sqrt(complex(-2.0, 0.0))\n"
"1.4142135623730951j"
msgstr ""

#: library/cmath.rst:42
msgid "Conversions to and from polar coordinates"
msgstr "Conversion vers et à partir de coordonnées polaires"

#: library/cmath.rst:44
#, fuzzy
msgid ""
"A Python complex number ``z`` is stored internally using *rectangular* or "
"*Cartesian* coordinates.  It is completely determined by its *real part* ``z."
"real`` and its *imaginary part* ``z.imag``."
msgstr ""
"Un nombre complexe Python ``z`` est stocké de manière interne en coordonnées "
"*cartésiennes*. Il est entièrement défini par sa *partie réelle* ``z.real`` "
"et sa *partie complexe* ``z.imag``. En d'autres termes ::"

#: library/cmath.rst:48
msgid ""
"*Polar coordinates* give an alternative way to represent a complex number.  "
"In polar coordinates, a complex number *z* is defined by the modulus *r* and "
"the phase angle *phi*. The modulus *r* is the distance from *z* to the "
"origin, while the phase *phi* is the counterclockwise angle, measured in "
"radians, from the positive x-axis to the line segment that joins the origin "
"to *z*."
msgstr ""
"Les *coordonnées polaires* donnent une manière alternative de représenter un "
"nombre complexe. En coordonnées polaires, un nombre complexe *z* est défini "
"par son module *r* et par son argument (*angle de phase*) *phi*. Le module "
"*r* est la distance entre *z* et l'origine, alors que l'argument *phi* est "
"l'angle (dans le sens inverse des aiguilles d'une montre, ou sens "
"trigonométrique), mesuré en radians, à partir de l'axe X positif, et vers le "
"segment de droite joignant *z* à l'origine."

#: library/cmath.rst:55
msgid ""
"The following functions can be used to convert from the native rectangular "
"coordinates to polar coordinates and back."
msgstr ""
"Les fonctions suivantes peuvent être utilisées pour convertir à partir des "
"coordonnées rectangulaires natives vers les coordonnées polaires, et vice-"
"versa."

#: library/cmath.rst:60
#, fuzzy
msgid ""
"Return the phase of *x* (also known as the *argument* of *x*), as a float. "
"``phase(x)`` is equivalent to ``math.atan2(x.imag, x.real)``.  The result "
"lies in the range [-\\ *π*, *π*], and the branch cut for this operation lies "
"along the negative real axis.  The sign of the result is the same as the "
"sign of ``x.imag``, even when ``x.imag`` is zero::"
msgstr ""
"Renvoie l'argument de *x*, dans un nombre flottant. ``phase(x)`` est "
"équivalent à ``math.atan2(x.imag, x.real)``. Le résultat se situe dans "
"l'intervalle [-\\ *π*, *π*], et la coupure par cette opération se situe sur "
"la partie négative de l'axe des réels, continue par au-dessus. Sur les "
"systèmes supportant les zéros signés (ce qui inclut la plupart des systèmes "
"utilisés actuellement), cela signifie que le signe du résultat est le même "
"que ``x.imag`` même quand ``x.imag`` vaut zéro ::"

#: library/cmath.rst:66
msgid ""
">>> phase(complex(-1.0, 0.0))\n"
"3.141592653589793\n"
">>> phase(complex(-1.0, -0.0))\n"
"-3.141592653589793"
msgstr ""

#: library/cmath.rst:74
msgid ""
"The modulus (absolute value) of a complex number *x* can be computed using "
"the built-in :func:`abs` function.  There is no separate :mod:`cmath` module "
"function for this operation."
msgstr ""
"Le module (valeur absolue) d'un nombre complexe *x* peut être calculé en "
"utilisant la primitive :func:`abs`. Il n'y a pas de fonction spéciale du "
"module :mod:`cmath` pour cette opération."

#: library/cmath.rst:81
msgid ""
"Return the representation of *x* in polar coordinates.  Returns a pair ``(r, "
"phi)`` where *r* is the modulus of *x* and phi is the phase of *x*.  "
"``polar(x)`` is equivalent to ``(abs(x), phase(x))``."
msgstr ""
"Renvoie la représentation de *x* en coordonnées polaires. Renvoie une paire "
"``(r, phi)`` où *r* est le module de *x* et phi est l'argument de *x*. "
"``polar(x)`` est équivalent à ``(abs(x), phase(x))``."

#: library/cmath.rst:89
#, fuzzy
msgid ""
"Return the complex number *x* with polar coordinates *r* and *phi*. "
"Equivalent to ``complex(r * math.cos(phi), r * math.sin(phi))``."
msgstr ""
"Renvoie le nombre complexe *x* dont les coordonnées polaires sont *r* et "
"*phi*. Équivalent à ``r * (math.cos(phi) + math.sin(phi)*1j)``."

#: library/cmath.rst:94
msgid "Power and logarithmic functions"
msgstr "Fonctions logarithme et exponentielle"

#: library/cmath.rst:98
msgid ""
"Return *e* raised to the power *x*, where *e* is the base of natural "
"logarithms."
msgstr ""
"Renvoie *e* élevé à la puissance *x*, où *e* est la base des logarithmes "
"naturels."

#: library/cmath.rst:104
#, fuzzy
msgid ""
"Returns the logarithm of *x* to the given *base*. If the *base* is not "
"specified, returns the natural logarithm of *x*. There is one branch cut, "
"from 0 along the negative real axis to -∞."
msgstr ""
"Renvoie le logarithme de *x* dans la *base* précisée. Si la *base* n'est pas "
"spécifiée, le logarithme *naturel* (népérien) de *x* est renvoyé. Il y a une "
"coupure, partant de 0 sur l'axe réel négatif et vers ``-∞``, continue par au-"
"dessus."

#: library/cmath.rst:111
msgid ""
"Return the base-10 logarithm of *x*. This has the same branch cut as :func:"
"`log`."
msgstr ""
"Renvoie le logarithme en base 10 de *x*. Elle a la même coupure que :func:"
"`log`."

#: library/cmath.rst:117
msgid ""
"Return the square root of *x*. This has the same branch cut as :func:`log`."
msgstr ""
"Renvoie la racine carrée de *x*. Elle a la même coupure que :func:`log`."

#: library/cmath.rst:121
msgid "Trigonometric functions"
msgstr "Fonctions trigonométriques"

#: library/cmath.rst:125
#, fuzzy
msgid ""
"Return the arc cosine of *x*. There are two branch cuts: One extends right "
"from 1 along the real axis to ∞. The other extends left from -1 along the "
"real axis to -∞."
msgstr ""
"Renvoie l'arc cosinus de *x*. Il y a deux coupures : une allant de 1 sur "
"l'axe réel vers ∞, continue par en-dessous ; l'autre allant de ``-1`` sur "
"l'axe réel vers ``-∞``, continue par au-dessus."

#: library/cmath.rst:132
msgid ""
"Return the arc sine of *x*. This has the same branch cuts as :func:`acos`."
msgstr ""
"Renvoie l'arc sinus de *x*. Elle a les mêmes coupures que :func:`acos`."

#: library/cmath.rst:137
#, fuzzy
msgid ""
"Return the arc tangent of *x*. There are two branch cuts: One extends from "
"``1j`` along the imaginary axis to ``∞j``. The other extends from ``-1j`` "
"along the imaginary axis to ``-∞j``."
msgstr ""
"Renvoie la tangente de *x*. l y a deux coupures : une allant de ``1j`` sur "
"l'axe imaginaire vers ``∞j``, continue par la droite ; l'autre allant de "
"``-1j`` sur l'axe imaginaire vers ``-∞j``, continue par la gauche."

#: library/cmath.rst:144
msgid "Return the cosine of *x*."
msgstr "Renvoie le cosinus de *x*."

#: library/cmath.rst:149
msgid "Return the sine of *x*."
msgstr "Renvoie le sinus de *x*."

#: library/cmath.rst:154
msgid "Return the tangent of *x*."
msgstr "Renvoie la tangente de *x*."

#: library/cmath.rst:158
msgid "Hyperbolic functions"
msgstr "Fonctions hyperboliques"

#: library/cmath.rst:162
#, fuzzy
msgid ""
"Return the inverse hyperbolic cosine of *x*. There is one branch cut, "
"extending left from 1 along the real axis to -∞."
msgstr ""
"Renvoie l'arc cosinus hyperbolique de *x*. Il y a une coupure, allant de 1 "
"sur l'axe réel vers ``-∞``, continue par au-dessus."

#: library/cmath.rst:168
#, fuzzy
msgid ""
"Return the inverse hyperbolic sine of *x*. There are two branch cuts: One "
"extends from ``1j`` along the imaginary axis to ``∞j``.  The other extends "
"from ``-1j`` along the imaginary axis to ``-∞j``."
msgstr ""
"Renvoie l'arc sinus hyperbolique de *x*. Il y a deux coupures : une allant "
"de ``1j`` sur l'axe imaginaire vers ``∞j``, continue par la droite ; l'autre "
"allant de ``-1j`` sur l'axe imaginaire vers ``∞j``, continue par la gauche."

#: library/cmath.rst:175
#, fuzzy
msgid ""
"Return the inverse hyperbolic tangent of *x*. There are two branch cuts: One "
"extends from ``1`` along the real axis to ``∞``. The other extends from "
"``-1`` along the real axis to ``-∞``."
msgstr ""
"Renvoie l'arc tangente hyperbolique de *x*. Il y a deux coupures : une "
"allant de ``1`` sur l'axe réel allant vers ``∞``, continue par en-dessous ; "
"l'autre allant de ``-1`` sur l'axe réel vers ``-∞``, continue par au-dessus."

#: library/cmath.rst:182
msgid "Return the hyperbolic cosine of *x*."
msgstr "Renvoie le cosinus hyperbolique de *x*."

#: library/cmath.rst:187
msgid "Return the hyperbolic sine of *x*."
msgstr "Renvoie le sinus hyperbolique de *x*."

#: library/cmath.rst:192
msgid "Return the hyperbolic tangent of *x*."
msgstr "Renvoie la tangente hyperbolique de *x*."

#: library/cmath.rst:196
msgid "Classification functions"
msgstr "Fonctions de classifications"

#: library/cmath.rst:200
msgid ""
"Return ``True`` if both the real and imaginary parts of *x* are finite, and "
"``False`` otherwise."
msgstr ""
"Renvoie ``True`` si la partie réelle *et* la partie imaginaire de *x* sont "
"finies, et ``False`` sinon."

#: library/cmath.rst:208
msgid ""
"Return ``True`` if either the real or the imaginary part of *x* is an "
"infinity, and ``False`` otherwise."
msgstr ""
"Renvoie ``True`` si soit la partie réelle *ou* la partie imaginaire de *x* "
"est infinie, et ``False`` sinon."

#: library/cmath.rst:214
msgid ""
"Return ``True`` if either the real or the imaginary part of *x* is a NaN, "
"and ``False`` otherwise."
msgstr ""
"Renvoie ``True`` si soit la partie réelle *ou* la partie imaginaire de *x* "
"est NaN, et ``False`` sinon."

#: library/cmath.rst:220
msgid ""
"Return ``True`` if the values *a* and *b* are close to each other and "
"``False`` otherwise."
msgstr ""
"Renvoie ``True`` si les valeurs *a* et *b* sont proches l'une de l'autre, et "
"``False`` sinon."

#: library/cmath.rst:223
msgid ""
"Whether or not two values are considered close is determined according to "
"given absolute and relative tolerances."
msgstr ""
"Déterminer si deux valeurs sont proches se fait à l'aide des tolérances "
"absolues et relatives données en paramètres."

#: library/cmath.rst:226
msgid ""
"*rel_tol* is the relative tolerance -- it is the maximum allowed difference "
"between *a* and *b*, relative to the larger absolute value of *a* or *b*. "
"For example, to set a tolerance of 5%, pass ``rel_tol=0.05``.  The default "
"tolerance is ``1e-09``, which assures that the two values are the same "
"within about 9 decimal digits.  *rel_tol* must be greater than zero."
msgstr ""
"*rel_tol* est la tolérance relative -- c'est la différence maximale permise "
"entre *a* et *b*, relativement à la plus grande valeur de *a* ou de *b*. Par "
"exemple, pour définir une tolérance de 5%,, précisez ``rel_tol=0.05``. La "
"tolérance par défaut est ``1e-09``, ce qui assure que deux valeurs sont les "
"mêmes à partir de la 9\\ :sup:`e` décimale. *rel_tol* doit être supérieur à "
"zéro."

#: library/cmath.rst:232
msgid ""
"*abs_tol* is the minimum absolute tolerance -- useful for comparisons near "
"zero. *abs_tol* must be at least zero."
msgstr ""
"*abs_tol* est la tolérance absolue minimale -- utile pour les comparaisons "
"proches de zéro. *abs_tol* doit valoir au moins zéro."

#: library/cmath.rst:235
msgid ""
"If no errors occur, the result will be: ``abs(a-b) <= max(rel_tol * "
"max(abs(a), abs(b)), abs_tol)``."
msgstr ""
"Si aucune erreur n'est rencontrée, le résultat sera : ``abs(a-b) <= "
"max(rel_tol * max(abs(a), abs(b)), abs_tol)``."

#: library/cmath.rst:238
msgid ""
"The IEEE 754 special values of ``NaN``, ``inf``, and ``-inf`` will be "
"handled according to IEEE rules.  Specifically, ``NaN`` is not considered "
"close to any other value, including ``NaN``.  ``inf`` and ``-inf`` are only "
"considered close to themselves."
msgstr ""
"Les valeurs spécifiques suivantes : ``NaN``, ``inf``, et ``-inf`` définies "
"dans la norme IEEE 754  seront manipulées selon les règles du standard IEEE. "
"En particulier, ``NaN`` n'est considéré proche d'aucune autre valeur, "
"``NaN`` inclus. ``inf`` et ``-inf`` ne sont considérés proches que d'eux-"
"mêmes."

#: library/cmath.rst:247
msgid ":pep:`485` -- A function for testing approximate equality"
msgstr ":pep:`485` -- Une fonction pour tester des égalités approximées"

#: library/cmath.rst:251
msgid "Constants"
msgstr "Constantes"

#: library/cmath.rst:255
msgid "The mathematical constant *π*, as a float."
msgstr "La constante mathématique *π*, en tant que flottant."

#: library/cmath.rst:260
msgid "The mathematical constant *e*, as a float."
msgstr "La constante mathématique *e*, en tant que flottant."

#: library/cmath.rst:265
msgid "The mathematical constant *τ*, as a float."
msgstr "La constante mathématique *τ*, sous forme de flottant."

#: library/cmath.rst:272
msgid "Floating-point positive infinity. Equivalent to ``float('inf')``."
msgstr ""
"Nombre à virgule flottante positif infini. Équivaut à ``float('inf')``."

#: library/cmath.rst:279
msgid ""
"Complex number with zero real part and positive infinity imaginary part. "
"Equivalent to ``complex(0.0, float('inf'))``."
msgstr ""
"Nombre complexe dont la partie réelle vaut zéro et la partie imaginaire un "
"infini positif. Équivalent à ``complex(0.0, float('inf'))``."

#: library/cmath.rst:287
msgid ""
"A floating-point \"not a number\" (NaN) value.  Equivalent to "
"``float('nan')``."
msgstr ""
"Un nombre à virgule flottante *NaN* (*Not a number*). Équivalent à "
"``float('nan')``."

#: library/cmath.rst:295
msgid ""
"Complex number with zero real part and NaN imaginary part. Equivalent to "
"``complex(0.0, float('nan'))``."
msgstr ""
"Nombre complexe dont la partie réelle vaut zéro et la partie imaginaire vaut "
"un *NaN*. Équivalent à ``complex(0.0, float('nan'))``."

#: library/cmath.rst:303
msgid ""
"Note that the selection of functions is similar, but not identical, to that "
"in module :mod:`math`.  The reason for having two modules is that some users "
"aren't interested in complex numbers, and perhaps don't even know what they "
"are.  They would rather have ``math.sqrt(-1)`` raise an exception than "
"return a complex number. Also note that the functions defined in :mod:"
"`cmath` always return a complex number, even if the answer can be expressed "
"as a real number (in which case the complex number has an imaginary part of "
"zero)."
msgstr ""
"Notez que la sélection de fonctions est similaire, mais pas identique, à "
"celles du module :mod:`math`. La raison d'avoir deux modules est que "
"certains utilisateurs ne sont pas intéressés par les nombres complexes, et "
"peut-être ne savent même pas ce qu'ils sont. Ils préféreraient alors que "
"``math.sqrt(-1)`` lève une exception au lieu de renvoyer un nombre complexe. "
"Également, notez que les fonctions définies dans :mod:`cmath` renvoient "
"toujours un nombre complexe, même si le résultat peut être exprimé à l'aide "
"d'un nombre réel (en quel cas la partie imaginaire du complexe vaut zéro)."

#: library/cmath.rst:311
msgid ""
"A note on branch cuts: They are curves along which the given function fails "
"to be continuous.  They are a necessary feature of many complex functions.  "
"It is assumed that if you need to compute with complex functions, you will "
"understand about branch cuts.  Consult almost any (not too elementary) book "
"on complex variables for enlightenment.  For information of the proper "
"choice of branch cuts for numerical purposes, a good reference should be the "
"following:"
msgstr ""
"Une note sur les *coupures* : ce sont des courbes sur lesquelles la fonction "
"n'est pas continue. Ce sont des caractéristiques nécessaires de beaucoup de "
"fonctions complexes. Il est supposé que si vous avez besoin d'utiliser des "
"fonctions complexes, vous comprendrez ce que sont les coupures. Consultez "
"n'importe quel livre (pas trop élémentaire) sur les variables complexes pour "
"plus d'informations. Pour des informations sur les choix des coupures à des "
"fins numériques, voici une bonne référence :"

#: library/cmath.rst:321
msgid ""
"Kahan, W:  Branch cuts for complex elementary functions; or, Much ado about "
"nothing's sign bit.  In Iserles, A., and Powell, M. (eds.), The state of the "
"art in numerical analysis. Clarendon Press (1987) pp165--211."
msgstr ""
"Kahan, W:  Branch cuts for complex elementary functions; or, Much ado about "
"nothing's sign bit.  In Iserles, A., and Powell, M. (eds.), The state of the "
"art in numerical analysis. Clarendon Press (1987) pp165--211."

#: library/cmath.rst:301
msgid "module"
msgstr ""

#: library/cmath.rst:301
msgid "math"
msgstr ""

#~ msgid ""
#~ "On platforms with hardware and system-level support for signed zeros, "
#~ "functions involving branch cuts are continuous on *both* sides of the "
#~ "branch cut: the sign of the zero distinguishes one side of the branch cut "
#~ "from the other.  On platforms that do not support signed zeros the "
#~ "continuity is as specified below."
#~ msgstr ""
#~ "Sur les plate-formes  avec un support système et matériel des zéros "
#~ "signés, les fonctions incluant une coupure complexe sont continues *de "
#~ "chaque* côté de la coupure : le signe du zéro distingue les deux "
#~ "extrémités de la coupure. Sur les plate-formes ne supportant pas les "
#~ "zéros signés, la continuité est spécifiée en-dessous."
