# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-28 15:29+0200\n"
"PO-Revision-Date: 2019-03-19 23:28+0100\n"
"Last-Translator: Julien Palard <julien@palard.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.1.1\n"

#: ../Doc/library/multiprocessing.rst:2
msgid ":mod:`multiprocessing` --- Process-based parallelism"
msgstr ":mod:`multiprocessing` — Parallélisme par processus"

#: ../Doc/library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**Code source  :** :source:`Lib/multiprocessing/`"

#: ../Doc/library/multiprocessing.rst:12
msgid "Introduction"
msgstr "Introduction"

#: ../Doc/library/multiprocessing.rst:14
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock` by using subprocesses instead of "
"threads.  Due to this, the :mod:`multiprocessing` module allows the "
"programmer to fully leverage multiple processors on a given machine.  It "
"runs on both Unix and Windows."
msgstr ""
":mod:`multiprocessing` est un paquet qui permet l'instanciation de processus "
"via la même API que le module :mod:`threading`. Le paquet :mod:"
"`multiprocessing` offre à la fois des possibilités de programmation "
"concurrente locale ou à distance, contournant les problèmes du :term:`Global "
"Interpreter Lock` en utilisant des processus plutôt que des fils "
"d'exécution. Ainsi, le module :mod:`multiprocessing` permet au développeur "
"de bénéficier entièrement des multiples processeurs sur une machine. Il "
"tourne à la fois sur les systèmes Unix et Windows."

#: ../Doc/library/multiprocessing.rst:22
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the :"
"class:`~multiprocessing.pool.Pool` object which offers a convenient means of "
"parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using :class:"
"`~multiprocessing.pool.Pool`, ::"
msgstr ""
"Le module :mod:`multiprocessing` introduit aussi des API sans analogues dans "
"le module :mod:`threading`. Un exemple est l'objet :class:`~multiprocessing."
"pool.Pool` qui offre une manière pratique de paralléliser l'exécution d'une "
"fonction sur de multiples valeurs d'entrée, distribuant ces valeurs entre "
"les processus (parallélisme de données). L'exemple suivant présente la "
"manière classique de définir une telle fonction dans un module afin que les "
"processus fils puissent importer ce module avec succès. L'exemple basique de "
"parallélisme de données utilise :class:`~multiprocessing.pool.Pool`, ::"

#: ../Doc/library/multiprocessing.rst:40
msgid "will print to standard output ::"
msgstr "affiche sur la sortie standard : ::"

#: ../Doc/library/multiprocessing.rst:46
msgid "The :class:`Process` class"
msgstr "La classe :class:`Process`"

#: ../Doc/library/multiprocessing.rst:48
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""
"Dans le module :mod:`multiprocessing`, les processus sont instanciés en "
"créant un objet :class:`Process` et en appelant sa méthode :meth:`~Process."
"start`. La classe :class:`Process` suit la même API que :class:`threading."
"Thread`. Un exemple trivial d'un programme multi-processus est : ::"

#: ../Doc/library/multiprocessing.rst:63
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr ""
"Pour afficher les IDs des processus impliqués, voici un exemple plus "
"étoffé : ::"

#: ../Doc/library/multiprocessing.rst:84
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"La nécessité de la ligne ``if __name__ == '__main__'`` est expliquée par :"
"ref:`multiprocessing-programming`."

#: ../Doc/library/multiprocessing.rst:90
msgid "Contexts and start methods"
msgstr "Contextes et méthodes de démarrage"

#: ../Doc/library/multiprocessing.rst:94
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"Suivant la plateforme, :mod:`multiprocessing` gère trois manières de "
"démarrer un processus. Ces *méthodes de démarrage* sont"

#: ../Doc/library/multiprocessing.rst:105
msgid "*spawn*"
msgstr "*spawn*"

#: ../Doc/library/multiprocessing.rst:98
msgid ""
"The parent process starts a fresh python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"objects :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork* "
"or *forkserver*."
msgstr ""
"Le processus parent démarre un processus neuf avec un interpréteur Python. "
"Le processus fils hérite uniquement des ressources nécessaires pour exécuter "
"la méthode :meth:`~Process.run` de l'objet associé au processus. En "
"particulier, les descripteurs de fichiers superflus et gérés par le "
"processus parent ne sont pas hérités. Démarrer un processus en utilisant "
"cette méthode est plutôt lent par rapport à *fork* ou *forkserver*."

#: ../Doc/library/multiprocessing.rst:105
msgid "Available on Unix and Windows.  The default on Windows."
msgstr "Disponible sur Unix et Windows. Par défaut sur Windows."

#: ../Doc/library/multiprocessing.rst:114
msgid "*fork*"
msgstr "*fork*"

#: ../Doc/library/multiprocessing.rst:108
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The "
"child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"Le processus parent utilise :func:`os.fork` pour *forker* l'interpréteur "
"Python. Le processus fils, quand il démarre, est effectivement identique au "
"processus parent. Toutes les ressources du parent sont héritées par le fils. "
"Notez qu'il est problématique de *forker* sans danger un processus *multi-"
"threadé*."

#: ../Doc/library/multiprocessing.rst:114
msgid "Available on Unix only.  The default on Unix."
msgstr "Disponible uniquement sous Unix. Par défaut sous Unix."

#: ../Doc/library/multiprocessing.rst:125
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../Doc/library/multiprocessing.rst:117
msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is started.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded so it is safe for it to "
"use :func:`os.fork`.  No unnecessary resources are inherited."
msgstr ""
"Quand le programme démarre et choisit la méthode de démarrage *forkserver*, "
"un processus serveur est lancé. Dès lors, chaque fois qu'un nouveau "
"processus est nécessaire, le processus parent se connecte au serveur et lui "
"demande de *forker* un nouveau processus. Le processus serveur de *fork* "
"n'utilisant qu'un seul fil d'exécution, il peut utiliser :func:`os.fork` "
"sans danger. Les ressources superflues ne sont pas héritées."

#: ../Doc/library/multiprocessing.rst:124
msgid ""
"Available on Unix platforms which support passing file descriptors over Unix "
"pipes."
msgstr ""
"Disponible sur les plateformes Unix qui acceptent le passage de descripteurs "
"de fichiers à travers des tubes (*pipes*) Unix."

#: ../Doc/library/multiprocessing.rst:127
msgid ""
"*spawn* added on all unix platforms, and *forkserver* added for some unix "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""
"*spawn* ajouté à toutes les plateformes Unix, et *forkserver* ajouté à "
"certaines plateformes Unix. Les processus fils n'héritent plus de tous les "
"descripteurs héritables du parent sous Windows."

#: ../Doc/library/multiprocessing.rst:133
msgid ""
"On Unix using the *spawn* or *forkserver* start methods will also start a "
"*semaphore tracker* process which tracks the unlinked named semaphores "
"created by processes of the program.  When all processes have exited the "
"semaphore tracker unlinks any remaining semaphores. Usually there should be "
"none, but if a process was killed by a signal there may be some \"leaked\" "
"semaphores.  (Unlinking the named semaphores is a serious matter since the "
"system allows only a limited number, and they will not be automatically "
"unlinked until the next reboot.)"
msgstr ""
"Sous Unix, utiliser les méthodes de démarrage *spawn* ou *forkserver* "
"démarre aussi un processus *semaphore tracker* qui traque les sémaphores "
"nommés non libérés créés par les processus du programme. Quand tous les "
"processus sont terminés, le traqueur de sémaphores libère les sémaphores "
"restants. Généralement il ne devrait pas y en avoir, mais si un processus a "
"été tué par un signal, certains sémaphores ont pu « fuiter ». (Libérer les "
"sémaphores nommés est une affaire sérieuse puisque le système n'en autorise "
"qu'un certain nombre, et qu'ils ne seront pas automatiquement libérés avant "
"le prochain redémarrage.)"

#: ../Doc/library/multiprocessing.rst:142
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"Pour sélectionner une méthode de démarrage, utilisez la fonction :func:"
"`set_start_method` dans la clause ``if __name__ == '__main__'`` du module "
"principal. Par exemple : ::"

#: ../Doc/library/multiprocessing.rst:159
msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr ""
":func:`set_start_method` ne doit pas être utilisée plus d'une fois dans le "
"programme."

#: ../Doc/library/multiprocessing.rst:162
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"Alternativement, vous pouvez utiliser :func:`get_context` pour obtenir un "
"contexte. Les contextes ont la même API que le module *multiprocessing*, et "
"permettent l'utilisation de plusieurs méthodes de démarrage dans un même "
"programme. ::"

#: ../Doc/library/multiprocessing.rst:180
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"Notez que les objets relatifs à un contexte ne sont pas forcément "
"compatibles avec les processus d'un contexte différent. En particulier, les "
"verrous créés avec le contexte *fork* ne peuvent pas être passés aux "
"processus lancés avec les méthodes *spawn* ou *forkserver*."

#: ../Doc/library/multiprocessing.rst:185
msgid ""
"A library which wants to use a particular start method should probably use :"
"func:`get_context` to avoid interfering with the choice of the library user."
msgstr ""
"Une bibliothèque qui veut utiliser une méthode de démarrage particulière "
"devrait probablement faire appel à :func:`get_context` pour éviter "
"d'interférer avec le choix de l'utilisateur de la bibliothèque."

#: ../Doc/library/multiprocessing.rst:191
msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods cannot currently be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on Unix. The ``'fork'`` start method does "
"work."
msgstr ""

#: ../Doc/library/multiprocessing.rst:198
msgid "Exchanging objects between processes"
msgstr "Échange d'objets entre les processus"

#: ../Doc/library/multiprocessing.rst:200
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ""
":mod:`multiprocessing` gère deux types de canaux de communication entre les "
"processus :"

#: ../Doc/library/multiprocessing.rst:203
msgid "**Queues**"
msgstr "**Queues**"

#: ../Doc/library/multiprocessing.rst:205
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ""
"La classe :class:`Queue` est un clone assez proche de :class:`queue.Queue`. "
"Par exemple : ::"

#: ../Doc/library/multiprocessing.rst:220
msgid "Queues are thread and process safe."
msgstr ""
"Les queues peuvent être utilisées par plusieurs fils d'exécution ou "
"processus."

#: ../Doc/library/multiprocessing.rst:222
msgid "**Pipes**"
msgstr "**Tubes** (*pipes*)"

#: ../Doc/library/multiprocessing.rst:224
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""
"La fonction :func:`Pipe` renvoie une paire d'objets de connexion connectés à "
"un tube qui est par défaut à double-sens. Par exemple : ::"

#: ../Doc/library/multiprocessing.rst:240
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""
"Les deux objets de connexion renvoyés par :func:`Pipe` représentent les deux "
"bouts d'un tube. Chaque objet de connexion possède (entre autres) des "
"méthodes :meth:`~Connection.send` et :meth:`~Connection.recv`. Notez que les "
"données d'un tube peuvent être corrompues si deux processus (ou fils "
"d'exécution) essaient de lire ou d'écrire sur le même bout du tube en même "
"temps. Évidemment il n'y a pas de risque de corruption si les processus "
"utilisent deux bouts différents en même temps."

#: ../Doc/library/multiprocessing.rst:250
msgid "Synchronization between processes"
msgstr "Synchronisation entre processus"

#: ../Doc/library/multiprocessing.rst:252
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` contient des équivalents à toutes les primitives de "
"synchronisation de :mod:`threading`. Par exemple il est possible d'utiliser "
"un verrou pour s'assurer qu'un seul processus à la fois écrit sur la sortie "
"standard : ::"

#: ../Doc/library/multiprocessing.rst:271
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr ""
"Sans le verrou, les sorties des différents processus risquent d'être "
"mélangées."

#: ../Doc/library/multiprocessing.rst:276
msgid "Sharing state between processes"
msgstr "Partager un état entre les processus"

#: ../Doc/library/multiprocessing.rst:278
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr ""
"Comme mentionné plus haut, il est généralement préférable d'éviter autant "
"que possible d'utiliser des états partagés en programmation concurrente. "
"C'est particulièrement vrai quand plusieurs processus sont utilisés."

#: ../Doc/library/multiprocessing.rst:282
msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr ""
"Cependant, si vous devez réellement partager des données, :mod:"
"`multiprocessing` permet de le faire de deux manières."

#: ../Doc/library/multiprocessing.rst:285
msgid "**Shared memory**"
msgstr "**Mémoire partagée**"

#: ../Doc/library/multiprocessing.rst:287
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr ""
"Les données peuvent être stockées dans une mémoire partagée en utilisant "
"des :class:`Value` ou des :class:`Array`. Par exemple, le code suivant : ::"

#: ../Doc/library/multiprocessing.rst:308
#: ../Doc/library/multiprocessing.rst:354
msgid "will print ::"
msgstr "affiche : ::"

#: ../Doc/library/multiprocessing.rst:313
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread-safe."
msgstr ""
"Les arguments ``'d'`` et ``'i'`` utilisés à la création des ``num`` et "
"`arr`` sont des codes de types tels qu'utilisés par le module :mod:`array` : "
"``'d'`` indique un flottant double-précision et ``'i'`` indique un entier "
"signé. Ces objets partagés seront sûr d'utilisation entre processus et fils "
"d'exécution."

#: ../Doc/library/multiprocessing.rst:318
msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"Pour plus de flexibilité dans l'utilisation de mémoire partagée, vous pouvez "
"utiliser le module :mod:`multiprocessing.sharedctypes` qui permet la "
"création d'objets arbitraires *ctypes* alloués depuis la mémoire partagée."

#: ../Doc/library/multiprocessing.rst:322
msgid "**Server process**"
msgstr "**Processus serveur**"

#: ../Doc/library/multiprocessing.rst:324
msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""
"Un objet gestionnaire renvoyé par :func:`Manager` contrôle un processus "
"serveur qui détient les objets Python et autorise les autres processus à les "
"manipuler à l'aide de mandataires."

#: ../Doc/library/multiprocessing.rst:328
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, :"
"class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :class:"
"`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and :class:"
"`Array`.  For example, ::"
msgstr ""
"Un gestionnaire renvoyé par :func:`Manager` supportera les types :class:"
"`list`, :class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:"
"`RLock`, :class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :"
"class:`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` et :class:"
"`Array`. Par exemple, ::"

#: ../Doc/library/multiprocessing.rst:359
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"Les processus serveurs de gestionnaires sont plus flexibles que les mémoires "
"partagées parce qu'ils peuvent gérer des types d'objets arbitraires. Aussi, "
"un gestionnaire unique peut être partagé par les processus sur différentes "
"machines à travers le réseau. Cependant, ils sont plus lents que les "
"mémoires partagées."

#: ../Doc/library/multiprocessing.rst:366
msgid "Using a pool of workers"
msgstr "Utiliser un réservoir de *workers*"

#: ../Doc/library/multiprocessing.rst:368
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
"La classe :class:`~multiprocessing.pool.Pool` représente une *pool* de "
"processus de travail. Elle possède des méthodes qui permettent aux tâches "
"d'être déchargées vers les processus de travail de différentes manières."

#: ../Doc/library/multiprocessing.rst:372
msgid "For example::"
msgstr "Par exemple ::"

#: ../Doc/library/multiprocessing.rst:416
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr ""
"Notez que les méthodes d'une *pool* ne devraient être utilisées que par le "
"processus qui l'a créée."

#: ../Doc/library/multiprocessing.rst:421
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"Fonctionnellement ce paquet exige que que le module ``__main__`` soit "
"importable par les fils. Cela est expliqué sur la page :ref:`multiprocessing-"
"programming`, il est cependant utile de le rappeler ici. Cela signifie que "
"certains exemples, comme les exemples utilisant :class:`multiprocessing.pool."
"Pool`, ne fonctionnent pas dans l'interpréteur interactif. Par exemple : ::"

#: ../Doc/library/multiprocessing.rst:443
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the master process "
"somehow.)"
msgstr ""
"(Si vous essayez ce code, il affichera trois traces d'appels complètes "
"entrelacées de manière semi-aléatoire, et vous aurez alors à stopper le "
"processus maître.)"

#: ../Doc/library/multiprocessing.rst:449
msgid "Reference"
msgstr "Référence"

#: ../Doc/library/multiprocessing.rst:451
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ""
"Le paquet :mod:`multiprocessing` reproduit en grande partie l'API du module :"
"mod:`threading`."

#: ../Doc/library/multiprocessing.rst:456
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` et exceptions"

#: ../Doc/library/multiprocessing.rst:461
msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""
"Les objets *process* représentent une activité exécutée dans un processus "
"séparé. La classe :class:`Process` a des équivalents à toutes les méthodes "
"de :class:`threading.Thread`."

#: ../Doc/library/multiprocessing.rst:465
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run()` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name (see :attr:`name` for more details). *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  If provided, the keyword-only "
"*daemon* argument sets the process :attr:`daemon` flag to ``True`` or "
"``False``.  If ``None`` (the default), this flag will be inherited from the "
"creating process."
msgstr ""
"Le constructeur doit toujours être appelé avec des arguments nommés. *group* "
"devrait toujours être ``None`` ; il existe uniquement pour la compatibilité "
"avec :class:`threading.Thread`. *target* est l'objet appelable qui est "
"invoqué par la méthode :meth:`run(). Il vaut ``None`` par défaut, signifiant "
"que rien n'est appelé. *name* est le nom du processus (voir :attr:`name` "
"pour plus de détails). *args* est le *tuple* d'arguments pour l'invocation "
"de la cible. *kwargs* est le dictionnaire des arguments nommés pour "
"l'invocation de la cible. S'il est fourni, l'argument nommé *daemon* met "
"l'option :attr:`daemon` du processus à ``True`` ou ``False``. S'il est "
"``None`` (par défaut), l'option est héritée par le processus créateur."

#: ../Doc/library/multiprocessing.rst:476
msgid "By default, no arguments are passed to *target*."
msgstr "Par défaut, aucun argument n'est passé à *target*."

#: ../Doc/library/multiprocessing.rst:478
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else "
"to the process."
msgstr ""
"Si une sous-classe redéfinit le constructeur, elle doit s'assurer d'invoquer "
"le constructeur de la classe de base (:meth:`Process.__init__`) avant de "
"faire autre chose du processus."

#: ../Doc/library/multiprocessing.rst:482
msgid "Added the *daemon* argument."
msgstr "Ajout de l'argument *daemon*."

#: ../Doc/library/multiprocessing.rst:487
msgid "Method representing the process's activity."
msgstr "Méthode représentant l'activité du processus."

#: ../Doc/library/multiprocessing.rst:489
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""
"Vous pouvez redéfinir cette méthode dans une sous-classe. La méthode "
"standard :meth:`run` invoque l'objet appelable passé au constructeur comme "
"argument *target*, si fourni, avec les arguments séquentiels et nommés "
"respectivement pris depuis les paramètres *args* et *kwargs*."

#: ../Doc/library/multiprocessing.rst:496
msgid "Start the process's activity."
msgstr "Démarre l'activité du processus."

#: ../Doc/library/multiprocessing.rst:498
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"Elle doit être appelée au plus une fois par objet processus. Elle s'arrange "
"pour que la méthode :meth:`run` de l'objet soit invoquée dans un processus "
"séparé."

#: ../Doc/library/multiprocessing.rst:503
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"Si l'argument optionnel *timeout* est ``None`` (par défaut), la méthode "
"bloque jusqu'à ce que le processus dont la méthode :meth:`join` a été "
"appelée se termine. Si *timeout* est un nombre positif, elle bloque au "
"maximum pendant *timeout* secondes. Notez que la méthode renvoie ``None`` si "
"le processus se termine ou si le temps d'exécution expire. Vérifiez "
"l'attribut :attr:`exitcode` du processus pour déterminer s'il s'est terminé."

#: ../Doc/library/multiprocessing.rst:510
msgid "A process can be joined many times."
msgstr "*join* peut être appelée plusieurs fois sur un même processus."

#: ../Doc/library/multiprocessing.rst:512
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""
"Un processus ne peut pas s'attendre lui-même car cela causerait un "
"interblocage. C'est une erreur d'essayer d'attendre un processus avant qu'il "
"ne soit démarré."

#: ../Doc/library/multiprocessing.rst:517
msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr ""
"Le nom du processus. Le nom est une chaîne de caractères utilisée uniquement "
"pour l'identification du processus. Il n'a pas de sémantique. Plusieurs "
"processus peuvent avoir le même nom."

#: ../Doc/library/multiprocessing.rst:521
msgid ""
"The initial name is set by the constructor.  If no explicit name is provided "
"to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the N-th "
"child of its parent."
msgstr ""
"Le nom initial est déterminé par le constructeur. Si aucun nom explicite "
"n'est fourni au constructeur, un nom de la forme « Process-N\\ :sub:`1`:N\\ :"
"sub:`2`:...:N\\ :sub:`k` » est construit, où chaque N\\ :sub:`k` est le N-"
"ième enfant de son parent."

#: ../Doc/library/multiprocessing.rst:528
msgid "Return whether the process is alive."
msgstr "Renvoie vrai si le processus est en vie, faux sinon."

#: ../Doc/library/multiprocessing.rst:530
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr ""
"Grossièrement, un objet processus est en vie depuis le moment où la méthode :"
"meth:`start` finit de s'exécuter jusqu'à ce que le processus fils se termine."

#: ../Doc/library/multiprocessing.rst:535
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr ""
"L'option *daemon* du processus, une valeur booléenne. L'option doit être "
"réglée avant que la méthode :meth:`start` ne soit appelée."

#: ../Doc/library/multiprocessing.rst:538
msgid "The initial value is inherited from the creating process."
msgstr "La valeur initiale est héritée par le processus créateur."

#: ../Doc/library/multiprocessing.rst:540
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr ""
"Quand un processus se ferme, il tente de terminer tous ses processus enfants "
"*daemon*."

#: ../Doc/library/multiprocessing.rst:543
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"Notez qu'un processus *daemon* n'est pas autorisé à créer des processus "
"fils. Sinon un processus *daemon* laisserait ses enfants orphelins lorsqu'il "
"se termine par la fermeture de son parent. De plus, ce **ne sont pas** des "
"*daemons* ou services Unix, ce sont des processus normaux qui seront "
"terminés (et non attendus) si un processus non *daemon* se ferme."

#: ../Doc/library/multiprocessing.rst:549
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""
"En plus de l'API :class:`threading.Thread`, les objets :class:`Process` "
"supportent aussi les attributs et méthodes suivants :"

#: ../Doc/library/multiprocessing.rst:554
msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr ""
"Renvoie l'ID du processus. Avant que le processus ne soit lancé, la valeur "
"est ``None``."

#: ../Doc/library/multiprocessing.rst:559
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated.  A negative value *-N* indicates that the child was terminated "
"by signal *N*."
msgstr ""
"Le code de fermeture de l'enfant. La valeur est ``None`` si le processus ne "
"s'est pas encore terminé. Une valeur négative *-N* indique que le fils a été "
"terminé par un signal *N*."

#: ../Doc/library/multiprocessing.rst:565
msgid "The process's authentication key (a byte string)."
msgstr "La clé d'authentification du processus (une chaîne d'octets)."

#: ../Doc/library/multiprocessing.rst:567
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ""
"Quand :mod:`multiprocessing` est initialisé, une chaîne aléatoire est "
"assignée au processus principal, en utilisant :func:`os.urandom`."

#: ../Doc/library/multiprocessing.rst:570
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
"Quand un objet :class:`Process` est créé, il hérité de la clé "
"d'authentification de son parent, bien que cela puisse être changé à l'aide "
"du paramètre :attr:`authkey` pour une autre chaîne d'octets."

#: ../Doc/library/multiprocessing.rst:574
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "Voir :ref:`multiprocessing-auth-keys`."

#: ../Doc/library/multiprocessing.rst:578
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr ""
"Un identifiant numérique de l'objet système qui devient « prêt » quand le "
"processus se termine."

#: ../Doc/library/multiprocessing.rst:581
msgid ""
"You can use this value if you want to wait on several events at once using :"
"func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join()` is "
"simpler."
msgstr ""
"Vous pouvez utiliser cette valeur si vous voulez attendre plusieurs "
"événements à la fois en utilisant :func:`multiprocessing.connection.wait`. "
"Autrement appeler :meth:`join()` est plus simple."

#: ../Doc/library/multiprocessing.rst:585
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and "
"``WaitForMultipleObjects`` family of API calls.  On Unix, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"Sous Windows, c'est un mécanisme de l'OS utilisable avec les familles "
"d'appels API ``WaitForSingleObject`` et ``WaitForMultipleObjects``. Sous "
"Unix, c'est un descripteur de fichier utilisable avec les primitives sur "
"module :mod:`select`."

#: ../Doc/library/multiprocessing.rst:593
msgid ""
"Terminate the process.  On Unix this is done using the ``SIGTERM`` signal; "
"on Windows :c:func:`TerminateProcess` is used.  Note that exit handlers and "
"finally clauses, etc., will not be executed."
msgstr ""
"Termine le processus. Sous Unix cela est réalisé à l'aide d'un signal "
"``SIGTERM``, sous Windows :c:func:`TerminateProcess` est utilisé. Notez que "
"les gestionnaires de sortie, les clauses `finally` etc. ne sont pas "
"exécutées."

#: ../Doc/library/multiprocessing.rst:597
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr ""
"Notez que les descendants du processus ne *seront pas* terminés -- ils "
"deviendront simplement orphelins."

#: ../Doc/library/multiprocessing.rst:602
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"Si cette méthode est utilisée quand le processus associé utilise un tube ou "
"une queue, alors le tube ou la queue sont susceptibles d'être corrompus et "
"peuvent devenir inutilisables par les autres processus. De façon similaire, "
"si le processus a acquis un verrou, un sémaphore ou autre, alors le terminer "
"est susceptible de provoquer des blocages dans les autres processus."

#: ../Doc/library/multiprocessing.rst:610
msgid "Same as :meth:`terminate()` but using the ``SIGKILL`` signal on Unix."
msgstr ""
"Identique à :meth:`terminate()` mais utilisant le signal ``SIGKILL`` sous "
"Unix."

#: ../Doc/library/multiprocessing.rst:616
msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and "
"attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
"Ferme l'objet :class:`Process`, libérant toutes les ressources qui lui sont "
"associées. Une :exc:`ValueError` est levée si le processus sous-jacent "
"tourne toujours. Une fois que :meth:`close` se termine avec succès, la "
"plupart des autres méthodes et attributs des objets :class:`Process` "
"lèveront une :exc:`ValueError`."

#: ../Doc/library/multiprocessing.rst:624
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"Notez que les méthodes :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` et :attr:`exitcode` ne devraient être appelées que par le "
"processus ayant créé l'objet *process*."

#: ../Doc/library/multiprocessing.rst:628
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "Exemple d'utilisation de quelques méthodes de :class:`Process` :"

#: ../Doc/library/multiprocessing.rst:648
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "La classe de base de toutes les exceptions de :mod:`multiprocessing`."

#: ../Doc/library/multiprocessing.rst:652
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the supplied "
"buffer object is too small for the message read."
msgstr ""
"Exception levée par :meth:`Connection.recv_bytes_into()` quand l'objet "
"tampon fourni est trop petit pour le message à lire."

#: ../Doc/library/multiprocessing.rst:655
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"Si ``e`` est une instance de :exc:`BufferTooShort` alors ``e.args[0]`` "
"donnera un message sous forme d'une chaîne d'octets."

#: ../Doc/library/multiprocessing.rst:660
msgid "Raised when there is an authentication error."
msgstr "Levée quand il y a une erreur d'authentification."

#: ../Doc/library/multiprocessing.rst:664
msgid "Raised by methods with a timeout when the timeout expires."
msgstr ""
"Levée par les méthodes avec temps d'exécution limité, quand ce temps expire."

#: ../Doc/library/multiprocessing.rst:667
msgid "Pipes and Queues"
msgstr "Tubes (*pipes*) et Queues"

#: ../Doc/library/multiprocessing.rst:669
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr ""
"Quand de multiples processus sont utilisés, de l'échange de messages est "
"souvent mis en place pour la communication entre processus et éviter d'avoir "
"à utiliser des primitives de synchronisation telles que des verrous."

#: ../Doc/library/multiprocessing.rst:673
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""
"Pour échanger des messages vous pouvez utiliser un :func:`Pipe` (pour une "
"connexion entre deux processus) ou une queue (qui autorise de multiples "
"producteurs et consommateurs)."

#: ../Doc/library/multiprocessing.rst:676
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues "
"modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and :"
"meth:`~queue.Queue.join` methods introduced into Python 2.5's :class:`queue."
"Queue` class."
msgstr ""
"Les types :class:`Queue`, :class:`SimpleQueue` et :class:`JoinableQueue` "
"sont des queues :abbr:`FIFO (first-in, first-out)` multi-producteurs et "
"multi-consommateurs modelées sur la classe :class:`queue.Queue` de la "
"bibliothèque standard. Elles diffèrent par l'absence dans :class:`Queue` des "
"méthodes :meth:`~queue.Queue.task_done` et :meth:`~queue.Queue.join` "
"introduites dans la classe :class:`queue.Queue` par Python 2.5."

#: ../Doc/library/multiprocessing.rst:683
msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"Si vous utilisez :class:`JoinableQueue` alors vous **devez** appeler :meth:"
"`JoinableQueue.task_done` pour chaque tâche retirée de la queue, sans quoi "
"le sémaphore utilisé pour compter le nombre de tâches non accomplies pourra "
"éventuellement déborder, levant une exception."

#: ../Doc/library/multiprocessing.rst:688
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""
"Notez que vous pouvez aussi créer une queue partagée en utilisant un objet "
"gestionnaire -- voir :ref:`multiprocessing-managers`."

#: ../Doc/library/multiprocessing.rst:693
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and :exc:`queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`queue`."
msgstr ""
":mod:`multiprocessing` utilise les exceptions habituelles :exc:`queue.Empty` "
"et :exc:`queue.Full` pour signaler un dépassement du temps maximal autorisé. "
"Elles ne sont pas disponibles dans l'espace de nommage :mod:"
"`multiprocessing` donc vous devez les importer depuis le module :mod:`queue`."

#: ../Doc/library/multiprocessing.rst:700
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use "
"a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"Quand un objet est placé dans une queue, l'objet est sérialisé par *pickle* "
"et un fil d'exécution en arrière-plan transmettra ensuite les données "
"sérialisées sur un tube sous-jacent. Cela a certaines conséquences qui "
"peuvent être un peu surprenantes, mais ne devrait causer aucune difficultés "
"pratiques -- si elles vous embêtent vraiment, alors vous pouvez à la place "
"utiliser une queue créée avec un :ref:`manager <multiprocessing-managers>`."

#: ../Doc/library/multiprocessing.rst:707
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"Après avoir placé un objet dans une queue vide il peut y avoir un délai "
"infinitésimal avant que la méthode :meth:`~Queue.empty` de la queue renvoie :"
"const:`False` et que :meth:`~Queue.get_nowait` renvoie une valeur sans lever "
"de :exc:`queue.Empty`."

#: ../Doc/library/multiprocessing.rst:712
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"Si plusieurs processus placent des objets dans la queue, il est possible "
"pour les objets d'être reçus de l'autre côté dans le désordre. Cependant, "
"les objets placés par un même processus seront toujours récupérés dans "
"l'ordre attendu."

#: ../Doc/library/multiprocessing.rst:719
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
"Si un processus est tué à l'aide de :meth:`Process.terminate` ou :func:`os."
"kill` pendant qu'il tente d'utiliser une :class:`Queue`, alors les données "
"de la queue peuvent être corrompues. Cela peut par la suite causer des "
"levées d'exceptions dans les autres processus quand ils tenteront d'utiliser "
"la queue."

#: ../Doc/library/multiprocessing.rst:726
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), then that process will not terminate until all "
"buffered items have been flushed to the pipe."
msgstr ""
"Comme mentionné plus haut, si un processus fils a placé des éléments dans la "
"queue (et qu'il n'a pas utilisé :meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>`), alors le processus ne se "
"terminera pas tant que les éléments placés dans le tampon n'auront pas été "
"transmis au tube."

#: ../Doc/library/multiprocessing.rst:731
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"Cela signifie que si vous essayez d'attendre ce processus vous pouvez "
"obtenir un interblocage, à moins que vous ne soyez sûr que tous les éléments "
"placés dans la queue ont été consommés. De même, si le processus fils n'est "
"pas un *daemon* alors le processus parent pourrait bloquer à la fermeture "
"quand il tentera d'attendre tous ses enfants non *daemons*."

#: ../Doc/library/multiprocessing.rst:736
msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr ""
"Notez que la queue créée à l'aide d'un gestionnaire n'a pas ce problème. "
"Voir :ref:`multiprocessing-programming`."

#: ../Doc/library/multiprocessing.rst:739
msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr ""
"Pour un exemple d'utilisation de queues pour de la communication entre les "
"processus, voir :ref:`multiprocessing-examples`."

#: ../Doc/library/multiprocessing.rst:745
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`~multiprocessing.connection."
"Connection` objects representing the ends of a pipe."
msgstr ""
"Renvoie une paire ``(conn1, conn2)`` d'objets :class:`~multiprocessing."
"connection.Connection` représentant les bouts d'un tube."

#: ../Doc/library/multiprocessing.rst:749
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"Si *duplex* vaut ``True`` (par défaut), alors le tube est bidirectionnel. Si "
"*duplex* vaut ``False`` il est unidirectionnel : ``conn1`` ne peut être "
"utilisé que pour recevoir des messages et ``conn2`` que pour en envoyer."

#: ../Doc/library/multiprocessing.rst:757
msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr ""
"Renvoie une queue partagée entre les processus utilisant un tube et quelques "
"verrous/sémaphores. Quand un processus place initialement un élément sur la "
"queue, un fil d'exécution *feeder* est démarré pour transférer les objets du "
"tampon vers le tube."

#: ../Doc/library/multiprocessing.rst:761
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"Les exceptions habituelles :exc:`queue.Empty` et :exc:`queue.Full` du "
"module :mod:`queue` de la bibliothèque standard sont levées pour signaler "
"les *timeouts*."

#: ../Doc/library/multiprocessing.rst:764
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` implémente toutes les méthodes de :class:`queue.Queue` à "
"l'exception de :meth:`~queue.Queue.task_done` et :meth:`~queue.Queue.join`."

#: ../Doc/library/multiprocessing.rst:769
msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr ""
"Renvoie la taille approximative de la queue. Ce nombre n'est pas fiable en "
"raison des problématiques de *multithreading* et *multiprocessing*."

#: ../Doc/library/multiprocessing.rst:772
msgid ""
"Note that this may raise :exc:`NotImplementedError` on Unix platforms like "
"Mac OS X where ``sem_getvalue()`` is not implemented."
msgstr ""
"Notez que cela peut lever une :exc:`NotImplementedError` sous les "
"plateformes Unix telles que Mac OS X où ``sem_getvalue()`` n'est pas "
"implémentée."

#: ../Doc/library/multiprocessing.rst:777
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Renvoie ``True`` si la queue est vide, ``False`` sinon. Cette valeur n'est "
"pas fiable en raison des problématiques de *multithreading* et "
"*multiprocessing*."

#: ../Doc/library/multiprocessing.rst:782
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Renvoie ``True`` si la queue est pleine, ``False`` sinon. Cette valeur n'est "
"pas fiable en raison des problématiques de *multithreading* et "
"*multiprocessing*."

#: ../Doc/library/multiprocessing.rst:787
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"Place *obj* dans la queue. Si l'argument optionnel *block* vaut ``True`` "
"(par défaut) est que *timeout* est ``None`` (par défaut), bloque jusqu'à ce "
"qu'un slot libre soit disponible. Si *timeout* est un nombre positif, la "
"méthode bloquera au maximum *timeout* secondes et lèvera une exception :exc:"
"`queue.Full` si aucun slot libre n'a été trouvé dans le temps imparti. "
"Autrement (*block* vaut ``False``), place un élément dans la queue si un "
"slot libre est immédiatement disponible, ou lève une exception :exc:`queue."
"Full` dans le cas contraire (*timeout* est ignoré dans ce cas)."

#: ../Doc/library/multiprocessing.rst:798
msgid "Equivalent to ``put(obj, False)``."
msgstr "Équivalent à ``put(obj, False)``."

#: ../Doc/library/multiprocessing.rst:802
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"Retire et renvoie un élément de la queue. Si l'argument optionnel *block* "
"vaut ``True`` (par défaut) et que *timeout* est ``None`` (par défaut), "
"bloque jusqu'à ce qu'un élément soit disponible. Si *timeout* (le délai "
"maximal autorisé) est un nombre positif, la méthode bloquera au maximum "
"*timeout* secondes et lèvera une exception :exc:`queue.Empty` si aucun "
"élément n'est disponible dans le temps imparti. Autrement (*block* vaut "
"``False``), renvoie un élément s'il est immédiatement disponible, ou lève "
"une exception :exc:`queue.Empty` dans le cas contraire (*timeout* est ignoré "
"dans ce cas)."

#: ../Doc/library/multiprocessing.rst:812
msgid "Equivalent to ``get(False)``."
msgstr "Équivalent à ``get(False)``."

#: ../Doc/library/multiprocessing.rst:814
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` possède quelques méthodes additionnelles non "
"présentes dans :class:`queue.Queue`. Ces méthodes ne sont habituellement pas "
"nécessaires pour la plupart des codes :"

#: ../Doc/library/multiprocessing.rst:820
msgid ""
"Indicate that no more data will be put on this queue by the current "
"process.  The background thread will quit once it has flushed all buffered "
"data to the pipe.  This is called automatically when the queue is garbage "
"collected."
msgstr ""
"Indique que plus aucune donnée ne peut être placée sur la queue par le "
"processus courant. Le fil d'exécution en arrière-plan se terminera quand il "
"aura transféré toutes les données du tampon vers le tube. Elle est appelée "
"automatiquement quand la queue est collectée par le ramasse-miettes."

#: ../Doc/library/multiprocessing.rst:827
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr ""
"Attend le fil d'exécution d'arrière-plan. Elle peut seulement être utilisée "
"une fois que :meth:`close` a été appelée. Elle bloque jusqu'à ce que le fil "
"d'arrière-plan se termine, assurant que toutes les données du tampon ont été "
"transmises au tube."

#: ../Doc/library/multiprocessing.rst:831
msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"Par défaut si un processus n'est pas le créateur de la queue alors à la "
"fermeture elle essaiera d'attendre le fil d'exécution d'arrière-plan de la "
"queue. Le processus peut appeler :meth:`cancel_join_thread` pour que :meth:"
"`join_thread` ne fasse rien."

#: ../Doc/library/multiprocessing.rst:837
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr ""
"Empêche :meth:`join_thread` de bloquer. En particulier, cela empêche le fil "
"d'arrière-plan d'être attendu automatiquement quand le processus se ferme -- "
"voir :meth:`join_thread`."

#: ../Doc/library/multiprocessing.rst:841
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to lost, and you almost certainly will not "
"need to use it. It is really only there if you need the current process to "
"exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""
"Un meilleur nom pour cette méthode pourrait être "
"``allow_exit_without_flush()``. Cela peut provoquer des pertes de données "
"placées dans la queue, et vous ne devriez certainement pas avoir besoin de "
"l'utiliser. Elle n'est là que si vous souhaitez terminer immédiatement le "
"processus sans transférer les données du tampon, et que vous ne vous "
"inquiétez pas de perdre des données."

#: ../Doc/library/multiprocessing.rst:850
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue` "
"will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"Le fonctionnement de cette classe requiert une implémentation de sémaphore "
"partagé sur le système d'exploitation hôte. Sans cela, la fonctionnalité "
"sera désactivée et la tentative d'instancier une :class:`Queue` lèvera une :"
"exc:`ImportError`. Voir :issue:`3770` pour plus d'informations. Cette "
"remarque reste valable pour les autres types de queues spécialisées définies "
"par la suite."

#: ../Doc/library/multiprocessing.rst:859
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked :class:`Pipe`."
msgstr ""
"Un type de :class:`Queue` simplifié, très proche d'un :class:`Pipe` avec "
"verrou."

#: ../Doc/library/multiprocessing.rst:863
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Renvoie ``True`` si la queue est vide, ``False`` sinon."

#: ../Doc/library/multiprocessing.rst:867
msgid "Remove and return an item from the queue."
msgstr "Supprime et renvoie un élément de la queue."

#: ../Doc/library/multiprocessing.rst:871
msgid "Put *item* into the queue."
msgstr "Place *item* dans la queue."

#: ../Doc/library/multiprocessing.rst:876
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue`, une sous-classe de :class:`Queue`, est une queue qui "
"ajoute des méthodes :meth:`task_done` et :meth:`join`."

#: ../Doc/library/multiprocessing.rst:881
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"Indique qu'une tâche précédemment placée dans la queue est complétée. "
"Utilisé par les consommateurs de la queue. Pour chaque :meth:`~Queue.get` "
"utilisé pour récupérer une tâche, un appel ultérieur à :meth:`task_done` "
"indique à la queue que le traitement de la tâche est terminé."

#: ../Doc/library/multiprocessing.rst:886
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Si un :meth:`~queue.Queue.join` est actuellement bloquant, il se débloquera "
"quand tous les éléments auront été traités (signifiant qu'un appel à :meth:"
"`task_done` a été reçu pour chaque élément ayant été placé via :meth:`~Queue."
"put` dans la queue)."

#: ../Doc/library/multiprocessing.rst:890
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Lève une exception :exc:`ValueError` si appelée plus de fois qu'il y avait "
"d'éléments dans la file."

#: ../Doc/library/multiprocessing.rst:896
msgid "Block until all items in the queue have been gotten and processed."
msgstr ""
"Bloque jusqu'à ce que tous les éléments de la queue aient été récupérés et "
"traités."

#: ../Doc/library/multiprocessing.rst:898
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"Le compteur des tâches non accomplies augmente chaque fois qu'un élément est "
"ajouté à la queue. Le compteur redescend chaque fois qu'un consommateur "
"appelle :meth:`task_done` pour indiquer qu'un élément a été récupéré et que "
"tout le travail qui le concerne est complété. Quand le compteur des tâches "
"non accomplies atteint zéro, :meth:`~queue.Queue.join` est débloquée."

#: ../Doc/library/multiprocessing.rst:906
msgid "Miscellaneous"
msgstr "Divers"

#: ../Doc/library/multiprocessing.rst:910
msgid "Return list of all live children of the current process."
msgstr "Renvoie la liste de tous les enfants vivants du processus courant."

#: ../Doc/library/multiprocessing.rst:912
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr ""
"Appeler cette méthode provoque l'effet de bord d'attendre tout processus qui "
"n'a pas encore terminé."

#: ../Doc/library/multiprocessing.rst:917
msgid "Return the number of CPUs in the system."
msgstr "Renvoie le nombre de CPU sur le système."

#: ../Doc/library/multiprocessing.rst:919
msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with ``len(os."
"sched_getaffinity(0))``"
msgstr ""
"Ce nombre n'est pas équivalent au nombre de CPUs que le processus courant "
"peut utiliser.  Le nombre de CPUs utilisables peut être obtenu avec ``len(os."
"sched_getaffinity(0))``"

#: ../Doc/library/multiprocessing.rst:923
msgid "May raise :exc:`NotImplementedError`."
msgstr "Peut lever une :exc:`NotImplementedError`."

#: ../Doc/library/multiprocessing.rst:926
msgid ":func:`os.cpu_count`"
msgstr ":func:`os.cpu_count`"

#: ../Doc/library/multiprocessing.rst:930
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "Renvoie l'objet :class:`Process` correspondant au processus courant."

#: ../Doc/library/multiprocessing.rst:932
msgid "An analogue of :func:`threading.current_thread`."
msgstr "Un analogue à :func:`threading.current_thread`."

#: ../Doc/library/multiprocessing.rst:936
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
"Ajoute le support des programmes utilisant :mod:`multiprocessing` qui ont "
"été gelés pour produire un exécutable Windows. (Testé avec **py2exe**, "
"**PyInstaller** et **cx_Freeze**.)"

#: ../Doc/library/multiprocessing.rst:940
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""
"Cette fonction doit être appelée juste après la ligne ``if __name__ == "
"'__main__'`` du module principal. Par exemple : ::"

#: ../Doc/library/multiprocessing.rst:952
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"Si la ligne ``freeze_support()`` est omise, alors tenter de lancer "
"l'exécutable gelé lèvera une :exc:`RuntimeError`."

#: ../Doc/library/multiprocessing.rst:955
msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run normally "
"by the Python interpreter on Windows (the program has not been frozen), then "
"``freeze_support()`` has no effect."
msgstr ""
"Appeler ``freeze_support()`` n'a pas d'effet quand elle est invoquée sur un "
"système d'exploitation autre que Windows. De plus, si le module est lancé "
"normalement par l'interpréteur Python sous Windows (le programme n'a pas été "
"gelé), alors ``freeze_support()`` n'a pas d'effet."

#: ../Doc/library/multiprocessing.rst:962
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  On Windows only ``'spawn'`` is available.  On Unix "
"``'fork'`` and ``'spawn'`` are always supported, with ``'fork'`` being the "
"default."
msgstr ""
"Renvoie la liste des méthodes de démarrage supportées, la première étant "
"celle par défaut. Les méthodes de démarrage possibles sont ``'fork'``, "
"``'spawn'`` et ``'forkserver'``. Sous Windows seule ``'spawn'`` est "
"disponible. Sous Unix ``'fork'`` et ``'spawn'`` sont disponibles, ``'fork'`` "
"étant celle par défaut."

#: ../Doc/library/multiprocessing.rst:972
msgid ""
"Return a context object which has the same attributes as the :mod:"
"`multiprocessing` module."
msgstr ""
"Renvoie un contexte ayant les mêmes attributs que le module :mod:"
"`multiprocessing`."

#: ../Doc/library/multiprocessing.rst:975
msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  :exc:"
"`ValueError` is raised if the specified start method is not available."
msgstr ""
"Si *method* est ``None`` le contexte par défaut est renvoyé. Sinon *method* "
"doit valoir ``'fork'``, ``'spawn'`` ou ``'forkserver'``. Une :exc:"
"`ValueError` est levée si la méthode de démarrage spécifiée n'est pas "
"disponible."

#: ../Doc/library/multiprocessing.rst:984
msgid "Return the name of start method used for starting processes."
msgstr ""
"Renvoie le nom de la méthode de démarrage utilisée pour démarrer le "
"processus."

#: ../Doc/library/multiprocessing.rst:986
msgid ""
"If the start method has not been fixed and *allow_none* is false, then the "
"start method is fixed to the default and the name is returned.  If the start "
"method has not been fixed and *allow_none* is true then ``None`` is returned."
msgstr ""
"Si le nom de la méthode n'a pas été fixé et que *allow_none* est faux, alors "
"la méthode de démarrage est réglée à celle par défaut et son nom est "
"renvoyé. Si la méthode n'a pas été fixée et que *allow_none* est vrai, "
"``None`` est renvoyé."

#: ../Doc/library/multiprocessing.rst:991
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  ``'fork'`` is the default on Unix, while ``'spawn'`` is the "
"default on Windows."
msgstr ""
"La valeur de retour peut être ``'fork'``, ``'spawn'``, ``'forkserver'`` ou "
"``None``. ``'fork'`` est la valeur par défaut sous Unix, ``'spawn'`` est "
"celle sous Windows."

#: ../Doc/library/multiprocessing.rst:999
msgid ""
"Sets the path of the Python interpreter to use when starting a child "
"process. (By default :data:`sys.executable` is used).  Embedders will "
"probably need to do some thing like ::"
msgstr ""
"Définit le chemin de l'interpréteur Python à utiliser pour démarrer un "
"processus fils. (Par défaut :data:`sys.executable` est utilisé). Les "
"intégrateurs devront probablement faire quelque chose comme : ::"

#: ../Doc/library/multiprocessing.rst:1005
msgid "before they can create child processes."
msgstr "avant de pouvoir créer des processus fils."

#: ../Doc/library/multiprocessing.rst:1007
msgid "Now supported on Unix when the ``'spawn'`` start method is used."
msgstr ""
"Maintenant supporté sous Unix quand la méthode de démarrage ``'spawn'`` est "
"utilisée."

#: ../Doc/library/multiprocessing.rst:1012
msgid ""
"Set the method which should be used to start child processes. *method* can "
"be ``'fork'``, ``'spawn'`` or ``'forkserver'``."
msgstr ""
"Règle la méthode qui doit être utilisée pour démarrer un processus fils. "
"*method* peut être ``'fork'``, ``'spawn'`` ou ``'forkserver'``."

#: ../Doc/library/multiprocessing.rst:1015
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"Notez que cette fonction ne devrait être appelée qu'une fois au plus, et "
"l'appel devrait être protégé à l'intérieur d'une clause ``if __name__ == "
"'__main__'`` dans le module principal."

#: ../Doc/library/multiprocessing.rst:1023
msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""
":mod:`multiprocessing` ne contient pas d'analogues à :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, ou :class:`threading."
"local`."

#: ../Doc/library/multiprocessing.rst:1030
msgid "Connection Objects"
msgstr "Objets de connexions"

#: ../Doc/library/multiprocessing.rst:1034
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""
"Les objets de connexion autorisent l'envoi et la réception d'objets "
"sérialisables ou de chaînes de caractères. Ils peuvent être vus comme des "
"interfaces de connexion (*sockets*) connectées orientées messages."

#: ../Doc/library/multiprocessing.rst:1037
msgid ""
"Connection objects are usually created using :func:`Pipe <multiprocessing."
"Pipe>` -- see also :ref:`multiprocessing-listeners-clients`."
msgstr ""
"Les objets de connexion sont habituellement créés via :func:`Pipe "
"<multiprocessing.Pipe>` -- voir aussi :ref:`multiprocessing-listeners-"
"clients`."

#: ../Doc/library/multiprocessing.rst:1045
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr ""
"Envoie un objet sur l'autre bout de la connexion, qui devra être lu avec :"
"meth:`recv`."

#: ../Doc/library/multiprocessing.rst:1048
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"L'objet doit être sérialisable. Les *pickles* très larges (approximativement "
"32 Mo+, bien que cela dépende de l'OS) pourront lever une exception :exc:"
"`ValueError`."

#: ../Doc/library/multiprocessing.rst:1053
msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Blocks until there is something to receive.  Raises :exc:`EOFError` "
"if there is nothing left to receive and the other end was closed."
msgstr ""
"Renvoie un objet envoyé depuis l'autre bout de la connexion en utilisant :"
"meth:`send`. Bloque jusqu'à ce que quelque chose soit reçu. Lève une :exc:"
"`EOFError` s'il n'y a plus rien à recevoir et que l'autre bout a été fermé."

#: ../Doc/library/multiprocessing.rst:1060
msgid "Return the file descriptor or handle used by the connection."
msgstr ""
"Renvoie le descripteur de fichier ou identifiant utilisé par la connexion."

#: ../Doc/library/multiprocessing.rst:1064
msgid "Close the connection."
msgstr "Ferme la connexion."

#: ../Doc/library/multiprocessing.rst:1066
msgid "This is called automatically when the connection is garbage collected."
msgstr ""
"Elle est appelée automatiquement quand la connexion est collectée par le "
"ramasse-miettes."

#: ../Doc/library/multiprocessing.rst:1070
msgid "Return whether there is any data available to be read."
msgstr ""
"Renvoie vrai ou faux selon si des données sont disponibles à la lecture."

#: ../Doc/library/multiprocessing.rst:1072
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"Si *timeout* n'est pas spécifié la méthode renverra immédiatement. Si "
"*timeout* est un nombre alors il spécifie le temps maximum de blocage en "
"secondes. Si *timeout* est ``None``, un temps d'attente infini est utilisé."

#: ../Doc/library/multiprocessing.rst:1076
msgid ""
"Note that multiple connection objects may be polled at once by using :func:"
"`multiprocessing.connection.wait`."
msgstr ""
"Notez que plusieurs objets de connexions peuvent être attendus en même temps "
"à l'aide de :func:`multiprocessing.connection.wait`."

#: ../Doc/library/multiprocessing.rst:1081
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ""
"Envoie des données binaires depuis un :term:`bytes-like object` comme un "
"message complet."

#: ../Doc/library/multiprocessing.rst:1083
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a :"
"exc:`ValueError` exception"
msgstr ""
"Si *offset* est fourni, les données sont lues depuis cette position dans le "
"tampon *buffer*. Si *size* est fourni, il indique le nombre d'octets qui "
"seront lus depuis *buffer*. Les tampons très larges (approximativement 32 MiB"
"+, bien que cela dépende de l'OS) pourront lever une exception :exc:"
"`ValueError`."

#: ../Doc/library/multiprocessing.rst:1090
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"Renvoie un message complet de données binaires envoyées depuis l'autre bout "
"de la connexion comme une chaîne de caractères. Bloque jusqu'à ce qu'il y "
"ait quelque chose à recevoir. Lève une :exc:`EOFError` s'il ne reste rien à "
"recevoir et que l'autre côté de la connexion a été fermé."

#: ../Doc/library/multiprocessing.rst:1095
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"Si *maxlength* est précisé que que le message est plus long que *maxlength* "
"alors une :exc:`OSError` est levée et la connexion n'est plus lisible."

#: ../Doc/library/multiprocessing.rst:1099
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"Cette fonction levait auparavant une :exc:`IOError`, qui est maintenant un "
"alias pour :exc:`OSError`."

#: ../Doc/library/multiprocessing.rst:1106
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"Lit et stocke dans *buffer* un message complet de données binaires envoyées "
"depuis l'autre bout de la connexion et renvoie le nombre d'octets du "
"message. Bloque jusqu'à ce qu'il y ait quelque chose à recevoir. Lève une :"
"exc:`EOFError` s'il ne reste rien à recevoir et que l'autre côté de la "
"connexion a été fermé."

#: ../Doc/library/multiprocessing.rst:1112
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given "
"then the message will be written into the buffer from that position.  Offset "
"must be a non-negative integer less than the length of *buffer* (in bytes)."
msgstr ""
"*buffer* doit être un :term:`bytes-like object` accessible en écriture. Si "
"*offset* est donné, le message sera écrit dans le tampon à partir de cette "
"position. *offset* doit être un entier positif, inférieur à la taille de "
"*buffer* (en octets)."

#: ../Doc/library/multiprocessing.rst:1117
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"Si le tampon est trop petit une exception :exc:`BufferTooShort` est levée et "
"le message complet est accessible via ``e.args[0]`` où ``e`` est l'instance "
"de l'exception."

#: ../Doc/library/multiprocessing.rst:1121
msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"Les objets de connexions eux-mêmes peuvent maintenant être transférés entre "
"les processus en utilisant :meth:`Connection.send` et :meth:`Connection."
"recv`."

#: ../Doc/library/multiprocessing.rst:1125
msgid ""
"Connection objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Les objets de connexions supportent maintenant le protocole des "
"gestionnaires de contexte -- voir :ref:`typecontextmanager`.  :meth:"
"`~contextmanager.__enter__` renvoie l'objet de connexion, et :meth:"
"`~contextmanager.__exit__` appelle :meth:`close`."

#: ../Doc/library/multiprocessing.rst:1130
msgid "For example:"
msgstr "Par exemple :"

#: ../Doc/library/multiprocessing.rst:1154
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
"La méthode :meth:`Connection.recv` désérialise automatiquement les données "
"qu'elle reçoit, ce qui peut être un risque de sécurité à moins que vous ne "
"fassiez réellement confiance au processus émetteur du message."

#: ../Doc/library/multiprocessing.rst:1158
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Par conséquent, à moins que l'objet de connexion soit instancié par :func:"
"`Pipe`, vous ne devriez uniquement utiliser les méthodes :meth:`~Connection."
"recv` et :meth:`~Connection.send` après avoir effectué une quelconque forme "
"d'authentification. Voir :ref:`multiprocessing-auth-keys`."

#: ../Doc/library/multiprocessing.rst:1165
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""
"Si un processus est tué pendant qu'il essaye de lire ou écrire sur le tube, "
"alors les données du tube ont des chances d'être corrompues, parce qu'il "
"devient impossible d'être sûr d'où se trouvent les bornes du message."

#: ../Doc/library/multiprocessing.rst:1171
msgid "Synchronization primitives"
msgstr "Primitives de synchronisation"

#: ../Doc/library/multiprocessing.rst:1175
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr ""
"Généralement les primitives de synchronisation ne sont pas nécessaire dans "
"un programme multi-processus comme elles le sont dans un programme multi-"
"fils d'exécution. Voir la documentation du module :mod:`threading`."

#: ../Doc/library/multiprocessing.rst:1179
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""
"Notez que vous pouvez aussi créer des primitives de synchronisation en "
"utilisant un objet gestionnaire -- voir :ref:`multiprocessing-managers`."

#: ../Doc/library/multiprocessing.rst:1184
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "Un objet barrière : un clone de :class:`threading.Barrier`."

#: ../Doc/library/multiprocessing.rst:1190
msgid ""
"A bounded semaphore object: a close analog of :class:`threading."
"BoundedSemaphore`."
msgstr ""
"Un objet sémaphore lié : un analogue proche de :class:`threading."
"BoundedSemaphore`."

#: ../Doc/library/multiprocessing.rst:1193
#: ../Doc/library/multiprocessing.rst:1331
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's "
"first argument is named *block*, as is consistent with :meth:`Lock.acquire`."
msgstr ""
"Une seule différence existe avec son proche analogue : le premier argument "
"de sa méthode ``acquire`` est appelé *block*, pour la cohérence avec :meth:"
"`Lock.acquire`."

#: ../Doc/library/multiprocessing.rst:1197
msgid ""
"On Mac OS X, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"Sur Mac OS X, elle n'est pas distinguable de la classe :class:`Semaphore` "
"parce que ``sem_getvalue()`` n'est pas implémentée sur cette plateforme."

#: ../Doc/library/multiprocessing.rst:1202
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr ""
"Une variable conditionnelle : un alias pour :class:`threading.Condition`."

#: ../Doc/library/multiprocessing.rst:1204
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"Si *lock* est spécifié il doit être un objet :class:`Lock` ou :class:`RLock` "
"du module :mod:`multiprocessing`."

#: ../Doc/library/multiprocessing.rst:1207
#: ../Doc/library/multiprocessing.rst:1741
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr "La méthode :meth:`~threading.Condition.wait_for` a été ajoutée."

#: ../Doc/library/multiprocessing.rst:1212
msgid "A clone of :class:`threading.Event`."
msgstr "Un clone de :class:`threading.Event`."

#: ../Doc/library/multiprocessing.rst:1217
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once "
"a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of :class:`threading."
"Lock` as it applies to threads are replicated here in :class:"
"`multiprocessing.Lock` as it applies to either processes or threads, except "
"as noted."
msgstr ""
"Un verrou non récursif : un analogue proche de :class:`threading.Lock`. Une "
"fois que le processus ou le fil d'exécution a acquis un verrou, les "
"tentatives suivantes d'acquisition depuis n'importe quel processus ou fil "
"d'exécution bloqueront jusqu'à ce qu'il soit libéré ; n'importe quel "
"processus ou fil peut le libérer. Les concepts et comportements de :class:"
"`threading.Lock` qui s'appliquent aux fils d'exécution sont répliqués ici "
"dans :class:`multiprocessing.Lock` et s'appliquent aux processus et aux fils "
"d'exécution, à l'exception de ce qui est indiqué."

#: ../Doc/library/multiprocessing.rst:1225
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
"Notez que :class:`Lock` est en fait une fonction *factory* qui renvoie une "
"instance de ``multiprocessing.synchronize.Lock`` initialisée avec un "
"contexte par défaut."

#: ../Doc/library/multiprocessing.rst:1229
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`Lock` supporte le protocole :term:`context manager` et peut ainsi "
"être utilisé avec une instruction :keyword:`with`."

#: ../Doc/library/multiprocessing.rst:1234
#: ../Doc/library/multiprocessing.rst:1285
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Acquiert un verrou, bloquant ou non bloquant."

#: ../Doc/library/multiprocessing.rst:1236
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and "
"return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"Avec l'argument *block* à ``True`` (par défaut), l'appel de méthode bloquera "
"jusqu'à ce que le verrou soit dans déverrouillé, puis le verrouillera avant "
"de renvoyer ``True``. Notez que le nom de ce premier argument diffère de "
"celui de :meth:`threading.Lock.acquire`."

#: ../Doc/library/multiprocessing.rst:1241
msgid ""
"With the *block* argument set to ``False``, the method call does not block.  "
"If the lock is currently in a locked state, return ``False``; otherwise set "
"the lock to a locked state and return ``True``."
msgstr ""
"Avec l'argument *block* à ``False``, l'appel de méthode ne bloque pas. Si le "
"verrou est actuellement verrouillé, renvoie ``False`` ; autrement verrouille "
"le verrou et renvoie ``True``."

#: ../Doc/library/multiprocessing.rst:1245
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can "
"not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"Quand invoqué avec un nombre flottant positif comme *timeout*, bloque au "
"maximum pendant ce nombre spécifié de secondes, tant que le verrou ne peut "
"être acquis. Les invocations avec une valeur de *timeout* négatives sont "
"équivalents à zéro. Les invocations avec un *timeout* à ``None`` (par "
"défaut) correspondent à un délai d'attente infini. Notez que le traitement "
"des valeurs de *timeout* négatives et ``None`` diffère du comportement "
"implémenté dans :meth:`threading.Lock.acquire`. L'argument *timeout* n'a pas "
"d'implication pratique si l'argument *block* est mis ) ``False`` et est "
"alors ignoré. Renvoie ``True`` si le verrou a été acquis et ``False`` si le "
"temps de *timeout* a expiré."

#: ../Doc/library/multiprocessing.rst:1260
msgid ""
"Release a lock.  This can be called from any process or thread, not only the "
"process or thread which originally acquired the lock."
msgstr ""
"Libère un verrou. Elle peut être appelée depuis n'importe quel processus ou "
"fil d'exécution, pas uniquement le processus ou le fil qui a acquis le "
"verrou à l'origine."

#: ../Doc/library/multiprocessing.rst:1263
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"Le comportement est le même que :meth:`threading.Lock.release` excepté que "
"lorsque la méthode est appelée sur un verrou déverrouillé, une :exc:"
"`ValueError` est levée."

#: ../Doc/library/multiprocessing.rst:1269
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"Un objet verrou récursif : un analogue proche de :class:`threading.RLock`. "
"Un verrou récursif doit être libéré par le processus ou le fil d'exécution "
"qui l'a acquis. Quand un processus ou un fil acquiert un verrou récursif, le "
"même processus/fil peut l'acquérir à nouveau sans bloquer ; le processus/fil "
"doit le libérer autant de fois qu'il l'acquiert."

#: ../Doc/library/multiprocessing.rst:1275
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default "
"context."
msgstr ""
"Notez que :class:`RLock` est en fait une fonction *factory* qui renvoie une "
"instance de ``multiprocessing.synchronize.RLock`` initialisée avec un "
"contexte par défaut."

#: ../Doc/library/multiprocessing.rst:1279
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`RLock` supporte le protocole :term:`context manager` et peut ainsi "
"être utilisée avec une instruction :keyword:`with`."

#: ../Doc/library/multiprocessing.rst:1287
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock "
"is in an unlocked state (not owned by any process or thread) unless the lock "
"is already owned by the current process or thread.  The current process or "
"thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation "
"of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"Quand invoqué avec l'argument *block* à ``True``, bloque jusqu'à ce que le "
"verrou soit déverrouillé (n'appartenant à aucun processus ou fil "
"d'exécution) sauf s'il appartient déjà au processus ou fil d'exécution "
"courant. Le processus ou fil d'exécution courant prend la possession du "
"verrou (s'il ne l'a pas déjà) et incrémente d'un le niveau de récursion du "
"verrou, renvoyant ainsi ``True``. Notez qu'il y a plusieurs différences dans "
"le comportement de ce premier argument comparé à l'implémentation de :meth:"
"`threading.RLock.acquire`, à commencer par le nom de l'argument lui-même."

#: ../Doc/library/multiprocessing.rst:1297
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or "
"thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"Quand invoqué avec l'argument *block* à ``False``, ne bloque pas. Si le "
"verrou est déjà acquis (et possédé) par un autre processus ou fil "
"d'exécution, le processus/fil courant n'en prend pas la possession et le "
"niveau de récursion n'est pas incrémenté, résultant en une valeur de retour "
"à ``False``. Si le verrou est déverrouillé, le processus/fil courant en "
"prend possession et incrémente son niveau de récursion, renvoyant ``True``."

#: ../Doc/library/multiprocessing.rst:1305
msgid ""
"Use and behaviors of the *timeout* argument are the same as in :meth:`Lock."
"acquire`.  Note that some of these behaviors of *timeout* differ from the "
"implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"L'usage et les comportements de l'argument *timeout* sont les mêmes que "
"pour :meth:`Lock.acquire`. Notez que certains de ces comportements diffèrent "
"par rapport à ceux implémentés par :meth:`threading.RLock.acquire`."

#: ../Doc/library/multiprocessing.rst:1312
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting "
"for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"Libère un verrou, décrémentant son niveau de récursion. Si après la "
"décrémentation le niveau de récursion est zéro, réinitialise le verrou à un "
"état déverrouillé (n'appartenant à aucun processus ou fil d'exécution) et si "
"des processus/fils attendent que le verrou se déverrouillé, autorise un seul "
"d'entre-eux à continuer. Si après cette décrémentation le niveau de "
"récursion est toujours strictement positif, le verrou reste verrouillé et "
"propriété du processus/fil appelant."

#: ../Doc/library/multiprocessing.rst:1320
msgid ""
"Only call this method when the calling process or thread owns the lock. An :"
"exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"N'appelez cette méthode que si le processus ou fil d'exécution appelant est "
"propriétaire du verrou. Une :exc:`AssertionError` est levée si cette méthode "
"est appelée par un processus/fil autre que le propriétaire ou si le verrou "
"n'est pas verrouillé (possédé). Notez que le type d'exception levé dans "
"cette situation diffère du comportement de :meth:`threading.RLock.release`."

#: ../Doc/library/multiprocessing.rst:1329
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "Un objet sémaphore, proche analogue de :class:`threading.Semaphore`."

#: ../Doc/library/multiprocessing.rst:1336
msgid ""
"On Mac OS X, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with "
"a timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"Sous Mac OS X, ``sem_timedwait`` n'est pas supporté, donc appeler "
"``acquire()`` avec un temps d'exécution limité émulera le comportement de "
"cette fonction en utilisant une boucle d'attente."

#: ../Doc/library/multiprocessing.rst:1341
msgid ""
"If the SIGINT signal generated by :kbd:`Ctrl-C` arrives while the main "
"thread is blocked by a call to :meth:`BoundedSemaphore.acquire`, :meth:`Lock."
"acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition."
"acquire` or :meth:`Condition.wait` then the call will be immediately "
"interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr ""
"Si le signal *SIGINT* généré par un :kbd:`Ctrl-C` survient pendant que le "
"fil d'exécution principal est bloqué par un appel à :meth:`BoundedSemaphore."
"acquire`, :meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Semaphore."
"acquire`, :meth:`Condition.acquire` ou :meth:`Condition.wait`, l'appel sera "
"immédiatement interrompu et une :exc:`KeyboardInterrupt` sera levée."

#: ../Doc/library/multiprocessing.rst:1347
msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr ""
"Cela diffère du comportement de :mod:`threading` où le *SIGINT* est ignoré "
"tant que les appels bloquants sont en cours."

#: ../Doc/library/multiprocessing.rst:1352
msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"Certaines des fonctionnalités de ce paquet requièrent une implémentation "
"fonctionnelle de sémaphores partagés sur le système hôte. Sans cela, le "
"module :mod:`multiprocessing.synchronize` sera désactivé, et les tentatives "
"de l'importer lèveront une :exc:`ImportError`. Voir :issue:`3770` pour plus "
"d'informations."

#: ../Doc/library/multiprocessing.rst:1360
msgid "Shared :mod:`ctypes` Objects"
msgstr "Objets :mod:`ctypes` partagés"

#: ../Doc/library/multiprocessing.rst:1362
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr ""
"Il est possible de créer des objets partagés utilisant une mémoire partagée "
"pouvant être héritée par les processus enfants."

#: ../Doc/library/multiprocessing.rst:1367
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"Renvoie un objet :mod:`ctypes` alloué depuis la mémoire partagée. Par défaut "
"la valeur de retour est en fait un *wrapper* synchronisé autour de l'objet. "
"L'objet en lui-même est accessible par l'attribut *value* de l'une :class:"
"`Value`."

#: ../Doc/library/multiprocessing.rst:1371
#: ../Doc/library/multiprocessing.rst:1458
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""
"*typecode_or_type* détermine le type de l'objet renvoyé : il s'agit soit "
"d'un type *ctype* soit d'un caractère *typecode* tel qu'utilisé par le "
"module :mod:`array`. *\\*args* est passé au constructeur de ce type."

#: ../Doc/library/multiprocessing.rst:1375
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` "
"or :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"Si *lock* vaut ``True`` (par défaut), alors un nouveau verrou récursif est "
"créé pour synchroniser l'accès à la valeur. Si *lock* est un objet :class:"
"`Lock` ou :class:`RLock` alors il sera utilisé pour synchroniser l'accès à "
"la valeur. Si *lock* vaut ``False``, l'accès à l'objet renvoyé ne sera pas "
"automatiquement protégé par un verrou, donc il ne sera pas forcément "
"« *process-safe* »"

#: ../Doc/library/multiprocessing.rst:1382
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"Les opérations telles que ``+=`` qui impliquent une lecture et une écriture "
"ne sont pas atomique. Ainsi si vous souhaitez par exemple réaliser une "
"incrémentation atomique sur une valeur partagée, vous ne pouvez pas "
"simplement faire : ::"

#: ../Doc/library/multiprocessing.rst:1388
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr ""
"En supposant que le verrou associé est récursif (ce qui est le cas par "
"défaut), vous pouvez à la place faire : ::"

#: ../Doc/library/multiprocessing.rst:1394
#: ../Doc/library/multiprocessing.rst:1484
#: ../Doc/library/multiprocessing.rst:1499
msgid "Note that *lock* is a keyword-only argument."
msgstr "Notez que *lock* est un argument *keyword-only*."

#: ../Doc/library/multiprocessing.rst:1398
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr ""
"Renvoie un tableau *ctypes* alloué depuis la mémoire partagée. Par défaut la "
"valeur de retour est en fait un *wrapper* synchronisé autour du tableau."

#: ../Doc/library/multiprocessing.rst:1401
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* détermine le type des éléments du tableau renvoyé : il "
"s'agit soit d'un type *ctype* soit d'un caractère *typecode* tel qu'utilisé "
"par le module :mod:`array`. Si *size_or_initialize* est un entier, alors il "
"détermine la taille du tableau, et le tableau sera initialisé avec des "
"zéros. Autrement, *size*or_initializer* est une séquence qui sera utilisée "
"pour initialiser le tableau et dont la taille détermine celle du tableau."

#: ../Doc/library/multiprocessing.rst:1408
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""
"Si *lock* vaut ``True`` (par défaut), alors un nouveau verrou est créé pour "
"synchroniser l'accès à la valeur. Si *lock* est un objet :class:`Lock` ou :"
"class:`RLock` alors il sera utilisé pour synchroniser l'accès à la valeur. "
"Si *lock* vaut ``False``, l'accès à l'objet renvoyé ne sera pas "
"automatiquement protégé par un verrou, donc il ne sera pas forcément "
"« *process-safe* »"

#: ../Doc/library/multiprocessing.rst:1415
msgid "Note that *lock* is a keyword only argument."
msgstr "Notez que *lock* est un argument *keyword-only*."

#: ../Doc/library/multiprocessing.rst:1417
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr ""
"Notez qu'un tableau de :data:`ctypes.c_char` a ses attributs *value* et "
"*raw* qui permettent de l'utiliser pour stocker et récupérer des chaînes de "
"caractères."

#: ../Doc/library/multiprocessing.rst:1422
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr "Le module :mod:`multiprocessing.sharedctypes`"

#: ../Doc/library/multiprocessing.rst:1427
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
"Le module :mod:`multiprocessing.sharedctypes` fournit des fonctions pour "
"allouer des objets :mod:`ctypes` depuis la mémoire partagée, qui peuvent "
"être hérités par les processus fils."

#: ../Doc/library/multiprocessing.rst:1433
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""
"Bien qu'il soit possible de stocker un pointeur dans une mémoire partagée, "
"souvenez-vous qu'il référencera un emplacement dans l'espace d'adressage "
"d'un processus particulier. Ainsi, le pointeur risque d'être invalide dans "
"le contexte d'un second processus et déréférencer le pointeur depuis ce "
"second processus pourrait causer un crash."

#: ../Doc/library/multiprocessing.rst:1441
msgid "Return a ctypes array allocated from shared memory."
msgstr "Renvoie un tableau *ctypes* alloué depuis la mémoire partagée."

#: ../Doc/library/multiprocessing.rst:1443
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* détermine le type des éléments du tableau renvoyé : il "
"s'agit soit d'un type *ctype* soit d'un caractère codant le type des "
"éléments du tableau (*typecode*) tel qu'utilisé par le module :mod:`array`. "
"Si *size_or_initialize* est un entier, alors il détermine la taille du "
"tableau, et le tableau sera initialisé avec des zéros. Autrement, "
"*size*or_initializer* est une séquence qui sera utilisée pour initialiser le "
"tableau et dont la taille détermine celle du tableau."

#: ../Doc/library/multiprocessing.rst:1450
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Notez que définir ou récupérer un élément est potentiellement non atomique "
"-- utilisez plutôt :func:`Array` pour vous assurer de synchroniser "
"automatiquement avec un verrou."

#: ../Doc/library/multiprocessing.rst:1456
msgid "Return a ctypes object allocated from shared memory."
msgstr "Renvoie un objet *ctypes* alloué depuis la mémoire partagée."

#: ../Doc/library/multiprocessing.rst:1462
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Notez que définir ou récupérer un élément est potentiellement non atomique "
"-- utilisez plutôt :func:`Value` pour vous assurer de synchroniser "
"automatiquement avec un verrou."

#: ../Doc/library/multiprocessing.rst:1466
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
"Notez qu'un tableau de :data:`ctypes.c_char` a ses attributs *value* et "
"*raw* qui permettent de l'utiliser pour stocker et récupérer des chaînes de "
"caractères -- voir la documentation de :mod:`ctypes`."

#: ../Doc/library/multiprocessing.rst:1472
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr ""
"Identique à :func:`RawArray` à l'exception que suivant la valeur de *lock* "
"un *wrapper* de synchronisation *process-safe* pourra être renvoyé à la "
"place d'un tableau *ctypes* brut."

#: ../Doc/library/multiprocessing.rst:1476
#: ../Doc/library/multiprocessing.rst:1492
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`~multiprocessing."
"Lock` or :class:`~multiprocessing.RLock` object then that will be used to "
"synchronize access to the value.  If *lock* is ``False`` then access to the "
"returned object will not be automatically protected by a lock, so it will "
"not necessarily be \"process-safe\"."
msgstr ""
"Si *lock* vaut ``True`` (par défaut), alors un nouveau verrou est créé pour "
"synchroniser l'accès à la valeur. Si *lock* est un objet :class:"
"`~multiprocessing.Lock` ou :class:`~multiprocessing.RLock` alors il sera "
"utilisé pour synchroniser l'accès à la valeur. Si *lock* vaut ``False``, "
"l'accès à l'objet renvoyé ne sera pas automatiquement protégé par un verrou, "
"donc il ne sera pas forcément « *process-safe* »"

#: ../Doc/library/multiprocessing.rst:1488
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr ""
"Identique à :func:`RawValue` à l'exception que suivant la valeur de *lock* "
"un *wrapper* de synchronisation *process-safe* pourra être renvoyé à la "
"place d'un objet *ctypes* brut."

#: ../Doc/library/multiprocessing.rst:1503
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr ""
"Renvoie un objet *ctypes* alloué depuis la mémoire partagée, qui est une "
"copie de l'objet *ctypes* *obj*."

#: ../Doc/library/multiprocessing.rst:1508
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""
"Renvoie un *wrapper* *process-safe* autour de l'objet *ctypes* qui utilise "
"*lock* pour synchroniser l'accès. Si *lock* est ``None`` (par défaut), un "
"objet :class:`multiprocessing.RLock` est créé automatiquement."

#: ../Doc/library/multiprocessing.rst:1512
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr ""
"Un *wrapper* synchronisé aura deux méthodes en plus de celles de l'objet "
"qu'il enveloppe : :meth:`get_obj` renvoie l'objet *wrappé* et :meth:"
"`get_lock` renvoie le verrou utilisé pour la synchronisation."

#: ../Doc/library/multiprocessing.rst:1516
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""
"Notez qu'accéder à l'objet *ctypes* à travers le *wrapper* peut s'avérer "
"beaucoup plus lent qu'accéder directement à l'objet *ctypes* brut."

#: ../Doc/library/multiprocessing.rst:1519
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr ""
"Les objets synchronisés supportent le protocole :term:`context manager`."

#: ../Doc/library/multiprocessing.rst:1523
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"Le tableau ci-dessous compare la syntaxe de création des objets *ctypes* "
"partagés depuis une mémoire partagée avec la syntaxe normale *ctypes*. (Dans "
"le tableau, ``MyStruct`` est une sous-classe quelconque de :class:`ctypes."
"Structure`.)"

#: ../Doc/library/multiprocessing.rst:1528
msgid "ctypes"
msgstr "ctypes"

#: ../Doc/library/multiprocessing.rst:1528
msgid "sharedctypes using type"
msgstr "*sharedctypes* utilisant un type"

#: ../Doc/library/multiprocessing.rst:1528
msgid "sharedctypes using typecode"
msgstr "*sharedctypes* utilisant un *typecode*"

#: ../Doc/library/multiprocessing.rst:1530
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../Doc/library/multiprocessing.rst:1530
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../Doc/library/multiprocessing.rst:1530
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../Doc/library/multiprocessing.rst:1531
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../Doc/library/multiprocessing.rst:1531
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../Doc/library/multiprocessing.rst:1532
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../Doc/library/multiprocessing.rst:1532
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../Doc/library/multiprocessing.rst:1532
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../Doc/library/multiprocessing.rst:1533
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../Doc/library/multiprocessing.rst:1533
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../Doc/library/multiprocessing.rst:1533
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../Doc/library/multiprocessing.rst:1537
msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr ""
"Ci-dessous un exemple où des objets *ctypes* sont modifiés par un processus "
"fils ::"

#: ../Doc/library/multiprocessing.rst:1575
msgid "The results printed are ::"
msgstr "Les résultats affichés sont ::"

#: ../Doc/library/multiprocessing.rst:1588
msgid "Managers"
msgstr "Gestionnaires"

#: ../Doc/library/multiprocessing.rst:1590
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages "
"*shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"Les gestionnaires fournissent un moyen de créer des données qui peuvent être "
"partagées entre les différents processus, incluant le partage à travers le "
"réseau entre des processus tournant sur des machines différentes. Un objet "
"gestionnaire contrôle un processus serveur qui gère les *shared objects*. "
"Les autres processus peuvent accéder aux objets partagés à l'aide de "
"mandataires."

#: ../Doc/library/multiprocessing.rst:1598
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"Renvoie un objet :class:`~multiprocessing.managers.SyncManager` démarré qui "
"peut être utilisé pour partager des objets entre les processus. L'objet "
"gestionnaire renvoyé correspond à un processus enfant instancié et possède "
"des méthodes pour créer des objets partagés et renvoyer les mandataires "
"correspondants."

#: ../Doc/library/multiprocessing.rst:1606
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr ""
"Les processus gestionnaires seront arrêtés dès qu'ils seront collectés par "
"le ramasse-miettes ou que leur processus parent se terminera. Les classes "
"gestionnaires sont définies dans le module :mod:`multiprocessing.managers` :"

#: ../Doc/library/multiprocessing.rst:1612
msgid "Create a BaseManager object."
msgstr "Crée un objet *BaseManager*."

#: ../Doc/library/multiprocessing.rst:1614
msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""
"Une fois créé il faut appeler :meth:`start` ou  ``get_server()."
"serve_forever()`` pour assurer que l'objet gestionnaire référence un "
"processus gestionnaire démarré."

#: ../Doc/library/multiprocessing.rst:1617
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*address* est l'adresse sur laquelle le processus gestionnaire écoute pour "
"de nouvelles connexions. Si *address* est ``None``, une adresse arbitraire "
"est choisie."

#: ../Doc/library/multiprocessing.rst:1620
msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* est la clé d'authentification qui sera utilisée pour vérifier la "
"validité des connexions entrantes sur le processus serveur. Si *authkey* est "
"``None`` alors ``current_process().authkey`` est utilisée. Autrement "
"*authkey* est utilisée et doit être une chaîne d'octets."

#: ../Doc/library/multiprocessing.rst:1627
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"Démarre un sous-processus pour démarrer le gestionnaire. Si *initializer* "
"n'est pas ``None`` alors le sous-processus appellera "
"``initializer(*initargs)`` quand il démarrera."

#: ../Doc/library/multiprocessing.rst:1632
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""
"Renvoie un objet :class:`Server` qui représente le serveur sous le contrôle "
"du gestionnaire. L'objet :class:`Server` supporte la méthode :meth:"
"`serve_forever` ::"

#: ../Doc/library/multiprocessing.rst:1641
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` possède en plus un attribut :attr:`address`."

#: ../Doc/library/multiprocessing.rst:1645
msgid "Connect a local manager object to a remote manager process::"
msgstr ""
"Connecte un objet gestionnaire local au processus gestionnaire distant ::"

#: ../Doc/library/multiprocessing.rst:1653
msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr ""
"Stoppe le processus utilisé par le gestionnaire. Cela est disponible "
"uniquement si :meth:`start` a été utilisée pour démarrer le processus "
"serveur."

#: ../Doc/library/multiprocessing.rst:1656
msgid "This can be called multiple times."
msgstr "Cette méthode peut être appelée plusieurs fois."

#: ../Doc/library/multiprocessing.rst:1660
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr ""
"Une méthode de classe qui peut être utilisée pour enregistrer un type ou un "
"appelable avec la classe gestionnaire."

#: ../Doc/library/multiprocessing.rst:1663
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr ""
"*typeif* est un « *type identifier* » qui est utilisé pour identifier un "
"type particulier d'objet partagé. Cela doit être une chaîne de caractères."

#: ../Doc/library/multiprocessing.rst:1666
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""
"*callable* est un objet appelable utilisé pour créer les objets avec cet "
"identifiant de type. Si une instance de gestionnaire prévoit de se connecter "
"au serveur en utilisant sa méthode :meth:`connect` ou si l'argument "
"*create_method* vaut ``False`` alors cet argument peut être laissé à "
"``None``."

#: ../Doc/library/multiprocessing.rst:1672
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* est une sous-classe de :class:`BaseProxy` utilisée pour créer "
"des mandataires autour des objets partagés avec ce *typeid*. S'il est "
"``None``, une classe mandataire sera créée automatiquement."

#: ../Doc/library/multiprocessing.rst:1676
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callmethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"*exposed* est utilisé pour préciser une séquence de noms de méthodes dont "
"les mandataires pour ce *typeid* doivent être autorisés à accéder via :meth:"
"`BaseProxy._callmethod`. (Si *exposed* est ``None`` alors :attr:`proxytype."
"_exposed_` est utilisé à la place s'il existe.) Dans le cas où aucune liste "
"*exposed* n'est précisée, toutes les « méthodes publiques » de l'objet "
"partagé seront accessibles. (Ici une « méthode publique » signifie n'importe "
"quel attribut qui possède une méthode :meth:`~object.__call__` et dont le "
"nom ne commence pas par un ``'_'``.)"

#: ../Doc/library/multiprocessing.rst:1685
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* est un tableau associatif utilisé pour préciser le type "
"de retour de ces méthodes exposées qui doivent renvoyer un mandataire. Il "
"associé un nom de méthode à une chaîne de caractères *typeid*. (Si "
"*method_to_typeid* est ``None``, :attr:`proxytype._method_to_typeid_` est "
"utilisé à la place s'il existe). Si le nom d'une méthode n'est pas une clé "
"de ce tableau associatif ou si la valeur associée est ``None``, l'objet "
"renvoyé par la méthode sera une copie de la valeur."

#: ../Doc/library/multiprocessing.rst:1692
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* détermine si une méthode devrait être créée avec le nom "
"*typeid*, qui peut être utilisée pour indiquer au processus serveur de créer "
"un nouvel objet partagé et d'en renvoyer un mandataire. a valeur par défaut "
"est ``True``."

#: ../Doc/library/multiprocessing.rst:1696
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ""
"Les instances de :class:`BaseManager` ont aussi une propriété en lecture "
"seule :"

#: ../Doc/library/multiprocessing.rst:1700
msgid "The address used by the manager."
msgstr "L'adresse utilisée par le gestionnaire."

#: ../Doc/library/multiprocessing.rst:1702
msgid ""
"Manager objects support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the server "
"process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"Les objets gestionnaires supportent le protocole des gestionnaires de "
"contexte -- voir :ref:`typecontextmanager`. :meth:`~contextmanager."
"__enter__` démarre le processus serveur (s'il n'a pas déjà été démarré) et "
"renvoie l'objet gestionnaire. :meth:`~contextmanager.__exit__` appelle :meth:"
"`shutdown`."

#: ../Doc/library/multiprocessing.rst:1708
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"Dans les versions précédentes :meth:`~contextmanager.__enter__` ne démarrait "
"pas le processus serveur du gestionnaire s'il n'était pas déjà démarré."

#: ../Doc/library/multiprocessing.rst:1713
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr ""
"Une sous-classe de :class:`BaseManager` qui peut être utilisée pour la "
"synchronisation entre processus. Des objets de ce type sont renvoyés par :"
"func:`multiprocessing.Manager`."

#: ../Doc/library/multiprocessing.rst:1717
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This "
"notably includes shared lists and dictionaries."
msgstr ""
"Ces méthodes créent et renvoient des :ref:`multiprocessing-proxy_objects` "
"pour un certain nombre de types de données communément utilisés pour être "
"synchronisés entre les processus. Elles incluent notamment des listes et "
"dictionnaires partagés."

#: ../Doc/library/multiprocessing.rst:1723
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr ""
"Crée un objet :class:`threading.Barrier` partagé et renvoie un mandataire "
"pour cet objet."

#: ../Doc/library/multiprocessing.rst:1730
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr ""
"Crée un objet :class:`threading.BoundedSemaphore` partagé et renvoie un "
"mandataire pour cet objet."

#: ../Doc/library/multiprocessing.rst:1735
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr ""
"Crée un objet :class:`threading.Condition` partagé et renvoie un mandataire "
"pour cet objet."

#: ../Doc/library/multiprocessing.rst:1738
msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""
"Si *lock* est fourni alors il doit être un mandataire pour un objet :class:"
"`threading.Lock` ou :class:`threading.RLock`."

#: ../Doc/library/multiprocessing.rst:1746
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr ""
"Crée un objet :class:`threading.Event` partagé et renvoie un mandataire pour "
"cet objet."

#: ../Doc/library/multiprocessing.rst:1750
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr ""
"Crée un objet :class:`threading.Lock` partagé et renvoie un mandataire pour "
"cet objet."

#: ../Doc/library/multiprocessing.rst:1754
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr ""
"Crée un objet :class:`Namespace` partagé et renvoie un mandataire pour cet "
"objet."

#: ../Doc/library/multiprocessing.rst:1758
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr ""
"Crée un objet :class:`queue.Queue` partagé et renvoie un mandataire pour cet "
"objet."

#: ../Doc/library/multiprocessing.rst:1762
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr ""
"Crée un objet :class:`threading.RLock` partagé et renvoie un mandataire pour "
"cet objet."

#: ../Doc/library/multiprocessing.rst:1766
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr ""
"Crée un objet :class:`threading.Semaphore` partagé et renvoie un mandataire "
"pour cet objet."

#: ../Doc/library/multiprocessing.rst:1771
msgid "Create an array and return a proxy for it."
msgstr "Crée un tableau et renvoie un mandataire pour cet objet."

#: ../Doc/library/multiprocessing.rst:1775
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr ""
"Crée un objet avec un attribut ``value`` accessible en écriture et renvoie "
"un mandataire pour cet objet."

#: ../Doc/library/multiprocessing.rst:1782
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr ""
"Crée un objet :class:`dict` partagé et renvoie un mandataire pour cet objet."

#: ../Doc/library/multiprocessing.rst:1787
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr ""
"Crée un objet :class:`list` partagé et renvoie un mandataire pour cet objet."

#: ../Doc/library/multiprocessing.rst:1789
msgid ""
"Shared objects are capable of being nested.  For example, a shared container "
"object such as a shared list can contain other shared objects which will all "
"be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"Les objets partagés peuvent être imbriqués. Par exemple, un conteneur "
"partagé tel qu'une liste partagée peu contenir d'autres objets partagés qui "
"seront aussi gérés et synchronisés par le :class:`SyncManager`."

#: ../Doc/library/multiprocessing.rst:1796
msgid "A type that can register with :class:`SyncManager`."
msgstr "Un type qui peut être enregistré avec :class:`SyncManager`."

#: ../Doc/library/multiprocessing.rst:1798
msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr ""
"Un espace de nommage n'a pas de méthodes publiques, mais possède des "
"attributs accessibles en écriture. Sa représentation montre les valeurs de "
"ses attributs."

#: ../Doc/library/multiprocessing.rst:1801
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""
"Cependant, en utilisant un mandataire pour un espace de nommage, un attribut "
"débutant par ``'_'`` est un attribut du mandataire et non de l'objet cible :"

#: ../Doc/library/multiprocessing.rst:1817
msgid "Customized managers"
msgstr "Gestionnaires personnalisés"

#: ../Doc/library/multiprocessing.rst:1819
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""
"Pour créer son propre gestionnaire, il faut créer une sous-classe de :class:"
"`BaseManager` et utiliser la méthode de classe :meth:`~BaseManager.register` "
"pour enregistrer de nouveaux types ou *callables* au gestionnaire. Par "
"exemple ::"

#: ../Doc/library/multiprocessing.rst:1844
msgid "Using a remote manager"
msgstr "Utiliser un gestionnaire distant"

#: ../Doc/library/multiprocessing.rst:1846
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""
"Il est possible de lancer un serveur gestionnaire sur une machine et d'avoir "
"des clients l'utilisant sur d'autres machines (en supposant que les pare-"
"feus impliqués l'autorisent)."

#: ../Doc/library/multiprocessing.rst:1849
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr ""
"Exécuter les commandes suivantes crée un serveur pour une simple queue "
"partagée à laquelle des clients distants peuvent accéder ::"

#: ../Doc/library/multiprocessing.rst:1861
msgid "One client can access the server as follows::"
msgstr "Un client peut accéder au serveur comme suit ::"

#: ../Doc/library/multiprocessing.rst:1871
msgid "Another client can also use it::"
msgstr "Un autre client peut aussi l'utiliser ::"

#: ../Doc/library/multiprocessing.rst:1882
msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr ""
"Les processus locaux peuvent aussi accéder à cette queue, utilisant le code "
"précédent sur le client pour y accéder à distance ::"

#: ../Doc/library/multiprocessing.rst:1907
msgid "Proxy Objects"
msgstr "Objets mandataires"

#: ../Doc/library/multiprocessing.rst:1909
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"Un mandataire est un objet qui *référence* un objet partagé appartenant "
"(supposément) à un processus différent. L'objet partagé est appelé le "
"*référent* du mandataire. Plusieurs mandataires peuvent avoir un même "
"référent."

#: ../Doc/library/multiprocessing.rst:1913
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""
"Un mandataire possède des méthodes qui appellent les méthodes "
"correspondantes du référent (bien que toutes les méthodes du référent ne "
"soient pas nécessairement accessibles à travers le mandataire). De cette "
"manière, un mandataire peut être utilisé comme le serait sont référent :"

#: ../Doc/library/multiprocessing.rst:1931
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""
"Notez qu'appliquer :func:`str` à un mandataire renvoie la représentation du "
"référent, alors que :func:`repr` renvoie celle du mandataire."

#: ../Doc/library/multiprocessing.rst:1935
msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  As such, a referent can contain :ref:"
"`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"Une fonctionnalité importantes des objets mandataires est qu'ils sont "
"sérialisables et peuvent donc être échangés entre les processus. Ainsi, un "
"référent peut contenir des :ref:`multiprocessing-proxy_objects`. Cela permet "
"d'imbriquer des listes et dictionnaires gérés ainsi que d'autres :ref:"
"`multiprocessing-proxy_objects` :"

#: ../Doc/library/multiprocessing.rst:1951
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr ""
"De même, les mandataires de listes et dictionnaires peuvent être imbriqués "
"dans d'autres ::"

#: ../Doc/library/multiprocessing.rst:1964
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained "
"in a referent, modifications to those mutable values will not be propagated "
"through the manager because the proxy has no way of knowing when the values "
"contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"Si des objets standards (non *proxyfiés*) :class:`list` ou :class:`dict` "
"sont contenus dans un référent, les modifications sur ces valeurs mutables "
"ne seront pas propagées à travers le gestionnaire parce que le mandataire "
"n'a aucun moyen de savoir quand les valeurs contenues sont modifiées. "
"Cependant, stocker une valeur dans un conteneur mandataire (qui déclenche un "
"appel à ``__setitem__`` sur le mandataire) propage bien la modification à "
"travers le gestionnaire et modifie effectivement l'élément, il est ainsi "
"possible de réassigner la valeur modifiée au conteneur mandataire ::"

#: ../Doc/library/multiprocessing.rst:1983
msgid ""
"This approach is perhaps less convenient than employing nested :ref:"
"`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""
"Cette approche est peut-être moins pratique que d'utiliser des :ref:"
"`multiprocessing-proxy_objects` imbriqués pour la majorité des cas "
"d'utilisation, mais démontre aussi un certain niveau de contrôle sur la "
"synchronisation."

#: ../Doc/library/multiprocessing.rst:1989
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""
"Les types de mandataires de :mod:`multiprocessing` n'implémentent rien pour "
"la comparaison par valeurs. Par exemple, on a :"

#: ../Doc/library/multiprocessing.rst:1997
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr ""
"Il faut à la place simplement utiliser une copie du référent pour faire les "
"comparaisons."

#: ../Doc/library/multiprocessing.rst:2001
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr ""
"Les objets mandataires sont des instances de sous-classes de :class:"
"`BaseProxy`."

#: ../Doc/library/multiprocessing.rst:2005
msgid "Call and return the result of a method of the proxy's referent."
msgstr ""
"Appelle et renvoie le résultat d'une méthode du référent du mandataire."

#: ../Doc/library/multiprocessing.rst:2007
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr ""
"Si ``proxy`` est un mandataire sont le référent est ``obj``, alors "
"l'expression ::"

#: ../Doc/library/multiprocessing.rst:2011
msgid "will evaluate the expression ::"
msgstr "s'évalue comme ::"

#: ../Doc/library/multiprocessing.rst:2015
msgid "in the manager's process."
msgstr "dans le processus du gestionnaire."

#: ../Doc/library/multiprocessing.rst:2017
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""
"La valeur renvoyée sera une copie du résultat de l'appel ou un mandataire "
"sur un nouvel objet partagé -- voir l'a documentation de l'argument "
"*method_to_typeid* de :meth:`BaseManager.register`."

#: ../Doc/library/multiprocessing.rst:2021
msgid ""
"If an exception is raised by the call, then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""
"Si une exception est levée par l'appel, elle est relayée par :meth:"
"`_callmethod`. Si une autre exception est levée par le processus du "
"gestionnaire, elle est convertie en une :exc:`RemoteError` et est levée par :"
"meth:`_callmethod`."

#: ../Doc/library/multiprocessing.rst:2026
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr ""
"Notez en particulier qu'une exception est levée si *methodname* n'est pas "
"*exposée*."

#: ../Doc/library/multiprocessing.rst:2029
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr "Un exemple d'utilisation de :meth:`_callmethod` :"

#: ../Doc/library/multiprocessing.rst:2045
msgid "Return a copy of the referent."
msgstr "Renvoie une copie du référent."

#: ../Doc/library/multiprocessing.rst:2047
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "Si le référent n'est pas sérialisable, une exception est levée."

#: ../Doc/library/multiprocessing.rst:2051
msgid "Return a representation of the proxy object."
msgstr "Renvoie la représentation de l'objet mandataire."

#: ../Doc/library/multiprocessing.rst:2055
msgid "Return the representation of the referent."
msgstr "Renvoie la représentation du référent."

#: ../Doc/library/multiprocessing.rst:2059
msgid "Cleanup"
msgstr "Nettoyage"

#: ../Doc/library/multiprocessing.rst:2061
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""
"Un mandataire utilise un *callback* sous une référence faible de façon à ce "
"que quand il est collecté par le ramasse-miettes, il se désenregistre auprès "
"du gestionnaire qui possède le référent."

#: ../Doc/library/multiprocessing.rst:2064
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr ""
"Un objet partagé est supprimé par le processus gestionnaire quand plus aucun "
"mandataire ne le référence."

#: ../Doc/library/multiprocessing.rst:2069
msgid "Process Pools"
msgstr "Bassins de processus"

#: ../Doc/library/multiprocessing.rst:2074
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ""
"On peut créer un bassin de processus qui exécuteront les tâches qui lui "
"seront soumises avec la classe :class:`Pool`."

#: ../Doc/library/multiprocessing.rst:2079
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""
"Un objet *process pool* qui contrôle un bassin de processus *workers* auquel "
"sont soumises des tâches. Il supporte les résultats asynchrones avec des "
"*timeouts* et des *callabacks*  et possède une implémentation parallèle de "
"*map*."

#: ../Doc/library/multiprocessing.rst:2083
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""
"*processes* est le nombre de processus *workers* à utiliser. Si *processes* "
"est ``None``, le nombre renvoyé par :func:`os.cpu_count` est utilisé."

#: ../Doc/library/multiprocessing.rst:2086
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"Si *initializer* n'est pas ``None``, chaque processus *worker* appellera "
"``initializer(*initargs)`` en démarrant."

#: ../Doc/library/multiprocessing.rst:2089
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* est le nombre de tâches qu'un processus *worker* peut "
"accomplir avant de se fermer et d'être remplacé par un *worker* frais, pour "
"permettre aux ressources inutilisées d'être libérées. Par défaut "
"*maxtasksperchild* est ``None``, ce qui signifie que le *worker* vit aussi "
"longtemps que le bassin."

#: ../Doc/library/multiprocessing.rst:2094
msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function :func:"
"`multiprocessing.Pool` or the :meth:`Pool` method of a context object.  In "
"both cases *context* is set appropriately."
msgstr ""
"*context* peut être utilisé pour préciser le contexte utilisé pour démarrer "
"les processus *workers*. Habituellement un bassin est créé à l'aide de la "
"fonction :func:`multiprocessing.Pool` ou de la méthode :meth:`Pool` d'un "
"objet de contexte. Dans les deux cas *context* est réglé de façon appropriée."

#: ../Doc/library/multiprocessing.rst:2100
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr ""
"Notez que les méthodes de l'objet *pool* ne doivent être appelées que par le "
"processus qui l'a créé."

#: ../Doc/library/multiprocessing.rst:2103
msgid "*maxtasksperchild*"
msgstr "*maxtasksperchild*"

#: ../Doc/library/multiprocessing.rst:2106
msgid "*context*"
msgstr "*context*"

#: ../Doc/library/multiprocessing.rst:2111
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems "
"(such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old "
"one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
"Les processus *workers* à l'intérieur d'une :class:`Pool` vivent par défaut "
"aussi longtemps que la queue de travail du bassin. Un modèle fréquent chez "
"d'autres systèmes (tels qu'Apache, *mod_wsgi*, etc.) pour libérer les "
"ressources détenues par les *workers* est d'autoriser un *worker* dans le "
"bassin à accomplir seulement une certaine charge de travail avant de se "
"fermer, se retrouvant nettoyé et remplacé par un nouvelle processus "
"fraîchement lancé. L'argument *maxtasksperchild* de :class:`Pool` expose "
"cette fonctionnalité à l'utilisateur final."

#: ../Doc/library/multiprocessing.rst:2121
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"Appelle *func* avec les arguments *args* et les arguments nommés *kwds*. "
"Bloque jusqu'à ce que que le résultat soit prêt. En raison de ce blocage, :"
"meth:`apply_async` est préférable pour exécuter du travail en parallèle. De "
"plus, *func* est exécutée sur un seul des *workers* du bassin."

#: ../Doc/library/multiprocessing.rst:2128
msgid "A variant of the :meth:`apply` method which returns a result object."
msgstr ""
"Une variante de la méthode :meth:`apply` qui renvoie un objet résultat."

#: ../Doc/library/multiprocessing.rst:2130
#: ../Doc/library/multiprocessing.rst:2159
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it, "
"that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"Si *callback* est précisé alors ce doit être un objet appelable qui accepte "
"un seul argument. Quand le résultat est prêt, *callback* est appelé avec ce "
"résultat, si l'appel n'échoue pas auquel cas *error_callback* est appelé à "
"la place."

#: ../Doc/library/multiprocessing.rst:2135
#: ../Doc/library/multiprocessing.rst:2164
msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"Si *error_callback* est précisé alors ce doit être un objet appelable qui "
"accepte un seul argument. Si la fonction cible échoue, alors "
"*error_callback* est appelé avec l'instance de l'exception."

#: ../Doc/library/multiprocessing.rst:2139
#: ../Doc/library/multiprocessing.rst:2168
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr ""
"Les *callbacks* doivent se terminer immédiatement, autrement le fil "
"d'exécution qui gère les résultats se retrouverait bloqué."

#: ../Doc/library/multiprocessing.rst:2144
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though).  It blocks until the result is ready."
msgstr ""
"Un équivalent parallèle à la fonction *built-in* :func:`map` (qui ne "
"supporte cependant qu'un *itérable* en argument). Elle bloque jusqu'à ce que "
"le résultat soit prêt."

#: ../Doc/library/multiprocessing.rst:2147
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""
"La méthode découpe l'itérable en un nombre de morceaux qu'elle envoie au "
"bassin de processus comme des tâches séparées. La taille (approximative) de "
"ces morceaux peut être précisée en passant à *chunksize* un entier positif."

#: ../Doc/library/multiprocessing.rst:2151
msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""

#: ../Doc/library/multiprocessing.rst:2157
msgid "A variant of the :meth:`.map` method which returns a result object."
msgstr "Une variante de la méthode :meth:`.map` qui renvoie un objet résultat."

#: ../Doc/library/multiprocessing.rst:2173
#, fuzzy
msgid "A lazier version of :meth:`.map`."
msgstr "Une version paresseuse de :meth:`map`."

#: ../Doc/library/multiprocessing.rst:2175
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"L'argument *chunksize* est le même que celui utilisé par la méthode :meth:`."
"map`. Pour de très longs itérables, utiliser une grande valeur pour "
"*chunksize* peut faire s'exécuter la tâche **beaucoup** plus rapidement "
"qu'en utilisant la valeur par défaut de ``1``."

#: ../Doc/library/multiprocessing.rst:2180
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"Aussi, si *chucksize* vaut ``1`` alors la méthode :meth:`!next` de "
"l'itérateur renvoyé par :meth:`imap` prend un paramètre optionnel "
"*timeout* : ``next(timeout)`` lève une :exc:`multiprocessing.TimeoutError` "
"si le résultat ne peut pas être renvoyé avant *timeout* secondes."

#: ../Doc/library/multiprocessing.rst:2187
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
"Identique à :meth:`imap` si ce n'est que l'ordre des résultats de "
"l'itérateur renvoyé doit être considéré comme arbitraire. (L'ordre n'est "
"garanti que quand il n'y a qu'un *worker*.)"

#: ../Doc/library/multiprocessing.rst:2193
msgid ""
"Like :meth:`map` except that the elements of the *iterable* are expected to "
"be iterables that are unpacked as arguments."
msgstr ""
"Semblable à :meth:`map` à l'exception que les éléments d'*iterable* doivent "
"être des itérables qui seront dépaquetés comme arguments pour la fonction."

#: ../Doc/library/multiprocessing.rst:2196
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"Par conséquent un *iterable* ``[(1,2), (3, 4)]`` donnera pour résultat "
"``[func(1,2), func(3,4)]``."

#: ../Doc/library/multiprocessing.rst:2203
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
"Une combinaison de :meth:`starmap` et :meth:`map_async` qui itère sur "
"*iterable* (composé d'itérables) et appelle *func* pour chaque itérable "
"dépaqueté. Renvoie l'objet résultat."

#: ../Doc/library/multiprocessing.rst:2211
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr ""
"Empêche de nouvelles tâches d'être envoyées à la *pool*. Les processus "
"*workers* se terminent une fois que toutes les tâches ont été complétées."

#: ../Doc/library/multiprocessing.rst:2216
msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr ""
"Stoppe immédiatement les processus *workers* sans finaliser les travaux "
"courants. Quand l'objet *pool* est collecté par le ramasse-miettes, sa "
"méthode :meth:`terminate` est appelée immédiatement."

#: ../Doc/library/multiprocessing.rst:2222
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr ""
"Attend que les processus *workers* se terminent. Il est nécessaire "
"d'appeler :meth:`close` ou :meth:`terminate` avant d'utiliser :meth:`join`."

#: ../Doc/library/multiprocessing.rst:2225
msgid ""
"Pool objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the pool "
"object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"Les bassins de *workers* supportent maintenant le protocole des "
"gestionnaires de contexte -- voir :ref:`typecontextmanager`. :meth:"
"`~contextmanager.__enter__` renvoie l'objet *pool* et :meth:`~contextmanager."
"__exit__` appelle :meth:`terminate`."

#: ../Doc/library/multiprocessing.rst:2233
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ""
"La classe des résultats renvoyés par :meth:`Pool.apply_async` et :meth:`Pool."
"map_async`."

#: ../Doc/library/multiprocessing.rst:2238
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""
"Renvoie le résultat quand il arrive. Si *timeout* n'est pas ``None`` et que "
"le résultat n'arrive pas avant *timeout* secondes, une :exc:`multiprocessing."
"TimeoutError` est levée. Si l'appel distance lève une exception, alors elle "
"est relayée par :meth:`get`."

#: ../Doc/library/multiprocessing.rst:2245
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr ""
"Attend que le résultat soit disponible ou que *timeout* secondes s'écoulent."

#: ../Doc/library/multiprocessing.rst:2249
msgid "Return whether the call has completed."
msgstr "Renvoie ``True`` ou ``False`` suivant si la tâche est accomplie."

#: ../Doc/library/multiprocessing.rst:2253
msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`AssertionError` if the result is not ready."
msgstr ""
"Renvoie ``True`` ou ``False`` suivant si la tâche est accomplie sans lever "
"d'exception. Lève une :exc:`AssertionError` si le résultat n'est pas prêt."

#: ../Doc/library/multiprocessing.rst:2256
msgid "The following example demonstrates the use of a pool::"
msgstr ""
"Les exemples suivants présentent l'utilisation d'un bassin de *workers* ::"

#: ../Doc/library/multiprocessing.rst:2283
msgid "Listeners and Clients"
msgstr "Auditeurs et Clients"

#: ../Doc/library/multiprocessing.rst:2288
msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""
"Habituellement l'échange de messages entre processus est réalisé en "
"utilisant des queues ou des objets :class:`~Connection` renvoyés par :func:"
"`~multiprocessing.Pipe`."

#: ../Doc/library/multiprocessing.rst:2292
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"Cependant, le module :mod:`multiprocessing.connection` permet un peu plus de "
"flexibilité. Il fournit un message de plus haut-niveau orienté API pour "
"traiter des *sockets* ou des tubes nommés sous Windows. Il supporte aussi la "
"*digest authentication* en utilisant le module :mod:`hmac`, et pour "
"interroger de multiples connexions en même temps."

#: ../Doc/library/multiprocessing.rst:2301
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr ""
"Envoie un message généré aléatoirement à l'autre bout de la connexion et "
"attend une réponse."

#: ../Doc/library/multiprocessing.rst:2304
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Si la réponse correspond au condensat du message avec la clé *authkey*, "
"alors un message de bienvenue est envoyé à l'autre bout de la connexion. "
"Autrement, une :exc:`~multiprocessing.AuthenticationError` est levée."

#: ../Doc/library/multiprocessing.rst:2310
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr ""
"Reçoit un message, calcule le condensat du message en utilisant la clé "
"*authkey*, et envoie le condensat en réponse."

#: ../Doc/library/multiprocessing.rst:2313
msgid ""
"If a welcome message is not received, then :exc:`~multiprocessing."
"AuthenticationError` is raised."
msgstr ""
"Si un message de bienvenue n'est pas reçu, une :exc:`~multiprocessing."
"AuthenticationError` est levée."

#: ../Doc/library/multiprocessing.rst:2318
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""
"Essaie d'établir une connexion avec l'auditeur qui utilise l'adresse "
"*address*, renvoie une :class:`~Connection`."

#: ../Doc/library/multiprocessing.rst:2321
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"Le type de la connexion est déterminé par l'argument *family*, mais il peut "
"généralement être omis puisqu'il peut être inféré depuis le format "
"d'*address*. (Voir :ref:`multiprocessing-address-formats`)"

#: ../Doc/library/multiprocessing.rst:2325
#: ../Doc/library/multiprocessing.rst:2360
msgid ""
"If *authkey* is given and not None, it should be a byte string and will be "
"used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is None. :exc:`~multiprocessing."
"AuthenticationError` is raised if authentication fails. See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Si *authkey* est passée et n'est pas ``None``, elle doit être une chaîne "
"d'octets et sera utilisée comme clé secrète pour le défi d'authentification "
"basé sur HMAC. Aucune authentification n'est réalisée si *authkey* est "
"``None``. Une :exc:`~multiprocessing.AuthenticationError` est levée si "
"l'authentification échoue. Voir :ref:`multiprocessing-auth-keys`."

#: ../Doc/library/multiprocessing.rst:2333
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr ""
"Un *wrapper* sur une *socket* liée ou un tube nommé sous Windows qui écoute "
"pour des connexions."

#: ../Doc/library/multiprocessing.rst:2336
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr ""
"*address* est l'adresse à utiliser par la *socket* liée ou le tube nommé de "
"l'objet auditeur."

#: ../Doc/library/multiprocessing.rst:2341
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr ""
"Si une adresse '0.0.0.0' est utilisée, l'adresse ne sera pas un point "
"d'accès connectable sous Windows. Si vous avez besoin d'un point d'accès "
"connectable, utilisez '127.0.0.1'."

#: ../Doc/library/multiprocessing.rst:2345
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*family* est le type de *socket* (ou tube nommé) à utiliser. Cela peut être "
"l'une des chaînes ``'AF_INET'`` (pour une *socket* TCP), ``'AF_UNIX'`` (pour "
"une *socket* Unix) ou ``'AF_PIPE'`` (pour un tube nommé sous Windows). "
"Seulement la première d'entre elles est garantie d'être disponible. Si "
"*family* est ``None``, la famille est inférée depuis le format d'*address*. "
"Si *address* est aussi ``None``, la famille par défaut est utilisée. La "
"famille par défaut est supposée être la plus rapide disponible. Voir :ref:"
"`multiprocessing-address-formats`. Notez que si la *family* est "
"``'AF_UNIX'`` et qu'*address* est ``None``, la *socket* est créée dans un "
"répertoire temporaire privé créé avec :func:`tempfile.mkstemp`."

#: ../Doc/library/multiprocessing.rst:2356
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"Si l'objet auditeur utilise une *socket* alors *backlog* (1 par défaut) es "
"passé à la méthode :meth:`~socket.socket.listen` de la *socket* une fois "
"qu'elle a été liée."

#: ../Doc/library/multiprocessing.rst:2368
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`~Connection` object. If authentication is attempted and "
"fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Accepte une connexion sur la *socket* liée ou le tube nommé de l'objet "
"auditeur et renvoie un objet :class:`~Connection`. Si la tentative "
"d'authentification échoue, une :exc:`~multiprocessing.AuthenticationError` "
"est levée."

#: ../Doc/library/multiprocessing.rst:2375
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""
"Ferme la *socket* liée ou le tube nommé de l'objet auditeur. La méthode est "
"appelée automatiquement quand l'auditeur est collecté par le ramasse-"
"miettes. Il est cependant conseillé de l'appeler explicitement."

#: ../Doc/library/multiprocessing.rst:2379
msgid "Listener objects have the following read-only properties:"
msgstr ""
"Les objets auditeurs ont aussi les propriétés en lecture seule suivantes :"

#: ../Doc/library/multiprocessing.rst:2383
msgid "The address which is being used by the Listener object."
msgstr "L'adresse utilisée par l'objet auditeur."

#: ../Doc/library/multiprocessing.rst:2387
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr ""
"L'adresse depuis laquelle a été établie la dernière connexion. ``None`` si "
"aucune n'est disponible."

#: ../Doc/library/multiprocessing.rst:2390
msgid ""
"Listener objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Les objets auditeurs supportent maintenant le protocole des gestionnaires de "
"contexte -- voir :ref:`typecontextmanager`. :meth:`~contextmanager."
"__enter__` renvoie l'objet auditeur, et :meth:`~contextmanager.__exit__` "
"appelle :meth:`close`."

#: ../Doc/library/multiprocessing.rst:2397
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it "
"will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"Attend qu'un objet d'*object_list* soit prêt. Renvoie la liste de ces objets "
"d'*object_list* qui sont prêts. Si *timeout* est un nombre flottant, l'appel "
"bloquera au maximum ce nombre de secondes. Si *timeout* est ``None``, "
"l'appelle bloquera pour une durée non limitée. Un *timeout* négatif est "
"équivalent à un *timeout* nul."

#: ../Doc/library/multiprocessing.rst:2403
msgid ""
"For both Unix and Windows, an object can appear in *object_list* if it is"
msgstr ""
"Pour Unix et Windows, un objet peut apparaître dans *object_list* s'il est"

#: ../Doc/library/multiprocessing.rst:2406
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr ""
"un objet :class:`~multiprocessing.connection.Connection` accessible en "
"lecture ;"

#: ../Doc/library/multiprocessing.rst:2407
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "un objet :class:`socket.socket` connecté et accessible en lecture ; ou"

#: ../Doc/library/multiprocessing.rst:2408
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a :class:"
"`~multiprocessing.Process` object."
msgstr ""
"l'attribut :attr:`~multiprocessing.Process.sentinel` d'un objet :class:"
"`~multiprocessing.Process`."

#: ../Doc/library/multiprocessing.rst:2411
msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr ""
"Une connexion ou une *socket* est prête quand il y a des données disponibles "
"en lecture dessus, ou que l'autre bout a été fermé."

#: ../Doc/library/multiprocessing.rst:2414
msgid ""
"**Unix**: ``wait(object_list, timeout)`` almost equivalent ``select."
"select(object_list, [], [], timeout)``.  The difference is that, if :func:"
"`select.select` is interrupted by a signal, it can raise :exc:`OSError` with "
"an error number of ``EINTR``, whereas :func:`wait` will not."
msgstr ""
"**Unix**: ``wait(object_list, timeout)`` est en grande partie équivalente à "
"``select.select(object_list, [], [], timeout)``. La différence est que, si :"
"func:`select.select` est interrompue par un signal, elle peut lever une :exc:"
"`OSError` avec un numéro d'erreur ``EINTR``, alors que :func:`wait` ne le "
"fera pas."

#: ../Doc/library/multiprocessing.rst:2420
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which "
"is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a :"
"meth:`fileno` method which returns a socket handle or pipe handle.  (Note "
"that pipe handles and socket handles are **not** waitable handles.)"
msgstr ""
"**Windows**: Un élément d'*object_list* doit être soit un identifiant "
"*waitable* (en accord avec la définition utilisée par la documentation de la "
"fonction Win32 ``WaitForMultipleObjects()``) soit un objet avec une méthode :"
"meth:`fileno` qui retourne un identifiant de *socket* ou de tube. (Notez que "
"les identifiants de tubes et de *sockets* **ne sont pas** des identifiants "
"*waitables*.)"

#: ../Doc/library/multiprocessing.rst:2430
msgid "**Examples**"
msgstr "**Exemples**"

#: ../Doc/library/multiprocessing.rst:2432
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""
"Le code serveur suivant crée un auditeur qui utilise ``'secret password'`` "
"comme clé d'authentification. Il attend ensuite une connexion et envoie les "
"données au client ::"

#: ../Doc/library/multiprocessing.rst:2451
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr "Le code suivant se connecte au serveur et en reçoit des données ::"

#: ../Doc/library/multiprocessing.rst:2468
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for "
"messages from multiple processes at once::"
msgstr ""
"Le code suivant utilise :func:`~multiprocessing.connection.wait` pour "
"attendre des messages depuis plusieurs processus à la fois ::"

#: ../Doc/library/multiprocessing.rst:2507
msgid "Address Formats"
msgstr "Formats d'adresses"

#: ../Doc/library/multiprocessing.rst:2509
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"Une adresse ``'AF_INET'`` est un *tuple* de la forme ``(hostname, port)`` où "
"*hostname* est une chaîne et *port* un entier."

#: ../Doc/library/multiprocessing.rst:2512
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr ""
"Une adresse ``'AF_UNIX'`` est une chaîne représentant un nom de fichier sur "
"le système de fichiers."

#: ../Doc/library/multiprocessing.rst:2518
msgid "An ``'AF_PIPE'`` address is a string of the form"
msgstr "Une adresse ``'AF_PIPE'`` est une chaîne de la forme"

#: ../Doc/library/multiprocessing.rst:2516
msgid ""
":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'`.  To use :func:`Client` to "
"connect to a named pipe on a remote computer called *ServerName* one should "
"use an address of the form :samp:`r'\\\\\\\\{ServerName}\\\\pipe\\"
"\\{PipeName}'` instead."
msgstr ""
":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'`. Pour utiliser un :func:`Client` "
"pour se connecter à un tube nommé sur une machine distante appelée "
"*ServerName*, il faut plutôt utiliser une adresse de la forme :samp:`r'\\\\\\"
"\\{ServerName}\\\\pipe\\\\{PipeName}'`."

#: ../Doc/library/multiprocessing.rst:2520
msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""
"Notez que toute chaîne commençant par deux antislashs est considérée par "
"défaut comme l'adresse d'un ``'AF_PIPE'`` plutôt qu'une adresse "
"``'AF_UNIX'``."

#: ../Doc/library/multiprocessing.rst:2527
msgid "Authentication keys"
msgstr "Clés d'authentification"

#: ../Doc/library/multiprocessing.rst:2529
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""
"Quand :meth:`Connection.recv <Connection.recv>` est utilisée, les données "
"reçues sont automatiquement désérialisées par *pickle*. Malheureusement "
"désérialiser des données depuis une source non sûre constitue un risque de "
"sécurité. Par conséquent :class:`Listener` et :func:`Client` utilisent le "
"module :mod:`hmac` pour fournir une authentification par condensat."

#: ../Doc/library/multiprocessing.rst:2535
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the connection.)"
msgstr ""
"Une clé d'authentification est une chaîne d'octets qui peut être vue comme "
"un mot de passe : quand une connexion est établie, les deux interlocuteurs "
"vont demander à l'autre une preuve qu'il connaît la clé d'authentification. "
"(Démontrer que les deux utilisent la même clé n'implique **pas** d'échanger "
"la clé sur la connexion.)"

#: ../Doc/library/multiprocessing.rst:2541
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will be automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""
"Si l'authentification est requise et qu'aucune clé n'est spécifiée alors la "
"valeur de retour de ``current_process().authkey`` est utilisée (voir :class:"
"`~multiprocessing.Process`). Celle valeur est automatiquement héritée par "
"tout objet :class:`~multiprocessing.Process` créé par le processus courant. "
"Cela signifie que (par défaut) tous les processus d'un programme multi-"
"processus partageront une clé d'authentification unique qui peut être "
"utilisée pour mettre en place des connexions entre-eux."

#: ../Doc/library/multiprocessing.rst:2549
msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr ""
"Des clés d'authentification adaptées peuvent aussi être générées par :func:"
"`os.urandom`."

#: ../Doc/library/multiprocessing.rst:2553
msgid "Logging"
msgstr "Journalisation"

#: ../Doc/library/multiprocessing.rst:2555
msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""
"Un certain support de la journalisation est disponible. Notez cependant que "
"le le paquet :mod:`logging` n'utilise pas de verrous partagés entre les "
"processus et il est donc possible (dépendant du type de gestionnaire) que "
"les messages de différents processus soient mélangés."

#: ../Doc/library/multiprocessing.rst:2562
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ""
"Renvoie le journaliseur utilisé par :mod:`multiprocessing`. Si nécessaire, "
"un nouveau sera créé."

#: ../Doc/library/multiprocessing.rst:2565
msgid ""
"When first created the logger has level :data:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""
"À sa première création le journaliseur a pour niveau :data:`logging.NOTSET` "
"et pas de gestionnaire par défaut. Les messages envoyés à ce journaliseur ne "
"seront pas propagés par défaut au journaliseur principal."

#: ../Doc/library/multiprocessing.rst:2569
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr ""
"Notez que sous Windows les processus fils n'hériteront que du niveau du "
"journaliseur du processus parent -- toute autre personnalisation du "
"journaliseur ne sera pas héritée."

#: ../Doc/library/multiprocessing.rst:2576
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``."
msgstr ""
"Cette fonction effectue un appel à :func:`get_logger` mais en plus de "
"renvoyer le journaliseur créé par *get_logger*, elle ajoute un gestionnaire "
"qui envoie la sortie sur :data:`sys.stderr` en utilisant le format "
"``'[%(levelname)s/%(processName)s] %(message)s'``."

#: ../Doc/library/multiprocessing.rst:2581
msgid "Below is an example session with logging turned on::"
msgstr ""
"L'exemple ci-dessous présente une session avec la journalisation activée ::"

#: ../Doc/library/multiprocessing.rst:2596
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr ""
"Pour un tableau complet des niveaux de journalisation, voir le module :mod:"
"`logging`."

#: ../Doc/library/multiprocessing.rst:2600
msgid "The :mod:`multiprocessing.dummy` module"
msgstr "Le module :mod:`multiprocessing.dummy`"

#: ../Doc/library/multiprocessing.rst:2605
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` réplique toute l'API de :mod:`multiprocessing` "
"mais n'est rien de plus qu'un *wrapper* autour du module :mod:`threading`."

#: ../Doc/library/multiprocessing.rst:2612
msgid "Programming guidelines"
msgstr "Lignes directrices de programmation"

#: ../Doc/library/multiprocessing.rst:2614
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ""
"Il y a certaines lignes directrices et idiomes auxquels il faut adhérer en "
"utilisant :mod:`multiprocessing`."

#: ../Doc/library/multiprocessing.rst:2619
msgid "All start methods"
msgstr "Toutes les méthodes de démarrage"

#: ../Doc/library/multiprocessing.rst:2621
msgid "The following applies to all start methods."
msgstr "Les règles suivantes s'appliquent aux méthodes de démarrage."

#: ../Doc/library/multiprocessing.rst:2623
msgid "Avoid shared state"
msgstr "Éviter les états partagés"

#: ../Doc/library/multiprocessing.rst:2625
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr ""
"Autant que possible, vous devriez éviter de déplacer de larges données entre "
"les processus."

#: ../Doc/library/multiprocessing.rst:2628
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr ""
"Il est probablement meilleur de s'en tenir à l'utilisation de queues et "
"tubes pour la communication entre processus plutôt que d'utiliser des "
"primitives de synchronisation plus bas-niveau."

#: ../Doc/library/multiprocessing.rst:2632
msgid "Picklability"
msgstr "Sérialisation"

#: ../Doc/library/multiprocessing.rst:2634
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr ""
"Assurez-vous que les arguments passés aux méthodes des mandataires soient "
"sérialisables (*pickables*)."

#: ../Doc/library/multiprocessing.rst:2636
msgid "Thread safety of proxies"
msgstr "Sûreté des mandataires à travers les fils d'exécution"

#: ../Doc/library/multiprocessing.rst:2638
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr ""
"N'utilisez pas d'objet mandataire depuis plus d'un fil d'exécution à moins "
"que vous ne le protégiez avec un verrou."

#: ../Doc/library/multiprocessing.rst:2641
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr ""
"(Il n'y a jamais de problème avec plusieurs processus utilisant un *même* "
"mandataire.)"

#: ../Doc/library/multiprocessing.rst:2643
msgid "Joining zombie processes"
msgstr "Attendre les processus zombies"

#: ../Doc/library/multiprocessing.rst:2645
msgid ""
"On Unix when a process finishes but has not been joined it becomes a zombie. "
"There should never be very many because each time a new process starts (or :"
"func:`~multiprocessing.active_children` is called) all completed processes "
"which have not yet been joined will be joined.  Also calling a finished "
"process's :meth:`Process.is_alive <multiprocessing.Process.is_alive>` will "
"join the process.  Even so it is probably good practice to explicitly join "
"all the processes that you start."
msgstr ""
"Sous Unix quand un processus se termine mais n'est pas attendu, il devient "
"un zombie. Il ne devrait jamais y en avoir beaucoup parce que chaque fois "
"qu'un nouveau processus démarre (ou que :func:`~multiprocessing."
"active_children` est appelée) tous les processus complétés qui n'ont pas été "
"attendus le seront. Aussi appeler la méthode :meth:`Process.is_alive "
"<multiprocessing.Process.is_alive>` d'un processus terminé attendra le "
"processus. Toutefois il est probablement une bonne pratique d'attendre "
"explicitement tous les processus que vous démarrez."

#: ../Doc/library/multiprocessing.rst:2653
msgid "Better to inherit than pickle/unpickle"
msgstr "Préférez hériter que sérialiser/désérialiser"

#: ../Doc/library/multiprocessing.rst:2655
msgid ""
"When using the *spawn* or *forkserver* start methods many types from :mod:"
"`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can "
"inherit it from an ancestor process."
msgstr ""
"Quand vous utilisez les méthodes de démarrage *spawn* ou *forkserver*, de "
"nombreux types de :mod:`multiprocessing` nécessitent d'être sérialisées pour "
"que les processus enfants puissent les utiliser. Cependant, il faut "
"généralement éviter d'envoyer des objets partagés aux autres processus en "
"utilisant des tubes ou des queues. Vous devriez plutôt vous arranger pour "
"qu'un processus qui nécessite l'accès à une ressource partagée créée autre "
"part qu'il en hérite depuis un de ses processus ancêtres."

#: ../Doc/library/multiprocessing.rst:2663
msgid "Avoid terminating processes"
msgstr "Éviter de terminer les processus"

#: ../Doc/library/multiprocessing.rst:2665
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"Utiliser la méthode :meth:`Process.terminate <multiprocessing.Process."
"terminate>` pour stopper un processus risque de casser ou de rendre "
"indisponible aux autres processus des ressources partagées (comme des "
"verrous, sémaphores, tubes et queues) actuellement utilisée par le processus."

#: ../Doc/library/multiprocessing.rst:2671
msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate <multiprocessing.Process.terminate>` on processes which never use "
"any shared resources."
msgstr ""
"Il est donc probablement préférable de n'utiliser :meth:`Process.terminate "
"<multiprocessing.Process.terminate>` que sur les processus qui n'utilisent "
"jamais de ressources partagées."

#: ../Doc/library/multiprocessing.rst:2675
msgid "Joining processes that use queues"
msgstr "Attendre les processus qui utilisent des queues"

#: ../Doc/library/multiprocessing.rst:2677
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` method of the "
"queue to avoid this behaviour.)"
msgstr ""
"Gardez à l'esprit qu'un processus qui a placé des éléments dans une queue "
"attendra que tous les éléments mis en tampon soient consommés par le fil "
"d'exécution « consommateur » du tube sous-jacent avant de se terminer. (Le "
"processus enfant peut appeler la méthode :meth:`Queue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` de la queue pour éviter ce "
"comportement.)"

#: ../Doc/library/multiprocessing.rst:2683
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"Cela signifie que chaque fois que vous utilisez une queue vous devez vous "
"assurer que tous les éléments qui y ont été placés seront effectivement "
"supprimés avant que le processus ne soit attendu. Autrement vous ne pouvez "
"pas être sûr que les processus qui ont placé des éléments dans la queue se "
"termineront. Souvenez-vous aussi que tous les processus non *daemons* seront "
"attendus automatiquement."

#: ../Doc/library/multiprocessing.rst:2689
msgid "An example which will deadlock is the following::"
msgstr "L'exemple suivant provoquera un interblocage ::"

#: ../Doc/library/multiprocessing.rst:2703
msgid ""
"A fix here would be to swap the last two lines (or simply remove the ``p."
"join()`` line)."
msgstr ""
"Une solution ici serait d'intervertir les deux dernières lignes (ou "
"simplement supprimer la ligne ``p.join()``)."

#: ../Doc/library/multiprocessing.rst:2706
msgid "Explicitly pass resources to child processes"
msgstr "Passer explicitement les ressources aux processus fils"

#: ../Doc/library/multiprocessing.rst:2708
msgid ""
"On Unix using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""
"Sous Unix en utilisant la méthode de démarrage *fork*, un processus fils "
"peut utiliser une ressource partagée créée par un processus parent en "
"utilisant une ressource globale. Cependant, il est préférable de passer "
"l'objet en argument au constructeur du processus fils."

#: ../Doc/library/multiprocessing.rst:2713
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process.  "
"This might be important if some resource is freed when the object is garbage "
"collected in the parent process."
msgstr ""
"En plus de rendre le code (potentiellement) compatible avec Windows et les "
"autres méthodes de démarrage, cela assure aussi que tant que le processus "
"fils est en vie, l'objet ne sera pas collecté par le ramasse-miettes du "
"processus parent. Cela peut être important si certaines ressources sont "
"libérées quand l'objet est collecté par le ramasse-miettes du processus "
"parent."

#: ../Doc/library/multiprocessing.rst:2720
msgid "So for instance ::"
msgstr "Donc par exemple ::"

#: ../Doc/library/multiprocessing.rst:2732
msgid "should be rewritten as ::"
msgstr "devrait être réécrit comme ::"

#: ../Doc/library/multiprocessing.rst:2744
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ""
"Faire attention à remplacer :data:`sys.stdin` par un objet « *file-like* »"

#: ../Doc/library/multiprocessing.rst:2746
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr "À l'origine, :mod:`multiprocessing` appelait inconditionnellement ::"

#: ../Doc/library/multiprocessing.rst:2750
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""
"dans la méthode :meth:`multiprocessing.Process._bootstrap` --- cela "
"provoquait des problèmes avec les processus imbriqués. Cela peut être changé "
"en ::"

#: ../Doc/library/multiprocessing.rst:2756
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :meth:"
"`~io.IOBase.close()` on this file-like object, it could result in the same "
"data being flushed to the object multiple times, resulting in corruption."
msgstr ""
"Qui résout le problème fondamental des collisions entre processus provoquant "
"des erreurs de mauvais descripteurs de fichiers, mais introduit un potentiel "
"danger pour les applications qui remplacent :func:`sys.stdin` avec un "
"« *file-like object* » ayant une sortie *bufferisée*. Ce danger est que si "
"plusieurs processus appellent :meth:`~io.IOBase.close()` sur cet objet *file-"
"like*, cela peut amener les données à être transmises à l'objet à plusieurs "
"reprises, résultant en une corruption."

#: ../Doc/library/multiprocessing.rst:2763
msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""
"Si vous écrivez un objet *file-like* et implémentez votre propre cache, vous "
"pouvez le rendre sûr pour les *forks* en stockant le *pid* chaque fois que "
"vous ajoutez des données au cache, et annulez le cache quand le *pip* "
"change. Par exemple ::"

#: ../Doc/library/multiprocessing.rst:2775
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr ""
"Pour plus d'informations, voir :issue:`5155`, :issue:`5313` et :issue:`5331`"

#: ../Doc/library/multiprocessing.rst:2778
msgid "The *spawn* and *forkserver* start methods"
msgstr "Les méthodes de démarrage *spawn* et *forkserver*"

#: ../Doc/library/multiprocessing.rst:2780
msgid ""
"There are a few extra restriction which don't apply to the *fork* start "
"method."
msgstr ""
"Certaines restrictions ne s'appliquent pas à la méthode de démarrage *fork*."

#: ../Doc/library/multiprocessing.rst:2783
msgid "More picklability"
msgstr "Plus de sérialisation"

#: ../Doc/library/multiprocessing.rst:2785
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. Also, "
"if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start <multiprocessing."
"Process.start>` method is called."
msgstr ""
"Assurez-vous que tous les argument de :meth:`Process.__init__` sont "
"sérialisables avec *pickle*. Aussi, si vous héritez de :class:"
"`~multiprocessing.Process`, assurez-vous que toutes les instances sont "
"sérialisables quand la méthode :meth:`Process.start <multiprocessing.Process."
"start>` est appelée."

#: ../Doc/library/multiprocessing.rst:2790
msgid "Global variables"
msgstr "Variables globales"

#: ../Doc/library/multiprocessing.rst:2792
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start <multiprocessing."
"Process.start>` was called."
msgstr ""
"Gardez en tête que si le code exécuté dans un processus fils essaie "
"d'accéder à une variable globale, alors la valeur qu'il voit (s'il y en a "
"une) pourrait ne pas être la même que la valeur du processus parent au "
"moment même où :meth:`Process.start <multiprocessing.Process.start>` est "
"appelée."

#: ../Doc/library/multiprocessing.rst:2797
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr ""
"Cependant, les variables globales qui sont juste des constantes de modules "
"ne posent pas de problèmes."

#: ../Doc/library/multiprocessing.rst:2800
msgid "Safe importing of main module"
msgstr "Importation sûre du module principal"

#: ../Doc/library/multiprocessing.rst:2802
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such a starting a new "
"process)."
msgstr ""
"Assurez-vous que le module principal peut être importé en toute sécurité par "
"un nouvel interpréteur Python sans causer d'effets de bord inattendus (comme "
"le démarrage d'un nouveau processus)."

#: ../Doc/library/multiprocessing.rst:2806
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"Par exemple, utiliser la méthode de démarrage *spawn* ou *forkserver* pour "
"lancer le module suivant échouerait avec une :exc:`RuntimeError` ::"

#: ../Doc/library/multiprocessing.rst:2818
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""
"Vous devriez plutôt protéger le « point d'entrée » du programme en utilisant "
"``if __name__ == '__main__':`` comme suit ::"

#: ../Doc/library/multiprocessing.rst:2832
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr ""
"(La ligne ``freeze_support()`` peut être omise si le programme est "
"uniquement lancé normalement et pas gelé.)"

#: ../Doc/library/multiprocessing.rst:2835
msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr ""
"Cela permet aux interpréteurs Python fraîchement instanciés d'importer en "
"toute sécurité le module et d'exécution ensuite la fonction ``foo()``."

#: ../Doc/library/multiprocessing.rst:2838
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr ""
"Des restrictions similaires s'appliquent si une *pool* ou un gestionnaire "
"est créé dans le module principal."

#: ../Doc/library/multiprocessing.rst:2845
msgid "Examples"
msgstr "Exemples"

#: ../Doc/library/multiprocessing.rst:2847
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr ""
"Démonstration de comment créer et utiliser des gestionnaires et mandataires "
"personnalisés :"

#: ../Doc/library/multiprocessing.rst:2853
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr "En utilisant :class:`~multiprocessing.pool.Pool` :"

#: ../Doc/library/multiprocessing.rst:2859
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker "
"processes and collect the results:"
msgstr ""
"Un exemple montrant comment utiliser des queues pour alimenter en tâches une "
"collection de processus *workers* et collecter les résultats :"
