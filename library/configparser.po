# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-29 16:33+0200\n"
"PO-Revision-Date: 2021-05-17 13:06+0200\n"
"Last-Translator: Dimitri Merejkowsky <dimitri@dmerej.info>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.3\n"

#: library/configparser.rst:2
msgid ":mod:`configparser` --- Configuration file parser"
msgstr ":mod:`configparser` — Lecture et écriture de fichiers de configuration"

#: library/configparser.rst:14
msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**Code source :** :source:`Lib/configparser.py`"

#: library/configparser.rst:24
msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"Ce module fournit la classe :class:`ConfigParser`. Cette classe implémente "
"un langage de configuration basique, proche de ce que l'on peut trouver dans "
"les fichiers *INI* de Microsoft Windows. Vous pouvez utiliser ce module pour "
"écrire des programmes Python qui sont facilement configurables par "
"l'utilisateur final."

#: library/configparser.rst:31
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr ""
"Ce module *n'implémente pas* la version étendue de la syntaxe *INI* qui "
"permet de lire ou d'écrire des valeurs dans la base de registre Windows en "
"utilisant divers préfixes."

#: library/configparser.rst:38
msgid "Module :mod:`shlex`"
msgstr "Module :mod:`shlex`"

#: library/configparser.rst:37
msgid ""
"Support for creating Unix shell-like mini-languages which can be used as an "
"alternate format for application configuration files."
msgstr ""
"Ce module fournit les outils permettant de créer des mini-langages de "
"programmation ressemblant au shell Unix, qui peuvent être utilisés comme "
"alternative pour les fichiers de configuration d'une application."

#: library/configparser.rst:41
msgid "Module :mod:`json`"
msgstr "Module :mod:`json`"

#: library/configparser.rst:41
msgid ""
"The json module implements a subset of JavaScript syntax which can also be "
"used for this purpose."
msgstr ""
"Le module *json* implémente un sous-ensemble de la syntaxe JavaScript, qui "
"peut aussi être utilisée à cet effet."

#: library/configparser.rst:51
msgid "Quick Start"
msgstr "Premiers pas"

#: library/configparser.rst:53
msgid "Let's take a very basic configuration file that looks like this:"
msgstr ""
"Prenons pour exemple un fichier de configuration très simple ressemblant à "
"ceci :"

#: library/configparser.rst:70
msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"La structure des fichiers *INI* est décrite dans la `section suivante "
"<#supported-ini-file-structure>`_. En bref,  chaque fichier est constitué de "
"sections, chacune des sections comprenant des clés associées à des valeurs. "
"Les classes du module :mod:`configparser` peuvent écrire et lire de tels "
"fichiers. Commençons par le code qui permet de générer le fichier ci-dessus."

#: library/configparser.rst:94
msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"Comme vous pouvez le voir, nous pouvons manipuler l'instance renvoyée par "
"l'analyse du fichier de configuration comme s'il s'agissait d'un "
"dictionnaire. Il y a des différences, comme `explicité ci-dessous <#mapping-"
"protocol-access>`_, mais le comportement de l'instance est très proche de ce "
"que vous pourriez attendre d'un dictionnaire."

#: library/configparser.rst:98
msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr ""
"Nous venons de créer et sauvegarder un fichier de configuration. Voyons "
"maintenant comment nous pouvons le lire et accéder aux données qu'il "
"contient."

#: library/configparser.rst:133
msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all "
"other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"Comme vous le voyez, l'API est assez simple à utiliser. La seule partie un "
"peu magique concerne la section ``DEFAULT``, qui fournit les valeurs par "
"défaut pour toutes les autres sections [1]_. Notez également que les clés à "
"l’intérieur des sections ne sont pas sensibles à la casse et qu'elles sont "
"stockées en minuscules. [1]_."

#: library/configparser.rst:140
msgid "Supported Datatypes"
msgstr "Types de données prises en charge"

#: library/configparser.rst:142
msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr ""
"Les lecteurs de configuration n'essayent jamais de deviner le type des "
"valeurs présentes dans les fichiers de configuration, et elles sont toujours "
"stockées en tant que chaînes de caractères. Ainsi, si vous avez besoin d'un "
"type différent, vous devez effectuer la conversion vous-même :"

#: library/configparser.rst:153
msgid ""
"Since this task is so common, config parsers provide a range of handy getter "
"methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"Puisque que cette tâche doit être fréquemment accomplie, les lecteurs de "
"configurations fournissent un ensemble d'accesseurs permettant de gérer les "
"entiers, les flottants et les booléens plus facilement. Le cas des booléens "
"est le plus pertinent. En effet, vous ne pouvez pas vous contenter "
"d'utiliser la fonction ``bool()`` directement puisque ``bool('False')`` "
"renvoie ``True``. C'est pourquoi les lecteurs fournissent également la "
"méthode :meth:`~ConfigParser.getboolean`. Cette méthode n'est pas sensible à "
"la casse et interprète correctement les valeurs booléennes associées aux "
"chaînes de caractères comme ``'yes'``-``'no'``, ``'on'``-``'off'``, "
"``'true'``-``'false'`` et ``'1'``-``'0'`` [1]_. Par exemple :"

#: library/configparser.rst:170
msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"En plus de :meth:`~ConfigParser.getboolean`, les lecteurs de configurations "
"fournissent également des méthodes similaires comme :meth:`~ConfigParser."
"getint` et :meth:`~ConfigParser.getfloat`. Vous pouvez enregistrer vos "
"propres convertisseurs et personnaliser ceux déjà fournis. [1]_"

#: library/configparser.rst:176
msgid "Fallback Values"
msgstr "Valeurs de substitution"

#: library/configparser.rst:178
msgid ""
"As with a dictionary, you can use a section's :meth:`get` method to provide "
"fallback values:"
msgstr ""
"Comme pour un dictionnaire, vous pouvez utiliser la méthode :meth:`get` "
"d'une section en spécifiant une valeur de substitution :"

#: library/configparser.rst:191
msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.com'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"Notez que les valeurs par défaut sont prioritaires par rapport aux valeurs "
"de substitution. Dans note exemple, la valeur de la clé ``CompressionLevel`` "
"était spécifiée uniquement dans la section ``DEFAULT``. Si nous essayons de "
"la récupérer depuis la section ``'topsecret.server.com'``, nous obtenons la "
"valeur par défaut, même en ayant spécifié une valeur de substitution :"

#: library/configparser.rst:202
msgid ""
"One more thing to be aware of is that the parser-level :meth:`get` method "
"provides a custom, more complex interface, maintained for backwards "
"compatibility.  When using this method, a fallback value can be provided via "
"the ``fallback`` keyword-only argument:"
msgstr ""
"Il est important de savoir que la méthode :meth:`get` appelée au niveau de "
"l'analyseur fournit une interface particulière et plus complexe, qui est "
"maintenue pour des raisons de rétrocompatibilité. Vous pouvez fournir une "
"valeur de substitution via l'argument obligatoirement nommé ``fallback`` :"

#: library/configparser.rst:213
msgid ""
"The same ``fallback`` argument can be used with the :meth:`~ConfigParser."
"getint`, :meth:`~ConfigParser.getfloat` and :meth:`~ConfigParser.getboolean` "
"methods, for example:"
msgstr ""
"L'argument ``fallback`` peut être utilisé de la même façon avec les "
"méthodes :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` et :"
"meth:`~ConfigParser.getboolean`. Par exemple :"

#: library/configparser.rst:229
msgid "Supported INI File Structure"
msgstr "Structure des fichiers *INI* prise en change"

#: library/configparser.rst:231
msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but "
"keys are not [1]_.  Leading and trailing whitespace is removed from keys and "
"values. Values can be omitted, in which case the key/value delimiter may "
"also be left out.  Values can also span multiple lines, as long as they are "
"indented deeper than the first line of the value.  Depending on the parser's "
"mode, blank lines may be treated as parts of multiline values or ignored."
msgstr ""
"Un fichier de configuration est constitué de sections. Chacune des sections "
"commence par un en-tête ``[section]``, suivi d'une liste de définitions clés-"
"valeurs séparées par une chaîne de caractères spécifique (``=`` ou ``:`` par "
"défaut [1]_). Par défaut, les noms des sections sont sensibles à la casse "
"mais pas les clés [1]_. Les caractères d'espacement en début et en fin des "
"clés et des valeurs sont supprimés. Les valeurs peuvent être absentes, "
"auquel cas il est possible d'omettre le délimiteur entre clé et valeur. Les "
"valeurs peuvent s'étendre sur plusieurs lignes, à partir du moment où les "
"lignes supplémentaires sont plus indentées que la première ligne. Les lignes "
"vides peuvent être considérées comme faisant partie des valeurs multi "
"lignes, en fonction de la configuration de l'analyseur."

#: library/configparser.rst:240
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"Les fichiers de configuration peuvent contenir des commentaires, préfixés "
"par des caractères spécifiques (``#`` et ``;`` par défaut [1]_). Les "
"commentaires peuvent apparaître à l'emplacement d'une ligne vide, et peuvent "
"aussi être indentés. [1]_"

#: library/configparser.rst:307
msgid "For example:"
msgstr "Par exemple :"

#: library/configparser.rst:292
msgid "Interpolation of values"
msgstr "Interpolation des valeurs"

#: library/configparser.rst:294
msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr ""
"La classe :class:`ConfigParser` prend en charge l’interpolation, en plus des "
"fonctionnalités de base. Cela signifie que les valeurs peuvent être traitées "
"avant d'être renvoyées par les appels aux méthodes ``get()``."

#: library/configparser.rst:302
msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values "
"to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
"Implémentation par défaut utilisée par la classe :class:`ConfigParser`. "
"Celle-ci permet aux valeurs de contenir des chaînes de formatage se référant "
"à d'autres valeurs dans la même section, ou bien à des valeurs dans la "
"section spéciale par défaut [1]_. D'autres valeurs par défaut peuvent être "
"fournies au moment de l'initialisation de cette classe."

#: library/configparser.rst:319
msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"Dans l'exemple ci-dessus, une classe :class:`Configparser` dont l'attribut "
"*interpolation* vaut ``BasicInterpolation()`` interprète la chaîne de "
"caractères ``%(home_dir)s`` en utilisant la valeur de la clé ``home_dir`` "
"(``/Users`` dans ce cas). ``%(my_dir)s`` est interprétée comme ``/Users/"
"lumberjack``. Les interpolations sont effectuées à la volée. Ainsi, les clés "
"utilisées comme référence à l’intérieur des chaînes de formatage peuvent "
"être définies dans le fichier de configuration dans n'importe quel ordre."

#: library/configparser.rst:326
msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return ``"
"%(my_dir)s/Pictures`` as the value of ``my_pictures`` and ``%(home_dir)s/"
"lumberjack`` as the value of ``my_dir``."
msgstr ""
"Si l'attribut ``interpolation`` vaut ``None``, le lecteur renvoie ``"
"%(my_dir)s/Pictures`` comme valeur pour ``my_pictures`` et ``%(home_dir)s/"
"lumberjack`` comme valeur pour ``my_dir``."

#: library/configparser.rst:334
msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the ``section:"
"`` part is omitted, interpolation defaults to the current section (and "
"possibly the default values from the special section)."
msgstr ""
"Autre façon de gérer l'interpolation en utilisant une syntaxe plus avancée, "
"utilisée par exemple par ``zc.buildout``. Cette syntaxe étendue utilise la "
"chaîne de formatage ``{section:option}}`` pour désigner une valeur "
"appartenant à une autre section. L'interpolation peut s'étendre sur "
"plusieurs niveaux. Par commodité, si la partie ``{section}`` est absente, "
"l'interpolation utilise la section courante par défaut (et, le cas échéant, "
"les valeurs de la section par défaut spéciale)."

#: library/configparser.rst:341
msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr ""
"Voici comment transformer la configuration ci-dessus avec la syntaxe "
"d'interpolation étendue :"

#: library/configparser.rst:354
msgid "Values from other sections can be fetched as well:"
msgstr ""
"Vous pouvez également récupérer des valeurs appartenant aux autres sections :"

#: library/configparser.rst:376
msgid "Mapping Protocol Access"
msgstr "Protocole d'accès associatif"

#: library/configparser.rst:380
msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of :mod:"
"`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"Le terme « protocole d'accès associatif » est utilisé pour décrire la "
"fonctionnalité qui permet d'utiliser des objets personnalisés comme s'il "
"s'agissait de dictionnaires. Dans le cas du module :mod:`configparser`, "
"l’implémentation du protocole utilise la notation ``parser['section']"
"['option']``."

#: library/configparser.rst:385
msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken "
"from the original parser on demand.  What's even more important is that when "
"values are changed on a section proxy, they are actually mutated in the "
"original parser."
msgstr ""
"En particulier, ``parser['section']`` renvoie un mandataire vers les données "
"de la section correspondantes dans l'analyseur. Cela signifie que les "
"valeurs ne sont pas copiées, mais prélevées depuis l'analyseur initial à la "
"demande. Plus important encore, lorsque les valeurs sont changées dans un "
"mandataire pour une section, elles sont en réalité changées dans l'analyseur "
"initial."

#: library/configparser.rst:391
msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the :class:"
"`~collections.abc.MutableMapping` ABC. However, there are a few differences "
"that should be taken into account:"
msgstr ""
"Les objets du module :mod:`configparser` se comportent le plus possible "
"comme des vrais dictionnaires. L'interface est complète et suit les "
"définitions fournies par la classe abstraite  :class:`~collections.abc."
"MutableMapping`. Cependant, il faut prendre en compte un certain nombre de "
"différences :"

#: library/configparser.rst:396
msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner "
"[1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by "
"default.  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"Par défaut, toutes les clés des sections sont accessibles sans respect de la "
"casse [1]_. Par exemple, ``for option in parser[\"section\"]`` renvoie "
"uniquement les clés telles que transformées par la méthode ``optionxform``, "
"c'est-à-dire des clés transformées en minuscules. De même, pour une section "
"contenant la clé ``a``, les deux expressions suivantes renvoient ``True`` ::"

#: library/configparser.rst:404
msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that ``."
"clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a :exc:`KeyError`."
msgstr ""
"Toutes les sections incluent en plus les valeurs de la section "
"``DEFAULTSECT``. Cela signifie qu'appeler ``clear()`` sur une section ne la "
"fera pas forcément apparaître vide. En effet, les valeurs par défaut ne "
"peuvent pas être supprimées de la section (car, techniquement, elles n'y "
"sont pas présentes). Si vous détruisez une valeur par défaut qui a été "
"écrasée dans une section, alors la valeur par défaut sera de nouveau "
"visible. Essayer de détruire une valeur par défaut lève l'exception :exc:"
"`KeyError`."

#: library/configparser.rst:411
msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "La section ``DEFAULTSECT`` ne peut pas être supprimée ::"

# fausse alerte dans poedit - garder le point-virgule
#: library/configparser.rst:413
msgid "trying to delete it raises :exc:`ValueError`,"
msgstr "l'exception :exc:`ValueError` est levée si on essaye de la supprimer ;"

# fausse alerte dans poedit - garder le point-virgule
#: library/configparser.rst:415
msgid "``parser.clear()`` leaves it intact,"
msgstr "appeler ``parser.clear()`` la laisse intacte ;"

#: library/configparser.rst:417
msgid "``parser.popitem()`` never returns it."
msgstr "appeler ```parser.popitem()`` ne la renvoie jamais."

#: library/configparser.rst:419
msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a "
"fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"Le deuxième argument de ``parser.get(section, option, **kwargs)`` n'est "
"**pas** une valeur de substitution. Notez cependant que les méthodes "
"``get()`` fournies par les sections sont compatibles à la fois avec le "
"protocole associatif et avec l'API classique de *configparser*."

#: library/configparser.rst:423
msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: ``parser."
"items(section, raw, vars)``.  The latter call returns a list of *option*, "
"*value* pairs for a specified ``section``, with all interpolations expanded "
"(unless ``raw=True`` is provided)."
msgstr ""
"La méthode ``parser.items()`` est compatible avec le protocole d'accès "
"associatif et renvoie une liste de paires *section_name*, *section_proxy*, "
"en incluant la section *DEFAULTSECT*. Cependant, cette méthode peut aussi "
"être appelée avec des arguments : ``parser.items(section, raw, vars)``. Dans "
"ce cas, la méthode renvoie une liste de paires *option*, *value* pour la "
"section spécifiée, en interprétant les interpolations (à moins d'utiliser "
"``raw=True``)."

#: library/configparser.rst:430
msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings "
"working as expected."
msgstr ""
"Le protocole d'accès est implémenté au-dessus de l'ancienne API. Ainsi, les "
"sous-classes qui écrasent des méthodes de l'interface originale se "
"comportent correctement du point de vue du protocole d'accès."

#: library/configparser.rst:436
msgid "Customizing Parser Behaviour"
msgstr "Personnalisation du comportement de l'analyseur"

#: library/configparser.rst:438
msgid ""
"There are nearly as many INI format variants as there are applications using "
"it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to "
"customize some of the features."
msgstr ""
"Il existe pratiquement autant de variations du format *INI* que "
"d'applications qui l'utilisent. Le module :mod:`configparser` fait son "
"possible pour gérer le plus grand nombre de variantes raisonnables du style "
"*INI*. Le comportement par défaut est principalement contraint par des "
"raisons historiques. De ce fait, il est très probable qu'il soit nécessaire "
"de personnaliser certaines des fonctionnalités de ce module."

#: library/configparser.rst:444
msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`__init__` options:"
msgstr ""
"La méthode la plus fréquemment utilisée pour changer la façon dont se "
"comporte un analyseur est d’utiliser les options de la méthode :meth:"
"`__init__` :"

#: library/configparser.rst:447
msgid "*defaults*, default value: ``None``"
msgstr "*defaults*, valeur par défaut : ``None``"

#: library/configparser.rst:449
msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr ""
"Cette option accepte un dictionnaire de paires clé—valeurs qui seront "
"placées dans la section ``DEFAULT`` initialement. Ceci est une façon "
"élégante de prendre en charge des fichiers de configuration qui n'ont pas "
"besoin de spécifier de valeurs lorsque celles-ci sont identiques aux valeurs "
"par défaut documentées."

#: library/configparser.rst:454
msgid ""
"Hint: if you want to specify default values for a specific section, use :"
"meth:`read_dict` before you read the actual file."
msgstr ""
"Conseil : utilisez la méthode :meth:`read_dict` avant de lire le ficher de "
"configuration si vous voulez spécifier des valeurs par défaut pour une "
"section spécifique."

#: library/configparser.rst:457
msgid "*dict_type*, default value: :class:`dict`"
msgstr "*dict_type*, valeur par défaut : :class:`dict`"

#: library/configparser.rst:459
msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the standard dictionary, "
"every section is stored in the order they were added to the parser.  Same "
"goes for options within sections."
msgstr ""
"Cette option influe de manière importante sur la façon dont le protocole "
"d'accès associatif se comporte et ce à quoi ressemblent les fichiers de "
"configuration une fois écrits. Avec un dictionnaire standard, les sections "
"sont stockées dans l'ordre où elles ont été ajoutées à l'analyseur. Ceci est "
"également vrai pour les options à l'intérieur des sections."

#: library/configparser.rst:464
msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back."
msgstr ""
"Si vous souhaitez classer les sections et les options lors de l'écriture par "
"exemple, vous pouvez utiliser un type de dictionnaire différent."

#: library/configparser.rst:467
msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order "
"of the keys will be ordered.  For example:"
msgstr ""
"À noter : il est possible d'ajouter un ensemble de paires clés—valeurs en "
"une seule opération. L'ordre des clés est préservé si vous utilisez un "
"dictionnaire standard pour cela. Par exemple :"

#: library/configparser.rst:489
msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*, valeur par défaut : ``False``"

#: library/configparser.rst:491
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The "
"*allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"Certains fichiers de configurations sont connus pour contenir des options "
"sans valeur associée, tout en se conformant à la syntaxe prise en charge par "
"le module :mod:`configparser` par ailleurs. Pour indiquer que de telles "
"valeurs sont acceptables, utilisez le paramètre *allow_no_value* lors de la "
"construction de l'instance :"

#: library/configparser.rst:526
msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*delimiters*, valeur par défaut : ``('=', ':')``"

#: library/configparser.rst:528
msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr ""
"Chaînes de caractères qui séparent les clés des valeurs à l'intérieur d'une "
"section. La première occurrence d'une telle chaîne à l'intérieur d'une ligne "
"est considérée comme un délimiteur. Cela signifie que les valeurs peuvent "
"contenir certains des délimiteurs (mais pas les clés)."

#: library/configparser.rst:532
msgid ""
"See also the *space_around_delimiters* argument to :meth:`ConfigParser."
"write`."
msgstr ""
"Voir aussi l'argument *space_around_delimiters* de la méthode :meth:"
"`ConfigParser.write`."

#: library/configparser.rst:535
msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr ""
"*comment_prefixes* (préfixes de commentaire) — valeur par défaut : ``('#', "
"';')``"

#: library/configparser.rst:537
msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr ""
"*inline_comment_prefixes* (préfixes de commentaire en ligne) — valeur par "
"défaut : ``('#', ';')``"

#: library/configparser.rst:539
msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"Les préfixes de commentaire indiquent le début d'un commentaire valide au "
"sein d'un fichier de configuration. Ils ne peuvent être utilisés qu'à "
"l'emplacement d'une ligne vide (potentiellement indentée). En revanche, les "
"préfixes de commentaires en ligne peuvent être utilisés après n'importe "
"quelle valeur valide (comme les noms des sections, les options et les lignes "
"vides). Par défaut, les commentaires en ligne sont désactivés et les "
"préfixes utilisés pour les commentaires à l'emplacement d'une ligne vide "
"sont `'#'`` et ``';'``."

#: library/configparser.rst:546
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"Les précédentes versions du module :mod:`configparser` se comportent comme "
"en utilisant ``comment_prefixes=('#',';')`` et "
"``inline_comment_prefixes=(';',)``."

#: library/configparser.rst:550
msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"Notez que les analyseurs ne prennent pas en charge l'échappement des "
"préfixes de commentaires. Ainsi, l'utilisation de *inline_comment_prefixes* "
"peut empêcher les utilisateurs de spécifier des valeurs qui contiennent des "
"caractères utilisés comme préfixe de commentaire. Dans le doute, il est "
"recommandé de ne pas utiliser *inline_comment_prefixes*. Dans tous les cas, "
"la seule façon de stocker des préfixes de commentaires au début d'une valeur "
"multi lignes est d'interpoler ceux-ci, par exemple ::"

#: library/configparser.rst:596
msgid "*strict*, default value: ``True``"
msgstr "*scrict*, valeur par défaut : ``True``"

#: library/configparser.rst:598
msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`read_file`, :"
"meth:`read_string` or :meth:`read_dict`).  It is recommended to use strict "
"parsers in new applications."
msgstr ""
"Quand la valeur ``True`` est spécifiée, le parseur refuse toute section ou "
"option dupliquée lors de la lecture d'une source unique (lorsque :meth:"
"`read_file`, :meth:`read_string` ou :meth:`read_dict` sont utilisées). Il "
"est recommandé d'utiliser un mode de fonctionnement strict pour les "
"analyseurs employés par de nouvelles applications."

#: library/configparser.rst:603
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr ""
"Les versions précédentes du module :mod:`configparser` se comportent comme "
"en utilisant ``strict=False``."

#: library/configparser.rst:607
msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*, valeur par défaut : ``True``"

#: library/configparser.rst:609
msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"Du point de vue des analyseurs, les valeurs peuvent s'étendre sur plusieurs "
"lignes à partir du moment où elles sont plus indentées que la clé qui les "
"contient. Par défaut les analyseurs autorisent les lignes vides à faire "
"partie de telles valeurs. Dans le même temps, les clés elles-mêmes peuvent "
"être indentées de façon à rendre le fichier plus lisible. En conséquence, il "
"est probable que l'utilisateur perde de vue la structure du fichier lorsque "
"celui-ci devient long et complexe. Prenez par exemple :"

#: library/configparser.rst:624
msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"Ceci est particulièrement problématique si l'utilisateur a configuré son "
"éditeur pour utiliser une police à chasse variable. C'est pourquoi il est "
"conseillé de ne pas prendre en charge les valeurs avec des lignes vides, à "
"moins que votre application en ait besoin. Dans ce cas, les lignes vides "
"sont toujours interprétées comme séparant des clés. Dans l'exemple ci-"
"dessus, cela produit deux clés : ``key`` et ``this``."

#: library/configparser.rst:630
msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: ``"
"\"DEFAULT\"``)"
msgstr ""
"*default_section*, valeur par défaut : ``configparser.DEFAULTSECT`` "
"(autrement dit : ``\"DEFAULT\"``)"

#: library/configparser.rst:633
msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or ``"
"\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the ``parser_instance."
"default_section`` attribute and may be modified at runtime (i.e. to convert "
"files from one format to another)."
msgstr ""

#: library/configparser.rst:644
msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr ""

#: library/configparser.rst:646
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. :class:"
"`RawConfigParser` has a default value of ``None``."
msgstr ""

#: library/configparser.rst:653
msgid "*converters*, default value: not set"
msgstr ""

#: library/configparser.rst:655
msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, "
"and :meth:`~ConfigParser.getboolean` are implemented.  Should other getters "
"be desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': decimal."
"Decimal}`` would add :meth:`getdecimal` on both the parser object and all "
"section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""

#: library/configparser.rst:666
msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""

#: library/configparser.rst:671
msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr ""

#: library/configparser.rst:677
msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``, "
"``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"Par défaut, la méthode :meth:`~ConfigParser.getboolean` considère les "
"valeurs suivantes comme vraies : `'1'``, ``'yes'``, ``'true'``, ``'on'``, et "
"les valeurs suivantes comme fausses : ``'0'``, ``'no'``, ``'false'``, "
"``'off'``. Vous pouvez changer ce comportement en spécifiant votre propre "
"dictionnaire associant des chaînes de caractères à des valeurs booléennes. "
"Par exemple :"

#: library/configparser.rst:695
msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or ``enabled``/"
"``disabled``."
msgstr ""

#: library/configparser.rst:701
msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""

#: library/configparser.rst:731
msgid ""
"The optionxform function transforms option names to a canonical form. This "
"should be an idempotent function: if the name is already in canonical form, "
"it should be returned unchanged."
msgstr ""

#: library/configparser.rst:738
msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered "
"part of the section name, thus ``[  larch  ]`` will be read as a section of "
"name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For "
"example:"
msgstr ""

#: library/configparser.rst:766
msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""

#: library/configparser.rst:772
msgid "Legacy API Examples"
msgstr ""

#: library/configparser.rst:774
msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""

#: library/configparser.rst:780
msgid "An example of writing to a configuration file::"
msgstr ""

#: library/configparser.rst:803
msgid "An example of reading the configuration file again::"
msgstr ""

#: library/configparser.rst:821
msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr ""

#: library/configparser.rst:854
msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr ""

#: library/configparser.rst:872
msgid "ConfigParser Objects"
msgstr ""

#: library/configparser.rst:876
msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""

#: library/configparser.rst:881
msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""

#: library/configparser.rst:887
msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or :exc:"
"`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` (default: "
"``True``), each empty line marks the end of an option.  Otherwise, internal "
"empty lines of a multiline option are kept as part of the value. When "
"*allow_no_value* is ``True`` (default: ``False``), options without values "
"are accepted; the value held for these is ``None`` and they are serialized "
"without the trailing delimiter."
msgstr ""

#: library/configparser.rst:897
msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes "
"(normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"on runtime using the ``default_section`` instance attribute."
msgstr ""

#: library/configparser.rst:902
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""

#: library/configparser.rst:908
msgid ""
"All option names used in interpolation will be passed through the :meth:"
"`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""

#: library/configparser.rst:914
msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`get*()` method on the parser "
"object and section proxies."
msgstr ""

#: library/configparser.rst:920
msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr ""

#: library/configparser.rst:923
msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""

#: library/configparser.rst:928
msgid "The *converters* argument was added."
msgstr ""

#: library/configparser.rst:931
msgid ""
"The *defaults* argument is read with :meth:`read_dict()`, providing "
"consistent behavior across the parser: non-string keys and values are "
"implicitly converted to strings."
msgstr ""

#: library/configparser.rst:1221
msgid ""
"The default *dict_type* is :class:`dict`, since it now preserves insertion "
"order."
msgstr ""

#: library/configparser.rst:942
msgid "Return a dictionary containing the instance-wide defaults."
msgstr ""

#: library/configparser.rst:947
msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr ""

#: library/configparser.rst:953
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""

#: library/configparser.rst:958
msgid "Non-string section names raise :exc:`TypeError`."
msgstr ""

#: library/configparser.rst:964
msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr ""

#: library/configparser.rst:970
msgid "Return a list of options available in the specified *section*."
msgstr ""

#: library/configparser.rst:975
msgid ""
"If the given *section* exists, and contains the given *option*, return :"
"const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""

#: library/configparser.rst:982
msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr ""

#: library/configparser.rst:985
msgid ""
"If *filenames* is a string, a :class:`bytes` object or a :term:`path-like "
"object`, it is treated as a single filename.  If a file named in *filenames* "
"cannot be opened, that file will be ignored.  This is designed so that you "
"can specify an iterable of potential configuration file locations (for "
"example, the current directory, the user's home directory, and some system-"
"wide directory), and all existing configuration files in the iterable will "
"be read."
msgstr ""

#: library/configparser.rst:994
msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using :meth:"
"`read_file` before calling :meth:`read` for any optional files::"
msgstr ""

#: library/configparser.rst:1007
msgid ""
"The *encoding* parameter.  Previously, all files were read using the default "
"encoding for :func:`open`."
msgstr ""

#: library/configparser.rst:1011
#, fuzzy
msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr ""
"Le paramètre  *filename* accepte un objet chemin-compatible :term:`path-like "
"object`."

#: library/configparser.rst:1014
msgid "The *filenames* parameter accepts a :class:`bytes` object."
msgstr ""

#: library/configparser.rst:1020
msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr ""

#: library/configparser.rst:1023
msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""

#: library/configparser.rst:1027
msgid "Replaces :meth:`readfp`."
msgstr ""

#: library/configparser.rst:1032
msgid "Parse configuration data from a string."
msgstr ""

#: library/configparser.rst:1034
msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""

#: library/configparser.rst:1043
msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""

#: library/configparser.rst:1049
msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr ""

#: library/configparser.rst:1052
msgid "This method can be used to copy state between parsers."
msgstr ""

#: library/configparser.rst:1059
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""

#: library/configparser.rst:1065
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the "
"*raw* argument is true.  Values for interpolation keys are looked up in the "
"same manner as the option."
msgstr ""

#: library/configparser.rst:1069
msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially "
"when using the mapping protocol)."
msgstr ""

#: library/configparser.rst:1077
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""

#: library/configparser.rst:1084
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""

#: library/configparser.rst:1091
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise :exc:"
"`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""

#: library/configparser.rst:1104
msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""

#: library/configparser.rst:1107
msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the :meth:"
"`get` method."
msgstr ""

#: library/configparser.rst:1111
msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr ""

#: library/configparser.rst:1119
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""

#: library/configparser.rst:1126
msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""

#: library/configparser.rst:1134
msgid ""
"Comments in the original configuration file are not preserved when writing "
"the configuration back. What is considered a comment, depends on the given "
"values for *comment_prefix* and *inline_comment_prefix*."
msgstr ""

#: library/configparser.rst:1142
msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""

#: library/configparser.rst:1150
msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr ""

#: library/configparser.rst:1156
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""

#: library/configparser.rst:1162
msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""

#: library/configparser.rst:1170
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr ""

#: library/configparser.rst:1176
msgid "Use :meth:`read_file` instead."
msgstr ""

#: library/configparser.rst:1179
msgid ""
":meth:`readfp` now iterates on *fp* instead of calling ``fp.readline()``."
msgstr ""

#: library/configparser.rst:1182
msgid ""
"For existing code calling :meth:`readfp` with arguments which don't support "
"iteration, the following generator may be used as a wrapper around the file-"
"like object::"
msgstr ""

#: library/configparser.rst:1192
msgid ""
"Instead of ``parser.readfp(fp)`` use ``parser."
"read_file(readline_generator(fp))``."
msgstr ""

#: library/configparser.rst:1198
msgid ""
"The maximum depth for recursive interpolation for :meth:`get` when the *raw* "
"parameter is false.  This is relevant only when the default *interpolation* "
"is used."
msgstr ""

#: library/configparser.rst:1206
msgid "RawConfigParser Objects"
msgstr ""

#: library/configparser.rst:1216
msgid ""
"Legacy variant of the :class:`ConfigParser`.  It has interpolation disabled "
"by default and allows for non-string section names, option names, and values "
"via its unsafe ``add_section`` and ``set`` methods, as well as the legacy "
"``defaults=`` keyword argument handling."
msgstr ""

#: library/configparser.rst:1226
msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""

#: library/configparser.rst:1233
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised."
msgstr ""

#: library/configparser.rst:1237
msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr ""

#: library/configparser.rst:1243
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use :class:"
"`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set to "
"true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""

#: library/configparser.rst:1250
msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a "
"file or get it in non-raw mode.  **Use the mapping protocol API** which does "
"not allow such assignments to take place."
msgstr ""

#: library/configparser.rst:1257
msgid "Exceptions"
msgstr "Exceptions"

#: library/configparser.rst:1261
msgid "Base class for all other :mod:`configparser` exceptions."
msgstr ""

#: library/configparser.rst:1266
msgid "Exception raised when a specified section is not found."
msgstr ""

#: library/configparser.rst:1271
msgid ""
"Exception raised if :meth:`add_section` is called with the name of a section "
"that is already present or in strict parsers when a section if found more "
"than once in a single input file, string or dictionary."
msgstr ""

#: library/configparser.rst:1275
msgid ""
"Optional ``source`` and ``lineno`` attributes and arguments to :meth:"
"`__init__` were added."
msgstr ""

#: library/configparser.rst:1282
msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""

#: library/configparser.rst:1290
msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr ""

#: library/configparser.rst:1296
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr ""

#: library/configparser.rst:1302
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of :"
"exc:`InterpolationError`."
msgstr ""

#: library/configparser.rst:1309
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ""

#: library/configparser.rst:1315
msgid ""
"Exception raised when the source text into which substitutions are made does "
"not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr ""

#: library/configparser.rst:1321
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr ""

#: library/configparser.rst:1327
msgid "Exception raised when errors occur attempting to parse a file."
msgstr ""

#: library/configparser.rst:1329
msgid ""
"The ``filename`` attribute and :meth:`__init__` argument were renamed to "
"``source`` for consistency."
msgstr ""

#: library/configparser.rst:1335
msgid "Footnotes"
msgstr "Notes"

#: library/configparser.rst:1336
msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""
