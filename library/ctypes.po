# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-09-23 16:16+0200\n"
"PO-Revision-Date: 2021-11-09 08:06+0100\n"
"Last-Translator: Antoine Wecxsteen\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.3\n"

#: library/ctypes.rst:2
msgid ":mod:`ctypes` --- A foreign function library for Python"
msgstr ":mod:`ctypes` — Bibliothèque Python d'appels à des fonctions externes"

#: library/ctypes.rst:11
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes` est une bibliothèque d'appel à des fonctions externes en "
"python. Elle fournit des types de données compatibles avec le langage C et "
"permet d'appeler des fonctions depuis des DLL ou des bibliothèques "
"partagées, rendant ainsi possible l'interfaçage de ces bibliothèques avec du "
"pur code Python."

#: library/ctypes.rst:19
msgid "ctypes tutorial"
msgstr "Didacticiel de *ctypes*"

#: library/ctypes.rst:21
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that "
"they actually work.  Since some code samples behave differently under Linux, "
"Windows, or macOS, they contain doctest directives in comments."
msgstr ""
"Remarque : les exemples de code de ce didacticiel utilisent :mod:`doctest` "
"pour s'assurer de leur propre bon fonctionnement. Vu que certains de ces "
"exemples ont un comportement différent en Linux, Windows ou macOS, ils "
"contiennent des directives *doctest* dans les commentaires."

#: library/ctypes.rst:25
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to :class:"
"`c_long`. So, you should not be confused if :class:`c_long` is printed if "
"you would expect :class:`c_int` --- they are actually the same type."
msgstr ""
"Remarque : le type :class:`c_int` du module apparaît dans certains de ces "
"exemples. Sur les plates-formes où ``sizeof(long) == sizeof(int)``, ce type "
"est un alias de :class:`c_long`. Ne soyez donc pas surpris si :class:"
"`c_long` s'affiche là où vous vous attendiez à :class:`c_int` — il s'agit "
"bien du même type."

#: library/ctypes.rst:33
msgid "Loading dynamic link libraries"
msgstr "Chargement des DLL"

#: library/ctypes.rst:35
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
":mod:`ctypes` fournit l'objet *cdll* pour charger des bibliothèques à liens "
"dynamiques (et les objets *windll* et *oledll* en Windows)."

#: library/ctypes.rst:38
msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :c:type:`HRESULT` error code. The "
"error code is used to automatically raise an :class:`OSError` exception when "
"the function call fails."
msgstr ""
"Une bibliothèque se charge en y accédant comme un attribut de ces objets. "
"*cdll* charge les bibliothèques qui exportent des fonctions utilisant la "
"convention d'appel standard ``cdecl``, alors que les bibliothèques qui se "
"chargent avec *windll* utilisent la convention d'appel ``stdcall``. *oledll* "
"utilise elle aussi la convention ``stdcall`` et suppose que les fonctions "
"renvoient un code d'erreur :c:type:`HRESULT` de Windows. Ce code d'erreur "
"est utilisé pour lever automatiquement une :class:`OSError` quand l'appel de "
"la fonction échoue."

#: library/ctypes.rst:46
msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"En Windows, les erreurs levaient auparavant une :exc:`WindowsError`, qui est "
"maintenant un alias de :exc:`OSError`."

#: library/ctypes.rst:51
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the cdecl calling "
"convention::"
msgstr ""
"Voici quelques exemples Windows. ``msvcrt`` est la bibliothèque standard C "
"de Microsoft qui contient la plupart des fonctions standards C. Elle suit la "
"convention d'appel *cdecl* ::"

#: library/ctypes.rst:63
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "Windows ajoute le suffixe habituel ``.dll`` automatiquement."

#: library/ctypes.rst:66
msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one being "
"used by Python. Where possible, use native Python functionality, or else "
"import and use the ``msvcrt`` module."
msgstr ""
"Accéder à la bibliothèque standard C par ``cdll.msvcrt`` utilise une version "
"obsolète de la bibliothèque qui peut avoir des problèmes de compatibilité "
"avec celle que Python utilise. Si possible, mieux vaut utiliser la "
"fonctionnalité native de Python, ou bien importer et utiliser le module "
"``msvcrt``."

#: library/ctypes.rst:71
msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`LoadLibrary` method of the dll loaders should be used, or "
"you should load the library by creating an instance of CDLL by calling the "
"constructor::"
msgstr ""
"Pour charger une bibliothèque en Linux, il faut passer le nom du fichier "
"*avec* son extension. Il est donc impossible de charger une bibliothèque en "
"accédant à un attribut. Il faut utiliser la méthode :meth:`LoadLibrary` des "
"chargeurs de DLL, ou bien charger la bibliothèque en créant une instance de "
"*CDLL* en appelant son constructeur ::"

#: library/ctypes.rst:89
msgid "Accessing functions from loaded dlls"
msgstr "Accès aux fonctions des DLL chargées"

#: library/ctypes.rst:91
msgid "Functions are accessed as attributes of dll objects::"
msgstr "Les fonctions sont alors des attributs des objets DLL ::"

#: library/ctypes.rst:106
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with an ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""
"Les DLL des systèmes *win32* comme ``kernel32`` et ``user32`` exportent "
"souvent une version ANSI et une version UNICODE d'une fonction. La version "
"UNICODE est exportée avec un ``W`` à la fin, et la version ANSI avec un "
"``A``. La fonction *win32* ``GetModuleHandle``, qui renvoie un *gestionnaire "
"de module* à partir de son nom, a le prototype C suivant (c'est une macro "
"qui décide d'exporter l'une ou l'autre à travers ``GetModuleHandle``, selon "
"qu'UNICODE est définie ou non) ::"

#: library/ctypes.rst:119
msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with bytes or string objects respectively."
msgstr ""
"*windll* n'en choisit pas une par magie, il faut accéder à la bonne en "
"écrivant explicitement ``GetModuleHandleA`` ou ``GetModuleHandleW`` et en "
"les appelant ensuite avec des objets octets ou avec des chaînes de "
"caractères, respectivement."

#: library/ctypes.rst:123
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use :func:"
"`getattr` to retrieve the function::"
msgstr ""
"Les DLL exportent parfois des fonctions dont les noms ne sont pas des "
"identifiants Python valides, comme ``\"??2@YAPAXI@Z\"``. Dans ce cas, il "
"faut utiliser :func:`getattr` pour accéder à la fonction ::"

#: library/ctypes.rst:131
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"Sous Windows, certaines DLL exportent des fonctions à travers un indice "
"plutôt qu'à travers un nom. On accède à une fonction en indiçant l'objet DLL "
"avec son index ::"

#: library/ctypes.rst:148
msgid "Calling functions"
msgstr "Appel de fonctions"

#: library/ctypes.rst:150
msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``time()`` function, which returns system time in seconds since the "
"Unix epoch, and the ``GetModuleHandleA()`` function, which returns a win32 "
"module handle."
msgstr ""
"Ces fonctions s'appellent comme n'importe quel appelable Python. Cet exemple "
"utilise la fonction ``time()``, qui renvoie le temps en secondes du système "
"depuis l'*epoch* Unix, et la fonction ``GetModuleHandleA()``, qui renvoie un "
"gestionnaire de module *win32*."

#: library/ctypes.rst:155
msgid ""
"This example calls both functions with a ``NULL`` pointer (``None`` should "
"be used as the ``NULL`` pointer)::"
msgstr ""
"Cet exemple appelle les deux fonctions avec un pointeur ``NULL`` (on utilise "
"``None`` pour passer un pointeur ``NULL``) ::"

#: library/ctypes.rst:164
msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""
"Une :exc:`ValueError` est levée quand on appelle une fonction ``stdcall`` "
"avec la convention d'appel ``cdecl`` et vice-versa ::"

#: library/ctypes.rst:179
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr ""
"Pour déterminer la convention d'appel, il faut consulter l'en-tête C ou la "
"documentation de la fonction à appeler."

#: library/ctypes.rst:182
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"En Windows, :mod:`ctypes` tire profit de la gestion structurée des "
"exceptions (*structured exception handling*) *win32* pour empêcher les "
"plantages dus à des interruptions, afin de préserver la protection globale "
"(*general protection faults*) du système, lorsque des fonctions sont "
"appelées avec un nombre incorrect d'arguments ::"

#: library/ctypes.rst:192
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway.  The :mod:`faulthandler` module can be helpful in "
"debugging crashes (e.g. from segmentation faults produced by erroneous C "
"library calls)."
msgstr ""
"Cependant, il y a suffisamment de façons de faire planter Python avec :mod:"
"`ctypes`, donc il faut être prudent dans tous les cas. Le module :mod:"
"`faulthandler` est pratique pour déboguer les plantages (p. ex. dus à des "
"erreurs de segmentation produites par des appels erronés à la bibliothèque "
"C)."

#: library/ctypes.rst:197
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only native "
"Python objects that can directly be used as parameters in these function "
"calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects and strings "
"are passed as pointer to the memory block that contains their data (:c:type:"
"`char *` or :c:type:`wchar_t *`).  Python integers are passed as the "
"platforms default C :c:type:`int` type, their value is masked to fit into "
"the C type."
msgstr ""
"``None``, les entiers, les objets octets et les chaînes de caractères "
"(Unicode) sont les seuls types natifs de Python qui peuvent être directement "
"passés en paramètres de ces appels de fonctions. ``None`` est passé comme le "
"pointeur C ``NULL``, les objets octets et les chaînes de caractères sont "
"passés comme un pointeur sur le bloc mémoire qui contient la donnée (:c:type:"
"`char *` ou :c:type:`wchar_t *`). Les entiers Python sont passés comme le "
"type C :c:type:`int` par défaut de la plate-forme, un masque étant appliqué "
"pour qu'ils tiennent dans le type C."

#: library/ctypes.rst:204
msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr ""
"Avant de poursuivre sur l'appel de fonctions avec d'autres types de "
"paramètres, apprenons-en un peu plus sur les types de données de :mod:"
"`ctypes`."

#: library/ctypes.rst:2143
msgid "Fundamental data types"
msgstr "Types de données de base"

#: library/ctypes.rst:213
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ""
":mod:`ctypes` définit plusieurs types de donnée de base compatibles avec le "
"C :"

#: library/ctypes.rst:216
msgid "ctypes type"
msgstr "Types de *ctypes*"

#: library/ctypes.rst:216
msgid "C type"
msgstr "Type C"

#: library/ctypes.rst:216
msgid "Python type"
msgstr "Type Python"

#: library/ctypes.rst:218
msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

#: library/ctypes.rst:218
msgid ":c:type:`_Bool`"
msgstr ":c:type:`_Bool`"

#: library/ctypes.rst:218
msgid "bool (1)"
msgstr "*bool* (1)"

#: library/ctypes.rst:220
msgid ":class:`c_char`"
msgstr ":class:`c_char`"

#: library/ctypes.rst:224
msgid ":c:type:`char`"
msgstr ":c:type:`char`"

#: library/ctypes.rst:220
msgid "1-character bytes object"
msgstr "objet octet (*bytes*) de 1 caractère"

#: library/ctypes.rst:222
msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

#: library/ctypes.rst:222
msgid ":c:type:`wchar_t`"
msgstr ":c:type:`wchar_t`"

#: library/ctypes.rst:222
msgid "1-character string"
msgstr "chaîne de caractères (*string*) de longueur 1"

#: library/ctypes.rst:224
msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

#: library/ctypes.rst:226 library/ctypes.rst:230 library/ctypes.rst:234
#: library/ctypes.rst:238 library/ctypes.rst:242 library/ctypes.rst:247
msgid "int"
msgstr "*int*"

#: library/ctypes.rst:226
msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

#: library/ctypes.rst:226
msgid ":c:type:`unsigned char`"
msgstr ":c:type:`unsigned char`"

#: library/ctypes.rst:228
msgid ":class:`c_short`"
msgstr ":class:`c_short`"

#: library/ctypes.rst:228
msgid ":c:type:`short`"
msgstr ":c:type:`short`"

#: library/ctypes.rst:230
msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

#: library/ctypes.rst:230
msgid ":c:type:`unsigned short`"
msgstr ":c:type:`unsigned short`"

#: library/ctypes.rst:232
msgid ":class:`c_int`"
msgstr ":class:`c_int`"

#: library/ctypes.rst:232
msgid ":c:type:`int`"
msgstr ":c:type:`int`"

#: library/ctypes.rst:234
msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

#: library/ctypes.rst:234
msgid ":c:type:`unsigned int`"
msgstr ":c:type:`unsigned int`"

#: library/ctypes.rst:236
msgid ":class:`c_long`"
msgstr ":class:`c_long`"

#: library/ctypes.rst:236
msgid ":c:type:`long`"
msgstr ":c:type:`long`"

#: library/ctypes.rst:238
msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

#: library/ctypes.rst:238
msgid ":c:type:`unsigned long`"
msgstr ":c:type:`unsigned long`"

#: library/ctypes.rst:240
msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

#: library/ctypes.rst:240
msgid ":c:type:`__int64` or :c:type:`long long`"
msgstr ":c:type:`__int64` ou :c:type:`long long`"

#: library/ctypes.rst:242
msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

#: library/ctypes.rst:242
msgid ":c:type:`unsigned __int64` or :c:type:`unsigned long long`"
msgstr ":c:type:`unsigned __int64` ou :c:type:`unsigned long long`"

#: library/ctypes.rst:245
msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

#: library/ctypes.rst:245
msgid ":c:type:`size_t`"
msgstr ":c:type:`size_t`"

#: library/ctypes.rst:247
msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

#: library/ctypes.rst:247
msgid ":c:type:`ssize_t` or :c:type:`Py_ssize_t`"
msgstr ":c:type:`ssize_t` ou :c:type:`Py_ssize_t`"

#: library/ctypes.rst:250
msgid ":class:`c_float`"
msgstr ":class:`c_float`"

#: library/ctypes.rst:250
msgid ":c:type:`float`"
msgstr ":c:type:`float`"

#: library/ctypes.rst:252 library/ctypes.rst:254
msgid "float"
msgstr "*float*"

#: library/ctypes.rst:252
msgid ":class:`c_double`"
msgstr ":class:`c_double`"

#: library/ctypes.rst:252
msgid ":c:type:`double`"
msgstr ":c:type:`double`"

#: library/ctypes.rst:254
msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

#: library/ctypes.rst:254
msgid ":c:type:`long double`"
msgstr ":c:type:`long double`"

#: library/ctypes.rst:256
msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

#: library/ctypes.rst:256
msgid ":c:type:`char *` (NUL terminated)"
msgstr ":c:type:`char *` (terminé par NUL)"

#: library/ctypes.rst:256
msgid "bytes object or ``None``"
msgstr "objet octet (*bytes*) ou ``None``"

#: library/ctypes.rst:258
msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

#: library/ctypes.rst:258
msgid ":c:type:`wchar_t *` (NUL terminated)"
msgstr ":c:type:`wchar_t *` (terminé par NUL)"

#: library/ctypes.rst:258
msgid "string or ``None``"
msgstr "chaîne de caractères (*string*) ou ``None``"

#: library/ctypes.rst:260
msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

#: library/ctypes.rst:260
msgid ":c:type:`void *`"
msgstr ":c:type:`void *`"

#: library/ctypes.rst:260
msgid "int or ``None``"
msgstr "*int* ou ``None``"

#: library/ctypes.rst:264
msgid "The constructor accepts any object with a truth value."
msgstr "Le constructeur accepte n'importe quel objet convertible en booléen."

#: library/ctypes.rst:266
msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr ""
"Il est possible de créer chacun de ces types en les appelant avec une valeur "
"d'initialisation du bon type et avec une valeur cohérente ::"

#: library/ctypes.rst:277
msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr ""
"Ces types étant des muables, leur valeur peut aussi être modifiée après "
"coup ::"

#: library/ctypes.rst:289
msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, :"
"class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they "
"point to, *not the contents* of the memory block (of course not, because "
"Python bytes objects are immutable)::"
msgstr ""
"Affecter une nouvelle valeur à une instance de type pointeur — :class:"
"`c_char_p`, :class:`c_wchar_p` et :class:`c_void_p` — change *la zone "
"mémoire* sur laquelle elle pointe, et non *le contenu* de ce bloc mémoire "
"(c'est logique parce que les objets octets sont immuables en Python) ::"

#: library/ctypes.rst:309
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a :"
"func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the "
"``value`` property::"
msgstr ""
"Cependant, prenez garde à ne pas en passer à des fonctions qui prennent en "
"paramètre des pointeurs sur de la mémoire modifiable. S'il vous faut de la "
"mémoire modifiable, *ctypes* fournit la fonction :func:"
"`create_string_buffer` qui en crée de plusieurs façons. L'attribut ``raw`` "
"permet d'accéder à (ou de modifier) un bloc mémoire ; l'attribut ``value`` "
"permet d'y accéder comme à une chaîne de caractères terminée par NUL ::"

#: library/ctypes.rst:333
msgid ""
"The :func:`create_string_buffer` function replaces the :func:`c_buffer` "
"function (which is still available as an alias), as well as the :func:"
"`c_string` function from earlier ctypes releases.  To create a mutable "
"memory block containing unicode characters of the C type :c:type:`wchar_t` "
"use the :func:`create_unicode_buffer` function."
msgstr ""
"La fonction :func:`create_string_buffer` remplace les fonctions :func:"
"`c_buffer` (qui en reste un alias) et :func:`c_string` des versions "
"antérieures de *ctypes*. La fonction :func:`create_unicode_buffer` crée un "
"bloc mémoire modifiable contenant des caractères Unicode du type C :c:type:"
"`wchar_t`."

#: library/ctypes.rst:343
msgid "Calling functions, continued"
msgstr "Appel de fonctions, suite"

#: library/ctypes.rst:345
msgid ""
"Note that printf prints to the real standard output channel, *not* to :data:"
"`sys.stdout`, so these examples will only work at the console prompt, not "
"from within *IDLE* or *PythonWin*::"
msgstr ""
"*printf* utilise la vraie sortie standard, et non :data:`sys.stdout` ; les "
"exemples suivants ne fonctionnent donc que dans une invite de commande et "
"non depuis *IDLE* or *PythonWin* ::"

#: library/ctypes.rst:365
msgid ""
"As has been mentioned before, all Python types except integers, strings, and "
"bytes objects have to be wrapped in their corresponding :mod:`ctypes` type, "
"so that they can be converted to the required C data type::"
msgstr ""
"Comme mentionné plus haut, tous les types Python (les entiers, les chaînes "
"de caractères et les objets octet exceptés) doivent être encapsulés dans "
"leur type :mod:`ctypes` correspondant pour pouvoir être convertis dans le "
"type C requis ::"

#: library/ctypes.rst:378
msgid "Calling functions with your own custom data types"
msgstr "Appel de fonctions avec des types de données personnalisés"

#: library/ctypes.rst:380
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments.  :mod:`ctypes` looks for "
"an :attr:`_as_parameter_` attribute and uses this as the function argument.  "
"Of course, it must be one of integer, string, or bytes::"
msgstr ""
"Il est possible de personnaliser la conversion des arguments effectuée par :"
"mod:`ctypes` pour permettre de passer en argument des instances de vos "
"propres classes. :mod:`ctypes` recherche un attribut :attr:`_as_parameter_` "
"et le prend comme argument à la fonction. Bien entendu, cet attribut doit "
"être un entier, une chaîne de caractères ou des octets ::"

#: library/ctypes.rst:395
msgid ""
"If you don't want to store the instance's data in the :attr:`_as_parameter_` "
"instance variable, you could define a :class:`property` which makes the "
"attribute available on request."
msgstr ""
"Si vous ne souhaitez pas stocker les données de l'instance dans la variable :"
"attr:`_as_parameter_` de l'instance, vous pouvez toujours définir une :class:"
"`propriété <property>` qui rend cet attribut disponible sur demande."

#: library/ctypes.rst:403
msgid "Specifying the required argument types (function prototypes)"
msgstr "Définition du type des arguments nécessaires (prototypes de fonction)"

#: library/ctypes.rst:405
msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`argtypes` attribute."
msgstr ""
"Il est possible de définir le type des arguments demandés par une fonction "
"exportée depuis une DLL en définissant son attribut :attr:`argtypes`."

#: library/ctypes.rst:408
msgid ""
":attr:`argtypes` must be a sequence of C data types (the ``printf`` function "
"is probably not a good example here, because it takes a variable number and "
"different types of parameters depending on the format string, on the other "
"hand this is quite handy to experiment with this feature)::"
msgstr ""
":attr:`argtypes` doit être une séquence de types de données C (la fonction "
"``printf`` n'est probablement pas le meilleur exemple pour l'illustrer, car "
"elle accepte un nombre variable d'arguments de types eux aussi variables, "
"selon la chaîne de formatage ; cela dit, elle se révèle pratique pour tester "
"cette fonctionnalité) ::"

#: library/ctypes.rst:419
msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr ""
"Définir un format empêche de passer des arguments de type incompatible "
"(comme le fait le prototype d'une fonction C) et tente de convertir les "
"arguments en des types valides ::"

#: library/ctypes.rst:431
msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`from_param` class method for them to be able to "
"use them in the :attr:`argtypes` sequence. The :meth:`from_param` class "
"method receives the Python object passed to the function call, it should do "
"a typecheck or whatever is needed to make sure this object is acceptable, "
"and then return the object itself, its :attr:`_as_parameter_` attribute, or "
"whatever you want to pass as the C function argument in this case. Again, "
"the result should be an integer, string, bytes, a :mod:`ctypes` instance, or "
"an object with an :attr:`_as_parameter_` attribute."
msgstr ""
"Pour appeler une fonction avec votre propre classe définie dans la séquence :"
"attr:`argtypes`, il est nécessaire d'implémenter une méthode de classe :meth:"
"`from_param`. La méthode de classe :meth:`from_param` récupère l'objet "
"Python passé à la fonction et doit faire une vérification de type ou tout ce "
"qui est nécessaire pour s'assurer que l'objet est valide, puis renvoie "
"l'objet lui-même, son attribut :attr:`_as_parameter_`, ou tout ce que vous "
"voulez passer comme argument fonction C dans ce cas. Encore une fois, il "
"convient que le résultat soit un entier, une chaîne, des octets, une "
"instance :mod:`ctypes` ou un objet avec un attribut :attr:`_as_parameter_`."

#: library/ctypes.rst:445
msgid "Return types"
msgstr "Types de sortie"

#: library/ctypes.rst:447
msgid ""
"By default functions are assumed to return the C :c:type:`int` type.  Other "
"return types can be specified by setting the :attr:`restype` attribute of "
"the function object."
msgstr ""
"Le module suppose que toutes les fonctions renvoient par défaut un :c:type:"
"`int` C. Pour préciser un autre type de sortie, il faut définir l'attribut :"
"attr:`restype` de l'objet encapsulant la fonction."

#: library/ctypes.rst:451
msgid ""
"Here is a more advanced example, it uses the ``strchr`` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""
"Voici un exemple plus poussé. Celui-ci utilise la fonction ``strchr``, qui "
"prend en paramètres un pointeur vers une chaîne et un caractère. Elle "
"renvoie un pointeur sur une chaîne de caractères ::"

#: library/ctypes.rst:464
msgid ""
"If you want to avoid the ``ord(\"x\")`` calls above, you can set the :attr:"
"`argtypes` attribute, and the second argument will be converted from a "
"single character Python bytes object into a C char::"
msgstr ""
"Pour économiser l'appel ``ord(\"x\")``, il est possible de définir "
"l'attribut :attr:`argtypes` ; le second argument, un objet octet à un seul "
"caractère, sera automatiquement converti en un caractère C ::"

#: library/ctypes.rst:482
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`restype` attribute, if the foreign function returns "
"an integer.  The callable will be called with the *integer* the C function "
"returns, and the result of this call will be used as the result of your "
"function call. This is useful to check for error return values and "
"automatically raise an exception::"
msgstr ""
"Si la fonction à interfacer renvoie un entier, l'attribut :attr:`restype` "
"peut aussi être un appelable (une fonction ou une classe par exemple). Dans "
"ce cas, l'appelable est appelé avec l'entier renvoyé par la fonction et le "
"résultat de cet appel sera le résultat final de l'appel à la fonction. C'est "
"pratique pour vérifier les codes d'erreurs des valeurs de retour et lever "
"automatiquement des exceptions ::"

#: library/ctypes.rst:505
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is "
"used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError`` appelle l'API Windows ``FormatMessage()`` pour obtenir une "
"représentation de la chaîne de caractères qui correspond au code d'erreur, "
"et *renvoie* une exception. ``WinError`` prend en paramètre — optionnel — le "
"code d'erreur. Si celui-ci n'est pas passé, elle appelle :func:"
"`GetLastError` pour le récupérer."

#: library/ctypes.rst:510
msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`errcheck` attribute; see the reference manual for details."
msgstr ""
"Notez cependant que l'attribut :attr:`errcheck` permet de vérifier bien plus "
"efficacement les erreurs ; référez-vous au manuel de référence pour plus de "
"précisions."

#: library/ctypes.rst:517
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "Passage de pointeurs (passage de paramètres par référence)"

#: library/ctypes.rst:519
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""
"Il arrive qu'une fonction C du code à interfacer requière un *pointeur* vers "
"un certain type de donnée en paramètre, typiquement pour écrire à l'endroit "
"correspondant ou si la donnée est trop grande pour pouvoir être passée par "
"valeur. Ce mécanisme est appelé *passage de paramètres par référence*."

#: library/ctypes.rst:523
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the :func:"
"`pointer` function, although :func:`pointer` does a lot more work since it "
"constructs a real pointer object, so it is faster to use :func:`byref` if "
"you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes` contient la fonction :func:`byref` qui permet de passer des "
"paramètres par référence. La fonction :func:`pointer` a la même utilité, "
"mais fait plus de travail car :func:`pointer` construit un véritable objet "
"pointeur. Ainsi, si vous n'avez pas besoin de cet objet dans votre code "
"Python, utiliser :func:`byref` est plus performant ::"

#: library/ctypes.rst:545
msgid "Structures and unions"
msgstr "Structures et unions"

#: library/ctypes.rst:547
msgid ""
"Structures and unions must derive from the :class:`Structure` and :class:"
"`Union` base classes which are defined in the :mod:`ctypes` module. Each "
"subclass must define a :attr:`_fields_` attribute.  :attr:`_fields_` must be "
"a list of *2-tuples*, containing a *field name* and a *field type*."
msgstr ""
"Les structures et les unions doivent hériter des classes de base :class:"
"`Structure` et :class:`Union` définies dans le module :mod:`ctypes`. Chaque "
"sous-classe doit définir un attribut :attr:`_fields_`. :attr:`_fields_` doit "
"être une liste de *paires*, contenant un *nom de champ* et un *type de "
"champ*."

#: library/ctypes.rst:552
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"Le type de champ doit être un type :mod:`ctypes` comme :class:`c_int` ou un "
"type :mod:`ctypes` dérivé : structure, union, tableau ou pointeur."

#: library/ctypes.rst:555
msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""
"Voici un exemple simple : une structure POINT qui contient deux entiers *x* "
"et *y* et qui montre également comment instancier une structure avec le "
"constructeur ::"

#: library/ctypes.rst:575
msgid ""
"You can, however, build much more complicated structures.  A structure can "
"itself contain other structures by using a structure as a field type."
msgstr ""
"Il est bien entendu possible de créer des structures plus complexes. Une "
"structure peut elle-même contenir d'autres structures en prenant une "
"structure comme type de champ."

#: library/ctypes.rst:578
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr ""
"Voici une structure RECT qui contient deux POINTs *upperleft* et "
"*lowerright* ::"

#: library/ctypes.rst:592
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr ""
"Une structure encapsulée peut être instanciée par un constructeur de "
"plusieurs façons ::"

#: library/ctypes.rst:597
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""
"Il est possible de récupérer les :term:`descripteurs <descriptor>` des "
"champs depuis la *classe*. Ils sont importants pour déboguer car ils "
"contiennent des informations utiles ::"

#: library/ctypes.rst:611
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-fields "
"to functions by value.  While this may work on 32-bit x86, it's not "
"guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by pointer."
msgstr ""
":mod:`ctypes` ne prend pas en charge le passage par valeur des unions ou des "
"structures avec des champs de bits. Bien que cela puisse fonctionner sur des "
"architectures 32 bits avec un jeu d'instructions x86, ce n'est pas garanti "
"par la bibliothèque en général. Les unions et les structures avec des champs "
"de bits doivent toujours être passées par pointeur."

#: library/ctypes.rst:617
msgid "Structure/union alignment and byte order"
msgstr "Alignement et boutisme des structures et des unions"

#: library/ctypes.rst:619
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior by specifying a :"
"attr:`_pack_` class attribute in the subclass definition. This must be set "
"to a positive integer and specifies the maximum alignment for the fields. "
"This is what ``#pragma pack(n)`` also does in MSVC."
msgstr ""
"Par défaut les champs d'une *Structure* ou d'une *Union* sont alignés de la "
"même manière que le ferait un compilateur C. Ce comportement peut être "
"redéfini en définissant l'attribut :attr:`_pack_` dans la définition de la "
"sous-classe. Ce champ doit être un entier positif et vaut l'alignement "
"maximal des champs. C'est ce que fait ``#pragma pack(n)`` pour MSVC."

#: library/ctypes.rst:625
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These "
"classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes` suit le boutisme natif pour les *Structure* et les *Union*. "
"Pour construire des structures avec un boutisme différent, utilisez les "
"classes de base :class:`BigEndianStructure`, :class:"
"`LittleEndianStructure`, :class:`BigEndianUnion` ou :class:"
"`LittleEndianUnion`. Ces classes ne peuvent pas avoir de champ pointeur."

#: library/ctypes.rst:635
msgid "Bit fields in structures and unions"
msgstr "Champs de bits dans les structures et les unions"

#: library/ctypes.rst:637
msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`_fields_` tuples::"
msgstr ""
"Il est possible de créer des structures et des unions contenant des champs "
"de bits. Seuls les entiers peuvent être des champs de bits, le nombre de "
"bits est défini dans le troisième champ du *n*-uplet :attr:`_fields_` ::"

#: library/ctypes.rst:655
msgid "Arrays"
msgstr "Tableaux"

#: library/ctypes.rst:657
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr ""
"Les tableaux sont des séquences qui contiennent un nombre fixe d'instances "
"du même type."

#: library/ctypes.rst:659
msgid ""
"The recommended way to create array types is by multiplying a data type with "
"a positive integer::"
msgstr ""
"La meilleure façon de créer des tableaux consiste à multiplier le type de "
"donnée par un entier positif ::"

#: library/ctypes.rst:664
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr ""
"Voici un exemple — un peu artificiel — d'une structure contenant, entre "
"autres, 4 POINTs ::"

#: library/ctypes.rst:680
msgid "Instances are created in the usual way, by calling the class::"
msgstr "Comme d'habitude, on crée les instances en appelant la classe ::"

#: library/ctypes.rst:686
msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr ""
"Le code précédent affiche une suite de ``0 0`` car le contenu du tableau est "
"initialisé avec des zéros."

#: library/ctypes.rst:689
msgid "Initializers of the correct type can also be specified::"
msgstr "Des valeurs d'initialisation du bon type peuvent être passées ::"

#: library/ctypes.rst:705
msgid "Pointers"
msgstr "Pointeurs"

#: library/ctypes.rst:707
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a :"
"mod:`ctypes` type::"
msgstr ""
"On crée une instance de pointeur en appelant la fonction :func:`pointer` sur "
"un type :mod:`ctypes` ::"

#: library/ctypes.rst:715
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which returns "
"the object to which the pointer points, the ``i`` object above::"
msgstr ""
"Les instances de pointeurs ont un attribut :attr:`~_Pointer.contents` qui "
"renvoie l'objet pointé (l'objet ``i`` ci-dessus) ::"

#: library/ctypes.rst:722
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
"Attention, :mod:`ctypes` ne fait pas de ROI (retour de l'objet initial). Il "
"crée un nouvel objet à chaque fois qu'on accède à un attribut ::"

#: library/ctypes.rst:731
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this "
"is stored::"
msgstr ""
"Affecter une autre instance de :class:`c_int` à l'attribut *contents* du "
"pointeur fait pointer le pointeur vers l'adresse mémoire de cette nouvelle "
"instance ::"

#: library/ctypes.rst:743
msgid "Pointer instances can also be indexed with integers::"
msgstr "Il est possible d'indexer les pointeurs par des entiers ::"

#: library/ctypes.rst:749
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "Affecter à travers un indice change la valeur pointée ::"

#: library/ctypes.rst:758
msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from "
"a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""
"Si vous êtes sûr de vous, vous pouvez utiliser d'autres valeurs que 0, comme "
"en C : il est ainsi possible de modifier une zone mémoire de votre choix. De "
"manière générale cette fonctionnalité ne s'utilise que sur un pointeur "
"renvoyé par une fonction C, pointeur que vous *savez* pointer vers un "
"tableau et non sur un seul élément."

#: library/ctypes.rst:764
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create "
"pointer instances, it has to create pointer *types* first. This is done with "
"the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and "
"returns a new type::"
msgstr ""
"Sous le capot, la fonction :func:`pointer` fait plus que simplement créer "
"une instance de pointeur ; elle doit d'abord créer un type « pointeur "
"sur… ». Cela s'effectue avec la fonction :func:`POINTER`, qui prend en "
"paramètre n'importe quel type :mod:`ctypes` et renvoie un nouveau type ::"

#: library/ctypes.rst:780
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"Appeler le pointeur sur type sans arguments crée un pointeur ``NULL``. Les "
"pointeurs ``NULL`` s'évaluent à ``False`` ::"

#: library/ctypes.rst:788
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes` vérifie que le pointeur n'est pas ``NULL`` quand il en "
"déréférence un (mais déréférencer des pointeurs non ``NULL`` invalides fait "
"planter Python) ::"

#: library/ctypes.rst:807
msgid "Type conversions"
msgstr "Conversions de type"

#: library/ctypes.rst:809
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`argtypes` list of a function or as the type "
"of a member field in a structure definition, only instances of exactly the "
"same type are accepted.  There are some exceptions to this rule, where "
"ctypes accepts other objects.  For example, you can pass compatible array "
"instances instead of pointer types.  So, for ``POINTER(c_int)``, ctypes "
"accepts an array of c_int::"
msgstr ""
"En général, *ctypes* respecte un typage fort. Cela signifie que si un "
"``POINTER(c_int)`` est présent dans la liste des :attr:`argtypes` d'une "
"fonction ou est le type d'un attribut membre dans une définition de "
"structure, seules des instances de ce type seront valides. Cette règle "
"comporte quelques exceptions pour lesquelles *ctypes* accepte d'autres "
"objets. Par exemple il est possible de passer des instances de tableau à "
"place de pointeurs, s'ils sont compatibles. Dans le cas de "
"``POINTER(c_int)``, *ctypes* accepte des tableaux de *c_int* ::"

#: library/ctypes.rst:830
msgid ""
"In addition, if a function argument is explicitly declared to be a pointer "
"type (such as ``POINTER(c_int)``) in :attr:`argtypes`, an object of the "
"pointed type (``c_int`` in this case) can be passed to the function.  ctypes "
"will apply the required :func:`byref` conversion in this case automatically."
msgstr ""
"De plus, si un paramètre de fonction est déclaré explicitement de type "
"pointeur (comme ``POINTER(c_int)``) dans les :attr:`argtypes`, il est aussi "
"possible de passer un objet du type pointé — ici, ``c_int`` — à la fonction. "
"*ctypes* appelle alors automatiquement la fonction de conversion :func:"
"`byref`."

#: library/ctypes.rst:835
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr ""
"Pour mettre un champ de type *POINTER* à ``NULL``, il faut lui affecter "
"``None`` ::"

#: library/ctypes.rst:842
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""
"Parfois il faut gérer des incompatibilités entre les types. En C, il est "
"possible de convertir un type en un autre. :mod:`ctypes` fournit la "
"fonction :func:`cast` qui permet la même chose. La structure ``Bar`` ci-"
"dessus accepte des pointeurs ``POINTER(c_int)`` ou des tableaux de :class:"
"`c_int` comme valeur pour le champ ``values``, mais pas des instances "
"d'autres types ::"

#: library/ctypes.rst:854
msgid "For these cases, the :func:`cast` function is handy."
msgstr "C'est là que la fonction :func:`cast` intervient."

#: library/ctypes.rst:856
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters, "
"a ctypes object that is or can be converted to a pointer of some kind, and a "
"ctypes pointer type.  It returns an instance of the second argument, which "
"references the same memory block as the first argument::"
msgstr ""
"La fonction :func:`cast` permet de convertir une instance de *ctypes* en un "
"pointeur vers un type de données *ctypes* différent. :func:`cast` prend deux "
"paramètres : un objet *ctypes* qui est, ou qui peut être converti en, un "
"certain pointeur et un type pointeur de *ctypes*. Elle renvoie une instance "
"du second argument, qui pointe sur le même bloc mémoire que le premier "
"argument ::"

#: library/ctypes.rst:867
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr ""
"Ainsi, la fonction :func:`cast` permet de remplir le champ ``values`` de la "
"structure ``Bar`` ::"

#: library/ctypes.rst:880
msgid "Incomplete Types"
msgstr "Types incomplets"

#: library/ctypes.rst:882
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr ""
"Un *type incomplet* est une structure, une union ou un tableau dont les "
"membres ne sont pas encore définis. C'est l'équivalent d'une déclaration "
"avancée en C, où la définition est fournie plus tard ::"

#: library/ctypes.rst:893
msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr ""
"Une traduction naïve, mais invalide, en code *ctypes* ressemblerait à ça ::"

#: library/ctypes.rst:906
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the :attr:"
"`_fields_` attribute later, after the class statement::"
msgstr ""
"Cela ne fonctionne pas parce que la nouvelle ``class cell`` n'est pas "
"accessible dans la définition de la classe elle-même. Dans le module :mod:"
"`ctypes`, on définit la classe ``cell`` et on définira les :attr:`_fields_` "
"plus tard, après avoir défini la classe ::"

#: library/ctypes.rst:918
msgid ""
"Let's try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr ""
"Essayons. Nous créons deux instances de ``cell``, les faisons pointer l'une "
"sur l'autre et enfin nous suivons quelques maillons de la chaîne de "
"pointeurs ::"

#: library/ctypes.rst:939
msgid "Callback functions"
msgstr "Fonctions de rappel"

#: library/ctypes.rst:941
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes` permet de créer des pointeurs de fonctions appelables par des "
"appelables Python. On les appelle parfois *fonctions de rappel*."

#: library/ctypes.rst:944
msgid ""
"First, you must create a class for the callback function. The class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"Tout d'abord, il faut créer une classe pour la fonction de rappel. La classe "
"connaît la convention d'appel, le type de retour ainsi que le nombre et le "
"type de paramètres que la fonction accepte."

#: library/ctypes.rst:948
msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback functions "
"using the ``cdecl`` calling convention. On Windows, the :func:`WINFUNCTYPE` "
"factory function creates types for callback functions using the ``stdcall`` "
"calling convention."
msgstr ""
"La fabrique :func:`CFUNCTYPE` crée un type pour les fonctions de rappel qui "
"suivent la convention d'appel ``cdecl``. En Windows, c'est la fabrique :func:"
"`WINFUNCTYPE` qui crée un type pour les fonctions de rappel qui suivent la "
"convention d'appel ``stdcall``."

#: library/ctypes.rst:953
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr ""
"Le premier paramètre de ces deux fonctions est le type de retour, et les "
"suivants sont les types des arguments qu'attend la fonction de rappel."

#: library/ctypes.rst:957
msgid ""
"I will present an example here which uses the standard C library's :c:func:"
"`qsort` function, that is used to sort items with the help of a callback "
"function.  :c:func:`qsort` will be used to sort an array of integers::"
msgstr ""
"Intéressons-nous à un exemple tiré de la bibliothèque standard C : la "
"fonction :c:func:`qsort`. Celle-ci permet de classer des éléments par "
"l'emploi d'une fonction de rappel. Nous allons utiliser :c:func:`qsort` pour "
"ordonner un tableau d'entiers ::"

#: library/ctypes.rst:967
msgid ""
":func:`qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two "
"pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer "
"otherwise."
msgstr ""
":func:`qsort` doit être appelée avec un pointeur vers la donnée à ordonner, "
"le nombre d'éléments dans la donnée, la taille d'un élément et un pointeur "
"vers le comparateur, c.-à-d. la fonction de rappel. Cette fonction sera "
"invoquée avec deux pointeurs sur deux éléments et doit renvoyer un entier "
"négatif si le premier élément est plus petit que le second, zéro s'ils sont "
"égaux et un entier positif sinon."

#: library/ctypes.rst:973
msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""
"Ainsi notre fonction de rappel reçoit des pointeurs vers des entiers et doit "
"renvoyer un entier. Créons d'abord le ``type`` pour la fonction de rappel ::"

#: library/ctypes.rst:979
msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr ""
"Pour commencer, voici une fonction de rappel simple qui affiche les valeurs "
"qu'on lui passe ::"

#: library/ctypes.rst:989
msgid "The result::"
msgstr "Résultat ::"

#: library/ctypes.rst:999
msgid "Now we can actually compare the two items and return a useful result::"
msgstr ""
"À présent, comparons pour de vrai les deux entiers et renvoyons un résultat "
"utile ::"

#: library/ctypes.rst:1014
msgid "As we can easily check, our array is sorted now::"
msgstr ""
"Et comme il est facile de le voir, notre tableau est désormais classé ::"

#: library/ctypes.rst:1021
msgid ""
"The function factories can be used as decorator factories, so we may as well "
"write::"
msgstr ""
"Ces fonctions peuvent aussi être utilisées comme des décorateurs ; il est "
"donc possible d'écrire ::"

#: library/ctypes.rst:1039
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as they "
"are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be "
"garbage collected, crashing your program when a callback is made."
msgstr ""
"Prenez garde à bien conserver une référence à un objet :func:`CFUNCTYPE` "
"tant que celui-ci est utilisé par le code C. :mod:`ctypes` ne le fait pas "
"tout seul et, si vous ne le faites pas, le ramasse-miette pourrait les "
"libérer, ce qui fera planter votre programme quand un appel sera fait."

#: library/ctypes.rst:1043
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values stored "
"with :class:`threading.local` will *not* survive across different callbacks, "
"even when those calls are made from the same C thread."
msgstr ""
"Notez aussi que si la fonction de rappel est appelée dans un fil d'exécution "
"créé hors de Python (p. ex. par du code externe qui appelle la fonction de "
"rappel), *ctypes* crée un nouveau fil Python « creux » à chaque fois. Ce "
"comportement est acceptable pour la plupart des cas d'utilisation, mais cela "
"implique que les valeurs stockées avec :class:`threading.local` ne seront "
"*pas* persistantes d'un appel à l'autre, même si les appels proviennent du "
"même fil d'exécution C."

#: library/ctypes.rst:1053
msgid "Accessing values exported from dlls"
msgstr "Accès aux variables exportées depuis une DLL"

#: library/ctypes.rst:1055
msgid ""
"Some shared libraries not only export functions, they also export variables. "
"An example in the Python library itself is the :c:data:`Py_OptimizeFlag`, an "
"integer set to 0, 1, or 2, depending on the :option:`-O` or :option:`-OO` "
"flag given on startup."
msgstr ""
"Certaines bibliothèques ne se contentent pas d'exporter des fonctions, elles "
"exportent aussi des variables. Par exemple, la bibliothèque Python exporte :"
"c:data:`Py_OptimizeFlag`, un entier valant 0, 1, ou 2 selon que l'option :"
"option:`-O` ou :option:`-OO` soit donnée au démarrage."

#: library/ctypes.rst:1060
msgid ""
":mod:`ctypes` can access values like this with the :meth:`in_dll` class "
"methods of the type.  *pythonapi* is a predefined symbol giving access to "
"the Python C api::"
msgstr ""
":mod:`ctypes` peut accéder à ce type de valeurs avec les méthodes de classe :"
"meth:`in_dll` du type considéré. *pythonapi* est un symbole prédéfini qui "
"donne accès à l'API C Python ::"

#: library/ctypes.rst:1069
msgid ""
"If the interpreter would have been started with :option:`-O`, the sample "
"would have printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would "
"have been specified."
msgstr ""
"Si l'interpréteur est lancé avec :option:`-O`, l'exemple affiche "
"``c_long(1)`` et ``c_long(2)`` avec :option:`-OO`."

#: library/ctypes.rst:1073
msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"Le pointeur :c:data:`PyImport_FrozenModules` exposé par Python est un autre "
"exemple complet de l'utilisation de pointeurs."

#: library/ctypes.rst:1076
msgid "Quoting the docs for that value:"
msgstr "Citons la documentation :"

#: library/ctypes.rst:1078
msgid ""
"This pointer is initialized to point to an array of :c:type:`struct _frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"Ce pointeur est initialisé de manière à pointer sur un tableau d'entrées de :"
"c:type:`struct _frozen`, dont tous les membres de la dernière valent "
"``NULL`` ou zéro. Quand un module figé est importé, il est cherché dans ce "
"tableau. Du code tiers peut jouer avec pour construire dynamiquement une "
"collection de module figés."

#: library/ctypes.rst:1083
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""
"Donc manipuler ce pointeur peut même se révéler utile. Pour limiter la "
"taille de l'exemple, nous nous bornons à montrer comment lire ce tableau "
"avec :mod:`ctypes` ::"

#: library/ctypes.rst:1095
msgid ""
"We have defined the :c:type:`struct _frozen` data type, so we can get the "
"pointer to the table::"
msgstr ""
"Le type de donnée :c:type:`struct _frozen` ayant été défini, nous pouvons "
"récupérer le pointeur vers le tableau ::"

#: library/ctypes.rst:1102
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably "
"crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the ``NULL`` entry::"
msgstr ""
"Puisque ``table`` est un ``pointer`` vers un tableau d'entrées de "
"``struct_frozen``, il est possible d'itérer dessus, mais il faut être "
"certain que la boucle se termine, car les pointeurs n'ont pas de taille. Tôt "
"ou tard, il planterait probablement avec une erreur de segmentation ou "
"autre, donc mieux vaut sortir de la boucle quand on lit l'entrée ``NULL`` ::"

#: library/ctypes.rst:1120
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative ``size`` member) is not well known, it is only "
"used for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"Le fait que le standard Python possède un module et un paquet figés "
"(indiqués par la valeur négative du membre *size*) est peu connu, cela ne "
"sert qu'aux tests. Essayez avec ``import __hello__`` par exemple."

#: library/ctypes.rst:1128
msgid "Surprises"
msgstr "Pièges"

#: library/ctypes.rst:1130
msgid ""
"There are some edges in :mod:`ctypes` where you might expect something other "
"than what actually happens."
msgstr ""
"Il y a quelques cas tordus dans :mod:`ctypes` où on peut s'attendre à un "
"résultat différent de la réalité."

#: library/ctypes.rst:1133
msgid "Consider the following example::"
msgstr "Examinons l'exemple suivant ::"

#: library/ctypes.rst:1153
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""
"Diantre. On s'attendait certainement à ce que le dernier résultat affiche "
"``3 4 1 2``. Que s'est-il passé ? Les étapes de la ligne ``rc.a, rc.b = rc."
"b, rc.a`` ci-dessus sont les suivantes ::"

#: library/ctypes.rst:1161
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't "
"have the expected effect."
msgstr ""
"Les objets ``temp0`` et ``temp1`` utilisent encore le tampon interne de "
"l'objet ``rc`` ci-dessus. Donc exécuter ``rc.a = temp0`` copie le contenu du "
"tampon de ``temp0`` dans celui de ``rc``. Ce qui, par ricochet, modifie le "
"contenu de ``temp1``. Et donc, la dernière affectation, ``rc.b = temp1``, "
"n'a pas l'effet escompté."

#: library/ctypes.rst:1167
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""
"Gardez en tête qu'accéder au sous-objet depuis une *Structure*, une *Union* "
"ou un *Array* ne copie *pas* le sous-objet, mais crée un objet interface qui "
"accède au tampon sous-jacent de l'objet initial."

#: library/ctypes.rst:1171
msgid ""
"Another example that may behave differently from what one would expect is "
"this::"
msgstr ""
"Un autre exemple de comportement *a priori* inattendu est le suivant ::"

#: library/ctypes.rst:1183
msgid ""
"Objects instantiated from :class:`c_char_p` can only have their value set to "
"bytes or integers."
msgstr ""
"La valeur d'une instance de :class:`c_char_p` ne peut être initialisée "
"qu'avec un octet ou un entier."

#: library/ctypes.rst:1186
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""
"Pourquoi cela affiche-t'il ``False`` ? Les instances *ctypes* sont des "
"objets qui contiennent un bloc mémoire et des :term:`descriptor` qui donnent "
"accès au contenu du ce bloc. Stocker un objet Python dans le bloc mémoire ne "
"stocke pas l'objet même ; seuls ses ``contents`` le sont. Accéder au "
"``contents`` crée un nouvel objet Python à chaque fois !"

#: library/ctypes.rst:1196
msgid "Variable-sized data types"
msgstr "Types de données à taille flottante"

#: library/ctypes.rst:1198
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and structures."
msgstr ""
":mod:`ctypes` assure la prise en charge des tableaux et des structures à "
"taille flottante."

#: library/ctypes.rst:1200
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""
"La fonction :func:`resize` permet de redimensionner la taille du tampon "
"mémoire d'un objet *ctypes* existant. Cette fonction prend l'objet comme "
"premier argument et la taille en octets désirée comme second. La taille du "
"tampon mémoire ne peut pas être inférieure à celle occupée par un objet "
"unitaire du type considéré. Une :exc:`ValueError` est levée si c'est le "
"cas ::"

#: library/ctypes.rst:1220
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""
"Cela dit, comment accéder aux éléments supplémentaires contenus dans le "
"tableau ? Vu que le type ne connaît que 4 éléments, on obtient une erreur si "
"l'on accède aux suivants ::"

#: library/ctypes.rst:1232
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
"Une autre approche pour utiliser des types de donnée à taille flottante "
"avec :mod:`ctypes` consiste à tirer profit de la nature intrinsèquement "
"dynamique de Python et de (re)définir le type de donnée une fois que la "
"taille demandée est connue, au cas-par-cas."

#: library/ctypes.rst:1240
msgid "ctypes reference"
msgstr "Référence du module"

#: library/ctypes.rst:1246
msgid "Finding shared libraries"
msgstr "Recherche de bibliothèques partagées"

#: library/ctypes.rst:1248
msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr ""
"Les langages compilés ont besoin d'accéder aux bibliothèques partagées au "
"moment de la compilation, de l'édition de liens et pendant l'exécution du "
"programme."

#: library/ctypes.rst:1251
msgid ""
"The purpose of the :func:`find_library` function is to locate a library in a "
"way similar to what the compiler or runtime loader does (on platforms with "
"several versions of a shared library the most recent should be loaded), "
"while the ctypes library loaders act like when a program is run, and call "
"the runtime loader directly."
msgstr ""
"Le but de la fonction :func:`find_library` est de trouver une bibliothèque "
"de la même façon que le ferait le compilateur ou le chargeur (sur les plates-"
"formes avec plusieurs versions de la même bibliothèque, la plus récente est "
"chargée), alors que les chargeurs de bibliothèques de *ctypes* se comportent "
"de la même façon qu'un programme qui s'exécute, et appellent directement le "
"chargeur."

#: library/ctypes.rst:1257
msgid ""
"The :mod:`ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ""
"Le module :mod:`ctypes.util` fournit une fonction pour déterminer quelle "
"bibliothèque charger."

#: library/ctypes.rst:1265
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Tente de trouver une bibliothèque et en renvoie le chemin. *name* est le nom "
"de la bibliothèque sans préfixe — comme *lib* — ni suffixe — comme ``.so``, "
"``.dylib`` ou un numéro de version (c.-à-d. la même forme que l'option POSIX "
"de l'éditeur de lien :option:`!-l`). Si la fonction ne parvient pas à "
"trouver de bibliothèque, elle renvoie ``None``."

#: library/ctypes.rst:1918
msgid "The exact functionality is system dependent."
msgstr "Le mode opératoire exact dépend du système."

#: library/ctypes.rst:1272
msgid ""
"On Linux, :func:`find_library` tries to run external programs (``/sbin/"
"ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library file. It "
"returns the filename of the library file."
msgstr ""
"Sous Linux, :func:`find_library` essaye de lancer des programmes externes "
"(``/sbin/ldconfig``, ``gcc``, ``objdump`` et ``ld``) pour trouver la "
"bibliothèque. Elle renvoie le nom de la bibliothèque sur le disque."

#: library/ctypes.rst:1276
msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is used "
"when searching for libraries, if a library cannot be found by any other "
"means."
msgstr ""
"Sous Linux, si les autres moyens échouent, la fonction utilise la variable "
"d'environnement ``LD_LIBRARY_PATH`` pour trouver la bibliothèque."

#: library/ctypes.rst:1280
msgid "Here are some examples::"
msgstr "Voici quelques exemples :"

#: library/ctypes.rst:1291
msgid ""
"On macOS, :func:`find_library` tries several predefined naming schemes and "
"paths to locate the library, and returns a full pathname if successful::"
msgstr ""
"Sous macOS, :func:`find_library` regarde dans des chemins et conventions de "
"chemins prédéfinies pour trouver la bibliothèque et en renvoie le chemin "
"complet si elle la trouve :"

#: library/ctypes.rst:1305
msgid ""
"On Windows, :func:`find_library` searches along the system search path, and "
"returns the full pathname, but since there is no predefined naming scheme a "
"call like ``find_library(\"c\")`` will fail and return ``None``."
msgstr ""
"Sous Windows, :func:`find_library` examine le chemin de recherche du système "
"et renvoie le chemin complet de la bibliothèque, mais comme il n'existe pas "
"de convention de nommage, des appels comme ``find_library(\"c\")`` échouent "
"et renvoient ``None``."

#: library/ctypes.rst:1309
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`find_library` to locate the "
"library at runtime."
msgstr ""
"Si vous encapsulez une bibliothèque partagée avec :mod:`ctypes`, il est "
"*probablement* plus judicieux de déterminer le chemin de cette bibliothèque "
"lors du développement et de l'écrire en dur dans le module d'encapsulation, "
"plutôt que d'utiliser :func:`find_library` pour la trouver lors de "
"l'exécution."

#: library/ctypes.rst:1317
msgid "Loading shared libraries"
msgstr "Chargement des bibliothèques partagées"

#: library/ctypes.rst:1319
msgid ""
"There are several ways to load shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr ""
"Il y a plusieurs moyens de charger une bibliothèque partagée dans un "
"processus Python. L'un d'entre eux consiste à instancier une des classes "
"suivantes :"

#: library/ctypes.rst:1325
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :c:type:`int`."
msgstr ""
"Une instance de cette classe représente une bibliothèque partagée déjà "
"chargée. Les fonctions de cette bibliothèque utilisent la convention d'appel "
"C standard et doivent renvoyer un :c:type:`int`."

#: library/ctypes.rst:1329
msgid ""
"On Windows creating a :class:`CDLL` instance may fail even if the DLL name "
"exists. When a dependent DLL of the loaded DLL is not found, a :exc:"
"`OSError` error is raised with the message *\"[WinError 126] The specified "
"module could not be found\".* This error message does not contain the name "
"of the missing DLL because the Windows API does not return this information "
"making this error hard to diagnose. To resolve this error and determine "
"which DLL is not found, you need to find the list of dependent DLLs and "
"determine which one is not found using Windows debugging and tracing tools."
msgstr ""
"En Windows, créer une instance de :class:`CDLL` peut échouer, même si une "
"DLL du bon nom existe. Quand une des dépendances de la DLL à charger ne peut "
"pas être trouvée, une :exc:`OSError` est levée avec le message *\"[WinError "
"126] The specified module could not be found\".* Ce message d'erreur ne "
"contient pas le nom de la DLL manquante car l'API Windows ne fournit pas "
"cette information. Cela rend l'erreur délicate à analyser ; pour la "
"résoudre, il faut lister toutes les dépendances de la DLL et trouver celle "
"qui manque en utilisant des outils de débogage et de traçage Windows."

#: library/ctypes.rst:1341
msgid ""
"`Microsoft DUMPBIN tool <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- A tool to find DLL dependents."
msgstr ""
"`DUMPBIN <https://docs.microsoft.com/cpp/build/reference/dependents>`_ — un "
"utilitaire Microsoft pour lister les dépendances d'une DLL."

#: library/ctypes.rst:1347
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return the windows specific :class:`HRESULT` code.  :class:"
"`HRESULT` values contain information specifying whether the function call "
"failed or succeeded, together with additional error code.  If the return "
"value signals a failure, an :class:`OSError` is automatically raised."
msgstr ""
"En Windows seulement : une instance de cette classe représente une "
"bibliothèque partagée déjà chargée. Les fonctions de cette bibliothèque "
"utilisent la convention d'appel *stdcall*, et doivent renvoyer un code :"
"class:`HRESULT` (propre à Windows). Les valeurs de :class:`HRESULT` "
"contiennent des informations précisant si l'appel de la fonction a échoué ou "
"s'il a réussi, ainsi qu'un code d'erreur supplémentaire. Si la valeur de "
"retour signale un échec, une :class:`OSError` est levée automatiquement."

#: library/ctypes.rst:1354
msgid ":exc:`WindowsError` used to be raised."
msgstr ":exc:`WindowsError` était levée auparavant."

#: library/ctypes.rst:1360
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return :c:type:`int` by default."
msgstr ""
"En Windows seulement : une instance de cette classe représente une "
"bibliothèque partagée déjà chargée. Les fonctions de cette bibliothèque "
"utilisent la convention d'appel *stdcall* et doivent renvoyer par défaut un :"
"c:type:`int`."

#: library/ctypes.rst:1364
msgid ""
"On Windows CE only the standard calling convention is used, for convenience "
"the :class:`WinDLL` and :class:`OleDLL` use the standard calling convention "
"on this platform."
msgstr ""
"Sous Windows CE, seule la convention d'appel standard est utilisée. Pour des "
"raisons pratiques, :class:`WinDLL` et :class:`OleDLL` utilisent la "
"convention d'appel standard sur cette plate-forme."

#: library/ctypes.rst:1368
msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""
"Le :term:`verrou global de l'interpréteur <global interpreter lock>` Python "
"est relâché avant chaque appel d'une fonction exposée par ces bibliothèques "
"et ré-activé après."

#: library/ctypes.rst:1374
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the "
"Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""
"Cette classe est identique à :class:`CDLL`, à ceci près que le GIL n'est "
"*pas* relâché pendant l'appel de la fonction, et, qu'au terme de l'appel, le "
"drapeau d'erreur Python est vérifié. Si celui-ci est activé, une exception "
"Python est levée."

#: library/ctypes.rst:1379
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr ""
"Donc, cette classe ne sert qu'à appeler les fonctions de l'API C de Python."

#: library/ctypes.rst:1381
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms ``dlopen`` or "
"``LoadLibrary`` function is used to load the library into the process, and "
"to get a handle to it."
msgstr ""
"Toutes ces classes peuvent être instanciées en les appelant avec le chemin "
"de la bibliothèque partagée comme unique argument. Il est aussi possible de "
"passer un lien vers une bibliothèque déjà chargée en utilisant le paramètre "
"``handle``. Sinon, les fonctions ``dlopen`` ou ``LoadLibrary`` de la plate-"
"forme sous-jacente permettent de charger la bibliothèque dans le processus, "
"et d'en obtenir un lien."

#: library/ctypes.rst:1388
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is "
"ignored.  On posix systems, RTLD_NOW is always added, and is not "
"configurable."
msgstr ""
"Le mode de chargement de la bibliothèque est défini par le paramètre *mode*. "
"Pour plus de détails, référez-vous à l'entrée :manpage:`dlopen(3)` du "
"manuel. En Windows, *mode* est ignoré. Sur les systèmes POSIX, RTLD_NOW y "
"est toujours ajouté. Ceci n'est pas configurable."

#: library/ctypes.rst:1393
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism that "
"allows accessing the system :data:`errno` error number in a safe way. :mod:"
"`ctypes` maintains a thread-local copy of the systems :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then "
"the :data:`errno` value before the function call is swapped with the ctypes "
"private copy, the same happens immediately after the function call."
msgstr ""
"Le paramètre *use_errno*, lorsque défini à vrai, active un mécanisme de "
"*ctypes* qui permet d'accéder au numéro d'erreur :data:`errno` du système de "
"manière sécurisée. :mod:`ctypes` maintient une copie de :data:`errno` du "
"système dans chaque fil d'exécution. Si vous appelez des fonctions externes "
"créées avec ``use_errno=True``, la valeur de :data:`errno` avant l'appel de "
"la fonction est échangée avec la copie privée de *ctypes*. La même chose se "
"produit juste après l'appel de la fonction."

#: library/ctypes.rst:1400
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""
"La fonction :func:`ctypes.get_errno` renvoie la valeur de la copie privée de "
"*ctypes*. La fonction :func:`ctypes.set_errno` affecte une nouvelle valeur à "
"la copie privée et renvoie l'ancienne valeur."

#: library/ctypes.rst:1404
msgid ""
"The *use_last_error* parameter, when set to true, enables the same mechanism "
"for the Windows error code which is managed by the :func:`GetLastError` and :"
"func:`SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""
"Définir le paramètre *use_last_error* à vrai active le même mécanisme pour "
"le code d'erreur de Windows qui est géré par les fonctions :func:"
"`GetLastError` et :func:`SetLastError` de l'API Windows ; :func:`ctypes."
"get_last_error` et :func:`ctypes.set_last_error` servent à obtenir et "
"modifier la copie privée *ctypes* de ce code d'erreur."

#: library/ctypes.rst:1410
msgid ""
"The *winmode* parameter is used on Windows to specify how the library is "
"loaded (since *mode* is ignored). It takes any value that is valid for the "
"Win32 API ``LoadLibraryEx`` flags parameter. When omitted, the default is to "
"use the flags that result in the most secure DLL load to avoiding issues "
"such as DLL hijacking. Passing the full path to the DLL is the safest way to "
"ensure the correct library and dependencies are loaded."
msgstr ""
"Sous Windows, le paramètre *winmode* définit comment charger la bibliothèque "
"(puisque *mode* est ignoré). Il accepte toute valeur compatible avec le "
"drapeau ``LoadLibraryEx`` de l'API Win32. Lorsqu'il est omis, les drapeaux "
"par défaut sont ceux qui chargent la DLL de la manière la plus sécurisée "
"possible, afin d'éviter des problèmes comme le détournement de DLL. Passer "
"le chemin complet à la DLL reste le moyen le plus sûr de s'assurer que la "
"bonne bibliothèque et les bonnes dépendances sont chargées."

#: library/ctypes.rst:1417
msgid "Added *winmode* parameter."
msgstr "Ajout du paramètre *winmode*."

#: library/ctypes.rst:1424
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr ""
"Valeur possible pour le paramètre *mode*. Vaut zéro sur les plates-formes où "
"ce drapeau n'est pas disponible."

#: library/ctypes.rst:1431
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr ""
"Valeur possible pour le paramètre *mode*. Vaut *RTLD_GLOBAL* sur les plates-"
"formes où ce drapeau n'est pas disponible."

#: library/ctypes.rst:1438
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"Mode de chargement par défaut des bibliothèques partagées. Vaut "
"*RTLD_GLOBAL* sur OSX 10.3 et *RTLD_LOCAL* sur les autres systèmes "
"d'exploitation."

#: library/ctypes.rst:1441
msgid ""
"Instances of these classes have no public methods.  Functions exported by "
"the shared library can be accessed as attributes or by index.  Please note "
"that accessing the function through an attribute caches the result and "
"therefore accessing it repeatedly returns the same object each time.  On the "
"other hand, accessing it through an index returns a new object each time::"
msgstr ""
"Les instances de ces classes n'ont pas de méthodes publiques ; on accède aux "
"fonctions de la bibliothèque partagée par attribut ou par indiçage. Notez "
"que les résultats des accès par attribut sont mis en cache, et donc des "
"accès consécutifs renvoient à chaque fois le même objet. Accéder à une "
"fonction par indice renvoie cependant chaque fois un nouvel objet :"

#: library/ctypes.rst:1454
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr ""
"Les attributs publics suivants sont disponibles, leur nom commence par un "
"tiret bas pour éviter les conflits avec les noms des fonctions exportées :"

#: library/ctypes.rst:1460
msgid "The system handle used to access the library."
msgstr "Le lien système d'accès à la bibliothèque."

#: library/ctypes.rst:1465
msgid "The name of the library passed in the constructor."
msgstr "Nom de la bibliothèque donné au constructeur."

#: library/ctypes.rst:1467
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`LoadLibrary` method, or by retrieving the library as "
"attribute of the loader instance."
msgstr ""
"Il est possible de charger une bibliothèque partagée soit en utilisant une "
"instance de la classe :class:`LibraryLoader`, soit en appelant la méthode :"
"meth:`LoadLibrary`, soit en récupérant la bibliothèque comme attribut de "
"l'instance du chargeur."

#: library/ctypes.rst:1475
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"Classe pour charger une bibliothèque partagée. *dlltype* doit être de type :"
"class:`CDLL`, :class:`PyDLL`, :class:`WinDLL` ou :class:`OleDLL`."

#: library/ctypes.rst:1478
msgid ""
":meth:`__getattr__` has special behavior: It allows loading a shared library "
"by accessing it as attribute of a library loader instance.  The result is "
"cached, so repeated attribute accesses return the same library each time."
msgstr ""
":meth:`__getattr__` a un comportement particulier : elle charge une "
"bibliothèque quand on accède à un attribut du chargeur. Le résultat est mis "
"en cache, donc des accès consécutifs renvoient la même bibliothèque à chaque "
"fois."

#: library/ctypes.rst:1484
msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr ""
"Charge une bibliothèque partagée dans le processus et la renvoie. Cette "
"méthode renvoie toujours une nouvelle instance de la bibliothèque."

#: library/ctypes.rst:1488
msgid "These prefabricated library loaders are available:"
msgstr "Plusieurs chargeurs sont fournis :"

#: library/ctypes.rst:1493
msgid "Creates :class:`CDLL` instances."
msgstr "Pour créer des instances de :class:`CDLL`."

#: library/ctypes.rst:1499
msgid "Windows only: Creates :class:`WinDLL` instances."
msgstr "Pour créer des instances de :class:`WinDLL` (uniquement en Windows)."

#: library/ctypes.rst:1505
msgid "Windows only: Creates :class:`OleDLL` instances."
msgstr "Pour créer des instances de :class:`OleDLL` (uniquement en Windows)."

#: library/ctypes.rst:1511
msgid "Creates :class:`PyDLL` instances."
msgstr "Pour créer des instances de :class:`PyDLL`."

#: library/ctypes.rst:1514
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr "Il existe un moyen rapide d'accéder directement à l'API C Python :"

#: library/ctypes.rst:1520
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C :c:type:"
"`int`, which is of course not always the truth, so you have to assign the "
"correct :attr:`restype` attribute to use these functions."
msgstr ""
"Une instance de :class:`PyDLL` dont les attributs sont les fonctions "
"exportées par l'API C Python. Toutes ces fonctions sont supposées renvoyer "
"un :c:type:`int` C, ce qui n'est bien entendu pas toujours le cas. Il faut "
"donc définir vous-même le bon attribut :attr:`restype` pour pouvoir les "
"utiliser."

#: library/ctypes.rst:1525
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlopen`` with argument "
"``name``."
msgstr ""
"Lève un :ref:`évènement d'audit <auditing>` ``ctypes.dlopen``, avec en "
"argument ``name``."

#: library/ctypes.rst:1527
msgid ""
"Loading a library through any of these objects raises an :ref:`auditing "
"event <auditing>` ``ctypes.dlopen`` with string argument ``name``, the name "
"used to load the library."
msgstr ""
"Charger une bibliothèque à l'aide d'un de ces objets avec en argument "
"``name``, le nom de la bibliothèque (une chaîne de caractères), lève un :ref:"
"`évènement d'audit <auditing>` ``ctypes.dlopen``."

#: library/ctypes.rst:1531
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlsym`` with arguments "
"``library``, ``name``."
msgstr ""
"Charger une bibliothèque à l'aide d'un de ces objets avec en argument "
"``name``, le nom de la bibliothèque (une chaîne de caractères), lève un :ref:"
"`évènement d'audit <auditing>` ``ctypes.dlopen``."

#: library/ctypes.rst:1533
msgid ""
"Accessing a function on a loaded library raises an auditing event ``ctypes."
"dlsym`` with arguments ``library`` (the library object) and ``name`` (the "
"symbol's name as a string or integer)."
msgstr ""
"Accéder à une fonction d'une bibliothèque lève un évènement d'audit ``ctypes."
"dlsym`` avec ``library`` (l'objet bibliothèque) et ``name`` (le nom du "
"symbole — une chaîne de caractères ou un entier) comme arguments."

#: library/ctypes.rst:1537
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlsym/handle`` with "
"arguments ``handle``, ``name``."
msgstr ""
"Charger une bibliothèque à l'aide d'un de ces objets avec en argument "
"``name``, le nom de la bibliothèque (une chaîne de caractères), lève un :ref:"
"`évènement d'audit <auditing>` ``ctypes.dlopen``."

#: library/ctypes.rst:1539
msgid ""
"In cases when only the library handle is available rather than the object, "
"accessing a function raises an auditing event ``ctypes.dlsym/handle`` with "
"arguments ``handle`` (the raw library handle) and ``name``."
msgstr ""
"Si seul le lien sur la bibliothèque, et non l'objet, est disponible, accéder "
"à une fonction lève l'évènement d'audit ``ctypes.dlsym/handle`` avec "
"``handle`` (le lien vers la bibliothèque) et ``name`` comme arguments."

#: library/ctypes.rst:1546
msgid "Foreign functions"
msgstr "Fonctions externes"

#: library/ctypes.rst:1548
msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this "
"way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader. They are instances of a private class:"
msgstr ""
"Comme expliqué dans la section précédente, on peut accéder aux fonctions "
"externes au travers des attributs des bibliothèques partagées. Un objet "
"fonction créé de cette façon accepte par défaut un nombre quelconque "
"d'arguments qui peuvent être de n'importe quel type de données *ctypes*. Il "
"renvoie le type par défaut du chargeur de la bibliothèque. Ce sont des "
"instances de la classe privée :"

#: library/ctypes.rst:1557
msgid "Base class for C callable foreign functions."
msgstr "Classe de base pour les fonctions externes C."

#: library/ctypes.rst:1559
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr ""
"Une instance de fonction externe est également un type de donnée compatible "
"avec le C ; elle représente un pointeur vers une fonction."

#: library/ctypes.rst:1562
msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr ""
"Son comportement peut-être personnalisé en réaffectant les attributs "
"spécifiques de l'objet représentant la fonction externe."

#: library/ctypes.rst:1567
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use "
"``None`` for :c:type:`void`, a function not returning anything."
msgstr ""
"Fait correspondre le type de retour de la fonction externe à un type "
"*ctypes*. Dans le cas où la fonction ne renvoie rien (:c:type:`void`), "
"utilisez ``None``."

#: library/ctypes.rst:1570
msgid ""
"It is possible to assign a callable Python object that is not a ctypes type, "
"in this case the function is assumed to return a C :c:type:`int`, and the "
"callable will be called with this integer, allowing further processing or "
"error checking.  Using this is deprecated, for more flexible post processing "
"or error checking use a ctypes data type as :attr:`restype` and assign a "
"callable to the :attr:`errcheck` attribute."
msgstr ""
"Il est aussi possible de passer n'importe quel un objet Python qui n'est pas "
"un type *ctypes* pourvu qu'il soit appelable. Dans ce cas, la fonction est "
"censée renvoyer un :c:type:`int` C et l'appelable sera appelé avec cet "
"entier, ce qui permet ainsi de faire des actions supplémentaires comme "
"vérifier un code d'erreur. Ce mécanisme est obsolète ; une façon plus souple "
"de faire des actions supplémentaires ou de la vérification consiste à "
"affecter un type *ctypes* à :attr:`restype` et à affecter un appelable à "
"l'attribut :attr:`errcheck`."

#: library/ctypes.rst:1579
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"Fait correspondre le type des arguments que la fonction accepte avec un *n*-"
"uplet de types *ctypes*. Les fonctions qui utilisent la convention d'appel "
"``stdcall`` ne peuvent être appelées qu'avec le même nombre d'arguments que "
"la taille du *n*-uplet mais les fonctions qui utilisent la convention "
"d'appel C acceptent aussi des arguments additionnels non-définis."

#: library/ctypes.rst:1585
msgid ""
"When a foreign function is called, each actual argument is passed to the :"
"meth:`from_param` class method of the items in the :attr:`argtypes` tuple, "
"this method allows adapting the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the :"
"attr:`argtypes` tuple will convert a string passed as argument into a bytes "
"object using ctypes conversion rules."
msgstr ""
"À l'appel d'une fonction externe, chaque argument est passé à la méthode de "
"classe :meth:`from_param` de l'élément correspondant dans le *n*-uplet des :"
"attr:`argtypes`. Cette méthode convertit l'argument initial en un objet que "
"la fonction externe peut comprendre. Par exemple, un :class:`c_char_p` dans "
"le *n*-uplet des :attr:`argtypes` va transformer la chaîne de caractères "
"passée en argument en un objet chaîne d'octets selon les règles de "
"conversion *ctypes*."

#: library/ctypes.rst:1592
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types, "
"but each item must have a :meth:`from_param` method which returns a value "
"usable as argument (integer, string, ctypes instance).  This allows defining "
"adapters that can adapt custom objects as function parameters."
msgstr ""
"Nouveau : il est maintenant possible de mettre des objets qui ne sont pas "
"des types de *ctypes* dans les *argtypes*, mais ceux-ci doivent avoir une "
"méthode :meth:`from_param` renvoyant une valeur qui peut être utilisée comme "
"un argument (entier, chaîne de caractères ou instance *ctypes*). Ceci permet "
"de créer des adaptateurs qui convertissent des objets arbitraires en des "
"paramètres de fonction."

#: library/ctypes.rst:1599
msgid ""
"Assign a Python function or another callable to this attribute. The callable "
"will be called with three or more arguments:"
msgstr ""
"Définit une fonction Python ou tout autre appelable qui sera appelé avec "
"trois arguments ou plus :"

#: library/ctypes.rst:1606
msgid ""
"*result* is what the foreign function returns, as specified by the :attr:"
"`restype` attribute."
msgstr ""
"*result* est la valeur de retour de la fonction externe, comme défini par "
"l'attribut :attr:`restype`."

#: library/ctypes.rst:1609
msgid ""
"*func* is the foreign function object itself, this allows reusing the same "
"callable object to check or post process the results of several functions."
msgstr ""
"*func* est l'objet représentant la fonction externe elle-même. Cet accesseur "
"permet de réutiliser le même appelable pour vérifier le résultat de "
"plusieurs fonctions ou de faire des actions supplémentaires après leur "
"exécution."

#: library/ctypes.rst:1613
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows specializing the behavior on the arguments used."
msgstr ""
"*arguments* est le *n*-uplet qui contient les paramètres initiaux passés à "
"la fonction, ceci permet de spécialiser le comportement des arguments "
"utilisés."

#: library/ctypes.rst:1617
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception "
"if the foreign function call failed."
msgstr ""
"L'objet renvoyé par cette fonction est celui renvoyé par l'appel de la "
"fonction externe, mais il peut aussi vérifier la valeur du résultat et lever "
"une exception si l'appel a échoué."

#: library/ctypes.rst:1624
msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr ""
"Exception levée quand un appel à la fonction externe ne peut pas convertir "
"un des arguments qu'elle a reçus."

#: library/ctypes.rst:1628
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.seh_exception`` with "
"argument ``code``."
msgstr ""

#: library/ctypes.rst:1630
msgid ""
"On Windows, when a foreign function call raises a system exception (for "
"example, due to an access violation), it will be captured and replaced with "
"a suitable Python exception. Further, an auditing event ``ctypes."
"seh_exception`` with argument ``code`` will be raised, allowing an audit "
"hook to replace the exception with its own."
msgstr ""
"En Windows, quand un appel à une fonction externe lève une exception système "
"(par exemple, une erreur de segmentation), celle-ci est interceptée pour "
"être remplacée par l'exception Python correspondante. De plus, un évènement "
"d'audit ``ctypes.seh_exception`` est levé avec ``code`` en argument, ce qui "
"permet à un point d'entrée (*hook* en anglais) d'audit de remplacer "
"l'exception par une des siennes."

#: library/ctypes.rst:1636
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.call_function`` with "
"arguments ``func_pointer``, ``arguments``."
msgstr ""
"Certaines manières d'appeler des fonction externes peuvent lever des "
"évènements d'audit ``ctypes.call_function`` avec ``function pointer`` et "
"``arguments`` comme arguments."

#: library/ctypes.rst:1638
msgid ""
"Some ways to invoke foreign function calls may raise an auditing event "
"``ctypes.call_function`` with arguments ``function pointer`` and "
"``arguments``."
msgstr ""
"Certaines manières d'appeler des fonction externes peuvent lever des "
"évènements d'audit ``ctypes.call_function`` avec ``function pointer`` et "
"``arguments`` comme arguments."

#: library/ctypes.rst:1644
msgid "Function prototypes"
msgstr "Prototypes de fonction"

#: library/ctypes.rst:1646
msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a "
"function (return type, argument types, calling convention) without defining "
"an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function, and can be used as "
"decorator factories, and as such, be applied to functions through the "
"``@wrapper`` syntax. See :ref:`ctypes-callback-functions` for examples."
msgstr ""
"Il est aussi possible de créer des fonctions externes en instanciant des "
"prototypes de fonction. Les prototypes de fonction ressemblent beaucoup aux "
"prototypes de fonctions en C ; ils décrivent une fonction (type de retour, "
"type des arguments, convention d'appel) sans préciser son implémentation. "
"Les fabriques de fonctions prennent en entrée le type de retour et le type "
"des arguments de la fonction, et peuvent être utilisées comme des "
"décorateurs-fabrique et ainsi s'appliquer à des fonctions avec la syntaxe "
"``@décorateur``. Ceci est illustré dans la section :ref:`ctypes-callback-"
"functions`."

#: library/ctypes.rst:1657
msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to true, the ctypes private copy of the system :data:"
"`errno` variable is exchanged with the real :data:`errno` value before and "
"after the call; *use_last_error* does the same for the Windows error code."
msgstr ""
"Renvoie un prototype de fonction qui crée des fonctions qui suivent la "
"convention d'appel standard C. Les fonctions libèreront le GIL lors de leur "
"exécution. Si *use_errno* est vrai, la copie privée *ctypes* de la variable "
"système :data:`errno` est échangée avec la vraie valeur de :data:`errno` "
"avant et après l'appel ; *use_last_error* a le même effet sous Windows."

#: library/ctypes.rst:1667
msgid ""
"Windows only: The returned function prototype creates functions that use the "
"``stdcall`` calling convention, except on Windows CE where :func:"
"`WINFUNCTYPE` is the same as :func:`CFUNCTYPE`.  The function will release "
"the GIL during the call.  *use_errno* and *use_last_error* have the same "
"meaning as above."
msgstr ""
"En Windows seulement : renvoie un prototype de fonction qui crée des "
"fonctions qui suivent la convention d'appel standard ``stdcall``, sauf sous "
"Windows CE où :func:`WINFUNCTYPE` équivaut à :func:`CFUNCTYPE`. Les "
"fonctions libèreront le GIL lors de leur exécution. *use_errno* et "
"*use_last_error* ont la même signification que ci-dessus."

#: library/ctypes.rst:1676
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the call."
msgstr ""
"Renvoie un prototype de fonction qui crée des fonctions qui suivent la "
"convention d'appel Python. Les fonctions ne libèreront *pas* le GIL lors de "
"leur exécution."

#: library/ctypes.rst:1679
msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the "
"call:"
msgstr ""
"Il y a plusieurs façons d'instancier les prototypes de fonction créés par "
"ces fabriques, selon le type et le nombre de paramètres de l'appel :"

#: library/ctypes.rst:1687
msgid ""
"Returns a foreign function at the specified address which must be an integer."
msgstr ""
"Renvoie une fonction externe sur l'adresse donnée sous la forme d'un entier."

#: library/ctypes.rst:1694
msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr ""
"Crée une fonction appelable depuis du code C (une fonction de rappel) d'un "
"appelable Python donné en paramètre."

#: library/ctypes.rst:1701
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be "
"a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the "
"exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""
"Renvoie une fonction externe exposée par une bibliothèque partagée. "
"*func_spec* est un couple ``(nom_ou_indice, bibliothèque)``. Le premier "
"élément est le nom de la fonction à passer comme une chaîne ou bien son "
"indice (dans la table des symboles) à passer comme un entier. Le second "
"élément est l'instance de la bibliothèque partagée."

#: library/ctypes.rst:1711
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""
"Renvoie une fonction qui appelle une méthode COM. *vtbl_index* est l'indice "
"de la fonction dans la table virtuelle, un petit entier positif. *name* est "
"le nom de la méthode COM. *iid* est un pointeur optionnel vers "
"l'identificateur de plateforme, qui est utilisé dans la remontée d'erreurs "
"étendue."

#: library/ctypes.rst:1716
msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`argtypes` tuple."
msgstr ""
"Les méthodes COM ont une convention d'appel particulière : elles requièrent "
"de passer un pointeur vers l'interface COM en premier argument, en sus des "
"arguments passés dans le *n*-uplet :attr:`argtypes`."

#: library/ctypes.rst:1720
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr ""
"Le paramètre optionnel *paramflags* crée une fabrique de fonction externes "
"avec des fonctionnalités supplémentaires par rapport à celles décrites ci-"
"dessus."

#: library/ctypes.rst:1723
msgid "*paramflags* must be a tuple of the same length as :attr:`argtypes`."
msgstr "*paramflags* est un *n*-uplet de la même taille que :attr:`argtypes`."

#: library/ctypes.rst:1725
msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr ""
"Chaque élément de ce *n*-uplet contient des informations supplémentaires sur "
"le paramètre correspondant. Ce doit être aussi un *n*-uplet, avec un, deux "
"ou trois éléments."

#: library/ctypes.rst:1728
msgid ""
"The first item is an integer containing a combination of direction flags for "
"the parameter:"
msgstr ""
"Le premier élément est un entier qui contient une combinaison de drapeaux "
"qui précisent le sens des paramètres (entrée ou sortie) :"

#: library/ctypes.rst:1732
msgid "1"
msgstr "1"

#: library/ctypes.rst:1732
msgid "Specifies an input parameter to the function."
msgstr "Paramètre d'entrée."

#: library/ctypes.rst:1735
msgid "2"
msgstr "2"

#: library/ctypes.rst:1735
msgid "Output parameter.  The foreign function fills in a value."
msgstr "Paramètre de sortie. La fonction externe va modifier cette valeur."

#: library/ctypes.rst:1738
msgid "4"
msgstr "4"

#: library/ctypes.rst:1738
msgid "Input parameter which defaults to the integer zero."
msgstr "Paramètre d'entrée, valant 0 par défaut."

#: library/ctypes.rst:1740
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""
"Le deuxième élément (optionnel) est une chaîne de caractères représentant le "
"nom du paramètre. Si cet élément est donné, la fonction externe pourra être "
"appelée avec des paramètres nommés."

#: library/ctypes.rst:1743
msgid "The optional third item is the default value for this parameter."
msgstr ""
"Le troisième élément (optionnel) est la valeur par défaut du paramètre."

#: library/ctypes.rst:1745
msgid ""
"This example demonstrates how to wrap the Windows ``MessageBoxW`` function "
"so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""
"L'exemple suivant montre comment encapsuler la fonction Windows "
"``MessageBoxW`` afin que celle-ci prenne en charge des paramètres par défaut "
"et des arguments nommés. Sa déclaration C dans le fichier d'en-tête des "
"fenêtres est ::"

#: library/ctypes.rst:1779
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "L'encapsulation :mod:`ctypes` correspondante est alors ::"

#: library/ctypes.rst:1764
msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr ""
"La fonction ``MessageBox`` peut désormais être appelée des manières "
"suivantes ::"

#: library/ctypes.rst:1770
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by "
"copying them into ``RECT`` structure that the caller has to supply.  Here is "
"the C declaration::"
msgstr ""
"L'exemple qui suit traite des paramètres en sortie. La fonction win32 "
"``GetWindowRect`` donne les dimensions d'une fenêtre en les copiant dans une "
"structure ``RECT`` que l'appelant doit fournir. Sa déclaration en C est ::"

#: library/ctypes.rst:1788
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function "
"now returns a RECT instance, when called."
msgstr ""
"Les fonctions avec des paramètres en sortie renvoient automatiquement la "
"valeur du paramètre de sortie s'il n'y en a qu'un seul, ou un *n*-uplet avec "
"les valeurs de sortie de chaque paramètre s'il y en a plusieurs. Ici, la "
"fonction *GetWindowRect* renvoie donc une instance de *RECT* quand elle est "
"appelée."

#: library/ctypes.rst:1793
msgid ""
"Output parameters can be combined with the :attr:`errcheck` protocol to do "
"further output processing and error checking.  The win32 ``GetWindowRect`` "
"api function returns a ``BOOL`` to signal success or failure, so this "
"function could do the error checking, and raises an exception when the api "
"call failed::"
msgstr ""
"Il est possible de combiner des paramètres en sortie avec le protocole :attr:"
"`errcheck` pour post-traiter les sorties et faire de la vérification "
"d'erreur. La fonction de l'API win32 ``GetWindowRect`` renvoie un ``BOOL`` "
"pour indiquer le succès ou l'échec de l'exécution, donc cette fonction peut "
"vérifier le résultat et lever une exception quand l'appel à l'API a échoué ::"

#: library/ctypes.rst:1806
msgid ""
"If the :attr:`errcheck` function returns the argument tuple it receives "
"unchanged, :mod:`ctypes` continues the normal processing it does on the "
"output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""
"Si la fonction :attr:`errcheck` renvoie le *n*-uplet passé en paramètre sans "
"rien y changer, :mod:`ctypes` continue l'exécution habituelle des paramètres "
"en sortie. Si on préfère renvoyer un *n*-uplet de coordonnées au lieu de "
"renvoyer une instance de ``RECT``, il faut récupérer les champs "
"correspondants et les renvoyer en retour. Dans ce cas, l'exécution "
"habituelle n'a plus lieu ::"

#: library/ctypes.rst:1825
msgid "Utility functions"
msgstr "Fonctions utilitaires"

#: library/ctypes.rst:1829
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr ""

#: library/ctypes.rst:1832
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.addressof`` with "
"argument ``obj``."
msgstr ""

#: library/ctypes.rst:1837
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a "
"ctypes type or instance."
msgstr ""

#: library/ctypes.rst:1843
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be "
"added to the internal pointer value."
msgstr ""

#: library/ctypes.rst:1847
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr ""

#: library/ctypes.rst:1851
msgid ""
"The returned object can only be used as a foreign function call parameter. "
"It behaves similar to ``pointer(obj)``, but the construction is a lot faster."
msgstr ""

#: library/ctypes.rst:1857
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""

#: library/ctypes.rst:1865
msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr ""

#: library/ctypes.rst:1868
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a bytes object which will be used to initialize the array items."
msgstr ""

#: library/ctypes.rst:1871
msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a NUL "
"termination character. An integer can be passed as second argument which "
"allows specifying the size of the array if the length of the bytes should "
"not be used."
msgstr ""

#: library/ctypes.rst:1876
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""

#: library/ctypes.rst:1881
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""

#: library/ctypes.rst:1884
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a string which will be used to initialize the array items."
msgstr ""

#: library/ctypes.rst:1887
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the array "
"is a NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the string "
"should not be used."
msgstr ""

#: library/ctypes.rst:1893
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""

#: library/ctypes.rst:1898
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllCanUnloadNow function "
"that the _ctypes extension dll exports."
msgstr ""

#: library/ctypes.rst:1905
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllGetClassObject function "
"that the ``_ctypes`` extension dll exports."
msgstr ""

#: library/ctypes.rst:1913
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""

#: library/ctypes.rst:1924
msgid ""
"Windows only: return the filename of the VC runtime library used by Python, "
"and by the extension modules.  If the name of the library cannot be "
"determined, ``None`` is returned."
msgstr ""

#: library/ctypes.rst:1928
msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""

#: library/ctypes.rst:1935
msgid ""
"Windows only: Returns a textual description of the error code *code*.  If no "
"error code is specified, the last error code is used by calling the Windows "
"api function GetLastError."
msgstr ""

#: library/ctypes.rst:1942
msgid ""
"Windows only: Returns the last error code set by Windows in the calling "
"thread. This function calls the Windows `GetLastError()` function directly, "
"it does not return the ctypes-private copy of the error code."
msgstr ""

#: library/ctypes.rst:1948
msgid ""
"Returns the current value of the ctypes-private copy of the system :data:"
"`errno` variable in the calling thread."
msgstr ""

#: library/ctypes.rst:1951
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_errno`` with no "
"arguments."
msgstr ""

#: library/ctypes.rst:1955
msgid ""
"Windows only: returns the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread."
msgstr ""

#: library/ctypes.rst:1958
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_last_error`` with no "
"arguments."
msgstr ""

#: library/ctypes.rst:1962
msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""

#: library/ctypes.rst:1969
msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""

#: library/ctypes.rst:1976
msgid ""
"This factory function creates and returns a new ctypes pointer type. Pointer "
"types are cached and reused internally, so calling this function repeatedly "
"is cheap. *type* must be a ctypes type."
msgstr ""

#: library/ctypes.rst:1983
msgid ""
"This function creates a new pointer instance, pointing to *obj*. The "
"returned object is of the type ``POINTER(type(obj))``."
msgstr ""

#: library/ctypes.rst:1986
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr ""

#: library/ctypes.rst:1992
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``, "
"but it is possible to enlarge the buffer."
msgstr ""

#: library/ctypes.rst:2000
msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno` "
"variable in the calling thread to *value* and return the previous value."
msgstr ""

#: library/ctypes.rst:2003
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_errno`` with "
"argument ``errno``."
msgstr ""

#: library/ctypes.rst:2008
msgid ""
"Windows only: set the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread to *value* and "
"return the previous value."
msgstr ""

#: library/ctypes.rst:2012
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_last_error`` with "
"argument ``error``."
msgstr ""

#: library/ctypes.rst:2017
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof`` operator."
msgstr ""

#: library/ctypes.rst:2023
msgid ""
"This function returns the C string starting at memory address *address* as a "
"bytes object. If size is specified, it is used as size, otherwise the string "
"is assumed to be zero-terminated."
msgstr ""

#: library/ctypes.rst:2027
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.string_at`` with "
"arguments ``address``, ``size``."
msgstr ""

#: library/ctypes.rst:2032
msgid ""
"Windows only: this function is probably the worst-named thing in ctypes. It "
"creates an instance of OSError.  If *code* is not specified, "
"``GetLastError`` is called to determine the error code. If *descr* is not "
"specified, :func:`FormatError` is called to get a textual description of the "
"error."
msgstr ""

#: library/ctypes.rst:2038
msgid "An instance of :exc:`WindowsError` used to be created."
msgstr ""

#: library/ctypes.rst:2044
msgid ""
"This function returns the wide character string starting at memory address "
"*address* as a string.  If *size* is specified, it is used as the number of "
"characters of the string, otherwise the string is assumed to be zero-"
"terminated."
msgstr ""

#: library/ctypes.rst:2049
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.wstring_at`` with "
"arguments ``address``, ``size``."
msgstr ""

#: library/ctypes.rst:2055
msgid "Data types"
msgstr "Types de données"

#: library/ctypes.rst:2060
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the :"
"func:`addressof` helper function. Another instance variable is exposed as :"
"attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""

#: library/ctypes.rst:2067
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""

#: library/ctypes.rst:2072
msgid ""
"This method returns a ctypes instance that shares the buffer of the *source* "
"object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a :"
"exc:`ValueError` is raised."
msgstr ""

#: library/ctypes.rst:2088
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` with "
"arguments ``pointer``, ``size``, ``offset``."
msgstr ""

#: library/ctypes.rst:2082
msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""

#: library/ctypes.rst:2092
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""

#: library/ctypes.rst:2095
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata`` with argument "
"``address``."
msgstr ""

#: library/ctypes.rst:2097
msgid ""
"This method, and others that indirectly call this method, raises an :ref:"
"`auditing event <auditing>` ``ctypes.cdata`` with argument ``address``."
msgstr ""

#: library/ctypes.rst:2103
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`argtypes` tuple; it must return an object that can "
"be used as a function call parameter."
msgstr ""

#: library/ctypes.rst:2108
msgid ""
"All ctypes data types have a default implementation of this classmethod that "
"normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""

#: library/ctypes.rst:2114
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""

#: library/ctypes.rst:2118
msgid "Common instance variables of ctypes data types:"
msgstr ""

#: library/ctypes.rst:2122
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The :attr:"
"`_b_base_` read-only member is the root ctypes object that owns the memory "
"block."
msgstr ""

#: library/ctypes.rst:2129
msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr ""

#: library/ctypes.rst:2134
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid.  "
"This object is only exposed for debugging; never modify the contents of this "
"dictionary."
msgstr ""

#: library/ctypes.rst:2147
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the "
"fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of :"
"class:`_CData`, so it inherits their methods and attributes. ctypes data "
"types that are not and do not contain pointers can now be pickled."
msgstr ""

#: library/ctypes.rst:2153
msgid "Instances have a single attribute:"
msgstr ""

#: library/ctypes.rst:2157
msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a Python "
"bytes object or string."
msgstr ""

#: library/ctypes.rst:2162
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""

#: library/ctypes.rst:2168
msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`restype` of :class:`c_char_p`, you will always "
"receive a Python bytes object, *not* a :class:`c_char_p` instance."
msgstr ""

#: library/ctypes.rst:2176
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course, "
"you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""

#: library/ctypes.rst:2181
msgid "These are the fundamental ctypes data types:"
msgstr ""

#: library/ctypes.rst:2185
msgid ""
"Represents the C :c:type:`signed char` datatype, and interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""

#: library/ctypes.rst:2192
msgid ""
"Represents the C :c:type:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""

#: library/ctypes.rst:2199
msgid ""
"Represents the C :c:type:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a bytes object."
msgstr ""

#: library/ctypes.rst:2207
msgid ""
"Represents the C :c:type:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""

#: library/ctypes.rst:2213
msgid ""
"Represents the C :c:type:`long double` datatype.  The constructor accepts an "
"optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""

#: library/ctypes.rst:2219
msgid ""
"Represents the C :c:type:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""

#: library/ctypes.rst:2225
msgid ""
"Represents the C :c:type:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""

#: library/ctypes.rst:2232
msgid ""
"Represents the C 8-bit :c:type:`signed int` datatype.  Usually an alias for :"
"class:`c_byte`."
msgstr ""

#: library/ctypes.rst:2238
msgid ""
"Represents the C 16-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr ""

#: library/ctypes.rst:2244
msgid ""
"Represents the C 32-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr ""

#: library/ctypes.rst:2250
msgid ""
"Represents the C 64-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr ""

#: library/ctypes.rst:2256
msgid ""
"Represents the C :c:type:`signed long` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""

#: library/ctypes.rst:2262
msgid ""
"Represents the C :c:type:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""

#: library/ctypes.rst:2268
msgid ""
"Represents the C :c:type:`signed short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""

#: library/ctypes.rst:2274
msgid "Represents the C :c:type:`size_t` datatype."
msgstr ""

#: library/ctypes.rst:2279
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr ""

#: library/ctypes.rst:2286
msgid ""
"Represents the C :c:type:`unsigned char` datatype, it interprets the value "
"as small integer.  The constructor accepts an optional integer initializer; "
"no overflow checking is done."
msgstr ""

#: library/ctypes.rst:2293
msgid ""
"Represents the C :c:type:`unsigned int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""

#: library/ctypes.rst:2300
msgid ""
"Represents the C 8-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ubyte`."
msgstr ""

#: library/ctypes.rst:2306
msgid ""
"Represents the C 16-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""

#: library/ctypes.rst:2312
msgid ""
"Represents the C 32-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""

#: library/ctypes.rst:2318
msgid ""
"Represents the C 64-bit :c:type:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""

#: library/ctypes.rst:2324
msgid ""
"Represents the C :c:type:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""

#: library/ctypes.rst:2330
msgid ""
"Represents the C :c:type:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""

#: library/ctypes.rst:2336
msgid ""
"Represents the C :c:type:`unsigned short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""

#: library/ctypes.rst:2342
msgid ""
"Represents the C :c:type:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr ""

#: library/ctypes.rst:2348
msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""

#: library/ctypes.rst:2355
msgid ""
"Represents the C :c:type:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""

#: library/ctypes.rst:2362
msgid ""
"Represent the C :c:type:`bool` datatype (more accurately, :c:type:`_Bool` "
"from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""

#: library/ctypes.rst:2369
msgid ""
"Windows only: Represents a :c:type:`HRESULT` value, which contains success "
"or error information for a function or method call."
msgstr ""

#: library/ctypes.rst:2375
msgid ""
"Represents the C :c:type:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:type:`PyObject *` pointer."
msgstr ""

#: library/ctypes.rst:2378
msgid ""
"The :mod:`ctypes.wintypes` module provides quite some other Windows specific "
"data types, for example :c:type:`HWND`, :c:type:`WPARAM`, or :c:type:"
"`DWORD`.  Some useful structures like :c:type:`MSG` or :c:type:`RECT` are "
"also defined."
msgstr ""

#: library/ctypes.rst:2386
msgid "Structured data types"
msgstr "Types de données dérivés de Structure"

#: library/ctypes.rst:2391
msgid "Abstract base class for unions in native byte order."
msgstr ""

#: library/ctypes.rst:2396
msgid "Abstract base class for structures in *big endian* byte order."
msgstr ""

#: library/ctypes.rst:2401
msgid "Abstract base class for structures in *little endian* byte order."
msgstr ""

#: library/ctypes.rst:2403
msgid ""
"Structures with non-native byte order cannot contain pointer type fields, or "
"any other data types containing pointer type fields."
msgstr ""

#: library/ctypes.rst:2409
msgid "Abstract base class for structures in *native* byte order."
msgstr ""

#: library/ctypes.rst:2411
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. :mod:"
"`ctypes` will create :term:`descriptor`\\s which allow reading and writing "
"the fields by direct attribute accesses.  These are the"
msgstr ""

#: library/ctypes.rst:2419
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or 3-"
"tuples.  The first item is the name of the field, the second item specifies "
"the type of the field; it can be any ctypes data type."
msgstr ""

#: library/ctypes.rst:2423
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""

#: library/ctypes.rst:2427
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""

#: library/ctypes.rst:2430
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating "
"data types that directly or indirectly reference themselves::"
msgstr ""

#: library/ctypes.rst:2440
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on it, "
"and so on).  Later assignments to the :attr:`_fields_` class variable will "
"raise an AttributeError."
msgstr ""

#: library/ctypes.rst:2445
msgid ""
"It is possible to define sub-subclasses of structure types, they inherit the "
"fields of the base class plus the :attr:`_fields_` defined in the sub-"
"subclass, if any."
msgstr ""

#: library/ctypes.rst:2452
msgid ""
"An optional small integer that allows overriding the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when :attr:"
"`_fields_` is assigned, otherwise it will have no effect."
msgstr ""

#: library/ctypes.rst:2459
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. :"
"attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""

#: library/ctypes.rst:2463
msgid ""
"The fields listed in this variable must be structure or union type fields. :"
"mod:`ctypes` will create descriptors in the structure type that allows "
"accessing the nested fields directly, without the need to create the "
"structure or union field."
msgstr ""

#: library/ctypes.rst:2468
msgid "Here is an example type (Windows)::"
msgstr ""

#: library/ctypes.rst:2481
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""

#: library/ctypes.rst:2493
msgid ""
"It is possible to define sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate :attr:"
"`_fields_` variable, the fields specified in this are appended to the fields "
"of the base class."
msgstr ""

#: library/ctypes.rst:2498
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the "
"same order as they are appear in :attr:`_fields_`.  Keyword arguments in the "
"constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for "
"names not present in :attr:`_fields_`."
msgstr ""

#: library/ctypes.rst:2509
msgid "Arrays and pointers"
msgstr "Tableaux et pointeurs"

#: library/ctypes.rst:2513
msgid "Abstract base class for arrays."
msgstr "Classe de base abstraite pour les *arrays*."

#: library/ctypes.rst:2515
msgid ""
"The recommended way to create concrete array types is by multiplying any :"
"mod:`ctypes` data type with a positive integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard subscript "
"and slice accesses; for slice reads, the resulting object is *not* itself "
"an :class:`Array`."
msgstr ""

#: library/ctypes.rst:2525
msgid ""
"A positive integer specifying the number of elements in the array. Out-of-"
"range subscripts result in an :exc:`IndexError`. Will be returned by :func:"
"`len`."
msgstr ""

#: library/ctypes.rst:2532
msgid "Specifies the type of each element in the array."
msgstr "Spécifie le type de chaque élément de l'*array*."

#: library/ctypes.rst:2535
msgid ""
"Array subclass constructors accept positional arguments, used to initialize "
"the elements in order."
msgstr ""

#: library/ctypes.rst:2541
msgid "Private, abstract base class for pointers."
msgstr ""

#: library/ctypes.rst:2543
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the type "
"that will be pointed to; this is done automatically by :func:`pointer`."
msgstr ""

#: library/ctypes.rst:2547
msgid ""
"If a pointer points to an array, its elements can be read and written using "
"standard subscript and slice accesses.  Pointer objects have no size, so :"
"func:`len` will raise :exc:`TypeError`.  Negative subscripts will read from "
"the memory *before* the pointer (as in C), and out-of-range subscripts will "
"probably crash with an access violation (if you're lucky)."
msgstr ""

#: library/ctypes.rst:2557
msgid "Specifies the type pointed to."
msgstr ""

#: library/ctypes.rst:2561
msgid ""
"Returns the object to which to pointer points.  Assigning to this attribute "
"changes the pointer to point to the assigned object."
msgstr ""
