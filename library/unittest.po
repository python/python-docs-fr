# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-17 21:38+0100\n"
"PO-Revision-Date: 2018-12-09 16:22+0100\n"
"Last-Translator: Lowic Mangin <louis.gabriel@orange.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.1.1\n"

#: ../Doc/library/unittest.rst:2
msgid ":mod:`unittest` --- Unit testing framework"
msgstr ":mod:`unittest` — *Framework* de tests unitaires"

#: ../Doc/library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**Code source :** :source:`Lib/unittest/__init__.py`"

#: ../Doc/library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(Si vous êtes déjà familier des concepts de base concernant les tests, vous "
"pouvez souhaiter passer à :ref:`la liste des méthodes <assert-methods>`.)"

#: ../Doc/library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
"Le cadre applicatif de tests unitaires :mod:`unittest` était au départ "
"inspiré par *JUnit* et ressemble aux principaux *frameworks* de tests "
"unitaires des autres langages. Il gère l'automatisation des tests,  le "
"partage de code pour la mise en place et la finalisation des tests, "
"l'agrégation de tests en collections, et l'indépendance des tests par "
"rapport au *framework* utilisé."

#: ../Doc/library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ""
"Pour y parvenir, :mod:`unittest` gère quelques concepts importants avec une "
"approche orientée objet :"

#: ../Doc/library/unittest.rst:32
msgid "test fixture"
msgstr "aménagement de test (*fixture*)"

#: ../Doc/library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associate cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
"Un :dfn:`aménagement de test (*fixture*)` désigne la préparation nécessaire "
"au déroulement d'un ou plusieurs tests, et toutes les actions de nettoyage "
"associées. Cela peut concerner, par exemple, la création de bases de données "
"temporaires ou mandataires, de répertoires, ou le démarrage d'un processus "
"serveur."

#: ../Doc/library/unittest.rst:37
msgid "test case"
msgstr "scénario de test"

#: ../Doc/library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
"Un :dfn:`scénario de test` est l'élément de base des tests. Il attend une "
"réponse spécifique pour un ensemble particulier d'entrées. :mod:`unittest` "
"fournit une classe de base, :class:`TestCase`, qui peut être utilisée pour "
"créer de nouveaux scénarios de test."

#: ../Doc/library/unittest.rst:41
msgid "test suite"
msgstr "suite de tests"

#: ../Doc/library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
"Une :dfn:`suite de tests` est une collection de scénarios de test, de suites "
"de tests ou les deux. Cela sert à regrouper les tests qui devraient être "
"exécutés ensemble."

#: ../Doc/library/unittest.rst:48
msgid "test runner"
msgstr "lanceur de tests"

#: ../Doc/library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
"Un :dfn:`lanceur de tests` est un composant qui orchestre l'exécution des "
"tests et fournit le résultat pour l'utilisateur. Le lanceur peut utiliser "
"une interface graphique, une interface textuelle, ou renvoie une valeur "
"spéciale pour indiquer les résultats de l'exécution des tests."

#: ../Doc/library/unittest.rst:53
msgid "Module :mod:`doctest`"
msgstr "Module :mod:`doctest`"

#: ../Doc/library/unittest.rst:53
msgid "Another test-support module with a very different flavor."
msgstr "Un autre module de test adoptant une approche très différente."

#: ../Doc/library/unittest.rst:57
msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../Doc/library/unittest.rst:56
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""
"Le papier originel de Kent Beck sur les *frameworks* de test utilisant le "
"modèle sur lequel s'appuie :mod:`unittest`."

#: ../Doc/library/unittest.rst:61
#, fuzzy
msgid ""
"`Nose <https://nose.readthedocs.io/>`_ and `pytest <https://docs.pytest.org/"
">`_"
msgstr ""
"`Nose <https://nose.readthedocs.io/>`_ et `py.test <https://docs.pytest.org/"
">`_"

#: ../Doc/library/unittest.rst:60
msgid ""
"Third-party unittest frameworks with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"Des *frameworks* tierces de tests unitaires avec une syntaxe allégée pour "
"l'écriture des tests. Par exemple, ``assert func(10) == 42``."

#: ../Doc/library/unittest.rst:65
msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"

#: ../Doc/library/unittest.rst:64
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"Une liste étendue des outils de test pour Python comprenant des *frameworks* "
"de tests fonctionnels et des bibliothèques d'objets simulés (*mocks*)."

#: ../Doc/library/unittest.rst:69
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"

#: ../Doc/library/unittest.rst:68
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr "un groupe de discussion dédié aux tests, et outils de test, en Python."

#: ../Doc/library/unittest.rst:71
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://jenkins.io/>`_ or  `Hudson <http://hudson-ci.org/>`_."
msgstr ""
"Le script :file:`Tools/unittestgui/unittestgui.py` dans la distribution "
"source de Python est un outil avec une interface graphique pour découvrir et "
"exécuter des tests. Il est principalement conçu pour être facile d'emploi "
"pour les débutants en matière de tests unitaires. Pour les environnements de "
"production il est recommandé que les tests soient pilotés par un système "
"d'intégration continue comme `Buildbot <https://buildbot.net/>`_, `Jenkins "
"<https://jenkins.io/>`_ ou  `Hudson <http://hudson-ci.org/>`_."

#: ../Doc/library/unittest.rst:82
msgid "Basic example"
msgstr "Exemple basique"

#: ../Doc/library/unittest.rst:84
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
"Le module :mod:`unittest` fournit un riche ensemble d'outils pour construire "
"et lancer des tests. Cette section montre qu'une petite partie des outils "
"suffit pour satisfaire les besoins de la plupart des utilisateurs."

#: ../Doc/library/unittest.rst:88
msgid "Here is a short script to test three string methods::"
msgstr "Voici un court script pour tester trois méthodes de *string* ::"

#: ../Doc/library/unittest.rst:112
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"Un scénario de test est créé comme classe-fille de :class:`unittest."
"TestCase`. Les trois tests individuels sont définis par des méthodes dont "
"les noms commencent par les lettres ``test``. Cette convention de nommage "
"signale au lanceur de tests quelles méthodes sont des tests."

#: ../Doc/library/unittest.rst:117
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"Le cœur de chaque test est un appel à :meth:`~TestCase.assertEqual` pour "
"vérifier un résultat attendu ; :meth:`~TestCase.assertTrue` ou :meth:"
"`~TestCase.assertFalse` pour vérifier une condition ; ou :meth:`~TestCase."
"assertRaises` pour vérifier qu'une exception particulière est levée. Ces "
"méthodes sont utilisées à la place du mot-clé :keyword:`assert`  pour que le "
"lanceur de tests puisse récupérer les résultats de tous les tests et "
"produire un rapport."

#: ../Doc/library/unittest.rst:124
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"Les méthodes :meth:`~TestCase.setUp` et :meth:`~TestCase.tearDown` vous "
"autorisent à définir des instructions qui seront exécutées avant et après "
"chaque méthode test. Elles sont davantage détaillées dans la section :ref:"
"`organizing-tests`."

#: ../Doc/library/unittest.rst:128
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"Le bloc final montre une manière simple de lancer les tests. :func:`unittest."
"main` fournit une interface en ligne de commande pour le script de test. "
"Lorsqu'il est lancé en ligne de commande, le script ci-dessus produit une "
"sortie qui ressemble à ceci ::"

#: ../Doc/library/unittest.rst:138
msgid ""
"Passing the ``-v`` option to your test script will instruct :func:`unittest."
"main` to enable a higher level of verbosity, and produce the following "
"output::"
msgstr ""
"Passer l'option ``-v`` à votre script de test informera :func:`unittest."
"main` qu'il doit fournir un niveau plus important de verbosité, et produit "
"la sortie suivante ::"

#: ../Doc/library/unittest.rst:150
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"Les exemples ci-dessus montrent les fonctionnalités d':mod:`unittest` les "
"plus communément utilisées et qui sont suffisantes pour couvrir les besoins "
"courants en matière de test. Le reste de la documentation explore l'ensemble "
"complet des fonctionnalités depuis les premiers principes."

#: ../Doc/library/unittest.rst:158
msgid "Command-Line Interface"
msgstr "Interface en ligne de commande"

#: ../Doc/library/unittest.rst:160
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"Le module *unittest* est utilisable depuis la ligne de commande pour "
"exécuter des tests à partir de modules, de classes ou même de méthodes de "
"test individuelles : ::"

#: ../Doc/library/unittest.rst:167
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"La commande accepte en argument une liste de n'importe quelle combinaison de "
"noms de modules et de noms de classes ou de méthodes entièrement qualifiés."

#: ../Doc/library/unittest.rst:170
msgid "Test modules can be specified by file path as well::"
msgstr ""
"Les modules de test peuvent également être spécifiés par un chemin de "
"fichier : ::"

#: ../Doc/library/unittest.rst:174
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"Cette fonctionnalité permet d'utiliser la complétion de l'interpréteur de "
"commandes système (*le shell*) pour spécifier le module de test. Le chemin "
"est converti en nom de module en supprimant le '.py' et en convertissant les "
"séparateurs de chemin en '.'. Si vous voulez exécuter un fichier test qui "
"n'est pas importable en tant que module, exécutez directement le fichier."

#: ../Doc/library/unittest.rst:180
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"Pour obtenir plus de détails lors de l'exécution utilisez l'option `-v` "
"(plus de verbosité): ::"

#: ../Doc/library/unittest.rst:184
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr ""
"Quand la commande est exécutée sans arguments :ref:`unittest-test-discovery` "
"est lancée: ::"

#: ../Doc/library/unittest.rst:188
msgid "For a list of all the command-line options::"
msgstr ""
"Pour afficher la liste de toutes les options de la commande utilisez "
"l'option `-h`: ::"

#: ../Doc/library/unittest.rst:192
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"Dans les versions antérieures, il était seulement possible d'exécuter des "
"méthodes de test individuelles et non des modules ou des classes."

#: ../Doc/library/unittest.rst:198
msgid "Command-line options"
msgstr "Options de la ligne de commande"

#: ../Doc/library/unittest.rst:200
msgid ":program:`unittest` supports these command-line options:"
msgstr "Le programme : `unittest` gère ces options de la ligne de commande :"

#: ../Doc/library/unittest.rst:206
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"Les flux de sortie et d'erreur standard sont mis en mémoire tampon pendant "
"l'exécution des tests. Les résultats d'un test réussi ne sont pas pris en "
"compte. Un test en échec ou en erreur est affiché sur la sortie et est  "
"ajouté aux messages d'erreur."

#: ../Doc/library/unittest.rst:212
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
"Utiliser :kbd:`Control-C` pendant l'exécution des tests attend que le test "
"en cours se termine, puis affiche tous les résultats obtenus jusqu'ici. Une "
"seconde utilisation de :kbd:`Control-C` provoque l'exception normale :exc:"
"`KeyboardInterrupt`."

#: ../Doc/library/unittest.rst:216
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"Voir `Signal Handling`_ pour les fonctions qui utilisent cette "
"fonctionnalité."

#: ../Doc/library/unittest.rst:220
msgid "Stop the test run on the first error or failure."
msgstr ""
"Arrête l'exécution des tests lors du premier cas d'erreur ou défaillance."

#: ../Doc/library/unittest.rst:224
msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"of the given patterns are included."
msgstr ""
"Exécute uniquement les méthodes de test et les classes qui correspondent au "
"motif ou à la chaîne de caractères. Cette option peut être utilisée "
"plusieurs fois, auquel cas tous les cas de test qui correspondent aux motifs "
"donnés sont inclus."

#: ../Doc/library/unittest.rst:228
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive "
"substring matching is used."
msgstr ""
"Les motifs qui contiennent un caractère de remplacement (``*``) sont "
"comparés au nom du test en utilisant :meth:`fnmatch.fnmatchcase` ; sinon, "
"une recherche simple de sous chaîne respectant la casse est faite."

#: ../Doc/library/unittest.rst:232
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr ""
"Les motifs sont comparés au nom de la méthode de test complètement qualifiée "
"tel qu'importé par le chargeur de test."

#: ../Doc/library/unittest.rst:235
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not ``bar_tests.FooTest."
"test_something``."
msgstr ""
"Par exemple, ``-k machin`` retient les tests ``machin_tests.UnTest."
"test_untruc``, ``truc_tests.UnTest.test_machin``, mais pas ``truc_tests."
"MachinTest.test_untruc``."

#: ../Doc/library/unittest.rst:240
msgid "Show local variables in tracebacks."
msgstr "Affiche les variables locales dans les traces d'appels."

#: ../Doc/library/unittest.rst:242
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr ""
"Les options de ligne de commande ``-b``, ``-c`` et ``-f`` ont été ajoutées."

#: ../Doc/library/unittest.rst:245
msgid "The command-line option ``--locals``."
msgstr "Ajout de l'option de ligne de commande ``--locals``."

#: ../Doc/library/unittest.rst:248
msgid "The command-line option ``-k``."
msgstr "Ajout de l'option de ligne de commande ``-k``."

#: ../Doc/library/unittest.rst:251
msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"La ligne de commande peut également être utilisée pour découvrir les tests, "
"pour exécuter tous les tests dans un projet ou juste un sous-ensemble."

#: ../Doc/library/unittest.rst:258
msgid "Test Discovery"
msgstr "Découverte des tests. "

#: ../Doc/library/unittest.rst:262
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` (including :term:`namespace packages "
"<namespace package>`) importable from the top-level directory of the project "
"(this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""
"*Unittest* prend en charge une découverte simple des tests. Afin d'être "
"compatible avec le système de découverte de test, tous les fichiers de test "
"doivent être des :ref:`modules <tut-modules>` ou des :ref:`paquets <tut-"
"packages>` (incluant des :term:`paquets-espaces de noms <namespace "
"package>`) importables du répertoire du projet (cela signifie que leurs noms "
"doivent être des :ref:`identifiants <identifiers>` valables)."

#: ../Doc/library/unittest.rst:269
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"La découverte de test est implémentée dans :meth:`TestLoader.discover`, mais "
"peut également être utilisée depuis la ligne de commande. Par exemple : ::"

#: ../Doc/library/unittest.rst:277
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"Comme raccourci, ``python -m unittest`` est l'équivalent de ``python -m "
"unittest discover``.Pour  passer des arguments au système de découverte des "
"tests, la sous-commande ``discover`` doit être utilisée explicitement."

#: ../Doc/library/unittest.rst:281
msgid "The ``discover`` sub-command has the following options:"
msgstr "La sous-commande ``discover`` a les options suivantes : ::"

#: ../Doc/library/unittest.rst:287
msgid "Verbose output"
msgstr "Affichage plus détaillé"

#: ../Doc/library/unittest.rst:291
msgid "Directory to start discovery (``.`` default)"
msgstr "Répertoire racine pour démarrer la découverte (``.`` par défaut)."

#: ../Doc/library/unittest.rst:295
msgid "Pattern to match test files (``test*.py`` default)"
msgstr "Motif de détection des fichiers de test (``test*.py`` par défaut)"

#: ../Doc/library/unittest.rst:299
msgid "Top level directory of project (defaults to start directory)"
msgstr "Répertoire de premier niveau du projet (répertoire racine par défaut)"

#: ../Doc/library/unittest.rst:301
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
"Les options :option:`-s`, :option:`-p`, et :option:`-t` peuvent être passées "
"en arguments positionnels dans cet ordre. Les deux lignes de commande "
"suivantes sont équivalentes : ::"

#: ../Doc/library/unittest.rst:308
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"En plus d'être un chemin, il est possible de passer un nom de paquet, par "
"exemple ``monprojet.souspaquet.test``, comme répertoire racine. Le nom du "
"paquet fourni est alors importé et son emplacement sur le système de "
"fichiers est utilisé comme répertoire racine."

#: ../Doc/library/unittest.rst:315
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"Le mécanisme de découverte charge les tests en les important. Une fois que "
"le système a trouvé tous les fichiers de test du répertoire de démarrage "
"spécifié, il transforme les chemins en noms de paquets à importer. Par "
"exemple :file:`truc/bidule/machin.py` est importé sous ``truc.bidule."
"machin``."

#: ../Doc/library/unittest.rst:320
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"Si un paquet est installé globalement et que le mécanisme de découverte de "
"test est effectué sur une copie différente du paquet, l'importation *peut* "
"se produire à partir du mauvais endroit. Si cela arrive, le système émet un "
"avertissement et se termine."

#: ../Doc/library/unittest.rst:324
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"Si vous donnez le répertoire racine sous la forme d'un nom de paquet plutôt "
"que d'un chemin d'accès à un répertoire, alors *discover* suppose que "
"l'emplacement à partir duquel il importe est l'emplacement que vous voulez, "
"vous ne verrez donc pas l'avertissement."

#: ../Doc/library/unittest.rst:329
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"Les modules de test et les paquets peuvent adapter le chargement et la "
"découverte des tests en utilisant le protocole `load_tests protocol`_."

#: ../Doc/library/unittest.rst:332
msgid "Test discovery supports :term:`namespace packages <namespace package>`."
msgstr ""
"La découverte de test prend en charge :term:`les paquets-espaces de noms "
"<namespace package>`."

#: ../Doc/library/unittest.rst:339
msgid "Organizing test code"
msgstr "Organiser le code de test"

#: ../Doc/library/unittest.rst:341
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"Les éléments de base des tests unitaires sont les :dfn:`test cases` --- Des "
"scénarios uniques qui sont mis en place et exécutés pour vérifier qu'ils "
"sont corrects.  Dans :mod:`unittest`, les scénarios de test sont représentés "
"par des instances de :class:`unittest.TestCase`. Pour créer vos propres "
"scénarios de test, vous devez écrire des sous-classes de :class:`TestCase` "
"ou utiliser :class:`FunctionTestCase`."

#: ../Doc/library/unittest.rst:347
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
"Le code de test d'une instance de :class:`TestCase` doit être entièrement "
"autonome, de sorte qu'il puisse être exécuté soit de manière isolée, soit en "
"combinaison arbitraire avec un nombre quelconque d'autres scénarios de test."

#: ../Doc/library/unittest.rst:351
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific "
"testing code::"
msgstr ""
"La sous-classe :class:`TestCase` la plus simple va tout simplement "
"implémenter une méthode de test (c'est-à-dire une méthode dont le nom "
"commence par ``test``) afin d'exécuter un code de test spécifique : ::"

#: ../Doc/library/unittest.rst:362
msgid ""
"Note that in order to test something, we use one of the :meth:`assert\\*` "
"methods provided by the :class:`TestCase` base class.  If the test fails, an "
"exception will be raised with an explanatory message, and :mod:`unittest` "
"will identify the test case as a :dfn:`failure`.  Any other exceptions will "
"be treated as :dfn:`errors`."
msgstr ""
"Notez que pour tester quelque chose, on utilise l'une des méthodes :meth:"
"`assert\\*` fournies par la classe de base :class:`TestCase`.  Si le test "
"échoue, une exception est levée avec un message explicatif, et :mod:"
"`unittest` identifie le cas de test comme un :dfn:`échec`.  Toute autre "
"exception est traitée comme une :dfn:`erreur`."

#: ../Doc/library/unittest.rst:368
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called :meth:`~TestCase."
"setUp`, which the testing framework will automatically call for every single "
"test we run::"
msgstr ""
"Les tests peuvent être nombreux et leur mise en place peut être répétitive.  "
"Heureusement, on peut factoriser le code de mise en place en implémentant "
"une méthode appelée :meth:`~TestCase.setUp`, que le système de test appelle "
"automatiquement pour chaque test exécuté : ::"

#: ../Doc/library/unittest.rst:389
msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr ""
"L'ordre dans lequel les différents tests sont exécutés est déterminé en "
"classant les noms des méthodes de test en fonction des relation d'ordre des "
"chaines de caractères ."

#: ../Doc/library/unittest.rst:393
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the test method will not be executed."
msgstr ""
"Si la méthode :meth:`~TestCase.setUp` lève une exception pendant l'exécution "
"du test, le système considère que le test a subi une erreur, et la méthode "
"test n'est pas exécutée."

#: ../Doc/library/unittest.rst:397
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the test method has been run::"
msgstr ""
"De même, on peut fournir une méthode :meth:`~TestCase.tearDown` qui nettoie "
"après l'exécution de la méthode de test : ::"

#: ../Doc/library/unittest.rst:409
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run "
"whether the test method succeeded or not."
msgstr ""
"Si :meth:`~TestCase.setUp` a réussi, :meth:`~TestCase.tearDown` est "
"exécutée, que la méthode de test ait réussi ou non."

#: ../Doc/library/unittest.rst:412
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called once per "
"test."
msgstr ""
"Un tel environnement de travail pour le code de test s'appelle une :dfn:"
"`fixture`.  Une nouvelle instance de *TestCase* est créée sous la forme d'un "
"dispositif de test unique utilisé pour exécuter chaque méthode de test "
"individuelle.  Ainsi :meth:`~TestCase.setUp`, :meth:`~TestCase.tearDown` et :"
"meth:`~TestCase.__init__` ne sont appelées qu'une fois par test."

#: ../Doc/library/unittest.rst:418
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`suite de tests`, represented by :mod:"
"`unittest`'s :class:`TestSuite` class.  In most cases, calling :func:"
"`unittest.main` will do the right thing and collect all the module's test "
"cases for you and execute them."
msgstr ""
"Il est recommandé d'utiliser *TestCase* pour regrouper les tests en fonction "
"des fonctionnalités qu'ils testent. :mod:`unittest` fournit un mécanisme "
"pour cela : la :dfn:`suite de tests`, représentée par :class:`TestSuite` du "
"module :mod:`unittest`. Dans la plupart des cas, appeler :func:`unittest."
"main` fait la bonne chose et rassemble tous les cas de test du module pour "
"vous et les exécute."

#: ../Doc/library/unittest.rst:425
msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr ""
"Cependant, si vous voulez personnaliser la construction de votre suite de "
"tests, vous pouvez le faire vous-même : ::"

#: ../Doc/library/unittest.rst:438
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"Vous pouvez placer les définitions des cas de test et des suites de test "
"dans le même module que le code à tester (tel que :file:`composant.py`), "
"mais il y a plusieurs avantages à placer le code test dans un module séparé, "
"tel que :file:`test_composant.py` :"

#: ../Doc/library/unittest.rst:443
msgid "The test module can be run standalone from the command line."
msgstr ""
"Le module de test peut être exécuté indépendamment depuis la ligne de "
"commande."

#: ../Doc/library/unittest.rst:445
msgid "The test code can more easily be separated from shipped code."
msgstr "Le code de test est plus facilement séparable du code livré."

#: ../Doc/library/unittest.rst:447
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"La tentation est moins grande de changer le code de test pour l'adapter au "
"code qu'il teste sans avoir une bonne raison."

#: ../Doc/library/unittest.rst:450
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr ""
"Le code de test doit être modifié beaucoup moins souvent que le code qu'il "
"teste."

#: ../Doc/library/unittest.rst:452
msgid "Tested code can be refactored more easily."
msgstr "Le code testé peut être réusiné plus facilement."

#: ../Doc/library/unittest.rst:454
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"Les tests pour les modules écrits en C doivent de toute façon être dans des "
"modules séparés, alors pourquoi ne pas être cohérents ?"

#: ../Doc/library/unittest.rst:457
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr ""
"Si la stratégie de test change, il n'est pas nécessaire de changer le code "
"source."

#: ../Doc/library/unittest.rst:463
msgid "Re-using old test code"
msgstr "Réutilisation d'ancien code de test"

#: ../Doc/library/unittest.rst:465
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""
"Certains utilisateurs constatent qu'ils ont du code de test existant qu'ils "
"souhaitent exécuter à partir de :mod:`unittest`, sans convertir chaque "
"ancienne fonction de test en une sous-classe de :class:`TestCase`."

#: ../Doc/library/unittest.rst:469
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"Pour cette raison, :mod:`unittest` fournit une classe :class:"
"`FunctionTestCase`. Cette sous-classe de :class:`TestCase` peut être "
"utilisée pour encapsuler une fonction de test existante. Des fonctions de "
"mise en place (*setUp*) et de démantèlement (*tearDown*) peuvent également "
"être fournies."

#: ../Doc/library/unittest.rst:473
msgid "Given the following test function::"
msgstr "Étant donné la fonction de test suivante : ::"

#: ../Doc/library/unittest.rst:480
msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr ""
"on peut créer une instance de scénario de test équivalente , avec des "
"méthodes optionnelles de mise en place et de démantèlement : ::"

#: ../Doc/library/unittest.rst:489
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"Même si  la classe :class:`FunctionTestCase` peut être utilisée pour "
"convertir rapidement une base de test existante vers un système basé sur :"
"mod:`unittest`. Cette approche n'est pas recommandée.  Prendre le temps de "
"bien configurer les sous-classes de :class:`TestCase` simplifiera "
"considérablement les futurs réusinages des tests."

#: ../Doc/library/unittest.rst:494
msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"Dans certains cas, les tests déjà existants ont pu être écrits avec le "
"module :mod:`doctest`.  Dans ce cas, :mod:`doctest` fournit une classe :"
"class:`DocTestSuite` qui peut construire automatiquement des instances de la "
"classe :class:`unittest.TestSuite` depuis des tests basés sur le module :mod:"
"`doctest`."

#: ../Doc/library/unittest.rst:503
msgid "Skipping tests and expected failures"
msgstr "Ignorer les tests et les erreurs prévisibles."

#: ../Doc/library/unittest.rst:507
msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"*Unittest* permet d'ignorer des méthodes de test individuelles et même des "
"classes entières de tests. De plus, il prend en charge le marquage d'un test "
"comme étant une \"erreur prévue\". Un test qui est cassé et qui échoue, mais "
"qui ne doit pas être considéré comme un échec dans la classe :class:"
"`TestResult`."

#: ../Doc/library/unittest.rst:512
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants."
msgstr ""
"Ignorer un test consiste à utiliser la fonction :func:`skip`  qui est un :"
"term:`decorator` ou une de ses variantes conditionnelles."

#: ../Doc/library/unittest.rst:515
msgid "Basic skipping looks like this::"
msgstr "Un exemple de tests à ignorer : ::"

#: ../Doc/library/unittest.rst:534
msgid "This is the output of running the example above in verbose mode::"
msgstr ""
"Ceci est le résultat de l'exécution de l'exemple ci-dessus en mode "
"verbeux : ::"

#: ../Doc/library/unittest.rst:545
msgid "Classes can be skipped just like methods::"
msgstr "Les classes peuvent être ignorées tout comme les méthodes : ::"

#: ../Doc/library/unittest.rst:552
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
"La méthode :meth:`TestCase.setUp` permet également d'ignorer le test.  Ceci "
"est utile lorsqu'une ressource qui doit être configurée n'est pas disponible."

#: ../Doc/library/unittest.rst:555
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr ""
"Les erreurs prévisibles utilisent le décorateur :func:`expectedFailure` : ::"

#: ../Doc/library/unittest.rst:562
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"Il est facile de faire ses propres décorateurs en créant un décorateur qui "
"appelle :func:`skip` sur le test que  vous voulez ignoré. Par exemple, ce "
"décorateur ignore le test à moins que l'objet passé ne possède un certain "
"attribut : ::"

#: ../Doc/library/unittest.rst:571
msgid "The following decorators implement test skipping and expected failures:"
msgstr ""
"Les décorateurs suivants implémentent le système d'omission des tests et les "
"erreurs prévisibles : ::"

#: ../Doc/library/unittest.rst:575
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"Ignore sans condition le test décoré.  *La raison* doit décrire la raison "
"pour laquelle le test est omis."

#: ../Doc/library/unittest.rst:580
msgid "Skip the decorated test if *condition* is true."
msgstr "Ignore le test décoré si la *condition* est vrai."

#: ../Doc/library/unittest.rst:584
msgid "Skip the decorated test unless *condition* is true."
msgstr "Ignore le test décoré sauf si la *condition* est vrai."

#: ../Doc/library/unittest.rst:588
msgid ""
"Mark the test as an expected failure.  If the test fails it will be "
"considered a success.  If the test passes, it will be considered a failure."
msgstr ""
"Marque le test comme étant un erreur attendue.  Si le test échoue lors de "
"son exécution, il n'est pas considéré comme étant en échec."

#: ../Doc/library/unittest.rst:593
msgid "This exception is raised to skip a test."
msgstr "Cette exception est levée pour ignorer un test."

#: ../Doc/library/unittest.rst:595
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"Habituellement, on utilise :meth:`TestCase.skipTest` ou l'un des décorateurs "
"d'omission au lieu de le lever une exception directement."

#: ../Doc/library/unittest.rst:598
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or :meth:`~TestCase."
"tearDown` run around them. Skipped classes will not have :meth:`~TestCase."
"setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped modules will not "
"have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"Les tests ignorés n'ont pas :meth:`~TestCase.setUp` ou :meth:`~TestCase."
"tearDown` d'exécutés. Les classes ignorées n'ont pas :meth:`~TestCase."
"setUpClass` ou :meth:`~TestCase.tearDownClass` d'exécutés. Les modules "
"sautés n'ont pas :func:`setUpModule` ou :func:`tearDownModule` d'exécutés."

#: ../Doc/library/unittest.rst:606
msgid "Distinguishing test iterations using subtests"
msgstr "Distinguer les itérations de test à l'aide de sous-tests"

#: ../Doc/library/unittest.rst:610
msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"Lorsque certains de vos tests ne diffèrent que par de très petites "
"différences, par exemple certains paramètres; *unittest* vous permet de les "
"distinguer en utilisant le gestionnaire de contexte :meth:`~TestCase."
"subTest` dans le corps d'une méthode de test."

#: ../Doc/library/unittest.rst:614
msgid "For example, the following test::"
msgstr "Par exemple, le test suivant : ::"

#: ../Doc/library/unittest.rst:626
msgid "will produce the following output::"
msgstr "produit le résultat suivant : ::"

#: ../Doc/library/unittest.rst:652
msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't "
"be displayed::"
msgstr ""
"Sans l'utilisation d'un sous-test, l'exécution se termine après le premier "
"échec, et l'erreur est moins facile à diagnostiquer car la valeur de ``i`` "
"ne s'affiche pas : ::"

#: ../Doc/library/unittest.rst:668
msgid "Classes and functions"
msgstr "Classes et fonctions"

#: ../Doc/library/unittest.rst:670
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "Cette section décrit en détail l'API de :mod:`unittest`."

#: ../Doc/library/unittest.rst:676
msgid "Test cases"
msgstr "Scénarios de tests"

#: ../Doc/library/unittest.rst:680
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in "
"the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
"Les instances de la classe :class:`TestCase` représentent des tests logiques "
"unitaires dans l'univers :mod:`unittest`. Cette classe est conçue pour être "
"utilisée comme classe de base. Les scénarios de tests sont à implémenter en "
"héritant de cette classe. La classe implémente l'interface nécessaire au "
"lanceur de test pour lui permettre de les exécuter ainsi que les méthodes "
"que le code de test peut utiliser pour vérifier et signaler les différents "
"types d'erreurs."

#: ../Doc/library/unittest.rst:687
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method "
"named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
"Chaque instance de la classe :class:`TestCase` exécutera une seule méthode "
"de base : La méthode nommée *methodName* . Dans la plupart des utilisations "
"de la classe :class:`TestCase`, vous n'avez pas à changer le nom de la "
"méthode, ni à réimplémenter la méthode ``runTest()``."

#: ../Doc/library/unittest.rst:692
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""
"La classe :class:`TestCase` peut désormais être utilisée sans passer de "
"paramètre *methodName*. Cela facilite l'usage de :class:`TestCase` dans "
"l'interpréteur interactif."

#: ../Doc/library/unittest.rst:697
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
"Les instances de la classe :class:`TestCase` fournissent trois groupes de "
"méthodes : un groupe utilisé pour exécuter le test, un autre utilisé par "
"l'implémentation du test pour vérifier les conditions et signaler les "
"échecs, et quelques méthodes de recherche permettant de recueillir des "
"informations sur le test lui-même."

#: ../Doc/library/unittest.rst:702
msgid "Methods in the first group (running the test) are:"
msgstr "Les méthodes du premier groupe (exécution du test) sont :"

#: ../Doc/library/unittest.rst:706
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"Méthode appelée pour réaliser la mise en place du test. Elle est exécutée "
"immédiatement avant l'appel de la méthode de test ; à l'exception de :exc:"
"`AssertionError` ou :exc:`SkipTest`, toute exception levée par cette méthode "
"est considérée une erreur et non pas comme un échec du test. "
"L'implémentation par défaut ne fait rien."

#: ../Doc/library/unittest.rst:714
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""
"Méthode appelée immédiatement après l'appel de la méthode de test et "
"l'enregistrement du résultat.  Elle est appelée même si la méthode de test a "
"levé une exception, de sorte que l'implémentation dans les sous-classes de "
"contrôles d'état interne à la classe doit être fait avec précaution.  Toute "
"exception, autre que :exc:`AssertionError` ou :exc:`SkipTest`, levée par "
"cette méthode est considérée comme une erreur supplémentaire plutôt que "
"comme un échec du test (augmentant ainsi le nombre total des erreurs "
"signalées). Cette méthode est appelée uniquement si l'exécution de :meth:"
"`setUp` est réussie quel que soit le résultat de la méthode de test. "
"L'implémentation par défaut ne fait rien."

#: ../Doc/library/unittest.rst:727
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"Méthode de classe appelée avant l'exécution des tests dans la classe en "
"question. ``setUpClass`` est appelé avec la classe comme seul argument et "
"doit être décoré comme une  :func:`classmethod` : ::"

#: ../Doc/library/unittest.rst:735 ../Doc/library/unittest.rst:750
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "Voir `Class and Module Fixtures`_ pour plus de détails."

#: ../Doc/library/unittest.rst:742
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"Méthode de classe appelée après l'exécution des tests de la classe en "
"question. ``tearDownClass`` est appelé avec la classe comme seul argument et "
"doit être décoré comme une :meth:`classmethod` : ::"

#: ../Doc/library/unittest.rst:757
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"Exécute le test, en collectant le résultat dans l'objet :class:`TestResult` "
"passé comme *result*.  Si *result* est omis ou vaut ``None``, un objet "
"temporaire de résultat est créé (en appelant la méthode :meth:"
"`defaultTestResult`) et utilisé. L'objet résultat est renvoyé à l'appelant "
"de :meth:`run`."

#: ../Doc/library/unittest.rst:763
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""
"Le même effet peut être obtenu en appelant simplement l'instance :class:"
"`TestCase`."

#: ../Doc/library/unittest.rst:766
msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr ""
"Les versions précédentes de ``run`` ne renvoyaient pas le résultat. Pas plus "
"que l'appel d'une instance."

#: ../Doc/library/unittest.rst:772
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""
"Appeler cette fonction pendant l'exécution d'une méthode de test ou de :meth:"
"`setUp` permet d'ignorer le test en cours.  Voir :ref:`unittest-skipping` "
"pour plus d'informations."

#: ../Doc/library/unittest.rst:780
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"Renvoie un gestionnaire de contexte qui exécute le bloc de code du contexte "
"comme un sous-test. *msg* et *params* sont des valeurs optionnelles et "
"arbitraires qui sont affichées chaque fois qu'un sous-test échoue, "
"permettant de les identifier clairement."

#: ../Doc/library/unittest.rst:785
msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr ""
"Un scénario de test peut contenir un nombre quelconque de déclarations de "
"sous-test, et elles peuvent être imbriquées librement."

#: ../Doc/library/unittest.rst:788
msgid "See :ref:`subtests` for more information."
msgstr "Voir :ref:`subtests` pour plus d'informations."

#: ../Doc/library/unittest.rst:795
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""
"Lance le test sans collecter le résultat.  Ceci permet aux exceptions levées "
"par le test d'être propagées à l'appelant, et donc peut être utilisé pour "
"exécuter des tests sous un débogueur."

#: ../Doc/library/unittest.rst:801
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
"La classe :class:`TestCase` fournit plusieurs méthodes d'assertion pour "
"vérifier et signaler les échecs.  Le tableau suivant énumère les méthodes "
"les plus couramment utilisées (voir les tableaux ci-dessous pour plus de "
"méthodes d'assertion) :"

#: ../Doc/library/unittest.rst:806 ../Doc/library/unittest.rst:928
#: ../Doc/library/unittest.rst:1120 ../Doc/library/unittest.rst:1247
msgid "Method"
msgstr "Méthode"

#: ../Doc/library/unittest.rst:806 ../Doc/library/unittest.rst:928
#: ../Doc/library/unittest.rst:1120
msgid "Checks that"
msgstr "Vérifie que"

#: ../Doc/library/unittest.rst:806 ../Doc/library/unittest.rst:928
#: ../Doc/library/unittest.rst:1120 ../Doc/library/unittest.rst:1247
msgid "New in"
msgstr "Disponible en"

#: ../Doc/library/unittest.rst:808
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../Doc/library/unittest.rst:808
msgid "``a == b``"
msgstr "``a == b``"

#: ../Doc/library/unittest.rst:811
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../Doc/library/unittest.rst:811
msgid "``a != b``"
msgstr "``a != b``"

#: ../Doc/library/unittest.rst:814
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../Doc/library/unittest.rst:814
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../Doc/library/unittest.rst:817
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../Doc/library/unittest.rst:817
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../Doc/library/unittest.rst:820
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../Doc/library/unittest.rst:820
msgid "``a is b``"
msgstr "``a is b``"

#: ../Doc/library/unittest.rst:820 ../Doc/library/unittest.rst:823
#: ../Doc/library/unittest.rst:826 ../Doc/library/unittest.rst:829
#: ../Doc/library/unittest.rst:832 ../Doc/library/unittest.rst:835
#: ../Doc/library/unittest.rst:933 ../Doc/library/unittest.rst:1128
#: ../Doc/library/unittest.rst:1131 ../Doc/library/unittest.rst:1134
#: ../Doc/library/unittest.rst:1137 ../Doc/library/unittest.rst:1140
#: ../Doc/library/unittest.rst:1249 ../Doc/library/unittest.rst:1252
#: ../Doc/library/unittest.rst:1255 ../Doc/library/unittest.rst:1258
#: ../Doc/library/unittest.rst:1261 ../Doc/library/unittest.rst:1264
msgid "3.1"
msgstr "3.1"

#: ../Doc/library/unittest.rst:823
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../Doc/library/unittest.rst:823
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../Doc/library/unittest.rst:826
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../Doc/library/unittest.rst:826
msgid "``x is None``"
msgstr "``x is None``"

#: ../Doc/library/unittest.rst:829
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../Doc/library/unittest.rst:829
msgid "``x is not None``"
msgstr "``x is not None``"

#: ../Doc/library/unittest.rst:832
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../Doc/library/unittest.rst:832
msgid "``a in b``"
msgstr "``a in b``"

#: ../Doc/library/unittest.rst:835
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../Doc/library/unittest.rst:835
msgid "``a not in b``"
msgstr "``a not in b``"

#: ../Doc/library/unittest.rst:838
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../Doc/library/unittest.rst:838
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../Doc/library/unittest.rst:838 ../Doc/library/unittest.rst:841
#: ../Doc/library/unittest.rst:936 ../Doc/library/unittest.rst:939
#: ../Doc/library/unittest.rst:1143 ../Doc/library/unittest.rst:1146
msgid "3.2"
msgstr "3.2"

#: ../Doc/library/unittest.rst:841
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../Doc/library/unittest.rst:841
msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

#: ../Doc/library/unittest.rst:845
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` only when "
"they are used as a context manager."
msgstr ""
"Toutes les méthodes *assert* prennent en charge un argument *msg* qui, s'il "
"est spécifié, est utilisé comme message d'erreur en cas d'échec (voir aussi :"
"data:`longMessage`). Notez que l'argument mot-clé *msg* peut être passé à :"
"meth:`assertRaises`, :meth:`assertRaisesRegex`, :meth:`assertWarns`, :meth:"
"`assertWarnsRegex`, seulement quand elles sont utilisées comme gestionnaire "
"de contexte."

#: ../Doc/library/unittest.rst:853
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""
"Vérifie que *first* et *second* sont égaux.  Si les valeurs ne sont pas "
"égales, le test échouera."

#: ../Doc/library/unittest.rst:856
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"En outre, si *first* et *second* ont exactement le même type et sont de type "
"*liste*, *tuple*, *dict*, *set*, *frozenset* ou *str* ou tout autre type de "
"sous classe enregistrée dans :meth:`addTypeEqualityFunc`. La fonction "
"égalité spécifique au type sera appelée pour générer une erreur plus utile "
"(voir aussi :ref:`liste des méthodes spécifiques de type <type-specific-"
"methods>`)."

#: ../Doc/library/unittest.rst:863
msgid "Added the automatic calling of type-specific equality function."
msgstr ""
"Ajout de l'appel automatique de la fonction d'égalité spécifique au type."

#: ../Doc/library/unittest.rst:866
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ""
"Ajout de :meth:`assertMultiLineEqual` comme fonction d'égalité de type par "
"défaut pour comparer les chaînes."

#: ../Doc/library/unittest.rst:873
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""
"Vérifie que *first* et *second* ne sont pas égaux.  Si les valeurs sont "
"égales, le test échouera."

#: ../Doc/library/unittest.rst:879
msgid "Test that *expr* is true (or false)."
msgstr "Vérifie que *expr* est vraie (ou fausse)."

#: ../Doc/library/unittest.rst:881
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"Notez que cela revient à utiliser ``bool(expr) is True`` et non à ``expr is "
"True`` (utilisez ``assertIs(expr, True)`` pour cette dernière). Cette "
"méthode doit également être évitée lorsque des méthodes plus spécifiques "
"sont disponibles (par exemple ``assertEqual(a, b)`` au lieu de "
"``assertTrue(a == b)``), car elles fournissent un meilleur message d'erreur "
"en cas d' échec."

#: ../Doc/library/unittest.rst:891
msgid ""
"Test that *first* and *second* evaluate (or don't evaluate) to the same "
"object."
msgstr ""
"Vérifie que *first* et *second* évaluent (ou n'évaluent pas) le même objet."

#: ../Doc/library/unittest.rst:900
msgid "Test that *expr* is (or is not) ``None``."
msgstr "Vérifie que *expr* est (ou n'est pas) la valeur ``Ǹone``"

#: ../Doc/library/unittest.rst:908
msgid "Test that *first* is (or is not) in *second*."
msgstr "Vérifie que *first* est (ou n'est pas) dans *second*."

#: ../Doc/library/unittest.rst:916
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"Vérifie que *obj* est (ou n'est pas) une instance de *cls* (Ce qui peut être "
"une classe ou un tuple de classes, comme utilisée par :func:`isinstance`). "
"Pour vérifier le type exact, utilisez :func:`assertIs(type(obj), cls) "
"<assertIs>`."

#: ../Doc/library/unittest.rst:924
msgid ""
"It is also possible to check the production of exceptions, warnings, and log "
"messages using the following methods:"
msgstr ""
"Il est également possible de vérifier la production des exceptions, des "
"avertissements et des messages de journaux à l'aide des méthodes suivantes :"

#: ../Doc/library/unittest.rst:930
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../Doc/library/unittest.rst:930
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` lève bien l'exception *exc*"

#: ../Doc/library/unittest.rst:933
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"

#: ../Doc/library/unittest.rst:933
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` lève bien l'exception *exc* et que le message "
"correspond au motif de l'expression régulière *r*"

#: ../Doc/library/unittest.rst:936
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

#: ../Doc/library/unittest.rst:936
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` lève bien l'avertissement *warn*"

#: ../Doc/library/unittest.rst:939
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"

#: ../Doc/library/unittest.rst:939
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` lève bien l'avertissement *warn* et que le message "
"correspond au motif de l'expression régulière *r*"

#: ../Doc/library/unittest.rst:942
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

#: ../Doc/library/unittest.rst:942
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr ""
"Le bloc ``with`` journalise dans le *logger*  avec un niveau minimum égal à "
"*level*"

#: ../Doc/library/unittest.rst:942
msgid "3.4"
msgstr "3.4"

#: ../Doc/library/unittest.rst:949
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""
"Vérifie qu'une exception est levée lorsque *callable* est appelé avec "
"n'importe quel argument positionnel ou mot-clé qui est également passé à :"
"meth:`assertRaises`.  Le test réussit si *exception* est levée, est en "
"erreur si une autre exception est levée, ou en échec si aucune exception "
"n'est levée. Pour capturer une exception d'un groupe d'exceptions, un couple "
"contenant les classes d'exceptions peut être passé à *exception*."

#: ../Doc/library/unittest.rst:956
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Si seuls les arguments *exception* et éventuellement *msg* sont donnés, "
"renvoie un gestionnaire de contexte pour que le code sous test puisse être "
"écrit en ligne plutôt que comme une fonction : ::"

#: ../Doc/library/unittest.rst:963
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr ""
"Lorsqu'il est utilisé comme gestionnaire de contexte, :meth:`assertRaises` "
"accepte l'argument de mot-clé supplémentaire *msg*."

#: ../Doc/library/unittest.rst:966
msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""
"Le gestionnaire de contexte enregistre l'exception capturée dans son "
"attribut :attr:`exception`. Ceci est particulièrement utile si l'intention "
"est d'effectuer des contrôles supplémentaires sur l'exception levée : ::"

#: ../Doc/library/unittest.rst:976
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""
"Ajout de la possibilité d'utiliser :meth:`assertRaises` comme gestionnaire "
"de contexte."

#: ../Doc/library/unittest.rst:979
msgid "Added the :attr:`exception` attribute."
msgstr "Ajout de l'attribut :attr:`exception`."

#: ../Doc/library/unittest.rst:982 ../Doc/library/unittest.rst:1008
#: ../Doc/library/unittest.rst:1049 ../Doc/library/unittest.rst:1072
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr ""
"Ajout de l'argument *msg* comme mot-clé lorsqu'il est utilisé comme "
"gestionnaire de contexte."

#: ../Doc/library/unittest.rst:989
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""
"Comme :meth:`assertRaises` mais vérifie aussi que *regex* correspond à la "
"représentation de la chaîne de caractères de l'exception levée.  *regex* "
"peut être un objet d'expression rationnelle ou une chaîne contenant une "
"expression rationnelle appropriée pour être utilisée par :func:`re.search`.  "
"Exemples : ::"

#: ../Doc/library/unittest.rst:997 ../Doc/library/unittest.rst:1065
msgid "or::"
msgstr "ou : ::"

#: ../Doc/library/unittest.rst:1002
msgid "under the name ``assertRaisesRegexp``."
msgstr "Sous le nom ``assertRaisesRegexp``"

#: ../Doc/library/unittest.rst:1005
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr "Renommé en :meth:`assertRaisesRegex`."

#: ../Doc/library/unittest.rst:1015
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Any exception is an error. To catch any of a group of warnings, a "
"tuple containing the warning classes may be passed as *warnings*."
msgstr ""

#: ../Doc/library/unittest.rst:1022
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""

#: ../Doc/library/unittest.rst:1029
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr ""

#: ../Doc/library/unittest.rst:1032
msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the warning caught::"
msgstr ""

#: ../Doc/library/unittest.rst:1044
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr ""

#: ../Doc/library/unittest.rst:1056
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""

#: ../Doc/library/unittest.rst:1077
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr ""

#: ../Doc/library/unittest.rst:1081
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages."
msgstr ""

#: ../Doc/library/unittest.rst:1085
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :attr:`logging.ERROR`).  The "
"default is :attr:`logging.INFO`."
msgstr ""

#: ../Doc/library/unittest.rst:1089
msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""

#: ../Doc/library/unittest.rst:1092
msgid ""
"The object returned by the context manager is a recording helper which keeps "
"tracks of the matching log messages.  It has two attributes:"
msgstr ""

#: ../Doc/library/unittest.rst:1098
msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr ""

#: ../Doc/library/unittest.rst:1103
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr ""

#: ../Doc/library/unittest.rst:1106
msgid "Example::"
msgstr "Exemple ::"

#: ../Doc/library/unittest.rst:1117
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""

#: ../Doc/library/unittest.rst:1122
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../Doc/library/unittest.rst:1122
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../Doc/library/unittest.rst:1125
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ""

#: ../Doc/library/unittest.rst:1125
msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

#: ../Doc/library/unittest.rst:1128
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../Doc/library/unittest.rst:1128
msgid "``a > b``"
msgstr "``a > b``"

#: ../Doc/library/unittest.rst:1131
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../Doc/library/unittest.rst:1131
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../Doc/library/unittest.rst:1134
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../Doc/library/unittest.rst:1134
msgid "``a < b``"
msgstr "``a < b``"

#: ../Doc/library/unittest.rst:1137
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../Doc/library/unittest.rst:1137
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../Doc/library/unittest.rst:1140
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

#: ../Doc/library/unittest.rst:1140
msgid "``r.search(s)``"
msgstr "``r.search(s)``"

#: ../Doc/library/unittest.rst:1143
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

#: ../Doc/library/unittest.rst:1143
msgid "``not r.search(s)``"
msgstr "``not r.search(s)``"

#: ../Doc/library/unittest.rst:1146
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

#: ../Doc/library/unittest.rst:1146
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order"
msgstr ""

#: ../Doc/library/unittest.rst:1155
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""

#: ../Doc/library/unittest.rst:1161
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""

#: ../Doc/library/unittest.rst:1164
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr ""

#: ../Doc/library/unittest.rst:1166
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""

#: ../Doc/library/unittest.rst:1177
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""

#: ../Doc/library/unittest.rst:1189
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""

#: ../Doc/library/unittest.rst:1195
msgid "under the name ``assertRegexpMatches``."
msgstr ""

#: ../Doc/library/unittest.rst:1197
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr ""

#: ../Doc/library/unittest.rst:1200
msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`."

#: ../Doc/library/unittest.rst:1202
msgid ""
"The name ``assertNotRegexpMatches`` is a deprecated alias for :meth:`."
"assertNotRegex`."
msgstr ""

#: ../Doc/library/unittest.rst:1209
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""

#: ../Doc/library/unittest.rst:1213
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""

#: ../Doc/library/unittest.rst:1224
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""

#: ../Doc/library/unittest.rst:1231
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""

#: ../Doc/library/unittest.rst:1242
msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""

#: ../Doc/library/unittest.rst:1247
msgid "Used to compare"
msgstr ""

#: ../Doc/library/unittest.rst:1249
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../Doc/library/unittest.rst:1249
msgid "strings"
msgstr "chaînes"

#: ../Doc/library/unittest.rst:1252
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../Doc/library/unittest.rst:1252
msgid "sequences"
msgstr "séquences"

#: ../Doc/library/unittest.rst:1255
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../Doc/library/unittest.rst:1255
msgid "lists"
msgstr ""

#: ../Doc/library/unittest.rst:1258
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../Doc/library/unittest.rst:1258
msgid "tuples"
msgstr ""

#: ../Doc/library/unittest.rst:1261
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../Doc/library/unittest.rst:1261
msgid "sets or frozensets"
msgstr ""

#: ../Doc/library/unittest.rst:1264
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../Doc/library/unittest.rst:1264
msgid "dicts"
msgstr ""

#: ../Doc/library/unittest.rst:1272
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1282
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""

#: ../Doc/library/unittest.rst:1287
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1297
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1308
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1312
msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr ""

#: ../Doc/library/unittest.rst:1320
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1331
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr ""

#: ../Doc/library/unittest.rst:1336
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""

#: ../Doc/library/unittest.rst:1342
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""

#: ../Doc/library/unittest.rst:1351
msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""

#: ../Doc/library/unittest.rst:1357
msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""

#: ../Doc/library/unittest.rst:1361
msgid "The class setting gets reset before each test call."
msgstr ""

#: ../Doc/library/unittest.rst:1368
msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1375
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr ""

#: ../Doc/library/unittest.rst:1381
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""

#: ../Doc/library/unittest.rst:1387
msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""

#: ../Doc/library/unittest.rst:1393
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""

#: ../Doc/library/unittest.rst:1397
msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""

#: ../Doc/library/unittest.rst:1404
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""

#: ../Doc/library/unittest.rst:1410
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""

#: ../Doc/library/unittest.rst:1415
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""

#: ../Doc/library/unittest.rst:1424
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (:abbr:`LIFO (last-in, first-out)`).  They are called with any "
"arguments and keyword arguments passed into :meth:`addCleanup` when they are "
"added."
msgstr ""

#: ../Doc/library/unittest.rst:1430
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""

#: ../Doc/library/unittest.rst:1438
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""

#: ../Doc/library/unittest.rst:1441
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""

#: ../Doc/library/unittest.rst:1446
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""

#: ../Doc/library/unittest.rst:1454
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""

#: ../Doc/library/unittest.rst:1464
msgid "Deprecated aliases"
msgstr ""

#: ../Doc/library/unittest.rst:1466
msgid ""
"For historical reasons, some of the :class:`TestCase` methods had one or "
"more aliases that are now deprecated.  The following table lists the correct "
"names along with their deprecated aliases:"
msgstr ""

#: ../Doc/library/unittest.rst:1471
msgid "Method Name"
msgstr "Nom de méthode"

#: ../Doc/library/unittest.rst:1471
msgid "Deprecated alias"
msgstr ""

#: ../Doc/library/unittest.rst:1473
msgid ":meth:`.assertEqual`"
msgstr ":meth:`.assertEqual`"

#: ../Doc/library/unittest.rst:1473
msgid "failUnlessEqual"
msgstr "failUnlessEqual"

#: ../Doc/library/unittest.rst:1473
msgid "assertEquals"
msgstr "assertEquals"

#: ../Doc/library/unittest.rst:1474
msgid ":meth:`.assertNotEqual`"
msgstr ":meth:`.assertNotEqual`"

#: ../Doc/library/unittest.rst:1474
msgid "failIfEqual"
msgstr "failIfEqual"

#: ../Doc/library/unittest.rst:1474
msgid "assertNotEquals"
msgstr "assertNotEquals"

#: ../Doc/library/unittest.rst:1475
msgid ":meth:`.assertTrue`"
msgstr ":meth:`.assertTrue`"

#: ../Doc/library/unittest.rst:1475
msgid "failUnless"
msgstr "failUnless"

#: ../Doc/library/unittest.rst:1475
msgid "assert\\_"
msgstr "assert\\_"

#: ../Doc/library/unittest.rst:1476
msgid ":meth:`.assertFalse`"
msgstr ":meth:`.assertFalse`"

#: ../Doc/library/unittest.rst:1476
msgid "failIf"
msgstr "failIf"

#: ../Doc/library/unittest.rst:1477
msgid ":meth:`.assertRaises`"
msgstr ":meth:`.assertRaises`"

#: ../Doc/library/unittest.rst:1477
msgid "failUnlessRaises"
msgstr "failUnlessRaises"

#: ../Doc/library/unittest.rst:1478
msgid ":meth:`.assertAlmostEqual`"
msgstr ":meth:`.assertAlmostEqual`"

#: ../Doc/library/unittest.rst:1478
msgid "failUnlessAlmostEqual"
msgstr "failUnlessAlmostEqual"

#: ../Doc/library/unittest.rst:1478
msgid "assertAlmostEquals"
msgstr "assertAlmostEquals"

#: ../Doc/library/unittest.rst:1479
msgid ":meth:`.assertNotAlmostEqual`"
msgstr ":meth:`.assertNotAlmostEqual`"

#: ../Doc/library/unittest.rst:1479
msgid "failIfAlmostEqual"
msgstr "failIfAlmostEqual"

#: ../Doc/library/unittest.rst:1479
msgid "assertNotAlmostEquals"
msgstr "assertNotAlmostEquals"

#: ../Doc/library/unittest.rst:1480
msgid ":meth:`.assertRegex`"
msgstr ":meth:`.assertRegex`"

#: ../Doc/library/unittest.rst:1480
msgid "assertRegexpMatches"
msgstr "assertRegexpMatches"

#: ../Doc/library/unittest.rst:1481
msgid ":meth:`.assertNotRegex`"
msgstr ":meth:`.assertNotRegex`"

#: ../Doc/library/unittest.rst:1481
msgid "assertNotRegexpMatches"
msgstr "assertNotRegexpMatches"

#: ../Doc/library/unittest.rst:1482
msgid ":meth:`.assertRaisesRegex`"
msgstr ":meth:`.assertRaisesRegex`"

#: ../Doc/library/unittest.rst:1482
msgid "assertRaisesRegexp"
msgstr "assertRaisesRegexp"

#: ../Doc/library/unittest.rst:1485
msgid "the fail* aliases listed in the second column."
msgstr ""

#: ../Doc/library/unittest.rst:1487
msgid "the assert* aliases listed in the third column."
msgstr ""

#: ../Doc/library/unittest.rst:1489
msgid ""
"``assertRegexpMatches`` and ``assertRaisesRegexp`` have been renamed to :"
"meth:`.assertRegex` and :meth:`.assertRaisesRegex`."
msgstr ""

#: ../Doc/library/unittest.rst:1492
msgid ""
"the ``assertNotRegexpMatches`` name in favor of :meth:`.assertNotRegex`."
msgstr "``assertNotRegexpMatches`` en faveur de :meth:`.assertNotRegex`."

#: ../Doc/library/unittest.rst:1498
msgid "Grouping tests"
msgstr ""

#: ../Doc/library/unittest.rst:1502
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""

#: ../Doc/library/unittest.rst:1507
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""

#: ../Doc/library/unittest.rst:1511
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""

#: ../Doc/library/unittest.rst:1519
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr ""

#: ../Doc/library/unittest.rst:1524
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""

#: ../Doc/library/unittest.rst:1527
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""

#: ../Doc/library/unittest.rst:1530
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ""

#: ../Doc/library/unittest.rst:1535
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""

#: ../Doc/library/unittest.rst:1543
msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""

#: ../Doc/library/unittest.rst:1550
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""

#: ../Doc/library/unittest.rst:1556
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""

#: ../Doc/library/unittest.rst:1566
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`__iter__` wasn't sufficient for "
"providing tests."
msgstr ""

#: ../Doc/library/unittest.rst:1571
msgid ""
"In earlier versions the :class:`TestSuite` held references to each :class:"
"`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that behavior "
"by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""

#: ../Doc/library/unittest.rst:1576
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""

#: ../Doc/library/unittest.rst:1581
msgid "Loading and running tests"
msgstr ""

#: ../Doc/library/unittest.rst:1585
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""

#: ../Doc/library/unittest.rst:1591
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr ""

#: ../Doc/library/unittest.rst:1596
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by "
"the loader at any point. Fatal errors are signalled by the relevant a method "
"raising an exception to the caller. Non-fatal errors are also indicated by a "
"synthetic test that will raise the original error when run."
msgstr ""

#: ../Doc/library/unittest.rst:1605
msgid ":class:`TestLoader` objects have the following methods:"
msgstr ""

#: ../Doc/library/unittest.rst:1610
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""

#: ../Doc/library/unittest.rst:1613
msgid ""
"A test case instance is created for each method named by :meth:"
"`getTestCaseNames`. By default these are the method names beginning with "
"``test``. If :meth:`getTestCaseNames` returns no methods, but the :meth:"
"`runTest` method is implemented, a single test case is created for that "
"method instead."
msgstr ""

#: ../Doc/library/unittest.rst:1622
msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""

#: ../Doc/library/unittest.rst:1629
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""

#: ../Doc/library/unittest.rst:1635
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""

#: ../Doc/library/unittest.rst:1640
msgid "Support for ``load_tests`` added."
msgstr ""

#: ../Doc/library/unittest.rst:1643
msgid ""
"The undocumented and unofficial *use_load_tests* default argument is "
"deprecated and ignored, although it is still accepted for backward "
"compatibility.  The method also now accepts a keyword-only argument "
"*pattern* which is passed to ``load_tests`` as the third argument."
msgstr ""

#: ../Doc/library/unittest.rst:1652
msgid "Return a suite of all test cases given a string specifier."
msgstr ""

#: ../Doc/library/unittest.rst:1654
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""

#: ../Doc/library/unittest.rst:1662
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""

#: ../Doc/library/unittest.rst:1672
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr ""

#: ../Doc/library/unittest.rst:1674
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by self.errors."
msgstr ""

#: ../Doc/library/unittest.rst:1683
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""

#: ../Doc/library/unittest.rst:1690
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""

#: ../Doc/library/unittest.rst:1696
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""

#: ../Doc/library/unittest.rst:1702
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then the top level "
"directory must be specified separately."
msgstr ""

#: ../Doc/library/unittest.rst:1706
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""

#: ../Doc/library/unittest.rst:1711
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function "
"itself calls ``loader.discover``."
msgstr ""

#: ../Doc/library/unittest.rst:1719
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""

#: ../Doc/library/unittest.rst:1723
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves. *top_level_dir* is stored so "
"``load_tests`` does not need to pass this argument in to ``loader."
"discover()``."
msgstr ""

#: ../Doc/library/unittest.rst:1728
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr ""

#: ../Doc/library/unittest.rst:1732
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips,   not "
"errors. Discovery works for :term:`namespace packages <namespace package>`. "
"Paths are sorted before being imported so that execution order is   the same "
"even if the underlying file system's ordering is not   dependent on file "
"name."
msgstr ""

#: ../Doc/library/unittest.rst:1740
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to "
"match the default pattern."
msgstr ""

#: ../Doc/library/unittest.rst:1746
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""

#: ../Doc/library/unittest.rst:1752
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""

#: ../Doc/library/unittest.rst:1755
msgid ""
"This affects :meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` "
"methods."
msgstr ""

#: ../Doc/library/unittest.rst:1761
msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods."
msgstr ""

#: ../Doc/library/unittest.rst:1767
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""

#: ../Doc/library/unittest.rst:1771 ../Doc/library/unittest.rst:1784
msgid "This affects all the :meth:`loadTestsFrom\\*` methods."
msgstr ""

#: ../Doc/library/unittest.rst:1775
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-v`` option)."
msgstr ""

#: ../Doc/library/unittest.rst:1778
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-v`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""

#: ../Doc/library/unittest.rst:1791
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""

#: ../Doc/library/unittest.rst:1794
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""

#: ../Doc/library/unittest.rst:1799
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""

#: ../Doc/library/unittest.rst:1804
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""

#: ../Doc/library/unittest.rst:1810
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""

#: ../Doc/library/unittest.rst:1816
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :meth:`TestCase.assert\\*` methods."
msgstr ""

#: ../Doc/library/unittest.rst:1822
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""

#: ../Doc/library/unittest.rst:1829
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure of "
"the test case."
msgstr ""

#: ../Doc/library/unittest.rst:1835
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""

#: ../Doc/library/unittest.rst:1840
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr ""

#: ../Doc/library/unittest.rst:1844
msgid "The total number of tests run so far."
msgstr ""

#: ../Doc/library/unittest.rst:1848
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""

#: ../Doc/library/unittest.rst:1857
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""

#: ../Doc/library/unittest.rst:1864
msgid "If set to true then local variables will be shown in tracebacks."
msgstr ""

#: ../Doc/library/unittest.rst:1870
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""

#: ../Doc/library/unittest.rst:1873
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""

#: ../Doc/library/unittest.rst:1879
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""

#: ../Doc/library/unittest.rst:1884
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""

#: ../Doc/library/unittest.rst:1889
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""

#: ../Doc/library/unittest.rst:1897
msgid "Called when the test case *test* is about to be run."
msgstr ""

#: ../Doc/library/unittest.rst:1901
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr ""

#: ../Doc/library/unittest.rst:1906
msgid "Called once before any tests are executed."
msgstr ""

#: ../Doc/library/unittest.rst:1913
msgid "Called once after all tests are executed."
msgstr ""

#: ../Doc/library/unittest.rst:1920
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""

#: ../Doc/library/unittest.rst:1924
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""

#: ../Doc/library/unittest.rst:1931
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""

#: ../Doc/library/unittest.rst:1934
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""

#: ../Doc/library/unittest.rst:1941
msgid "Called when the test case *test* succeeds."
msgstr ""

#: ../Doc/library/unittest.rst:1943
msgid "The default implementation does nothing."
msgstr ""

#: ../Doc/library/unittest.rst:1948
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""

#: ../Doc/library/unittest.rst:1951
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""

#: ../Doc/library/unittest.rst:1957
msgid ""
"Called when the test case *test* fails, but was marked with the :func:"
"`expectedFailure` decorator."
msgstr ""

#: ../Doc/library/unittest.rst:1960
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""

#: ../Doc/library/unittest.rst:1967
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""

#: ../Doc/library/unittest.rst:1970
msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""

#: ../Doc/library/unittest.rst:1976
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""

#: ../Doc/library/unittest.rst:1980
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by :func:"
"`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""

#: ../Doc/library/unittest.rst:1984
msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr ""

#: ../Doc/library/unittest.rst:1992
msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`."
msgstr ""

#: ../Doc/library/unittest.rst:1995
msgid ""
"This class was previously named ``_TextTestResult``. The old name still "
"exists as an alias but is deprecated."
msgstr ""

#: ../Doc/library/unittest.rst:2002
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""

#: ../Doc/library/unittest.rst:2010
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""

#: ../Doc/library/unittest.rst:2017
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` and :exc:`ImportWarning` "
"even if they are :ref:`ignored by default <warning-ignored>`. Deprecation "
"warnings caused by :ref:`deprecated unittest methods <deprecated-aliases>` "
"are also special-cased and, when the warning filters are ``'default'`` or "
"``'always'``, they will appear only once per-module, in order to avoid too "
"many warning messages.  This behavior can be overridden using Python's :"
"option:`!-Wd` or :option:`!-Wa` options (see :ref:`Warning control <using-on-"
"warnings>`) and leaving *warnings* to ``None``."
msgstr ""

#: ../Doc/library/unittest.rst:2028
msgid "Added the ``warnings`` argument."
msgstr ""

#: ../Doc/library/unittest.rst:2031
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr ""

#: ../Doc/library/unittest.rst:2035
msgid "Added the tb_locals parameter."
msgstr ""

#: ../Doc/library/unittest.rst:2040
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""

#: ../Doc/library/unittest.rst:2044
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""

#: ../Doc/library/unittest.rst:2053
msgid ""
"This method is the main public interface to the `TextTestRunner`. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A :class:"
"`TestResult` is created by calling :func:`_makeResult` and the test(s) are "
"run and the results printed to stdout."
msgstr ""

#: ../Doc/library/unittest.rst:2064
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""

#: ../Doc/library/unittest.rst:2072
msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr ""

#: ../Doc/library/unittest.rst:2078
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If "
"not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""

#: ../Doc/library/unittest.rst:2083
msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""

#: ../Doc/library/unittest.rst:2087
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success or failure of the tests run."
msgstr ""

#: ../Doc/library/unittest.rst:2091
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""

#: ../Doc/library/unittest.rst:2094
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""

#: ../Doc/library/unittest.rst:2101
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""

#: ../Doc/library/unittest.rst:2104
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`!-W` option is passed to :program:`python` "
"(see :ref:`Warning control <using-on-warnings>`), otherwise it will be set "
"to ``'default'``."
msgstr ""

#: ../Doc/library/unittest.rst:2110
msgid ""
"Calling ``main`` actually returns an instance of the ``TestProgram`` class. "
"This stores the result of the tests run as the ``result`` attribute."
msgstr ""

#: ../Doc/library/unittest.rst:2113
msgid "The *exit* parameter was added."
msgstr ""

#: ../Doc/library/unittest.rst:2116
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""

#: ../Doc/library/unittest.rst:2120
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr ""

#: ../Doc/library/unittest.rst:2126
msgid "load_tests Protocol"
msgstr ""

#: ../Doc/library/unittest.rst:2130
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""

#: ../Doc/library/unittest.rst:2133
msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""

#: ../Doc/library/unittest.rst:2138
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It "
"defaults to ``None``."
msgstr ""

#: ../Doc/library/unittest.rst:2141
msgid "It should return a :class:`TestSuite`."
msgstr ""

#: ../Doc/library/unittest.rst:2143
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""

#: ../Doc/library/unittest.rst:2149
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""

#: ../Doc/library/unittest.rst:2161
msgid ""
"If discovery is started in a directory containing a package, either from the "
"command line or by calling :meth:`TestLoader.discover`, then the package :"
"file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be "
"left up to ``load_tests`` which is called with the following arguments::"
msgstr ""

#: ../Doc/library/unittest.rst:2170
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""

#: ../Doc/library/unittest.rst:2174
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""

#: ../Doc/library/unittest.rst:2185
msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr ""

#: ../Doc/library/unittest.rst:2192
msgid "Class and Module Fixtures"
msgstr ""

#: ../Doc/library/unittest.rst:2194
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""

#: ../Doc/library/unittest.rst:2199
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""

#: ../Doc/library/unittest.rst:2203
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""

#: ../Doc/library/unittest.rst:2206
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""

#: ../Doc/library/unittest.rst:2209
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""

#: ../Doc/library/unittest.rst:2216
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""

#: ../Doc/library/unittest.rst:2220
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""

#: ../Doc/library/unittest.rst:2229
msgid "setUpClass and tearDownClass"
msgstr ""

#: ../Doc/library/unittest.rst:2231
msgid "These must be implemented as class methods::"
msgstr ""

#: ../Doc/library/unittest.rst:2244
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""

#: ../Doc/library/unittest.rst:2248
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""

#: ../Doc/library/unittest.rst:2256
msgid "setUpModule and tearDownModule"
msgstr ""

#: ../Doc/library/unittest.rst:2258
msgid "These should be implemented as functions::"
msgstr ""

#: ../Doc/library/unittest.rst:2266
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""

#: ../Doc/library/unittest.rst:2273
msgid "Signal Handling"
msgstr ""

#: ../Doc/library/unittest.rst:2277
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main()`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""

#: ../Doc/library/unittest.rst:2284
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""

#: ../Doc/library/unittest.rst:2293
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""

#: ../Doc/library/unittest.rst:2298
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""

#: ../Doc/library/unittest.rst:2305
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""

#: ../Doc/library/unittest.rst:2309
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""

#: ../Doc/library/unittest.rst:2316
msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""

#: ../Doc/library/unittest.rst:2323
msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler while the test is being executed::"
msgstr ""
