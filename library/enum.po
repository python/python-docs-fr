# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-12 18:59+0200\n"
"PO-Revision-Date: 2019-07-26 19:08+0200\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Last-Translator: Antoine Wecxsteen\n"
"X-Generator: Poedit 2.0.6\n"

#: ../Doc/library/enum.rst:2
msgid ":mod:`enum` --- Support for enumerations"
msgstr ":mod:`enum` — Énumerations"

#: ../Doc/library/enum.rst:14
msgid "**Source code:** :source:`Lib/enum.py`"
msgstr "**Code source :** :source:`Lib/enum.py`"

#: ../Doc/library/enum.rst:18
msgid ""
"An enumeration is a set of symbolic names (members) bound to unique, "
"constant values.  Within an enumeration, the members can be compared by "
"identity, and the enumeration itself can be iterated over."
msgstr ""
"Une énumération est un ensemble de noms symboliques, appelés *membres*, liés "
"à des valeurs constantes et uniques. Au sein d'une énumération, les membres "
"peuvent être comparés entre eux et il est possible d'itérer sur "
"l'énumération elle-même."

#: ../Doc/library/enum.rst:24
msgid "Module Contents"
msgstr "Contenu du module"

#: ../Doc/library/enum.rst:26
msgid ""
"This module defines four enumeration classes that can be used to define "
"unique sets of names and values: :class:`Enum`, :class:`IntEnum`, :class:"
"`Flag`, and :class:`IntFlag`.  It also defines one decorator, :func:"
"`unique`, and one helper, :class:`auto`."
msgstr ""
"Ce module définit quatre classes d'énumération qui permettent de définir des "
"ensembles uniques de noms et de valeurs : :class:`Enum`, :class:`IntEnum`, :"
"class:`Flag`, et :class:`IntFlag`. Il fournit également un décorateur, :func:"
"`unique`, ainsi qu'une classe utilitaire, :class:`auto`."

#: ../Doc/library/enum.rst:33
msgid ""
"Base class for creating enumerated constants.  See section `Functional API`_ "
"for an alternate construction syntax."
msgstr ""
"Classe de base pour créer une énumération de constantes. Voir la section "
"`API par fonction`_ pour une syntaxe alternative de construction."

#: ../Doc/library/enum.rst:38
msgid ""
"Base class for creating enumerated constants that are also subclasses of :"
"class:`int`."
msgstr ""
"Classe de base pour créer une énumération de constantes qui sont également "
"des sous-classes de :class:`int`."

#: ../Doc/library/enum.rst:43
msgid ""
"Base class for creating enumerated constants that can be combined using the "
"bitwise operators without losing their :class:`IntFlag` membership. :class:"
"`IntFlag` members are also subclasses of :class:`int`."
msgstr ""
"Classe de base pour créer une énumération de constantes pouvant être "
"combinées avec des opérateurs de comparaison bit-à-bit, sans perdre leur "
"qualité de :class:`IntFlag`. Les membres de :class:`IntFlag` sont aussi des "
"sous-classes de :class:`int`."

#: ../Doc/library/enum.rst:49
msgid ""
"Base class for creating enumerated constants that can be combined using the "
"bitwise operations without losing their :class:`Flag` membership."
msgstr ""
"Classe de base pour créer une énumération de constantes pouvant être "
"combinées avec des opérateurs de comparaison bit-à-bit, sans perdre leur "
"qualité de :class:`Flag`."

#: ../Doc/library/enum.rst:54
msgid ""
"Enum class decorator that ensures only one name is bound to any one value."
msgstr ""
"Décorateur de classe qui garantit qu'une valeur ne puisse être associée qu'à "
"un seul nom."

#: ../Doc/library/enum.rst:58
msgid "Instances are replaced with an appropriate value for Enum members."
msgstr ""
"Les instances de cette classe remplacent les membres d'une *Enum* par une "
"valeur appropriée."

#: ../Doc/library/enum.rst:60
msgid "``Flag``, ``IntFlag``, ``auto``"
msgstr "``Flag``, ``IntFlag``, ``auto``"

#: ../Doc/library/enum.rst:64
msgid "Creating an Enum"
msgstr "Création d'une *Enum*"

#: ../Doc/library/enum.rst:66
msgid ""
"Enumerations are created using the :keyword:`class` syntax, which makes them "
"easy to read and write.  An alternative creation method is described in "
"`Functional API`_.  To define an enumeration, subclass :class:`Enum` as "
"follows::"
msgstr ""
"Une énumération est créée comme une :keyword:`class`, ce qui la rend facile "
"à lire et à écrire. Une autre méthode de création est décrite dans `API par "
"fonction`_. Pour définir une énumération, il faut hériter de :class:`Enum` "
"de la manière suivante : ::"

#: ../Doc/library/enum.rst:78
msgid "Enum member values"
msgstr "Valeurs des membres d'une *Enum*"

#: ../Doc/library/enum.rst:80
msgid ""
"Member values can be anything: :class:`int`, :class:`str`, etc..  If the "
"exact value is unimportant you may use :class:`auto` instances and an "
"appropriate value will be chosen for you.  Care must be taken if you mix :"
"class:`auto` with other values."
msgstr ""
"La valeur d'un membre peut être de n'importe quel type : :class:`int`, :"
"class:`str`, etc. Si la valeur exacte n'a pas d'importance, utilisez des "
"instances de :class:`auto` et une valeur appropriée sera choisie pour vous. "
"Soyez vigilant si vous mélangez :class:`auto` avec d'autres valeurs."

#: ../Doc/library/enum.rst:85
msgid "Nomenclature"
msgstr "Nomenclature"

#: ../Doc/library/enum.rst:87
msgid "The class :class:`Color` is an *enumeration* (or *enum*)"
msgstr "La classe :class:`Color` est une *énumération* (ou un *enum*)."

#: ../Doc/library/enum.rst:88
msgid ""
"The attributes :attr:`Color.RED`, :attr:`Color.GREEN`, etc., are "
"*enumeration members* (or *enum members*) and are functionally constants."
msgstr ""
"Les attributs :attr:`Color.RED`, :attr:`Color.GREEN`, etc., sont les "
"*membres de l'énumération* (ou les *membres de l'enum*) et sont "
"fonctionnellement des constantes."

#: ../Doc/library/enum.rst:90
msgid ""
"The enum members have *names* and *values* (the name of :attr:`Color.RED` is "
"``RED``, the value of :attr:`Color.BLUE` is ``3``, etc.)"
msgstr ""
"Les membres de *l'enum* ont chacun un *nom* et une *valeur* ; le nom de :"
"attr:`Color.RED` est ``RED``, la valeur de :attr:`Color.BLUE` est ``3``, etc."

#: ../Doc/library/enum.rst:96
msgid ""
"Even though we use the :keyword:`class` syntax to create Enums, Enums are "
"not normal Python classes.  See `How are Enums different?`_ for more details."
msgstr ""
"Même si on utilise la syntaxe en :keyword:`class` pour créer des "
"énumérations, les *Enums* ne sont pas des vraies classes Python. Voir `En "
"quoi les Enums sont différentes ?`_ pour plus de détails."

#: ../Doc/library/enum.rst:100
msgid "Enumeration members have human readable string representations::"
msgstr ""
"Les membres d'une énumération ont une représentation en chaîne de caractères "
"compréhensible par un humain : ::"

#: ../Doc/library/enum.rst:105
msgid "...while their ``repr`` has more information::"
msgstr "… tandis que leur ``repr`` contient plus d'informations : ::"

#: ../Doc/library/enum.rst:110
msgid "The *type* of an enumeration member is the enumeration it belongs to::"
msgstr ""
"Le *type* d'un membre est l'énumération auquel ce membre appartient : ::"

#: ../Doc/library/enum.rst:118
msgid "Enum members also have a property that contains just their item name::"
msgstr "Les membres ont également un attribut qui contient leur nom : ::"

#: ../Doc/library/enum.rst:123
msgid "Enumerations support iteration, in definition order::"
msgstr ""
"Les énumérations sont itérables, l'ordre d'itération est celui dans lequel "
"les membres sont déclarés : ::"

#: ../Doc/library/enum.rst:139
msgid ""
"Enumeration members are hashable, so they can be used in dictionaries and "
"sets::"
msgstr ""
"Les membres d'une énumération sont hachables, ils peuvent ainsi être "
"utilisés dans des dictionnaires ou des ensembles : ::"

#: ../Doc/library/enum.rst:149
msgid "Programmatic access to enumeration members and their attributes"
msgstr "Accès dynamique aux membres et à leurs attributs"

#: ../Doc/library/enum.rst:151
msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"Il est parfois utile de pouvoir accéder dynamiquement aux membres d'une "
"énumération (p. ex. dans des situations où il ne suffit pas d'utiliser "
"``Color.RED`` car la couleur précise n'est pas connue à l'écriture du "
"programme). ``Enum`` permet de tels accès : ::"

#: ../Doc/library/enum.rst:160
msgid "If you want to access enum members by *name*, use item access::"
msgstr ""
"Pour accéder aux membres par leur *nom*, utilisez l'accès par indexation : ::"

#: ../Doc/library/enum.rst:167
msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr "Pour obtenir l'attribut :attr:`name` ou :attr:`value` d'un membre : ::"

#: ../Doc/library/enum.rst:177
msgid "Duplicating enum members and values"
msgstr "Duplication de membres et de valeurs"

#: ../Doc/library/enum.rst:179
msgid "Having two enum members with the same name is invalid::"
msgstr ""
"Il n'est pas possible d'avoir deux membres du même nom dans un *enum* : ::"

#: ../Doc/library/enum.rst:189
msgid ""
"However, two enum members are allowed to have the same value.  Given two "
"members A and B with the same value (and A defined first), B is an alias to "
"A.  By-value lookup of the value of A and B will return A.  By-name lookup "
"of B will also return A::"
msgstr ""
"Cependant deux membres peuvent avoir la même valeur. Si deux membres A et B "
"ont la même valeur (et que A est défini en premier), B sera un alias de A. "
"Un accès par valeur avec la valeur commune à A et B renverra A. Un accès à B "
"par nom renverra aussi A : ::"

#: ../Doc/library/enum.rst:209
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"Il est interdit de créer un membre avec le même nom qu'un attribut déjà "
"défini (un autre membre, une méthode, etc.) ou de créer un attribut avec le "
"nom d'un membre."

#: ../Doc/library/enum.rst:215
msgid "Ensuring unique enumeration values"
msgstr "Coercition d'unicité des valeurs d'une énumération"

#: ../Doc/library/enum.rst:217
msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, the following decorator can be used to "
"ensure each value is used only once in the enumeration:"
msgstr ""
"Par défaut, les énumérations autorisent les alias de nom pour une même "
"valeur. Quand ce comportement n'est pas désiré, il faut utiliser le "
"décorateur suivant pour s'assurer que chaque valeur n'est utilisée qu'une "
"seule fois au sein de l'énumération : ::"

#: ../Doc/library/enum.rst:223
msgid ""
"A :keyword:`class` decorator specifically for enumerations.  It searches an "
"enumeration's :attr:`__members__` gathering any aliases it finds; if any are "
"found :exc:`ValueError` is raised with the details::"
msgstr ""
"Un décorateur de :keyword:`class` spécifique aux énumérations. Il examine "
"l'attribut :attr:`__members__` d'une énumération et recherche des alias ; "
"s'il en trouve, l'exception :exc:`ValueError` est levée avec des détails : ::"

#: ../Doc/library/enum.rst:241
msgid "Using automatic values"
msgstr "Valeurs automatiques"

#: ../Doc/library/enum.rst:243
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr ""
"Si la valeur exacte n'a pas d'importance, vous pouvez utiliser :class:"
"`auto` : ::"

#: ../Doc/library/enum.rst:254
msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr ""
"Les valeurs sont déterminées par :func:`_generate_next_value_`, qui peut "
"être redéfinie : ::"

#: ../Doc/library/enum.rst:272
msgid ""
"The goal of the default :meth:`_generate_next_value_` methods is to provide "
"the next :class:`int` in sequence with the last :class:`int` provided, but "
"the way it does this is an implementation detail and may change."
msgstr ""
"La méthode par défaut :meth:`_generate_next_value_` doit fournir le :class:"
"`int` suivant de la séquence en fonction du dernier :class:`int` fourni, "
"mais la séquence générée dépend de l'implémentation Python."

#: ../Doc/library/enum.rst:277
msgid "Iteration"
msgstr "Itération"

#: ../Doc/library/enum.rst:279
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr ""
"Itérer sur les membres d'une énumération ne parcourt pas les alias : ::"

#: ../Doc/library/enum.rst:284
msgid ""
"The special attribute ``__members__`` is an ordered dictionary mapping names "
"to members.  It includes all names defined in the enumeration, including the "
"aliases::"
msgstr ""
"L'attribut spécial ``__members__`` est un dictionnaire ordonné qui fait "
"correspondre les noms aux membres. Il inclut tous les noms définis dans "
"l'énumération, alias compris : ::"

#: ../Doc/library/enum.rst:296
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"L'attribut  ``__members__`` peut servir à accéder dynamiquement aux membres "
"de l'énumération. Par exemple, pour trouver tous les alias : ::"

#: ../Doc/library/enum.rst:304
msgid "Comparisons"
msgstr "Comparaisons"

#: ../Doc/library/enum.rst:306
msgid "Enumeration members are compared by identity::"
msgstr "Les membres d'une énumération sont comparés par identité : ::"

#: ../Doc/library/enum.rst:315
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"Les comparaisons d'ordre entre les valeurs d'une énumération n'existent "
"*pas* ; les membres d'un *enum* ne sont pas des entiers (voir cependant "
"`IntEnum`_ ci-dessous) : ::"

#: ../Doc/library/enum.rst:323
msgid "Equality comparisons are defined though::"
msgstr "A contrario, les comparaisons d'égalité existent : ::"

#: ../Doc/library/enum.rst:332
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr ""
"Les comparaisons avec des valeurs ne provenant pas d'énumérations sont "
"toujours fausses (ici encore, :class:`IntEnum` a été conçue pour fonctionner "
"différemment, voir ci-dessous) : ::"

#: ../Doc/library/enum.rst:341
msgid "Allowed members and attributes of enumerations"
msgstr "Membres et attributs autorisés dans une énumération"

#: ../Doc/library/enum.rst:343
msgid ""
"The examples above use integers for enumeration values.  Using integers is "
"short and handy (and provided by default by the `Functional API`_), but not "
"strictly enforced.  In the vast majority of use-cases, one doesn't care what "
"the actual value of an enumeration is.  But if the value *is* important, "
"enumerations can have arbitrary values."
msgstr ""
"Les exemples précédents utilisent des entiers pour énumérer les valeurs. "
"C'est un choix concis et pratique (et implémenté par défaut dans l' `API par "
"fonction`_), mais ce n'est pas une obligation. Dans la majorité des cas, il "
"importe peu de connaître la valeur réelle d'une énumération. Il est "
"toutefois possible de donner une valeur arbitraire aux énumérations, si "
"cette valeur est *vraiment* significative."

#: ../Doc/library/enum.rst:349
msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr ""
"Les énumérations sont des classes Python, et peuvent donc avoir des méthodes "
"et des méthodes spéciales. L'énumération suivante : ::"

#: ../Doc/library/enum.rst:369
msgid "Then::"
msgstr "amène : ::"

#: ../Doc/library/enum.rst:378
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, :meth:"
"`__add__`, etc.), descriptors (methods are also descriptors), and variable "
"names listed in :attr:`_ignore_`."
msgstr ""
"Les règles pour ce qui est autorisé sont les suivantes : les noms qui "
"commencent et finissent avec un seul tiret bas sont réservés par *enum* et "
"ne peuvent pas être utilisés ; tous les autres attributs définis dans "
"l'énumération en deviendront des membres, à l'exception des méthodes "
"spéciales (:meth:`__str__`, :meth:`__add__`, etc.), des descripteurs (les "
"méthodes sont aussi des descripteurs) et des noms de variable listés dans :"
"attr:`_ignore_`."

#: ../Doc/library/enum.rst:385
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__` "
"then whatever value(s) were given to the enum member will be passed into "
"those methods.  See `Planet`_ for an example."
msgstr ""
"Remarque : si l'énumération définit :meth:`__new__` and/or :meth:`__init__`, "
"alors la (ou les) valeur affectée au membre sera passée à ces méthodes. Voir "
"l'exemple de `Planet`_."

#: ../Doc/library/enum.rst:391
msgid "Restricted Enum subclassing"
msgstr "Restrictions sur l'héritage"

#: ../Doc/library/enum.rst:393
msgid ""
"A new :class:`Enum` class must have one base Enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"Une nouvelle classe :class:`Enum` doit avoir une classe *Enum* de base, au "
"plus un type de données concret, et autant de classes de mélange (basées "
"sur :class:`object`) que nécessaire. L'ordre de ces classes de base est le "
"suivant : ::"

#: ../Doc/library/enum.rst:400
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr ""
"Hériter d'une énumération n'est permis que si cette énumération ne définit "
"aucun membre. Le code suivant n'est pas autorisé : ::"

#: ../Doc/library/enum.rst:410
msgid "But this is allowed::"
msgstr "Mais celui-ci est correct : ::"

#: ../Doc/library/enum.rst:421
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"Autoriser l'héritage d' *enums* définissant des membres violerait des "
"invariants sur les types et les instances. D'un autre côté, il est logique "
"d'autoriser un groupe d'énumérations à partager un comportement commun (voir "
"`OrderedEnum`_ pour exemple)."

#: ../Doc/library/enum.rst:428
msgid "Pickling"
msgstr "Sérialisation"

#: ../Doc/library/enum.rst:430
msgid "Enumerations can be pickled and unpickled::"
msgstr "Les énumérations peuvent être sérialisées et dé-sérialisées : ::"

#: ../Doc/library/enum.rst:437
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"Les restrictions habituelles de sérialisation s'appliquent : les *enums* à "
"sérialiser doivent être déclarés dans l'espace de nom de haut niveau du "
"module car la dé-sérialisation nécessite que ces *enums* puissent être "
"importés depuis ce module."

#: ../Doc/library/enum.rst:443
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"Depuis la version 4 du protocole de *pickle*, il est possible de sérialiser "
"facilement des *enums* imbriqués dans d'autres classes."

#: ../Doc/library/enum.rst:446
msgid ""
"It is possible to modify how Enum members are pickled/unpickled by defining :"
"meth:`__reduce_ex__` in the enumeration class."
msgstr ""
"Redéfinir la méthode :meth:`__reduce_ex__` permet de modifier la "
"sérialisation ou la dé-sérialisation des membres d'une énumération."

#: ../Doc/library/enum.rst:451
msgid "Functional API"
msgstr "API par fonction"

#: ../Doc/library/enum.rst:453
msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ""
"La :class:`Enum` est appelable et implémente l'API par fonction suivante : ::"

#: ../Doc/library/enum.rst:465
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"La sémantique de cette API est similaire à  :class:`~collections."
"namedtuple`. Le premier argument de l'appel à :class:`Enum` est le nom de "
"l'énumération."

#: ../Doc/library/enum.rst:468
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr ""
"Le second argument est la *source* des noms des membres de l'énumération. Il "
"peut être une chaîne de caractères contenant les noms séparés par des "
"espaces, une séquence de noms, une séquence de couples clé / valeur ou une "
"correspondance (p. ex. un dictionnaire) entre noms et valeurs. Les deux "
"dernières options permettent d'affecter des valeurs arbitraires aux "
"énumérations ; les autres affectent automatiquement des entiers en "
"commençant par 1 (le paramètre ``start`` permet de changer la valeur de "
"départ). Ceci renvoie une nouvelle classe dérivée de :class:`Enum`. En "
"d'autres termes, la déclaration de :class:`Animal` ci-dessus équivaut à : ::"

#: ../Doc/library/enum.rst:484
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but enum members all evaluate to "
"``True``."
msgstr ""
"La valeur de départ par défaut est ``1`` et non ``0`` car ``0`` au sens "
"booléen vaut ``False`` alors que tous les membres d'une enum valent ``True``."

#: ../Doc/library/enum.rst:488
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in separate module, and also may not work on IronPython or Jython). "
"The solution is to specify the module name explicitly as follows::"
msgstr ""
"La sérialisation d'énumérations créées avec l'API en fonction peut être "
"source de problèmes, car celle-ci repose sur des détails d'implémentation de "
"l'affichage de la pile d'appel pour tenter de déterminer dans quel module "
"l'énumération est créée (p. ex. elle échouera avec les fonctions utilitaires "
"provenant d'un module séparé, et peut ne pas fonctionner avec IronPython ou "
"Jython). La solution consiste à préciser explicitement le nom du module "
"comme ceci : ::"

#: ../Doc/library/enum.rst:498
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"Si ``module`` n'est pas fourni et que *Enum* ne peut pas le deviner, les "
"nouveaux membres de *l' Enum* ne seront pas non-sérialisables ; pour garder "
"les erreurs au plus près de leur origine, la sérialisation sera désactivée."

#: ../Doc/library/enum.rst:502
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~definition.__qualname__` being set to the location where pickle will be "
"able to find the class.  For example, if the class was made available in "
"class SomeData in the global scope::"
msgstr ""
"Le nouveau protocole version 4 de *pickle* se base lui aussi, dans certains "
"cas, sur le fait que :attr:`~definition.__qualname__` pointe sur l'endroit "
"où *pickle* peut trouver la classe. Par exemple, si la classe était "
"disponible depuis la classe *SomeData* dans l'espace de nom de plus haut "
"niveau : ::"

#: ../Doc/library/enum.rst:509
msgid "The complete signature is::"
msgstr "La signature complète est la suivante : ::"

#: ../Doc/library/enum.rst:0
msgid "value"
msgstr "value"

#: ../Doc/library/enum.rst:513
msgid "What the new Enum class will record as its name."
msgstr "Le nom de la la nouvelle classe *Enum*."

#: ../Doc/library/enum.rst:0
msgid "names"
msgstr "names"

#: ../Doc/library/enum.rst:515
msgid ""
"The Enum members.  This can be a whitespace or comma separated string "
"(values will start at 1 unless otherwise specified)::"
msgstr ""
"Les membres de l'énumération. Une chaîne de caractères séparés par des "
"espaces ou des virgules (la valeur de départ est fixée à 1, sauf si "
"spécifiée autrement) : ::"

#: ../Doc/library/enum.rst:520
msgid "or an iterator of names::"
msgstr "ou un itérateur sur les noms : ::"

#: ../Doc/library/enum.rst:524
msgid "or an iterator of (name, value) pairs::"
msgstr "ou un itérateur sur les tuples (nom, valeur) : ::"

#: ../Doc/library/enum.rst:528
msgid "or a mapping::"
msgstr "ou une correspondance : ::"

#: ../Doc/library/enum.rst:0
msgid "module"
msgstr "module"

#: ../Doc/library/enum.rst:532
msgid "name of module where new Enum class can be found."
msgstr "nom du module dans lequel la classe *Enum* se trouve."

#: ../Doc/library/enum.rst:0
msgid "qualname"
msgstr "qualname"

#: ../Doc/library/enum.rst:534
msgid "where in module new Enum class can be found."
msgstr "localisation de la nouvelle classe *Enum* dans le module."

#: ../Doc/library/enum.rst:0
msgid "type"
msgstr "type"

#: ../Doc/library/enum.rst:536
msgid "type to mix in to new Enum class."
msgstr "le type à mélanger dans la nouvelle classe *Enum*."

#: ../Doc/library/enum.rst:0
msgid "start"
msgstr "start"

#: ../Doc/library/enum.rst:538
msgid "number to start counting at if only names are passed in."
msgstr "index de départ si uniquement des noms sont passés."

#: ../Doc/library/enum.rst:540
msgid "The *start* parameter was added."
msgstr "Ajout du paramètre *start*."

#: ../Doc/library/enum.rst:545
msgid "Derived Enumerations"
msgstr "Énumérations dérivées"

#: ../Doc/library/enum.rst:548
msgid "IntEnum"
msgstr "IntEnum"

#: ../Doc/library/enum.rst:550
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr ""
"La première version dérivée de :class:`Enum` qui existe est aussi une sous-"
"classe de :class:`int`. Les membres de :class:`IntEnum` peuvent être "
"comparés à des entiers et, par extension, les comparaisons entre des "
"énumération entières de type différent sont possibles : ::"

#: ../Doc/library/enum.rst:571
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr ""
"Elles ne peuvent cependant toujours pas être comparées à des énumérations "
"standards de :class:`Enum` : ::"

#: ../Doc/library/enum.rst:584
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ""
"Les valeurs de :class:`IntEnum` se comportent comme des entiers, comme on "
"pouvait s'y attendre : ::"

#: ../Doc/library/enum.rst:595
msgid "IntFlag"
msgstr "IntFlag"

#: ../Doc/library/enum.rst:597
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member.  However, as the name implies, :class:`IntFlag` "
"members also subclass :class:`int` and can be used wherever an :class:`int` "
"is used.  Any operation on an :class:`IntFlag` member besides the bit-wise "
"operations will lose the :class:`IntFlag` membership."
msgstr ""
"La version dérivée suivante de :class:`Enum` est :class:`IntFlag`. Elle est "
"aussi basée sur :class:`int`, à la différence près que les membres de :class:"
"`IntFlag` peuvent être combinés en utilisant les opérateurs bit-à-bit (&, "
"\\|, ^, ~) et que le résultat reste un membre de :class:`IntFlag`. "
"Cependant, comme le nom l'indique, les membres d'une classe :class:`IntFlag` "
"héritent aussi de :class:`int` et peuvent être utilisés là où un :class:"
"`int` est utilisé. Toute opération sur un membre d'une classe :class:"
"`IntFlag`, autre qu'un opérateur bit-à-bit lui fait perdre sa qualité de :"
"class:`IntFlag`."

#: ../Doc/library/enum.rst:607
msgid "Sample :class:`IntFlag` class::"
msgstr "Exemple d'une classe :class:`IntFlag` : ::"

#: ../Doc/library/enum.rst:623
msgid "It is also possible to name the combinations::"
msgstr "Il est aussi possible de nommer les combinaisons : ::"

#: ../Doc/library/enum.rst:635
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
"Une autre différence importante entre :class:`IntFlag` et :class:`Enum` est "
"que, si aucune option n'est activée (la valeur vaut 0), son évaluation "
"booléenne est :data:`False` : ::"

#: ../Doc/library/enum.rst:643
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them::"
msgstr ""
"Comme les membres d'une classe :class:`IntFlag` héritent aussi de :class:"
"`int`, ils peuvent être combinés avec eux : ::"

#: ../Doc/library/enum.rst:651
msgid "Flag"
msgstr "Option"

#: ../Doc/library/enum.rst:653
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"La dernière version dérivée est la classe :class:`Flag`.  Comme :class:"
"`IntFlag`, les membres d'une classe :class:`Flag` peuvent être combinés en "
"utilisant les opérateurs de comparaison bit-à-bit. Cependant, à la "
"différence de :class:`IntFlag`, ils ne peuvent ni être combinés, ni être "
"comparés avec une autre énumération :class:`Flag`, ni avec :class:`int`. "
"Bien qu'il soit possible de définir directement les valeurs, il est "
"recommandé d'utiliser :class:`auto` comme valeur et de laisser :class:`Flag` "
"choisir une valeur appropriée."

#: ../Doc/library/enum.rst:662
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"Comme avec :class:`IntFlag`, si une combinaison de membres d'une classe :"
"class:`Flag` n'active aucune option, l'évaluation booléenne de la "
"comparaison est :data:`False` : ::"

#: ../Doc/library/enum.rst:676
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags won't::"
msgstr ""
"Les options de base doivent avoir des puissances de deux pour valeurs (1, 2, "
"4, 8, ...) mais pas les combinaisons : ::"

#: ../Doc/library/enum.rst:688
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr ""
"Donner un nom à la valeur \"aucune option activée\" ne change pas sa valeur "
"booléenne : ::"

#: ../Doc/library/enum.rst:704
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"Dans la plupart des cas, il est fortement recommandé d'utiliser :class:"
"`Enum` and :class:`Flag` pour écrire du code nouveau, car :class:`IntEnum` "
"and :class:`IntFlag` violent certains principes sémantiques d'une "
"énumération (en pouvant être comparées à des entiers, et donc, par "
"transitivité, à d'autres énumérations). :class:`IntEnum` and :class:"
"`IntFlag` ne doivent être utilisées que dans les cas où :class:`Enum` and :"
"class:`Flag` ne suffisent pas ; par exemple quand des constantes entières "
"sont remplacées par des énumérations, ou pour l’interopérabilité avec "
"d'autres systèmes."

#: ../Doc/library/enum.rst:714
msgid "Others"
msgstr "Autres"

#: ../Doc/library/enum.rst:716
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
"Bien que :class:`IntEnum` fasse partie du module :mod:`enum`, elle serait "
"très simple à implémenter hors de ce module : ::"

#: ../Doc/library/enum.rst:722
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`StrEnum` that mixes in :class:`str` instead of :class:"
"`int`."
msgstr ""
"Ceci montre comment définir des énumérations dérivées similaires ; par "
"exemple une classe :class:`StrEnum` qui dériverait de :class:`str` au lieu "
"de :class:`int`."

#: ../Doc/library/enum.rst:725
msgid "Some rules:"
msgstr "Quelques règles :"

#: ../Doc/library/enum.rst:727
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before :class:"
"`Enum` itself in the sequence of bases, as in the :class:`IntEnum` example "
"above."
msgstr ""
"Pour hériter de :class:`Enum`, les types de mélange doivent être placés "
"avant la classe :class:`Enum` elle-même dans la liste des classes de base, "
"comme dans l'exemple de :class:`IntEnum` ci-dessus."

#: ../Doc/library/enum.rst:730
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another data type such as :class:`int` or :class:"
"`str`."
msgstr ""
"Même si une classe :class:`Enum` peut avoir des membres de n'importe quel "
"type, dès lors qu'un type de mélange est ajouté, tous les membres doivent "
"être de ce type, p. ex. :class:`int` ci-dessus. Cette restriction ne "
"s'applique pas aux types de mélange qui ne font qu'ajouter des méthodes et "
"ne définissent pas de type de données, tels :class:`int` ou :class:`str`. "

#: ../Doc/library/enum.rst:735
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr ""
"Quand un autre type de données est mélangé, l'attribut :attr:`value` n'est "
"*pas* identique au membre de l'énumération lui-même, bien qu'ils soient "
"équivalents et égaux en comparaison."

#: ../Doc/library/enum.rst:738
msgid ""
"%-style formatting:  `%s` and `%r` call the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` respectively; other codes (such as `%i` or `"
"%h` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""
"Formatage de style *%* : `%s` et `%r` appellent respectivement les méthodes :"
"meth:`__str__` et :meth:`__repr__` de la classe :class:`Enum` ; les autres "
"codes, comme `%i` ou `%h` pour *IntEnum*, s'appliquent au membre comme si "
"celui-ci était converti en son type de mélange."

#: ../Doc/library/enum.rst:741
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the mixed-in type's :meth:`__format__`.  If the :class:"
"`Enum` class's :func:`str` or :func:`repr` is desired, use the `!s` or `!r` "
"format codes."
msgstr ""
":ref:`Chaînes de caractères formatées littérales <f-strings>` : :meth:`str."
"format`, et :func:`format` appellent la méthode :meth:`__format__` du type "
"de mélange.  Pour appeler les fonctions :func:`str` ou :func:`repr` de la "
"classe :class:`Enum`, il faut utiliser les codes de formatage `!s` ou `!r`."

#: ../Doc/library/enum.rst:748
msgid "Interesting examples"
msgstr "Exemples intéressants"

#: ../Doc/library/enum.rst:750
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`IntFlag`, and :class:`Flag` "
"are expected to cover the majority of use-cases, they cannot cover them "
"all.  Here are recipes for some different types of enumerations that can be "
"used directly, or as examples for creating one's own."
msgstr ""
"Bien que :class:`Enum`, :class:`IntEnum`, :class:`IntFlag`, et :class:`Flag` "
"soient conçues pour répondre à la majorité des besoins, elles ne peuvent "
"répondre à tous. Voici quelques recettes d'énumération qui peuvent être "
"réutilisées telles quelles, ou peuvent servir d'exemple pour développer vos "
"propres énumérations."

#: ../Doc/library/enum.rst:757
msgid "Omitting values"
msgstr "Omettre les valeurs"

#: ../Doc/library/enum.rst:759
msgid ""
"In many use-cases one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr ""
"Dans de nombreux cas, la valeur réelle de l'énumération n'a pas "
"d'importance. Il y a plusieurs façons de définir ce type d'énumération "
"simple :"

#: ../Doc/library/enum.rst:762
msgid "use instances of :class:`auto` for the value"
msgstr "affecter des instances de :class:`auto` aux valeurs"

#: ../Doc/library/enum.rst:763
msgid "use instances of :class:`object` as the value"
msgstr "affecter des instances de :class:`object` aux valeurs"

#: ../Doc/library/enum.rst:764
msgid "use a descriptive string as the value"
msgstr "affecter des chaînes de caractères aux valeurs pour les décrire"

#: ../Doc/library/enum.rst:765
msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the tuple "
"with an :class:`int` value"
msgstr ""
"affecter un n-uplet aux valeurs et définir une méthode :meth:`__new__` pour "
"remplacer les n-uplets avec un :class:`int`"

#: ../Doc/library/enum.rst:768
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"Utiliser une de ces méthodes indique à l'utilisateur que les valeurs n'ont "
"pas d'importance. Cela permet aussi d'ajouter, de supprimer ou de ré-"
"ordonner les membres sans avoir à ré-énumérer les membres existants."

#: ../Doc/library/enum.rst:772
msgid ""
"Whichever method you choose, you should provide a :meth:`repr` that also "
"hides the (unimportant) value::"
msgstr ""
"Quelle que soit la méthode choisie, il faut fournir une méthode :meth:`repr` "
"qui masque les valeurs (pas importantes de toute façon) : ::"

#: ../Doc/library/enum.rst:782
msgid "Using :class:`auto`"
msgstr "Avec :class:`auto`"

#: ../Doc/library/enum.rst:784
msgid "Using :class:`auto` would look like::"
msgstr "On utilise :class:`auto` de la manière suivante : ::"

#: ../Doc/library/enum.rst:796
msgid "Using :class:`object`"
msgstr "Avec :class:`object`"

#: ../Doc/library/enum.rst:798
msgid "Using :class:`object` would look like::"
msgstr "On utilise :class:`object` de la manière suivante : ::"

#: ../Doc/library/enum.rst:810
msgid "Using a descriptive string"
msgstr "Avec une chaîne de caractères de description"

#: ../Doc/library/enum.rst:812
msgid "Using a string as the value would look like::"
msgstr "On utilise une chaîne de caractères de la manière suivante : ::"

#: ../Doc/library/enum.rst:826
msgid "Using a custom :meth:`__new__`"
msgstr "Avec une méthode ad-hoc :meth:`__new__`"

#: ../Doc/library/enum.rst:828
msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr ""
"On utilise une méthode :meth:`__new__` d'énumération de la manière "
"suivante : ::"

#: ../Doc/library/enum.rst:850
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ""
"La méthode :meth:`__new__`, si définie, est appelée à la création des "
"membres de l'énumération ; elle est ensuite remplacée par la méthode :meth:"
"`__new__` de *Enum*, qui est utilisée après la création de la classe pour la "
"recherche des membres existants."

#: ../Doc/library/enum.rst:856
msgid "OrderedEnum"
msgstr "OrderedEnum"

#: ../Doc/library/enum.rst:858
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"Une énumération ordonnée qui n'est pas basée sur :class:`IntEnum`, et qui "
"par conséquent respecte les invariants classiques de :class:`Enum` (comme "
"par exemple l'impossibilité de pouvoir être comparée à d'autres "
"énumérations) ::"

#: ../Doc/library/enum.rst:892
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../Doc/library/enum.rst:894
msgid ""
"Raises an error if a duplicate member name is found instead of creating an "
"alias::"
msgstr ""
"Lève une erreur si un membre est dupliqué, plutôt que de créer un alias : ::"

#: ../Doc/library/enum.rst:919
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"Cet exemple d'héritage de *Enum* est intéressant pour ajouter ou modifier "
"des comportements comme interdire les alias. Si vous ne souhaitez "
"qu'interdire les alias, il suffit d'utiliser le décorateur :func:`unique`."

#: ../Doc/library/enum.rst:925
msgid "Planet"
msgstr "Planet"

#: ../Doc/library/enum.rst:927
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined the value of the enum "
"member will be passed to those methods::"
msgstr ""
"Si :meth:`__new__` ou :meth:`__init__` sont définies, la valeur du membre de "
"l'énumération sera passée à ces méthodes : ::"

#: ../Doc/library/enum.rst:955
msgid "TimePeriod"
msgstr "TimePeriod"

#: ../Doc/library/enum.rst:957
msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr "Exemple d'utilisation de l'attribut :attr:`_ignore_` : ::"

#: ../Doc/library/enum.rst:974
msgid "How are Enums different?"
msgstr "En quoi les *Enums* sont différentes ?"

#: ../Doc/library/enum.rst:976
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived Enum "
"classes and their instances (members)."
msgstr ""
"Les *enums* ont une métaclasse spéciale qui affecte de nombreux aspects des "
"classes dérivées de *Enum* et de leur instances (membres)."

#: ../Doc/library/enum.rst:981
msgid "Enum Classes"
msgstr "Classes *Enum*"

#: ../Doc/library/enum.rst:983
msgid ""
"The :class:`EnumMeta` metaclass is responsible for providing the :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods that "
"allow one to do things with an :class:`Enum` class that fail on a typical "
"class, such as `list(Color)` or `some_enum_var in Color`.  :class:`EnumMeta` "
"is responsible for ensuring that various other methods on the final :class:"
"`Enum` class are correct (such as :meth:`__new__`, :meth:`__getnewargs__`, :"
"meth:`__str__` and :meth:`__repr__`)."
msgstr ""
"La métaclasse :class:`EnumMeta` se charge de fournir les méthodes :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` etc. qui permettent de "
"faire des opérations sur une classe :class:`Enum` qui ne fonctionneraient "
"pas sur une classe standard, comme `list(Color)` ou `some_enum_var in "
"Color`. :class:`EnumMeta` garantit que les autres méthodes de la classe "
"finale :class:`Enum` sont correctes (comme :meth:`__new__`, :meth:"
"`__getnewargs__`, :meth:`__str__` et :meth:`__repr__`)."

#: ../Doc/library/enum.rst:993
msgid "Enum Members (aka instances)"
msgstr "Membres d'Enum (c.-à-d. instances)"

#: ../Doc/library/enum.rst:995
msgid ""
"The most interesting thing about Enum members is that they are singletons. :"
"class:`EnumMeta` creates them all while it is creating the :class:`Enum` "
"class itself, and then puts a custom :meth:`__new__` in place to ensure that "
"no new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"Il est intéressant de souligner que les membres d'une *Enum* sont des "
"singletons.  La classe :class:`EnumMeta` les crée tous au moment de la "
"création de la classe :class:`Enum` elle-même, et implémente une méthode :"
"meth:`__new__` spécifique. Cette méthode renvoie toujours les instances de "
"membres déjà existantes pour être sûr de ne jamais en instancier de "
"nouvelles."

#: ../Doc/library/enum.rst:1003
msgid "Finer Points"
msgstr "Aspects approfondis"

#: ../Doc/library/enum.rst:1006
msgid "Supported ``__dunder__`` names"
msgstr "Noms de la forme ``__dunder__`` disponibles"

#: ../Doc/library/enum.rst:1008
msgid ""
":attr:`__members__` is an :class:`OrderedDict` of ``member_name``:``member`` "
"items.  It is only available on the class."
msgstr ""
":attr:`__members__` est une :class:`OrderedDict` de correspondances "
"``nom_du_membre`` / ``membre``. Elle n'est disponible que depuis la classe."

#: ../Doc/library/enum.rst:1011
msgid ""
":meth:`__new__`, if specified, must create and return the enum members; it "
"is also a very good idea to set the member's :attr:`_value_` appropriately.  "
"Once all the members are created it is no longer used."
msgstr ""
"La méthode :meth:`__new__`, si elle est définie, doit créer et renvoyer les "
"membres de l'énumération ; affecter correctement l'attribut :attr:`_value_` "
"du membre est également conseillé. Une fois que tous les membres ont été "
"créés, cette méthode n'est plus utilisée."

#: ../Doc/library/enum.rst:1017
msgid "Supported ``_sunder_`` names"
msgstr "Noms de la forme ``_sunder_`` disponibles"

#: ../Doc/library/enum.rst:1019
msgid "``_name_`` -- name of the member"
msgstr "``_name_`` -- nom du membre"

#: ../Doc/library/enum.rst:1020
msgid ""
"``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr ""
"``_value_`` -- valeur du membre ; il est possible d'y accéder ou de la muer "
"dans ``__new__``"

#: ../Doc/library/enum.rst:1022
msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be "
"overridden"
msgstr ""
"``_missing_`` -- une fonction de recherche qui est appelée quand la valeur "
"n'est pas trouvée ; elle peut être redéfinie"

#: ../Doc/library/enum.rst:1024
msgid ""
"``_ignore_`` -- a list of names, either as a :func:`list` or a :func:`str`, "
"that will not be transformed into members, and will be removed from the "
"final class"
msgstr ""
"``_ignore_`` -- une liste de noms, sous la forme de :func:`list` ou de :func:"
"`str`, qui ne seront pas transformés en membres, et seront supprimés de la "
"classe résultante"

#: ../Doc/library/enum.rst:1027
msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is consistent "
"(class attribute, removed during class creation)"
msgstr ""
"``_order_`` -- utilisé en Python 2 ou 3 pour s'assurer que l'ordre des "
"membres est cohérent (attribut de classe, supprimé durant la création de la "
"classe)"

#: ../Doc/library/enum.rst:1029
msgid ""
"``_generate_next_value_`` -- used by the `Functional API`_ and by :class:"
"`auto` to get an appropriate value for an enum member; may be overridden"
msgstr ""
"``_generate_next_value_`` -- utilisée par l' `API par fonction`_ et par :"
"class:`auto` pour obtenir une valeur appropriée à affecter à un membre de "
"*l'enum* ; elle peut être redéfinie"

#: ../Doc/library/enum.rst:1033
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: ../Doc/library/enum.rst:1034
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../Doc/library/enum.rst:1036
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` attribute "
"can be provided.  It will be checked against the actual order of the "
"enumeration and raise an error if the two do not match::"
msgstr ""
"Pour faciliter la transition de Python 2 en Python 3, l'attribut l'attribut :"
"attr:`_order_` peut être défini. Il sera comparé au véritable ordre de "
"l'énumération et lève une erreur si les deux ne correspondent pas : ::"

#: ../Doc/library/enum.rst:1052
msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition "
"order is lost before it can be recorded."
msgstr ""
"En Python 2, l'attribut :attr:`_order_` est indispensable car l'ordre de la "
"définition est perdu avant de pouvoir \n"
"être enregistré."

#: ../Doc/library/enum.rst:1056
msgid "``Enum`` member type"
msgstr "Type des membres de ``Enum``"

#: ../Doc/library/enum.rst:1058
msgid ""
":class:`Enum` members are instances of their :class:`Enum` class, and are "
"normally accessed as ``EnumClass.member``.  Under certain circumstances they "
"can also be accessed as ``EnumClass.member.member``, but you should never do "
"this as that lookup may fail or, worse, return something besides the :class:"
"`Enum` member you are looking for (this is another good reason to use all-"
"uppercase names for members)::"
msgstr ""
"Les membres de :class:`Enum` sont des instances de leur classe :class:"
"`Enum`. On y accède normalement par ``ClasseEnum.membre``.  Dans certains "
"cas, on peut également y accéder par ``ClasseEnum.membre.membre``, mais ceci "
"est fortement déconseillé car cette indirection est susceptible d'échouer, "
"ou pire, de ne pas renvoyer le membre de la classe :class:`Enum` désiré "
"(c'est une autre bonne raison pour définir tous les noms des membres en "
"majuscules) : ::"

#: ../Doc/library/enum.rst:1079
msgid "Boolean value of ``Enum`` classes and members"
msgstr "Valeur booléenne des classes ``Enum`` et de leurs membres"

#: ../Doc/library/enum.rst:1081
msgid ""
":class:`Enum` members that are mixed with non-:class:`Enum` types (such as :"
"class:`int`, :class:`str`, etc.) are evaluated according to the mixed-in "
"type's rules; otherwise, all members evaluate as :data:`True`.  To make your "
"own Enum's boolean evaluation depend on the member's value add the following "
"to your class::"
msgstr ""
"Les membres d'une classe :class:`Enum` mélangée avec un type non dérivé de :"
"class:`Enum` (comme :class:`int`, :class:`str`, etc.) sont évalués selon les "
"règles du type de mélange. Sinon, tous les membres valent :data:`True`. Pour "
"faire dépendre l'évaluation booléenne de votre propre *Enum* de la valeur du "
"membre, il faut ajouter le code suivant à votre classe : ::"

#: ../Doc/library/enum.rst:1090
msgid ":class:`Enum` classes always evaluate as :data:`True`."
msgstr "Les classes :class:`Enum` valent toujours :data:`True`."

#: ../Doc/library/enum.rst:1094
msgid "``Enum`` classes with methods"
msgstr "Classes ``Enum`` avec des méthodes"

#: ../Doc/library/enum.rst:1096
msgid ""
"If you give your :class:`Enum` subclass extra methods, like the `Planet`_ "
"class above, those methods will show up in a :func:`dir` of the member, but "
"not of the class::"
msgstr ""
"Si votre classe :class:`Enum` contient des méthodes supplémentaires, comme "
"la classe `Planet`_ ci-dessus, elles s'afficheront avec un appel à :func:"
"`dir` sur le membre, mais pas avec un appel sur la classe : ::"

#: ../Doc/library/enum.rst:1107
msgid "Combining members of ``Flag``"
msgstr "Combinaison de membres de ``Flag``"

#: ../Doc/library/enum.rst:1109
msgid ""
"If a combination of Flag members is not named, the :func:`repr` will include "
"all named flags and all named combinations of flags that are in the value::"
msgstr ""
"Si une valeur issue de la combinaison de membres de *Flag* n'est pas "
"associée explicitement à un membre, la fonction :func:`repr` inclut tous les "
"membres et toutes les combinaisons de membres présents dans cette valeur : ::"
