# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-23 09:57+0100\n"
"PO-Revision-Date: 2023-01-07 22:57+0100\n"
"Last-Translator: Antoine Wecxsteen\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.1\n"

#: library/enum.rst:2
msgid ":mod:`enum` --- Support for enumerations"
msgstr ":mod:`enum` — Énumérations"

#: library/enum.rst:14
msgid "**Source code:** :source:`Lib/enum.py`"
msgstr "**Code source :** :source:`Lib/enum.py`"

#: library/enum.rst:18
msgid ""
"This page contains the API reference information. For tutorial information "
"and discussion of more advanced topics, see"
msgstr ""
"Cette page contient les informations de référence de l'API. Pour des "
"informations sur le didacticiel et une discussion sur des sujets plus "
"avancés, reportez-vous à"

#: library/enum.rst:21
msgid ":ref:`Basic Tutorial <enum-basic-tutorial>`"
msgstr ":ref:`Tutoriel de base <enum-basic-tutorial>`"

#: library/enum.rst:22
msgid ":ref:`Advanced Tutorial <enum-advanced-tutorial>`"
msgstr ":ref:`Tutoriel avancé <enum-advanced-tutorial>`"

#: library/enum.rst:23
msgid ":ref:`Enum Cookbook <enum-cookbook>`"
msgstr ":ref:`Recettes pour les énumérations <enum-cookbook>`"

#: library/enum.rst:27
msgid "An enumeration:"
msgstr "Une énumération :"

#: library/enum.rst:29
msgid "is a set of symbolic names (members) bound to unique values"
msgstr ""
"est un ensemble de noms symboliques (appelés membres) liés à des valeurs "
"uniques,"

#: library/enum.rst:30
#, fuzzy
msgid ""
"can be iterated over to return its canonical (i.e. non-alias) members in "
"definition order"
msgstr ""
"peut être utilisée comme itérable et renvoie ses membres dans l'ordre de "
"définition,"

#: library/enum.rst:32
msgid "uses *call* syntax to return members by value"
msgstr "utilise la syntaxe *d'appel* pour renvoyer les valeurs de ses membres,"

#: library/enum.rst:33
msgid "uses *index* syntax to return members by name"
msgstr "utilise la syntaxe *d'indiçage* pour renvoyer les noms de ses membres."

#: library/enum.rst:35
msgid ""
"Enumerations are created either by using :keyword:`class` syntax, or by "
"using function-call syntax::"
msgstr ""
"Les énumérations sont créées soit en utilisant la syntaxe :keyword:`class`, "
"soit en utilisant la syntaxe d'appel de fonction ::"

#: library/enum.rst:49
msgid ""
"Even though we can use :keyword:`class` syntax to create Enums, Enums are "
"not normal Python classes.  See :ref:`How are Enums different? <enum-class-"
"differences>` for more details."
msgstr ""
"Même si on peut utiliser la syntaxe :keyword:`class` pour créer des "
"énumérations, les *Enums* ne sont pas des vraies classes Python. Lisez :ref:"
"`En quoi les énumérations sont-elles différentes ? <enum-class-differences>` "
"pour plus de détails."

#: library/enum.rst:53
msgid "Nomenclature"
msgstr "Nomenclature"

#: library/enum.rst:55
#, fuzzy
msgid "The class :class:`!Color` is an *enumeration* (or *enum*)"
msgstr "La classe :class:`Color` est une *énumération* (ou une *enum*)."

#: library/enum.rst:56
#, fuzzy
msgid ""
"The attributes :attr:`!Color.RED`, :attr:`!Color.GREEN`, etc., are "
"*enumeration members* (or *members*) and are functionally constants."
msgstr ""
"Les attributs :attr:`Color.RED`, :attr:`Color.GREEN`, etc., sont les "
"*membres de l'énumération* (ou *membres*) et sont fonctionnellement des "
"constantes."

#: library/enum.rst:58
#, fuzzy
msgid ""
"The enum members have *names* and *values* (the name of :attr:`!Color.RED` "
"is ``RED``, the value of :attr:`!Color.BLUE` is ``3``, etc.)"
msgstr ""
"Les membres de l’énumération ont chacun un *nom* et une *valeur* ; le nom "
"de :attr:`Color.RED` est ``RED``, la valeur de :attr:`Color.BLUE` est ``3``, "
"etc."

#: library/enum.rst:65
msgid "Module Contents"
msgstr "Contenu du module"

#: library/enum.rst:67
msgid ":class:`EnumType`"
msgstr ":class:`EnumType`"

#: library/enum.rst:69
msgid "The ``type`` for Enum and its subclasses."
msgstr "Le ``type`` d'*Enum* et de ses sous-classes."

#: library/enum.rst:71
msgid ":class:`Enum`"
msgstr ":class:`Enum`"

#: library/enum.rst:73
msgid "Base class for creating enumerated constants."
msgstr "Classe mère pour créer une énumération de constantes."

#: library/enum.rst:75
msgid ":class:`IntEnum`"
msgstr ":class:`IntEnum`"

#: library/enum.rst:77
msgid ""
"Base class for creating enumerated constants that are also subclasses of :"
"class:`int`. (`Notes`_)"
msgstr ""
"Classe mère pour créer une énumération de constantes qui sont également des "
"sous-classes de :class:`int` (`notes`_)."

#: library/enum.rst:80
msgid ":class:`StrEnum`"
msgstr ":class:`StrEnum`"

#: library/enum.rst:82
msgid ""
"Base class for creating enumerated constants that are also subclasses of :"
"class:`str`. (`Notes`_)"
msgstr ""
"Classe mère pour créer une énumération de constantes qui sont également des "
"sous-classes de :class:`str` (`notes`_)."

#: library/enum.rst:85
msgid ":class:`Flag`"
msgstr ":class:`Flag`"

#: library/enum.rst:87
msgid ""
"Base class for creating enumerated constants that can be combined using the "
"bitwise operations without losing their :class:`Flag` membership."
msgstr ""
"Classe mère pour créer une énumération de constantes pouvant être combinées "
"avec des opérateurs de comparaison bit-à-bit, sans perdre leur qualité de :"
"class:`Flag`."

#: library/enum.rst:90
msgid ":class:`IntFlag`"
msgstr ":class:`IntFlag`"

#: library/enum.rst:92
msgid ""
"Base class for creating enumerated constants that can be combined using the "
"bitwise operators without losing their :class:`IntFlag` membership. :class:"
"`IntFlag` members are also subclasses of :class:`int`. (`Notes`_)"
msgstr ""
"Classe mère pour créer une énumération de constantes pouvant être combinées "
"avec des opérateurs de comparaison bit-à-bit, sans perdre leur qualité de :"
"class:`IntFlag`. Les membres de :class:`IntFlag` sont aussi des sous-classes "
"de :class:`int` (`notes`_)."

#: library/enum.rst:96
#, fuzzy
msgid ":class:`ReprEnum`"
msgstr ":class:`Enum`"

#: library/enum.rst:98
#, fuzzy
msgid ""
"Used by :class:`IntEnum`, :class:`StrEnum`, and :class:`IntFlag` to keep "
"the :class:`str() <str>` of the mixed-in type."
msgstr ":class:`IntEnum`, :class:`StrEnum` et :class:`IntFlag`"

#: library/enum.rst:101
msgid ":class:`EnumCheck`"
msgstr ":class:`EnumCheck`"

#: library/enum.rst:103
msgid ""
"An enumeration with the values ``CONTINUOUS``, ``NAMED_FLAGS``, and "
"``UNIQUE``, for use with :func:`verify` to ensure various constraints are "
"met by a given enumeration."
msgstr ""
"Énumération avec les valeurs ``CONTINUOUS``, ``NAMED_FLAGS`` et ``UNIQUE``, "
"à utiliser avec :func:`verify` pour s'assurer que diverses contraintes sont "
"satisfaites par une énumération donnée."

#: library/enum.rst:107
msgid ":class:`FlagBoundary`"
msgstr ":class:`FlagBoundary`"

#: library/enum.rst:109
msgid ""
"An enumeration with the values ``STRICT``, ``CONFORM``, ``EJECT``, and "
"``KEEP`` which allows for more fine-grained control over how invalid values "
"are dealt with in an enumeration."
msgstr ""
"Énumération avec les valeurs ``STRICT``, ``CONFORM``, ``EJECT`` et ``KEEP`` "
"qui permet un contrôle plus précis sur la façon dont les valeurs invalides "
"sont traitées dans une énumération."

#: library/enum.rst:113
msgid ":class:`auto`"
msgstr ":class:`auto`"

#: library/enum.rst:115
msgid ""
"Instances are replaced with an appropriate value for Enum members. :class:"
"`StrEnum` defaults to the lower-cased version of the member name, while "
"other Enums default to 1 and increase from there."
msgstr ""
"Les instances sont remplacées par une valeur appropriée pour les membres de "
"l'énumération. :class:`StrEnum` utilise par défaut la version minuscule du "
"nom du membre, tandis que les autres énumérations utilisent 1 par défaut et "
"puis augmentent."

#: library/enum.rst:119
msgid ":func:`~enum.property`"
msgstr ":func:`~enum.property`"

#: library/enum.rst:121
msgid ""
"Allows :class:`Enum` members to have attributes without conflicting with "
"member names."
msgstr ""
"Permet aux membres d'une :class:`Enum` d'avoir des attributs sans entrer en "
"conflit avec les noms des membres."

#: library/enum.rst:124
msgid ":func:`unique`"
msgstr ":func:`unique`"

#: library/enum.rst:126
msgid ""
"Enum class decorator that ensures only one name is bound to any one value."
msgstr ""
"Décorateur de classe qui garantit qu'une valeur ne puisse être associée qu'à "
"un seul nom."

#: library/enum.rst:128
msgid ":func:`verify`"
msgstr ":func:`verify`"

#: library/enum.rst:130
msgid ""
"Enum class decorator that checks user-selectable constraints on an "
"enumeration."
msgstr ""
"Décorateur de classe qui vérifie des contraintes personnalisées pour une "
"énumération."

#: library/enum.rst:133
msgid ":func:`member`"
msgstr ":func:`member`"

#: library/enum.rst:135
msgid "Make ``obj`` a member.  Can be used as a decorator."
msgstr "Fait de ``obj`` un membre. Peut être utilisé comme décorateur."

#: library/enum.rst:137
msgid ":func:`nonmember`"
msgstr ":func:`nonmember`"

#: library/enum.rst:139
msgid "Do not make ``obj`` a member.  Can be used as a decorator."
msgstr ""
"Fait que ``obj`` n'est pas un membre. Peut être utilisé comme décorateur."

#: library/enum.rst:141
#, fuzzy
msgid ":func:`global_enum`"
msgstr ":func:`nonmember`"

#: library/enum.rst:143
msgid ""
"Modify the :class:`str() <str>` and :func:`repr` of an enum to show its "
"members as belonging to the module instead of its class. Should only be used "
"if the enum members will be exported to the module global namespace."
msgstr ""

#: library/enum.rst:148
msgid ":func:`show_flag_values`"
msgstr ""

#: library/enum.rst:150
msgid "Return a list of all power-of-two integers contained in a flag."
msgstr ""

#: library/enum.rst:153
msgid "``Flag``, ``IntFlag``, ``auto``"
msgstr "``Flag``, ``IntFlag``, ``auto``"

#: library/enum.rst:154
msgid ""
"``StrEnum``, ``EnumCheck``, ``ReprEnum``, ``FlagBoundary``, ``property``, "
"``member``, ``nonmember``, ``global_enum``, ``show_flag_values``"
msgstr ""

#: library/enum.rst:159
msgid "Data Types"
msgstr "Types de données"

#: library/enum.rst:164
msgid ""
"*EnumType* is the :term:`metaclass` for *enum* enumerations.  It is possible "
"to subclass *EnumType* -- see :ref:`Subclassing EnumType <enumtype-"
"examples>` for details."
msgstr ""
"*EnumType* est la :term:`métaclasse <metaclass>` pour les énumérations. Il "
"est possible de sous-classer *EnumType* ­— voir :ref:`Sous-classer EnumType "
"<enumtype-examples>` pour plus de détails."

#: library/enum.rst:168
#, fuzzy
msgid ""
"*EnumType* is responsible for setting the correct :meth:`!__repr__`, :meth:`!"
"__str__`, :meth:`!__format__`, and :meth:`!__reduce__` methods on the final "
"*enum*, as well as creating the enum members, properly handling duplicates, "
"providing iteration over the enum class, etc."
msgstr ""
"*EnumType* est chargé de définir les méthodes correctes :meth:`__repr__`, :"
"meth:`__str__`, :meth:`__format__` et :meth:`__reduce__` sur l'énumération "
"finale, ainsi que de créer les membres de l'énumération, de gérer "
"correctement les doublons, de fournir une itération sur la classe *enum*, "
"etc."

#: library/enum.rst:175
msgid "Returns ``True`` if member belongs to the ``cls``::"
msgstr "Renvoie ``True`` si le membre appartient à ``cls`` ::"

#: library/enum.rst:183
msgid ""
"In Python 3.12 it will be possible to check for member values and not just "
"members; until then, a ``TypeError`` will be raised if a non-Enum-member is "
"used in a containment check."
msgstr ""
"Dans Python 3.12, il sera possible de vérifier les valeurs des membres et "
"pas seulement les membres ; en attendant, une ``TypeError`` est levée si un "
"membre non-Enum est utilisé dans une vérification d'appartenance."

#: library/enum.rst:189
msgid ""
"Returns ``['__class__', '__doc__', '__members__', '__module__']`` and the "
"names of the members in *cls*::"
msgstr ""
"Renvoie ``['__class__', '__doc__', '__members__', '__module__']`` et les "
"noms des membres de *cls* ::"

#: library/enum.rst:197
msgid ""
"Returns the Enum member in *cls* matching *name*, or raises an :exc:"
"`AttributeError`::"
msgstr ""
"Renvoie le membre de l'énumération *cls* correspondant à *name* ou lève une :"
"exc:`AttributeError` ::"

#: library/enum.rst:204
#, fuzzy
msgid ""
"Returns the Enum member in *cls* matching *name*, or raises a :exc:"
"`KeyError`::"
msgstr ""
"Renvoie le membre de l'énumération *cls* correspondant à *name* ou lève une :"
"exc:`KeyError` ::"

#: library/enum.rst:211
msgid "Returns each member in *cls* in definition order::"
msgstr "Renvoie chaque membre de *cls* dans l'ordre de définition ::"

#: library/enum.rst:218
msgid "Returns the number of member in *cls*::"
msgstr "Renvoie le nombre de membres de *cls* ::"

#: library/enum.rst:225
msgid "Returns each member in *cls* in reverse definition order::"
msgstr "Renvoie chaque membre de *cls* dans l'ordre inverse de définition ::"

#: library/enum.rst:233
msgid "*Enum* is the base class for all *enum* enumerations."
msgstr "*Enum* est la classe mère de toutes les énumérations."

#: library/enum.rst:237
msgid "The name used to define the ``Enum`` member::"
msgstr "Le nom utilisé pour définir le membre de l'``Enum`` ::"

#: library/enum.rst:244
msgid "The value given to the ``Enum`` member::"
msgstr "La valeur attribuée au membre de l'``Enum`` ::"

#: library/enum.rst:249
msgid "Enum member values"
msgstr "Valeurs des membres d'une *Enum*"

#: library/enum.rst:251
#, fuzzy
msgid ""
"Member values can be anything: :class:`int`, :class:`str`, etc.  If the "
"exact value is unimportant you may use :class:`auto` instances and an "
"appropriate value will be chosen for you.  See :class:`auto` for the details."
msgstr ""
"La valeur d'un membre peut être de n'importe quel type : :class:`int`, :"
"class:`str`, etc. Si la valeur exacte n'a pas d'importance, utilisez des "
"instances de :class:`auto` et une valeur appropriée sera choisie pour vous. "
"Soyez vigilant si vous mélangez :class:`auto` avec d'autres valeurs."

#: library/enum.rst:258
msgid ""
"``_ignore_`` is only used during creation and is removed from the "
"enumeration once creation is complete."
msgstr ""
"``_ignore_`` n'est utilisé que lors de la création et est supprimé de "
"l'énumération une fois la création terminée."

#: library/enum.rst:261
msgid ""
"``_ignore_`` is a list of names that will not become members, and whose "
"names will also be removed from the completed enumeration.  See :ref:"
"`TimePeriod <enum-time-period>` for an example."
msgstr ""
"``_ignore_`` est une liste de noms qui ne deviendront pas membres et qui "
"seront également supprimés de l'énumération terminée. Voir :ref:`Intervalle "
"de temps <enum-time-period>` pour un exemple."

#: library/enum.rst:267
msgid "This method is called in two different ways:"
msgstr "Cette méthode peut être appelée de deux manières différentes :"

#: library/enum.rst:269
msgid "to look up an existing member:"
msgstr "pour chercher un membre existant :"

#: library/enum.rst:0
msgid "cls"
msgstr "cls"

#: library/enum.rst:276
msgid "The enum class being called."
msgstr "Classe de l'énumération concernée."

#: library/enum.rst:0
msgid "value"
msgstr "value"

#: library/enum.rst:272
msgid "The value to lookup."
msgstr "Valeur à chercher."

#: library/enum.rst:274
msgid "to use the ``cls`` enum to create a new enum:"
msgstr ""
"pour utiliser l'énumération ``cls`` afin de créer une nouvelle énumération :"

#: library/enum.rst:277
msgid "The name of the new Enum to create."
msgstr "Nom de la nouvelle énumération à créer."

#: library/enum.rst:0
msgid "names"
msgstr "names"

#: library/enum.rst:278
msgid "The names/values of the members for the new Enum."
msgstr "Couples nom-valeur des membres de la nouvelle énumération."

#: library/enum.rst:0
msgid "module"
msgstr "module"

#: library/enum.rst:279
msgid "The name of the module the new Enum is created in."
msgstr "Nom du module dans lequel la classe *Enum* se trouve."

#: library/enum.rst:0
msgid "qualname"
msgstr "qualname"

#: library/enum.rst:280
msgid "The actual location in the module where this Enum can be found."
msgstr "Position dans le module où la classe *Enum* se trouve."

#: library/enum.rst:0
msgid "type"
msgstr "type"

#: library/enum.rst:281
msgid "A mix-in type for the new Enum."
msgstr "Type à mélanger pour la nouvelle énumération."

#: library/enum.rst:0
msgid "start"
msgstr "start"

#: library/enum.rst:282
#, fuzzy
msgid "The first integer value for the Enum (used by :class:`auto`)."
msgstr "Première valeur entière de l'énumération (utilisé par  :class:`auto`)"

#: library/enum.rst:0
msgid "boundary"
msgstr "boundary"

#: library/enum.rst:283
#, fuzzy
msgid ""
"How to handle out-of-range values from bit operations (:class:`Flag` only)."
msgstr ""
"Définit la gestion les valeurs hors plage des opérations bit-à-bit (:class:"
"`Flag` uniquement)"

#: library/enum.rst:287
msgid ""
"Returns ``['__class__', '__doc__', '__module__', 'name', 'value']`` and any "
"public methods defined on *self.__class__*::"
msgstr ""
"Renvoie ``['__class__', '__doc__', '__module__', 'name', 'value']`` et "
"toutes les méthodes publiques définies pour *self.__class__* ::"

#: library/enum.rst:0
msgid "name"
msgstr "name"

#: library/enum.rst:307
msgid "The name of the member being defined (e.g. 'RED')."
msgstr "Nom du membre en cours de définition (par ex. ``RED``)."

#: library/enum.rst:308
msgid "The start value for the Enum; the default is 1."
msgstr "Valeur de départ pour l'énumération ; 1 par défaut."

#: library/enum.rst:0
msgid "count"
msgstr "count"

#: library/enum.rst:309
msgid "The number of members currently defined, not including this one."
msgstr ""
"Nombre de membres actuellement définis, le membre actuel n'étant pas inclus."

#: library/enum.rst:0
msgid "last_values"
msgstr "last_values"

#: library/enum.rst:310
msgid "A list of the previous values."
msgstr "Liste des valeurs précédentes."

#: library/enum.rst:312
msgid ""
"A *staticmethod* that is used to determine the next value returned by :class:"
"`auto`::"
msgstr ""
"Méthode statique utilisée pour déterminer la prochaine valeur à renvoyer "
"par :class:`auto` ::"

#: library/enum.rst:327
msgid ""
"A *classmethod* that is used to further configure subsequent subclasses. By "
"default, does nothing."
msgstr ""
"Méthode de classe utilisée pour personnaliser davantage les sous-classes à "
"venir. Ne fait rien par défaut."

#: library/enum.rst:332
msgid ""
"A *classmethod* for looking up values not found in *cls*.  By default it "
"does nothing, but can be overridden to implement custom search behavior::"
msgstr ""
"Méthode de classe pour chercher des valeurs non trouvées dans *cls*. Ne fait "
"rien par défaut mais peut être surchargée pour implémenter un comportement "
"personnalisé de recherche ::"

#: library/enum.rst:353
msgid ""
"Returns the string used for *repr()* calls.  By default, returns the *Enum* "
"name, member name, and value, but can be overridden::"
msgstr ""
"Renvoie la chaîne utilisée pour les appels à *repr()*. Par défaut, renvoie "
"le nom de l'énumération, le nom du membre et sa valeur, mais peut être "
"surchargée ::"

#: library/enum.rst:368
msgid ""
"Returns the string used for *str()* calls.  By default, returns the *Enum* "
"name and member name, but can be overridden::"
msgstr ""
"Renvoie la chaîne utilisée pour les appels à *str()*. Par défaut, renvoie le "
"nom *Enum* et le nom du membre, mais peut être remplacé ::"

#: library/enum.rst:382
#, fuzzy
msgid ""
"Returns the string used for *format()* and *f-string* calls.  By default, "
"returns :meth:`__str__` return value, but can be overridden::"
msgstr ""
"Renvoie la chaîne utilisée pour les appels à *format()* et *f-string*. Par "
"défaut, renvoie la valeur renvoyée par :meth:`__str__`, mais peut être "
"remplacé ::"

#: library/enum.rst:396
msgid ""
"Using :class:`auto` with :class:`Enum` results in integers of increasing "
"value, starting with ``1``."
msgstr ""
"L'utilisation de :class:`auto` avec :class:`Enum` donne des nombres entiers "
"de valeur croissante, en commençant par ``1``."

#: library/enum.rst:402
msgid ""
"*IntEnum* is the same as *Enum*, but its members are also integers and can "
"be used anywhere that an integer can be used.  If any integer operation is "
"performed with an *IntEnum* member, the resulting value loses its "
"enumeration status."
msgstr ""
"*IntEnum* est identique à *Enum*, mais ses membres sont également des "
"entiers et peuvent être utilisés partout où un entier peut être utilisé. Si "
"une opération sur un entier est effectuée avec un membre *IntEnum*, la "
"valeur résultante perd son statut de membre d'énumération."

#: library/enum.rst:422
msgid ""
"Using :class:`auto` with :class:`IntEnum` results in integers of increasing "
"value, starting with ``1``."
msgstr ""
"L'utilisation de :class:`auto` avec :class:`IntEnum` donne des entiers de "
"valeur croissante, en commençant par ``1``."

#: library/enum.rst:425
#, fuzzy
msgid ""
":meth:`~object.__str__` is now :meth:`!int.__str__` to better support the "
"*replacement of existing constants* use-case. :meth:`~object.__format__` was "
"already :meth:`!int.__format__` for that same reason."
msgstr ""
":meth:`__str__` est maintenant :func:`int.__str__` pour mieux prendre en "
"charge le cas d'utilisation du *remplacement de constantes existantes*. :"
"meth:`__format__` était déjà :func:`int.__format__` pour la même raison."

#: library/enum.rst:432
msgid ""
"*StrEnum* is the same as *Enum*, but its members are also strings and can be "
"used in most of the same places that a string can be used.  The result of "
"any string operation performed on or with a *StrEnum* member is not part of "
"the enumeration."
msgstr ""
"*StrEnum* est identique à *Enum*, mais ses membres sont également des "
"chaînes et peuvent être utilisés dans la plupart des endroits où une chaîne "
"peut être utilisée. Le résultat de toute opération de chaîne effectuée sur "
"ou avec un membre *StrEnum* ne fait pas partie de l'énumération."

#: library/enum.rst:438
#, fuzzy
msgid ""
"There are places in the stdlib that check for an exact :class:`str` instead "
"of a :class:`str` subclass (i.e. ``type(unknown) == str`` instead of "
"``isinstance(unknown, str)``), and in those locations you will need to use "
"``str(StrEnum.member)``."
msgstr ""
"Il y a des endroits dans la bibliothèque standard qui vérifient s'ils ont "
"affaire à une sous-classe :class:`str` exacte au lieu d'une sous-classe :"
"class:`str` (c'est-à-dire ``type(unknown) == str`` au lieu de "
"``isinstance(str, unknown)``) et, dans ce cas, vous devez utiliser "
"``str(StrEnum.member)``."

#: library/enum.rst:445
msgid ""
"Using :class:`auto` with :class:`StrEnum` results in the lower-cased member "
"name as the value."
msgstr ""
"L'utilisation de :class:`auto` avec :class:`StrEnum` donne le nom du membre "
"en minuscule comme valeur."

#: library/enum.rst:450
#, fuzzy
msgid ""
":meth:`~object.__str__` is :meth:`!str.__str__` to better support the "
"*replacement of existing constants* use-case.  :meth:`~object.__format__` is "
"likewise :meth:`!str.__format__` for that same reason."
msgstr ""
":meth:`__str__` est :func:`str.__str__` pour mieux prendre en charge le cas "
"d'utilisation de *remplacement de constantes existantes*. :meth:`__format__` "
"est également :func:`str.__format__` pour la même raison."

#: library/enum.rst:458
msgid ""
"*Flag* members support the bitwise operators ``&`` (*AND*), ``|`` (*OR*), "
"``^`` (*XOR*), and ``~`` (*INVERT*); the results of those operators are "
"members of the enumeration."
msgstr ""
"Les membres *Flag* prennent en charge les opérateurs bit-à-bit ``&`` (*ET*), "
"``|`` (*OU*), ``^`` (*OU EXCLUSIF*) et ``~`` (*NON*) ; les résultats de ces "
"opérations sont membres de l'énumération."

#: library/enum.rst:464
msgid "Returns *True* if value is in self::"
msgstr "Renvoie *True* si la valeur est dans *self* ::"

#: library/enum.rst:484
#, fuzzy
msgid "Returns all contained non-alias members::"
msgstr "Renvoie tous les membres ::"

#: library/enum.rst:493
msgid "Aliases are no longer returned during iteration."
msgstr ""

#: library/enum.rst:497
msgid "Returns number of members in flag::"
msgstr "Renvoie le nombre de membres de *Flag* ::"

#: library/enum.rst:506
msgid "Returns *True* if any members in flag, *False* otherwise::"
msgstr ""
"Renvoie *True* s'il y a un membre dans les bits de *Flag*, *False* sinon ::"

#: library/enum.rst:518
msgid "Returns current flag binary or'ed with other::"
msgstr "Renvoie le *OU* logique entre le membre et *other* ::"

#: library/enum.rst:525
msgid "Returns current flag binary and'ed with other::"
msgstr "Renvoie le *ET* logique entre le membre et *other* ::"

#: library/enum.rst:534
msgid "Returns current flag binary xor'ed with other::"
msgstr "Renvoie le *OU Exclusif* logique entre le membre et *other* ::"

#: library/enum.rst:543
msgid "Returns all the flags in *type(self)* that are not in self::"
msgstr ""
"Renvoie tous les membres de *type(self)* qui ne sont pas dans *self* "
"(opération logique sur les bits) ::"

#: library/enum.rst:554
msgid ""
"Function used to format any remaining unnamed numeric values.  Default is "
"the value's repr; common choices are :func:`hex` and :func:`oct`."
msgstr ""
"Fonction utilisée pour formater toutes les valeurs numériques sans nom "
"restantes. La valeur par défaut est la représentation de la valeur ; les "
"choix courants sont :func:`hex` et :func:`oct`."

#: library/enum.rst:559
msgid ""
"Using :class:`auto` with :class:`Flag` results in integers that are powers "
"of two, starting with ``1``."
msgstr ""
"L'utilisation de :class:`auto` avec :class:`Flag` donne des entiers qui sont "
"des puissances de deux, en commençant par ``1``."

#: library/enum.rst:562
msgid "The *repr()* of zero-valued flags has changed.  It is now::"
msgstr "La *repr()* des membres de valeur zéro a changé. C'est maintenant ::"

#: library/enum.rst:570
msgid ""
"*IntFlag* is the same as *Flag*, but its members are also integers and can "
"be used anywhere that an integer can be used."
msgstr ""
"*IntFlag* est identique à *Flag*, mais ses membres sont également des "
"entiers et peuvent être utilisés partout où un entier peut être utilisé."

#: library/enum.rst:583
msgid ""
"If any integer operation is performed with an *IntFlag* member, the result "
"is not an *IntFlag*::"
msgstr ""
"Si une opération sur un entier est effectuée avec un membre d'un *IntFlag*, "
"le résultat n'est pas un *IntFlag* ::"

#: library/enum.rst:589
msgid "If a *Flag* operation is performed with an *IntFlag* member and:"
msgstr "Si une opération *Flag* est effectuée avec un membre *IntFlag* et :"

#: library/enum.rst:591
msgid "the result is a valid *IntFlag*: an *IntFlag* is returned"
msgstr "le résultat est un *IntFlag* valide : un *IntFlag* est renvoyé ;"

#: library/enum.rst:592
msgid ""
"the result is not a valid *IntFlag*: the result depends on the "
"*FlagBoundary* setting"
msgstr ""
"le résultat n'est pas un *IntFlag* valide : le résultat dépend du paramètre "
"*FlagBoundary*."

#: library/enum.rst:594
msgid "The *repr()* of unnamed zero-valued flags has changed.  It is now:"
msgstr ""
"La *repr()* des *intflag* sans nom à valeur nulle a changé. C'est "
"maintenant :"

#: library/enum.rst:601
msgid ""
"Using :class:`auto` with :class:`IntFlag` results in integers that are "
"powers of two, starting with ``1``."
msgstr ""
"L'utilisation de :class:`auto` avec :class:`IntFlag` donne des entiers qui "
"sont des puissances de deux, en commençant par ``1``."

#: library/enum.rst:606
#, fuzzy
msgid ""
":meth:`~object.__str__` is now :meth:`!int.__str__` to better support the "
"*replacement of existing constants* use-case.  :meth:`~object.__format__` "
"was already :meth:`!int.__format__` for that same reason."
msgstr ""
":meth:`__str__` est maintenant :func:`int.__str__` pour mieux prendre en "
"charge le cas d'utilisation du *remplacement de constantes existantes*. :"
"meth:`__format__` était déjà :func:`int.__format__` pour la même raison."

#: library/enum.rst:610
msgid ""
"Inversion of an :class:`!IntFlag` now returns a positive value that is the "
"union of all flags not in the given flag, rather than a negative value. This "
"matches the existing :class:`Flag` behavior."
msgstr ""

#: library/enum.rst:616
#, fuzzy
msgid ""
":class:`!ReprEnum` uses the :meth:`repr() <Enum.__repr__>` of :class:`Enum`, "
"but the :class:`str() <str>` of the mixed-in data type:"
msgstr ":class:`IntEnum`, :class:`StrEnum` et :class:`IntFlag` :"

#: library/enum.rst:619
#, fuzzy
msgid ":meth:`!int.__str__` for :class:`IntEnum` and :class:`IntFlag`"
msgstr ":class:`IntEnum`, :class:`StrEnum` et :class:`IntFlag`"

#: library/enum.rst:620
msgid ":meth:`!str.__str__` for :class:`StrEnum`"
msgstr ""

#: library/enum.rst:622
msgid ""
"Inherit from :class:`!ReprEnum` to keep the :class:`str() <str>` / :func:"
"`format` of the mixed-in data type instead of using the :class:`Enum`-"
"default :meth:`str() <Enum.__str__>`."
msgstr ""

#: library/enum.rst:631
msgid ""
"*EnumCheck* contains the options used by the :func:`verify` decorator to "
"ensure various constraints; failed constraints result in a :exc:`ValueError`."
msgstr ""
"*EnumCheck* contient les options utilisées par le décorateur :func:`verify` "
"pour assurer diverses contraintes ; si une contrainte n'est pas validée, "
"une :exc:`ValueError` est levée."

#: library/enum.rst:636
msgid "Ensure that each value has only one name::"
msgstr "Assure que chaque valeur n'a qu'un seul nom ::"

#: library/enum.rst:652
msgid ""
"Ensure that there are no missing values between the lowest-valued member and "
"the highest-valued member::"
msgstr ""
"Assure qu'il n'y a pas de valeurs manquantes entre le membre ayant la valeur "
"la plus faible et le membre ayant la valeur la plus élevée ::"

#: library/enum.rst:667
#, fuzzy
msgid ""
"Ensure that any flag groups/masks contain only named flags -- useful when "
"values are specified instead of being generated by :func:`auto`::"
msgstr ""
"Assure que tous les groupes/masques sont possibles en n'utilisant que des "
"membres nommés — utile lorsque des valeurs sont spécifiées au lieu d'être "
"générées par :func:`auto` ::"

#: library/enum.rst:684
msgid ""
"CONTINUOUS and NAMED_FLAGS are designed to work with integer-valued members."
msgstr ""
"CONTINUOUS et NAMED_FLAGS sont conçus pour fonctionner avec des membres à "
"valeur entière."

#: library/enum.rst:690
msgid ""
"*FlagBoundary* controls how out-of-range values are handled in *Flag* and "
"its subclasses."
msgstr ""
"*FlagBoundary* contrôle la façon dont les valeurs hors plage sont gérées "
"dans *Flag* et ses sous-classes."

#: library/enum.rst:695
msgid ""
"Out-of-range values cause a :exc:`ValueError` to be raised.  This is the "
"default for :class:`Flag`::"
msgstr ""
"Les valeurs hors plage provoquent la levée d'une :exc:`ValueError`. C'est la "
"valeur par défaut pour :class:`Flag` ::"

#: library/enum.rst:712
msgid ""
"Out-of-range values have invalid values removed, leaving a valid *Flag* "
"value::"
msgstr ""
"Les valeurs hors plage, invalides, sont supprimées laissant une valeur "
"*Flag* valide ::"

#: library/enum.rst:725
msgid ""
"Out-of-range values lose their *Flag* membership and revert to :class:`int`. "
"This is the default for :class:`IntFlag`::"
msgstr ""
"Les valeurs hors plage perdent leur appartenance à *Flag* et reviennent à :"
"class:`int`. C'est la valeur par défaut pour :class:`IntFlag` ::"

#: library/enum.rst:738
msgid ""
"Out-of-range values are kept, and the *Flag* membership is kept.  This is "
"used for some stdlib flags:"
msgstr ""
"Les valeurs hors plage sont conservées et l'appartenance *Flag* est "
"conservée. C'est utilisé pour certains drapeaux de la bibliothèque standard :"

#: library/enum.rst:754
msgid "Supported ``__dunder__`` names"
msgstr "Noms de la forme ``__dunder__`` disponibles"

#: library/enum.rst:756
#, fuzzy
msgid ""
":attr:`~EnumType.__members__` is a read-only ordered mapping of "
"``member_name``:``member`` items.  It is only available on the class."
msgstr ""
":attr:`__members__` est un dictionnaire en lecture seule ordonné d'éléments "
"``nom_du_membre`` : ``membre``. Il n'est disponible que depuis la classe."

#: library/enum.rst:759
#, fuzzy
msgid ""
":meth:`~object.__new__`, if specified, must create and return the enum "
"members; it is also a very good idea to set the member's :attr:`!_value_` "
"appropriately.  Once all the members are created it is no longer used."
msgstr ""
"La méthode :meth:`__new__`, si elle est définie, doit créer et renvoyer les "
"membres de l'énumération ; affecter correctement l'attribut :attr:`_value_` "
"du membre est également conseillé. Une fois que tous les membres ont été "
"créés, cette méthode n'est plus utilisée."

#: library/enum.rst:765
msgid "Supported ``_sunder_`` names"
msgstr "Noms de la forme ``_sunder_`` disponibles"

#: library/enum.rst:767
msgid "``_name_`` -- name of the member"
msgstr "``_name_`` — nom du membre"

#: library/enum.rst:768
msgid ""
"``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr ""
"``_value_`` — valeur du membre ; il est possible d'y accéder et de la "
"modifier dans ``__new__``"

#: library/enum.rst:770
msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be "
"overridden"
msgstr ""
"``_missing_`` — fonction de recherche appelée quand la valeur n'est pas "
"trouvée ; elle peut être redéfinie"

#: library/enum.rst:772
msgid ""
"``_ignore_`` -- a list of names, either as a :class:`list` or a :class:"
"`str`, that will not be transformed into members, and will be removed from "
"the final class"
msgstr ""
"``_ignore_`` — liste de noms, sous la forme d'une :func:`list` ou d'une :"
"func:`str`, qui ne sont pas convertis en membres et sont supprimés de la "
"classe résultante"

#: library/enum.rst:775
msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is consistent "
"(class attribute, removed during class creation)"
msgstr ""
"``_order_`` — utilisée en Python 2 ou 3 pour s'assurer que l'ordre des "
"membres est cohérent dans les différentes versions de Python (attribut de "
"classe, supprimé durant la création de la classe)"

#: library/enum.rst:777
msgid ""
"``_generate_next_value_`` -- used to get an appropriate value for an enum "
"member; may be overridden"
msgstr ""
"``_generate_next_value_`` — utilisée pour obtenir une valeur appropriée à "
"affecter à un membre de l’énumération ; elle peut être redéfinie"

#: library/enum.rst:782
msgid ""
"For standard :class:`Enum` classes the next value chosen is the last value "
"seen incremented by one."
msgstr ""
"Pour les classes standard :class:`Enum`, la valeur suivante choisie est la "
"dernière valeur vue incrémentée de un."

#: library/enum.rst:785
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two, regardless of the last value seen."
msgstr ""
"Pour les classes :class:`Flag`, la valeur suivante choisie est la puissance "
"de deux la plus élevée suivante, quelle que soit la dernière valeur vue."

#: library/enum.rst:788
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: library/enum.rst:789
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: library/enum.rst:794
msgid "Utilities and Decorators"
msgstr "Utilitaires et décorateurs"

#: library/enum.rst:798
#, fuzzy
msgid ""
"*auto* can be used in place of a value.  If used, the *Enum* machinery will "
"call an *Enum*'s :meth:`~Enum._generate_next_value_` to get an appropriate "
"value. For *Enum* and *IntEnum* that appropriate value will be the last "
"value plus one; for *Flag* and *IntFlag* it will be the first power-of-two "
"greater than the highest value; for *StrEnum* it will be the lower-cased "
"version of the member's name.  Care must be taken if mixing *auto()* with "
"manually specified values."
msgstr ""
"*auto* peut être utilisée à la place d'une valeur. Si elle est utilisée, le "
"fonctionnement interne d'*Enum* appelle :meth:`_generate_next_value_` pour "
"obtenir une valeur appropriée. Pour *Enum* et *IntEnum*, cette valeur "
"appropriée est la dernière valeur plus un ; pour *Flag* et *IntFlag*, c'est "
"la première puissance de deux supérieure à la plus grande valeur ; pour "
"*StrEnum*, c'est le nom du membre en minuscules."

#: library/enum.rst:806
msgid ""
"*auto* instances are only resolved when at the top level of an assignment:"
msgstr ""

#: library/enum.rst:808
msgid "``FIRST = auto()`` will work (auto() is replaced with ``1``);"
msgstr ""

#: library/enum.rst:809
msgid ""
"``SECOND = auto(), -2`` will work (auto is replaced with ``2``, so ``2, -2`` "
"is"
msgstr ""

#: library/enum.rst:810
#, fuzzy
msgid "used to create the ``SECOND`` enum member;"
msgstr "Le nom utilisé pour définir le membre de l'``Enum`` ::"

#: library/enum.rst:811
msgid ""
"``THREE = [auto(), -3]`` will *not* work (``<auto instance>, -3`` is used to "
"create the ``THREE`` enum member)"
msgstr ""

#: library/enum.rst:816
msgid ""
"In prior versions, ``auto()`` had to be the only thing on the assignment "
"line to work properly."
msgstr ""

#: library/enum.rst:819
msgid ""
"``_generate_next_value_`` can be overridden to customize the values used by "
"*auto*."
msgstr ""
"``_generate_next_value_`` peut être surchargée pour personnaliser les "
"valeurs produites par *auto*."

#: library/enum.rst:822
msgid ""
"in 3.13 the default ``_generate_next_value_`` will always return the highest "
"member value incremented by 1, and will fail if any member is an "
"incompatible type."
msgstr ""

#: library/enum.rst:828
msgid ""
"A decorator similar to the built-in *property*, but specifically for "
"enumerations.  It allows member attributes to have the same names as members "
"themselves."
msgstr ""
"Décorateur similaire au *property* natif, mais spécifique aux énumérations. "
"Il permet aux attributs de membre d'avoir les mêmes noms que les membres eux-"
"mêmes."

#: library/enum.rst:832
msgid ""
"the *property* and the member must be defined in separate classes; for "
"example, the *value* and *name* attributes are defined in the *Enum* class, "
"and *Enum* subclasses can define members with the names ``value`` and "
"``name``."
msgstr ""
"*property* et le membre doivent être définis dans des classes distinctes ; "
"par exemple, les attributs *value* et *name* sont définis dans la classe "
"*Enum*, et les sous-classes d'*Enum* peuvent définir des membres avec les "
"noms ``value`` et ``name``."

#: library/enum.rst:841
#, fuzzy
msgid ""
"A :keyword:`class` decorator specifically for enumerations.  It searches an "
"enumeration's :attr:`~EnumType.__members__`, gathering any aliases it finds; "
"if any are found :exc:`ValueError` is raised with the details::"
msgstr ""
"Décorateur de :keyword:`classe <class>` spécifique aux énumérations. Il "
"examine l'attribut :attr:`__members__` d'une énumération et recherche des "
"synonymes ; s'il en trouve, l'exception :exc:`ValueError` est levée avec des "
"détails ::"

#: library/enum.rst:859
msgid ""
"A :keyword:`class` decorator specifically for enumerations.  Members from :"
"class:`EnumCheck` are used to specify which constraints should be checked on "
"the decorated enumeration."
msgstr ""
"Décorateur de :keyword:`classe <class>` spécifique aux énumérations. Utilisé "
"pour spécifier quelles contraintes doivent être vérifiées par les membres de "
"l':class:`EnumCheck` décorée."

#: library/enum.rst:867
msgid "A decorator for use in enums: its target will become a member."
msgstr ""
"Décorateur à utiliser dans les énumérations : sa cible devient un membre."

#: library/enum.rst:873
msgid "A decorator for use in enums: its target will not become a member."
msgstr ""
"Décorateur à utiliser dans les énumérations : sa cible ne devient pas un "
"membre."

#: library/enum.rst:879
msgid ""
"A decorator to change the :class:`str() <str>` and :func:`repr` of an enum "
"to show its members as belonging to the module instead of its class. Should "
"only be used when the enum members are exported to the module global "
"namespace (see :class:`re.RegexFlag` for an example)."
msgstr ""

#: library/enum.rst:889
msgid "Return a list of all power-of-two integers contained in a flag *value*."
msgstr ""

#: library/enum.rst:896
msgid "Notes"
msgstr "Notes"

#: library/enum.rst:898
msgid ":class:`IntEnum`, :class:`StrEnum`, and :class:`IntFlag`"
msgstr ":class:`IntEnum`, :class:`StrEnum` et :class:`IntFlag`"

#: library/enum.rst:900
msgid ""
"These three enum types are designed to be drop-in replacements for existing "
"integer- and string-based values; as such, they have extra limitations:"
msgstr ""
"Ces trois types d'énumération sont conçus pour remplacer directement les "
"valeurs existantes basées sur des entiers et des chaînes ; en tant que tels, "
"ils ont des limitations supplémentaires :"

#: library/enum.rst:903
msgid "``__str__`` uses the value and not the name of the enum member"
msgstr "``__str__`` utilise la valeur et pas le nom du membre de l'énumération"

#: library/enum.rst:905
msgid ""
"``__format__``, because it uses ``__str__``, will also use the value of the "
"enum member instead of its name"
msgstr ""
"``__format__``, parce qu'elle fait appel à ``__str__``, utilise également la "
"valeur du membre de l'énumération au lieu de son nom"

#: library/enum.rst:908
msgid ""
"If you do not need/want those limitations, you can either create your own "
"base class by mixing in the ``int`` or ``str`` type yourself::"
msgstr ""
"Si ces limitations ne vous conviennent pas, vous pouvez créer votre propre "
"classe mère en mélangeant vous-même le type ``int`` ou ``str`` ::"

#: library/enum.rst:915
msgid "or you can reassign the appropriate :meth:`str`, etc., in your enum::"
msgstr ""
"ou vous pouvez réassigner la :meth:`str` appropriée, etc., dans votre "
"énumération ::"

#~ msgid ""
#~ ":meth:`__str__` is now :func:`int.__str__` to better support the "
#~ "*replacement of existing constants* use-case. :meth:`__format__` was "
#~ "already :func:`int.__format__` for that same reason."
#~ msgstr ""
#~ ":meth:`__str__` est maintenant :func:`int.__str__` pour mieux prendre en "
#~ "charge le cas d'utilisation du *remplacement de constantes existantes*. :"
#~ "meth:`__format__` était déjà :func:`int.__format__` pour la même raison."

#~ msgid "``StrEnum``, ``EnumCheck``, ``FlagBoundary``, ``property``"
#~ msgstr "``StrEnum``, ``EnumCheck``, ``FlagBoundary``, ``property``"

#~ msgid "``member``, ``nonmember``"
#~ msgstr "``member``, ``nonmember``"

#~ msgid ""
#~ "An enumeration is a set of symbolic names (members) bound to unique, "
#~ "constant values.  Within an enumeration, the members can be compared by "
#~ "identity, and the enumeration itself can be iterated over."
#~ msgstr ""
#~ "Une énumération est un ensemble de noms symboliques, appelés *membres*, "
#~ "liés à des valeurs constantes et uniques. Au sein d'une énumération, les "
#~ "membres peuvent être comparés et il est possible d'itérer sur "
#~ "l'énumération elle-même."

#~ msgid "Case of Enum Members"
#~ msgstr "Convention de nommage pour les membres d'une **Enum**"

#~ msgid ""
#~ "Because Enums are used to represent constants we recommend using "
#~ "UPPER_CASE names for enum members, and will be using that style in our "
#~ "examples."
#~ msgstr ""
#~ "Puisque les **Enums** sont utilisées pour représenter des constantes, il "
#~ "est recommandé d'utiliser des majuscules (format "
#~ "``MAJUSCULE_AVEC_SOULIGNÉS``) pour leurs membres. Cette convention de "
#~ "style sera utilisée dans les exemples."

#~ msgid ""
#~ "This module defines four enumeration classes that can be used to define "
#~ "unique sets of names and values: :class:`Enum`, :class:`IntEnum`, :class:"
#~ "`Flag`, and :class:`IntFlag`.  It also defines one decorator, :func:"
#~ "`unique`, and one helper, :class:`auto`."
#~ msgstr ""
#~ "Ce module définit quatre classes d'énumération qui permettent de définir "
#~ "des ensembles uniques de noms et de valeurs : :class:`Enum`, :class:"
#~ "`IntEnum`, :class:`Flag` et :class:`IntFlag`. Il fournit également un "
#~ "décorateur, :func:`unique`, ainsi qu'une classe utilitaire, :class:`auto`."

#~ msgid ""
#~ "Base class for creating enumerated constants.  See section `Functional "
#~ "API`_ for an alternate construction syntax."
#~ msgstr ""
#~ "Classe de base pour créer une énumération de constantes. Voir la section "
#~ "`API par fonction`_ pour une syntaxe alternative de construction."

#~ msgid "Creating an Enum"
#~ msgstr "Création d'une *Enum*"

#~ msgid ""
#~ "Enumerations are created using the :keyword:`class` syntax, which makes "
#~ "them easy to read and write.  An alternative creation method is described "
#~ "in `Functional API`_.  To define an enumeration, subclass :class:`Enum` "
#~ "as follows::"
#~ msgstr ""
#~ "Une énumération est créée comme une :keyword:`class`, ce qui la rend "
#~ "facile à lire et à écrire. Une autre méthode de création est décrite dans "
#~ "`API par fonction`_. Pour définir une énumération, il faut hériter de :"
#~ "class:`Enum` de la manière suivante ::"

#~ msgid "Enumeration members have human readable string representations::"
#~ msgstr ""
#~ "Les membres d'une énumération ont une représentation en chaîne de "
#~ "caractères compréhensible par un humain ::"

#~ msgid "...while their ``repr`` has more information::"
#~ msgstr "… tandis que leur ``repr`` contient plus d'informations ::"

#~ msgid ""
#~ "The *type* of an enumeration member is the enumeration it belongs to::"
#~ msgstr ""
#~ "Le *type* d'un membre est l'énumération auquel ce membre appartient ::"

#~ msgid ""
#~ "Enum members also have a property that contains just their item name::"
#~ msgstr "Les membres ont également un attribut qui contient leur nom ::"

#~ msgid ""
#~ "Enumeration members are hashable, so they can be used in dictionaries and "
#~ "sets::"
#~ msgstr ""
#~ "Les membres d'une énumération sont hachables, ils peuvent ainsi être "
#~ "utilisés dans des dictionnaires ou des ensembles ::"

#~ msgid "Programmatic access to enumeration members and their attributes"
#~ msgstr "Accès dynamique aux membres et à leurs attributs"

#~ msgid ""
#~ "Sometimes it's useful to access members in enumerations programmatically "
#~ "(i.e. situations where ``Color.RED`` won't do because the exact color is "
#~ "not known at program-writing time).  ``Enum`` allows such access::"
#~ msgstr ""
#~ "Il est parfois utile de pouvoir accéder dynamiquement aux membres d'une "
#~ "énumération (p. ex. dans des situations où il ne suffit pas d'utiliser "
#~ "``Color.RED`` car la couleur précise n'est pas connue à l'écriture du "
#~ "programme). ``Enum`` permet de tels accès ::"

#~ msgid "If you want to access enum members by *name*, use item access::"
#~ msgstr ""
#~ "Pour accéder aux membres par leur *nom*, utilisez l'accès par "
#~ "indexation ::"

#~ msgid ""
#~ "If you have an enum member and need its :attr:`name` or :attr:`value`::"
#~ msgstr ""
#~ "Pour obtenir l'attribut :attr:`name` ou :attr:`value` d'un membre ::"

#~ msgid "Duplicating enum members and values"
#~ msgstr "Duplication de membres et de valeurs"

#~ msgid "Having two enum members with the same name is invalid::"
#~ msgstr ""
#~ "Il n'est pas possible d'avoir deux membres du même nom dans un *enum* ::"

#~ msgid ""
#~ "However, two enum members are allowed to have the same value.  Given two "
#~ "members A and B with the same value (and A defined first), B is an alias "
#~ "to A.  By-value lookup of the value of A and B will return A.  By-name "
#~ "lookup of B will also return A::"
#~ msgstr ""
#~ "Cependant deux membres peuvent avoir la même valeur. Si deux membres A et "
#~ "B ont la même valeur (et que A est défini en premier), B sera un alias de "
#~ "A. Un accès par valeur avec la valeur commune à A et B renverra A. Un "
#~ "accès à B par nom renverra aussi A ::"

#~ msgid ""
#~ "Attempting to create a member with the same name as an already defined "
#~ "attribute (another member, a method, etc.) or attempting to create an "
#~ "attribute with the same name as a member is not allowed."
#~ msgstr ""
#~ "Il est interdit de créer un membre avec le même nom qu'un attribut déjà "
#~ "défini (un autre membre, une méthode, etc.) ou de créer un attribut avec "
#~ "le nom d'un membre."

#~ msgid "Ensuring unique enumeration values"
#~ msgstr "Coercition d'unicité des valeurs d'une énumération"

#~ msgid ""
#~ "By default, enumerations allow multiple names as aliases for the same "
#~ "value. When this behavior isn't desired, the following decorator can be "
#~ "used to ensure each value is used only once in the enumeration:"
#~ msgstr ""
#~ "Par défaut, les énumérations autorisent les alias de nom pour une même "
#~ "valeur. Quand ce comportement n'est pas désiré, il faut utiliser le "
#~ "décorateur suivant pour s'assurer que chaque valeur n'est utilisée qu'une "
#~ "seule fois au sein de l'énumération :"

#~ msgid "Using automatic values"
#~ msgstr "Valeurs automatiques"

#~ msgid "If the exact value is unimportant you can use :class:`auto`::"
#~ msgstr ""
#~ "Si la valeur exacte n'a pas d'importance, vous pouvez utiliser :class:"
#~ "`auto` ::"

#~ msgid ""
#~ "The values are chosen by :func:`_generate_next_value_`, which can be "
#~ "overridden::"
#~ msgstr ""
#~ "Les valeurs sont déterminées par :func:`_generate_next_value_`, qui peut "
#~ "être redéfinie ::"

#~ msgid ""
#~ "The goal of the default :meth:`_generate_next_value_` method is to "
#~ "provide the next :class:`int` in sequence with the last :class:`int` "
#~ "provided, but the way it does this is an implementation detail and may "
#~ "change."
#~ msgstr ""
#~ "La méthode :meth:`_generate_next_value_` doit renvoyer le prochain :class:"
#~ "`int` de la séquence à partir du dernier :class:`int` fourni, mais "
#~ "l'implémentation de cette fonction peut changer."

#~ msgid ""
#~ "The :meth:`_generate_next_value_` method must be defined before any "
#~ "members."
#~ msgstr ""
#~ "La méthode :meth:`_generate_next_value_` doit être définie avant tout "
#~ "membre."

#~ msgid "Iteration"
#~ msgstr "Itération"

#~ msgid "Iterating over the members of an enum does not provide the aliases::"
#~ msgstr ""
#~ "Itérer sur les membres d'une énumération ne parcourt pas les alias ::"

#~ msgid ""
#~ "The special attribute ``__members__`` is a read-only ordered mapping of "
#~ "names to members.  It includes all names defined in the enumeration, "
#~ "including the aliases::"
#~ msgstr ""
#~ "L'attribut spécial ``__members__`` est un dictionnaire en lecture seule "
#~ "ordonné qui fait correspondre les noms aux membres. Il inclut tous les "
#~ "noms définis dans l'énumération, alias compris ::"

#~ msgid ""
#~ "The ``__members__`` attribute can be used for detailed programmatic "
#~ "access to the enumeration members.  For example, finding all the aliases::"
#~ msgstr ""
#~ "L'attribut ``__members__`` peut servir à accéder dynamiquement aux "
#~ "membres de l'énumération. Par exemple, pour trouver tous les alias ::"

#~ msgid "Comparisons"
#~ msgstr "Comparaisons"

#~ msgid "Enumeration members are compared by identity::"
#~ msgstr "Les membres d'une énumération sont comparés par identité ::"

#~ msgid ""
#~ "Ordered comparisons between enumeration values are *not* supported.  Enum "
#~ "members are not integers (but see `IntEnum`_ below)::"
#~ msgstr ""
#~ "Les comparaisons d'ordre entre les valeurs d'une énumération n'existent "
#~ "*pas* ; les membres d'un *enum* ne sont pas des entiers (voir cependant "
#~ "`IntEnum`_ ci-dessous) ::"

#~ msgid "Equality comparisons are defined though::"
#~ msgstr "A contrario, les comparaisons d'égalité existent ::"

#~ msgid ""
#~ "Comparisons against non-enumeration values will always compare not equal "
#~ "(again, :class:`IntEnum` was explicitly designed to behave differently, "
#~ "see below)::"
#~ msgstr ""
#~ "Les comparaisons avec des valeurs ne provenant pas d'énumérations sont "
#~ "toujours fausses (ici encore, :class:`IntEnum` a été conçue pour "
#~ "fonctionner différemment, voir ci-dessous) ::"

#~ msgid "Allowed members and attributes of enumerations"
#~ msgstr "Membres et attributs autorisés dans une énumération"

#~ msgid ""
#~ "The examples above use integers for enumeration values.  Using integers "
#~ "is short and handy (and provided by default by the `Functional API`_), "
#~ "but not strictly enforced.  In the vast majority of use-cases, one "
#~ "doesn't care what the actual value of an enumeration is.  But if the "
#~ "value *is* important, enumerations can have arbitrary values."
#~ msgstr ""
#~ "Les exemples précédents utilisent des entiers pour énumérer les valeurs. "
#~ "C'est un choix concis et pratique (et implémenté par défaut dans l'`API "
#~ "par fonction`_), mais ce n'est pas une obligation. Dans la majorité des "
#~ "cas, il importe peu de connaître la valeur réelle d'une énumération. Il "
#~ "est toutefois possible de donner une valeur arbitraire aux énumérations, "
#~ "si cette valeur est *vraiment* significative."

#~ msgid ""
#~ "Enumerations are Python classes, and can have methods and special methods "
#~ "as usual.  If we have this enumeration::"
#~ msgstr ""
#~ "Les énumérations sont des classes Python et peuvent donc avoir des "
#~ "méthodes et des méthodes spéciales. L'énumération suivante ::"

#~ msgid "Then::"
#~ msgstr "Amène ::"

#~ msgid ""
#~ "The rules for what is allowed are as follows: names that start and end "
#~ "with a single underscore are reserved by enum and cannot be used; all "
#~ "other attributes defined within an enumeration will become members of "
#~ "this enumeration, with the exception of special methods (:meth:"
#~ "`__str__`, :meth:`__add__`, etc.), descriptors (methods are also "
#~ "descriptors), and variable names listed in :attr:`_ignore_`."
#~ msgstr ""
#~ "Les règles pour ce qui est autorisé sont les suivantes : les noms qui "
#~ "commencent et finissent avec un seul tiret bas sont réservés par *enum* "
#~ "et ne peuvent pas être utilisés ; tous les autres attributs définis dans "
#~ "l'énumération en deviendront des membres, à l'exception des méthodes "
#~ "spéciales (:meth:`__str__`, :meth:`__add__`, etc.), des descripteurs (les "
#~ "méthodes sont aussi des descripteurs) et des noms de variable listés "
#~ "dans :attr:`_ignore_`."

#~ msgid ""
#~ "Note:  if your enumeration defines :meth:`__new__` and/or :meth:"
#~ "`__init__` then any value(s) given to the enum member will be passed into "
#~ "those methods. See `Planet`_ for an example."
#~ msgstr ""
#~ "Remarque : si votre énumération définit :meth:`__new__` ou :meth:"
#~ "`__init__`, alors les valeurs affectées aux membres seront passées à ces "
#~ "méthodes. Voir `Planet`_ pour exemple."

#~ msgid "Restricted Enum subclassing"
#~ msgstr "Restrictions sur l'héritage"

#~ msgid ""
#~ "A new :class:`Enum` class must have one base Enum class, up to one "
#~ "concrete data type, and as many :class:`object`-based mixin classes as "
#~ "needed.  The order of these base classes is::"
#~ msgstr ""
#~ "Une nouvelle classe :class:`Enum` doit avoir une classe *Enum* de base, "
#~ "au plus un type de données concret et autant de classes de mélange "
#~ "(basées sur :class:`object`) que nécessaire. L'ordre de ces classes de "
#~ "base est le suivant ::"

#~ msgid ""
#~ "Also, subclassing an enumeration is allowed only if the enumeration does "
#~ "not define any members.  So this is forbidden::"
#~ msgstr ""
#~ "Hériter d'une énumération n'est permis que si cette énumération ne "
#~ "définit aucun membre. Le code suivant n'est pas autorisé ::"

#~ msgid "But this is allowed::"
#~ msgstr "Mais celui-ci est correct ::"

#~ msgid ""
#~ "Allowing subclassing of enums that define members would lead to a "
#~ "violation of some important invariants of types and instances.  On the "
#~ "other hand, it makes sense to allow sharing some common behavior between "
#~ "a group of enumerations. (See `OrderedEnum`_ for an example.)"
#~ msgstr ""
#~ "Autoriser l'héritage d'*enums* définissant des membres violerait des "
#~ "invariants sur les types et les instances. D'un autre côté, il est "
#~ "logique d'autoriser un groupe d'énumérations à partager un comportement "
#~ "commun (voir par exemple `OrderedEnum`_)."

#~ msgid "Pickling"
#~ msgstr "Sérialisation"

#~ msgid "Enumerations can be pickled and unpickled::"
#~ msgstr "Les énumérations peuvent être sérialisées et déserialisées ::"

#~ msgid ""
#~ "The usual restrictions for pickling apply: picklable enums must be "
#~ "defined in the top level of a module, since unpickling requires them to "
#~ "be importable from that module."
#~ msgstr ""
#~ "Les restrictions habituelles de sérialisation s'appliquent : les *enums* "
#~ "à sérialiser doivent être déclarés dans l'espace de nom de haut niveau du "
#~ "module, car la déserialisation nécessite que ces *enums* puissent être "
#~ "importés depuis ce module."

#~ msgid ""
#~ "With pickle protocol version 4 it is possible to easily pickle enums "
#~ "nested in other classes."
#~ msgstr ""
#~ "Depuis la version 4 du protocole de *pickle*, il est possible de "
#~ "sérialiser facilement des *enums* imbriqués dans d'autres classes."

#~ msgid ""
#~ "It is possible to modify how Enum members are pickled/unpickled by "
#~ "defining :meth:`__reduce_ex__` in the enumeration class."
#~ msgstr ""
#~ "Redéfinir la méthode :meth:`__reduce_ex__` permet de modifier la "
#~ "sérialisation ou la dé-sérialisation des membres d'une énumération."

#~ msgid "Functional API"
#~ msgstr "API par fonction"

#~ msgid ""
#~ "The :class:`Enum` class is callable, providing the following functional "
#~ "API::"
#~ msgstr ""
#~ "La :class:`Enum` est appelable et implémente l'API par fonction "
#~ "suivante ::"

#~ msgid ""
#~ "The semantics of this API resemble :class:`~collections.namedtuple`. The "
#~ "first argument of the call to :class:`Enum` is the name of the "
#~ "enumeration."
#~ msgstr ""
#~ "La sémantique de cette API est similaire à :class:`~collections."
#~ "namedtuple`. Le premier argument de l'appel à :class:`Enum` est le nom de "
#~ "l'énumération."

#~ msgid ""
#~ "The second argument is the *source* of enumeration member names.  It can "
#~ "be a whitespace-separated string of names, a sequence of names, a "
#~ "sequence of 2-tuples with key/value pairs, or a mapping (e.g. dictionary) "
#~ "of names to values.  The last two options enable assigning arbitrary "
#~ "values to enumerations; the others auto-assign increasing integers "
#~ "starting with 1 (use the ``start`` parameter to specify a different "
#~ "starting value).  A new class derived from :class:`Enum` is returned.  In "
#~ "other words, the above assignment to :class:`Animal` is equivalent to::"
#~ msgstr ""
#~ "Le second argument est la *source* des noms des membres de l'énumération. "
#~ "Il peut être une chaîne de caractères contenant les noms séparés par des "
#~ "espaces, une séquence de noms, une séquence de couples clé / valeur ou un "
#~ "dictionnaire (p. ex. un *dict*) de valeurs indexées par des noms. Les "
#~ "deux dernières options permettent d'affecter des valeurs arbitraires aux "
#~ "énumérations ; les autres affectent automatiquement des entiers en "
#~ "commençant par 1 (le paramètre ``start`` permet de changer la valeur de "
#~ "départ). Ceci renvoie une nouvelle classe dérivée de :class:`Enum`. En "
#~ "d'autres termes, la déclaration de :class:`Animal` ci-dessus équivaut à ::"

#~ msgid ""
#~ "The reason for defaulting to ``1`` as the starting number and not ``0`` "
#~ "is that ``0`` is ``False`` in a boolean sense, but enum members all "
#~ "evaluate to ``True``."
#~ msgstr ""
#~ "La valeur de départ par défaut est ``1`` et non ``0`` car ``0`` au sens "
#~ "booléen vaut ``False`` alors que tous les membres d'une *enum* valent "
#~ "``True``."

#~ msgid ""
#~ "Pickling enums created with the functional API can be tricky as frame "
#~ "stack implementation details are used to try and figure out which module "
#~ "the enumeration is being created in (e.g. it will fail if you use a "
#~ "utility function in separate module, and also may not work on IronPython "
#~ "or Jython). The solution is to specify the module name explicitly as "
#~ "follows::"
#~ msgstr ""
#~ "La sérialisation d'énumérations créées avec l'API en fonction peut être "
#~ "source de problèmes, car celle-ci repose sur des détails d'implémentation "
#~ "de l'affichage de la pile d'appel pour tenter de déterminer dans quel "
#~ "module l'énumération est créée (p. ex. elle échouera avec les fonctions "
#~ "utilitaires provenant d'un module séparé et peut ne pas fonctionner avec "
#~ "IronPython ou Jython). La solution consiste à préciser explicitement le "
#~ "nom du module comme ceci ::"

#~ msgid ""
#~ "If ``module`` is not supplied, and Enum cannot determine what it is, the "
#~ "new Enum members will not be unpicklable; to keep errors closer to the "
#~ "source, pickling will be disabled."
#~ msgstr ""
#~ "Si ``module`` n'est pas fourni et que *Enum* ne peut pas le deviner, les "
#~ "nouveaux membres de *l'Enum* ne seront pas déserialisables ; pour garder "
#~ "les erreurs au plus près de leur origine, la sérialisation sera "
#~ "désactivée."

#~ msgid ""
#~ "The new pickle protocol 4 also, in some circumstances, relies on :attr:"
#~ "`~definition.__qualname__` being set to the location where pickle will be "
#~ "able to find the class.  For example, if the class was made available in "
#~ "class SomeData in the global scope::"
#~ msgstr ""
#~ "Le nouveau protocole version 4 de *pickle* se base lui aussi, dans "
#~ "certains cas, sur le fait que :attr:`~definition.__qualname__` pointe sur "
#~ "l'endroit où *pickle* peut trouver la classe. Par exemple, si la classe "
#~ "était disponible depuis la classe *SomeData* dans l'espace de nom de plus "
#~ "haut niveau ::"

#~ msgid "The complete signature is::"
#~ msgstr "La signature complète est la suivante ::"

#~ msgid "What the new Enum class will record as its name."
#~ msgstr "Le nom de la la nouvelle classe *Enum*."

#~ msgid ""
#~ "The Enum members.  This can be a whitespace or comma separated string "
#~ "(values will start at 1 unless otherwise specified)::"
#~ msgstr ""
#~ "Les membres de l'énumération. Une chaîne de caractères séparés par des "
#~ "espaces ou des virgules (la valeur de départ est fixée à 1, sauf si "
#~ "spécifiée autrement) ::"

#~ msgid "or an iterator of names::"
#~ msgstr "ou un itérateur sur les noms ::"

#~ msgid "or an iterator of (name, value) pairs::"
#~ msgstr "ou un itérateur sur les *n*-uplets (nom, valeur) ::"

#~ msgid "or a mapping::"
#~ msgstr "ou une correspondance ::"

#~ msgid "where in module new Enum class can be found."
#~ msgstr "localisation de la nouvelle classe *Enum* dans le module."

#~ msgid "type to mix in to new Enum class."
#~ msgstr "le type à mélanger dans la nouvelle classe *Enum*."

#~ msgid "number to start counting at if only names are passed in."
#~ msgstr "index de départ si uniquement des noms sont passés."

#~ msgid "The *start* parameter was added."
#~ msgstr "Ajout du paramètre *start*."

#~ msgid ""
#~ "The first variation of :class:`Enum` that is provided is also a subclass "
#~ "of :class:`int`.  Members of an :class:`IntEnum` can be compared to "
#~ "integers; by extension, integer enumerations of different types can also "
#~ "be compared to each other::"
#~ msgstr ""
#~ "La première version dérivée de :class:`Enum` qui existe est aussi une "
#~ "sous-classe de :class:`int`. Les membres de :class:`IntEnum` peuvent être "
#~ "comparés à des entiers et, par extension, les comparaisons entre des "
#~ "énumérations entières de type différent sont possibles ::"

#~ msgid ""
#~ "However, they still can't be compared to standard :class:`Enum` "
#~ "enumerations::"
#~ msgstr ""
#~ "Elles ne peuvent cependant toujours pas être comparées à des énumérations "
#~ "standards de :class:`Enum` ::"

#~ msgid ""
#~ ":class:`IntEnum` values behave like integers in other ways you'd expect::"
#~ msgstr ""
#~ "Les valeurs de :class:`IntEnum` se comportent comme des entiers, comme on "
#~ "pouvait s'y attendre ::"

#~ msgid "IntFlag"
#~ msgstr "IntFlag"

#~ msgid ""
#~ "The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
#~ "based on :class:`int`.  The difference being :class:`IntFlag` members can "
#~ "be combined using the bitwise operators (&, \\|, ^, ~) and the result is "
#~ "still an :class:`IntFlag` member.  However, as the name implies, :class:"
#~ "`IntFlag` members also subclass :class:`int` and can be used wherever an :"
#~ "class:`int` is used.  Any operation on an :class:`IntFlag` member besides "
#~ "the bit-wise operations will lose the :class:`IntFlag` membership."
#~ msgstr ""
#~ "La version dérivée suivante de :class:`Enum` est :class:`IntFlag`. Elle "
#~ "est aussi basée sur :class:`int`, à la différence près que les membres "
#~ "de :class:`IntFlag` peuvent être combinés en utilisant les opérateurs bit-"
#~ "à-bit (&, \\|, ^, ~) et que le résultat reste un membre de :class:"
#~ "`IntFlag`. Cependant, comme le nom l'indique, les membres d'une classe :"
#~ "class:`IntFlag` héritent aussi de :class:`int` et peuvent être utilisés "
#~ "là où un :class:`int` est utilisé. Toute opération sur un membre d'une "
#~ "classe :class:`IntFlag`, autre qu'un opérateur bit-à-bit lui fait perdre "
#~ "sa qualité de :class:`IntFlag`."

#~ msgid "It is also possible to name the combinations::"
#~ msgstr "Il est aussi possible de nommer les combinaisons ::"

#~ msgid ""
#~ "Another important difference between :class:`IntFlag` and :class:`Enum` "
#~ "is that if no flags are set (the value is 0), its boolean evaluation is :"
#~ "data:`False`::"
#~ msgstr ""
#~ "Une autre différence importante entre :class:`IntFlag` et :class:`Enum` "
#~ "est que, si aucune option n'est activée (la valeur vaut 0), son "
#~ "évaluation booléenne est :data:`False` ::"

#~ msgid ""
#~ "Because :class:`IntFlag` members are also subclasses of :class:`int` they "
#~ "can be combined with them::"
#~ msgstr ""
#~ "Comme les membres d'une classe :class:`IntFlag` héritent aussi de :class:"
#~ "`int`, ils peuvent être combinés avec eux ::"

#~ msgid "Flag"
#~ msgstr "Option"

#~ msgid ""
#~ "The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:"
#~ "`Flag` members can be combined using the bitwise operators (&, \\|, ^, "
#~ "~).  Unlike :class:`IntFlag`, they cannot be combined with, nor compared "
#~ "against, any other :class:`Flag` enumeration, nor :class:`int`.  While it "
#~ "is possible to specify the values directly it is recommended to use :"
#~ "class:`auto` as the value and let :class:`Flag` select an appropriate "
#~ "value."
#~ msgstr ""
#~ "La dernière version dérivée est la classe :class:`Flag`.  Comme :class:"
#~ "`IntFlag`, les membres d'une classe :class:`Flag` peuvent être combinés "
#~ "en utilisant les opérateurs de comparaison bit-à-bit. Cependant, à la "
#~ "différence de :class:`IntFlag`, ils ne peuvent ni être combinés, ni être "
#~ "comparés avec une autre énumération :class:`Flag`, ni avec :class:`int`. "
#~ "Bien qu'il soit possible de définir directement les valeurs, il est "
#~ "recommandé d'utiliser :class:`auto` comme valeur et de laisser :class:"
#~ "`Flag` choisir une valeur appropriée."

#~ msgid ""
#~ "Like :class:`IntFlag`, if a combination of :class:`Flag` members results "
#~ "in no flags being set, the boolean evaluation is :data:`False`::"
#~ msgstr ""
#~ "Comme avec :class:`IntFlag`, si une combinaison de membres d'une classe :"
#~ "class:`Flag` n'active aucune option, l'évaluation booléenne de la "
#~ "comparaison est :data:`False` ::"

#~ msgid ""
#~ "Individual flags should have values that are powers of two (1, 2, 4, "
#~ "8, ...), while combinations of flags won't::"
#~ msgstr ""
#~ "Les options de base doivent avoir des puissances de deux pour valeurs (1, "
#~ "2, 4, 8, ...) mais pas les combinaisons ::"

#~ msgid ""
#~ "Giving a name to the \"no flags set\" condition does not change its "
#~ "boolean value::"
#~ msgstr ""
#~ "Donner un nom à la valeur « aucune option activée » ne change pas sa "
#~ "valeur booléenne ::"

#~ msgid ""
#~ "For the majority of new code, :class:`Enum` and :class:`Flag` are "
#~ "strongly recommended, since :class:`IntEnum` and :class:`IntFlag` break "
#~ "some semantic promises of an enumeration (by being comparable to "
#~ "integers, and thus by transitivity to other unrelated enumerations).  :"
#~ "class:`IntEnum` and :class:`IntFlag` should be used only in cases where :"
#~ "class:`Enum` and :class:`Flag` will not do; for example, when integer "
#~ "constants are replaced with enumerations, or for interoperability with "
#~ "other systems."
#~ msgstr ""
#~ "Dans la plupart des cas, il est fortement recommandé d'utiliser :class:"
#~ "`Enum` et :class:`Flag` pour écrire du code nouveau, car :class:`IntEnum` "
#~ "et :class:`IntFlag` violent certains principes sémantiques d'une "
#~ "énumération (en pouvant être comparées à des entiers et donc, par "
#~ "transitivité, à d'autres énumérations). :class:`IntEnum` et :class:"
#~ "`IntFlag` ne doivent être utilisées que dans les cas où :class:`Enum` et :"
#~ "class:`Flag` ne suffisent pas ; par exemple quand des constantes entières "
#~ "sont remplacées par des énumérations, ou pour l’interopérabilité avec "
#~ "d'autres systèmes."

#~ msgid "Others"
#~ msgstr "Autres"

#~ msgid ""
#~ "While :class:`IntEnum` is part of the :mod:`enum` module, it would be "
#~ "very simple to implement independently::"
#~ msgstr ""
#~ "Bien que :class:`IntEnum` fasse partie du module :mod:`enum`, elle serait "
#~ "très simple à implémenter hors de ce module ::"

#~ msgid ""
#~ "This demonstrates how similar derived enumerations can be defined; for "
#~ "example a :class:`StrEnum` that mixes in :class:`str` instead of :class:"
#~ "`int`."
#~ msgstr ""
#~ "Ceci montre comment définir des énumérations dérivées similaires ; par "
#~ "exemple une classe :class:`StrEnum` qui dériverait de :class:`str` au "
#~ "lieu de :class:`int`."

#~ msgid "Some rules:"
#~ msgstr "Quelques règles :"

#~ msgid ""
#~ "When subclassing :class:`Enum`, mix-in types must appear before :class:"
#~ "`Enum` itself in the sequence of bases, as in the :class:`IntEnum` "
#~ "example above."
#~ msgstr ""
#~ "Pour hériter de :class:`Enum`, les types de mélange doivent être placés "
#~ "avant la classe :class:`Enum` elle-même dans la liste des classes de "
#~ "base, comme dans l'exemple de :class:`IntEnum` ci-dessus."

#~ msgid ""
#~ "While :class:`Enum` can have members of any type, once you mix in an "
#~ "additional type, all the members must have values of that type, e.g. :"
#~ "class:`int` above.  This restriction does not apply to mix-ins which only "
#~ "add methods and don't specify another type."
#~ msgstr ""
#~ "Même si une classe :class:`Enum` peut avoir des membres de n'importe quel "
#~ "type, dès qu'un type est spécifié à la déclaration de la classe, alors "
#~ "tous les membres doivent être de ce type, p. ex. :class:`int` ci-dessus. "
#~ "Cette restriction ne s'applique pas aux classes dérivées qui n'ajoutent "
#~ "que des méthodes supplémentaires sans spécifier un type de données."

#~ msgid ""
#~ "When another data type is mixed in, the :attr:`value` attribute is *not "
#~ "the same* as the enum member itself, although it is equivalent and will "
#~ "compare equal."
#~ msgstr ""
#~ "Quand un autre type de données est mélangé, l'attribut :attr:`value` "
#~ "n'est *pas* identique au membre de l'énumération lui-même, bien qu'ils "
#~ "soient équivalents et égaux en comparaison."

#~ msgid ""
#~ "%-style formatting:  `%s` and `%r` call the :class:`Enum` class's :meth:"
#~ "`__str__` and :meth:`__repr__` respectively; other codes (such as `%i` or "
#~ "`%h` for IntEnum) treat the enum member as its mixed-in type."
#~ msgstr ""
#~ "Formatage de style *%* : `%s` et `%r` appellent respectivement les "
#~ "méthodes :meth:`__str__` et :meth:`__repr__` de la classe :class:`Enum` ; "
#~ "les autres codes, comme `%i` ou `%h` pour *IntEnum*, s'appliquent au "
#~ "membre comme si celui-ci était converti en son type de mélange."

#~ msgid ""
#~ ":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :"
#~ "func:`format` will use the mixed-in type's :meth:`__format__` unless :"
#~ "meth:`__str__` or :meth:`__format__` is overridden in the subclass, in "
#~ "which case the overridden methods or :class:`Enum` methods will be used. "
#~ "Use the !s and !r format codes to force usage of the :class:`Enum` "
#~ "class's :meth:`__str__` and :meth:`__repr__` methods."
#~ msgstr ""
#~ "Les :ref:`chaînes littérales formatées <f-strings>` : :meth:`str.format` "
#~ "et :func:`format` appellent la méthode :meth:`__format__` du type dérivé "
#~ "à moins que :meth:`__str__` ou :meth:`__format__` soit surchargée dans la "
#~ "sous-classe, auquel cas les méthodes surchargées ou celles de la classe :"
#~ "class:`Enum`  seront utilisées. Pour appeler les méthodes :meth:`__str__` "
#~ "ou :meth:`__repr__` de la classe :class:`Enum`, il faut utiliser les "
#~ "codes de formatage ``!s`` ou ``!r``."

#~ msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
#~ msgstr "Quand utiliser :meth:`__new__` ou :meth:`__init__`"

#~ msgid ""
#~ ":meth:`__new__` must be used whenever you want to customize the actual "
#~ "value of the :class:`Enum` member.  Any other modifications may go in "
#~ "either :meth:`__new__` or :meth:`__init__`, with :meth:`__init__` being "
#~ "preferred."
#~ msgstr ""
#~ ":meth:`__new__` doit être utilisé dès que vous souhaitez personnaliser la "
#~ "valeur effective des membres d'un :class:`Enum`. Tout autre modification "
#~ "peut autant aller dans :meth:`__new__` que dans :meth:`__init__`, mais "
#~ "l'usage de :meth:`__init__` est recommandé."

#~ msgid ""
#~ "For example, if you want to pass several items to the constructor, but "
#~ "only want one of them to be the value::"
#~ msgstr ""
#~ "Par exemple, si vous voulez passer plusieurs éléments au constructeur, "
#~ "mais qu'un seul d'entre eux soit la valeur ::"

#~ msgid "Interesting examples"
#~ msgstr "Exemples intéressants"

#~ msgid ""
#~ "While :class:`Enum`, :class:`IntEnum`, :class:`IntFlag`, and :class:"
#~ "`Flag` are expected to cover the majority of use-cases, they cannot cover "
#~ "them all.  Here are recipes for some different types of enumerations that "
#~ "can be used directly, or as examples for creating one's own."
#~ msgstr ""
#~ "Bien que :class:`Enum`, :class:`IntEnum`, :class:`IntFlag` et :class:"
#~ "`Flag` soient conçues pour répondre à la majorité des besoins, elles ne "
#~ "peuvent répondre à tous. Voici quelques recettes d'énumération qui "
#~ "peuvent être réutilisées telles quelles, ou peuvent servir d'exemple pour "
#~ "développer vos propres énumérations."

#~ msgid "Omitting values"
#~ msgstr "Omettre les valeurs"

#~ msgid ""
#~ "In many use-cases one doesn't care what the actual value of an "
#~ "enumeration is. There are several ways to define this type of simple "
#~ "enumeration:"
#~ msgstr ""
#~ "Dans de nombreux cas, la valeur réelle de l'énumération n'a pas "
#~ "d'importance. Il y a plusieurs façons de définir ce type d'énumération "
#~ "simple :"

#~ msgid "use instances of :class:`auto` for the value"
#~ msgstr "affecter des instances de :class:`auto` aux valeurs"

#~ msgid "use instances of :class:`object` as the value"
#~ msgstr "affecter des instances de :class:`object` aux valeurs"

#~ msgid "use a descriptive string as the value"
#~ msgstr "affecter des chaînes de caractères aux valeurs pour les décrire"

#~ msgid ""
#~ "use a tuple as the value and a custom :meth:`__new__` to replace the "
#~ "tuple with an :class:`int` value"
#~ msgstr ""
#~ "affecter un *n*-uplet aux valeurs et définir une méthode :meth:`__new__` "
#~ "pour remplacer les *n*-uplets avec un :class:`int`"

#~ msgid ""
#~ "Using any of these methods signifies to the user that these values are "
#~ "not important, and also enables one to add, remove, or reorder members "
#~ "without having to renumber the remaining members."
#~ msgstr ""
#~ "Utiliser une de ces méthodes indique à l'utilisateur que les valeurs "
#~ "n'ont pas d'importance. Cela permet aussi d'ajouter, de supprimer ou de "
#~ "ré-ordonner les membres sans avoir à ré-énumérer les membres existants."

#~ msgid ""
#~ "Whichever method you choose, you should provide a :meth:`repr` that also "
#~ "hides the (unimportant) value::"
#~ msgstr ""
#~ "Quelle que soit la méthode choisie, il faut fournir une méthode :meth:"
#~ "`repr` qui masque les valeurs (pas importantes de toute façon) ::"

#~ msgid "Using :class:`auto` would look like::"
#~ msgstr "On utilise :class:`auto` de la manière suivante ::"

#~ msgid "Using :class:`object`"
#~ msgstr "Avec :class:`object`"

#~ msgid "Using :class:`object` would look like::"
#~ msgstr "On utilise :class:`object` de la manière suivante ::"

#~ msgid "Using a descriptive string"
#~ msgstr "Avec une chaîne de caractères de description"

#~ msgid "Using a string as the value would look like::"
#~ msgstr "On utilise une chaîne de caractères de la manière suivante ::"

#~ msgid "Using a custom :meth:`__new__`"
#~ msgstr "Avec une méthode ad-hoc :meth:`__new__`"

#~ msgid "Using an auto-numbering :meth:`__new__` would look like::"
#~ msgstr ""
#~ "On utilise une méthode :meth:`__new__` d'énumération de la manière "
#~ "suivante ::"

#~ msgid ""
#~ "To make a more general purpose ``AutoNumber``, add ``*args`` to the "
#~ "signature::"
#~ msgstr ""
#~ "Pour définir un ``AutoNumber`` plus générique, ajoutez ``*args`` à la "
#~ "signature ::"

#~ msgid ""
#~ "Then when you inherit from ``AutoNumber`` you can write your own "
#~ "``__init__`` to handle any extra arguments::"
#~ msgstr ""
#~ "Ainsi, quand vous héritez d'``AutoNumber``, vous pouvez définir "
#~ "``__init__`` pour gérer tout argument supplémentaire ::"

#~ msgid ""
#~ "The :meth:`__new__` method, if defined, is used during creation of the "
#~ "Enum members; it is then replaced by Enum's :meth:`__new__` which is used "
#~ "after class creation for lookup of existing members."
#~ msgstr ""
#~ "La méthode :meth:`__new__`, si définie, est appelée à la création des "
#~ "membres de l'énumération ; elle est ensuite remplacée par la méthode :"
#~ "meth:`__new__` de *Enum*, qui est utilisée après la création de la classe "
#~ "pour la recherche des membres existants."

#~ msgid "OrderedEnum"
#~ msgstr "OrderedEnum"

#~ msgid ""
#~ "An ordered enumeration that is not based on :class:`IntEnum` and so "
#~ "maintains the normal :class:`Enum` invariants (such as not being "
#~ "comparable to other enumerations)::"
#~ msgstr ""
#~ "Une énumération ordonnée qui n'est pas basée sur :class:`IntEnum` et qui, "
#~ "par conséquent, respecte les invariants classiques de :class:`Enum` "
#~ "(comme par exemple l'impossibilité de pouvoir être comparée à d'autres "
#~ "énumérations) ::"

#~ msgid "DuplicateFreeEnum"
#~ msgstr "DuplicateFreeEnum"

#~ msgid ""
#~ "Raises an error if a duplicate member name is found instead of creating "
#~ "an alias::"
#~ msgstr ""
#~ "Lève une erreur si un membre est dupliqué, plutôt que de créer un alias ::"

#~ msgid ""
#~ "This is a useful example for subclassing Enum to add or change other "
#~ "behaviors as well as disallowing aliases.  If the only desired change is "
#~ "disallowing aliases, the :func:`unique` decorator can be used instead."
#~ msgstr ""
#~ "Cet exemple d'héritage de *Enum* est intéressant pour ajouter ou modifier "
#~ "des comportements comme interdire les alias. Si vous ne souhaitez "
#~ "qu'interdire les alias, il suffit d'utiliser le décorateur :func:`unique`."

#~ msgid "Planet"
#~ msgstr "Planet"

#~ msgid ""
#~ "If :meth:`__new__` or :meth:`__init__` is defined the value of the enum "
#~ "member will be passed to those methods::"
#~ msgstr ""
#~ "Si :meth:`__new__` ou :meth:`__init__` sont définies, la valeur du membre "
#~ "de l'énumération sera passée à ces méthodes ::"

#~ msgid "TimePeriod"
#~ msgstr "TimePeriod"

#~ msgid "An example to show the :attr:`_ignore_` attribute in use::"
#~ msgstr "Exemple d'utilisation de l'attribut :attr:`_ignore_` ::"

#~ msgid "How are Enums different?"
#~ msgstr "En quoi les *Enums* sont différentes ?"

#~ msgid ""
#~ "Enums have a custom metaclass that affects many aspects of both derived "
#~ "Enum classes and their instances (members)."
#~ msgstr ""
#~ "Les *enums* ont une métaclasse spéciale qui affecte de nombreux aspects "
#~ "des classes dérivées de *Enum* et de leurs instances (membres)."

#~ msgid "Enum Classes"
#~ msgstr "Classes *Enum*"

#~ msgid ""
#~ "The :class:`EnumMeta` metaclass is responsible for providing the :meth:"
#~ "`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods that "
#~ "allow one to do things with an :class:`Enum` class that fail on a typical "
#~ "class, such as `list(Color)` or `some_enum_var in Color`.  :class:"
#~ "`EnumMeta` is responsible for ensuring that various other methods on the "
#~ "final :class:`Enum` class are correct (such as :meth:`__new__`, :meth:"
#~ "`__getnewargs__`, :meth:`__str__` and :meth:`__repr__`)."
#~ msgstr ""
#~ "La métaclasse :class:`EnumMeta` se charge de fournir les méthodes :meth:"
#~ "`__contains__`, :meth:`__dir__`, :meth:`__iter__` etc. qui permettent de "
#~ "faire des opérations sur une classe :class:`Enum` qui ne fonctionneraient "
#~ "pas sur une classe standard, comme `list(Color)` ou `some_enum_var in "
#~ "Color`. :class:`EnumMeta` garantit que les autres méthodes de la classe "
#~ "finale :class:`Enum` sont correctes (comme :meth:`__new__`, :meth:"
#~ "`__getnewargs__`, :meth:`__str__` et :meth:`__repr__`)."

#~ msgid "Enum Members (aka instances)"
#~ msgstr "Membres d'Enum (c.-à-d. instances)"

#~ msgid ""
#~ "The most interesting thing about Enum members is that they are "
#~ "singletons. :class:`EnumMeta` creates them all while it is creating the :"
#~ "class:`Enum` class itself, and then puts a custom :meth:`__new__` in "
#~ "place to ensure that no new ones are ever instantiated by returning only "
#~ "the existing member instances."
#~ msgstr ""
#~ "Il est intéressant de souligner que les membres d'une *Enum* sont des "
#~ "singletons.  La classe :class:`EnumMeta` les crée tous au moment de la "
#~ "création de la classe :class:`Enum` elle-même et implémente une méthode :"
#~ "meth:`__new__` spécifique. Cette méthode renvoie toujours les instances "
#~ "de membres déjà existantes pour être sûr de ne jamais en instancier de "
#~ "nouvelles."

#~ msgid "Finer Points"
#~ msgstr "Aspects approfondis"

#~ msgid ""
#~ "To help keep Python 2 / Python 3 code in sync an :attr:`_order_` "
#~ "attribute can be provided.  It will be checked against the actual order "
#~ "of the enumeration and raise an error if the two do not match::"
#~ msgstr ""
#~ "Pour faciliter la transition de Python 2 en Python 3, l'attribut :attr:"
#~ "`_order_` peut être défini. Il sera comparé au véritable ordre de "
#~ "l'énumération et lève une erreur si les deux ne correspondent pas ::"

#~ msgid ""
#~ "In Python 2 code the :attr:`_order_` attribute is necessary as definition "
#~ "order is lost before it can be recorded."
#~ msgstr ""
#~ "En Python 2, l'attribut :attr:`_order_` est indispensable car l'ordre de "
#~ "la définition est perdu avant de pouvoir être enregistré."

#~ msgid "_Private__names"
#~ msgstr "_Noms__privés"

#~ msgid ""
#~ ":ref:`Private names <private-name-mangling>` will be normal attributes in "
#~ "Python 3.11 instead of either an error or a member (depending on if the "
#~ "name ends with an underscore). Using these names in 3.10 will issue a :"
#~ "exc:`DeprecationWarning`."
#~ msgstr ""
#~ "Les :ref:`noms privés <private-name-mangling>` seront des attributs "
#~ "habituels avec Python 3.11 et non plus des erreurs ou membres (selon si "
#~ "le nom termine par tiret bas ou non). Utiliser ces noms avec Python 3.10 "
#~ "lèvera un :exc:`DeprecationWarning`."

#~ msgid "``Enum`` member type"
#~ msgstr "Type des membres de ``Enum``"

#~ msgid ""
#~ ":class:`Enum` members are instances of their :class:`Enum` class, and are "
#~ "normally accessed as ``EnumClass.member``.  Under certain circumstances "
#~ "they can also be accessed as ``EnumClass.member.member``, but you should "
#~ "never do this as that lookup may fail or, worse, return something besides "
#~ "the :class:`Enum` member you are looking for (this is another good reason "
#~ "to use all-uppercase names for members)::"
#~ msgstr ""
#~ "Les membres de :class:`Enum` sont des instances de leur classe :class:"
#~ "`Enum`. On y accède normalement par ``ClasseEnum.membre``.  Dans certains "
#~ "cas, on peut également y accéder par ``ClasseEnum.membre.membre``, mais "
#~ "ceci est fortement déconseillé car cette indirection est susceptible "
#~ "d'échouer, ou pire, de ne pas renvoyer le membre de la classe :class:"
#~ "`Enum` désiré (c'est une autre bonne raison pour définir tous les noms "
#~ "des membres en majuscules) ::"

#~ msgid "This behavior is deprecated and will be removed in 3.11."
#~ msgstr "Ce comportement est obsolète et sera retiré en 3.11."

#~ msgid "Boolean value of ``Enum`` classes and members"
#~ msgstr "Valeur booléenne des classes ``Enum`` et de leurs membres"

#~ msgid ""
#~ ":class:`Enum` members that are mixed with non-:class:`Enum` types (such "
#~ "as :class:`int`, :class:`str`, etc.) are evaluated according to the mixed-"
#~ "in type's rules; otherwise, all members evaluate as :data:`True`.  To "
#~ "make your own Enum's boolean evaluation depend on the member's value add "
#~ "the following to your class::"
#~ msgstr ""
#~ "Les membres d'une classe :class:`Enum` mélangée avec un type non dérivé "
#~ "de :class:`Enum` (comme :class:`int`, :class:`str`, etc.) sont évalués "
#~ "selon les règles du type de mélange. Sinon, tous les membres valent :data:"
#~ "`True`. Pour faire dépendre l'évaluation booléenne de votre propre *Enum* "
#~ "de la valeur du membre, il faut ajouter le code suivant à votre classe ::"

#~ msgid ":class:`Enum` classes always evaluate as :data:`True`."
#~ msgstr "Les classes :class:`Enum` valent toujours :data:`True`."

#~ msgid "``Enum`` classes with methods"
#~ msgstr "Classes ``Enum`` avec des méthodes"

#~ msgid ""
#~ "If you give your :class:`Enum` subclass extra methods, like the `Planet`_ "
#~ "class above, those methods will show up in a :func:`dir` of the member, "
#~ "but not of the class::"
#~ msgstr ""
#~ "Si votre classe :class:`Enum` contient des méthodes supplémentaires, "
#~ "comme la classe `Planet`_ ci-dessus, elles s'afficheront avec un appel à :"
#~ "func:`dir` sur le membre, mais pas avec un appel sur la classe ::"

#~ msgid "Combining members of ``Flag``"
#~ msgstr "Combinaison de membres de ``Flag``"

#~ msgid ""
#~ "If a combination of Flag members is not named, the :func:`repr` will "
#~ "include all named flags and all named combinations of flags that are in "
#~ "the value::"
#~ msgstr ""
#~ "Si une valeur issue de la combinaison de membres de *Flag* n'est pas "
#~ "associée explicitement à un membre, la fonction :func:`repr` inclut tous "
#~ "les membres et toutes les combinaisons de membres présents dans cette "
#~ "valeur ::"

#~ msgid ""
#~ "In 3.11 unnamed combinations of flags will only produce the canonical "
#~ "flag members (aka single-value flags).  So ``Color(7)`` will produce "
#~ "something like ``<Color.BLUE|GREEN|RED: 7>``."
#~ msgstr ""
#~ "En 3.11, les combinaisons non-nommées de ``Flag`` ne renverront que les "
#~ "*flags* canoniques (*flags* associés à une unique valeur). Donc "
#~ "``Color(7)`` renverra ``<Color.BLUE|GREE|RED: 7>``."
