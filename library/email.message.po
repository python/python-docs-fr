# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2023-07-29 23:04+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/email.message.rst:2
#, fuzzy
msgid ":mod:`!email.message`: Representing an email message"
msgstr ":mod:`email.message` : représentation d'un message électronique"

#: library/email.message.rst:10
msgid "**Source code:** :source:`Lib/email/message.py`"
msgstr "**Code source :** :source:`Lib/email/message.py`"

#: library/email.message.rst:14
msgid "[1]_"
msgstr "[1]_"

#: library/email.message.rst:16
msgid ""
"The central class in the :mod:`email` package is the :class:`EmailMessage` "
"class, imported from the :mod:`email.message` module.  It is the base class "
"for the :mod:`email` object model.  :class:`EmailMessage` provides the core "
"functionality for setting and querying header fields, for accessing message "
"bodies, and for creating or modifying structured messages."
msgstr ""
"La classe centrale du paquet :mod:`email` est la classe :class:"
"`EmailMessage`, importée du module :mod:`email.message`. C'est la classe "
"mère du modèle d'objet :mod:`email`. :class:`EmailMessage` fournit la "
"fonctionnalité de base pour définir et interroger les champs d'en-tête, pour "
"accéder au corps des messages et pour créer ou modifier des messages "
"structurés."

#: library/email.message.rst:22
msgid ""
"An email message consists of *headers* and a *payload* (which is also "
"referred to as the *content*).  Headers are :rfc:`5322` or :rfc:`6532` style "
"field names and values, where the field name and value are separated by a "
"colon.  The colon is not part of either the field name or the field value.  "
"The payload may be a simple text message, or a binary object, or a "
"structured sequence of sub-messages each with their own set of headers and "
"their own payload.  The latter type of payload is indicated by the message "
"having a MIME type such as :mimetype:`multipart/\\*` or :mimetype:`message/"
"rfc822`."
msgstr ""
"Un message électronique se compose d'en-têtes (*headers*) et d'une *charge "
"utile* (*payload* en anglais, également appelée *contenu* – *content* en "
"anglais). Les en-têtes sont des noms et valeurs de champ de style :rfc:"
"`5322` ou :rfc:`6532`, où le nom et la valeur du champ sont séparés par deux "
"points. Les deux-points ne font partie ni du nom du champ ni de la valeur du "
"champ. La charge utile peut être un simple message texte, un objet binaire "
"ou une séquence structurée de sous-messages chacun avec son propre ensemble "
"d'en-têtes et sa propre charge utile. Ce dernier type de charge utile est "
"indiqué par le message ayant un type MIME tel que :mimetype:`multipart/\\*` "
"ou :mimetype:`message/rfc822`."

#: library/email.message.rst:31
msgid ""
"The conceptual model provided by an :class:`EmailMessage` object is that of "
"an ordered dictionary of headers coupled with a *payload* that represents "
"the :rfc:`5322` body of the message, which might be a list of sub-"
"``EmailMessage`` objects.  In addition to the normal dictionary methods for "
"accessing the header names and values, there are methods for accessing "
"specialized information from the headers (for example the MIME content "
"type), for operating on the payload, for generating a serialized version of "
"the message, and for recursively walking over the object tree."
msgstr ""
"Le modèle conceptuel fourni par un objet :class:`EmailMessage` est celui "
"d'un dictionnaire ordonné d'en-têtes couplé à une *charge utile* qui "
"représente le corps :rfc:`5322` du message, qui peut être une liste de sous-"
"objets ``EmailMessage``. En plus des méthodes de dictionnaire normales pour "
"accéder aux noms et valeurs d'en-têtes, il existe des méthodes pour accéder "
"à des informations spécialisées à partir des en-têtes (par exemple le type "
"de contenu MIME), pour agir sur la charge utile, pour générer une version "
"sérialisée du message et pour parcourir récursivement l'arborescence "
"d'objets."

#: library/email.message.rst:40
#, fuzzy
msgid ""
"The :class:`EmailMessage` dictionary-like interface is indexed by the header "
"names, which must be ASCII values.  The values of the dictionary are strings "
"with some extra methods.  Headers are stored and returned in case-preserving "
"form, but field names are matched case-insensitively.  The keys are ordered, "
"but unlike a real dict, there can be duplicates.  Additional methods are "
"provided for working with headers that have duplicate keys."
msgstr ""
"L'interface de type dictionnaire :class:`EmailMessage` est indexée par les "
"noms d'en-tête, qui doivent être des valeurs ASCII. Les valeurs du "
"dictionnaire sont des chaînes avec quelques méthodes supplémentaires. Les en-"
"têtes sont stockés et renvoyés sous une forme respectant la casse, mais les "
"noms de champ sont mis en correspondance sans tenir compte de la casse. "
"Contrairement à un vrai dictionnaire, il y a un ordre pour les clés et il "
"peut y avoir des clés en double. Des méthodes supplémentaires sont fournies "
"pour travailler avec des en-têtes qui ont des clés en double."

#: library/email.message.rst:47
msgid ""
"The *payload* is either a string or bytes object, in the case of simple "
"message objects, or a list of :class:`EmailMessage` objects, for MIME "
"container documents such as :mimetype:`multipart/\\*` and :mimetype:`message/"
"rfc822` message objects."
msgstr ""
"La *charge utile* est soit une chaîne ou un objet d'octets, dans le cas "
"d'objets de message simples, soit une liste d'objets :class:`EmailMessage` "
"pour les documents de conteneur MIME tels que :mimetype:`multipart/\\*` et "
"les objets messages :mimetype:`message/rfc822`."

#: library/email.message.rst:55
msgid ""
"If *policy* is specified use the rules it specifies to update and serialize "
"the representation of the message.  If *policy* is not set, use the :class:"
"`~email.policy.default` policy, which follows the rules of the email RFCs "
"except for line endings (instead of the RFC mandated ``\\r\\n``, it uses the "
"Python standard ``\\n`` line endings).  For more information see the :mod:"
"`~email.policy` documentation."
msgstr ""
"Si *policy* est spécifiée, Python utilise les règles qu'elle spécifie pour "
"mettre à jour et sérialiser la représentation du message. Si *policy* n'est "
"pas définie, Python utilise la politique :class:`~email.policy.default`, qui "
"suit les règles des RFC de messagerie sauf pour les fins de ligne (au lieu "
"de ``\\r\\n`` indiqués par la RFC, il utilise les fins de ligne standard "
"Python ``\\n``). Pour plus d'informations, consultez la documentation :mod:"
"`~email.policy`."

#: library/email.message.rst:64
#, fuzzy
msgid ""
"Return the entire message flattened as a string.  When optional *unixfrom* "
"is true, the envelope header is included in the returned string.  *unixfrom* "
"defaults to ``False``.  For backward compatibility with the base :class:"
"`~email.message.Message` class *maxheaderlen* is accepted, but defaults to "
"``None``, which means that by default the line length is controlled by the :"
"attr:`~email.policy.Policy.max_line_length` of the policy.  The *policy* "
"argument may be used to override the default policy obtained from the "
"message instance.  This can be used to control some of the formatting "
"produced by the method, since the specified *policy* will be passed to the :"
"class:`~email.generator.Generator`."
msgstr ""
"Renvoie le message entier aplati sous forme de chaîne. Lorsque l'option "
"*unixfrom* est vraie, l'en-tête de l'enveloppe est inclus dans la chaîne "
"renvoyée. *unixfrom* par défaut est ``False``. Pour la rétrocompatibilité "
"avec la classe mère :class:`~email.message.Message`, la valeur "
"*maxheaderlen* de la classe est acceptée, mais la valeur par défaut est "
"``None``, ce qui signifie que par défaut la longueur de la ligne est "
"contrôlée par l'attribut :attr:`~ email.policy.EmailPolicy.max_line_length` "
"de la politique. L'argument *policy* peut être utilisé pour remplacer la "
"politique par défaut obtenue à partir de l'instance de message. Cela peut "
"être utilisé pour contrôler une partie du formatage produit par la méthode, "
"puisque la *policy* spécifiée sera transmise à :class:`~email.generator."
"Generator`."

#: library/email.message.rst:114
msgid ""
"Flattening the message may trigger changes to the :class:`EmailMessage` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr ""
"L'aplatissement du message peut déclencher des changements dans :class:"
"`EmailMessage` si les valeurs par défaut doivent être renseignées pour "
"terminer la transformation en chaîne (par exemple, les limites MIME peuvent "
"être générées ou modifiées)."

#: library/email.message.rst:80
msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.Generator` for "
"a more flexible API for serializing messages.  Note also that this method is "
"restricted to producing messages serialized as \"7 bit clean\" when :attr:"
"`~email.policy.EmailPolicy.utf8` is ``False``, which is the default."
msgstr ""
"Notez que cette méthode est fournie à titre de commodité et n'est peut-être "
"pas la méthode la plus utile pour sérialiser les messages dans votre "
"application, en particulier si vous traitez plusieurs messages. Voir :class:"
"`email.generator.Generator` pour une API plus flexible pour la sérialisation "
"des messages. Notez également que cette méthode est limitée à la production "
"de messages sérialisés en « 7 bits propres » lorsque :attr:`~email.policy."
"EmailPolicy.utf8` est ``False``, qui est la valeur par défaut."

#: library/email.message.rst:88
msgid ""
"the default behavior when *maxheaderlen* is not specified was changed from "
"defaulting to 0 to defaulting to the value of *max_line_length* from the "
"policy."
msgstr ""
"le comportement par défaut lorsque *maxheaderlen* n'est pas spécifié est "
"passé de la valeur par défaut à 0 à la valeur par défaut de "
"*max_line_length* de la politique."

#: library/email.message.rst:95
msgid ""
"Equivalent to ``as_string(policy=self.policy.clone(utf8=True))``.  Allows "
"``str(msg)`` to produce a string containing the serialized message in a "
"readable format."
msgstr ""
"Équivalent à ``as_string(policy=self.policy.clone(utf8=True))``. Permet à "
"``str(msg)`` de produire une chaîne contenant le message sérialisé dans un "
"format lisible."

#: library/email.message.rst:99
msgid ""
"the method was changed to use ``utf8=True``, thus producing an :rfc:`6531`-"
"like message representation, instead of being a direct alias for :meth:"
"`as_string`."
msgstr ""
"la méthode a été modifiée pour utiliser ``utf8=True``, produisant ainsi une "
"représentation de message semblable à :rfc:`6531`, au lieu d'être un alias "
"direct pour :meth:`as_string`."

#: library/email.message.rst:106
msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned string.  "
"*unixfrom* defaults to ``False``.  The *policy* argument may be used to "
"override the default policy obtained from the message instance. This can be "
"used to control some of the formatting produced by the method, since the "
"specified *policy* will be passed to the :class:`~email.generator."
"BytesGenerator`."
msgstr ""
"Renvoie le message entier aplati en tant qu'objet bytes. Lorsque l'option "
"*unixfrom* est vraie, l'en-tête de l'enveloppe est inclus dans la chaîne "
"renvoyée. *unixfrom* par défaut est ``False``. L'argument *policy* peut être "
"utilisé pour remplacer la politique par défaut obtenue à partir de "
"l'instance de message. Cela peut être utilisé pour contrôler une partie du "
"formatage produit par la méthode, puisque la *policy* spécifiée sera "
"transmise à :class:`~email.generator.BytesGenerator`."

#: library/email.message.rst:118
msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.BytesGenerator` "
"for a more flexible API for serializing messages."
msgstr ""
"Notez que cette méthode est fournie à titre de commodité et n'est peut-être "
"pas la méthode la plus utile pour sérialiser les messages dans votre "
"application, en particulier si vous traitez plusieurs messages. Voir :class:"
"`email.generator.BytesGenerator` pour une API plus flexible pour la "
"sérialisation des messages."

#: library/email.message.rst:127
#, fuzzy
msgid ""
"Equivalent to :meth:`.as_bytes`.  Allows ``bytes(msg)`` to produce a bytes "
"object containing the serialized message."
msgstr ""
"Équivalent à :meth:`.as_bytes()`. Permet à ``bytes(msg)`` de produire un "
"objet bytes contenant le message sérialisé."

#: library/email.message.rst:133
msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ :class:"
"`EmailMessage` objects, otherwise return ``False``.  When :meth:"
"`is_multipart` returns ``False``, the payload should be a string object "
"(which might be a CTE encoded binary payload).  Note that :meth:"
"`is_multipart` returning ``True`` does not necessarily mean that \"msg."
"get_content_maintype() == 'multipart'\" will return the ``True``. For "
"example, ``is_multipart`` will return ``True`` when the :class:"
"`EmailMessage` is of type ``message/rfc822``."
msgstr ""
"Renvoie ``True`` si la charge utile du message est une liste d'objets :class:"
"`EmailMessage`, sinon renvoie ``False``. Lorsque :meth:`is_multipart` "
"renvoie ``False``, la charge utile doit être un objet chaîne (qui peut être "
"une charge utile binaire encodée CTE). Notez que :meth:`is_multipart` "
"renvoyant ``True`` ne signifie pas nécessairement que ``msg."
"get_content_maintype() == 'multipart'`` renvoie ``True``. Par exemple, "
"``is_multipart`` renvoie ``True`` lorsque le :class:`EmailMessage` est de "
"type ``message/rfc822``."

#: library/email.message.rst:145
msgid ""
"Set the message's envelope header to *unixfrom*, which should be a string.  "
"(See :class:`~mailbox.mboxMessage` for a brief description of this header.)"
msgstr ""
"Définit l'en-tête de l'enveloppe du message sur *unixfrom*, qui doit être "
"une chaîne (voir :class:`~mailbox.mboxMessage` pour une brève description de "
"cet en-tête)."

#: library/email.message.rst:152
msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the envelope "
"header was never set."
msgstr ""
"Renvoie l'en-tête de l'enveloppe du message. La valeur par défaut est "
"``None`` si l'en-tête de l'enveloppe n'a jamais été défini."

#: library/email.message.rst:156
msgid ""
"The following methods implement the mapping-like interface for accessing the "
"message's headers.  Note that there are some semantic differences between "
"these methods and a normal mapping (i.e. dictionary) interface.  For "
"example, in a dictionary there are no duplicate keys, but here there may be "
"duplicate message headers.  Also, in dictionaries there is no guaranteed "
"order to the keys returned by :meth:`keys`, but in an :class:`EmailMessage` "
"object, headers are always returned in the order they appeared in the "
"original message, or in which they were added to the message later.  Any "
"header deleted and then re-added is always appended to the end of the header "
"list."
msgstr ""
"Les méthodes suivantes implémentent l'interface de type correspondance pour "
"accéder aux en-têtes du message. Notez qu'il existe des différences "
"sémantiques entre ces méthodes et une interface de correspondance normale "
"(c'est-à-dire un dictionnaire). Par exemple, dans un dictionnaire, il n'y a "
"pas de clés en double, mais ici, il peut y avoir des en-têtes de message en "
"double. De plus, dans les dictionnaires, il n'y a pas d'ordre garanti pour "
"les clés renvoyées par :meth:`keys`, mais dans un objet :class:"
"`EmailMessage`, les en-têtes sont toujours renvoyés dans l'ordre dans lequel "
"ils sont apparus dans le message d'origine, ou dans lequel ils ont été "
"ajoutés au message plus tard. Tout en-tête supprimé puis rajouté est "
"toujours ajouté à la fin de la liste des en-têtes."

#: library/email.message.rst:167
msgid ""
"These semantic differences are intentional and are biased toward convenience "
"in the most common use cases."
msgstr ""
"Ces différences sémantiques sont intentionnelles et privilégient la "
"commodité dans les cas d'utilisation les plus courants."

#: library/email.message.rst:170
msgid ""
"Note that in all cases, any envelope header present in the message is not "
"included in the mapping interface."
msgstr ""
"Notez que dans tous les cas, tout en-tête d'enveloppe présent dans le "
"message n'est pas inclus dans l'interface de correspondance."

#: library/email.message.rst:176
msgid "Return the total number of headers, including duplicates."
msgstr "Renvoie le nombre total d'en-têtes, y compris les doublons."

#: library/email.message.rst:181
msgid ""
"Return ``True`` if the message object has a field named *name*. Matching is "
"done without regard to case and *name* does not include the trailing colon.  "
"Used for the ``in`` operator.  For example::"
msgstr ""
"Renvoie ``True`` si l'objet message a un champ nommé *name*. La "
"correspondance est effectuée sans tenir compte de la casse et *name* "
"n'inclut pas les deux-points de fin. Utilisé pour l'opérateur ``in``. Par "
"exemple ::"

#: library/email.message.rst:185
msgid ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"
msgstr ""

#: library/email.message.rst:191
msgid ""
"Return the value of the named header field.  *name* does not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a :"
"exc:`KeyError` is never raised."
msgstr ""
"Renvoie la valeur du champ d'en-tête nommé. *name* n'inclut pas le "
"séparateur de champ deux-points. Si l'en-tête est manquant, ``None`` est "
"renvoyée ; :exc:`KeyError` n'est jamais levée."

#: library/email.message.rst:195
msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is undefined.  "
"Use the :meth:`get_all` method to get the values of all the extant headers "
"named *name*."
msgstr ""
"Notez que si le champ nommé apparaît plus d'une fois dans les en-têtes du "
"message, il n'est pas défini la valeur de quel champ est renvoyée. Utilisez "
"la méthode :meth:`get_all` pour obtenir les valeurs de tous les en-têtes "
"existants nommés *name*."

#: library/email.message.rst:200
msgid ""
"Using the standard (non-``compat32``) policies, the returned value is an "
"instance of a subclass of :class:`email.headerregistry.BaseHeader`."
msgstr ""
"En utilisant les politiques standard (non-``compat32``), la valeur renvoyée "
"est une instance d'une sous-classe de :class:`email.headerregistry."
"BaseHeader`."

#: library/email.message.rst:206
msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing headers."
msgstr ""
"Ajoute un en-tête au message avec le nom de champ *name* et la valeur *val*. "
"Le champ est ajouté à la fin des en-têtes existants du message."

#: library/email.message.rst:209
msgid ""
"Note that this does *not* overwrite or delete any existing header with the "
"same name.  If you want to ensure that the new header is the only one "
"present in the message with field name *name*, delete the field first, e.g.::"
msgstr ""
"Notez que cela n'écrase *pas* ou ne supprime aucun en-tête existant portant "
"le même nom. Si vous voulez vous assurer que le nouvel en-tête est le seul "
"présent dans le message avec le nom de champ *name*, supprimez d'abord le "
"champ, par exemple ::"

#: library/email.message.rst:213
msgid ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"
msgstr ""

#: library/email.message.rst:216
#, fuzzy
msgid ""
"If the :mod:`policy <email.policy>` defines certain headers to be unique (as "
"the standard policies do), this method may raise a :exc:`ValueError` when an "
"attempt is made to assign a value to such a header when one already exists.  "
"This behavior is intentional for consistency's sake, but do not depend on it "
"as we may choose to make such assignments do an automatic deletion of the "
"existing header in the future."
msgstr ""
"Si la :mod:`policy` définit certains en-têtes comme étant uniques (comme le "
"font les politiques standards), cette méthode peut lever une :exc:"
"`ValueError` lorsqu'une tentative est faite pour attribuer une valeur à un "
"tel en-tête alors qu'il en existe déjà un. Ce comportement est intentionnel "
"pour des raisons de cohérence, mais ne vous y fiez pas car Python pourrait "
"choisir de faire en sorte que de telles affectations effectuent une "
"suppression automatique de l'en-tête existant à l'avenir."

#: library/email.message.rst:226
msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr ""
"Supprime toutes les occurrences du champ portant le nom *name* des en-têtes "
"du message. Aucune exception n'est levée si le champ nommé n'est pas présent "
"dans les en-têtes."

#: library/email.message.rst:233
msgid "Return a list of all the message's header field names."
msgstr "Renvoie une liste de tous les noms de champs d'en-tête du message."

#: library/email.message.rst:238
msgid "Return a list of all the message's field values."
msgstr "Renvoie une liste de toutes les valeurs de champ du message."

#: library/email.message.rst:243
msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr ""
"Renvoie une liste de couples contenant tous les en-têtes et valeurs de champ "
"du message."

#: library/email.message.rst:249
#, fuzzy
msgid ""
"Return the value of the named header field.  This is identical to :meth:"
"`~object.__getitem__` except that optional *failobj* is returned if the "
"named header is missing (*failobj* defaults to ``None``)."
msgstr ""
"Renvoie la valeur du champ d'en-tête nommé. Identique à :meth:`__getitem__` "
"sauf que l'option *failobj* est renvoyée si l'en-tête nommé est manquant "
"(*failobj* est ``None`` par défaut)."

#: library/email.message.rst:254
msgid "Here are some additional useful header related methods:"
msgstr "Voici quelques méthodes supplémentaires utiles liées aux en-têtes :"

#: library/email.message.rst:259
msgid ""
"Return a list of all the values for the field named *name*. If there are no "
"such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr ""
"Renvoie la liste de toutes les valeurs du champ nommé *name*. S'il n'y a pas "
"d'en-têtes nommés de ce type dans le message, *failobj* est renvoyé (la "
"valeur par défaut est ``None``)."

#: library/email.message.rst:266
msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the *primary* "
"value for the header."
msgstr ""
"Étend les en-têtes. Cette méthode est similaire à :meth:`__setitem__` sauf "
"que des paramètres d'en-tête supplémentaires peuvent être fournis en tant "
"qu'arguments nommés. *_name* est le champ d'en-tête à ajouter et *_value* "
"est la valeur *primaire* de l'en-tête."

#: library/email.message.rst:271
msgid ""
"For each item in the keyword argument dictionary *_params*, the key is taken "
"as the parameter name, with underscores converted to dashes (since dashes "
"are illegal in Python identifiers).  Normally, the parameter will be added "
"as ``key=\"value\"`` unless the value is ``None``, in which case only the "
"key will be added."
msgstr ""
"Pour chaque élément du dictionnaire d'arguments nommés *_params*, la clé est "
"prise comme nom de paramètre, avec des traits de soulignement convertis en "
"tirets (puisque les tirets sont illégaux dans les identifiants Python). "
"Normalement, le paramètre est ajouté en tant que ``key=\"value\"`` sauf si "
"la valeur est ``None``, auquel cas seule la clé est ajoutée."

#: library/email.message.rst:277
msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly controlled by specifying the value as a three tuple in the format "
"``(CHARSET, LANGUAGE, VALUE)``, where ``CHARSET`` is a string naming the "
"charset to be used to encode the value, ``LANGUAGE`` can usually be set to "
"``None`` or the empty string (see :rfc:`2231` for other possibilities), and "
"``VALUE`` is the string value containing non-ASCII code points.  If a three "
"tuple is not passed and the value contains non-ASCII characters, it is "
"automatically encoded in :rfc:`2231` format using a ``CHARSET`` of ``utf-8`` "
"and a ``LANGUAGE`` of ``None``."
msgstr ""
"Si la valeur contient des caractères non-ASCII, le jeu de caractères et la "
"langue peuvent être explicitement contrôlés en spécifiant la valeur sous la "
"forme d'un triplet au format ``(CHARSET, LANGUAGE, VALUE)``, où ``CHARSET`` "
"est une chaîne nommant le jeu de caractères à utiliser pour encoder la "
"valeur, ``LANGUAGE`` peut généralement être défini sur ``None`` ou sur la "
"chaîne vide (voir :rfc:`2231` pour d'autres possibilités) et ``VALUE`` est "
"la chaîne contenant les valeurs des points de code non-ASCII. Si un triplet "
"n'est pas passé et que la valeur contient des caractères non-ASCII, elle est "
"automatiquement encodée au format :rfc:`2231` en utilisant ``utf-8`` comme "
"``CHARSET`` et ``None`` comme ``LANGUAGE``."

#: library/email.message.rst:287
msgid "Here is an example::"
msgstr "Voici un exemple ::"

#: library/email.message.rst:289
msgid "msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"
msgstr ""

#: library/email.message.rst:291
msgid "This will add a header that looks like ::"
msgstr "Cela ajoute un en-tête qui ressemble à ::"

#: library/email.message.rst:293
msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr ""

#: library/email.message.rst:295
msgid "An example of the extended interface with non-ASCII characters::"
msgstr "Un exemple d'interface étendue avec des caractères non-ASCII ::"

#: library/email.message.rst:297
msgid ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"
msgstr ""

#: library/email.message.rst:303
msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case of the original "
"header.  If no matching header is found, raise a :exc:`KeyError`."
msgstr ""
"Remplace un en-tête. Remplace le premier en-tête trouvé dans le message qui "
"correspond à *_name*, en conservant l'ordre des en-têtes et la casse du nom "
"de champ de l'en-tête d'origine. Si aucun en-tête correspondant n'est "
"trouvé, lève une :exc:`KeyError`."

#: library/email.message.rst:311
msgid ""
"Return the message's content type, coerced to lower case of the form :"
"mimetype:`maintype/subtype`.  If there is no :mailheader:`Content-Type` "
"header in the message return the value returned by :meth:"
"`get_default_type`.  If the :mailheader:`Content-Type` header is invalid, "
"return ``text/plain``."
msgstr ""
"Renvoie le type de contenu du message, contraint en minuscules de la forme :"
"mimetype:`maintype/subtype`. S'il n'y a pas d'en-tête :mailheader:`Content-"
"Type` dans le message, renvoie la valeur renvoyée par :meth:"
"`get_default_type`. Si l'en-tête :mailheader:`Content-Type` n'est pas "
"valide, renvoie ``text/plain``."

#: library/email.message.rst:317
msgid ""
"(According to :rfc:`2045`, messages always have a default type, :meth:"
"`get_content_type` will always return a value.  :rfc:`2045` defines a "
"message's default type to be :mimetype:`text/plain` unless it appears inside "
"a :mimetype:`multipart/digest` container, in which case it would be :"
"mimetype:`message/rfc822`.  If the :mailheader:`Content-Type` header has an "
"invalid type specification, :rfc:`2045` mandates that the default type be :"
"mimetype:`text/plain`.)"
msgstr ""
"(Selon la :rfc:`2045`, les messages ont toujours un type par défaut, :meth:"
"`get_content_type` renvoie toujours une valeur. La :rfc:`2045` définit le "
"type par défaut d'un message comme étant :mimetype:`text/plain` à moins "
"qu'il n'apparaisse dans un conteneur :mimetype:`multipart/digest`, auquel "
"cas ce serait :mimetype:`message/rfc822`. Si l'en-tête :mailheader:`Content-"
"Type` a une spécification de type invalide, la :rfc:`2045` exige que le type "
"par défaut soit :mimetype:`text/plain`.)"

#: library/email.message.rst:328
msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype` "
"part of the string returned by :meth:`get_content_type`."
msgstr ""
"Renvoie le type de contenu principal du message. C'est la partie :mimetype:"
"`maintype` de la chaîne renvoyée par :meth:`get_content_type`."

#: library/email.message.rst:334
msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` part "
"of the string returned by :meth:`get_content_type`."
msgstr ""
"Renvoie le type de sous-contenu du message. C'est la partie :mimetype:"
"`subtype` de la chaîne renvoyée par :meth:`get_content_type`."

#: library/email.message.rst:340
msgid ""
"Return the default content type.  Most messages have a default content type "
"of :mimetype:`text/plain`, except for messages that are subparts of :"
"mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"Renvoie le type de contenu par défaut. La plupart des messages ont un type "
"de contenu :mimetype:`text/plain` par défaut, à l'exception des messages qui "
"sont des sous-parties des conteneurs :mimetype:`multipart/digest`. Ces sous-"
"parties ont un type de contenu par défaut de :mimetype:`message/rfc822`."

#: library/email.message.rst:348
msgid ""
"Set the default content type.  *ctype* should either be :mimetype:`text/"
"plain` or :mimetype:`message/rfc822`, although this is not enforced.  The "
"default content type is not stored in the :mailheader:`Content-Type` header, "
"so it only affects the return value of the ``get_content_type`` methods when "
"no :mailheader:`Content-Type` header is present in the message."
msgstr ""
"Définit le type de contenu par défaut. *ctype* doit être :mimetype:`text/"
"plain` ou :mimetype:`message/rfc822`, bien que cela ne soit pas imposé. Le "
"type de contenu par défaut n'est pas stocké dans l'en-tête :mailheader:"
"`Content-Type`, il n'affecte donc que la valeur de retour des méthodes "
"``get_content_type`` lorsqu'aucun en-tête :mailheader:`Content-Type` n'est "
"présent dans le message ."

#: library/email.message.rst:359
msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the parameter "
"already exists in the header, replace its value with *value*. When *header* "
"is ``Content-Type`` (the default) and the header does not yet exist in the "
"message, add it, set its value to :mimetype:`text/plain`, and append the new "
"parameter value.  Optional *header* specifies an alternative header to :"
"mailheader:`Content-Type`."
msgstr ""
"Définit un paramètre dans l'en-tête :mailheader:`Content-Type`. Si le "
"paramètre existe déjà dans l'en-tête, remplace sa valeur par *value*. "
"Lorsque *header* est ``Content-Type`` (la valeur par défaut) et que l'en-"
"tête n'existe pas encore dans le message, l'ajoute, définit sa valeur sur :"
"mimetype:`text/plain` et ajoute la nouvelle valeur du paramètre. *header* "
"facultatif spécifie un en-tête alternatif à :mailheader:`Content-Type`."

#: library/email.message.rst:366
msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly specified using the optional *charset* and *language* "
"parameters.  Optional *language* specifies the :rfc:`2231` language, "
"defaulting to the empty string.  Both *charset* and *language* should be "
"strings.  The default is to use the ``utf8`` *charset* and ``None`` for the "
"*language*."
msgstr ""
"Si la valeur contient des caractères non ASCII, le jeu de caractères et la "
"langue peuvent être explicitement spécifiés à l'aide des paramètres "
"facultatifs *charset* et *language*. L'option *language* spécifie la langue :"
"rfc:`2231`, par défaut la chaîne vide. *charset* et *language* doivent être "
"des chaînes. La valeur par défaut est ``utf8`` pour *charset* et ``None`` "
"pour *language*."

#: library/email.message.rst:373
msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of "
"the list of headers.  If *replace* is ``True``, the header will be updated "
"in place."
msgstr ""
"Si *replace* est ``False`` (valeur par défaut), l'en-tête est déplacé à la "
"fin de la liste des en-têtes. Si *replace* est ``True``, l'en-tête est mis à "
"jour sur place."

#: library/email.message.rst:394
msgid ""
"Use of the *requote* parameter with :class:`EmailMessage` objects is "
"deprecated."
msgstr ""
"L'utilisation du paramètre *requote* avec les objets :class:`EmailMessage` "
"est obsolète."

#: library/email.message.rst:380
#, fuzzy
msgid ""
"Note that existing parameter values of headers may be accessed through the :"
"attr:`~email.headerregistry.ParameterizedMIMEHeader.params` attribute of the "
"header value (for example, ``msg['Content-Type'].params['charset']``)."
msgstr ""
"Notez que les valeurs existantes des paramètres des en-têtes sont "
"accessibles via l'attribut :attr:`~email.headerregistry.BaseHeader.params` "
"de la valeur d'en-tête (par exemple, ``msg['Content-Type']."
"params['charset' ]``)."

# suit un :
#: library/email.message.rst:384
msgid "``replace`` keyword was added."
msgstr "le paramètre nommé ``replace`` a été ajouté."

#: library/email.message.rst:389
msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type` "
"header.  The header will be re-written in place without the parameter or its "
"value.  Optional *header* specifies an alternative to :mailheader:`Content-"
"Type`."
msgstr ""
"Supprime complètement le paramètre donné de l'en-tête :mailheader:`Content-"
"Type`. L'en-tête est réécrit en place sans le paramètre ou sa valeur. "
"L'option *header* spécifie une alternative à :mailheader:`Content-Type`."

#: library/email.message.rst:400
msgid ""
"Return the value of the ``filename`` parameter of the :mailheader:`Content-"
"Disposition` header of the message.  If the header does not have a "
"``filename`` parameter, this method falls back to looking for the ``name`` "
"parameter on the :mailheader:`Content-Type` header.  If neither is found, or "
"the header is missing, then *failobj* is returned. The returned string will "
"always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Renvoie la valeur du paramètre ``filename`` de l'en-tête :mailheader:"
"`Content-Disposition` du message. Si l'en-tête n'a pas de paramètre "
"``filename``, cette méthode revient à rechercher le paramètre ``name`` dans "
"l'en-tête :mailheader:`Content-Type`. Si aucun n'est trouvé, ou si l'en-tête "
"est manquant, alors *failobj* est renvoyé. La chaîne renvoyée est toujours "
"sans guillemets selon :func:`email.utils.unquote`."

#: library/email.message.rst:411
msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader:`Content-"
"Type` header of the message, or *failobj* if either the header is missing, "
"or has no ``boundary`` parameter.  The returned string will always be "
"unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Renvoie la valeur du paramètre ``boundary`` de l'en-tête :mailheader:"
"`Content-Type` du message, ou *failobj* si l'en-tête est manquant ou n'a pas "
"de paramètre ``boundary``. La chaîne renvoyée est toujours sans guillemets "
"selon :func:`email.utils.unquote`."

#: library/email.message.rst:419
msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to "
"*boundary*.  :meth:`set_boundary` will always quote *boundary* if "
"necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the message "
"object has no :mailheader:`Content-Type` header."
msgstr ""
"Définit le paramètre ``boundary`` de l'en-tête :mailheader:`Content-Type` "
"sur *boundary*. :meth:`set_boundary` entoure *boundary* de guillemets si "
"nécessaire. Une :exc:`~email.errors.HeaderParseError` est levée si l'objet "
"message n'a pas d'en-tête :mailheader:`Content-Type`."

#: library/email.message.rst:424
msgid ""
"Note that using this method is subtly different from deleting the old :"
"mailheader:`Content-Type` header and adding a new one with the new boundary "
"via :meth:`add_header`, because :meth:`set_boundary` preserves the order of "
"the :mailheader:`Content-Type` header in the list of headers."
msgstr ""
"Notez que l'utilisation de cette méthode est légèrement différente de la "
"suppression de l'ancien en-tête :mailheader:`Content-Type` et de l'ajout "
"d'un nouveau avec la nouvelle délimitation via :meth:`add_header`, car :meth:"
"`set_boundary` préserve l'ordre des en-têtes :mailheader:`Content-Type` dans "
"la liste des en-têtes."

#: library/email.message.rst:433
msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` header, "
"coerced to lower case.  If there is no :mailheader:`Content-Type` header, or "
"if that header has no ``charset`` parameter, *failobj* is returned."
msgstr ""
"Renvoie le paramètre ``charset`` de l'en-tête :mailheader:`Content-Type`, "
"contraint en minuscules. S'il n'y a pas d'en-tête :mailheader:`Content-"
"Type`, ou si cet en-tête n'a pas de paramètre ``charset``, *failobj* est "
"renvoyé."

#: library/email.message.rst:440
msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one element "
"for each subpart in the payload, otherwise, it will be a list of length 1."
msgstr ""
"Renvoie la liste des noms des jeux de caractères dans le message. Si le "
"message est un :mimetype:`multipart`, alors la liste contient un élément "
"pour chaque sous-partie dans la charge utile, sinon c'est une liste de "
"longueur 1."

#: library/email.message.rst:444
msgid ""
"Each item in the list will be a string which is the value of the ``charset`` "
"parameter in the :mailheader:`Content-Type` header for the represented "
"subpart.  If the subpart has no :mailheader:`Content-Type` header, no "
"``charset`` parameter, or is not of the :mimetype:`text` main MIME type, "
"then that item in the returned list will be *failobj*."
msgstr ""
"Chaque élément de la liste est une chaîne qui est la valeur du paramètre "
"``charset`` dans l'en-tête :mailheader:`Content-Type` pour la sous-partie "
"représentée. Si la sous-partie n'a pas d'en-tête :mailheader:`Content-Type`, "
"pas de paramètre ``charset`` ou n'est pas du type MIME principal :mimetype:"
"`text`, alors cet élément est *failobj* dans la liste renvoyée."

#: library/email.message.rst:453
msgid ""
"Return ``True`` if there is a :mailheader:`Content-Disposition` header and "
"its (case insensitive) value is ``attachment``, ``False`` otherwise."
msgstr ""
"Renvoie ``True`` s'il y a un en-tête :mailheader:`Content-Disposition` et "
"que sa valeur (insensible à la casse) est ``attachment``, ``False`` sinon."

#: library/email.message.rst:456
msgid ""
"is_attachment is now a method instead of a property, for consistency with :"
"meth:`~email.message.Message.is_multipart`."
msgstr ""
"*is_attachment* est maintenant une méthode au lieu d'une propriété, par "
"souci de cohérence avec :meth:`~email.message.Message.is_multipart`."

#: library/email.message.rst:463
msgid ""
"Return the lowercased value (without parameters) of the message's :"
"mailheader:`Content-Disposition` header if it has one, or ``None``.  The "
"possible values for this method are *inline*, *attachment* or ``None`` if "
"the message follows :rfc:`2183`."
msgstr ""
"Renvoie la valeur en minuscules (sans paramètres) de l'en-tête :mailheader:"
"`Content-Disposition` du message s'il en a un, ou ``None``. Les valeurs "
"possibles pour cette méthode sont *inline*, *attachment* ou ``None`` si le "
"message respecte la :rfc:`2183`."

#: library/email.message.rst:471
msgid ""
"The following methods relate to interrogating and manipulating the content "
"(payload) of the message."
msgstr ""
"Les méthodes suivantes concernent l'interrogation et la manipulation du "
"contenu (charge utile) du message."

#: library/email.message.rst:477
msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in depth-"
"first traversal order.  You will typically use :meth:`walk` as the iterator "
"in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
"La méthode :meth:`walk` est un générateur polyvalent qui peut être utilisé "
"pour itérer sur toutes les parties et sous-parties d'un arbre d'objets de "
"message, dans l'ordre de parcours en profondeur d'abord. L'utilisation "
"classique est d'itérer avec :meth:`walk` dans une boucle ``for`` ; chaque "
"itération renvoie la sous-partie suivante."

#: library/email.message.rst:482
msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr ""
"Voici un exemple qui imprime le type MIME de chaque partie d'une structure "
"de message en plusieurs parties :"

#: library/email.message.rst:491
msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"
msgstr ""

#: library/email.message.rst:503
msgid ""
"``walk`` iterates over the subparts of any part where :meth:`is_multipart` "
"returns ``True``, even though ``msg.get_content_maintype() == 'multipart'`` "
"may return ``False``.  We can see this in our example by making use of the "
"``_structure`` debug helper function:"
msgstr ""
"``walk`` itère sur les sous-parties de toute partie où :meth:`is_multipart` "
"renvoie ``True``, même si ``msg.get_content_maintype() == 'multipart'`` peut "
"renvoyer ``False``. Nous pouvons le voir dans notre exemple en utilisant la "
"fonction d'aide au débogage ``_structure`` :"

#: library/email.message.rst:509
msgid ""
">>> from email.iterators import _structure\n"
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"
msgstr ""

#: library/email.message.rst:531
msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into the "
"subparts."
msgstr ""
"Ici, les parties ``message`` ne sont pas des ``multiparts``, mais elles "
"contiennent des sous-parties. ``is_multipart()`` renvoie ``True`` et "
"``walk`` descend dans les sous-parties."

#: library/email.message.rst:538
msgid ""
"Return the MIME part that is the best candidate to be the \"body\" of the "
"message."
msgstr ""
"Renvoie la partie MIME qui est la meilleure candidate pour être le corps du "
"message."

#: library/email.message.rst:541
msgid ""
"*preferencelist* must be a sequence of strings from the set ``related``, "
"``html``, and ``plain``, and indicates the order of preference for the "
"content type of the part returned."
msgstr ""
"*preferencelist* doit être une séquence de chaînes de l'ensemble "
"``related``, ``html`` et ``plain``, et indique l'ordre de préférence pour le "
"type de contenu de la partie renvoyée."

#: library/email.message.rst:545
msgid ""
"Start looking for candidate matches with the object on which the "
"``get_body`` method is called."
msgstr ""
"Elle commence par rechercher des correspondances candidates avec l'objet sur "
"lequel la méthode ``get_body`` est appelée."

#: library/email.message.rst:548
msgid ""
"If ``related`` is not included in *preferencelist*, consider the root part "
"(or subpart of the root part) of any related encountered as a candidate if "
"the (sub-)part matches a preference."
msgstr ""
"Si ``related`` n'est pas inclus dans *preferencelist*, elle considère la "
"partie racine (ou sous-partie de la partie racine) de tout lien rencontré "
"comme candidat si la (sous-)partie correspond à une préférence."

#: library/email.message.rst:552
msgid ""
"When encountering a ``multipart/related``, check the ``start`` parameter and "
"if a part with a matching :mailheader:`Content-ID` is found, consider only "
"it when looking for candidate matches.  Otherwise consider only the first "
"(default root) part of the ``multipart/related``."
msgstr ""
"Lorsqu'elle rencontre un ``multipart/related``, elle vérifie le paramètre "
"``start`` et si une partie avec un :mailheader:`Content-ID` correspondant "
"est trouvée, elle la considère uniquement lors de la recherche de "
"correspondances candidates. Sinon, elle ne considère que la première partie "
"(racine par défaut) de ``multipart/related``."

#: library/email.message.rst:557
msgid ""
"If a part has a :mailheader:`Content-Disposition` header, only consider the "
"part a candidate match if the value of the header is ``inline``."
msgstr ""
"Si une partie a un en-tête :mailheader:`Content-Disposition`, elle ne "
"considère la partie comme une correspondance candidate que si la valeur de "
"l'en-tête est ``inline``."

#: library/email.message.rst:560
msgid ""
"If none of the candidates matches any of the preferences in "
"*preferencelist*, return ``None``."
msgstr ""
"Si aucun des candidats ne correspond à aucune des préférences dans "
"*preferencelist*, elle renvoie ``None``."

#: library/email.message.rst:563
msgid ""
"Notes: (1) For most applications the only *preferencelist* combinations that "
"really make sense are ``('plain',)``, ``('html', 'plain')``, and the default "
"``('related', 'html', 'plain')``.  (2) Because matching starts with the "
"object on which ``get_body`` is called, calling ``get_body`` on a "
"``multipart/related`` will return the object itself unless *preferencelist* "
"has a non-default value. (3) Messages (or message parts) that do not specify "
"a :mailheader:`Content-Type` or whose :mailheader:`Content-Type` header is "
"invalid will be treated as if they are of type ``text/plain``, which may "
"occasionally cause ``get_body`` to return unexpected results."
msgstr ""
"Remarques : (1) Pour la plupart des applications, les seules combinaisons "
"*preferencelist* qui ont vraiment un sens sont ``('plain',)``, ``('html', "
"'plain')`` et la valeur par défaut ``( 'related', 'html', 'plain')``. (2) "
"Parce que la correspondance commence avec l'objet sur lequel ``get_body`` "
"est appelée, appeler ``get_body`` sur un ``multipart/related`` renvoie "
"l'objet lui-même à moins que *preferencelist* n'ait une valeur autre que "
"celle par défaut. (3) Les messages (ou parties de message) qui ne spécifient "
"pas un :mailheader:`Content-Type` ou dont l'en-tête :mailheader:`Content-"
"Type` est invalide sont traités comme s'ils étaient de type ``text/plain``, "
"ce qui peut occasionnellement amener ``get_body`` à renvoyer des résultats "
"inattendus."

#: library/email.message.rst:577
msgid ""
"Return an iterator over all of the immediate sub-parts of the message that "
"are not candidate \"body\" parts.  That is, skip the first occurrence of "
"each of ``text/plain``, ``text/html``, ``multipart/related``, or ``multipart/"
"alternative`` (unless they are explicitly marked as attachments via :"
"mailheader:`Content-Disposition: attachment`), and return all remaining "
"parts.  When applied directly to a ``multipart/related``, return an iterator "
"over the all the related parts except the root part (ie: the part pointed to "
"by the ``start`` parameter, or the first part if there is no ``start`` "
"parameter or the ``start`` parameter doesn't match the :mailheader:`Content-"
"ID` of any of the parts).  When applied directly to a ``multipart/"
"alternative`` or a non-``multipart``, return an empty iterator."
msgstr ""
"Renvoie un itérateur sur toutes les sous-parties immédiates du message qui "
"ne sont pas des parties de « corps » candidates. Autrement dit, elle ignore "
"la première occurrence de chacun des éléments suivants : ``text/plain``, "
"``text/html``, ``multipart/related`` ou ``multipart/alternative`` (sauf "
"s'ils sont explicitement marqués comme pièces jointes via :mailheader:"
"`Content-Disposition: attachment`), et renvoie toutes les parties restantes. "
"Lorsqu'elle est appliquée directement à un ``multipart/related``, renvoie un "
"itérateur sur toutes les parties liées sauf la partie racine (c'est-à-dire "
"la partie pointée par le paramètre ``start``, ou la première partie s'il n'y "
"a pas de paramètre ``start`` ou si le paramètre ``start`` ne correspond pas "
"au :mailheader:`Content-ID` de l'une des parties). Lorsqu'elle est appliquée "
"directement à un ``multipart/alternative`` ou à un non-``multipart``, elle "
"renvoie un itérateur vide."

#: library/email.message.rst:593
msgid ""
"Return an iterator over all of the immediate sub-parts of the message, which "
"will be empty for a non-``multipart``.  (See also :meth:`~email.message."
"EmailMessage.walk`.)"
msgstr ""
"Renvoie un itérateur sur toutes les sous-parties immédiates du message, qui "
"seront vides pour une non-``multipart`` (voir aussi :meth:`~email.message."
"EmailMessage.walk`)."

#: library/email.message.rst:600
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.get_content` method of "
"the *content_manager*, passing self as the message object, and passing along "
"any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`."
msgstr ""
"Appelle la méthode :meth:`~email.contentmanager.ContentManager.get_content` "
"du *content_manager*, en passant *self* comme objet message et en passant "
"tout autre argument ou mot-clé comme argument supplémentaire. Si "
"*content_manager* n'est pas spécifié, utilise le ``content_manager`` "
"spécifié par la :mod:`~email.policy` actuelle."

#: library/email.message.rst:609
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.set_content` method of "
"the *content_manager*, passing self as the message object, and passing along "
"any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`."
msgstr ""
"Appelle la méthode :meth:`~email.contentmanager.ContentManager.set_content` "
"du *content_manager*, en passant *self* comme objet message et en passant "
"tout autre argument ou mot-clé comme argument supplémentaire. Si "
"*content_manager* n'est pas spécifié, utilise le ``content_manager`` "
"spécifié par la :mod:`~email.policy` actuelle."

#: library/email.message.rst:618
msgid ""
"Convert a non-``multipart`` message into a ``multipart/related`` message, "
"moving any existing :mailheader:`Content-` headers and payload into a (new) "
"first part of the ``multipart``.  If *boundary* is specified, use it as the "
"boundary string in the multipart, otherwise leave the boundary to be "
"automatically created when it is needed (for example, when the message is "
"serialized)."
msgstr ""
"Convertit un message non-``multipart`` en un message ``multipart/related``, "
"en déplaçant tous les en-têtes :mailheader:`Content-` existants et la charge "
"utile dans une (nouvelle) première partie du ``multipart``. Si *boundary* "
"est spécifié, elle l'utilise comme chaîne de délimitation dans le "
"*multipart*, sinon elle laisse la délimitation être créée automatiquement "
"lorsque cela est nécessaire (par exemple, lorsque le message est sérialisé)."

#: library/email.message.rst:628
msgid ""
"Convert a non-``multipart`` or a ``multipart/related`` into a ``multipart/"
"alternative``, moving any existing :mailheader:`Content-` headers and "
"payload into a (new) first part of the ``multipart``.  If *boundary* is "
"specified, use it as the boundary string in the multipart, otherwise leave "
"the boundary to be automatically created when it is needed (for example, "
"when the message is serialized)."
msgstr ""
"Convertit un non-``multipart`` ou un ``multipart/related`` en un ``multipart/"
"alternative``, en déplaçant tous les en-têtes :mailheader:`Content-` "
"existants et la charge utile dans une (nouvelle) première partie du "
"``multipart``. Si *boundary* est spécifiée, l'utilise comme chaîne de "
"délimitation dans le *multipart*, sinon laisse la délimitation être créée "
"automatiquement lorsque cela est nécessaire (par exemple, lorsque le message "
"est sérialisé)."

#: library/email.message.rst:638
msgid ""
"Convert a non-``multipart``, a ``multipart/related``, or a ``multipart-"
"alternative`` into a ``multipart/mixed``, moving any existing :mailheader:"
"`Content-` headers and payload into a (new) first part of the "
"``multipart``.  If *boundary* is specified, use it as the boundary string in "
"the multipart, otherwise leave the boundary to be automatically created when "
"it is needed (for example, when the message is serialized)."
msgstr ""
"Convertit un non-``multipart``, un ``multipart/related`` ou un ``multipart-"
"alternative`` en un ``multipart/mixed``, en déplaçant tous les en-têtes :"
"mailheader:`Content-` existants et charge utile dans une (nouvelle) première "
"partie du ``multipart``. Si *boundary* est spécifiée, l'utilise comme chaîne "
"de délimitation dans le *multipart*, sinon elle laisse la délimitation être "
"créée automatiquement lorsque cela est nécessaire (par exemple, lorsque le "
"message est sérialisé)."

#: library/email.message.rst:648
msgid ""
"If the message is a ``multipart/related``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and :meth:`~email."
"message.Message.attach` it to the ``multipart``.  If the message is a non-"
"``multipart``, call :meth:`make_related` and then proceed as above.  If the "
"message is any other type of ``multipart``, raise a :exc:`TypeError`. If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`. If the added part has no :mailheader:"
"`Content-Disposition` header, add one with the value ``inline``."
msgstr ""
"Si le message est un ``multipart/related``, crée un nouvel objet message, "
"passe tous les arguments à sa méthode :meth:`set_content` et le joint avec :"
"meth:`~email.message.Message.attach` au ``multipart``. Si le message n'est "
"pas en ``multipart``, appelle :meth:`make_related` puis procède comme ci-"
"dessus. Si le message est un autre type de ``multipart``, lève une :exc:"
"`TypeError`. Si *content_manager* n'est pas spécifié, utilise le "
"``content_manager`` spécifié par la :mod:`~email.policy` actuelle. Si la "
"partie ajoutée n'a pas d'en-tête :mailheader:`Content-Disposition`, en "
"ajoute un avec la valeur ``inline``."

#: library/email.message.rst:661
msgid ""
"If the message is a ``multipart/alternative``, create a new message object, "
"pass all of the arguments to its :meth:`set_content` method, and :meth:"
"`~email.message.Message.attach` it to the ``multipart``.  If the message is "
"a non-``multipart`` or ``multipart/related``, call :meth:`make_alternative` "
"and then proceed as above.  If the message is any other type of "
"``multipart``, raise a :exc:`TypeError`. If *content_manager* is not "
"specified, use the ``content_manager`` specified by the current :mod:`~email."
"policy`."
msgstr ""
"Si le message est un ``multipart/alternative``, crée un nouvel objet "
"message, transmet tous les arguments à sa méthode :meth:`set_content` et le "
"joint avec :meth:`~email.message.Message.attach` au ``multipart``. Si le "
"message est non-``multipart`` ou ``multipart/related``, appelle :meth:"
"`make_alternative` puis procède comme ci-dessus. Si le message est un autre "
"type de ``multipart``, lève une :exc:`TypeError`. Si *content_manager* n'est "
"pas spécifié, utilise le ``content_manager`` spécifié par la :mod:`~email."
"policy` actuelle."

#: library/email.message.rst:673
msgid ""
"If the message is a ``multipart/mixed``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and :meth:`~email."
"message.Message.attach` it to the ``multipart``.  If the message is a non-"
"``multipart``, ``multipart/related``, or ``multipart/alternative``, call :"
"meth:`make_mixed` and then proceed as above. If *content_manager* is not "
"specified, use the ``content_manager`` specified by the current :mod:`~email."
"policy`.  If the added part has no :mailheader:`Content-Disposition` header, "
"add one with the value ``attachment``.  This method can be used both for "
"explicit attachments (:mailheader:`Content-Disposition: attachment`) and "
"``inline`` attachments (:mailheader:`Content-Disposition: inline`), by "
"passing appropriate options to the ``content_manager``."
msgstr ""
"Si le message est un ``multipart/mixed``, crée un nouvel objet message, "
"passe tous les arguments à sa méthode :meth:`set_content` et le joint avec :"
"meth:`~email.message.Message.attach` au ``multipart``. Si le message n'est "
"pas en ``multipart``, ``multipart/related`` ou ``multipart/alternative``, "
"appelle :meth:`make_mixed` puis procède comme ci-dessus. Si "
"*content_manager* n'est pas spécifié, utilise le ``content_manager`` "
"spécifié par la :mod:`~email.policy` actuelle. Si la partie ajoutée n'a pas "
"d'en-tête :mailheader:`Content-Disposition`, en ajoute un avec la valeur "
"``attachment``. Cette méthode peut être utilisée à la fois pour les pièces "
"jointes explicites (:mailheader:`Content-Disposition:attachment`) et les "
"pièces jointes ``inline`` (:mailheader:`Content-Disposition:inline`), en "
"passant les options appropriées au ``content_manager``."

#: library/email.message.rst:689
msgid "Remove the payload and all of the headers."
msgstr "Supprime la charge utile et tous les en-têtes."

#: library/email.message.rst:694
#, fuzzy
msgid ""
"Remove the payload and all of the :mailheader:`!Content-` headers, leaving "
"all other headers intact and in their original order."
msgstr ""
"Supprime la charge utile et tous les en-têtes :exc:`Content-`, en laissant "
"tous les autres en-têtes intacts et dans leur ordre d'origine."

#: library/email.message.rst:698
msgid ":class:`EmailMessage` objects have the following instance attributes:"
msgstr ""
"Les objets :class:`EmailMessage` ont les attributs d'instance suivants :"

#: library/email.message.rst:703
msgid ""
"The format of a MIME document allows for some text between the blank line "
"following the headers, and the first multipart boundary string. Normally, "
"this text is never visible in a MIME-aware mail reader because it falls "
"outside the standard MIME armor.  However, when viewing the raw text of the "
"message, or when viewing the message in a non-MIME aware reader, this text "
"can become visible."
msgstr ""
"Le format d'un document MIME permet d'insérer du texte entre la ligne vide "
"suivant les en-têtes et la première chaîne de délimitation en plusieurs "
"parties. Normalement, ce texte n'est jamais visible dans un lecteur de "
"courrier compatible MIME car il ne fait pas partie de l'attirail MIME "
"standard. Toutefois, lors de l'affichage du texte brut du message ou lors de "
"l'affichage du message dans un lecteur non compatible MIME, ce texte peut "
"devenir visible."

#: library/email.message.rst:710
msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text after "
"the headers but before the first boundary string, it assigns this text to "
"the message's *preamble* attribute.  When the :class:`~email.generator."
"Generator` is writing out the plain text representation of a MIME message, "
"and it finds the message has a *preamble* attribute, it will write this text "
"in the area between the headers and the first boundary.  See :mod:`email."
"parser` and :mod:`email.generator` for details."
msgstr ""
"L'attribut *preamble* contient ce texte hors cadre de tête pour les "
"documents MIME. Lorsque :class:`~email.parser.Parser` découvre du texte "
"après les en-têtes mais avant la première chaîne de délimitation, il "
"attribue ce texte à l'attribut *preamble* du message. Lorsque :class:`~email."
"generator.Generator` écrit la représentation en texte brut d'un message "
"MIME, et qu'il trouve que le message a un attribut *preamble*, il écrit ce "
"texte dans la zone entre les en-têtes et la première limite. Voir :mod:"
"`email.parser` et :mod:`email.generator` pour plus de détails."

#: library/email.message.rst:720
msgid ""
"Note that if the message object has no preamble, the *preamble* attribute "
"will be ``None``."
msgstr ""
"Notez que si l'objet message n'a pas de préambule, l'attribut *preamble* est "
"``None``."

#: library/email.message.rst:726
msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and the "
"end of the message.  As with the :attr:`~EmailMessage.preamble`, if there is "
"no epilog text this attribute will be ``None``."
msgstr ""
"L'attribut *epilogue* agit de la même manière que l'attribut *preamble*, "
"sauf qu'il contient du texte qui apparaît entre la dernière limite et la fin "
"du message. Comme avec :attr:`~EmailMessage.preamble`, s'il n'y a pas de "
"texte d'épilogue, cet attribut est ``None``."

#: library/email.message.rst:734
msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description of "
"the possible parsing defects."
msgstr ""
"L'attribut *defects* contient une liste de tous les problèmes rencontrés "
"lors de l'analyse de ce message. Voir :mod:`email.errors` pour une "
"description détaillée des défauts d'analyse possibles."

#: library/email.message.rst:741
msgid ""
"This class represents a subpart of a MIME message.  It is identical to :"
"class:`EmailMessage`, except that no :mailheader:`MIME-Version` headers are "
"added when :meth:`~EmailMessage.set_content` is called, since sub-parts do "
"not need their own :mailheader:`MIME-Version` headers."
msgstr ""
"Cette classe représente une sous-partie d'un message MIME. Elle est "
"identique à :class:`EmailMessage`, sauf qu'aucun en-tête :mailheader:`MIME-"
"Version` n'est ajouté lorsque :meth:`~EmailMessage.set_content` est appelée, "
"car les sous-parties n'ont pas besoin de leurs propres en-têtes :mailheader:"
"`MIME-Version`."

#: library/email.message.rst:748
msgid "Footnotes"
msgstr "Notes"

#: library/email.message.rst:749
msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional "
"package>`.  Docs for legacy message class moved to :ref:`compat32_message`."
msgstr ""
"Ajouté à l'origine dans 3.4 en tant que :term:`module provisoire <paquet "
"provisoire>`. Les documents pour la classe de message héritée ont été "
"déplacés dans :ref:`compat32_message`."
