# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2023-02-17 14:44+0100\n"
"Last-Translator: \n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0.1\n"

#: library/email.examples.rst:4
msgid ":mod:`email`: Examples"
msgstr ":mod:`email`: Exemples"

#: library/email.examples.rst:6
msgid ""
"Here are a few examples of how to use the :mod:`email` package to read, "
"write, and send simple email messages, as well as more complex MIME messages."
msgstr ""
"Cette page contient quelques exemples de l'utilisation du package :mod:"
"`email` pour lire, écrire, et envoyer de simples messages mail, ainsi que "
"des messages MIME plus complexes."

#: library/email.examples.rst:9
msgid ""
"First, let's see how to create and send a simple text message (both the text "
"content and the addresses may contain unicode characters):"
msgstr ""
"Premièrement, regardons comment créer et envoyer un message avec simplement "
"du texte (le contenu textuel et les adresses peuvent tous deux contenir des "
"caractères Unicodes) :"

#: library/email.examples.rst:12
msgid ""
"# Import smtplib for the actual sending function\n"
"import smtplib\n"
"\n"
"# Import the email modules we'll need\n"
"from email.message import EmailMessage\n"
"\n"
"# Open the plain text file whose name is in textfile for reading.\n"
"with open(textfile) as fp:\n"
"    # Create a text/plain message\n"
"    msg = EmailMessage()\n"
"    msg.set_content(fp.read())\n"
"\n"
"# me == the sender's email address\n"
"# you == the recipient's email address\n"
"msg['Subject'] = f'The contents of {textfile}'\n"
"msg['From'] = me\n"
"msg['To'] = you\n"
"\n"
"# Send the message via our own SMTP server.\n"
"s = smtplib.SMTP('localhost')\n"
"s.send_message(msg)\n"
"s.quit()\n"
msgstr ""

#: library/email.examples.rst:15
msgid ""
"Parsing :rfc:`822` headers can easily be done by the using the classes from "
"the :mod:`~email.parser` module:"
msgstr ""
"Analyser des entêtes :rfc:`822` peut être aisément réalisé en utilisant les "
"classes du module :mod:`~email.parser` :"

#: library/email.examples.rst:18
msgid ""
"# Import the email modules we'll need\n"
"#from email.parser import BytesParser\n"
"from email.parser import Parser\n"
"from email.policy import default\n"
"\n"
"# If the e-mail headers are in a file, uncomment these two lines:\n"
"# with open(messagefile, 'rb') as fp:\n"
"#     headers = BytesParser(policy=default).parse(fp)\n"
"\n"
"#  Or for parsing headers in a string (this is an uncommon operation), use:\n"
"headers = Parser(policy=default).parsestr(\n"
"        'From: Foo Bar <user@example.com>\\n'\n"
"        'To: <someone_else@example.com>\\n'\n"
"        'Subject: Test message\\n'\n"
"        '\\n'\n"
"        'Body would go here\\n')\n"
"\n"
"#  Now the header items can be accessed as a dictionary:\n"
"print('To: {}'.format(headers['to']))\n"
"print('From: {}'.format(headers['from']))\n"
"print('Subject: {}'.format(headers['subject']))\n"
"\n"
"# You can also access the parts of the addresses:\n"
"print('Recipient username: {}'.format(headers['to'].addresses[0].username))\n"
"print('Sender name: {}'.format(headers['from'].addresses[0].display_name))\n"
msgstr ""

#: library/email.examples.rst:21
msgid ""
"Here's an example of how to send a MIME message containing a bunch of family "
"pictures that may be residing in a directory:"
msgstr ""
"Voici un exemple de l'envoi d'un message MIME contenant une série de photos "
"de famille qui sont stockés ensemble dans un dossier :"

#: library/email.examples.rst:24
msgid ""
"# Import smtplib for the actual sending function.\n"
"import smtplib\n"
"\n"
"# Here are the email package modules we'll need.\n"
"from email.message import EmailMessage\n"
"\n"
"# Create the container email message.\n"
"msg = EmailMessage()\n"
"msg['Subject'] = 'Our family reunion'\n"
"# me == the sender's email address\n"
"# family = the list of all recipients' email addresses\n"
"msg['From'] = me\n"
"msg['To'] = ', '.join(family)\n"
"msg.preamble = 'You will not see this in a MIME-aware mail reader.\\n'\n"
"\n"
"# Open the files in binary mode.  You can also omit the subtype\n"
"# if you want MIMEImage to guess it.\n"
"for file in pngfiles:\n"
"    with open(file, 'rb') as fp:\n"
"        img_data = fp.read()\n"
"    msg.add_attachment(img_data, maintype='image',\n"
"                                 subtype='png')\n"
"\n"
"# Send the email via our own SMTP server.\n"
"with smtplib.SMTP('localhost') as s:\n"
"    s.send_message(msg)\n"
msgstr ""

#: library/email.examples.rst:27
msgid ""
"Here's an example of how to send the entire contents of a directory as an "
"email message: [1]_"
msgstr ""
"Voici un exemple d'envoi du contenu d'un dossier entier en tant que message "
"mail : [1]_"

#: library/email.examples.rst:30
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"\"\"\"Send the contents of a directory as a MIME message.\"\"\"\n"
"\n"
"import os\n"
"import smtplib\n"
"# For guessing MIME type based on file name extension\n"
"import mimetypes\n"
"\n"
"from argparse import ArgumentParser\n"
"\n"
"from email.message import EmailMessage\n"
"from email.policy import SMTP\n"
"\n"
"\n"
"def main():\n"
"    parser = ArgumentParser(description=\"\"\"\\\n"
"Send the contents of a directory as a MIME message.\n"
"Unless the -o option is given, the email is sent by forwarding to your "
"local\n"
"SMTP server, which then does the normal delivery process.  Your local "
"machine\n"
"must be running an SMTP server.\n"
"\"\"\")\n"
"    parser.add_argument('-d', '--directory',\n"
"                        help=\"\"\"Mail the contents of the specified "
"directory,\n"
"                        otherwise use the current directory.  Only the "
"regular\n"
"                        files in the directory are sent, and we don't "
"recurse to\n"
"                        subdirectories.\"\"\")\n"
"    parser.add_argument('-o', '--output',\n"
"                        metavar='FILE',\n"
"                        help=\"\"\"Print the composed message to FILE "
"instead of\n"
"                        sending the message to the SMTP server.\"\"\")\n"
"    parser.add_argument('-s', '--sender', required=True,\n"
"                        help='The value of the From: header (required)')\n"
"    parser.add_argument('-r', '--recipient', required=True,\n"
"                        action='append', metavar='RECIPIENT',\n"
"                        default=[], dest='recipients',\n"
"                        help='A To: header value (at least one required)')\n"
"    args = parser.parse_args()\n"
"    directory = args.directory\n"
"    if not directory:\n"
"        directory = '.'\n"
"    # Create the message\n"
"    msg = EmailMessage()\n"
"    msg['Subject'] = f'Contents of directory {os.path.abspath(directory)}'\n"
"    msg['To'] = ', '.join(args.recipients)\n"
"    msg['From'] = args.sender\n"
"    msg.preamble = 'You will not see this in a MIME-aware mail reader.\\n'\n"
"\n"
"    for filename in os.listdir(directory):\n"
"        path = os.path.join(directory, filename)\n"
"        if not os.path.isfile(path):\n"
"            continue\n"
"        # Guess the content type based on the file's extension.  Encoding\n"
"        # will be ignored, although we should check for simple things like\n"
"        # gzip'd or compressed files.\n"
"        ctype, encoding = mimetypes.guess_type(path)\n"
"        if ctype is None or encoding is not None:\n"
"            # No guess could be made, or the file is encoded (compressed), "
"so\n"
"            # use a generic bag-of-bits type.\n"
"            ctype = 'application/octet-stream'\n"
"        maintype, subtype = ctype.split('/', 1)\n"
"        with open(path, 'rb') as fp:\n"
"            msg.add_attachment(fp.read(),\n"
"                               maintype=maintype,\n"
"                               subtype=subtype,\n"
"                               filename=filename)\n"
"    # Now send or store the message\n"
"    if args.output:\n"
"        with open(args.output, 'wb') as fp:\n"
"            fp.write(msg.as_bytes(policy=SMTP))\n"
"    else:\n"
"        with smtplib.SMTP('localhost') as s:\n"
"            s.send_message(msg)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""

#: library/email.examples.rst:33
msgid ""
"Here's an example of how to unpack a MIME message like the one above, into a "
"directory of files:"
msgstr ""
"Voici un exemple de comment décomposer un message MIME comme celui ci-dessus "
"en tant que fichiers dans un dossier :"

#: library/email.examples.rst:36
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"\"\"\"Unpack a MIME message into a directory of files.\"\"\"\n"
"\n"
"import os\n"
"import email\n"
"import mimetypes\n"
"\n"
"from email.policy import default\n"
"\n"
"from argparse import ArgumentParser\n"
"\n"
"\n"
"def main():\n"
"    parser = ArgumentParser(description=\"\"\"\\\n"
"Unpack a MIME message into a directory of files.\n"
"\"\"\")\n"
"    parser.add_argument('-d', '--directory', required=True,\n"
"                        help=\"\"\"Unpack the MIME message into the named\n"
"                        directory, which will be created if it doesn't "
"already\n"
"                        exist.\"\"\")\n"
"    parser.add_argument('msgfile')\n"
"    args = parser.parse_args()\n"
"\n"
"    with open(args.msgfile, 'rb') as fp:\n"
"        msg = email.message_from_binary_file(fp, policy=default)\n"
"\n"
"    try:\n"
"        os.mkdir(args.directory)\n"
"    except FileExistsError:\n"
"        pass\n"
"\n"
"    counter = 1\n"
"    for part in msg.walk():\n"
"        # multipart/* are just containers\n"
"        if part.get_content_maintype() == 'multipart':\n"
"            continue\n"
"        # Applications should really sanitize the given filename so that an\n"
"        # email message can't be used to overwrite important files\n"
"        filename = part.get_filename()\n"
"        if not filename:\n"
"            ext = mimetypes.guess_extension(part.get_content_type())\n"
"            if not ext:\n"
"                # Use a generic bag-of-bits extension\n"
"                ext = '.bin'\n"
"            filename = f'part-{counter:03d}{ext}'\n"
"        counter += 1\n"
"        with open(os.path.join(args.directory, filename), 'wb') as fp:\n"
"            fp.write(part.get_payload(decode=True))\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""

#: library/email.examples.rst:39
msgid ""
"Here's an example of how to create an HTML message with an alternative plain "
"text version.  To make things a bit more interesting, we include a related "
"image in the html part, and we save a copy of what we are going to send to "
"disk, as well as sending it."
msgstr ""
"Voici un exemple de création d'un message HTML avec une version en texte "
"comme alternative. Pour rendre les choses un peu plus intéressantes, nous "
"incluons aussi une image dans la partie HTML, nous sauvons une copie du "
"message sur le disque, et nous l'envoyons."

#: library/email.examples.rst:44
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"import smtplib\n"
"\n"
"from email.message import EmailMessage\n"
"from email.headerregistry import Address\n"
"from email.utils import make_msgid\n"
"\n"
"# Create the base text message.\n"
"msg = EmailMessage()\n"
"msg['Subject'] = \"Ayons asperges pour le déjeuner\"\n"
"msg['From'] = Address(\"Pepé Le Pew\", \"pepe\", \"example.com\")\n"
"msg['To'] = (Address(\"Penelope Pussycat\", \"penelope\", \"example.com\"),\n"
"             Address(\"Fabrette Pussycat\", \"fabrette\", \"example.com\"))\n"
"msg.set_content(\"\"\"\\\n"
"Salut!\n"
"\n"
"Cela ressemble à un excellent recipie[1] déjeuner.\n"
"\n"
"[1] http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718\n"
"\n"
"--Pepé\n"
"\"\"\")\n"
"\n"
"# Add the html version.  This converts the message into a multipart/"
"alternative\n"
"# container, with the original text message as the first part and the new "
"html\n"
"# message as the second part.\n"
"asparagus_cid = make_msgid()\n"
"msg.add_alternative(\"\"\"\\\n"
"<html>\n"
"  <head></head>\n"
"  <body>\n"
"    <p>Salut!</p>\n"
"    <p>Cela ressemble à un excellent\n"
"        <a href=\"http://www.yummly.com/recipe/Roasted-Asparagus-"
"Epicurious-203718\">\n"
"            recipie\n"
"        </a> déjeuner.\n"
"    </p>\n"
"    <img src=\"cid:{asparagus_cid}\" />\n"
"  </body>\n"
"</html>\n"
"\"\"\".format(asparagus_cid=asparagus_cid[1:-1]), subtype='html')\n"
"# note that we needed to peel the <> off the msgid for use in the html.\n"
"\n"
"# Now add the related image to the html part.\n"
"with open(\"roasted-asparagus.jpg\", 'rb') as img:\n"
"    msg.get_payload()[1].add_related(img.read(), 'image', 'jpeg',\n"
"                                     cid=asparagus_cid)\n"
"\n"
"# Make a local copy of what we are going to send.\n"
"with open('outgoing.msg', 'wb') as f:\n"
"    f.write(bytes(msg))\n"
"\n"
"# Send the message via local SMTP server.\n"
"with smtplib.SMTP('localhost') as s:\n"
"    s.send_message(msg)\n"
msgstr ""

#: library/email.examples.rst:47
msgid ""
"If we were sent the message from the last example, here is one way we could "
"process it:"
msgstr ""
"Si on nous avait envoyé le message de l'exemple précédent, voici la manière "
"avec laquelle nous pourrions le traiter :"

#: library/email.examples.rst:50
msgid ""
"import os\n"
"import sys\n"
"import tempfile\n"
"import mimetypes\n"
"import webbrowser\n"
"\n"
"# Import the email modules we'll need\n"
"from email import policy\n"
"from email.parser import BytesParser\n"
"\n"
"\n"
"def magic_html_parser(html_text, partfiles):\n"
"    \"\"\"Return safety-sanitized html linked to partfiles.\n"
"\n"
"    Rewrite the href=\"cid:....\" attributes to point to the filenames in "
"partfiles.\n"
"    Though not trivial, this should be possible using html.parser.\n"
"    \"\"\"\n"
"    raise NotImplementedError(\"Add the magic needed\")\n"
"\n"
"\n"
"# In a real program you'd get the filename from the arguments.\n"
"with open('outgoing.msg', 'rb') as fp:\n"
"    msg = BytesParser(policy=policy.default).parse(fp)\n"
"\n"
"# Now the header items can be accessed as a dictionary, and any non-ASCII "
"will\n"
"# be converted to unicode:\n"
"print('To:', msg['to'])\n"
"print('From:', msg['from'])\n"
"print('Subject:', msg['subject'])\n"
"\n"
"# If we want to print a preview of the message content, we can extract "
"whatever\n"
"# the least formatted payload is and print the first three lines.  Of "
"course,\n"
"# if the message has no plain text part printing the first three lines of "
"html\n"
"# is probably useless, but this is just a conceptual example.\n"
"simplest = msg.get_body(preferencelist=('plain', 'html'))\n"
"print()\n"
"print(''.join(simplest.get_content().splitlines(keepends=True)[:3]))\n"
"\n"
"ans = input(\"View full message?\")\n"
"if ans.lower()[0] == 'n':\n"
"    sys.exit()\n"
"\n"
"# We can extract the richest alternative in order to display it:\n"
"richest = msg.get_body()\n"
"partfiles = {}\n"
"if richest['content-type'].maintype == 'text':\n"
"    if richest['content-type'].subtype == 'plain':\n"
"        for line in richest.get_content().splitlines():\n"
"            print(line)\n"
"        sys.exit()\n"
"    elif richest['content-type'].subtype == 'html':\n"
"        body = richest\n"
"    else:\n"
"        print(\"Don't know how to display {}\".format(richest."
"get_content_type()))\n"
"        sys.exit()\n"
"elif richest['content-type'].content_type == 'multipart/related':\n"
"    body = richest.get_body(preferencelist=('html'))\n"
"    for part in richest.iter_attachments():\n"
"        fn = part.get_filename()\n"
"        if fn:\n"
"            extension = os.path.splitext(part.get_filename())[1]\n"
"        else:\n"
"            extension = mimetypes.guess_extension(part.get_content_type())\n"
"        with tempfile.NamedTemporaryFile(suffix=extension, delete=False) as "
"f:\n"
"            f.write(part.get_content())\n"
"            # again strip the <> to go from email form of cid to html form.\n"
"            partfiles[part['content-id'][1:-1]] = f.name\n"
"else:\n"
"    print(\"Don't know how to display {}\".format(richest."
"get_content_type()))\n"
"    sys.exit()\n"
"with tempfile.NamedTemporaryFile(mode='w', delete=False) as f:\n"
"    f.write(magic_html_parser(body.get_content(), partfiles))\n"
"webbrowser.open(f.name)\n"
"os.remove(f.name)\n"
"for fn in partfiles.values():\n"
"    os.remove(fn)\n"
"\n"
"# Of course, there are lots of email messages that could break this simple\n"
"# minded program, but it will handle the most common ones.\n"
msgstr ""

#: library/email.examples.rst:52
msgid "Up to the prompt, the output from the above is:"
msgstr "La sortie textuelle du code ci dessus est :"

#: library/email.examples.rst:54
msgid ""
"To: Penelope Pussycat <penelope@example.com>, Fabrette Pussycat "
"<fabrette@example.com>\n"
"From: Pepé Le Pew <pepe@example.com>\n"
"Subject: Ayons asperges pour le déjeuner\n"
"\n"
"Salut!\n"
"\n"
"Cela ressemble à un excellent recipie[1] déjeuner."
msgstr ""

#: library/email.examples.rst:66
msgid "Footnotes"
msgstr "Notes"

#: library/email.examples.rst:67
msgid ""
"Thanks to Matthew Dixon Cowles for the original inspiration and examples."
msgstr ""
"Merci à Matthew Dixon Cowles pour l'inspiration originale et les exemples."
