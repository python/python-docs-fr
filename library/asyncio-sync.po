# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 22:40+0100\n"
"PO-Revision-Date: 2023-06-11 16:49+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/asyncio-sync.rst:7
msgid "Synchronization Primitives"
msgstr "Primitives de synchronisation"

#: library/asyncio-sync.rst:9
msgid "**Source code:** :source:`Lib/asyncio/locks.py`"
msgstr "**Code source :** :source:`Lib/asyncio/locks.py`"

#: library/asyncio-sync.rst:13
msgid ""
"asyncio synchronization primitives are designed to be similar to those of "
"the :mod:`threading` module with two important caveats:"
msgstr ""
"Les primitives de synchronisation *asyncio* sont conçues pour être "
"similaires à celles du module :mod:`threading` avec deux mises en garde "
"importantes :"

#: library/asyncio-sync.rst:16
msgid ""
"asyncio primitives are not thread-safe, therefore they should not be used "
"for OS thread synchronization (use :mod:`threading` for that);"
msgstr ""
"les primitives *asyncio* ne sont pas *thread-safe*, elles ne doivent donc "
"pas être utilisées pour la synchronisation des fils d'exécution du système "
"d'exploitation (utilisez :mod:`threading` pour cela) ;"

#: library/asyncio-sync.rst:20
msgid ""
"methods of these synchronization primitives do not accept the *timeout* "
"argument; use the :func:`asyncio.wait_for` function to perform operations "
"with timeouts."
msgstr ""
"les méthodes de ces primitives de synchronisation n'acceptent pas l'argument "
"*timeout* ; utilisez la fonction :func:`asyncio.wait_for` pour effectuer des "
"opérations avec des délais d'attente."

#: library/asyncio-sync.rst:24
msgid "asyncio has the following basic synchronization primitives:"
msgstr ""
"*asyncio* possède les primitives de synchronisation de base suivantes :"

#: library/asyncio-sync.rst:26
msgid ":class:`Lock`"
msgstr ":class:`Lock`"

#: library/asyncio-sync.rst:27
msgid ":class:`Event`"
msgstr ":class:`Event`"

#: library/asyncio-sync.rst:28
msgid ":class:`Condition`"
msgstr ":class:`Condition`"

#: library/asyncio-sync.rst:29
msgid ":class:`Semaphore`"
msgstr ":class:`Semaphore`"

#: library/asyncio-sync.rst:30
msgid ":class:`BoundedSemaphore`"
msgstr ":class:`BoundedSemaphore`"

#: library/asyncio-sync.rst:31
msgid ":class:`Barrier`"
msgstr ":class:`Barrier`"

#: library/asyncio-sync.rst:38
msgid "Lock"
msgstr "Verrou (*lock*)"

#: library/asyncio-sync.rst:42
msgid "Implements a mutex lock for asyncio tasks.  Not thread-safe."
msgstr ""
"Implémente un verrou exclusif (*mutex*) pour les tâches asynchrones. Ce "
"n'est pas compatible avec les programmes à fils d'exécution multiples."

#: library/asyncio-sync.rst:44
msgid ""
"An asyncio lock can be used to guarantee exclusive access to a shared "
"resource."
msgstr ""
"Un verrou *asyncio* peut être utilisé pour garantir un accès exclusif à une "
"ressource partagée."

#: library/asyncio-sync.rst:47
msgid "The preferred way to use a Lock is an :keyword:`async with` statement::"
msgstr ""
"La meilleure façon d'utiliser un verrou est une instruction :keyword:`async "
"with` ::"

#: library/asyncio-sync.rst:50
msgid ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"async with lock:\n"
"    # access shared state"
msgstr ""

#: library/asyncio-sync.rst:199 library/asyncio-sync.rst:304
msgid "which is equivalent to::"
msgstr "ce qui équivaut à ::"

#: library/asyncio-sync.rst:58
msgid ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"await lock.acquire()\n"
"try:\n"
"    # access shared state\n"
"finally:\n"
"    lock.release()"
msgstr ""

# suit un :
#: library/asyncio-sync.rst:112 library/asyncio-sync.rst:292
#: library/asyncio-sync.rst:347
msgid "Removed the *loop* parameter."
msgstr "suppression du paramètre *loop*."

#: library/asyncio-sync.rst:72
msgid "Acquire the lock."
msgstr "Verrouille (ou acquiert) le verrou."

#: library/asyncio-sync.rst:74
msgid ""
"This method waits until the lock is *unlocked*, sets it to *locked* and "
"returns ``True``."
msgstr ""
"Cette méthode attend que le verrou soit déverrouillé (*unlocked*), le "
"verrouille (positionné sur *locked*) et renvoie ``True``."

#: library/asyncio-sync.rst:77
msgid ""
"When more than one coroutine is blocked in :meth:`acquire` waiting for the "
"lock to be unlocked, only one coroutine eventually proceeds."
msgstr ""
"Lorsque plus d'une coroutine est bloquée dans :meth:`acquire` en attendant "
"que le verrou soit déverrouillé, seule une coroutine continue finalement."

#: library/asyncio-sync.rst:81
msgid ""
"Acquiring a lock is *fair*: the coroutine that proceeds will be the first "
"coroutine that started waiting on the lock."
msgstr ""
"L'acquisition d'un verrou est *équitable* : la coroutine qui acquiert le "
"verrou est celle qui était la première à attendre le verrou."

#: library/asyncio-sync.rst:86
msgid "Release the lock."
msgstr "Libère le verrou."

#: library/asyncio-sync.rst:88
msgid "When the lock is *locked*, reset it to *unlocked* and return."
msgstr "Lorsque le verrou est verrouillé, le déverrouille et termine."

#: library/asyncio-sync.rst:90
msgid "If the lock is *unlocked*, a :exc:`RuntimeError` is raised."
msgstr "Si le verrou est déjà déverrouillé, une :exc:`RuntimeError` est levée."

#: library/asyncio-sync.rst:94
msgid "Return ``True`` if the lock is *locked*."
msgstr "Renvoie ``True`` si le verrou est verrouillé."

#: library/asyncio-sync.rst:98
msgid "Event"
msgstr "Événement (*Event*)"

#: library/asyncio-sync.rst:102
msgid "An event object.  Not thread-safe."
msgstr ""
"Objet événement. Non compatible avec les programmes à plusieurs fils "
"d'exécution."

#: library/asyncio-sync.rst:104
msgid ""
"An asyncio event can be used to notify multiple asyncio tasks that some "
"event has happened."
msgstr ""
"Un événement asynchrone peut être utilisé pour notifier plusieurs tâches "
"asynchrones qu'un événement s'est produit."

#: library/asyncio-sync.rst:107
msgid ""
"An Event object manages an internal flag that can be set to *true* with the :"
"meth:`~Event.set` method and reset to *false* with the :meth:`clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is set to "
"*true*.  The flag is set to *false* initially."
msgstr ""
"Un objet *Event* gère un drapeau interne qui peut être activé (ou mis à "
"*vrai*) avec la méthode :meth:`~Event.set` et désactivé (ou mis à *faux*) "
"avec la méthode :meth:`clear`. La méthode :meth:`~Event.wait` se bloque "
"jusqu'à ce que l'indicateur soit activé. L'indicateur est initialement "
"désactivé."

#: library/asyncio-sync.rst:371
msgid "Example::"
msgstr "Exemple ::"

#: library/asyncio-sync.rst:119
msgid ""
"async def waiter(event):\n"
"    print('waiting for it ...')\n"
"    await event.wait()\n"
"    print('... got it!')\n"
"\n"
"async def main():\n"
"    # Create an Event object.\n"
"    event = asyncio.Event()\n"
"\n"
"    # Spawn a Task to wait until 'event' is set.\n"
"    waiter_task = asyncio.create_task(waiter(event))\n"
"\n"
"    # Sleep for 1 second and set the event.\n"
"    await asyncio.sleep(1)\n"
"    event.set()\n"
"\n"
"    # Wait until the waiter task is finished.\n"
"    await waiter_task\n"
"\n"
"asyncio.run(main())"
msgstr ""

#: library/asyncio-sync.rst:142
msgid "Wait until the event is set."
msgstr "Attend que l'évènement soit activé."

#: library/asyncio-sync.rst:144
msgid ""
"If the event is set, return ``True`` immediately. Otherwise block until "
"another task calls :meth:`~Event.set`."
msgstr ""
"Si l'événement est activé (*vrai*), renvoie ``True`` immédiatement. Sinon "
"bloque jusqu'à ce qu'une autre tâche appelle :meth:`~Event.set`."

#: library/asyncio-sync.rst:149
msgid "Set the event."
msgstr "Active l'événement."

#: library/asyncio-sync.rst:151
msgid "All tasks waiting for event to be set will be immediately awakened."
msgstr ""
"Toutes les tâches en attente de l'événement sont immédiatement réveillées."

#: library/asyncio-sync.rst:156
msgid "Clear (unset) the event."
msgstr "Efface (désactive) l'événement."

#: library/asyncio-sync.rst:158
msgid ""
"Tasks awaiting on :meth:`~Event.wait` will now block until the :meth:`~Event."
"set` method is called again."
msgstr ""
"Les tâches en attente sur :meth:`~Event.wait` seront désormais bloquées "
"jusqu'à ce que la méthode :meth:`~Event.set` soit à nouveau appelée."

#: library/asyncio-sync.rst:163
msgid "Return ``True`` if the event is set."
msgstr "Renvoie ``True`` si l'évènement est actif."

#: library/asyncio-sync.rst:167
msgid "Condition"
msgstr "Condition"

#: library/asyncio-sync.rst:171
msgid "A Condition object.  Not thread-safe."
msgstr ""
"Objet Condition. Non compatible avec les programmes à plusieurs fils "
"d'exécution."

#: library/asyncio-sync.rst:173
msgid ""
"An asyncio condition primitive can be used by a task to wait for some event "
"to happen and then get exclusive access to a shared resource."
msgstr ""
"Une primitive de condition asynchrone peut être utilisée par une tâche pour "
"attendre qu'un événement se produise, puis obtenir un accès exclusif à une "
"ressource partagée."

#: library/asyncio-sync.rst:177
msgid ""
"In essence, a Condition object combines the functionality of an :class:"
"`Event` and a :class:`Lock`.  It is possible to have multiple Condition "
"objects share one Lock, which allows coordinating exclusive access to a "
"shared resource between different tasks interested in particular states of "
"that shared resource."
msgstr ""
"Essentiellement, un objet *Condition* combine les fonctionnalités d'un :"
"class:`Event` et d'un :class:`Lock`. Il est possible que plusieurs objets "
"*Condition* partagent un seul verrou, ce qui permet de coordonner l'accès "
"exclusif à une ressource partagée entre différentes tâches intéressées par "
"des états particuliers de cette ressource partagée."

#: library/asyncio-sync.rst:183
msgid ""
"The optional *lock* argument must be a :class:`Lock` object or ``None``.  In "
"the latter case a new Lock object is created automatically."
msgstr ""
"L'argument optionnel *lock* doit être un objet :class:`Lock` ou ``None``. "
"Dans ce dernier cas, un nouvel objet *Lock* est créé automatiquement."

#: library/asyncio-sync.rst:190
msgid ""
"The preferred way to use a Condition is an :keyword:`async with` statement::"
msgstr ""
"La meilleure façon d'utiliser une *Condition* est une instruction :keyword:"
"`async with` ::"

#: library/asyncio-sync.rst:193
msgid ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"async with cond:\n"
"    await cond.wait()"
msgstr ""

#: library/asyncio-sync.rst:201
msgid ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"await cond.acquire()\n"
"try:\n"
"    await cond.wait()\n"
"finally:\n"
"    cond.release()"
msgstr ""

#: library/asyncio-sync.rst:212
msgid "Acquire the underlying lock."
msgstr "Verrouille le verrou sous-jacent."

#: library/asyncio-sync.rst:214
msgid ""
"This method waits until the underlying lock is *unlocked*, sets it to "
"*locked* and returns ``True``."
msgstr ""
"Cette méthode attend que le verrou sous-jacent soit déverrouillé, le "
"verrouille et renvoie ``True``."

#: library/asyncio-sync.rst:219
#, fuzzy
msgid ""
"Wake up *n* tasks (1 by default) waiting on this condition.  If fewer than "
"*n* tasks are waiting they are all awakened."
msgstr ""
"Réveille au plus *n* tâches (1 par défaut) en attente de cette condition. La "
"méthode ne fait rien si aucune tâche n'est en attente."

#: library/asyncio-sync.rst:237
msgid ""
"The lock must be acquired before this method is called and released shortly "
"after.  If called with an *unlocked* lock a :exc:`RuntimeError` error is "
"raised."
msgstr ""
"Le verrou doit être verrouillé avant que cette méthode ne soit appelée et "
"libéré peu de temps après. S'il est appelé avec un verrou déverrouillé, une "
"erreur :exc:`RuntimeError` est levée."

#: library/asyncio-sync.rst:228
msgid "Return ``True`` if the underlying lock is acquired."
msgstr "Renvoie ``True`` si le verrou sous-jacent est verrouillé."

#: library/asyncio-sync.rst:232
msgid "Wake up all tasks waiting on this condition."
msgstr "Réveille toutes les tâches en attente sur cette condition."

#: library/asyncio-sync.rst:234
msgid "This method acts like :meth:`notify`, but wakes up all waiting tasks."
msgstr ""
"Cette méthode agit comme :meth:`notify`, mais réveille toutes les tâches en "
"attente."

#: library/asyncio-sync.rst:243
msgid "Release the underlying lock."
msgstr "Libère le verrou sous-jacent."

#: library/asyncio-sync.rst:245
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""
"Lorsqu'elle est invoquée sur un verrou déverrouillé, une :exc:`RuntimeError` "
"est levée."

#: library/asyncio-sync.rst:250
msgid "Wait until notified."
msgstr "Attend d'être notifié."

#: library/asyncio-sync.rst:252
msgid ""
"If the calling task has not acquired the lock when this method is called, a :"
"exc:`RuntimeError` is raised."
msgstr ""
"Si la tâche appelante n'a pas verrouillé le verrou lorsque cette méthode est "
"appelée, une :exc:`RuntimeError` est levée."

#: library/asyncio-sync.rst:255
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call. Once awakened, the "
"Condition re-acquires its lock and this method returns ``True``."
msgstr ""
"Cette méthode libère le verrou sous-jacent, puis se bloque jusqu'à ce "
"qu'elle soit réveillée par un appel :meth:`notify` ou :meth:`notify_all`. "
"Une fois réveillée, la *Condition* verrouille à nouveau son verrou et cette "
"méthode renvoie ``True``."

#: library/asyncio-sync.rst:260
msgid ""
"Note that a task *may* return from this call spuriously, which is why the "
"caller should always re-check the state and be prepared to :meth:`wait` "
"again. For this reason, you may prefer to use :meth:`wait_for` instead."
msgstr ""

#: library/asyncio-sync.rst:267
msgid "Wait until a predicate becomes *true*."
msgstr "Attend jusqu'à ce qu'un prédicat devienne vrai."

#: library/asyncio-sync.rst:269
#, fuzzy
msgid ""
"The predicate must be a callable which result will be interpreted as a "
"boolean value.  The method will repeatedly :meth:`wait` until the predicate "
"evaluates to *true*. The final value is the return value."
msgstr ""
"Le prédicat doit être un appelable dont le résultat est interprété comme une "
"valeur booléenne. La valeur finale est la valeur de retour."

#: library/asyncio-sync.rst:276
msgid "Semaphore"
msgstr "Sémaphore"

#: library/asyncio-sync.rst:280
msgid "A Semaphore object.  Not thread-safe."
msgstr ""
"Objet *Sémaphore*. Non compatible avec les programmes à plusieurs fils "
"d'exécution."

#: library/asyncio-sync.rst:282
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`acquire` call and incremented by each :meth:`release` call. The counter can "
"never go below zero; when :meth:`acquire` finds that it is zero, it blocks, "
"waiting until some task calls :meth:`release`."
msgstr ""
"Un sémaphore gère un compteur interne qui est décrémenté à chaque appel :"
"meth:`acquire` et incrémenté à chaque appel :meth:`release`. Le compteur ne "
"peut jamais descendre en dessous de zéro ; quand :meth:`acquire` trouve "
"qu'il est égal à zéro, il se bloque, en attendant qu'une tâche appelle :meth:"
"`release`."

#: library/asyncio-sync.rst:288
msgid ""
"The optional *value* argument gives the initial value for the internal "
"counter (``1`` by default). If the given value is less than ``0`` a :exc:"
"`ValueError` is raised."
msgstr ""
"L'argument optionnel *value* donne la valeur initiale du compteur interne "
"(``1`` par défaut). Si la valeur donnée est inférieure à ``0`` une :exc:"
"`ValueError` est levée."

#: library/asyncio-sync.rst:295
msgid ""
"The preferred way to use a Semaphore is an :keyword:`async with` statement::"
msgstr ""
"La meilleure façon d'utiliser un sémaphore est une instruction :keyword:"
"`async with` ::"

#: library/asyncio-sync.rst:298
msgid ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"async with sem:\n"
"    # work with shared resource"
msgstr ""

#: library/asyncio-sync.rst:306
msgid ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"await sem.acquire()\n"
"try:\n"
"    # work with shared resource\n"
"finally:\n"
"    sem.release()"
msgstr ""

#: library/asyncio-sync.rst:317
msgid "Acquire a semaphore."
msgstr "Acquiert un sémaphore."

#: library/asyncio-sync.rst:319
msgid ""
"If the internal counter is greater than zero, decrement it by one and return "
"``True`` immediately.  If it is zero, wait until a :meth:`release` is called "
"and return ``True``."
msgstr ""
"Si le compteur interne est supérieur à zéro, le décrémente d'une unité et "
"renvoie ``True`` immédiatement. Si c'est zéro, attend que :meth:`release` "
"soit appelée et renvoie ``True``."

#: library/asyncio-sync.rst:325
msgid "Returns ``True`` if semaphore can not be acquired immediately."
msgstr ""
"Renvoie ``True`` si le sémaphore ne peut pas être acquis immédiatement."

#: library/asyncio-sync.rst:329
msgid ""
"Release a semaphore, incrementing the internal counter by one. Can wake up a "
"task waiting to acquire the semaphore."
msgstr ""
"Relâche un sémaphore, incrémentant le compteur interne d'une unité. Peut "
"réveiller une tâche en attente d'acquisition du sémaphore."

#: library/asyncio-sync.rst:332
msgid ""
"Unlike :class:`BoundedSemaphore`, :class:`Semaphore` allows making more "
"``release()`` calls than ``acquire()`` calls."
msgstr ""
"Contrairement à :class:`BoundedSemaphore`, :class:`Semaphore` permet de "
"faire plus d'appels ``release()`` que d'appels ``acquire()``."

#: library/asyncio-sync.rst:337
msgid "BoundedSemaphore"
msgstr "Sémaphore capé (*BoundedSemaphore*)"

#: library/asyncio-sync.rst:341
msgid "A bounded semaphore object.  Not thread-safe."
msgstr ""
"Objet sémaphore capé. Non compatible avec les programmes à plusieurs fils "
"d'exécution."

#: library/asyncio-sync.rst:343
msgid ""
"Bounded Semaphore is a version of :class:`Semaphore` that raises a :exc:"
"`ValueError` in :meth:`~Semaphore.release` if it increases the internal "
"counter above the initial *value*."
msgstr ""
"*Bounded Semaphore* est une version de :class:`Semaphore` qui lève une :exc:"
"`ValueError` dans :meth:`~Semaphore.release` s'il augmente le compteur "
"interne au-dessus de la *value* initiale."

#: library/asyncio-sync.rst:352
msgid "Barrier"
msgstr "Barrière (*Barrier*)"

#: library/asyncio-sync.rst:356
msgid "A barrier object.  Not thread-safe."
msgstr ""
"Objet barrière. Non compatible avec les programmes à plusieurs fils "
"d'exécution."

#: library/asyncio-sync.rst:358
msgid ""
"A barrier is a simple synchronization primitive that allows to block until "
"*parties* number of tasks are waiting on it. Tasks can wait on the :meth:"
"`~Barrier.wait` method and would be blocked until the specified number of "
"tasks end up waiting on :meth:`~Barrier.wait`. At that point all of the "
"waiting tasks would unblock simultaneously."
msgstr ""
"Une barrière est une simple primitive de synchronisation qui permet de "
"bloquer jusqu'à ce que *parties* tâches l'attendent. Les tâches attendent "
"sur la méthode :meth:`~Barrier.wait` et sont bloquées jusqu'à ce que le "
"nombre spécifié de tâches attendent sur :meth:`~Barrier.wait`. À ce stade, "
"toutes les tâches en attente se débloquent simultanément."

#: library/asyncio-sync.rst:364
msgid ""
":keyword:`async with` can be used as an alternative to awaiting on :meth:"
"`~Barrier.wait`."
msgstr ""
":keyword:`async with` peut être utilisé comme alternative à l'attente sur :"
"meth:`~Barrier.wait`."

#: library/asyncio-sync.rst:367
msgid "The barrier can be reused any number of times."
msgstr "La barrière peut être réutilisée un nombre illimité de fois."

#: library/asyncio-sync.rst:373
msgid ""
"async def example_barrier():\n"
"   # barrier with 3 parties\n"
"   b = asyncio.Barrier(3)\n"
"\n"
"   # create 2 new waiting tasks\n"
"   asyncio.create_task(b.wait())\n"
"   asyncio.create_task(b.wait())\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"   # The third .wait() call passes the barrier\n"
"   await b.wait()\n"
"   print(b)\n"
"   print(\"barrier passed\")\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"asyncio.run(example_barrier())"
msgstr ""

#: library/asyncio-sync.rst:394
msgid "Result of this example is::"
msgstr "Le résultat de cet exemple est ::"

#: library/asyncio-sync.rst:396
msgid ""
"<asyncio.locks.Barrier object at 0x... [filling, waiters:2/3]>\n"
"<asyncio.locks.Barrier object at 0x... [draining, waiters:0/3]>\n"
"barrier passed\n"
"<asyncio.locks.Barrier object at 0x... [filling, waiters:0/3]>"
msgstr ""

#: library/asyncio-sync.rst:405
msgid ""
"Pass the barrier. When all the tasks party to the barrier have called this "
"function, they are all unblocked simultaneously."
msgstr ""
"Passe la barrière. Lorsque toutes les tâches bloquées à la barrière ont "
"appelé cette fonction, elles sont toutes débloquées simultanément."

#: library/asyncio-sync.rst:408
msgid ""
"When a waiting or blocked task in the barrier is cancelled, this task exits "
"the barrier which stays in the same state. If the state of the barrier is "
"\"filling\", the number of waiting task decreases by 1."
msgstr ""
"Lorsqu'une tâche en attente ou bloquée à la barrière est annulée, cette "
"tâche sort de la barrière qui reste dans le même état. Si la barrière est en "
"cours de « remplissage », le nombre de tâche en attente diminue de 1."

#: library/asyncio-sync.rst:413
msgid ""
"The return value is an integer in the range of 0 to ``parties-1``, different "
"for each task. This can be used to select a task to do some special "
"housekeeping, e.g.::"
msgstr ""
"La valeur de retour est un entier compris entre 0 et ``parties-1``, "
"différent pour chaque tâche. Cela peut être utilisé pour sélectionner une "
"tâche qui fera du ménage, par exemple ::"

#: library/asyncio-sync.rst:417
msgid ""
"...\n"
"async with barrier as position:\n"
"   if position == 0:\n"
"      # Only one task prints this\n"
"      print('End of *draining phase*')"
msgstr ""

#: library/asyncio-sync.rst:423
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a task is waiting. It could raise a :exc:"
"`CancelledError` if a task is cancelled."
msgstr ""
"Cette méthode peut lever une exception :class:`BrokenBarrierError` si la "
"barrière est brisée ou réinitialisée alors qu'une tâche est en attente. Cela "
"peut lever une :exc:`CancelledError` si une tâche est annulée."

#: library/asyncio-sync.rst:429
msgid ""
"Return the barrier to the default, empty state.  Any tasks waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"Ramène la barrière à l'état vide par défaut. Toutes les tâches en attente "
"reçoivent l'exception :class:`BrokenBarrierError`."

#: library/asyncio-sync.rst:432
msgid ""
"If a barrier is broken it may be better to just leave it and create a new "
"one."
msgstr ""
"Si une barrière est brisée, il peut être préférable de la quitter et d'en "
"créer une nouvelle."

#: library/asyncio-sync.rst:436
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`. Use this for "
"example if one of the tasks needs to abort, to avoid infinite waiting tasks."
msgstr ""
"Met la barrière dans un état cassé. Cela provoque l'échec de tout appel "
"actif ou futur à :meth:`wait` avec une :class:`BrokenBarrierError`. Utilisez "
"ceci par exemple si l'une des tâches doit être abandonnée, pour éviter des "
"tâches en attente infinie."

#: library/asyncio-sync.rst:443
msgid "The number of tasks required to pass the barrier."
msgstr "Le nombre de tâches nécessaires pour franchir la barrière."

#: library/asyncio-sync.rst:447
msgid "The number of tasks currently waiting in the barrier while filling."
msgstr ""
"Le nombre de tâches actuellement en attente à la barrière pendant le "
"remplissage."

#: library/asyncio-sync.rst:451
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "Booléen qui vaut ``True`` si la barrière est rompue."

#: library/asyncio-sync.rst:456
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
"Cette exception, une sous-classe de :exc:`RuntimeError`, est déclenchée "
"lorsque l'objet :class:`Barrier` est réinitialisé ou cassé."

# suit un :
#: library/asyncio-sync.rst:464
msgid ""
"Acquiring a lock using ``await lock`` or ``yield from lock`` and/or :keyword:"
"`with` statement (``with await lock``, ``with (yield from lock)``) was "
"removed.  Use ``async with lock`` instead."
msgstr ""
"l'acquisition d'un verrou en utilisant ``wait lock`` ou ``yield from lock`` "
"ou :keyword:`with` (``with await lock``, ``with (yield from lock)``) a été "
"supprimée. Utilisez ``async with lock`` à la place."
