# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-01 00:16+0100\n"
"PO-Revision-Date: 2023-06-19 23:01+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "Transports et Protocoles"

#: library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "Préface"

#: library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"Les transports et les protocoles sont utilisés par les API de boucle "
"d'événements **de bas niveau** telles que :meth:`loop.create_connection`. "
"Ils utilisent un style de programmation basé sur les fonctions de rappel et "
"permettent des implémentations hautes performances de protocoles réseau (par "
"exemple, HTTP) ou de communication inter-processus (*IPC*)."

#: library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"Avant tout, les transports et les protocoles ne doivent être utilisés que "
"dans des bibliothèques et des cadriciels et jamais dans des applications "
"asynchrones de haut niveau."

#: library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr ""
"Cette page de documentation couvre à la fois `Transports`_ et `Protocoles`_."

#: library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "Introduction"

#: library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"Au plus haut niveau, le transport concerne *comment* les octets sont "
"transmis, tandis que le protocole détermine *quels* octets transmettre (et "
"dans une certaine mesure quand)."

#: library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"Pour l'écrire autrement : un transport est une abstraction pour un "
"connecteur (*socket* ou tout autre point de terminaison d'entrée-sortie) "
"tandis qu'un protocole est une abstraction pour une application, du point de "
"vue du transport."

#: library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"Encore une autre vue est que les interfaces de transport et de protocole "
"définissent ensemble une interface abstraite pour utiliser les entrées-"
"sorties réseau et les entrées-sorties inter-processus."

#: library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"Il existe toujours une relation 1:1 entre les objets de transport et de "
"protocole : le protocole appelle les méthodes de transport pour envoyer des "
"données, tandis que le transport appelle les méthodes de protocole pour lui "
"transmettre les données reçues."

#: library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"La plupart des méthodes de boucles d'événements orientées connexion (telles "
"que :meth:`loop.create_connection`) acceptent généralement un argument "
"*protocol_factory* utilisé pour créer un objet *Protocol* pour une connexion "
"acceptée, représentée par un objet *Transport*. De telles méthodes renvoient "
"généralement un *n*-uplet ``(transport, protocol)``."

#: library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "Sommaire"

#: library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "Cette page de documentation contient les sections suivantes :"

#: library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"La section `Transports`_ documente les classes *asyncio* :class:"
"`BaseTransport`, :class:`ReadTransport`, :class:`WriteTransport`, :class:"
"`Transport`, :class:`DatagramTransport` et :class:`SubprocessTransport`."

#: library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"La section `Protocols`_ documente les classes *asyncio* :class:"
"`BaseProtocol`, :class:`Protocol`, :class:`BufferedProtocol`, :class:"
"`DatagramProtocol` et :class:`SubprocessProtocol`."

#: library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"La section `Examples`_ montre comment utiliser les transports, les "
"protocoles et les API de boucle d'événements de bas niveau."

#: library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "Transports"

#: library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**Code source :** :source:`Lib/asyncio/transports.py`"

#: library/asyncio-protocol.rst:76
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"Les transports sont des classes fournies par :mod:`asyncio` afin d'abstraire "
"différents types de canaux de communication."

#: library/asyncio-protocol.rst:79
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"Les objets de transport sont toujours instanciés par une :ref:`boucle "
"d'événements asyncio <asyncio-event-loop>`."

#: library/asyncio-protocol.rst:82
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"*asyncio* implémente les transports pour TCP, UDP, SSL et les tubes de sous-"
"processus. Les méthodes disponibles sur un transport dépendent du type de "
"transport."

#: library/asyncio-protocol.rst:85
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"Les classes de transport ne sont :ref:`pas compatibles avec les fils "
"d'exécution multiples <asyncio-multithreading>`."

#: library/asyncio-protocol.rst:89
msgid "Transports Hierarchy"
msgstr "Hiérarchie des transports"

#: library/asyncio-protocol.rst:93
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"Classe de base pour tous les transports. Contient des méthodes partagées par "
"tous les transports *asyncio*."

#: library/asyncio-protocol.rst:98
msgid "A base transport for write-only connections."
msgstr "Transport de base pour les connexions en écriture seule."

#: library/asyncio-protocol.rst:100
msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Les instances de la classe *WriteTransport* sont renvoyées par la méthode de "
"boucle d'événements :meth:`loop.connect_write_pipe` et sont également "
"utilisées par les méthodes liées aux sous-processus comme :meth:`loop."
"subprocess_exec`."

#: library/asyncio-protocol.rst:107
msgid "A base transport for read-only connections."
msgstr "Transport de base pour les connexions en lecture seule."

#: library/asyncio-protocol.rst:109
msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Les instances de la classe *ReadTransport* sont renvoyées par la méthode de "
"boucle d'événements :meth:`loop.connect_read_pipe` et sont également "
"utilisées par les méthodes liées aux sous-processus comme :meth:`loop."
"subprocess_exec`."

#: library/asyncio-protocol.rst:116
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"Interface représentant un transport bidirectionnel, comme une connexion TCP."

#: library/asyncio-protocol.rst:119
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"L'utilisateur n'instancie pas un transport directement ; il appelle une "
"fonction utilitaire, lui transmettant une fabrique de protocoles et d'autres "
"informations nécessaires pour créer le transport et le protocole."

#: library/asyncio-protocol.rst:123
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"Les instances de la classe *Transport* sont renvoyées ou utilisées par des "
"méthodes de boucle d'événements comme :meth:`loop.create_connection`, :meth:"
"`loop.create_unix_connection`, :meth:`loop.create_server`, :meth:`loop."
"sendfile`, etc."

#: library/asyncio-protocol.rst:131
msgid "A transport for datagram (UDP) connections."
msgstr "Transport pour les connexions par datagrammes (UDP)."

#: library/asyncio-protocol.rst:133
msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"Les instances de la classe *DatagramTransport* sont renvoyées par la méthode "
"de boucle d'événements :meth:`loop.create_datagram_endpoint`."

#: library/asyncio-protocol.rst:139
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr ""
"Abstraction pour représenter une connexion entre un parent et son processus "
"enfant au niveau du système d'exploitation."

#: library/asyncio-protocol.rst:142
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"Les instances de la classe *SubprocessTransport* sont renvoyées par les "
"méthodes de boucle d'événements :meth:`loop.subprocess_shell` et :meth:`loop."
"subprocess_exec`."

#: library/asyncio-protocol.rst:148
msgid "Base Transport"
msgstr "Classe de base des Transports"

#: library/asyncio-protocol.rst:152
msgid "Close the transport."
msgstr "Ferme le transport."

#: library/asyncio-protocol.rst:154
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument. The transport should not be used once it is closed."
msgstr ""
"Si le transport a une mémoire tampon pour les données sortantes, les données "
"mises en mémoire tampon seront vidées de manière asynchrone. Aucune autre "
"donnée ne sera reçue. Une fois que toutes les données mises en mémoire "
"tampon ont été vidées, la méthode :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` sera appelée avec :const:`None` comme "
"argument. Le transport ne doit pas être utilisé une fois qu'il est fermé."

#: library/asyncio-protocol.rst:164
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "Renvoie ``True`` si le transport se ferme ou est fermé."

#: library/asyncio-protocol.rst:168
msgid "Return information about the transport or underlying resources it uses."
msgstr ""
"Renvoie des informations sur le transport ou les ressources sous-jacentes "
"qu'il utilise."

#: library/asyncio-protocol.rst:171
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr ""
"*name* est une chaîne représentant l'information spécifique au transport à "
"obtenir."

#: library/asyncio-protocol.rst:174
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* est la valeur à renvoyer si les informations ne sont pas "
"disponibles ou si le transport ne prend pas en charge l'implémentation de "
"boucle d'événements tierce donnée ou la plateforme actuelle."

#: library/asyncio-protocol.rst:179
msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"Par exemple, le code suivant tente d'obtenir l'objet *socket* sous-jacent du "
"transport :"

#: library/asyncio-protocol.rst:186
msgid "Categories of information that can be queried on some transports:"
msgstr ""
"Catégories d'informations pouvant être interrogées sur certains transports :"

#: library/asyncio-protocol.rst:188
msgid "socket:"
msgstr "*socket* :"

#: library/asyncio-protocol.rst:190
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'`` : l'adresse distante à laquelle le *socket* est connecté, "
"résultat de :meth:`socket.socket.getpeername` (``None`` en cas d'erreur)"

#: library/asyncio-protocol.rst:194
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'`` : Instance de :class:`socket.socket`"

#: library/asyncio-protocol.rst:196
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'`` : la propre adresse du connecteur, résultat de :meth:`socket."
"socket.getsockname`"

#: library/asyncio-protocol.rst:199
msgid "SSL socket:"
msgstr "Connecteur (*socket*) SSL :"

#: library/asyncio-protocol.rst:201
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'compression'`` : l'algorithme de compression utilisé (chaîne de "
"caractères), ou ``None`` si la connexion n'est pas compressée ; résultat de :"
"meth:`ssl.SSLSocket.compression`"

#: library/asyncio-protocol.rst:205
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'`` : un *n*-uplet à trois valeurs contenant le nom du chiffrement "
"utilisé, la version du protocole SSL qui définit son utilisation et le "
"nombre de bits secrets utilisés ; résultat de :meth:`ssl.SSLSocket.cipher`"

#: library/asyncio-protocol.rst:210
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'`` : certificat du pair ; résultat de :meth:`ssl.SSLSocket."
"getpeercert`"

#: library/asyncio-protocol.rst:213
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``sslcontext'`` : instance de :class:`ssl.SSLContext`"

#: library/asyncio-protocol.rst:215
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'`` : instance de :class:`ssl.SSLObject` ou de :class:`ssl."
"SSLSocket`"

#: library/asyncio-protocol.rst:218
msgid "pipe:"
msgstr "tube :"

#: library/asyncio-protocol.rst:220
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'`` : objet *pipe*"

#: library/asyncio-protocol.rst:222
msgid "subprocess:"
msgstr "sous-processus :"

#: library/asyncio-protocol.rst:224
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'sous-processus'`` : instance de :class:`subprocess.Popen`"

#: library/asyncio-protocol.rst:228
msgid "Set a new protocol."
msgstr "Change le protocole."

#: library/asyncio-protocol.rst:230
msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"La commutation de protocole ne doit être effectuée que lorsque les deux "
"protocoles sont documentés pour prendre en charge la commutation."

#: library/asyncio-protocol.rst:235
msgid "Return the current protocol."
msgstr "Renvoie le protocole courant."

#: library/asyncio-protocol.rst:239
msgid "Read-only Transports"
msgstr "Transports en lecture seule"

#: library/asyncio-protocol.rst:243
msgid "Return ``True`` if the transport is receiving new data."
msgstr "Renvoie ``True`` si le transport reçoit de nouvelles données."

#: library/asyncio-protocol.rst:249
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"Met en pause l'extrémité de réception du transport. Aucune donnée ne sera "
"transmise à la méthode :meth:`protocol.data_received() <Protocol."
"data_received>` du protocole jusqu'à ce que :meth:`resume_reading` soit "
"appelée."

# suit un :
#: library/asyncio-protocol.rst:253
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"la méthode est idempotente, c'est-à-dire qu'elle peut être appelée lorsque "
"le transport est déjà en pause ou fermé."

#: library/asyncio-protocol.rst:259
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"Reprend la réception. La méthode :meth:`protocol.data_received() <Protocol."
"data_received>` du protocole sera appelée à nouveau si certaines données "
"sont disponibles pour la lecture."

# suit un :
#: library/asyncio-protocol.rst:263
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"la méthode est idempotente, c'est-à-dire qu'elle peut être appelée alors que "
"le transport est déjà en train de lire."

#: library/asyncio-protocol.rst:269
msgid "Write-only Transports"
msgstr "Transports en lecture-écriture"

#: library/asyncio-protocol.rst:273
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Ferme le transport immédiatement, sans attendre la fin des opérations en "
"attente. Les données mises en mémoire tampon sont perdues. Aucune autre "
"donnée ne sera reçue. La méthode :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` du protocole sera éventuellement appelée "
"avec :const:`None` comme argument."

#: library/asyncio-protocol.rst:281
msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"Renvoie :const:`True` si le transport gère :meth:`~WriteTransport."
"write_eof`, :const:`False` sinon."

#: library/asyncio-protocol.rst:286
msgid "Return the current size of the output buffer used by the transport."
msgstr ""
"Renvoie la taille actuelle du tampon de sortie utilisé par le transport."

#: library/asyncio-protocol.rst:290
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"Obtient les seuils *high* et *low* pour le contrôle du flux d'écriture. "
"Renvoie un *n*-uplet ``(low, high)`` où *low* et *high* sont des nombres "
"positifs d'octets."

#: library/asyncio-protocol.rst:294
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "Utilisez :meth:`set_write_buffer_limits` pour définir les limites."

#: library/asyncio-protocol.rst:300
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr ""
"Définit les seuils *high* et *low* pour le contrôle du flux d'écriture."

#: library/asyncio-protocol.rst:302
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"Ces deux valeurs (mesurées en nombre d'octets) contrôlent quand les "
"méthodes :meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` et :"
"meth:`protocol.resume_writing() <BaseProtocol.resume_writing>` du protocole "
"sont appelées. S'il est spécifié, le seuil bas doit être inférieur ou égal "
"au seuil haut. Ni *high* ni *low* ne peuvent être négatifs."

#: library/asyncio-protocol.rst:310
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` est appelée lorsque la taille du tampon "
"devient supérieure ou égale à la valeur *high*. Si l'écriture a été "
"interrompue, :meth:`~BaseProtocol.resume_writing` est appelée lorsque la "
"taille du tampon devient inférieure ou égale à la valeur *low*."

#: library/asyncio-protocol.rst:315
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"Les valeurs par défaut sont spécifiques à l'implémentation. Si seul le seuil "
"supérieur est donné, le seuil bas prend par défaut une valeur spécifique à "
"l'implémentation inférieure ou égale au seuil supérieur. Définir *high* sur "
"zéro force également *low* sur zéro et provoque l'appel de :meth:"
"`~BaseProtocol.pause_writing` chaque fois que le tampon devient non vide. "
"Définir *low* sur zéro entraîne l'appel de :meth:`~BaseProtocol."
"resume_writing` uniquement une fois que le tampon est vide. L'utilisation de "
"zéro pour l'un ou l'autre seuil est généralement sous-optimal car cela "
"réduit les possibilités d'effectuer des entrées-sorties et des calculs "
"simultanément."

#: library/asyncio-protocol.rst:326
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"Utilisez :meth:`~WriteTransport.get_write_buffer_limits` pour obtenir les "
"limites."

#: library/asyncio-protocol.rst:331
msgid "Write some *data* bytes to the transport."
msgstr "Écrit des octets de *data* sur le transport."

#: library/asyncio-protocol.rst:333 library/asyncio-protocol.rst:362
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"Cette méthode ne bloque pas ; elle met les données en mémoire tampon et "
"s'arrange pour qu'elles soient envoyées de manière asynchrone."

#: library/asyncio-protocol.rst:338
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"Écrit une liste (ou tout itérable) d'octets de données dans le transport. "
"Ceci est fonctionnellement équivalent à appeler :meth:`write` sur chaque "
"élément produit par l'itérable, mais peut être implémentée plus efficacement."

#: library/asyncio-protocol.rst:345
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"Ferme l'extrémité d'écriture du transport après avoir vidé toutes les "
"données mises en mémoire tampon. Des données peuvent encore être reçues."

#: library/asyncio-protocol.rst:348
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"Cette méthode peut lever :exc:`NotImplementedError` si le transport (par "
"exemple SSL) ne prend pas en charge les connexions semi-fermées."

#: library/asyncio-protocol.rst:353
msgid "Datagram Transports"
msgstr "Transports par datagrammes"

#: library/asyncio-protocol.rst:357
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"Envoie les octets *data* au pair distant indiqué par *addr* (une adresse "
"cible dépendante du transport). Si *addr* est :const:`None`, les données "
"sont envoyées à l'adresse cible indiquée lors de la création du transport."

#: library/asyncio-protocol.rst:365
msgid ""
"This method can be called with an empty bytes object to send a zero-length "
"datagram. The buffer size calculation used for flow control is also updated "
"to account for the datagram header."
msgstr ""

#: library/asyncio-protocol.rst:372
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Ferme le transport immédiatement, sans attendre la fin des opérations en "
"attente. Les données mises en mémoire tampon sont perdues. Aucune autre "
"donnée ne sera reçue. La méthode :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` du protocole sera éventuellement appelée "
"avec :const:`None` comme argument."

#: library/asyncio-protocol.rst:382
msgid "Subprocess Transports"
msgstr "Transports entre sous-processus"

#: library/asyncio-protocol.rst:386
msgid "Return the subprocess process id as an integer."
msgstr ""
"Renvoie l'identifiant du sous processus sous la forme d'un nombre entier."

#: library/asyncio-protocol.rst:390
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"Renvoie le transport pour le canal de communication correspondant au "
"descripteur de fichier *fd* donné sous forme d'un entier :"

#: library/asyncio-protocol.rst:393
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0`` : transport de flux en lecture de l'entrée standard (*stdin*), ou :"
"const:`None` si le sous-processus n'a pas été créé avec ``stdin=PIPE``"

#: library/asyncio-protocol.rst:395
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1`` : transport de flux en écriture de la sortie standard (*stdout*), ou :"
"const:`None` si le sous-processus n'a pas été créé avec ``stdout=PIPE``"

#: library/asyncio-protocol.rst:397
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2`` : transport de flux en écriture de l'erreur standard (*stderr*), ou :"
"const:`None` si le sous-processus n'a pas été créé avec ``stderr=PIPE``"

#: library/asyncio-protocol.rst:399
msgid "other *fd*: :const:`None`"
msgstr "autre *fd* : :const:`None`"

#: library/asyncio-protocol.rst:403
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"Renvoie le code de retour du sous-processus sous la forme d'un entier ou :"
"const:`None` s'il n'a pas été renvoyé, ce qui est similaire à l'attribut :"
"attr:`subprocess.Popen.returncode`."

#: library/asyncio-protocol.rst:409
msgid "Kill the subprocess."
msgstr "Tue le sous-processus."

#: library/asyncio-protocol.rst:411
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"Sur les systèmes POSIX, la fonction envoie SIGKILL au sous-processus. Sous "
"Windows, cette méthode est un alias pour :meth:`terminate`."

#: library/asyncio-protocol.rst:414
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "Voir aussi :meth:`subprocess.Popen.kill`."

#: library/asyncio-protocol.rst:418
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"Envoie le numéro de *signal* au sous-processus, comme dans :meth:`subprocess."
"Popen.send_signal`."

#: library/asyncio-protocol.rst:423
msgid "Stop the subprocess."
msgstr "Termine le sous-processus."

#: library/asyncio-protocol.rst:425
#, fuzzy
msgid ""
"On POSIX systems, this method sends :py:const:`~signal.SIGTERM` to the "
"subprocess. On Windows, the Windows API function :c:func:`!TerminateProcess` "
"is called to stop the subprocess."
msgstr ""
"Sur les systèmes POSIX, cette méthode envoie SIGTERM au sous-processus. Sous "
"Windows, la fonction API Windows *TerminateProcess()* est appelée pour "
"arrêter le sous-processus."

#: library/asyncio-protocol.rst:429
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "Voir aussi :meth:`subprocess.Popen.terminate`."

#: library/asyncio-protocol.rst:433
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "Tue le sous-processus en appelant la méthode :meth:`kill`."

#: library/asyncio-protocol.rst:435
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"Si le sous-processus n'est pas encore terminé, ferme les transports des "
"tubes *stdin*, *stdout* et *stderr*."

#: library/asyncio-protocol.rst:442
msgid "Protocols"
msgstr "Protocoles"

#: library/asyncio-protocol.rst:444
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**Code source :** :source:`Lib/asyncio/protocols.py`"

#: library/asyncio-protocol.rst:448
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"*asyncio* fournit un ensemble de classes mères abstraites qui doivent être "
"utilisées pour implémenter des protocoles réseau. Ces classes sont destinées "
"à être utilisées avec les :ref:`transports <asyncio-transport>`."

#: library/asyncio-protocol.rst:452
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"Les sous-classes des classes mères abstraites de protocole peuvent "
"implémenter certaines ou toutes les méthodes. Toutes ces méthodes sont des "
"rappels : elles sont appelées par des transports sur certains événements, "
"par exemple lors de la réception de certaines données. Une méthode de "
"protocole de base doit être appelée par le transport correspondant."

#: library/asyncio-protocol.rst:459
msgid "Base Protocols"
msgstr "Protocoles de base"

#: library/asyncio-protocol.rst:463
msgid "Base protocol with methods that all protocols share."
msgstr "Protocole de base avec des méthodes partagées par tous les protocoles."

#: library/asyncio-protocol.rst:467
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"Classe mère pour l'implémentation des protocoles de streaming (TCP, sockets "
"Unix, etc.)."

#: library/asyncio-protocol.rst:472
msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"Classe mère pour implémenter des protocoles de streaming avec contrôle "
"manuel du tampon de réception."

#: library/asyncio-protocol.rst:477
msgid "The base class for implementing datagram (UDP) protocols."
msgstr ""
"Classe mère pour l'implémentation des protocoles par datagrammes (UDP)."

#: library/asyncio-protocol.rst:481
msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"Classe mère pour implémenter des protocoles communiquant avec des processus "
"enfants (canaux unidirectionnels)."

#: library/asyncio-protocol.rst:486
msgid "Base Protocol"
msgstr "Protocoles de base"

#: library/asyncio-protocol.rst:488
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr ""
"Tous les protocoles asynchrones peuvent implémenter des rappels pour les "
"protocoles de base."

#: library/asyncio-protocol.rst:491
msgid "Connection Callbacks"
msgstr "Rappels pour les connexions"

#: library/asyncio-protocol.rst:492
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"Les méthodes de rappel pour les connexions concernent tous les protocoles, "
"exactement une fois par connexion réussie. Tous les autres rappels de "
"protocole ne peuvent être appelés qu'entre ces deux méthodes."

#: library/asyncio-protocol.rst:498
msgid "Called when a connection is made."
msgstr "Appelée lorsqu'une connexion est établie."

#: library/asyncio-protocol.rst:500
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"L'argument *transport* est le transport représentant la connexion. Le "
"protocole est chargé de stocker la référence à son transport."

#: library/asyncio-protocol.rst:506
msgid "Called when the connection is lost or closed."
msgstr "Appelée lorsqu'une connexion est perdue ou fermée."

#: library/asyncio-protocol.rst:508
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"L'argument est soit un objet exception soit :const:`None`. Ce dernier "
"signifie qu'un EOF régulier est reçu, ou que la connexion a été interrompue "
"ou fermée par ce côté de la connexion."

#: library/asyncio-protocol.rst:514
msgid "Flow Control Callbacks"
msgstr "Rappels pour le contrôle de flux"

#: library/asyncio-protocol.rst:515
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"Les méthodes de rappel pour le contrôle de flux concernent les transports et "
"sont utilisés pour suspendre ou reprendre l'écriture effectuée par le "
"protocole."

#: library/asyncio-protocol.rst:518
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"Voir la documentation de la méthode :meth:`~WriteTransport."
"set_write_buffer_limits` pour plus de détails."

#: library/asyncio-protocol.rst:523
msgid "Called when the transport's buffer goes over the high watermark."
msgstr ""
"Appelée lorsque la mémoire tampon du transport dépasse la limite supérieure."

#: library/asyncio-protocol.rst:527
msgid "Called when the transport's buffer drains below the low watermark."
msgstr ""
"Appelée lorsque la mémoire tampon du transport passe sous le seuil bas."

#: library/asyncio-protocol.rst:529
msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"Si la taille du tampon est égale au seuil haut, :meth:`~BaseProtocol."
"pause_writing` n'est pas appelée : la taille du tampon doit être strictement "
"supérieure."

#: library/asyncio-protocol.rst:533
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"Inversement, :meth:`~BaseProtocol.resume_writing` est appelée lorsque la "
"taille du tampon est égale ou inférieure au seuil bas. Ces conditions de fin "
"sont importantes pour s'assurer que les choses se déroulent comme prévu "
"lorsque l'un ou l'autre seuil est à zéro."

#: library/asyncio-protocol.rst:540
msgid "Streaming Protocols"
msgstr "Protocoles connectés"

#: library/asyncio-protocol.rst:542
msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"Les méthodes d'événement, telles que :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe` et :meth:`loop.connect_write_pipe` acceptent les "
"fabriques qui renvoient des protocoles connectés."

#: library/asyncio-protocol.rst:550
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"Appelée lorsque certaines données sont reçues. *data* est un objet bytes non "
"vide contenant les données entrantes."

#: library/asyncio-protocol.rst:553
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"Le fait que les données soient mises en mémoire tampon, fragmentées ou "
"réassemblées dépend du transport. En général, vous ne devez pas vous fier à "
"une sémantique spécifique et plutôt rendre votre analyse générique et "
"flexible. Cependant, les données sont toujours reçues dans le bon ordre."

#: library/asyncio-protocol.rst:558
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"La méthode peut être appelée un nombre arbitraire de fois lorsqu'une "
"connexion est ouverte."

#: library/asyncio-protocol.rst:561
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once ``eof_received()`` is called, ``data_received()`` is not "
"called anymore."
msgstr ""
"Cependant, :meth:`protocol.eof_received() <Protocol.eof_received>` est "
"appelée au plus une fois. Une fois que ``eof_received()`` est appelée, "
"``data_received()`` n'est plus appelée."

#: library/asyncio-protocol.rst:567
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"Appelée lorsque l'autre extrémité signale qu'il n'enverra plus de données "
"(par exemple en appelant :meth:`transport.write_eof() <WriteTransport."
"write_eof>`, si l'autre extrémité utilise également *asyncio*)."

#: library/asyncio-protocol.rst:572
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"Cette méthode peut renvoyer une valeur évaluée à faux (y compris ``None``), "
"auquel cas le transport se ferme de lui-même. À l'inverse, si cette méthode "
"renvoie une valeur évaluée à vrai, le protocole utilisé détermine s'il faut "
"fermer le transport. Puisque l'implémentation par défaut renvoie ``None``, "
"elle ferme implicitement la connexion."

#: library/asyncio-protocol.rst:578
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"Certains transports, y compris SSL, ne prennent pas en charge les connexions "
"semi-fermées, auquel cas renvoyer *True* à partir de cette méthode entraîne "
"la fermeture de la connexion."

#: library/asyncio-protocol.rst:583 library/asyncio-protocol.rst:641
msgid "State machine:"
msgstr "Machine à états :"

#: library/asyncio-protocol.rst:594
msgid "Buffered Streaming Protocols"
msgstr "Protocoles connectés avec tampon"

#: library/asyncio-protocol.rst:598
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"Les protocoles avec mise en mémoire tampon peuvent être utilisés avec "
"n'importe quelle méthode de boucle d'événements prenant en charge les "
"`protocoles connectés`_."

#: library/asyncio-protocol.rst:601
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"Les implémentations de ``BufferedProtocol`` permettent une allocation et un "
"contrôle manuels explicites du tampon de réception. Les boucles d'événements "
"peuvent alors utiliser le tampon fourni par le protocole pour éviter les "
"copies de données inutiles. Cela peut entraîner une amélioration notable des "
"performances pour les protocoles qui reçoivent de grandes quantités de "
"données. Des implémentations de protocole sophistiquées peuvent réduire "
"considérablement le nombre d'allocations de mémoire tampon."

#: library/asyncio-protocol.rst:608
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""
"Les méthodes de rappel suivantes sont appelées sur les instances :class:"
"`BufferedProtocol` :"

#: library/asyncio-protocol.rst:613
msgid "Called to allocate a new receive buffer."
msgstr "Appelée pour allouer un nouveau tampon de réception."

#: library/asyncio-protocol.rst:615
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* est la taille minimale recommandée pour le tampon renvoyé. Il est "
"acceptable de renvoyer des tampons plus petits ou plus grands que ce que "
"suggère *sizehint*. Lorsqu'il est défini à −1, la taille du tampon peut être "
"arbitraire. C'est une erreur de renvoyer un tampon de taille nulle."

#: library/asyncio-protocol.rst:620
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` doit renvoyer un objet implémentant le :ref:`protocole "
"tampon <bufferobjects>`."

#: library/asyncio-protocol.rst:625
msgid "Called when the buffer was updated with the received data."
msgstr "Appelée lorsque le tampon a été mis à jour avec les données reçues."

#: library/asyncio-protocol.rst:627
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr ""
"*nbytes* est le nombre total d'octets qui ont été écrits dans la mémoire "
"tampon."

#: library/asyncio-protocol.rst:631
msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
"Voir la documentation de la méthode :meth:`protocol.eof_received() <Protocol."
"eof_received>`."

#: library/asyncio-protocol.rst:635
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` peut être appelée un nombre arbitraire "
"de fois pendant une connexion. Cependant, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` est appelée au plus une fois et, si elle est "
"appelée, :meth:`~BufferedProtocol.get_buffer` et :meth:`~BufferedProtocol."
"buffer_updated` ne seront pas appelées après."

#: library/asyncio-protocol.rst:654
msgid "Datagram Protocols"
msgstr "Protocoles par datagrammes (non connectés)"

#: library/asyncio-protocol.rst:656
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"Les instances du protocole par datagrammes doivent être construites par des "
"fabriques de protocole transmises à la méthode :meth:`loop."
"create_datagram_endpoint`."

#: library/asyncio-protocol.rst:661
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"Appelée lorsqu'un datagramme est reçu. *data* est un objet bytes contenant "
"les données entrantes. *addr* est l'adresse du pair qui envoie les données ; "
"le format exact dépend du transport."

#: library/asyncio-protocol.rst:667
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"Appelée lorsqu'une opération d'envoi ou de réception précédente lève une :"
"class:`OSError`. *exc* est l'instance :class:`OSError`."

#: library/asyncio-protocol.rst:670
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"Cette méthode est appelée dans de rares cas, lorsque le transport (par "
"exemple UDP) détecte qu'un datagramme n'a pas pu être livré à son "
"destinataire. Cependant, il est courant que les datagrammes qui ne peuvent "
"être acheminés soient supprimés silencieusement."

#: library/asyncio-protocol.rst:677
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"Sur les systèmes BSD (macOS, FreeBSD, etc.), le contrôle de flux n'est pas "
"pris en charge pour les protocoles par datagrammes, car il n'existe aucun "
"moyen fiable de détecter les échecs d'envoi causés par l'écriture d'un trop "
"grand nombre de paquets."

#: library/asyncio-protocol.rst:681
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"Le connecteur apparaît toujours « prêt » et les paquets en excès sont "
"supprimés. Une :class:`OSError` avec ``errno`` définie sur :const:`errno."
"ENOBUFS` peut être levée ou non ; si elle est levée, c'est communiqué à :"
"meth:`DatagramProtocol.error_received` et ignoré dans le cas contraire."

#: library/asyncio-protocol.rst:690
msgid "Subprocess Protocols"
msgstr "Protocoles liés aux sous-processus"

#: library/asyncio-protocol.rst:692
msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"Les instances de protocole de sous-processus doivent être construites par "
"des fabriques de protocole transmises aux méthodes :meth:`loop."
"subprocess_exec` et :meth:`loop.subprocess_shell`."

#: library/asyncio-protocol.rst:698
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"Appelée lorsqu'un processus enfant écrit sur sa sortie d'erreur ou sa sortie "
"standard."

#: library/asyncio-protocol.rst:701
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* est l'entier représentant le descripteur de fichier du tube."

#: library/asyncio-protocol.rst:703
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* est un objet bytes non vide contenant les données reçues."

#: library/asyncio-protocol.rst:707
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"Appelé lorsqu'un des tubes de communication avec un sous-processus est fermé."

#: library/asyncio-protocol.rst:710
msgid "*fd* is the integer file descriptor that was closed."
msgstr ""
"*fd* est l'entier représentant le descripteur de fichier qui a été fermé."

#: library/asyncio-protocol.rst:714
msgid "Called when the child process has exited."
msgstr "Appelée lorsqu'un processus enfant se termine."

#: library/asyncio-protocol.rst:716
msgid ""
"It can be called before :meth:`~SubprocessProtocol.pipe_data_received` and :"
"meth:`~SubprocessProtocol.pipe_connection_lost` methods."
msgstr ""

#: library/asyncio-protocol.rst:721
msgid "Examples"
msgstr "Exemples"

#: library/asyncio-protocol.rst:726
msgid "TCP Echo Server"
msgstr "Serveur *écho* en TCP"

#: library/asyncio-protocol.rst:728
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
"Crée un serveur d'écho TCP en utilisant la méthode :meth:`loop."
"create_server`, renvoie les données reçues et ferme la connexion ::"

#: library/asyncio-protocol.rst:769
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
"L'exemple :ref:`asyncio-tcp-echo-server-streams` utilise la fonction de haut "
"niveau :func:`asyncio.start_server`."

#: library/asyncio-protocol.rst:775
msgid "TCP Echo Client"
msgstr "Client *écho* en TCP"

#: library/asyncio-protocol.rst:777
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
"Client d'écho TCP utilisant la méthode :meth:`loop.create_connection` envoie "
"des données et attend que la connexion soit fermée ::"

#: library/asyncio-protocol.rst:825
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
"L'exemple :ref:`asyncio-tcp-echo-client-streams` utilise la fonction de haut "
"niveau :func:`asyncio.open_connection`."

#: library/asyncio-protocol.rst:832
msgid "UDP Echo Server"
msgstr "Serveur *écho* en UDP"

#: library/asyncio-protocol.rst:834
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
"Serveur d'écho UDP, utilisant la méthode :meth:`loop."
"create_datagram_endpoint`, qui renvoie les données reçues ::"

#: library/asyncio-protocol.rst:876
msgid "UDP Echo Client"
msgstr "Client *écho* en UDP"

#: library/asyncio-protocol.rst:878
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""
"Client d'écho UDP, utilisant la méthode :meth:`loop."
"create_datagram_endpoint`, qui envoie des données et ferme le transport "
"lorsqu'il reçoit la réponse :"

#: library/asyncio-protocol.rst:933
msgid "Connecting Existing Sockets"
msgstr "Connexion de connecteurs existants"

#: library/asyncio-protocol.rst:935
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"Attend qu'un connecteur reçoive des données en utilisant la méthode :meth:"
"`loop.create_connection` avec un protocole ::"

#: library/asyncio-protocol.rst:989
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
"L'exemple :ref:`asyncio_example_watch_fd` utilise la méthode de bas niveau :"
"meth:`loop.add_reader` pour enregistrer un descripteur de fichier."

#: library/asyncio-protocol.rst:993
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
"L'exemple :ref:`asyncio_example_create_connection-streams` utilise des flux "
"de haut niveau créés par la fonction :func:`open_connection` dans une "
"coroutine."

#: library/asyncio-protocol.rst:1000
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "*loop.subprocess_exec()* et *SubprocessProtocol*"

#: library/asyncio-protocol.rst:1002
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"Un exemple de protocole de sous-processus utilisé pour obtenir la sortie "
"d'un sous-processus et attendre la sortie du sous-processus."

#: library/asyncio-protocol.rst:1005
msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr ""
"Le sous-processus est créé par la méthode :meth:`loop.subprocess_exec` ::"

#: library/asyncio-protocol.rst:1065
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"Voir aussi le :ref:`même exemple <asyncio_example_create_subprocess_exec>` "
"écrit à l'aide d'API de haut niveau."
