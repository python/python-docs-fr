# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-31 11:33+0100\n"
"PO-Revision-Date: 2021-10-28 11:44+0200\n"
"Last-Translator: David GIRAUD <davidgiraud@protonmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0\n"

#: library/dataclasses.rst:2
msgid ":mod:`dataclasses` --- Data Classes"
msgstr ":mod:`dataclasses` — Classes de Données"

#: library/dataclasses.rst:10
msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**Code source :** :source:`Lib/dataclasses.py`"

#: library/dataclasses.rst:14
msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special method`\\s such as :meth:`__init__` and :meth:"
"`__repr__` to user-defined classes.  It was originally described in :pep:"
"`557`."
msgstr ""
"Ce module fournit un décorateur et des fonctions pour générer "
"automatiquement les  :term:`méthodes spéciales <special method>` comme :meth:"
"`__init__` et :meth:`__repr__` dans les *Classes de Données* définies par "
"l’utilisateur.  Ces classes ont été décrites dans la :pep:`557`."

#: library/dataclasses.rst:19
msgid ""
"The member variables to use in these generated methods are defined using :"
"pep:`526` type annotations.  For example, this code::"
msgstr ""
"Les variables membres à utiliser dans ces méthodes générées sont définies en "
"utilisant les annotations de type :pep:`526`.  Par exemple ::"

#: library/dataclasses.rst:34
msgid "will add, among other things, a :meth:`__init__` that looks like::"
msgstr ""
"ce code ajoute à la classe, entre autres choses, une méthode :meth:"
"`__init__` qui ressemble à ::"

#: library/dataclasses.rst:41
msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the ``InventoryItem`` definition shown above."
msgstr ""
"Il est important de noter que cette méthode est ajoutée automatiquement dans "
"la classe. Elle n’est jamais écrite dans la définition de ``InventoryItem``."

#: library/dataclasses.rst:47
msgid "Module contents"
msgstr "Classe de données"

#: library/dataclasses.rst:51
msgid ""
"This function is a :term:`decorator` that is used to add generated :term:"
"`special method`\\s to classes, as described below."
msgstr ""
"Cette fonction est un :term:`décorateur <decorator>` qui ajoute aux classes "
"des :term:`méthodes spéciales <special method>` générées automatiquement. "
"Voici une description plus détaillée."

#: library/dataclasses.rst:54
msgid ""
"The :func:`dataclass` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as a class variable that has a :term:`type annotation "
"<variable annotation>`.  With two exceptions described below, nothing in :"
"func:`dataclass` examines the type specified in the variable annotation."
msgstr ""
"Le décorateur :func:`dataclass` examine la classe pour trouver des champs.  "
"Un champ est défini comme une variable de classe qui possède une :term:"
"`annotation de type <variable annotation>`.  À deux exceptions près décrites "
"plus bas, :func:`dataclass` ne prend pas en considération le type donné dans "
"l'annotation."

#: library/dataclasses.rst:60
msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr ""
"L’ordre des paramètres des méthodes générées est celui d’apparition des "
"champs dans la définition de la classe."

#: library/dataclasses.rst:63
msgid ""
"The :func:`dataclass` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist in the "
"class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that it is called on; no new class is "
"created."
msgstr ""
"Le décorateur :func:`dataclass` ajoute diverses méthodes spéciales à la "
"classe, décrites ci-après.  Si l’une des méthodes ajoutées existe déjà dans "
"la classe, le comportement dépend des paramètres. Le décorateur renvoie la "
"classe sur laquelle il est appelé ; aucune nouvelle classe n'est créée."

#: library/dataclasses.rst:69
msgid ""
"If :func:`dataclass` is used just as a simple decorator with no parameters, "
"it acts as if it has the default values documented in this signature.  That "
"is, these three uses of :func:`dataclass` are equivalent::"
msgstr ""
"Si :func:`dataclass` est utilisé directement, il se comporte comme si on "
"l’avait appelé sans argument (c.-à-d. en laissant les valeurs par défaut de "
"sa signature). Ainsi, les trois usages suivants de :func:`dataclass` sont "
"équivalents ::"

#: library/dataclasses.rst:86
msgid "The parameters to :func:`dataclass` are:"
msgstr "Les paramètres de :func:`dataclass` sont les suivants :"

#: library/dataclasses.rst:88
msgid ""
"``init``: If true (the default), a :meth:`__init__` method will be generated."
msgstr ""
"*init* : si vrai (par défaut), une méthode :meth:`__init__` est générée."

#: library/dataclasses.rst:91
msgid ""
"If the class already defines :meth:`__init__`, this parameter is ignored."
msgstr ""
"Si la classe définit déjà une méthode :meth:`__init__`, ce paramètre est "
"ignoré."

#: library/dataclasses.rst:94
msgid ""
"``repr``: If true (the default), a :meth:`__repr__` method will be "
"generated.  The generated repr string will have the class name and the name "
"and repr of each field, in the order they are defined in the class.  Fields "
"that are marked as being excluded from the repr are not included.  For "
"example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"*repr* : si vrai (par défaut), une méthode :meth:`__repr__` est générée.  La "
"chaîne de représentation comporte le nom de la classe et le nom ainsi que la "
"représentation de chaque champ, suivant leur ordre de définition.  Les "
"champs marqués comme exclus de la représentation (voir ``Field`` ci-dessous) "
"sont ignorés.  Par exemple : ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."

#: library/dataclasses.rst:101
msgid ""
"If the class already defines :meth:`__repr__`, this parameter is ignored."
msgstr ""
"Si la classe définit déjà une méthode :meth:`__repr__`, ce paramètre est "
"ignoré."

#: library/dataclasses.rst:104
msgid ""
"``eq``: If true (the default), an :meth:`__eq__` method will be generated.  "
"This method compares the class as if it were a tuple of its fields, in "
"order.  Both instances in the comparison must be of the identical type."
msgstr ""
"*eq* : si vrai (par défaut), une méthode :meth:`__eq__` est générée.  Cette "
"méthode permet de comparer les instances de la classe comme si elles étaient "
"des *n*-uplet de leurs champs, pris dans l’ordre. Les deux instances dans la "
"comparaison doivent être de même type."

#: library/dataclasses.rst:109
msgid "If the class already defines :meth:`__eq__`, this parameter is ignored."
msgstr ""
"Si la classe définit déjà une méthode :meth:`__eq__`, ce paramètre est "
"ignoré."

#: library/dataclasses.rst:112
msgid ""
"``order``: If true (the default is ``False``), :meth:`__lt__`, :meth:"
"`__le__`, :meth:`__gt__`, and :meth:`__ge__` methods will be generated.  "
"These compare the class as if it were a tuple of its fields, in order.  Both "
"instances in the comparison must be of the identical type.  If ``order`` is "
"true and ``eq`` is false, a :exc:`ValueError` is raised."
msgstr ""
"*order* : si vrai (``False`` par défaut), les méthodes :meth:`__lt__`, :meth:"
"`__le__`, :meth:`__gt__`, et :meth:`__ge__` sont générées.  Elles permettent "
"de comparer les instances de la classe en les considérant comme des *n*-"
"uplets, dans l’ordre de définition des champs.  Toutes les instances dans la "
"comparaison doivent être de même type.  Si ``order`` est vrai mais que "
"``eq`` est faux, une :exc:`ValueError` est levée."

#: library/dataclasses.rst:119
msgid ""
"If the class already defines any of :meth:`__lt__`, :meth:`__le__`, :meth:"
"`__gt__`, or :meth:`__ge__`, then :exc:`TypeError` is raised."
msgstr ""
"Si la classe définit déjà l’une des méthodes :meth:`__lt__`, :meth:"
"`__le__`, :meth:`__gt__`, ou :meth:`__ge__`, alors une :exc:`TypeError` est "
"levée."

#: library/dataclasses.rst:123
msgid ""
"``unsafe_hash``: If ``False`` (the default), a :meth:`__hash__` method is "
"generated according to how ``eq`` and ``frozen`` are set."
msgstr ""
"*unsafe_hash* : si ``False`` (par défaut), une méthode :meth:`__hash__` est "
"générée et son comportement dépend des valeurs de *eq* et *frozen*."

#: library/dataclasses.rst:126
msgid ""
":meth:`__hash__` is used by built-in :meth:`hash()`, and when objects are "
"added to hashed collections such as dictionaries and sets.  Having a :meth:"
"`__hash__` implies that instances of the class are immutable. Mutability is "
"a complicated property that depends on the programmer's intent, the "
"existence and behavior of :meth:`__eq__`, and the values of the ``eq`` and "
"``frozen`` flags in the :func:`dataclass` decorator."
msgstr ""
":meth:`__hash__` est utilisée par la fonction native :meth:`hash()`, ainsi "
"que lorsqu’un objet est inséré dans une collection utilisant du hachage, tel "
"qu’un dictionnaire ou un ensemble.  Avoir une méthode :meth:`__hash__` "
"implique que les instances de la classe sont immuables. La muabilité est une "
"propriété complexe qui dépend des intentions du programmeur, de l’existence "
"et du comportement de la méthode :meth:`__eq__`, et des valeurs des options "
"*eq* et *frozen* dans l’appel au décorateur :func:`dataclass`."

#: library/dataclasses.rst:133
msgid ""
"By default, :func:`dataclass` will not implicitly add a :meth:`__hash__` "
"method unless it is safe to do so.  Neither will it add or change an "
"existing explicitly defined :meth:`__hash__` method.  Setting the class "
"attribute ``__hash__ = None`` has a specific meaning to Python, as described "
"in the :meth:`__hash__` documentation."
msgstr ""
"Par défaut, :func:`dataclass` n’ajoute pas de méthode implicite :meth:"
"`__hash__`, sauf s’il n’existe aucun risque sous-jacent.  Il n’ajoute ou ne "
"modifie pas non plus la méthode :meth:`__hash__` si elle a été définie "
"explicitement.  Définir l’attribut de classe ``__hash__ = None`` a une "
"signification particulière, comme précisé dans la documentation de :meth:"
"`__hash__`."

#: library/dataclasses.rst:139
msgid ""
"If :meth:`__hash__` is not explicitly defined, or if it is set to ``None``, "
"then :func:`dataclass` *may* add an implicit :meth:`__hash__` method. "
"Although not recommended, you can force :func:`dataclass` to create a :meth:"
"`__hash__` method with ``unsafe_hash=True``. This might be the case if your "
"class is logically immutable but can nonetheless be mutated. This is a "
"specialized use case and should be considered carefully."
msgstr ""
"Si :meth:`__hash__` n’est pas défini explicitement, ou s’il a pour valeur "
"``None``, alors :func:`dataclass` *peut* ajouter une méthode :meth:"
"`__hash__` implicite. Bien que ce ne soit pas recommandé, vous pouvez "
"forcer :func:`dataclass` à créer une méthode :meth:`__hash__` en utilisant "
"``unsafe_hash=True``. Cela pourrait être nécessaire si votre classe est "
"logiquement immuable mais qu’une mutation est tout de même possible. Il "
"s'agit là d'un cas particulier qui doit être considéré avec la plus grande "
"prudence."

#: library/dataclasses.rst:146
msgid ""
"Here are the rules governing implicit creation of a :meth:`__hash__` "
"method.  Note that you cannot both have an explicit :meth:`__hash__` method "
"in your dataclass and set ``unsafe_hash=True``; this will result in a :exc:"
"`TypeError`."
msgstr ""
"Voici les règles autour de la création implicite de la méthode :meth:"
"`__hash__`.  Il faut noter que vous ne pouvez pas avoir à la fois une "
"méthode :meth:`__hash__` explicite dans votre classe de données et définir "
"``unsafe_hash=True`` ; cela lèvera une :exc:`TypeError`."

#: library/dataclasses.rst:151
msgid ""
"If ``eq`` and ``frozen`` are both true, by default :func:`dataclass` will "
"generate a :meth:`__hash__` method for you.  If ``eq`` is true and "
"``frozen`` is false, :meth:`__hash__` will be set to ``None``, marking it "
"unhashable (which it is, since it is mutable).  If ``eq`` is false, :meth:"
"`__hash__` will be left untouched meaning the :meth:`__hash__` method of the "
"superclass will be used (if the superclass is :class:`object`, this means it "
"will fall back to id-based hashing)."
msgstr ""
"Si *eq* et *frozen* sont tous deux vrais, :func:`dataclass` génère par "
"défaut une méthode :meth:`__hash__` pour vous.  Si *eq* est vrai mais que "
"*frozen* est faux, :meth:`__hash__` prend la valeur ``None``, marquant la "
"classe comme non-hachable (et c’est le cas, puisque les instances sont "
"mutables).  Si ``eq`` est faux, la méthode :meth:`__hash__` est laissée "
"intacte, ce qui veut dire que la méthode :meth:`__hash__` de la classe "
"parente sera utilisée (si la classe parente est :class:`object`, le "
"comportement est un hachage basé sur les id)."

#: library/dataclasses.rst:159
msgid ""
"``frozen``: If true (the default is ``False``), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances.  If :meth:"
"`__setattr__` or :meth:`__delattr__` is defined in the class, then :exc:"
"`TypeError` is raised.  See the discussion below."
msgstr ""
"*frozen* : si vrai (faux par défaut), assigner une valeur à un champ lève "
"une exception.  Cela simule le comportement des instances figées en lecture "
"seule.  Si la méthode :meth:`__setattr__` ou :meth:`__delattr__` est définie "
"sur la classe, alors une :exc:`TypeError` est levée.  Voir la discussion ci-"
"dessous."

#: library/dataclasses.rst:164
msgid ""
"``match_args``: If true (the default is ``True``), the ``__match_args__`` "
"tuple will be created from the list of parameters to the generated :meth:"
"`__init__` method (even if :meth:`__init__` is not generated, see above).  "
"If false, or if ``__match_args__`` is already defined in the class, then "
"``__match_args__`` will not be generated."
msgstr ""
"*match_args* : si vrai (``True`` est la valeur par défaut), le *n*-uplet "
"``__match_args__`` est créé automatiquement depuis la liste des paramètres "
"de la méthode :meth:`__init__` générée (même si :meth:`__init__` n'est pas "
"générée, voir ci-dessus). Si faux ou si ``__match_args__`` est déjà défini "
"dans la classe alors ``__match_args__`` n'est pas créé."

#: library/dataclasses.rst:173
msgid ""
"``kw_only``: If true (the default value is ``False``), then all fields will "
"be marked as keyword-only.  If a field is marked as keyword-only, then the "
"only affect is that the :meth:`__init__` parameter generated from a keyword-"
"only field must be specified with a keyword when :meth:`__init__` is "
"called.  There is no effect on any other aspect of dataclasses.  See the :"
"term:`parameter` glossary entry for details.  Also see the :const:`KW_ONLY` "
"section."
msgstr ""
"*kw_only* : si vrai (``False`` est la valeur par défaut) alors tous les "
"champs sont marqués comme exclusivement nommés. Si un champ est marqué comme "
"exclusivement nommé, le seul impact est que le champ de la méthode :meth:"
"`__init__` générée devra être explicitement nommé lors de l'appel de la "
"méthode :meth:`__init__`. Il n'y a aucun autre effet dans les autres aspects "
"des classes de données. Voir l'entrée :term:`paramètre <parameter>` du "
"glossaire pour plus d'informations. Voir également la section :const:"
"`KW_ONLY`."

#: library/dataclasses.rst:184
msgid ""
"``slots``: If true (the default is ``False``), :attr:`__slots__` attribute "
"will be generated and new class will be returned instead of the original "
"one. If :attr:`__slots__` is already defined in the class, then :exc:"
"`TypeError` is raised."
msgstr ""
"*slot* : si vrai (``False`` est la valeur par défaut), l'attribut :attr:"
"`__slots__` est généré et une nouvelle classe est renvoyée à la place de "
"celle d'origine. Si :attr:`__slots__` est déjà défini dans la classe alors "
"une :exc:`TypeError` est levée."

#: library/dataclasses.rst:191
msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr ""
"Les champs peuvent éventuellement préciser une valeur par défaut, en "
"utilisant la syntaxe Python normale ::"

#: library/dataclasses.rst:199
msgid ""
"In this example, both ``a`` and ``b`` will be included in the added :meth:"
"`__init__` method, which will be defined as::"
msgstr ""
"Dans cet exemple, ``a`` et ``b`` sont tous deux inclus dans la signature de "
"la méthode générée :meth:`__init__`, qui est définie comme suit ::"

#: library/dataclasses.rst:204
msgid ""
":exc:`TypeError` will be raised if a field without a default value follows a "
"field with a default value.  This is true whether this occurs in a single "
"class, or as a result of class inheritance."
msgstr ""
"Une :exc:`TypeError` est levée si un champ sans valeur par défaut est défini "
"après un champ avec une valeur par défaut.  C’est le cas que ce soit dans "
"une seule classe ou si c’est le résultat d’un héritage de classes."

#: library/dataclasses.rst:210
msgid ""
"For common and simple use cases, no other functionality is required.  There "
"are, however, some dataclass features that require additional per-field "
"information.  To satisfy this need for additional information, you can "
"replace the default field value with a call to the provided :func:`field` "
"function.  For example::"
msgstr ""
"Dans les cas les plus simples et courants, ce qui a été décrit jusqu'ici "
"suffit. Cependant, les classes de données possèdent des fonctionnalités "
"supplémentaires fondées sur des métadonnées propres à chaque champ. Pour "
"remplir ces métadonnées, il suffit de mettre un appel à la fonction :func:"
"`field` à la place de la valeur par défaut, comme dans cet exemple :"

#: library/dataclasses.rst:223
msgid ""
"As shown above, the :const:`MISSING` value is a sentinel object used to "
"detect if some parameters are provided by the user. This sentinel is used "
"because ``None`` is a valid value for some parameters with a distinct "
"meaning.  No code should directly use the :const:`MISSING` value."
msgstr ""
"Comme le montre la signature, la constante :const:`MISSING` est une valeur "
"sentinelle pour déterminer si des paramètres ont été fournis par "
"l'utilisateur. ``None`` ne conviendrait pas puisque c'est une valeur avec un "
"sens qui peut être différent pour certains paramètres. La sentinelle :const:"
"`MISSING` est interne au module et ne doit pas être utilisée dans vos "
"programmes."

#: library/dataclasses.rst:228
msgid "The parameters to :func:`field` are:"
msgstr "Les paramètres de :func:`field` sont :"

#: library/dataclasses.rst:230
msgid ""
"``default``: If provided, this will be the default value for this field.  "
"This is needed because the :meth:`field` call itself replaces the normal "
"position of the default value."
msgstr ""
"*default* : s'il est fourni, il devient la valeur par défaut du champ. "
"L'appel à :meth:`field` est mis à la place normale de la valeur par défaut, "
"d'où la nécessité de ce paramètre."

#: library/dataclasses.rst:234
msgid ""
"``default_factory``: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among other "
"purposes, this can be used to specify fields with mutable default values, as "
"discussed below.  It is an error to specify both ``default`` and "
"``default_factory``."
msgstr ""
"*default_factory* : s'il est fourni, ce doit être un objet appelable sans "
"argument. Il est alors appelé à chaque fois qu'il faut une valeur par défaut "
"pour le champ. Ceci permet, entre autres choses, de définir des champs dont "
"les valeurs par défaut sont muables. Une erreur se produit si *default* et "
"*default_factory* sont donnés tous les deux."

#: library/dataclasses.rst:240
msgid ""
"``init``: If true (the default), this field is included as a parameter to "
"the generated :meth:`__init__` method."
msgstr ""
"*init* : si vrai (par défaut), la méthode :meth:`__init__` générée possède "
"un paramètre correspondant à ce champ."

#: library/dataclasses.rst:243
msgid ""
"``repr``: If true (the default), this field is included in the string "
"returned by the generated :meth:`__repr__` method."
msgstr ""
"*repr* : si vrai (par défaut), le champ est inclus dans les chaînes "
"construites par la méthode :meth:`__repr__` générée."

#: library/dataclasses.rst:246
msgid ""
"``hash``: This can be a bool or ``None``.  If true, this field is included "
"in the generated :meth:`__hash__` method.  If ``None`` (the default), use "
"the value of ``compare``: this would normally be the expected behavior.  A "
"field should be considered in the hash if it's used for comparisons.  "
"Setting this value to anything other than ``None`` is discouraged."
msgstr ""
"*hash* : ce paramètre est un booléen ou ``None``. La valeur ``False`` force "
"la prise en compte du champ dans la méthode :meth:`__hash__` générée, alors "
"que ``False`` force son exclusion. ``None`` revient à mettre la même valeur "
"que *compare*, ce qui est en général correct : il faut inclure dans le "
"hachage les champs employés pour les comparaisons. Il est déconseillé de "
"mettre ce paramètre à autre chose que ``None``."

#: library/dataclasses.rst:253
msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be if a "
"field is expensive to compute a hash value for, that field is needed for "
"equality testing, and there are other fields that contribute to the type's "
"hash value.  Even if a field is excluded from the hash, it will still be "
"used for comparisons."
msgstr ""
"Cependant, une raison légitime de mettre *hash* à ``False`` alors que "
"*compare* est à ``True`` est la concourance de trois facteurs : le champ est "
"coûteux à hacher ; il est nécessaire pour les comparaisons d'égalité ; et il "
"y a déjà d'autres champs qui participent au hachage des instances. À ce "
"moment, on peut alors se passer du champ dans le hachage tout en le faisant "
"participer aux comparaisons."

#: library/dataclasses.rst:259
msgid ""
"``compare``: If true (the default), this field is included in the generated "
"equality and comparison methods (:meth:`__eq__`, :meth:`__gt__`, et al.)."
msgstr ""
"*compare* : si vrai (par défaut), le champ est considéré dans les "
"comparaisons d'égalité et d'inégalité dans les méthodes générées :meth:"
"`__eq__`, :meth:`__gt__`, etc."

#: library/dataclasses.rst:263
msgid ""
"``metadata``: This can be a mapping or None. None is treated as an empty "
"dict.  This value is wrapped in :func:`~types.MappingProxyType` to make it "
"read-only, and exposed on the :class:`Field` object. It is not used at all "
"by Data Classes, and is provided as a third-party extension mechanism. "
"Multiple third-parties can each have their own key, to use as a namespace in "
"the metadata."
msgstr ""
"*metadata* : ce paramètre est un tableau associatif (*mapping* en anglais). "
"La valeur par défaut de ``None`` est prise comme un dictionnaire vide. Le "
"tableau associatif devient accessible sur l'objet :class:`Field`, sous la "
"forme d'un :func:`~types.MappingProxyType` afin qu'il soit en lecture seule."

#: library/dataclasses.rst:271
msgid ""
"``kw_only``: If true, this field will be marked as keyword-only. This is "
"used when the generated :meth:`__init__` method's parameters are computed."
msgstr ""
"``kw_only`` : Si vrai ce champ est marqué comme exclusivement nommé. Cela "
"est utilisé lors du traitement des paramètres de la méthode :meth:`__init__` "
"générée."

#: library/dataclasses.rst:277
msgid ""
"If the default value of a field is specified by a call to :func:`field()`, "
"then the class attribute for this field will be replaced by the specified "
"``default`` value.  If no ``default`` is provided, then the class attribute "
"will be deleted.  The intent is that after the :func:`dataclass` decorator "
"runs, the class attributes will all contain the default values for the "
"fields, just as if the default value itself were specified.  For example, "
"after::"
msgstr ""
"Si la valeur par défaut d'un champ est donnée dans un appel à :func:`field` "
"(et pas directement), l'attribut correspondant de la classe est remplacé par "
"cette valeur. Si le paramètre *default* n'est pas passé, l'attribut est "
"simplement supprimé. De cette manière, après le passage du décorateur :func:"
"`dataclass`, les attributs de la classe contiennent les valeurs par défaut "
"des champs exactement comme si elles avaient été définies directement. Par "
"exemple :"

#: library/dataclasses.rst:293
msgid ""
"The class attribute ``C.z`` will be ``10``, the class attribute ``C.t`` will "
"be ``20``, and the class attributes ``C.x`` and ``C.y`` will not be set."
msgstr ""
"Après l'exécution de ce code, l'attribut de classe ``C.z`` vaut ``10`` et "
"l'attribut ``C.t`` vaut ``20``, alors que les attributs ``C.x`` et ``C.y`` "
"n'existent pas."

#: library/dataclasses.rst:299
msgid ""
":class:`Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`Field` object "
"directly.  Its documented attributes are:"
msgstr ""
"Les objets :class:`Field` contiennent des informations sur les champs. Ils "
"sont créés en interne, et on y accède à l'aide de la méthode au niveau du "
"module :func:`fields` (voir plus bas). Les utilisateurs ne doivent jamais "
"instancier un objet :class:`Field` eux-mêmes. Les attributs documentés sont "
"les suivants :"

#: library/dataclasses.rst:304
msgid "``name``: The name of the field."
msgstr "*name* : le nom du champ  ;"

#: library/dataclasses.rst:306
msgid "``type``: The type of the field."
msgstr "*type* : le type associé au champ par l'annotation  ;"

#: library/dataclasses.rst:308
msgid ""
"``default``, ``default_factory``, ``init``, ``repr``, ``hash``, ``compare``, "
"``metadata``, and ``kw_only`` have the identical meaning and values as they "
"do in the :func:`field` function."
msgstr ""
"*default*, *default_factory*, *init*, *repr*, *hash*, *compare*, *metadata* "
"et *kw_only* qui correspondent aux paramètres de :func:`field` et en "
"prennent les valeurs."

#: library/dataclasses.rst:312
msgid ""
"Other attributes may exist, but they are private and must not be inspected "
"or relied on."
msgstr ""
"D'autres attributs peuvent exister, mais ils sont privés et ne sont pas "
"censés être inspectés. Le code ne doit jamais reposer sur eux."

#: library/dataclasses.rst:317
msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this "
"dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. Does "
"not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"Renvoie un *n*-uplet d'objets :class:`Field` correspondant aux champs de "
"l'argument, à l'exclusion des pseudo-champs ``ClassVar`` ou ``InitVar``. "
"L'argument peut être soit une classe de données, soit une instance d'une "
"telle classe ; si ce n'est pas le cas, une exception :exc:`TypeError` est "
"levée."

#: library/dataclasses.rst:324
#, fuzzy
msgid ""
"Converts the dataclass ``instance`` to a dict (by using the factory function "
"``dict_factory``).  Each dataclass is converted to a dict of its fields, as "
"``name: value`` pairs.  dataclasses, dicts, lists, and tuples are recursed "
"into.  Other objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Convertit *instance*, une instance d'une classe de données, en un "
"dictionnaire. Le résultat est construit par la fonction *dict_factory*. Les "
"clés et valeurs proviennent directement des champs. Les dictionnaires, "
"listes, *n*-uplets et instances de classes de données sont traversés pour "
"convertir récursivement toutes les instances de classes de données qu'ils "
"contiennent. Voici un exemple :"

#: library/dataclasses.rst:330
msgid "Example of using :func:`asdict` on nested dataclasses::"
msgstr ""

#: library/dataclasses.rst:367
msgid "To create a shallow copy, the following workaround may be used::"
msgstr ""

#: library/dataclasses.rst:351
#, fuzzy
msgid ""
":func:`asdict` raises :exc:`TypeError` if ``instance`` is not a dataclass "
"instance."
msgstr ""
"Lève :exc:`TypeError` si *instance* n'est pas une instance d'une classe de "
"données."

#: library/dataclasses.rst:356
#, fuzzy
msgid ""
"Converts the dataclass ``instance`` to a tuple (by using the factory "
"function ``tuple_factory``).  Each dataclass is converted to a tuple of its "
"field values.  dataclasses, dicts, lists, and tuples are recursed into. "
"Other objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Convertit l'instance d'une classe de données *instance* en un *n*-uplet des "
"valeurs de ses champs. Le résultat est construit par la fonction "
"*tuple_factory*. Cette fonction agit récursivement sur les dictionnaires, "
"listes, *n*-uplets et instances de classes de données."

#: library/dataclasses.rst:362
msgid "Continuing from the previous example::"
msgstr "Pour continuer l'exemple précédent :"

#: library/dataclasses.rst:371
#, fuzzy
msgid ""
":func:`astuple` raises :exc:`TypeError` if ``instance`` is not a dataclass "
"instance."
msgstr ""
"Lève :exc:`TypeError` si *instance* n'est pas une instance d'une classe de "
"données."

#: library/dataclasses.rst:376
msgid ""
"Creates a new dataclass with name ``cls_name``, fields as defined in "
"``fields``, base classes as given in ``bases``, and initialized with a "
"namespace as given in ``namespace``.  ``fields`` is an iterable whose "
"elements are each either ``name``, ``(name, type)``, or ``(name, type, "
"Field)``.  If just ``name`` is supplied, ``typing.Any`` is used for "
"``type``.  The values of ``init``, ``repr``, ``eq``, ``order``, "
"``unsafe_hash``, ``frozen``, ``match_args``, ``kw_only``, and  ``slots`` "
"have the same meaning as they do in :func:`dataclass`."
msgstr ""
"Crée une nouvelle classe de données avec le nom *cls_name*. Les champs "
"proviennent de l'objet itérable *fields*. Les classes mères sont lues dans "
"*bases*. L'espace de nommage de la classe est initialisé par *namespace*. La "
"forme la plus générale d'un élément de *fields* est un triplet ``(nom, type, "
"objet_Field)``. Le troisième élément peut être omis. On peut aussi passer un "
"simple nom, auquel cas le type sera ``typing.Any``. Les paramètres restants, "
"à savoir *init*, *repr*, *eq*, *order*, *unsafe_hash*, *frozen*, "
"*march_args*, *kw_only* et *slots*, sont les mêmes que dans :func:"
"`dataclass`."

#: library/dataclasses.rst:386
msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with ``__annotations__`` can then apply the :func:"
"`dataclass` function to convert that class to a dataclass.  This function is "
"provided as a convenience.  For example::"
msgstr ""
"Cette fonction est pratique mais pas absolument nécessaire, puisqu'il suffit "
"de créer par un moyen quelconque une classe avec l'attribut "
"``__annotation__`` et de lui appliquer la fonction :func:`dataclass`, qui la "
"convertit en une classe de données. Par exemple, ceci :"

#: library/dataclasses.rst:398
msgid "Is equivalent to::"
msgstr "est équivalent à ::"

#: library/dataclasses.rst:411
msgid ""
"Creates a new object of the same type as ``instance``, replacing fields with "
"values from ``changes``.  If ``instance`` is not a Data Class, raises :exc:"
"`TypeError`.  If values in ``changes`` do not specify fields, raises :exc:"
"`TypeError`."
msgstr ""
"Crée un nouvel objet du même type que *instance* en effectuant les "
"remplacements donnés par *changes* dans ses champs. L'argument *instance* "
"doit être une instance d'une classe de données, sans quoi :exc:`TypeError` "
"est levée. De même, si une clé dans *changes* ne correspond à aucun champ de "
"l'instance, :exc:`TypeError` est levée."

#: library/dataclasses.rst:416
msgid ""
"The newly returned object is created by calling the :meth:`__init__` method "
"of the dataclass.  This ensures that :meth:`__post_init__`, if present, is "
"also called."
msgstr ""
"L'objet renvoyé est créé à l'aide de la méthode :meth:`__init__` de la "
"classe de données, ce qui garantit que :meth:`__post_init__` est appelée (si "
"elle existe)."

#: library/dataclasses.rst:420
msgid ""
"Init-only variables without default values, if any exist, must be specified "
"on the call to :func:`replace` so that they can be passed to :meth:"
"`__init__` and :meth:`__post_init__`."
msgstr ""
"Si un champ d'initialisation (voir plus bas) n'a pas de valeur par défaut, "
"il faut l'inclure dans l'appel à :func:`replace` afin qu'il soit passé à :"
"meth:`__init__` et :meth:`__post_init__`."

#: library/dataclasses.rst:424
msgid ""
"It is an error for ``changes`` to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"Si une clé de *changes* correspond à un champ défini avec ``init=False``, :"
"exc:`ValueError` est levée."

#: library/dataclasses.rst:428
msgid ""
"Be forewarned about how ``init=False`` fields work during a call to :func:"
"`replace`.  They are not copied from the source object, but rather are "
"initialized in :meth:`__post_init__`, if they're initialized at all.  It is "
"expected that ``init=False`` fields will be rarely and judiciously used.  If "
"they are used, it might be wise to have alternate class constructors, or "
"perhaps a custom ``replace()`` (or similarly named) method which handles "
"instance copying."
msgstr ""
"Prenez garde aux champs définis avec ``init=False`` dans un appel à :func:"
"`replace`. Ils ne sont pas copiés automatiquement de l'instance source. "
"C'est le rôle de :meth:`__post_init__` de les initialiser — ou pas. Les "
"champs avec ``init=False`` doivent rarement être utilisés et seulement à bon "
"escient. Si vous en avez, il peut être sage de traiter la copie des "
"instances par des constructeurs de classe alternatifs, ou bien une méthode "
"personnalisée ``replace()`` (ou un nom similaire)."

#: library/dataclasses.rst:439
msgid ""
"Return ``True`` if its parameter is a dataclass or an instance of one, "
"otherwise return ``False``."
msgstr ""
"Renvoie ``True`` si l'argument est soit une classe de données, soit une "
"instance d'une telle classe. Sinon, renvoie ``False``."

#: library/dataclasses.rst:442
msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"Pour vérifier qu'un objet *obj* est une instance d'une classe de données, et "
"non pas lui-même une classe de données, ajoutez le test ``not "
"isinstance(obj, type)`` ::"

#: library/dataclasses.rst:451
msgid "A sentinel value signifying a missing default or default_factory."
msgstr ""
"Une valeur sentinelle pour dénoter l'absence de *default* ou "
"*default_factory*."

#: library/dataclasses.rst:455
msgid ""
"A sentinel value used as a type annotation.  Any fields after a pseudo-field "
"with the type of :const:`KW_ONLY` are marked as keyword-only fields.  Note "
"that a pseudo-field of type :const:`KW_ONLY` is otherwise completely "
"ignored.  This includes the name of such a field.  By convention, a name of "
"``_`` is used for a :const:`KW_ONLY` field.  Keyword-only fields signify :"
"meth:`__init__` parameters that must be specified as keywords when the class "
"is instantiated."
msgstr ""
"Une valeur sentinelle utilisée en tant qu'annotation de type. Chaque "
"attribut situé après un pseudo-champ ayant pour type la constante :const:"
"`KW_ONLY` est marqué comme champ exclusivement nommé. Notez que le pseudo-"
"champ ayant pour type la constante :const:`KW_ONLY` est par ailleurs "
"complètement ignoré. Par convention le nom ``_`` est utilisé pour "
"l'attribut :const:`KW_ONLY`. Les paramètres de la méthode :meth:`__init__` "
"exclusivement nommés doivent être spécifiés par leur nom lors de "
"l'instanciation de la classe."

#: library/dataclasses.rst:464
msgid ""
"In this example, the fields ``y`` and ``z`` will be marked as keyword-only "
"fields::"
msgstr ""
"Dans cette exemple ``y`` et ``z`` sont marqués comme exclusivement nommés ::"

#: library/dataclasses.rst:475
msgid ""
"In a single dataclass, it is an error to specify more than one field whose "
"type is :const:`KW_ONLY`."
msgstr ""
"Une erreur est levée s'il y a plus d'un champ de type :const:`KW_ONLY` dans "
"une unique classe de données."

#: library/dataclasses.rst:480
msgid ""
"Raised when an implicitly defined :meth:`__setattr__` or :meth:`__delattr__` "
"is called on a dataclass which was defined with ``frozen=True``. It is a "
"subclass of :exc:`AttributeError`."
msgstr ""
"Sous-classe de :exc:`AttributeError`, levée lorsqu'une méthode :meth:"
"`__setattr__` ou :meth:`__delattr__` définie implicitement est appelée dans "
"une classe de données définie avec ``frozen=True``."

#: library/dataclasses.rst:485
msgid "Post-init processing"
msgstr "Post-initialisation"

#: library/dataclasses.rst:487
msgid ""
"The generated :meth:`__init__` code will call a method named :meth:"
"`__post_init__`, if :meth:`__post_init__` is defined on the class.  It will "
"normally be called as ``self.__post_init__()``. However, if any ``InitVar`` "
"fields are defined, they will also be passed to :meth:`__post_init__` in the "
"order they were defined in the class.  If no :meth:`__init__` method is "
"generated, then :meth:`__post_init__` will not automatically be called."
msgstr ""
"Après avoir initialisé l'objet, la méthode :meth:`__init__` générée appelle "
"la méthode :meth:`__post_init__`, si elle est définie. :meth:`__post_init__` "
"est habituellement appelée avec un simple ``self.__post_init__()``. "
"Cependant, si la classe comporte des champs d'initialisation (voir plus "
"bas), leurs valeurs sont aussi passées à :meth:`__post_init__` telles "
"qu'elles ont été fournies à :meth:`__init__`. Si la classe est créée avec "
"``init=False``, :meth:`__post_init__` n'est jamais appelée automatiquement."

#: library/dataclasses.rst:495
msgid ""
"Among other uses, this allows for initializing field values that depend on "
"one or more other fields.  For example::"
msgstr ""
"Cette méthode permet, entre autres, d'initialiser des champs qui dépendent "
"d'autres champs. Par exemple :"

#: library/dataclasses.rst:507
msgid ""
"The :meth:`__init__` method generated by :func:`dataclass` does not call "
"base class :meth:`__init__` methods. If the base class has an :meth:"
"`__init__` method that has to be called, it is common to call this method in "
"a :meth:`__post_init__` method::"
msgstr ""
"Les méthodes :meth:`__init__` des classes mères ne sont pas appelées "
"automatiquement par la méthode :meth:`__init__` que génère :func:"
"`dataclass`. S'il faut appeler ces méthodes :meth:`__init__`, il est courant "
"de le faire dans :meth:`__post_init__` :"

#: library/dataclasses.rst:524
msgid ""
"Note, however, that in general the dataclass-generated :meth:`__init__` "
"methods don't need to be called, since the derived dataclass will take care "
"of initializing all fields of any base class that is a dataclass itself."
msgstr ""
"Notez toutefois qu'il n'est généralement pas nécessaire d'appeler une "
"méthode :meth:`__init__` si elle a été générée automatiquement dans une "
"classe de données, car la classe fille initialise elle-même les champs "
"apportés par toute classe mère qui est aussi une classe de données."

#: library/dataclasses.rst:528
msgid ""
"See the section below on init-only variables for ways to pass parameters to :"
"meth:`__post_init__`.  Also see the warning about how :func:`replace` "
"handles ``init=False`` fields."
msgstr ""
"Voir la section plus bas à propos des variables d'initialisation pour les "
"moyens de passer des paramètres à :meth:`__post_init__`. Voir également "
"l'avertissement sur le traitement par :func:`replace` des champs définis "
"avec ``init=False``."

#: library/dataclasses.rst:533
msgid "Class variables"
msgstr "Variables de classe"

#: library/dataclasses.rst:535
msgid ""
"One of two places where :func:`dataclass` actually inspects the type of a "
"field is to determine if a field is a class variable as defined in :pep:"
"`526`.  It does this by checking if the type of the field is ``typing."
"ClassVar``.  If a field is a ``ClassVar``, it is excluded from consideration "
"as a field and is ignored by the dataclass mechanisms.  Such ``ClassVar`` "
"pseudo-fields are not returned by the module-level :func:`fields` function."
msgstr ""
"Voici le premier des deux cas où le type fourni dans l'annotation d'un champ "
"est pris en compte par :func:`dataclass` au moment de l'exécution. Si ce "
"type est ``typing.ClassVar``, le champ est considéré comme une variable de "
"classe, notion définie dans la :pep:`526`. Les champs de ce genre sont "
"complètement ignorés du point de vue des classes de données. Ils "
"n'apparaissent pas dans le résultat de :func:`fields`."

#: library/dataclasses.rst:544
msgid "Init-only variables"
msgstr "Variables d'initialisation"

#: library/dataclasses.rst:546
msgid ""
"The other place where :func:`dataclass` inspects a type annotation is to "
"determine if a field is an init-only variable.  It does this by seeing if "
"the type of a field is of type ``dataclasses.InitVar``.  If a field is an "
"``InitVar``, it is considered a pseudo-field called an init-only field.  As "
"it is not a true field, it is not returned by the module-level :func:"
"`fields` function.  Init-only fields are added as parameters to the "
"generated :meth:`__init__` method, and are passed to the optional :meth:"
"`__post_init__` method.  They are not otherwise used by dataclasses."
msgstr ""
"L'autre cas où l'annotation de type influence :func:`dataclass` est le "
"suivant : si le type est ``dataclasses.InitVar``, le nom devient un « champ "
"d'initialisation ». Puisque ce n'est pas un vrai champ, il n'est pas inclus "
"dans le *n*-uplet que renvoie :func:`fields`. Les champs d'initialisation "
"sont ajoutés en tant que paramètres à la méthode :meth:`__init__` générée. "
"Leurs valeurs sont passées à :meth:`__post_init__`, si cette méthode existe. "
"C'est la seule manière dont elles sont utilisées."

#: library/dataclasses.rst:556
msgid ""
"For example, suppose a field will be initialized from a database, if a value "
"is not provided when creating the class::"
msgstr ""
"On peut par exemple imaginer un champ initialisé à partir d'une base de "
"données s'il n'a pas reçu de valeur explicite :"

#: library/dataclasses.rst:571
msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for ``i`` "
"and ``j``, but not for ``database``."
msgstr ""
"Ici, :func:`fields` renvoie des objets :class:`Field` correspondant à ``i`` "
"et à ``j``, mais pas à ``database``."

#: library/dataclasses.rst:575
msgid "Frozen instances"
msgstr "Instances figées"

#: library/dataclasses.rst:577
msgid ""
"It is not possible to create truly immutable Python objects.  However, by "
"passing ``frozen=True`` to the :meth:`dataclass` decorator you can emulate "
"immutability.  In that case, dataclasses will add :meth:`__setattr__` and :"
"meth:`__delattr__` methods to the class.  These methods will raise a :exc:"
"`FrozenInstanceError` when invoked."
msgstr ""
"Bien qu'il ne soit pas possible de créer des objets Python strictement "
"immuables, on peut rendre les instances d'une classe de données quasi "
"immuables en passant ``frozen=True`` au décorateur :meth:`dataclass`, ce qui "
"lui fait générer des méthodes :meth:`__setattr__` et :meth:`__delattr__`. "
"Celles-ci lèvent systématiquement l'exception :exc:`FrozenInstanceError`."

#: library/dataclasses.rst:583
msgid ""
"There is a tiny performance penalty when using ``frozen=True``: :meth:"
"`__init__` cannot use simple assignment to initialize fields, and must use :"
"meth:`object.__setattr__`."
msgstr ""
"Les performances sont légèrement moins bonnes avec ``frozen=True`` car :meth:"
"`__init__` doit passer par :meth:`object.__setattr__` au lieu de simples "
"affectations pour initialiser les champs."

#: library/dataclasses.rst:588
msgid "Inheritance"
msgstr "Héritage"

#: library/dataclasses.rst:590
msgid ""
"When the dataclass is being created by the :meth:`dataclass` decorator, it "
"looks through all of the class's base classes in reverse MRO (that is, "
"starting at :class:`object`) and, for each dataclass that it finds, adds the "
"fields from that base class to an ordered mapping of fields. After all of "
"the base class fields are added, it adds its own fields to the ordered "
"mapping.  All of the generated methods will use this combined, calculated "
"ordered mapping of fields.  Because the fields are in insertion order, "
"derived classes override base classes.  An example::"
msgstr ""
"Au moment de la création d'une classe de données, le décorateur :meth:"
"`dataclass` parcourt toutes les classes mères dans l'ordre inverse de "
"résolution des méthodes (donc en commençant par :class:`object`). À chaque "
"fois qu'une classe de données est rencontrée, ses champs sont insérés dans "
"un tableau associatif ordonné. Pour finir, les champs de la classe elle-même "
"sont rajoutés. Toutes les méthodes générées utilisent en interne ce même "
"tableau associatif. Puisqu'il est ordonné, les champs des classes filles "
"écrasent ceux des classes mères. Voici un exemple :"

#: library/dataclasses.rst:610
msgid ""
"The final list of fields is, in order, ``x``, ``y``, ``z``.  The final type "
"of ``x`` is ``int``, as specified in class ``C``."
msgstr ""
"La liste finale des champs contient, dans l'ordre, ``x``, ``y``, ``z``. Le "
"type de ``x`` est ``int``, comme déclaré dans ``C``."

#: library/dataclasses.rst:613
msgid "The generated :meth:`__init__` method for ``C`` will look like::"
msgstr "La méthode :meth:`__init__` générée pour ``C`` ressemble à :"

#: library/dataclasses.rst:618
msgid "Re-ordering of keyword-only parameters in :meth:`__init__`"
msgstr ""
"Réarrangement des paramètres exclusivement nommés dans :meth:`__init__`"

#: library/dataclasses.rst:620
msgid ""
"After the parameters needed for :meth:`__init__` are computed, any keyword-"
"only parameters are moved to come after all regular (non-keyword-only) "
"parameters.  This is a requirement of how keyword-only parameters are "
"implemented in Python: they must come after non-keyword-only parameters."
msgstr ""
"Lorsque les paramètres requis pour :meth:`__init__` sont préparés, tout ceux "
"marqués comme exclusivement nommé sont déplacés pour être positionnés après "
"tous ceux non exclusivement nommés. Ceci est un prérequis de la façon dont "
"les paramètres exclusivement nommés sont implémentés en Python : ils sont "
"après les paramètres non exclusivement nommés."

#: library/dataclasses.rst:626
msgid ""
"In this example, ``Base.y``, ``Base.w``, and ``D.t`` are keyword-only "
"fields, and ``Base.x`` and ``D.z`` are regular fields::"
msgstr ""
"Dans cet exemple, ``Base.y``, ``Base.w``, et ``D.t`` sont des champs "
"exclusivement nommés alors que``Base.x`` et ``D.z`` sont des champs "
"normaux ::"

#: library/dataclasses.rst:641
msgid "The generated :meth:`__init__` method for ``D`` will look like::"
msgstr "La méthode :meth:`__init__` générée pour ``D`` ressemble à  ::"

#: library/dataclasses.rst:645
msgid ""
"Note that the parameters have been re-ordered from how they appear in the "
"list of fields: parameters derived from regular fields are followed by "
"parameters derived from keyword-only fields."
msgstr ""
"Les paramètres ont été réarrangés par rapport à leur ordre d'apparition dans "
"la liste des champs : les paramètres provenant des attributs normaux sont "
"suivis par les paramètres qui proviennent des attributs exclusivement nommés."

#: library/dataclasses.rst:649
msgid ""
"The relative ordering of keyword-only parameters is maintained in the re-"
"ordered :meth:`__init__` parameter list."
msgstr ""
"L'ordre relatif des paramètres exclusivement nommés est conservé par le "
"réarrangement des paramètres d'\\ :meth:`__init__`."

#: library/dataclasses.rst:654
msgid "Default factory functions"
msgstr "Fabriques de valeurs par défaut"

#: library/dataclasses.rst:656
msgid ""
"If a :func:`field` specifies a ``default_factory``, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
"Le paramètre facultatif *default_factory* de :func:`field` est une fonction "
"qui est appelée sans argument pour fournir des valeurs par défaut. Par "
"exemple, voici comment donner la valeur par défaut d'une liste vide :"

#: library/dataclasses.rst:662
msgid ""
"If a field is excluded from :meth:`__init__` (using ``init=False``) and the "
"field also specifies ``default_factory``, then the default factory function "
"will always be called from the generated :meth:`__init__` function.  This "
"happens because there is no other way to give the field an initial value."
msgstr ""
"Si un champ avec fabrique est exclu de :meth:`__init__` (par "
"``init=False``), alors la fabrique est appelée par :meth:`__init__` pour "
"chaque nouvelle instance, puisque c'est le seul moyen d'obtenir une valeur à "
"laquelle initialiser le champ."

#: library/dataclasses.rst:669
msgid "Mutable default values"
msgstr "Valeurs par défaut muables"

#: library/dataclasses.rst:671
msgid ""
"Python stores default member variable values in class attributes. Consider "
"this example, not using dataclasses::"
msgstr ""
"En Python, les valeurs par défaut des attributs sont stockées dans des "
"attributs de la classe. Observez cet exemple, sans classe de données :"

#: library/dataclasses.rst:686
msgid ""
"Note that the two instances of class ``C`` share the same class variable "
"``x``, as expected."
msgstr ""
"Comme attendu, les deux instances de ``C`` partagent le même objet pour "
"l'attribut ``x``."

#: library/dataclasses.rst:689
msgid "Using dataclasses, *if* this code was valid::"
msgstr "Avec les classes de données, si ce code était valide :"

#: library/dataclasses.rst:697
msgid "it would generate code similar to::"
msgstr "il générerait un code équivalent à :"

#: library/dataclasses.rst:708
msgid ""
"This has the same issue as the original example using class ``C``. That is, "
"two instances of class ``D`` that do not specify a value for ``x`` when "
"creating a class instance will share the same copy of ``x``.  Because "
"dataclasses just use normal Python class creation they also share this "
"behavior.  There is no general way for Data Classes to detect this "
"condition.  Instead, the :func:`dataclass` decorator will raise a :exc:"
"`TypeError` if it detects a default parameter of type ``list``, ``dict``, or "
"``set``. This is a partial solution, but it does protect against many common "
"errors."
msgstr ""
"On se retrouve avec le même problème qu'au premier exemple avec la classe "
"``C``. Les classes de données étant créées comme toutes les autres classes "
"Python, leur comportement est identique. Ainsi, deux instances distinctes de "
"``D`` où l'attribut ``x`` a été laissé à sa valeur par défaut partagent la "
"même copie de l'objet ``x``. Il n'y a aucun moyen commun de détecter cette "
"situation. C'est pourquoi le décorateur :func:`dataclass` lève :exc:"
"`TypeError` si une valeur par défaut est de type ``list``, ``dict`` ou "
"``set`` est détectée. Cette solution n'est pas parfaite, mais permet "
"d'éviter la majorité des erreurs."

#: library/dataclasses.rst:719
msgid ""
"Using default factory functions is a way to create new instances of mutable "
"types as default values for fields::"
msgstr ""
"Pour qu'un champ d'un type muable soit par défaut initialisé à un nouvel "
"objet pour chaque instance, utilisez une fonction de fabrique :"

#~ msgid "Module-level decorators, classes, and functions"
#~ msgstr "Décorateurs, classes et fonctions du module"

#~ msgid "Exceptions"
#~ msgstr "Exceptions"
