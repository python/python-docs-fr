# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-24 09:01+0200\n"
"PO-Revision-Date: 2019-12-01 23:39+0100\n"
"Last-Translator: \n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.1\n"

#: library/contextlib.rst:2
msgid ""
":mod:`!contextlib` --- Utilities for :keyword:`!with`\\ -statement contexts"
msgstr ""
":mod:`!contextlib` — Utilitaires pour les contextes s'appuyant sur "
"l'instruction :keyword:`!with`"

#: library/contextlib.rst:7
msgid "**Source code:** :source:`Lib/contextlib.py`"
msgstr "**Code source :** :source:`Lib/contextlib.py`"

#: library/contextlib.rst:11
msgid ""
"This module provides utilities for common tasks involving the :keyword:"
"`with` statement. For more information see also :ref:`typecontextmanager` "
"and :ref:`context-managers`."
msgstr ""
"Ce module fournit des utilitaires pour les tâches impliquant le mot-clé :"
"keyword:`with`. Pour plus d'informations voir aussi :ref:"
"`typecontextmanager` et :ref:`context-managers`."

#: library/contextlib.rst:17
msgid "Utilities"
msgstr "Utilitaires"

#: library/contextlib.rst:19
msgid "Functions and classes provided:"
msgstr "Fonctions et classes fournies :"

#: library/contextlib.rst:23
msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__enter__` and :meth:`object.__exit__`. A default implementation for :meth:"
"`object.__enter__` is provided which returns ``self`` while :meth:`object."
"__exit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`typecontextmanager`."
msgstr ""
":term:`Classe mère abstraite <abstract base class>` pour les classes qui "
"implémentent les méthodes :meth:`object.__enter__` et :meth:`object."
"__exit__`. Une implémentation par défaut de :meth:`object.__enter__` est "
"fournie, qui renvoie ``self``, et :meth:`object.__exit__` est une méthode "
"abstraite qui renvoie ``None`` par défaut. Voir aussi la définition de :ref:"
"`typecontextmanager`."

#: library/contextlib.rst:34
msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__aenter__` and :meth:`object.__aexit__`. A default implementation for :meth:"
"`object.__aenter__` is provided which returns ``self`` while :meth:`object."
"__aexit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`async-context-managers`."
msgstr ""
":term:`Classe mère abstraite <abstract base class>` pour les classes qui "
"implémentent les méthodes :meth:`object.__aenter__` et :meth:`object."
"__aexit__`. Une implémentation par défaut de :meth:`object.__aenter__` est "
"fournie, qui renvoie ``self``, et :meth:`object.__aexit__` est une méthode "
"abstraite qui renvoie ``None`` par défaut. Voir aussi la définition de :ref:"
"`async-context-managers`."

#: library/contextlib.rst:46
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`with` statement context managers, without needing to "
"create a class or separate :meth:`__enter__` and :meth:`__exit__` methods."
msgstr ""
"Cette fonction est un :term:`decorator` qui peut être utilisé pour définir "
"une fonction fabriquant des gestionnaires de contexte à utiliser avec :"
"keyword:`with`, sans nécessiter de créer une classe ou des méthodes :meth:"
"`__enter__` et :meth:`__exit__` séparées."

#: library/contextlib.rst:50
msgid ""
"While many objects natively support use in with statements, sometimes a "
"resource needs to be managed that isn't a context manager in its own right, "
"and doesn't implement a ``close()`` method for use with ``contextlib."
"closing``"
msgstr ""
"Alors que de nombreux objets s'utilisent nativement dans des blocs *with*, "
"on trouve parfois des ressources qui nécessitent d'être gérées mais ne sont "
"pas des gestionnaires de contextes, et qui n'implémentent pas de méthode "
"``close()`` pour pouvoir être utilisées avec ``contextlib.closing``"

#: library/contextlib.rst:54
msgid ""
"An abstract example would be the following to ensure correct resource "
"management::"
msgstr ""
"L'exemple abstrait suivant présente comment assurer une gestion correcte des "
"ressources ::"

#: library/contextlib.rst:73
#, fuzzy
msgid ""
"The function being decorated must return a :term:`generator`-iterator when "
"called. This iterator must yield exactly one value, which will be bound to "
"the targets in the :keyword:`with` statement's :keyword:`!as` clause, if any."
msgstr ""
"La fonction à décorer doit renvoyer un :term:`générateur-itérateur "
"<generator-iterator>` quand elle est appelée. Ce générateur ne doit produire "
"qu'une seule valeur, qui est récupérée dans le bloc :keyword:`with` à l'aide "
"de la clause :keyword:`!as` si précisée."

#: library/contextlib.rst:77
msgid ""
"At the point where the generator yields, the block nested in the :keyword:"
"`with` statement is executed.  The generator is then resumed after the block "
"is exited. If an unhandled exception occurs in the block, it is reraised "
"inside the generator at the point where the yield occurred.  Thus, you can "
"use a :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` "
"statement to trap the error (if any), or ensure that some cleanup takes "
"place. If an exception is trapped merely in order to log it or to perform "
"some action (rather than to suppress it entirely), the generator must "
"reraise that exception. Otherwise the generator context manager will "
"indicate to the :keyword:`!with` statement that the exception has been "
"handled, and execution will resume with the statement immediately following "
"the :keyword:`!with` statement."
msgstr ""
"Au moment où le générateur produit une valeur, le bloc imbriqué sous "
"l'instruction :keyword:`with` est exécuté. Le générateur est ensuite repris "
"après la sortie du bloc. Si une exception non gérée survient dans le bloc, "
"elle est relayée dans le générateur au niveau de l'instruction *yield*. "
"Ainsi, vous pouvez utiliser les instructions :keyword:`try`…\\ :keyword:"
"`except`…\\ :keyword:`finally` pour attraper l'erreur (s'il y a), ou vous "
"assurer qu'un nettoyage a bien lieu. Si une exception est attrapée dans "
"l'unique but d'être journalisée ou d'effectuer une action particulière "
"(autre que supprimer entièrement l'exception), le générateur se doit de la "
"relayer. Autrement le générateur gestionnaire de contexte doit indiquer à "
"l'instruction :keyword:`!with` que l'exception a été gérée, et l'exécution "
"reprend sur l'instruction qui suit directement le bloc :keyword:`!with`."

#: library/contextlib.rst:89
msgid ""
":func:`contextmanager` uses :class:`ContextDecorator` so the context "
"managers it creates can be used as decorators as well as in :keyword:`with` "
"statements. When used as a decorator, a new generator instance is implicitly "
"created on each function call (this allows the otherwise \"one-shot\" "
"context managers created by :func:`contextmanager` to meet the requirement "
"that context managers support multiple invocations in order to be used as "
"decorators)."
msgstr ""
"Le décorateur :func:`contextmanager` utilise la classe :class:"
"`ContextDecorator` afin que les gestionnaires de contexte qu'il crée "
"puissent être utilisés aussi bien en tant que décorateurs qu'avec des "
"instructions :keyword:`with`. Quand vous l'utilisez comme décorateur, une "
"nouvelle instance du générateur est créée à chaque appel de la fonction "
"(cela permet aux gestionnaires de contexte à usage unique créés par :func:"
"`contextmanager` de remplir la condition de pouvoir être invoqués plusieurs "
"fois afin d'être utilisés comme décorateurs)."

#: library/contextlib.rst:96
msgid "Use of :class:`ContextDecorator`."
msgstr "Utilisation de la classe :class:`ContextDecorator`."

#: library/contextlib.rst:102
msgid ""
"Similar to :func:`~contextlib.contextmanager`, but creates an :ref:"
"`asynchronous context manager <async-context-managers>`."
msgstr ""
"Similaire à :func:`~contextlib.contextmanager`, mais crée un :ref:"
"`gestionnaire de contexte asynchrone <async-context-managers>`."

#: library/contextlib.rst:105
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`async with` statement asynchronous context managers, "
"without needing to create a class or separate :meth:`__aenter__` and :meth:"
"`__aexit__` methods. It must be applied to an :term:`asynchronous generator` "
"function."
msgstr ""
"Cette fonction est un :term:`decorator` qui peut être utilisé pour définir "
"une fonction fabriquant des gestionnaires de contexte asynchrones à utiliser "
"avec :keyword:`async with`, sans nécessiter de créer une classe ou des "
"méthodes :meth:`__aenter__` et :meth:`__aexit__` séparées. Le décorateur "
"doit être appliqué à une fonction renvoyant un :term:`asynchronous "
"generator`."

#: library/contextlib.rst:111
msgid "A simple example::"
msgstr "Un exemple simple ::"

#: library/contextlib.rst:132
msgid ""
"Return a context manager that closes *thing* upon completion of the block.  "
"This is basically equivalent to::"
msgstr ""
"Renvoie un gestionnaire de contexte qui ferme *thing* à la fin du bloc. "
"C'est essentiellement équivalent à ::"

#: library/contextlib.rst:144
msgid "And lets you write code like this::"
msgstr "Et cela vous permet d'écrire du code tel que ::"

#: library/contextlib.rst:153
msgid ""
"without needing to explicitly close ``page``.  Even if an error occurs, "
"``page.close()`` will be called when the :keyword:`with` block is exited."
msgstr ""
"sans besoin de fermer explicitement ``page``. Même si une erreur survient, "
"``page.close()`` est appelée à la fermeture du bloc :keyword:`with`."

#: library/contextlib.rst:161
msgid ""
"Return a context manager that returns *enter_result* from ``__enter__``, but "
"otherwise does nothing. It is intended to be used as a stand-in for an "
"optional context manager, for example::"
msgstr ""
"Renvoie un gestionnaire de contexte dont la méthode ``__enter__`` renvoie "
"*enter_result*, mais ne fait rien d'autre. L'idée est de l'utiliser comme "
"remplaçant pour un gestionnaire de contexte optionnel, par exemple ::"

#: library/contextlib.rst:175
msgid "An example using *enter_result*::"
msgstr "Un exemple utilisant *enter_result* ::"

#: library/contextlib.rst:193
msgid ""
"Return a context manager that suppresses any of the specified exceptions if "
"they occur in the body of a with statement and then resumes execution with "
"the first statement following the end of the with statement."
msgstr ""
"Renvoie un gestionnaire de contexte qui supprime toutes les exceptions "
"spécifiées si elles surviennent dans le corps du bloc *with*, et reprend "
"l'exécution sur la première instruction qui suit la fin du bloc *with*."

#: library/contextlib.rst:197
msgid ""
"As with any other mechanism that completely suppresses exceptions, this "
"context manager should be used only to cover very specific errors where "
"silently continuing with program execution is known to be the right thing to "
"do."
msgstr ""
"Comme pour tous les mécanismes qui suppriment complètement les exceptions, "
"ce gestionnaire de contexte doit seulement être utilisé pour couvrir des cas "
"très spécifiques d'erreurs où il est certain que continuer silencieusement "
"l'exécution du programme est la bonne chose à faire."

#: library/contextlib.rst:202
msgid "For example::"
msgstr "Par exemple ::"

#: library/contextlib.rst:212
msgid "This code is equivalent to::"
msgstr "Ce code est équivalent à ::"

#: library/contextlib.rst:224 library/contextlib.rst:263
#: library/contextlib.rst:273
msgid "This context manager is :ref:`reentrant <reentrant-cms>`."
msgstr "Ce gestionnaire de contexte est :ref:`réentrant <reentrant-cms>`."

#: library/contextlib.rst:231
msgid ""
"Context manager for temporarily redirecting :data:`sys.stdout` to another "
"file or file-like object."
msgstr ""
"Gestionnaire de contexte servant à rediriger temporairement :data:`sys."
"stdout` vers un autre fichier ou objet fichier-compatible."

#: library/contextlib.rst:234
msgid ""
"This tool adds flexibility to existing functions or classes whose output is "
"hardwired to stdout."
msgstr ""
"Cet outil ajoute une certaine flexibilité aux fonctions ou classes "
"existantes dont la sortie est envoyée vers la sortie standard."

#: library/contextlib.rst:237
msgid ""
"For example, the output of :func:`help` normally is sent to *sys.stdout*. "
"You can capture that output in a string by redirecting the output to an :"
"class:`io.StringIO` object::"
msgstr ""
"Par exemple, la sortie de :func:`help` est normalement envoyée vers *sys."
"stdout*. Vous pouvez capturer cette sortie dans une chaîne de caractères en "
"la redirigeant vers un objet :class:`io.StringIO` ::"

#: library/contextlib.rst:246
msgid ""
"To send the output of :func:`help` to a file on disk, redirect the output to "
"a regular file::"
msgstr ""
"Pour envoyer la sortie de :func:`help` vers un fichier sur le disque, "
"redirigez-la sur un fichier normal ::"

#: library/contextlib.rst:253
msgid "To send the output of :func:`help` to *sys.stderr*::"
msgstr "Pour envoyer la sortie de :func:`help` sur *sys.stderr* ::"

#: library/contextlib.rst:258
msgid ""
"Note that the global side effect on :data:`sys.stdout` means that this "
"context manager is not suitable for use in library code and most threaded "
"applications. It also has no effect on the output of subprocesses. However, "
"it is still a useful approach for many utility scripts."
msgstr ""
"Notez que l'effet de bord global sur :data:`sys.stdout` signifie que ce "
"gestionnaire de contexte n'est pas adapté à une utilisation dans le code "
"d'une bibliothèque ni dans la plupart des applications à plusieurs fils "
"d'exécution. Aussi, cela n'a pas d'effet sur la sortie des sous-processus. "
"Cependant, cela reste une approche utile pour beaucoup de scripts "
"utilitaires."

#: library/contextlib.rst:270
msgid ""
"Similar to :func:`~contextlib.redirect_stdout` but redirecting :data:`sys."
"stderr` to another file or file-like object."
msgstr ""
"Similaire à :func:`~contextlib.redirect_stdout` mais redirige :data:`sys."
"stderr` vers un autre fichier ou objet fichier-compatible."

#: library/contextlib.rst:280
msgid ""
"A base class that enables a context manager to also be used as a decorator."
msgstr ""
"Une classe mère qui permet à un gestionnaire de contexte d'être aussi "
"utilisé comme décorateur."

#: library/contextlib.rst:282
msgid ""
"Context managers inheriting from ``ContextDecorator`` have to implement "
"``__enter__`` and ``__exit__`` as normal. ``__exit__`` retains its optional "
"exception handling even when used as a decorator."
msgstr ""
"Les gestionnaires de contexte héritant de ``ContextDecorator`` doivent "
"implémenter ``__enter__`` et ``__exit__`` comme habituellement. ``__exit__`` "
"conserve sa gestion optionnelle des exceptions même lors de l'utilisation en "
"décorateur."

#: library/contextlib.rst:286
msgid ""
"``ContextDecorator`` is used by :func:`contextmanager`, so you get this "
"functionality automatically."
msgstr ""
"``ContextDecorator`` est utilisé par :func:`contextmanager`, donc vous "
"bénéficiez automatiquement de cette fonctionnalité."

#: library/contextlib.rst:289
msgid "Example of ``ContextDecorator``::"
msgstr "Exemple de ``ContextDecorator`` ::"

#: library/contextlib.rst:318
msgid ""
"This change is just syntactic sugar for any construct of the following form::"
msgstr ""
"Ce changement est simplement un sucre syntaxique pour les constructions de "
"la forme suivante ::"

#: library/contextlib.rst:324
msgid "``ContextDecorator`` lets you instead write::"
msgstr "``ContextDecorator`` vous permet d'écrire à la place ::"

#: library/contextlib.rst:330
msgid ""
"It makes it clear that the ``cm`` applies to the whole function, rather than "
"just a piece of it (and saving an indentation level is nice, too)."
msgstr ""
"Cela éclaircit le fait que ``cm`` s'applique à la fonction entière, et pas "
"seulement à un morceau en particulier (et gagner un niveau d'indentation est "
"toujours appréciable)."

#: library/contextlib.rst:333
msgid ""
"Existing context managers that already have a base class can be extended by "
"using ``ContextDecorator`` as a mixin class::"
msgstr ""
"Les gestionnaires de contexte existants qui ont déjà une classe mère peuvent "
"être étendus en utilisant ``ContextDecorator`` comme une *mixin* ::"

#: library/contextlib.rst:346
msgid ""
"As the decorated function must be able to be called multiple times, the "
"underlying context manager must support use in multiple :keyword:`with` "
"statements. If this is not the case, then the original construct with the "
"explicit :keyword:`!with` statement inside the function should be used."
msgstr ""
"Comme la fonction décorée doit être capable d'être appelée plusieurs fois, "
"le gestionnaire de contexte sous-jacent doit permettre d'être utilisé dans "
"de multiples instructions :keyword:`with`. Si ce n'est pas le cas, alors la "
"construction d'origine avec de multiples instructions :keyword:`!with` au "
"sein de la fonction doit être utilisée."

#: library/contextlib.rst:356
msgid ""
"A context manager that is designed to make it easy to programmatically "
"combine other context managers and cleanup functions, especially those that "
"are optional or otherwise driven by input data."
msgstr ""
"Gestionnaire de contexte conçu pour simplifier le fait de combiner "
"programmatiquement d'autres gestionnaires de contexte et fonctions de "
"nettoyage, spécifiquement ceux qui sont optionnels ou pilotés par des "
"données d'entrée."

#: library/contextlib.rst:360
msgid ""
"For example, a set of files may easily be handled in a single with statement "
"as follows::"
msgstr ""
"Par exemple, un ensemble de fichiers peut facilement être géré dans une "
"unique instruction *with* comme suit ::"

#: library/contextlib.rst:369
msgid ""
"Each instance maintains a stack of registered callbacks that are called in "
"reverse order when the instance is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement). Note that callbacks are *not* "
"invoked implicitly when the context stack instance is garbage collected."
msgstr ""
"Chaque instance maintient une pile de fonctions de rappels (*callbacks*) "
"enregistrées qui sont appelées en ordre inverse quand l'instance est fermée "
"(explicitement ou implicitement à la fin d'un bloc :keyword:`with`). Notez "
"que ces fonctions ne sont *pas* invoquées implicitement quand l'instance de "
"la pile de contextes est collectée par le ramasse-miettes."

#: library/contextlib.rst:374
msgid ""
"This stack model is used so that context managers that acquire their "
"resources in their ``__init__`` method (such as file objects) can be handled "
"correctly."
msgstr ""
"Ce modèle de pile est utilisé afin que les gestionnaires de contexte qui "
"acquièrent leurs ressources dans leur méthode ``__init__`` (tels que les "
"objets-fichiers) puissent être gérés correctement."

#: library/contextlib.rst:378
msgid ""
"Since registered callbacks are invoked in the reverse order of registration, "
"this ends up behaving as if multiple nested :keyword:`with` statements had "
"been used with the registered set of callbacks. This even extends to "
"exception handling - if an inner callback suppresses or replaces an "
"exception, then outer callbacks will be passed arguments based on that "
"updated state."
msgstr ""
"Comme les fonctions de rappel enregistrées sont invoquées dans l'ordre "
"inverse d'enregistrement, cela revient au même que si de multiples blocs :"
"keyword:`with` imbriqués avaient été utilisés avec l'ensemble de fonctions "
"enregistrées. Cela s'étend aussi à la gestion d'exceptions — si une fonction "
"de rappel intérieure supprime ou remplace une exception, alors les fonctions "
"extérieures reçoivent des arguments basés sur ce nouvel état."

#: library/contextlib.rst:385
msgid ""
"This is a relatively low level API that takes care of the details of "
"correctly unwinding the stack of exit callbacks. It provides a suitable "
"foundation for higher level context managers that manipulate the exit stack "
"in application specific ways."
msgstr ""
"C'est une *API* relativement bas-niveau qui s'occupe de dérouler "
"correctement la pile des appels de sortie. Elle fournit une base adaptée "
"pour des gestionnaires de contexte de plus haut niveau qui manipulent la "
"pile de sortie de manière spécifique à l'application."

#: library/contextlib.rst:394
msgid ""
"Enters a new context manager and adds its :meth:`__exit__` method to the "
"callback stack. The return value is the result of the context manager's own :"
"meth:`__enter__` method."
msgstr ""
"Entre dans un nouveau gestionnaire de contexte et ajoute sa méthode :meth:"
"`__exit__` à la pile d'appels. La valeur de retour est le résultat de la "
"méthode :meth:`__enter__` du gestionnaire de contexte donné."

#: library/contextlib.rst:398
msgid ""
"These context managers may suppress exceptions just as they normally would "
"if used directly as part of a :keyword:`with` statement."
msgstr ""
"Ces gestionnaires de contexte peuvent supprimer des exceptions comme ils le "
"feraient normalement s'ils étaient utilisés directement derrière une "
"instruction :keyword:`with`."

#: library/contextlib.rst:403
msgid "Adds a context manager's :meth:`__exit__` method to the callback stack."
msgstr ""
"Ajoute la méthode :meth:`__exit__` d'un gestionnaire de contexte à la pile "
"d'appels."

#: library/contextlib.rst:405
msgid ""
"As ``__enter__`` is *not* invoked, this method can be used to cover part of "
"an :meth:`__enter__` implementation with a context manager's own :meth:"
"`__exit__` method."
msgstr ""
"Comme ``__enter__`` n'est *pas* invoquée, cette méthode peut être utilisée "
"pour couvrir une partie de l'implémentation de :meth:`__enter__` avec la "
"propre méthode :meth:`__exit__` d'un gestionnaire de contexte."

#: library/contextlib.rst:409
msgid ""
"If passed an object that is not a context manager, this method assumes it is "
"a callback with the same signature as a context manager's :meth:`__exit__` "
"method and adds it directly to the callback stack."
msgstr ""
"Si l'argument passé n'est pas un gestionnaire de contexte, la méthode assume "
"qu'il s'agit d'une fonction de rappel avec la même signature que la méthode :"
"meth:`__exit__` des gestionnaires de contexte pour l'ajouter directement à "
"la pile d'appels."

#: library/contextlib.rst:413
msgid ""
"By returning true values, these callbacks can suppress exceptions the same "
"way context manager :meth:`__exit__` methods can."
msgstr ""
"En retournant des valeurs vraies, ces fonctions peuvent supprimer des "
"exceptions de la même manière que le peuvent les méthodes :meth:`__exit__` "
"des gestionnaires de contexte."

#: library/contextlib.rst:416
msgid ""
"The passed in object is returned from the function, allowing this method to "
"be used as a function decorator."
msgstr ""
"L'objet passé en paramètre est renvoyé par la fonction, ce qui permet à la "
"méthode d'être utilisée comme décorateur de fonction."

#: library/contextlib.rst:421
msgid ""
"Accepts an arbitrary callback function and arguments and adds it to the "
"callback stack."
msgstr ""
"Accepte une fonction arbitraire et ses arguments et les ajoute à la pile des "
"fonctions de rappel."

#: library/contextlib.rst:424
msgid ""
"Unlike the other methods, callbacks added this way cannot suppress "
"exceptions (as they are never passed the exception details)."
msgstr ""
"À la différence des autres méthodes, les fonctions de rappel ajoutées de "
"cette manière ne peuvent pas supprimer les exceptions (puisqu'elles ne "
"reçoivent jamais les détails de l'exception)."

#: library/contextlib.rst:427
msgid ""
"The passed in callback is returned from the function, allowing this method "
"to be used as a function decorator."
msgstr ""
"La fonction passée en paramètre est renvoyée par la méthode, ce qui permet à "
"la méthode d'être utilisée comme décorateur de fonction."

#: library/contextlib.rst:432
msgid ""
"Transfers the callback stack to a fresh :class:`ExitStack` instance and "
"returns it. No callbacks are invoked by this operation - instead, they will "
"now be invoked when the new stack is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement)."
msgstr ""
"Transfère la pile d'appels à une nouvelle instance de :class:`ExitStack` et "
"la renvoie. Aucune fonction de rappel n'est invoquée par cette opération — à "
"la place, elles sont dorénavant invoquées quand la nouvelle pile sera close "
"(soit explicitement soit implicitement à la fin d'un bloc :keyword:`with`)."

#: library/contextlib.rst:437
msgid ""
"For example, a group of files can be opened as an \"all or nothing\" "
"operation as follows::"
msgstr ""
"Par exemple, un groupe de fichiers peut être ouvert comme une opération "
"« tout ou rien » comme suit ::"

#: library/contextlib.rst:451
msgid ""
"Immediately unwinds the callback stack, invoking callbacks in the reverse "
"order of registration. For any context managers and exit callbacks "
"registered, the arguments passed in will indicate that no exception occurred."
msgstr ""
"Déroule immédiatement la pile d'appels, invoquant les fonctions de rappel "
"dans l'ordre inverse d'enregistrement. Pour chaque gestionnaire de contexte "
"et fonction de sortie enregistré, les arguments passés indiqueront qu'aucune "
"exception n'est survenue."

#: library/contextlib.rst:458
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>`, similar to :"
"class:`ExitStack`, that supports combining both synchronous and asynchronous "
"context managers, as well as having coroutines for cleanup logic."
msgstr ""
"Un :ref:`gestionnaire de contexte asynchrone <async-context-managers>`, "
"similaire à :class:`ExitStack`, apte à combiner à la fois des gestionnaires "
"de contexte synchrones et asynchrones, ainsi que la gestion de coroutines "
"pour la logique de nettoyage."

#: library/contextlib.rst:463
msgid ""
"The :meth:`close` method is not implemented, :meth:`aclose` must be used "
"instead."
msgstr ""
"La méthode :meth:`close` n'est pas implémentée, :meth:`aclose` doit plutôt "
"être utilisée."

#: library/contextlib.rst:468
msgid ""
"Similar to :meth:`enter_context` but expects an asynchronous context manager."
msgstr ""
"Similaire à :meth:`enter_context` mais attend un gestionnaire de contexte "
"asynchrone."

#: library/contextlib.rst:473
msgid ""
"Similar to :meth:`push` but expects either an asynchronous context manager "
"or a coroutine function."
msgstr ""
"Similaire à :meth:`push` mais attend soit un gestionnaire de contexte "
"asynchrone soit une fonction coroutine."

#: library/contextlib.rst:478
msgid "Similar to :meth:`callback` but expects a coroutine function."
msgstr "Similaire à :meth:`callback` mais attend une fonction coroutine."

#: library/contextlib.rst:482
msgid "Similar to :meth:`close` but properly handles awaitables."
msgstr ""
"Similaire à :meth:`close` mais gère correctement les tâches asynchrones."

#: library/contextlib.rst:484
msgid "Continuing the example for :func:`asynccontextmanager`::"
msgstr "En continuité de l'exemple de :func:`asynccontextmanager` ::"

#: library/contextlib.rst:496
msgid "Examples and Recipes"
msgstr "Exemples et Recettes"

#: library/contextlib.rst:498
msgid ""
"This section describes some examples and recipes for making effective use of "
"the tools provided by :mod:`contextlib`."
msgstr ""
"Cette section décrit quelques exemples et recettes pour décrire une "
"utilisation réelle des outils fournis par :mod:`contextlib`."

#: library/contextlib.rst:503
msgid "Supporting a variable number of context managers"
msgstr "Gérer un nombre variable de gestionnaires de contexte"

#: library/contextlib.rst:505
msgid ""
"The primary use case for :class:`ExitStack` is the one given in the class "
"documentation: supporting a variable number of context managers and other "
"cleanup operations in a single :keyword:`with` statement. The variability "
"may come from the number of context managers needed being driven by user "
"input (such as opening a user specified collection of files), or from some "
"of the context managers being optional::"
msgstr ""
"Le cas d'utilisation primaire de :class:`ExitStack` est celui décrit dans la "
"documentation de la classe : gérer un nombre variable de gestionnaires de "
"contexte et d'autres opérations de nettoyage en une unique instruction :"
"keyword:`with`. La variabilité peut venir du nombre de gestionnaires de "
"contexte voulus découlant d'une entrée de l'utilisateur (comme ouvrir une "
"collection spécifique de fichiers de l'utilisateur), ou de certains "
"gestionnaires de contexte qui peuvent être optionnels ::"

#: library/contextlib.rst:520
msgid ""
"As shown, :class:`ExitStack` also makes it quite easy to use :keyword:`with` "
"statements to manage arbitrary resources that don't natively support the "
"context management protocol."
msgstr ""
"Comme montré, :class:`ExitStack` rend aussi assez facile d'utiliser les "
"instructions :keyword:`with` pour gérer des ressources arbitraires qui ne "
"gèrent pas nativement le protocole des gestionnaires de contexte."

#: library/contextlib.rst:526
msgid "Catching exceptions from ``__enter__`` methods"
msgstr "Attraper des exceptions depuis les méthodes ``__enter__``"

#: library/contextlib.rst:528
msgid ""
"It is occasionally desirable to catch exceptions from an ``__enter__`` "
"method implementation, *without* inadvertently catching exceptions from the :"
"keyword:`with` statement body or the context manager's ``__exit__`` method. "
"By using :class:`ExitStack` the steps in the context management protocol can "
"be separated slightly in order to allow this::"
msgstr ""
"Il est occasionnellement souhaitable d'attraper les exceptions depuis "
"l'implémentation d'une méthode ``__enter__``, *sans* attraper par "
"inadvertance les exceptions du corps de l'instruction :keyword:`with` ou de "
"la méthode ``__exit__`` des gestionnaires de contexte. En utilisant :class:"
"`ExitStack`, les étapes du protocole des gestionnaires de contexte peuvent "
"être légèrement séparées pour permettre le code suivant ::"

#: library/contextlib.rst:543
msgid ""
"Actually needing to do this is likely to indicate that the underlying API "
"should be providing a direct resource management interface for use with :"
"keyword:`try`/:keyword:`except`/:keyword:`finally` statements, but not all "
"APIs are well designed in that regard. When a context manager is the only "
"resource management API provided, then :class:`ExitStack` can make it easier "
"to handle various situations that can't be handled directly in a :keyword:"
"`with` statement."
msgstr ""
"Avoir à faire cela est en fait surtout utile pour indiquer que l'*API* sous-"
"jacente devrait fournir une interface directe de gestion des ressources à "
"utiliser avec les instructions :keyword:`try`/:keyword:`except`/:keyword:"
"`finally`, mais que toutes les *API* ne sont pas bien conçues dans cet "
"objectif. Quand un gestionnaire de contexte est la seule *API* de gestion "
"des ressources fournie, alors :class:`ExitStack` peut rendre plus facile la "
"gestion de plusieurs situations qui ne peuvent pas être traitées directement "
"dans une instruction :keyword:`with`."

#: library/contextlib.rst:553
msgid "Cleaning up in an ``__enter__`` implementation"
msgstr "Nettoyer dans une méthode ``__enter__``"

#: library/contextlib.rst:555
msgid ""
"As noted in the documentation of :meth:`ExitStack.push`, this method can be "
"useful in cleaning up an already allocated resource if later steps in the :"
"meth:`__enter__` implementation fail."
msgstr ""
"Comme indiqué dans la documentation de :meth:`ExitStack.push`, cette méthode "
"peut être utile pour nettoyer une ressource déjà allouée si les dernières "
"étapes de l'implémentation de :meth:`__enter__` échouent."

#: library/contextlib.rst:559
msgid ""
"Here's an example of doing this for a context manager that accepts resource "
"acquisition and release functions, along with an optional validation "
"function, and maps them to the context management protocol::"
msgstr ""
"Voici un exemple de gestionnaire de contexte qui reçoit des fonctions "
"d'acquisition de ressources et de libération, avec une méthode de validation "
"optionnelle, et qui les adapte au protocole des gestionnaires de contexte ::"

#: library/contextlib.rst:599
msgid "Replacing any use of ``try-finally`` and flag variables"
msgstr "Remplacer un ``try-finally`` avec une option variable"

#: library/contextlib.rst:601
msgid ""
"A pattern you will sometimes see is a ``try-finally`` statement with a flag "
"variable to indicate whether or not the body of the ``finally`` clause "
"should be executed. In its simplest form (that can't already be handled just "
"by using an ``except`` clause instead), it looks something like this::"
msgstr ""
"Un modèle que vous rencontrerez parfois est un bloc ``try-finally`` avec une "
"option pour indiquer si le corps de la clause ``finally`` doit être exécuté "
"ou non. Dans sa forme la plus simple (qui ne peut pas déjà être gérée avec "
"juste une clause ``except``), cela ressemble à ::"

#: library/contextlib.rst:615
msgid ""
"As with any ``try`` statement based code, this can cause problems for "
"development and review, because the setup code and the cleanup code can end "
"up being separated by arbitrarily long sections of code."
msgstr ""
"Comme avec n'importe quel code basé sur une instruction ``try``, cela peut "
"poser problème pour le développement et la revue, parce que beaucoup de "
"codes d'installation et de nettoyage peuvent finir par être séparés par des "
"sections de code arbitrairement longues."

#: library/contextlib.rst:619
msgid ""
":class:`ExitStack` makes it possible to instead register a callback for "
"execution at the end of a ``with`` statement, and then later decide to skip "
"executing that callback::"
msgstr ""
":class:`ExitStack` rend possible de plutôt enregistrer une fonction de "
"rappel pour être exécutée à la fin d'une instruction ``with``, et décider "
"ensuite de passer l'exécution de cet appel ::"

#: library/contextlib.rst:631
msgid ""
"This allows the intended cleanup up behaviour to be made explicit up front, "
"rather than requiring a separate flag variable."
msgstr ""
"Cela permet de rendre explicite dès le départ le comportement de nettoyage "
"attendu, plutôt que de nécessiter une option séparée."

#: library/contextlib.rst:634
msgid ""
"If a particular application uses this pattern a lot, it can be simplified "
"even further by means of a small helper class::"
msgstr ""
"Si une application particulière utilise beaucoup ce modèle, cela peut-être "
"simplifié encore plus au moyen d'une petite classe d'aide ::"

#: library/contextlib.rst:652
msgid ""
"If the resource cleanup isn't already neatly bundled into a standalone "
"function, then it is still possible to use the decorator form of :meth:"
"`ExitStack.callback` to declare the resource cleanup in advance::"
msgstr ""
"Si le nettoyage de la ressource n'est pas déjà soigneusement embarqué dans "
"une fonction autonome, il est possible d'utiliser le décorateur :meth:"
"`ExitStack.callback` pour déclarer la fonction de nettoyage de ressource en "
"avance ::"

#: library/contextlib.rst:667
msgid ""
"Due to the way the decorator protocol works, a callback function declared "
"this way cannot take any parameters. Instead, any resources to be released "
"must be accessed as closure variables."
msgstr ""
"Dû au fonctionnement du protocole des décorateurs, une fonction déclarée "
"ainsi ne peut prendre aucun paramètre. À la place, les ressources à libérer "
"doivent être récupérées depuis l'extérieur comme des variables de fermeture "
"(*closure*)."

#: library/contextlib.rst:673
msgid "Using a context manager as a function decorator"
msgstr ""
"Utiliser un gestionnaire de contexte en tant que décorateur de fonction"

#: library/contextlib.rst:675
msgid ""
":class:`ContextDecorator` makes it possible to use a context manager in both "
"an ordinary ``with`` statement and also as a function decorator."
msgstr ""
":class:`ContextDecorator` rend possible l'utilisation d'un gestionnaire de "
"contexte à la fois ordinairement avec une instruction ``with`` ou comme un "
"décorateur de fonction."

#: library/contextlib.rst:678
msgid ""
"For example, it is sometimes useful to wrap functions or groups of "
"statements with a logger that can track the time of entry and time of exit.  "
"Rather than writing both a function decorator and a context manager for the "
"task, inheriting from :class:`ContextDecorator` provides both capabilities "
"in a single definition::"
msgstr ""
"Par exemple, il est parfois utile d'emballer les fonctions ou blocs "
"d'instructions avec un journaliseur qui pourrait suivre le temps d'exécution "
"entre l'entrée et la sortie. Plutôt qu'écrire à la fois un décorateur et un "
"gestionnaire de contexte pour la même tâche, hériter de :class:"
"`ContextDecorator` fournit les deux fonctionnalités en une seule "
"définition ::"

#: library/contextlib.rst:699
msgid "Instances of this class can be used as both a context manager::"
msgstr ""
"Les instances de cette classe peuvent être utilisées comme gestionnaires de "
"contexte ::"

#: library/contextlib.rst:705
msgid "And also as a function decorator::"
msgstr "Et comme décorateurs de fonctions ::"

#: library/contextlib.rst:712
msgid ""
"Note that there is one additional limitation when using context managers as "
"function decorators: there's no way to access the return value of :meth:"
"`__enter__`. If that value is needed, then it is still necessary to use an "
"explicit ``with`` statement."
msgstr ""
"Notez qu'il y a une autre limitation en utilisant les gestionnaires de "
"contexte comme décorateurs : il n'y a aucune manière d'accéder à la valeur "
"de retour de :meth:`__enter__`. Si cette valeur est nécessaire, il faut "
"utiliser explicitement une instruction ``with``."

#: library/contextlib.rst:720
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - The \"with\" statement"

#: library/contextlib.rst:720
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"La spécification, les motivations et des exemples de l'instruction :keyword:"
"`with` en Python."

#: library/contextlib.rst:726
msgid "Single use, reusable and reentrant context managers"
msgstr "Gestionnaires de contexte à usage unique, réutilisables et réentrants"

#: library/contextlib.rst:728
msgid ""
"Most context managers are written in a way that means they can only be used "
"effectively in a :keyword:`with` statement once. These single use context "
"managers must be created afresh each time they're used - attempting to use "
"them a second time will trigger an exception or otherwise not work correctly."
msgstr ""
"La plupart des gestionnaires de contexte sont écrits d'une manière qui ne "
"leur permet que d'être utilisés une fois avec une instruction :keyword:"
"`with`. Ces gestionnaires de contexte à usage unique doivent être recréés "
"chaque fois qu'ils sont utilisés — tenter de les utiliser une seconde fois "
"lève une exception ou ne fonctionne pas correctement."

#: library/contextlib.rst:734
msgid ""
"This common limitation means that it is generally advisable to create "
"context managers directly in the header of the :keyword:`with` statement "
"where they are used (as shown in all of the usage examples above)."
msgstr ""
"Cette limitation commune signifie qu'il est généralement conseillé de créer "
"les gestionnaires de contexte directement dans l'en-tête du bloc :keyword:"
"`with` où ils sont utilisés (comme montré dans tous les exemples "
"d'utilisation au-dessus)."

#: library/contextlib.rst:738
msgid ""
"Files are an example of effectively single use context managers, since the "
"first :keyword:`with` statement will close the file, preventing any further "
"IO operations using that file object."
msgstr ""
"Les fichiers sont un exemple de gestionnaires de contexte étant "
"effectivement à usage unique, puisque la première instruction :keyword:"
"`with` ferme le fichier, empêchant d'autres opérations d'entrée/sortie "
"d'être exécutées sur ce fichier."

#: library/contextlib.rst:742
msgid ""
"Context managers created using :func:`contextmanager` are also single use "
"context managers, and will complain about the underlying generator failing "
"to yield if an attempt is made to use them a second time::"
msgstr ""
"Les gestionnaires de contexte créés avec :func:`contextmanager` sont aussi à "
"usage unique, et se plaindront du fait que le générateur sous-jacent ne "
"produise plus de valeur si vous essayez de les utiliser une seconde fois ::"

#: library/contextlib.rst:770
msgid "Reentrant context managers"
msgstr "Gestionnaires de contexte réentrants"

#: library/contextlib.rst:772
msgid ""
"More sophisticated context managers may be \"reentrant\". These context "
"managers can not only be used in multiple :keyword:`with` statements, but "
"may also be used *inside* a :keyword:`!with` statement that is already using "
"the same context manager."
msgstr ""
"Certains gestionnaires de contexte plus sophistiqués peuvent être "
"« réentrants ». Ces gestionnaires de contexte ne peuvent pas seulement être "
"utilisés avec plusieurs instructions :keyword:`with`, mais aussi *à "
"l'intérieur* d'une instruction :keyword:`!with` qui utilise déjà ce même "
"gestionnaire de contexte."

#: library/contextlib.rst:777
msgid ""
":class:`threading.RLock` is an example of a reentrant context manager, as "
"are :func:`suppress` and :func:`redirect_stdout`. Here's a very simple "
"example of reentrant use::"
msgstr ""
":class:`threading.RLock` est un exemple de gestionnaire de contexte "
"réentrant, comme le sont aussi :func:`suppress` et :func:`redirect_stdout`. "
"Voici un très simple exemple d'utilisation réentrante ::"

#: library/contextlib.rst:796
msgid ""
"Real world examples of reentrancy are more likely to involve multiple "
"functions calling each other and hence be far more complicated than this "
"example."
msgstr ""
"Les exemples plus réels de réentrance sont susceptibles d'invoquer plusieurs "
"fonctions s'entre-appelant, et donc être bien plus compliqués que cet "
"exemple."

#: library/contextlib.rst:800
msgid ""
"Note also that being reentrant is *not* the same thing as being thread "
"safe. :func:`redirect_stdout`, for example, is definitely not thread safe, "
"as it makes a global modification to the system state by binding :data:`sys."
"stdout` to a different stream."
msgstr ""
"Notez aussi qu'être réentrant ne signifie *pas* être *thread safe*. :func:"
"`redirect_stdout`, par exemple, n'est définitivement pas *thread safe*, "
"puisqu'il effectue des changements globaux sur l'état du système en "
"branchant :data:`sys.stdout` sur différents flux."

#: library/contextlib.rst:809
msgid "Reusable context managers"
msgstr "Gestionnaires de contexte réutilisables"

#: library/contextlib.rst:811
msgid ""
"Distinct from both single use and reentrant context managers are \"reusable"
"\" context managers (or, to be completely explicit, \"reusable, but not "
"reentrant\" context managers, since reentrant context managers are also "
"reusable). These context managers support being used multiple times, but "
"will fail (or otherwise not work correctly) if the specific context manager "
"instance has already been used in a containing with statement."
msgstr ""
"D'autres gestionnaires de contexte que ceux à usage unique et les réentrants "
"sont les gestionnaires de contexte « réutilisables » (ou, pour être plus "
"explicite, « réutilisables mais pas réentrants », puisque les gestionnaires "
"de contexte réentrants sont aussi réutilisables). Ces gestionnaires de "
"contexte sont conçus afin d'être utilisés plusieurs fois, mais échoueront "
"(ou ne fonctionnent pas correctement) si l'instance de gestionnaire de "
"contexte référencée a déjà été utilisée dans une instruction *with* "
"englobante."

#: library/contextlib.rst:818
msgid ""
":class:`threading.Lock` is an example of a reusable, but not reentrant, "
"context manager (for a reentrant lock, it is necessary to use :class:"
"`threading.RLock` instead)."
msgstr ""
":class:`threading.Lock` est un exemple de gestionnaire de contexte "
"réutilisable mais pas réentrant (pour un verrou réentrant, il faut à la "
"place utiliser :class:`threading.RLock`)."

#: library/contextlib.rst:822
msgid ""
"Another example of a reusable, but not reentrant, context manager is :class:"
"`ExitStack`, as it invokes *all* currently registered callbacks when leaving "
"any with statement, regardless of where those callbacks were added::"
msgstr ""
"Un autre exemple de gestionnaire de contexte réutilisable mais pas réentrant "
"est :class:`ExitStack`, puisqu'il invoque *toutes* les fonctions de rappel "
"actuellement enregistrées en quittant l'instruction *with*, sans regarder où "
"ces fonctions ont été ajoutées ::"

#: library/contextlib.rst:853
msgid ""
"As the output from the example shows, reusing a single stack object across "
"multiple with statements works correctly, but attempting to nest them will "
"cause the stack to be cleared at the end of the innermost with statement, "
"which is unlikely to be desirable behaviour."
msgstr ""
"Comme le montre la sortie de l'exemple, réutiliser une simple pile entre "
"plusieurs instructions *with* fonctionne correctement, mais essayer de les "
"imbriquer fait que la pile est vidée à la fin du *with* le plus imbriqué, ce "
"qui n'est probablement pas le comportement voulu."

#: library/contextlib.rst:858
msgid ""
"Using separate :class:`ExitStack` instances instead of reusing a single "
"instance avoids that problem::"
msgstr ""
"Pour éviter ce problème, utilisez des instances différentes de :class:"
"`ExitStack` plutôt qu'une seule instance ::"
