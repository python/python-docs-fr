# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-04-05 10:05+0200\n"
"PO-Revision-Date: 2021-09-15 23:54+0200\n"
"Last-Translator: Jean Abou Samra <jean@abou-samra.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.1\n"

#: library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` — Arbres Syntaxiques Abstraits"

#: library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Code source :** :source:`Lib/ast.py`"

#: library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
"Le module :mod:`ast` permet aux applications Python de traiter les arbres "
"syntaxiques, dérivés directement de la grammaire abstraite du langage. On "
"peut notamment déterminer dans un programme la forme de chaque élément de "
"grammaire, qui est susceptible d'être modifiée par les nouvelles versions de "
"Python."

#: library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"Un arbre syntaxique abstrait peut être généré en passant l'option :data:`ast."
"PyCF_ONLY_AST` à la fonction native :func:`compile`, ou à l'aide de la "
"fonction auxiliaire :func:`parse` fournie par ce module. Le résultat est un "
"arbre composé d'objets dont les classes héritent toutes de :class:`ast.AST`. "
"On peut compiler les arbres en code objet Python à l'aide de la fonction "
"native :func:`compile`."

#: library/ast.rst:33
msgid "Abstract Grammar"
msgstr "Grammaire abstraite"

#: library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "La grammaire abstraite est actuellement définie comme suit :"

#: library/ast.rst:42
msgid "Node classes"
msgstr "Classes de nœuds"

#: library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`below <abstract-grammar>`.  They are defined in the :mod:`_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"C'est la classe de base de toute classe de nœuds des d'arbres syntaxiques "
"abstraits. Les classes de nœuds elle-mêmes sont dérivées du fichier :file:"
"`Parser/Python.asdl`, qui est reproduit :ref:`ci-dessous <abstract-"
"grammar>`. Elles sont définies dans le module C :mod:`_ast` et ré-exportées "
"dans le module :mod:`ast`."

#: library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"Il y a une classe définie pour chacun des symboles présents à gauche dans la "
"grammaire abstraite (par exemple :class:`ast.stmt` ou :class:`ast.expr`). En "
"plus de cela, une classe est définie pour chacun des constructeurs présentés "
"à droite ; ces classes héritent des classes situées à leur gauche dans "
"l'arbre. Par exemple, la classe :class:`ast.BinOp` hérite de la classe :"
"class:`ast.expr`. Pour les règles de réécriture avec alternatives (les "
"« sommes »), la classe de la partie gauche est abstraite : seules les "
"classes de nœuds à droite sont instanciées."

#: library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr ""
"Chaque classe concrète possède un attribut :attr:`_fields` donnant les noms "
"de tous les nœuds enfants."

#: library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"Chaque instance d'une classe concrète possède un attribut pour chaque nœud "
"enfant, du type défini par la grammaire. Par exemple, les instances :class:"
"`ast.BinOp` possèdent un attribut :attr:`left` de type :class:`ast.expr`."

#: library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"Si un attribut est marqué comme optionnel dans la grammaire (avec un point "
"d'interrogation ``?``), sa valeur peut être ``None``. S'il peut avoir zéro, "
"une ou plusieurs valeurs (ce qui est marqué par un astérisque ``*``), elles "
"sont regroupées dans une liste Python. Tous les attributs possibles doivent "
"être présents et avoir une valeur valide pour compiler un arbre syntaxique "
"avec :func:`compile`."

#: library/ast.rst:82
#, fuzzy
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""
"Les instances des sous-classes de :class:`ast.expr` et :class:`ast.stmt` "
"possèdent les attributs :attr:`lineno`, :attr:`col_offset`, :attr:"
"`end_lineno` et :attr:`end_col_offset`. Les attributs :attr:`lineno` et :"
"attr:`end_lineno` sont les numéros de ligne de début et de fin dans le code "
"source (indexés à partir de 1, la première ligne est la ligne 1). Les "
"attributs :attr:`col_offset` et :attr:`end_col_offset` représentent quant à "
"eux les décalages respectifs, en octets au format UTF-8, du premier et du "
"dernier lexème qui ont généré le nœud. Les décalages sont exprimés en octets "
"au format UTF-8 parce que l'analyseur syntaxique utilise l'UTF-8 en interne."

#: library/ast.rst:91
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"Les décalages *end…* ne sont pas obligatoires ni nécessaires au compilateur. "
"*end_col_offset* pointe *après* le dernier lexème. On peut donc obtenir la "
"partie du code source ayant donné lieu à une expression avec "
"``ligne_source[nœud.col_offset : nœud.end_col_offset]``."

#: library/ast.rst:96
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""
"Le constructeur d'une classe nommée :class:`ast.T` analyse ses arguments "
"comme suit :"

#: library/ast.rst:98
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"S'il y a des arguments positionnels, il doit y avoir autant de termes dans :"
"attr:`T._fields` ; ils sont assignés comme attributs portant ces noms."

#: library/ast.rst:100
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"S'il y a des arguments nommés, ils définissent les attributs de mêmes noms "
"avec les valeurs données."

#: library/ast.rst:103
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"Par exemple, pour créer et peupler un nœud :class:`ast.UnaryOp`, on peut "
"utiliser ::"

#: library/ast.rst:115
msgid "or the more compact ::"
msgstr "ou, plus compact ::"

#: library/ast.rst:122
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr ""
"toutes les constantes sont désormais représentées par des instances de :"
"class:`ast.Constant`."

#: library/ast.rst:126
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""

#: library/ast.rst:131
msgid ""
"Old classes :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, :class:"
"`ast.NameConstant` and :class:`ast.Ellipsis` are still available, but they "
"will be removed in future Python releases.  In the meantime, instantiating "
"them will return an instance of a different class."
msgstr ""
"les classes :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, :class:"
"`ast.NameConstant` et :class:`ast.Ellipsis` sont toujours présentes, mais "
"seront supprimées dans une version future. Pour l'instant, leurs "
"constructeurs renvoient des instances de classes différentes."

#: library/ast.rst:138
msgid ""
"Old classes :class:`ast.Index` and :class:`ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""
"les classes :class:`ast.Index` et :class:`ast.ExtSlice` seront retirées à "
"l'avenir. Pour l'instant, elles sont toujours disponibles mais leurs "
"constructeurs renvoient des instances de classes différentes."

#: library/ast.rst:144
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"Les descriptions individuelles des classes de nœuds dans la prochaine "
"section sont au départ adaptées du merveilleux projet `Green Tree Snakes "
"<https://greentreesnakes.readthedocs.io/en/latest/>`_, porté par de nombreux "
"contributeurs."

#: library/ast.rst:150
msgid "Literals"
msgstr "Littéraux"

#: library/ast.rst:154
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""
"Valeur constante, contenue dans le champ *value*. Les valeurs possibles sont "
"celles de types simples comme les nombres, les chaînes de caractères, ou "
"encore ``None``, mais aussi certains conteneurs immuables (*n*-uplets et "
"ensembles figés) lorsque tous leurs éléments sont constants."

#: library/ast.rst:168
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr ""
"Champ de formatage dans une chaîne littérale formatée (*f-string*). Ce nœud "
"peut être isolé si la chaîne contient un unique champ et rien d'autre. "
"Sinon, il apparaît dans :class:`JoinedStr`."

#: library/ast.rst:172
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"*value* est un nœud d'expression quelconque (comme un littéral, une "
"variable, ou encore un appel de fonction)."

#: library/ast.rst:174
msgid "``conversion`` is an integer:"
msgstr "*conversion* est un entier parmi les valeurs suivantes :"

#: library/ast.rst:176
msgid "-1: no formatting"
msgstr "-1, aucun formatage ;"

#: library/ast.rst:177
msgid "115: ``!s`` string formatting"
msgstr "115, pour le formatage par ``str()`` correspondant à ``!s`` ;"

#: library/ast.rst:178
msgid "114: ``!r`` repr formatting"
msgstr "114, pour le formatage par ``repr()`` correspondant à ``!r`` ;"

#: library/ast.rst:179
msgid "97: ``!a`` ascii formatting"
msgstr "97, pour le formatage par ``ascii()`` correspondant à ``!a``."

#: library/ast.rst:181
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"*format_spec* est un nœud :class:`JoinedStr` qui précise la manière de "
"formater la valeur. Si aucun formatage particulier n'a été donné, "
"*format_spec* vaut ``None``. *conversion* et *format_spec* peuvent tout à "
"fait coexister."

#: library/ast.rst:188
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr ""
"Chaîne littérale formatée (*f-string*), qui contient une liste de nœuds :"
"class:`FormattedValue` et :class:`Constant`."

#: library/ast.rst:217
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"Liste ou *n*-uplet, dont les éléments sont rassemblés dans la liste *elts*. "
"*ctx* est une instance de :class:`Store` si la liste ou le *n*-uplet est la "
"cible d'une affectation (par exemple ``(x, y) = quelque_chose``). Sinon, "
"c'est une instance de :class:`Load`."

#: library/ast.rst:243
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr "Ensemble. *elts* est la liste de ses éléments."

#: library/ast.rst:258
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"Dictionnaire. Les listes *keys* et *values* contiennent respectivement les "
"clés et les valeurs. Leurs ordres se correspondent, c'est-à-dire que la "
"valeur associée à l'élément d'indice *i* dans *keys* est à chercher à "
"l'indice *i* de *values*. *keys* et *values* sont donc des équivalents à "
"``dictionnaire.keys()`` et ``dictionnaire.values()``."

#: library/ast.rst:262
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"Si un dictionnaire littéral contient une expression doublement étoilée à "
"déballer, elle est intégrée dans *values*, et ``None`` est mis à la place "
"correspondante dans *keys*."

#: library/ast.rst:280
msgid "Variables"
msgstr "Variables"

#: library/ast.rst:284
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr ""
"Variable, dont le nom est *id* (une chaîne de caractères). *ctx* est de l'un "
"des trois types :"

#: library/ast.rst:292
msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr ""
"Ces types de contexte distinguent les variables selon qu'elles sont "
"utilisées pour lire la valeur, mettre la variable à une nouvelle valeur, ou "
"supprimer la variable."

#: library/ast.rst:325
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"Élément étoilé. *value* est le nœud auquel s'applique l'étoile. Le plus "
"souvent, *value* est une instance de :class:`Name`. Ce type est notamment "
"nécessaire pour les appels de fonction avec déballage d'arguments (par "
"exemple ``fonction(*args)`` ; voir aussi :class:`Call`)."

#: library/ast.rst:348
msgid "Expressions"
msgstr "Expressions"

#: library/ast.rst:352
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"Lorsque une expression, comme l'appel d'une fonction, apparaît comme une "
"instruction à elle seule, sans que la valeur ne soit utilisée ou "
"sauvegardée, l'expression est insérée dans ce conteneur. Le type de *value* "
"peut être l'un des autres nœuds décrits dans cette section, ou bien parmi :"
"class:`Constant`, :class:`Name`, :class:`Lambda`, :class:`Yield` et :class:"
"`YieldFrom`."

#: library/ast.rst:371
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr ""
"Unité lexicale désignant une opération unaire. L'opérateur est *op*, "
"l'opérande *operand* est un nœud d'expression quelconque."

#: library/ast.rst:380
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"Unités lexicales désignant des opérations unaires. :class:`Not` correspond "
"au mot-clé ``not``, :class:`Invert` à l'opérateur ``~``."

#: library/ast.rst:394
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"Opération binaire (comme l'addition ou la division). L'opérateur est *op*, "
"les opérandes *left* et *right* sont des nœuds d'expression quelconques."

#: library/ast.rst:421
msgid "Binary operator tokens."
msgstr "Unités lexicales pour les opérations binaires."

#: library/ast.rst:426
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"Opération booléenne, c'est-à-dire ``and`` ou ``or``, entre *op* et les "
"éléments de *values*. Les deux opérateurs sont distingués par le type de "
"*op*, à savoir :class:`And` ou :class:`Or`. Les applications successives du "
"même opérateur (comme ``a or b or c``) sont regroupées dans un nœud unique "
"avec plusieurs éléments dans la liste *values*."

#: library/ast.rst:431
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr ""
"L'opérateur ``not`` n'est pas implémenté ici, mais bien dans :class:"
"`UnaryOp`."

#: library/ast.rst:447
msgid "Boolean operator tokens."
msgstr "Unités lexicales pour les opérations booléennes."

#: library/ast.rst:452
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"Comparaison de deux valeurs ou plus. *left* est le premier élément de la "
"comparaison, *ops* la liste des opérateurs, et *comparators* la liste des "
"éléments restants de la comparaison."

#: library/ast.rst:481
msgid "Comparison operator tokens."
msgstr "Unités lexicales pour les comparaisons."

#: library/ast.rst:486
msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"Appel d'une fonction. Le nœud *func*, représentant la fonction appelée, est "
"habituellement de type :class:`Name` ou :class:`Attribute`. Les arguments "
"sont contenus dans :"

#: library/ast.rst:489
msgid "``args`` holds a list of the arguments passed by position."
msgstr ""
"*args*, la liste des arguments passés sans les nommer (arguments "
"positionnels) ;"

#: library/ast.rst:490
msgid ""
"``keywords`` holds a list of :class:`keyword` objects representing arguments "
"passed by keyword."
msgstr ""
"*keywords*, la liste des arguments nommés sous forme de nœuds :class:"
"`keyword`."

#: library/ast.rst:493
msgid ""
"When creating a ``Call`` node, ``args`` and ``keywords`` are required, but "
"they can be empty lists. ``starargs`` and ``kwargs`` are optional."
msgstr ""
"Les arguments *args* et *keywords* du constructeur de ``Call`` sont "
"obligatoires (mais peuvent être des listes vides). *starargs* (arguments "
"étoilés) et *kwargs* (arguments nommés) sont facultatifs."

#: library/ast.rst:517
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""

#: library/ast.rst:523
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"Expression ternaire (``a if b else c``). Chaque champ contient un unique "
"nœud. Dans l'exemple suivant, les trois sont de la classe :class:`Name`."

#: library/ast.rst:538
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"Accès à un attribut (comme ``d.keys``). *value* est un nœud, souvent de la "
"classe :class:`Name`. *attr* est le nom de l'attribut, sous forme de chaîne "
"de caractères. *ctx* est de classe :class:`Load`, :class:`Store` ou :class:"
"`Del` selon le type de l'action effectuée sur l'attribut."

#: library/ast.rst:555
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"Expression d'affectation. Ces nœuds proviennent de l'opérateur « morse » ``:"
"=``. Contrairement à :class:`Assign`, dont le premier argument est une liste "
"qui peut contenir plusieurs cibles, les arguments *target* et *value* sont "
"ici des nœuds simples."

#: library/ast.rst:570
msgid "Subscripting"
msgstr "Indiçage"

#: library/ast.rst:574
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"Accès à un indice, par exemple ``liste[1]``. *value* est l'objet où l'indice "
"est pris, donc la plupart du temps une séquence ou une table associative. "
"*slice* est soit un indice, soit une tranche, soit une clé. Les instances "
"de :class:`Tuple` pour *slice* peuvent contenir des objets :class:`Slice`. "
"*ctx* est de type :class:`Load`, :class:`Store` ou :class:`Del` selon "
"l'action appliquée à l'indice."

#: library/ast.rst:598
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"Tranches normales (de la forme ``début:fin`` ou ``début:fin:pas``). Les "
"instances de cette classe ne peuvent apparaître que dans le champ *slice* "
"d'un :class:`Subscript`, que ce soit directement ou en tant qu'élément d'un :"
"class:`Tuple`."

#: library/ast.rst:615
msgid "Comprehensions"
msgstr "Compréhensions"

#: library/ast.rst:622
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"Liste, ensemble ou dictionnaire en compréhension, ou expression génératrice. "
"*elt* est l'expression avant le premier ``for``, évaluée à chaque itération. "
"Il est remplacé par *key* (expression pour la clé) et *value* (expression "
"pour la valeur) dans le cas des dictionnaires."

#: library/ast.rst:626
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "*generators* est une liste de nœuds :class:`comprehension`."

#: library/ast.rst:668
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"Une clause ``for`` à l'intérieur d'une compréhension. *iter* est l'objet à "
"parcourir, *target* est la cible de l'affectation qui se produit à chaque "
"itération (la plupart du temps un nœud :class:`Name` ou :class:`Tuple`). "
"*ifs* contient les tests  qui décident si l'élément doit être inséré. C'est "
"une liste, car chaque ``for`` peut être suivi de plusieurs ``if``."

#: library/ast.rst:673
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"*is_async* est une valeur booléenne sous forme d'entier, 0 ou 1, qui indique "
"si la compréhension est asynchrone, c'est-à-dire qu'elle a été écrite avec "
"``async for`` au lieu de ``for``."

#: library/ast.rst:739
msgid "Statements"
msgstr "Instructions"

#: library/ast.rst:743
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr ""
"Affectation. *targets* est une liste de nœuds, *value* est simplement un "
"nœud."

#: library/ast.rst:745
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"S'il y a plusieurs nœuds dans *targets*, ils sont tous pris comme des cibles "
"auxquelles est affectée la même expression. Le déballage de séquences est "
"représenté par des nœuds :class:`Tuple` ou :class:`List` comme éléments de "
"*targets*."

#: library/ast.rst:1038 library/ast.rst:1632
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr ""
"Le champ facultatif *type_comment* contient une annotation de type fournie "
"par un commentaire, et ce sous la forme d'une chaîne de caractères."

#: library/ast.rst:781
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, a :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node. ``simple`` is a boolean "
"integer set to True for a :class:`Name` node in ``target`` that do not "
"appear in between parenthesis and are hence pure names and not expressions."
msgstr ""
"Affectation accompagnée d'une annotation de type. La cible *target* est un "
"nœud de type :class:`Name`, :class:`Attribute` ou :class:`Subscript`. "
"*annotation* est le contenu de l'annotation, par exemple un nœud :class:"
"`Constant` ou :class:`Name`. Le champ *value* est facultatif et peut "
"contenir un nœud, la valeur affectée à la cible. *simple* est une valeur "
"booléenne sous forme d'entier, 0 ou 1, qui vaut 1 si et seulement si "
"*target* est de type :class:`Name` et provient d'un nom sans parenthèses, "
"donc un nom simple plutôt qu'une expression."

#: library/ast.rst:836
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"Affectation incrémentale, par exemple ``a += 1``. Dans l'exemple qui suit, "
"*target* est un nœud de type :class:`Name` avec le nom ``'x'`` (de contexte :"
"class:`Store`), *op* est une instance de :class:`Add`, et *value* est un "
"nœud :class:`Constant` contenant la valeur 1."

#: library/ast.rst:841
#, fuzzy
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""
"Contrairement aux cibles acceptées par :class:`Assign`, le champ *target* ne "
"peut pas être ici de type :class:`Tuple` ou :class:`List`."

#: library/ast.rst:858
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"Instruction ``raise``. *exc* est l'exception à lever, la plupart du temps un "
"nœud de type :class:`Call` ou :class:`Name`. Ce champ vaut ``None`` dans le "
"cas d'un ``raise`` sans rien d'autre. Le champ facultatif *cause* correspond "
"à la partie après le ``from`` dans ``raise ... from ...``."

#: library/ast.rst:875
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr ""
"Assertion. *test* est la condition, par exemple un nœud :class:`Compare`. "
"*msg* est le message d'erreur affiché si le test s'évalue comme faux."

#: library/ast.rst:891
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"Instruction ``del``. Les éléments à supprimer sont rassemblés dans la liste "
"*target*. Ce sont généralement des nœuds de type :class:`Name`, :class:"
"`Attribute` ou :class:`Subscript`."

#: library/ast.rst:909
msgid "A ``pass`` statement."
msgstr "Instruction ``pass``."

#: library/ast.rst:920
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"Il existe d'autres instructions, qui ne peuvent apparaître que dans certains "
"contextes spécifiques comme l'intérieur d'une fonction ou d'une boucle. "
"Elles sont décrites dans d'autres sections de ce document."

#: library/ast.rst:924
msgid "Imports"
msgstr "Importations"

#: library/ast.rst:928
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr ""
"Instruction ``import``. *names* prend la forme d'une liste de nœuds :class:"
"`alias`."

#: library/ast.rst:945
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"Instruction ``from ... import ...``. La partie après ``from`` est mise dans "
"*module* comme une simple chaîne de caractères. Dans le cas des importations "
"relatives, comme ``from ..module import quelque_chose``, *module* ne "
"contient pas les points au début. Dans les instructions de la forme ``from . "
"import toto``, *module* vaut ``None``. *level* est le niveau d'importation "
"relative sous forme d'entier (0 pour les importations absolues)."

#: library/ast.rst:967
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"Correspond à ``... as ...`` dans une importation. *name* et *asname* sont de "
"simples chaînes de caractères, qui correspondent aux deux parties de ``... "
"as ...``. Dans les instructions sans ``as`` (où le module n'est pas "
"renommé), *asname* vaut ``None``."

#: library/ast.rst:984
msgid "Control flow"
msgstr "Contrôle de l'exécution"

#: library/ast.rst:987
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr ""
"Si une clause facultative comme ``else`` est absente, le champ correspondant "
"dans l'arbre est une liste vide."

# Il faut développer un peu plus que l'original car le lecteur ne
# comprend pas forcément les termes « body » et « orelse ». La même
# considération s'applique à bien des descriptions par la suite.
#: library/ast.rst:992
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"Instruction ``if``. La condition, *test*, est un nœud, par exemple une "
"instance de :class:`Compare`. *body* est la liste des instructions du bloc. "
"*orelse* contient les instructions dans le ``else`` (liste vide s'il n'y a "
"pas de ``else``)."

#: library/ast.rst:995
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"Les clauses ``elif`` ne possèdent pas de représentation particulière. Elles "
"sont simplement mises dans le *orelse* du ``if`` ou ``elif`` précédent, "
"comme nœuds de type :class:`If`."

#: library/ast.rst:1030
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple` or :class:`List` node. ``iter`` holds "
"the item to be looped over, again as a single node. ``body`` and ``orelse`` "
"contain lists of nodes to execute. Those in ``orelse`` are executed if the "
"loop finishes normally, rather than via a ``break`` statement."
msgstr ""
"Boucle ``for``. Elle porte sur l'itérable donné par le nœud *iter*. La cible "
"des affectations successives est *target*, qui est un nœud de type :class:"
"`Name`, :class:`Tuple` ou :class:`List`. Les instructions du bloc ``for`` "
"forment la liste *body*. Celles de la liste *orelse* proviennent d'une "
"éventuelle clause ``else`` et sont exécutées si la boucle se termine par "
"épuisement de l'itérable, et non pas par un ``break``."

#: library/ast.rst:1064
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr ""
"Boucle ``while``. *test* est la condition évaluée à chaque itération, par "
"exemple un nœud :class:`Compare`. *body* contient les instructions du bloc, "
"et *orelse* celles d'un éventuel bloc ``else``, exécuté lorsque la boucle "
"termine parce que la condition devient fausse et non pas à cause d'une "
"instruction ``break``."

#: library/ast.rst:1091
msgid "The ``break`` and ``continue`` statements."
msgstr "Instructions ``break`` et ``continue``."

#: library/ast.rst:1126
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"Bloc ``try``. Les nœuds de la liste *body* sont les instructions à exécuter "
"sous contrôle des exceptions. La liste *handlers* contient des nœuds :class:"
"`ExceptHandler`, un par ``except``. Les listes *orelse* et *finalbody* "
"contiennent respectivement les instructions se trouvant dans d'éventuels "
"blocs ``else`` et ``finally``."

#: library/ast.rst:1172
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"Une clause ``except``. Elle intercepte les exceptions de types donnés par "
"*type*, qui est le plus souvent un nœud :class:`Name` ou bien ``None`` "
"(cette dernière valeur pour les clauses fourre-tout ``except:``). Le nom "
"éventuel de la variable à laquelle affecter l'exception est dans la chaîne "
"de caractères *name* (``None`` s'il n'y a pas de ``as``). Les instructions "
"sous le ``except`` sont dans la liste *body*."

#: library/ast.rst:1206
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"Bloc ``with``. Les gestionnaires de contexte sont stockés dans *items* comme "
"instances de :class:`withitem`. Les instructions sous le ``with`` forment la "
"liste *body*."

#: library/ast.rst:1216
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"Gestionnaire de contexte dans un bloc ``with``. Le gestionnaire est donné "
"par le nœud *context_expr*, souvent une instance de :class:`Call`. S'il y a "
"affectation avec ``as``, *optional_vars* contient sa cible, qui est un nœud "
"de type :class:`Name`, :class:`Tuple` ou :class:`List`. Sinon, "
"*optional_vars* vaut ``None``."

#: library/ast.rst:1249
msgid "Pattern matching"
msgstr ""

#: library/ast.rst:1254
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""

#: library/ast.rst:1260
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the :class:"
"`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""

#: library/ast.rst:1265
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the "
"pattern matches the subject."
msgstr ""

#: library/ast.rst:1268
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr ""

#: library/ast.rst:1311
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is "
"equal to the evaluated value."
msgstr ""

#: library/ast.rst:1338
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""

#: library/ast.rst:1363
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""

#: library/ast.rst:1394
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr ""

#: library/ast.rst:1434
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match "
"statement documentation."
msgstr ""

#: library/ast.rst:1440
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""

#: library/ast.rst:1480
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""

#: library/ast.rst:1487
msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr ""

#: library/ast.rst:1491
msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr ""

#: library/ast.rst:1544
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name) "
"and will always succeed."
msgstr ""

#: library/ast.rst:1549
msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr ""

#: library/ast.rst:1585
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""

#: library/ast.rst:1617
msgid "Function and class definitions"
msgstr "Définition de fonctions et de classes"

#: library/ast.rst:1621
msgid "A function definition."
msgstr "Définition d'une fonction."

#: library/ast.rst:1623
msgid "``name`` is a raw string of the function name."
msgstr ""
"*name* donne le nom de la fonction sous forme d'une chaîne de caractères."

#: library/ast.rst:1624
#, fuzzy
msgid "``args`` is an :class:`arguments` node."
msgstr ""
"*args* est un nœud de type :class:`arguments` qui contient les arguments de "
"la signature."

#: library/ast.rst:1625
msgid "``body`` is the list of nodes inside the function."
msgstr "*body* est la liste des instructions dans le corps de la fonction."

#: library/ast.rst:1626
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr ""
"*decorators_list* est une liste de décorateurs appliqués à la fonction. Ils "
"sont rangés dans leur ordre d'apparition, c'est-à-dire que le premier de la "
"liste est appliqué en dernier."

#: library/ast.rst:1628
msgid "``returns`` is the return annotation."
msgstr "*returns* est l'annotation de renvoi éventuelle."

#: library/ast.rst:1637
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"Fonction anonyme. Elle est créée avec le mot-clé ``lambda``, limitée à "
"renvoyer une simple expression, et peut être intégrée à une expression plus "
"large. Contrairement à :class:`FunctionDef`, *body* est ici un nœud unique. "
"*args* est une instance de ``arguments`` qui contient les arguments de la "
"signature."

#: library/ast.rst:1661
msgid "The arguments for a function."
msgstr "Arguments d'une fonction."

#: library/ast.rst:1663
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr ""
"*posonlyargs*, *args* et *kwonlyargs* sont des listes de nœuds :class:`arg` "
"qui correspondent respectivement aux arguments obligatoirement positionnels, "
"positionnels ou nommés et obligatoirement nommés."

#: library/ast.rst:1664
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"*varargs* et *kwargs* sont des nœuds :class:`arg` qui apparaissent avec la "
"capture des arguments restants, positionnels (``*arguments_positionnels``) "
"et nommés (``**arguments_nommés``)."

#: library/ast.rst:1666
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"*kw_defaults* est la liste des valeurs par défaut pour les arguments "
"obligatoirement nommés. Si l'un des éléments n'est pas un nœud mais "
"``None``, il n'y a pas de valeur par défaut et l'argument correspondant doit "
"être passé obligatoirement à la fonction."

#: library/ast.rst:1668
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"*defaults* est, quant à elle, la liste des valeurs par défauts pour les "
"arguments qui peuvent être passés de manière positionnelle (obligatoirement "
"ou non). S'il y a moins d'éléments dans la liste que d'arguments "
"positionnels, ces éléments donnent les valeurs par défaut des *n* derniers "
"arguments positionnels (avec *n* la longueur de *defaults*)."

#: library/ast.rst:1675
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name, "
"``annotation`` is its annotation, such as a :class:`Str` or :class:`Name` "
"node."
msgstr ""

#: library/ast.rst:1681
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr ""
"Le champ facultatif *type_comment* est, sous forme de chaîne, une annotation "
"de type fournie par un commentaire."

#: library/ast.rst:1725
msgid "A ``return`` statement."
msgstr "Instruction ``return``, qui renvoie *value*."

#: library/ast.rst:1740
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in a :class:`Expr` node if the value sent back is not "
"used."
msgstr ""
"Expression ``yield`` ou ``yield from``. Ce sont bien des expressions, non "
"pas des instructions. Il faut donc les placer dans un nœud :class:`Expr` si "
"la valeur qu'elles renvoient n'est pas utilisée dans une expression plus "
"large."

#: library/ast.rst:1765
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr ""
"Instruction ``global`` ou ``nonlocal``. Elle s'applique aux noms de "
"variables donnés dans *names*, une liste de chaînes de caractères."

#: library/ast.rst:1792
msgid "A class definition."
msgstr "Définition d'une classe."

#: library/ast.rst:1794
msgid "``name`` is a raw string for the class name"
msgstr "*name* est le nom de la classe sous forme de chaîne de caractères ;"

#: library/ast.rst:1795
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr "*bases* est la liste des classes mères données explicitement ;"

#: library/ast.rst:1796
#, fuzzy
msgid ""
"``keywords`` is a list of :class:`keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
"`PEP-3115 <https://www.python.org/dev/peps/pep-3115/>`_."
msgstr ""
"*keywords* est une liste de nœuds de type :class:`keyword`. Le principal mot-"
"clé qui peut y apparaître est ``metaclass``. Les autres sont passés à la "
"métaclasse (voir la :pep:`3115`) ;"

#: library/ast.rst:1799
msgid ""
"``starargs`` and ``kwargs`` are each a single node, as in a function call. "
"starargs will be expanded to join the list of base classes, and kwargs will "
"be passed to the metaclass."
msgstr ""

#: library/ast.rst:1802
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr ""
"*body* est la liste des instructions contenues dans la définition de classe ;"

#: library/ast.rst:1804
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr ""
"*decorators_list* est une liste de nœuds, comme pour :class:`FunctionDef`."

#: library/ast.rst:1833
msgid "Async and await"
msgstr "``async`` et ``await``"

#: library/ast.rst:1837
msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr ""
"Fonction déclarée avec ``async def``. Les champs sont les mêmes que dans :"
"class:`FunctionDef`."

#: library/ast.rst:1843
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Expression ``await``, qui attend *value*. Ces nœuds ne peuvent apparaître "
"qu'à l'intérieur de :class:`AsyncFunctionDef`."

#: library/ast.rst:1876
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Instruction ``async for`` ou ``async with``. Les champs sont les mêmes que "
"ceux de :class:`For` et :class:`With`. Ces nœuds ne peuvent apparaître qu'à "
"l'intérieur de :class:`AsyncFunctionDef`."

#: library/ast.rst:1881
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (e.g. :class:`ast.Add`)."
msgstr ""
"Lorsqu'une chaîne contenant du code est transformée en arbre syntaxique par :"
"func:`ast.parse`, les nœuds représentants les opérateurs (classes filles de :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` et :class:`ast.expr_context`) sont des singletons à l'intérieur de "
"l'arbre renvoyé. Si l'un, par exemple une instance de :class:`ast.Add`, est "
"muté, la modification sera visible sur toutes les autres apparitions de "
"l'opérateur."

#: library/ast.rst:1889
msgid ":mod:`ast` Helpers"
msgstr "Outils du module :mod:`ast`"

#: library/ast.rst:1891
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"À part les classes de nœuds, le module :mod:`ast` définit plusieurs "
"fonctions et classes utilitaires pour traverser les arbres syntaxiques "
"abstraits."

#: library/ast.rst:1896
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""
"Analyse le code source et renvoie un arbre syntaxique. Équivalent à "
"``compile(source, filename, mode, ast.PyCF_ONLY_AST)``."

#: library/ast.rst:1899
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""
"Si *type_comments* est mis à ``True``, l'analyseur syntaxique reconnaît les "
"commentaires de type et les ajoute à l'arbre, comme décrit dans la :pep:"
"`484` et la :pep:`526`. Ceci revient à ajouter :data:`ast."
"PyCF_TYPE_COMMENTS` à l'argument *flags* de :func:`compile`. Une erreur de "
"syntaxe est levée si un commentaire de type est placé au mauvais endroit. "
"Les commentaires ``# type: ignore`` sont également détectés et leurs "
"positions dans la source sont placées dans l'attribut *type_ignores* du "
"nœud :class:`Module`. Sans cette option, les commentaires de type sont "
"ignorés tout comme les commentaires ordinaires, et l'attribut *type_comment* "
"des nœuds dont le type possède ce champ sera toujours mis à ``None``."

#: library/ast.rst:1909
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""

#: library/ast.rst:1913
msgid ""
"Also, setting ``feature_version`` to a tuple ``(major, minor)`` will attempt "
"to parse using that Python version's grammar. Currently ``major`` must equal "
"to ``3``.  For example, setting ``feature_version=(3, 4)`` will allow the "
"use of ``async`` and ``await`` as variable names.  The lowest supported "
"version is ``(3, 4)``; the highest is ``sys.version_info[0:2]``."
msgstr ""
"Si *feature_version* est défini à une version de Python, sous la forme d'un "
"couple ``(version_majeure, version_mineure)``, l'analyseur tentera de lire "
"la source en se conformant à la syntaxe de cette version. Ainsi, avec "
"``feature_version=(3, 4)``, les noms ``async`` et ``await`` peuvent nommer "
"des variables. La version la plus ancienne prise en charge est actuellement "
"``(3, 4)`` ; la plus récente est ``sys.version_info[0:2]``."

#: library/ast.rst:1920
msgid ""
"If source contains a null character ('\\0'), :exc:`ValueError` is raised."
msgstr ""

#: library/ast.rst:1923
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""

#: library/ast.rst:1930
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""

#: library/ast.rst:1973
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"Il est possible de faire planter l'interpréteur Python avec des chaînes "
"suffisamment grandes ou complexes lors de la compilation d'un arbre "
"syntaxique en raison de la limitation de la profondeur de la pile d'appels."

#: library/ast.rst:1938
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"ajout des paramètres *type_comments* et *feature_version* ainsi que de la "
"valeur ``'func_type'`` pour *mode*."

#: library/ast.rst:1944
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
"À partir d'un arbre syntaxique :class:`ast.AST`, reconstruit un code sous "
"forme de chaîne de caractères. S'il est passé à :func:`ast.parse`, le "
"résultat produit un arbre :class:`ast.AST` équivalent à l'original."

#: library/ast.rst:1949
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""

#: library/ast.rst:1954
msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr ""
"Une :exc:`RecursionError` est levée si l'expression comporte de très "
"nombreux niveaux d'imbrication."

#: library/ast.rst:1962
#, fuzzy
msgid ""
"Safely evaluate an expression node or a string containing a Python literal "
"or container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"Évalue de manière sûre un nœud d'expression, ou bien une chaîne de "
"caractères contenant une valeur littérale simple ou un conteneur sous forme "
"littérale. La chaîne de caractères ou le nœud fourni ne doit contenir que "
"des littéraux parmi les types suivants : chaînes de caractères, octets, "
"nombres, *n*-uplets, listes, dictionnaires, ensembles, booléens, et ``None``."

#: library/ast.rst:1967
msgid ""
"This can be used for safely evaluating strings containing Python values from "
"untrusted sources without the need to parse the values oneself.  It is not "
"capable of evaluating arbitrarily complex expressions, for example involving "
"operators or indexing."
msgstr ""
"Cela peut être utilisé pour évaluer de manière sûre la chaîne de caractères "
"contenant des valeurs Python de source non fiable sans avoir besoin "
"d'analyser les valeurs elles-mêmes. Cette fonction n'est pas capable "
"d'évaluer des expressions arbitrairement complexes, par exemple impliquant "
"des opérateurs ou de l'indiçage."

#: library/ast.rst:1977
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` and :exc:`RecursionError` depending on the malformed input."
msgstr ""

#: library/ast.rst:1981
msgid "Now allows bytes and set literals."
msgstr "accepte maintenant les octets et ensembles littéraux."

#: library/ast.rst:1984
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "accepte ``set()`` pour les ensembles vides."

#: library/ast.rst:1987
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr ""

#: library/ast.rst:1993
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"Renvoie la *docstring* du nœud *node* (de type :class:`FunctionDef`, :class:"
"`AsyncFunctionDef`, :class:`ClassDef` or :class:`Module`), ou ``None`` s'il "
"n'a pas de *docstring*. Si *clean* est vrai, cette fonction nettoie "
"l'indentation de la *docstring* avec :func:`inspect.cleandoc`."

#: library/ast.rst:1999
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` est maintenant gérée."

#: library/ast.rst:2005
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`lineno`, :attr:`end_lineno`, :attr:"
"`col_offset`, or :attr:`end_col_offset`) is missing, return ``None``."
msgstr ""
"Donne la partie de *source* (le code source) qui a donné lieu à *node*. Si "
"l'un des attributs de localisation du nœud (:attr:`lineno`, :attr:"
"`end_lineno`, :attr:`col_offset` et :attr:`end_col_offset`) n'est pas "
"rempli, cette fonction renvoie ``None``."

#: library/ast.rst:2009
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""

#: library/ast.rst:2017
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`lineno` and :attr:`col_offset` attributes for every node that supports "
"them.  This is rather tedious to fill in for generated nodes, so this helper "
"adds these attributes recursively where not already set, by setting them to "
"the values of the parent node.  It works recursively starting at *node*."
msgstr ""
"Lorsque l'on compile un arbre avec :func:`compile`, le compilateur attend "
"les attributs :attr:`lineno` et :attr:`col_offset` pour tous les nœuds qui "
"les prennent en charge. Il est fastidieux de les remplir pour les nœuds "
"générés par du code. Cette fonction utilitaire ajoute ces attributs de "
"manière récursive là où ils ne sont pas déjà définis, en les définissant "
"comme les valeurs du nœud parent. Elle fonctionne récursivement en démarrant "
"de *node*."

#: library/ast.rst:2026
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"Incrémente de *n* les numéros des lignes de début et ligne de fin de chaque "
"nœud dans l'arbre, en commençant par le nœud *node*. C'est utile pour "
"« déplacer du code » à un endroit différent dans un fichier."

#: library/ast.rst:2033
msgid ""
"Copy source location (:attr:`lineno`, :attr:`col_offset`, :attr:"
"`end_lineno`, and :attr:`end_col_offset`) from *old_node* to *new_node* if "
"possible, and return *new_node*."
msgstr ""
"Copie la position dans la source (attributs :attr:`lineno`, :attr:"
"`col_offset`, :attr:`end_lineno` et :attr:`end_col_offset`) de l'ancien nœud "
"*old_node* vers le nouveau nœud *new_node*, si possible, et renvoie "
"*new_node*."

#: library/ast.rst:2040
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"Produit un *n*-uplet de couples ``(nom_du_champ, valeur)`` pour chaque champ "
"de ``node._fields`` qui est présent dans *node*."

#: library/ast.rst:2046
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"Produit tous les nœuds enfants directs de *node*, c'est-à-dire tous les "
"champs qui sont des nœuds et tous les éléments des champs qui sont des "
"listes de nœuds."

#: library/ast.rst:2052
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"Produit récursivement tous les nœuds enfants dans l'arbre en commençant par "
"*node* (*node* lui-même est inclus), sans ordre spécifique. C'est utile "
"lorsque l'on souhaite modifier les nœuds sur place sans prêter attention au "
"contexte."

#: library/ast.rst:2059
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"Classe de base pour un visiteur de nœud, qui parcourt l'arbre syntaxique "
"abstrait et appelle une fonction de visite pour chacun des nœuds trouvés. "
"Cette fonction peut renvoyer une valeur, qui est transmise par la méthode :"
"meth:`visit`."

#: library/ast.rst:2063
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"Cette classe est faite pour être dérivée, en ajoutant des méthodes de visite "
"à la sous-classe."

#: library/ast.rst:2068
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"Visite un nœud. L'implémentation par défaut appelle la méthode :samp:`self."
"visit_{classe}` où *classe* représente le nom de la classe du nœud, ou :meth:"
"`generic_visit` si cette méthode n'existe pas."

#: library/ast.rst:2074
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr ""
"Le visiteur appelle la méthode :meth:`visit` de tous les enfants du nœud."

#: library/ast.rst:2076
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"Notons que les nœuds enfants qui possèdent une méthode de visite spéciale ne "
"sont pas visités à moins que le visiteur n'appelle la méthode :meth:"
"`generic_visit` ou ne les visite lui-même."

#: library/ast.rst:2080
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"N'utilisez pas :class:`NodeVisitor` si vous souhaitez appliquer des "
"changements sur les nœuds lors du parcours. Pour cela, un visiteur spécial "
"existe (:class:`NodeTransformer`) qui permet les modifications."

#: library/ast.rst:2086
msgid ""
"Methods :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` and :meth:`visit_Ellipsis` are deprecated now and will "
"not be called in future Python versions.  Add the :meth:`visit_Constant` "
"method to handle all constant nodes."
msgstr ""
"les méthodes :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :"
"meth:`visit_NameConstant` et :meth:`visit_Ellipsis` sont devenues obsolètes "
"et cesseront d'être appelées dans une version ultérieure de Python. Écrivez "
"une méthode :meth:`visit_Constant` pour traiter tous les nœuds qui "
"représentent des valeurs constantes."

#: library/ast.rst:2094
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
"Une sous-classe de :class:`NodeVisitor` qui traverse l'arbre syntaxique "
"abstrait et permet de modifier les nœuds."

#: library/ast.rst:2097
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
"Le :class:`NodeTransformer` traverse l'arbre syntaxique et utilise la valeur "
"renvoyée par les méthodes du visiteur pour remplacer ou supprimer l'ancien "
"nœud. Si la valeur renvoyée par la méthode du visiteur est ``None``, le nœud "
"est supprimé de sa position, sinon il est remplacé par cette valeur. Elle "
"peut être le nœud original, auquel cas il n'y a pas de remplacement."

#: library/ast.rst:2103
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"Voici un exemple de transformation qui réécrit tous les accès à la valeur "
"d'une variable ``toto`` en ``data['toto']`` ::"

#: library/ast.rst:2115
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr ""
"Gardez en tête que si un nœud sur lequel vous travaillez a des nœuds "
"enfants, vous devez transformer également ces nœuds enfants vous-même ou "
"appeler d'abord la méthode :meth:`generic_visit` sur le nœud."

#: library/ast.rst:2119
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"Pour les nœuds qui font partie d'un groupe (notamment toutes les "
"instructions), le visiteur peut aussi renvoyer une liste des nœuds plutôt "
"qu'un seul nœud."

#: library/ast.rst:2123
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:"
"`lineno`), :func:`fix_missing_locations` should be called with the new sub-"
"tree to recalculate the location information::"
msgstr ""
"Si :class:`NodeTransformer` ajoute de nouveaux nœuds à l'original sans leur "
"donner les attributs de position dans la source (:attr:`lineno` et "
"consorts), il faut passer le nouvel arbre (ou la nouvelle partie de l'arbre) "
"à :func:`fix_missing_locations` pour calculer les positions manquantes :"

#: library/ast.rst:2131
msgid "Usually you use the transformer like this::"
msgstr "Utilisation typique des transformations ::"

#: library/ast.rst:2138
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"Renvoie une représentation sous forme de chaîne de caractères de l'arbre "
"contenu dans *node*. Ceci est principalement utile à des fins de débogage. "
"Par défaut, les champs sont passés comme paramètres nommés aux constructeurs "
"des classes d'arbre syntaxiques. Cependant, si *annotate_fields* est mis à "
"``False``, les valeurs sont passées, lorsque cela est possible, comme "
"arguments positionnels, rendant la représentation plus compacte. Les "
"attributs comme les numéros de lignes et positions sur les lignes sont "
"masqués par défaut, mais on peut les inclure en mettant *include_attributes* "
"à ``True``."

#: library/ast.rst:2146
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"La représentation peut comprendre une indentation afin d'être plus lisible. "
"Si *indent* est une chaîne de caractères (par exemple une tabulation "
"``\"\\t\"``), elle est insérée au début des lignes en la répétant autant de "
"fois que le niveau d'indentation. Un entier positif équivaut à un certain "
"nombre d'espaces. Un entier strictement négatif produit un effet identique à "
"0 ou la chaîne vide, c'est-à-dire des retours à la ligne sans indentation. "
"Avec la valeur par défaut de ``None``, la sortie tient sur une seule ligne."

#: library/ast.rst:2153
msgid "Added the *indent* option."
msgstr "ajout du paramètre *indent*."

#: library/ast.rst:2160
msgid "Compiler Flags"
msgstr "Options du compilateur"

#: library/ast.rst:2162
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""
"Les options suivantes sont prises en charge par la fonction :func:`compile`. "
"Elles permettent de modifier le comportement de la compilation."

#: library/ast.rst:2167
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"Active la reconnaissance de ``await``, ``async for``, ``async with`` et des "
"compréhensions asynchrones au niveau le plus haut."

#: library/ast.rst:2174
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""
"Génère et renvoie un arbre syntaxique au lieu d'un objet de code compilé."

#: library/ast.rst:2179
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
"Ajoute la prise en charge des commentaires de types tels que définis dans "
"la :pep:`484` et la :pep:`526` (``# type: un_type`` et ``# type: ignore``)."

#: library/ast.rst:2188
msgid "Command-Line Usage"
msgstr "Utilisation en ligne de commande"

#: library/ast.rst:2192
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ""
"Le module :mod:`ast` peut être exécuté en tant que script en ligne de "
"commande. C'est aussi simple que ceci :"

#: library/ast.rst:2199
msgid "The following options are accepted:"
msgstr "Les options suivantes sont acceptées :"

#: library/ast.rst:2205
msgid "Show the help message and exit."
msgstr "Affiche un message d'aide et quitte."

#: library/ast.rst:2210
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr ""
"Précise le type de code à compiler, comme l'argument *mode* de la fonction :"
"func:`parse`."

#: library/ast.rst:2215
msgid "Don't parse type comments."
msgstr "Désactive la reconnaissance des commentaires de type."

#: library/ast.rst:2219
msgid "Include attributes such as line numbers and column offsets."
msgstr ""
"Affiche les attributs comme les numéros de lignes et les décalages par "
"rapport aux débuts des lignes."

#: library/ast.rst:2224
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "Nombre d'espaces pour chaque niveau d'indentation dans la sortie."

#: library/ast.rst:2226
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
"L'entrée est lue dans le fichier :file:`infile`, s'il est donné, ou l'entrée "
"standard sinon. Le code source est transformé en un arbre syntaxique, qui "
"est affiché sur la sortie standard."

#: library/ast.rst:2232
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, une "
"ressource documentaire externe, qui possède plus de détails pour travailler "
"avec des arbres syntaxiques Python."

#: library/ast.rst:2235
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annote les arbres syntaxiques Python avec les positions des lexèmes et les "
"extraits de code source à partir desquels ils sont produits. Ceci est utile "
"pour les outils qui transforment du code source."

#: library/ast.rst:2240
msgid ""
"`leoAst.py <http://leoeditor.com/appendices.html#leoast-py>`_ unifies the "
"token-based and parse-tree-based views of python programs by inserting two-"
"way links between tokens and ast nodes."
msgstr ""
"`leoAst.py <http://leoeditor.com/appendices.html#leoast-py>`_ unifie les "
"visions des lexèmes et des arbres syntaxiques en insérant des liens "
"bidirectionnels entre les deux."

#: library/ast.rst:2244
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ produit à partir du code source "
"des arbres syntaxiques concrets, qui ressemblent à leurs homologues "
"abstraits et conservent tous les détails du formatage. Cette bibliothèque "
"est utile aux outils de réusinage et d'analyse de code."

#: library/ast.rst:2249
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_ est un analyseur syntaxique de code "
"Python qui gère la récupération d'erreurs et la génération de code (de "
"l'arbre syntaxique vers le code source), le tout pour les grammaires de "
"différentes versions de Python et en utilisant différentes versions. Il sait "
"également donner plusieurs erreurs de syntaxe en une seule fois."
