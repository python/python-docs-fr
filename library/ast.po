# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-29 16:06+0100\n"
"PO-Revision-Date: 2018-09-11 07:42+0200\n"
"Last-Translator: Julien VITARD <julienvitard@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.8.11\n"

#: ../Doc/library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- Arbres Syntaxiques Abstraits"

#: ../Doc/library/ast.rst:10
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Code source :** :source:`Lib/ast.py`"

#: ../Doc/library/ast.rst:14
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
"Le module :mod:`ast` permet aux applications Python de traiter la grammaire "
"abstraite de l'arbre syntaxique Python. La grammaire abstraite Python elle-"
"même est susceptible d'être modifiée à chaque nouvelle version de Python; ce "
"module permet de trouver à quoi la grammaire actuelle ressemble."

#: ../Doc/library/ast.rst:19
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"Un arbre syntaxique abstrait peut être généré en passant l'option :data:`ast."
"PyCF_ONLY_AST` à la fonction native :func:`compile`, ou en utilisant la "
"fonction de facilité :func:`parse` fournie par le module. Le résultat est un "
"arbre composé d'objets dont les classes héritent toutes de :class:`ast.AST`. "
"Un arbre syntaxique abstrait peut être compilé en code objet Python en "
"utilisant la fonction native :func:`compile`."

#: ../Doc/library/ast.rst:27
msgid "Node classes"
msgstr "Les classes nœud"

#: ../Doc/library/ast.rst:31
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`below <abstract-grammar>`.  They are defined in the :mod:`_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"C'est la classe de base de toute classe nœud de l'AST. Les classes nœud "
"courantes sont dérivées du fichier :file:`Parser/Python.asdl`, qui est "
"reproduit :ref:`ci-dessous <abstract-grammar>`. Ils sont définis dans le "
"module C :mod:`_ast` et ré-exportés dans le module :mod:`ast`."

#: ../Doc/library/ast.rst:36
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"Il y a une classe définie pour chacun des symboles présents à gauche dans la "
"grammaire abstraite (par exemple, :class:`ast.stmt` ou :class:`ast.expr`). "
"En plus de cela, il y a une classe définie pour chacun des constructeurs "
"présentés à droite; ces classes héritent des classes situées à gauche dans "
"l'arbre. Par exemple, la classe :class:`ast.BinOp` hérite de la classe :"
"class:`ast.expr`. Pour les règles de réécriture avec alternatives (comme "
"*sums*), la partie gauche est abstraite : seules les instances des "
"constructeurs spécifiques aux nœuds sont créés."

#: ../Doc/library/ast.rst:49
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr ""
"Chaque classe concrète possède un attribut :attr:`_fields` donnant les noms "
"de tous les nœuds enfants."

#: ../Doc/library/ast.rst:52
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"Chaque instance d'une classe concrète possède un attribut pour chaque nœud "
"enfant, du type défini par la grammaire. Par exemple, les instances :class:"
"`ast.BinOp` possèdent un attribut :attr:`left` de type :class:`ast.expr`."

#: ../Doc/library/ast.rst:56
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"Si ces attributs sont marqués comme optionnels dans la grammaire (en "
"utilisant un point d'interrogation ``?``), la valeur peut être ``None``. Si "
"les attributs peuvent avoir zéro ou plus valeurs (marqués avec un astérisque "
"``*``), les valeurs sont représentées par des listes Python. Tous les "
"attributs possibles doivent être présents et avoir une valeur valide pour "
"compiler un AST avec :func:`compile`."

#: ../Doc/library/ast.rst:65
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno` and :attr:`col_offset` attributes.  The :attr:`lineno` is the line "
"number of source text (1-indexed so the first line is line 1) and the :attr:"
"`col_offset` is the UTF-8 byte offset of the first token that generated the "
"node.  The UTF-8 offset is recorded because the parser uses UTF-8 internally."
msgstr ""
"Les instances des sous-classes :class:`ast.expr` et :class:`ast.stmt` "
"possèdent les attributs :attr:`lineno` et :attr:`col_offset`. L'attribut :"
"attr:`lineno` est le numéro de ligne dans le code source (indexé à partir de "
"1 tel que la première ligne est la ligne 1) et l'attribut :attr:`col_offset` "
"qui représente le décalage UTF-8 en byte du premier jeton qui a généré le "
"nœud. Le décalage UTF-8 est enregistré parce que l'analyseur syntaxique "
"utilise l'UTF-8 en interne."

#: ../Doc/library/ast.rst:72
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""
"Le constructeur d'une classe :class:`ast.T` analyse ses arguments comme "
"suit :"

#: ../Doc/library/ast.rst:74
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"S'il y a des arguments positionnels, il doit y avoir autant de termes dans :"
"attr:`T._fields`; ils sont assignés comme attributs portant ces noms."

#: ../Doc/library/ast.rst:76
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"S'il y a des arguments nommés, ils définissent les attributs de mêmes noms "
"avec les valeurs données."

#: ../Doc/library/ast.rst:79
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"Par exemple, pour créer et peupler un nœud :class:`ast.UnaryOp`, on peut "
"utiliser : ::"

#: ../Doc/library/ast.rst:91
msgid "or the more compact ::"
msgstr "ou, plus compact : ::"

#: ../Doc/library/ast.rst:100
msgid "Abstract Grammar"
msgstr "Grammaire abstraite"

#: ../Doc/library/ast.rst:102
msgid "The abstract grammar is currently defined as follows:"
msgstr "La grammaire abstraite est actuellement définie comme suit :"

#: ../Doc/library/ast.rst:109
msgid ":mod:`ast` Helpers"
msgstr "Outils du module :mod:`ast`"

#: ../Doc/library/ast.rst:111
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"À part la classe nœud, le module :mod:`ast` définit ces fonctions et classes "
"utilitaires pour traverser les arbres syntaxiques abstraits :"

#: ../Doc/library/ast.rst:116
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""
"Analyse le code source en un nœud AST. Équivalent à ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."

#: ../Doc/library/ast.rst:120 ../Doc/library/ast.rst:138
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"Il est possible de faire planter l'interpréteur Python avec des chaînes "
"suffisamment grandes ou complexes lors de la compilation d'un objet AST dû à "
"la limitation de la profondeur de la pile d'appels."

#: ../Doc/library/ast.rst:127
msgid ""
"Safely evaluate an expression node or a string containing a Python literal "
"or container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, and ``None``."
msgstr ""
"Évalue de manière sûre un nœud expression ou une chaîne de caractères "
"contenant une expression littérale Python ou un conteneur. La chaîne de "
"caractères ou le nœud fourni peut seulement faire partie des littéraux "
"Python suivants : chaînes de caractères, bytes, nombres, n-uplets, listes, "
"dictionnaires, ensembles, booléens, et ``None``."

#: ../Doc/library/ast.rst:132
msgid ""
"This can be used for safely evaluating strings containing Python values from "
"untrusted sources without the need to parse the values oneself.  It is not "
"capable of evaluating arbitrarily complex expressions, for example involving "
"operators or indexing."
msgstr ""
"Cela peut être utilisé pour évaluer de manière sûre la chaîne de caractères "
"contenant des valeurs Python de sources non fiable sans avoir besoin "
"d'analyser les valeurs elles-mêmes. Cette fonction n'est pas capable "
"d'évaluer des expressions complexes arbitraires, par exemple impliquant des "
"opérateurs ou de l'indexation."

#: ../Doc/library/ast.rst:142
msgid "Now allows bytes and set literals."
msgstr "Accepte maintenant les littéraux suivants *bytes* et *sets*."

#: ../Doc/library/ast.rst:148
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"Renvoie la *docstring* du *node* donné (qui doit être un nœud de type :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module`), ou ``None`` s'il n'a pas de *docstring*. Si *clean* est vrai, "
"cette fonction nettoie l'indentation de la *docstring* avec :func:`inspect."
"cleandoc`."

#: ../Doc/library/ast.rst:154
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` est maintenant gérée"

#: ../Doc/library/ast.rst:160
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`lineno` and :attr:`col_offset` attributes for every node that supports "
"them.  This is rather tedious to fill in for generated nodes, so this helper "
"adds these attributes recursively where not already set, by setting them to "
"the values of the parent node.  It works recursively starting at *node*."
msgstr ""
"Lorsque l'on compile un arbre avec :func:`compile`, le compilateur attend "
"les attributs :attr:`lineno` et :attr:`col_offset` pour tous les nœuds qui "
"les supportent. Il est fastidieux de les remplir pour les nœuds générés, "
"cette fonction utilitaire ajoute ces attributs de manière récursive là où "
"ils ne sont pas déjà définis, en les définissant comme les valeurs du nœud "
"parent. Elle fonctionne récursivement en démarrant de *node*."

#: ../Doc/library/ast.rst:169
msgid ""
"Increment the line number of each node in the tree starting at *node* by "
"*n*. This is useful to \"move code\" to a different location in a file."
msgstr ""
"Incrémente de *n* le numéro de ligne de chaque nœud dans l'arbre en "
"commençant par le nœud *node*. C'est utile pour \"déplacer du code\" à un "
"endroit différent dans un fichier."

#: ../Doc/library/ast.rst:175
msgid ""
"Copy source location (:attr:`lineno` and :attr:`col_offset`) from *old_node* "
"to *new_node* if possible, and return *new_node*."
msgstr ""
"Copie le code source (:attr:`lineno` et :attr:`col_offset`) de l'ancien nœud "
"*old_node* vers le nouveau nœud *new_node* si possible, et renvoie "
"*new_node*."

#: ../Doc/library/ast.rst:181
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"Produit un n-uplet de ``(fieldname, value)`` pour chaque champ de ``node."
"_fields`` qui est présent dans *node*."

#: ../Doc/library/ast.rst:187
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"Produit tous les nœuds enfants directs de *node*, c'est à dire, tous les "
"champs qui sont des nœuds et tous les éléments des champs qui sont des "
"listes de nœuds."

#: ../Doc/library/ast.rst:193
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"Produit récursivement tous les nœuds enfants dans l'arbre en commençant par "
"*node* (*node* lui-même est inclus), sans ordre spécifique. C'est utile "
"lorsque l'on souhaite modifier les nœuds sur place sans prêter attention au "
"contexte."

#: ../Doc/library/ast.rst:200
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"Classe de base pour un visiteur de nœud, qui parcourt l'arbre syntaxique "
"abstrait et appelle une fonction de visite pour chacun des nœuds trouvés. "
"Cette fonction peut renvoyer une valeur qui est transmise par la méthode :"
"meth:`visit`."

#: ../Doc/library/ast.rst:204
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"Cette classe est faite pour être dérivée, en ajoutant des méthodes de visite "
"à la sous-classe."

#: ../Doc/library/ast.rst:209
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"Visite un nœud. L'implémentation par défaut appelle la méthode :samp:`self."
"visit_{classname}` où *classname* représente le nom de la classe du nœud, "
"ou :meth:`generic_visit` si cette méthode n'existe pas."

#: ../Doc/library/ast.rst:215
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr ""
"Le visiteur appelle la méthode :meth:`visit` de tous les enfants du nœud."

#: ../Doc/library/ast.rst:217
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"Notons que les nœuds enfants qui possèdent une méthode de visite spéciale ne "
"seront pas visités à moins que le visiteur n'appelle la méthode :meth:"
"`generic_visit` ou ne les visite lui-même."

#: ../Doc/library/ast.rst:221
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"N'utilisez pas :class:`NodeVisitor` si vous souhaitez appliquer des "
"changements sur les nœuds lors du parcours. Pour cela, un visiteur spécial "
"existe (:class:`NodeTransformer`) qui permet les modifications."

#: ../Doc/library/ast.rst:228
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
"Une sous-classe :class:`NodeVisitor` qui traverse l'arbre syntaxique "
"abstrait et permet les modifications des nœuds."

#: ../Doc/library/ast.rst:231
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
"Le :class:`NodeTransformer` traverse l'AST et utilise la valeur renvoyée par "
"les méthodes du visiteur pour remplacer ou supprimer l'ancien nœud. Si la "
"valeur renvoyée par la méthode du visiteur est ``None``, le nœud est "
"supprimé de sa position, sinon il est remplacé par la valeur de retour. La "
"valeur de retour peut être le nœud original et dans ce cas, il n'y a pas de "
"remplacement. "

#: ../Doc/library/ast.rst:237
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"Voici un exemple du *transformer* qui réécrit les occurrences du "
"dictionnaire (``foo``) en ``data['foo']`` : ::"

#: ../Doc/library/ast.rst:249
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr ""
"Gardez en tête que si un nœud sur lequel vous travaillez a des nœuds "
"enfants, vous devez transformer également ces nœuds enfant vous-même ou "
"appeler d'abord la méthode :meth:`generic_visit` sur le nœud."

#: ../Doc/library/ast.rst:253
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"Pour les nœuds qui font partie d'une collection d'instructions (cela "
"s'applique à tous les nœuds instruction), le visiteur peut aussi renvoyer la "
"liste des nœuds plutôt qu'un seul nœud."

#: ../Doc/library/ast.rst:257
msgid "Usually you use the transformer like this::"
msgstr "Utilisation typique du *transformer* ::"

#: ../Doc/library/ast.rst:264
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  The returned string will show the names and the values "
"for fields.  This makes the code impossible to evaluate, so if evaluation is "
"wanted *annotate_fields* must be set to ``False``.  Attributes such as line "
"numbers and column offsets are not dumped by default.  If this is wanted, "
"*include_attributes* can be set to ``True``."
msgstr ""
"Renvoie un *dump* formaté de l'arbre dans *node*. C'est principalement utile "
"à des fins de débogage. La chaîne de caractères renvoyée présente les noms "
"et valeurs des champs. Cela rend le code impossible à évaluer, si l'on "
"souhaite évaluer ce code, l'option *annotate_fields* doit être définie comme "
"``False``. Les attributs comme les numéros de ligne et les décalages de "
"colonne ne sont pas récupérés par défaut. Si l'on souhaite les récupérer, "
"l'option *include_attributes* peut être définie comme ``True``."

#: ../Doc/library/ast.rst:273
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, une "
"ressource documentaire externe, qui possède plus de détails pour travailler "
"avec des ASTs Python."
