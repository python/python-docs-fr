# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-09-12 13:37+0200\n"
"PO-Revision-Date: 2017-11-07 22:59+0100\n"
"Last-Translator: Julien Palard <julien@palard.fr>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.0.2\n"

#: ../Doc/library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- Opérations à base d'expressions rationnelles"

#: ../Doc/library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr "**Code source :** :source:`Lib/re.py`"

#: ../Doc/library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr ""
"Ce module fournit des opérations sur les expressions rationnelles  "
"similaires à celles que l'on trouve dans Perl."

#: ../Doc/library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings as well as 8-"
"bit strings. However, Unicode strings and 8-bit strings cannot be mixed: "
"that is, you cannot match a Unicode string with a byte pattern or vice-"
"versa; similarly, when asking for a substitution, the replacement string "
"must be of the same type as both the pattern and the search string."
msgstr ""
"Motifs comme chaînes à analyser peuvent aussi bien être des chaînes Unicode "
"que des chaînes 8-bit. Cependant, chaînes Unicode et 8-bit ne peuvent pas "
"être mélangées : vous ne pouvez ainsi pas analyser une chaîne Unicode avec "
"un motif 8-bit, et inversement ; similairement, lors d'une substitution, la "
"chaîne de remplacement doit être du même type que le motif et la chaîne "
"analysée."

#: ../Doc/library/re.rst:23
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal."
msgstr ""
"Les expressions rationnelles utilisent le caractère *backslash* (``'\\'``) "
"pour indiquer des formes spéciales ou permettre d'utiliser des caractères "
"spéciaux sans en invoquer le sens.  Cela entre en conflit avec l'utilisation "
"en Python du même caractère pour la même raison dans les chaînes "
"littérales ; par exemple, pour rechercher un *backslash* littéral il "
"faudrait écrire ``'\\\\\\\\'`` comme motif, parce que l'expression "
"rationnelle devrait être ``\\\\``, et chaque *backslash* exprimé par ``\\"
"\\`` au sein des chaînes littérales Python."

#: ../Doc/library/re.rst:32
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"La solution est d'utiliser la notation des chaînes brutes en Python pour les "
"expressions rationnelles ; Les *backslashes* ne provoquent aucun traitement "
"spécifique dans les chaînes littérales préfixées par ``'r'``.  Ainsi, ``r"
"\"\\n\"`` est une chaîne de deux caractères contenant ``'\\'`` et ``'n'``, "
"tandis que ``\"\\n\"`` est une chaîne contenant un unique caractère : un "
"saut de ligne. Généralement, les motifs seront exprimés en Python à l'aide "
"de chaînes brutes."

#: ../Doc/library/re.rst:39
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"Il est important de noter que la plupart des opérations sur les expressions "
"rationnelles sont disponibles comme fonctions au niveau du module et comme "
"méthodes des :ref:`expressions rationnelles compilées <re-objects>`.  Les "
"fonctions sont des raccourcis qui ne vous obligent pas à d'abord compiler un "
"objet *regex*, mais auxquelles manquent certains paramètres de configuration "
"fine."

#: ../Doc/library/re.rst:47
msgid ""
"The third-party `regex <https://pypi.python.org/pypi/regex/>`_ module, which "
"has an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"Le module tiers `regex <https://pypi.python.org/pypi/regex/>`_, dont "
"l'interface est compatible avec le module :mod:`re` de la bibliothèque "
"standard, mais offre des fonctionnalités additionnelles et un meilleur "
"support de l'Unicode."

#: ../Doc/library/re.rst:55
msgid "Regular Expression Syntax"
msgstr "Syntaxe des Expressions Rationnelles"

#: ../Doc/library/re.rst:57
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"Une expression rationnelle (*regular expression* ou *RE*) spécifie un "
"ensemble de chaînes de caractères qui lui correspondent ; les fonctions de "
"ce module vous permettent de vérifier si une chaîne particulière correspond "
"à une expression rationnelle donnée (ou si un expression rationnelle donnée "
"correspond à une chaîne particulière, ce qui revient à la même chose)."

#: ../Doc/library/re.rst:62
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book referenced above, or almost any textbook about "
"compiler construction."
msgstr ""
"Les expressions rationnelles peuvent être concaténées pour former de "
"nouvelles expressions : si *A* et *B* sont deux expressions rationnelles, "
"alors *AB* est aussi une expression rationnelle. En général, si une chaîne "
"*p* valide *A* et qu'une autre chaîne *q* valide *B*, la chaîne *pq* "
"validera AB. Cela est vrai tant que *A* et *B* ne contiennent pas "
"d'opérations de précédence ; de conditions liées entre *A* et *B* ; ou de "
"références vers des groupes numérotés.  Ainsi, des expressions complexes "
"peuvent facilement être construites depuis de plus simples expressions "
"primitives comme celles décrites ici.  Pour plus de détails sur la théorie "
"et l'implémentation des expressions rationnelles, consultez le livre de "
"Frield référencé plus tôt, ou à peu près n'importe quel livre dédié à la "
"construction de compilateurs."

#: ../Doc/library/re.rst:72
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"Une brève explication sur le format des expressions rationnelles suit.  Pour "
"de plus amples informations, et une meilleure présentation, référez-vous au :"
"ref:`regex-howto`."

#: ../Doc/library/re.rst:75
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"Les expressions rationnelles peuvent contenir à la fois des caractères "
"spéciaux et ordinaires. Les plus ordinaires, comme ``'A'``, ``'a'`` ou "
"``'0'`` sont les expressions rationnelles les plus simples : elles "
"correspondent simplement à elles-mêmes.  Vous pouvez concaténer deux "
"caractères ordinaires, donc ``last`` correspond à la chaîne ``'last'``.  "
"(Dans la suite de cette section, nous écrirons les expressions rationnelles "
"dans ``ce style spécifique``, généralement sans guillemets, et les chaînes à "
"tester ``'entourées de simples guillemets'``.)"

#: ../Doc/library/re.rst:82
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted. Regular expression pattern strings "
"may not contain null bytes, but can specify the null byte using a ``"
"\\number`` notation such as ``'\\x00'``."
msgstr ""
"Certains caractères, comme ``'|'`` ou ``'('``, sont spéciaux. Des caractères "
"spéciaux peuvent aussi exister pour les classes de caractères ordinaires, ou "
"affecter comment les expressions rationnelles autour d'eux seront "
"interprétées. Les motifs d'expressions rationnelles ne devraient pas "
"contenir de caractères nuls, mais peuvent spécifier le caractère nul en "
"utilisant une notation ``\\number`` comme ``\\x00``."

#: ../Doc/library/re.rst:88
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the "
"expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""
"Les caractères de répétition (``*``, ``+``, ``?``, ``{m,n}``, etc.) ne "
"peuvent être directement imbriqués. Cela empêche l'ambiguïté avec le suffixe "
"modificateur non gourmand ``?``, et avec les autres modificateurs dans "
"d'autres implémentations. Pour appliquer une seconde répétition à une "
"première, des parenthèses peuvent être utilisées. Par exemple, l'expression "
"``(?:a{6})*`` valide toutes les chaînes composées d'un nombre de caractères "
"``'a'`` multiple de six."

#: ../Doc/library/re.rst:95
msgid "The special characters are:"
msgstr "Les caractères spéciaux sont :"

#: ../Doc/library/re.rst:100
msgid "``'.'``"
msgstr "``'.'``"

#: ../Doc/library/re.rst:98
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""
"(Point.)  Dans le mode par défaut, il valide tout caractère à l'exception du "
"saut de ligne.  Si l'option :const:`DOTALL` a été spécifiée, il valide tout "
"caractère, saut de ligne compris."

#: ../Doc/library/re.rst:104
msgid "``'^'``"
msgstr "``'^'``"

#: ../Doc/library/re.rst:103
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(Accent circonflexe.)  Valide le début d'une chaîne de caractères, ainsi que "
"ce qui suit chaque saut de ligne en mode :const:`MULTILINE`."

#: ../Doc/library/re.rst:113
msgid "``'$'``"
msgstr "``'$'``"

#: ../Doc/library/re.rst:107
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression ``foo"
"$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"Valide la fin d'une chaîne de caractères, ou juste avant le saut de ligne à "
"la fin de la chaîne, ainsi qu'avant chaque saut de ligne en mode :const:"
"`MULTILINE`.  ``foo`` valide à la fois 'foo' et 'foobar', tandis que "
"l'expression rationnelle ``foo$`` ne correspond qu'à 'foo'.  Plus "
"intéressant, chercher ``foo.$`` dans ``'foo1\\nfoo2\\n'`` trouve normalement "
"'foo2', mais 'foo1' en mode :const:`MULTILINE` ; chercher un simple ``$`` "
"dans ``'foo\\n'`` trouvera deux correspondances (vides) : une juste avant le "
"saut de ligne, et une à la fin de la chaîne."

#: ../Doc/library/re.rst:118
msgid "``'*'``"
msgstr "``'*'``"

#: ../Doc/library/re.rst:116
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"Implique à l'expression rationnelle résultante de valider 0 répétition ou "
"plus de l'expression qui précède, avec autant de répétitions que possible.  "
"``ab*`` validera 'a', 'ab' ou 'a' suivi de n'importe quel nombre de 'b'."

#: ../Doc/library/re.rst:123
msgid "``'+'``"
msgstr "``'+'``"

#: ../Doc/library/re.rst:121
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"Implique à l'expression rationnelle résultante de valider une répétition ou "
"plus de l'expression qui précède. ``ab+`` validera 'a' suivi de n'importe "
"quel nombre non nul de 'b' ; ça ne validera pas la chaîne 'a'."

#: ../Doc/library/re.rst:127
msgid "``'?'``"
msgstr "``'?'``"

#: ../Doc/library/re.rst:126
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"Implique à l'expression rationnelle résultante de valider 0 ou 1 répétition "
"de l'expression qui précède. ``ab?`` correspondra à la fois à 'a' et 'ab'."

#: ../Doc/library/re.rst:136
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../Doc/library/re.rst:130
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``<a> b <c>``, it will match the entire "
"string, and not just ``<a>``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``<a>``."
msgstr ""
"Les qualificateurs ``'*'``, ``'+'`` et ``'?'`` sont tous :dfn:`greedy` "
"(gourmands) ; ils valident autant de texte que possible.  Parfois ce "
"comportement n'est pas désiré ; si l'expression rationnelle ``<.*>`` est "
"testée avec la chaîne ``<a> b <c>``, cela correspondra à la chaîne entière, "
"et non juste à ``<a>``.  Ajouter ``?`` derrière le qualificateur lui fait "
"réaliser l'opération de façon :dfn:`non-greedy` (ou :dfn:`minimal`) ; le "
"*moins* de caractères possibles seront validés.  Utiliser l'expression "
"rationnelle ``<.*?>`` validera uniquement ``<a>``."

#: ../Doc/library/re.rst:141
msgid "``{m}``"
msgstr "``{m}``"

#: ../Doc/library/re.rst:139
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"Spécifie qu'exactement *m* copies de l'expression rationnelle qui précède "
"devront être validées ; un nombre plus faible de correspondances empêche "
"l'expression entière de correspondre.  Par exemple, ``a{6}`` correspondra "
"exactement à six caractères ``'a'``, mais pas à cinq."

#: ../Doc/library/re.rst:150
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../Doc/library/re.rst:144
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``aaaab`` or a thousand "
"``'a'`` characters followed by a ``b``, but not ``aaab``. The comma may not "
"be omitted or the modifier would be confused with the previously described "
"form."
msgstr ""
"Implique à l'expression rationnelle résultante de valider entre *m* et *n* "
"répétitions de l'expression qui précède, cherchant à en valider le plus "
"possible.  Par exemple, ``a{3,5}`` validera entre 3 et 5 caractères "
"``'a'``.  Omettre *m* revient à spécifier 0 comme borne inférieure, et "
"omettre *n* à avoir une borne supérieure infinie.  Par exemple, ``a{4,}b`` "
"correspondra à ``aaaab`` ou à un millier de caractères ``'a'`` suivis d'un "
"``b``, mais pas à ``aaab``. La virgule ne doit pas être omise, auquel cas le "
"modificateur serait confondu avec la forme décrite précédemment."

#: ../Doc/library/re.rst:157
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../Doc/library/re.rst:153
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous qualifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"Implique à l'expression rationnelle résultante de valider entre *m* et *n* "
"répétitions de l'expression qui précède, cherchant à en valider le moins "
"possible.  Il s'agit de la version non gourmande du précédent "
"qualificateur.  Par exemple, dans la chaîne de 6 caractères ``'aaaaaa'``, "
"``a{3,5}`` trouvera 5 caractères ``'a'``, alors que ``a{3,5}?`` n'en "
"trouvera que 3."

#: ../Doc/library/re.rst:170
msgid "``'\\'``"
msgstr "``'\\'``"

#: ../Doc/library/re.rst:160
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"Échappe à la fois les caractères spéciaux (permettant d'utiliser des "
"caractères comme ``'*'``, ``'?'`` et autres), ou signale une séquence "
"spéciale ; les séquences spéciales sont décrites ci-dessous."

#: ../Doc/library/re.rst:164
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"Si vous n'utilisez pas de chaînes brutes pour exprimer le motif, souvenez-"
"vous que Python utilise aussi le *backslash* comme une séquence "
"d'échappement dans les chaînes littérales ; si la séquence d'échappement "
"n'est pas reconnue par le parseur Python, le *backslash* et les caractères "
"qui le suivent sont inclus dans la chaîne renvoyée.  Cependant, si Python "
"avait reconnu la séquence, le *backslash* aurait dû être doublé.  C'est "
"assez compliqué et difficile à comprendre, c'est pourquoi il est hautement "
"recommandé d'utiliser des chaînes brutes pour tout sauf les expressions les "
"plus simples."

#: ../Doc/library/re.rst:202
msgid "``[]``"
msgstr "``[]``"

#: ../Doc/library/re.rst:173
msgid "Used to indicate a set of characters.  In a set:"
msgstr "Utilisé pour indiquer un ensemble de caractères.  Dans un ensemble :"

#: ../Doc/library/re.rst:175
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"Les caractères peuvent être listés individuellement, e.g. ``[amk]`` "
"correspondra à ``'a'``, ``'m'`` ou ``'k'``."

#: ../Doc/library/re.rst:178
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"Des intervalles de caractères peuvent être indiqués en donnant deux "
"caractères et les séparant par un ``'-'``, par exemple ``[a-z]`` "
"correspondra à toute lettre minuscule *ASCII*, ``[0-5][0-9]`` à tous nombres "
"de deux chiffres entre ``00` et ``59``, et ``[0-9A-Fa-f]`` correspondra à "
"n'importe quel chiffre hexadécimal.  Si ``'-'`` est échappé (``[a\\-z]``) ou "
"s'il est placé comme premier ou dernier caractère (e.g. ``[a-]``), il "
"correspondra à un ``'-'`` littéral."

#: ../Doc/library/re.rst:185
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"Les caractères spéciaux perdent leur sens à l'intérieur des ensembles.  Par "
"exemple, ``[(+*)]`` validera chacun des caractères littéraux ``'('``, "
"``'+'``, ``'*'`` ou ``')'``."

#: ../Doc/library/re.rst:189
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on "
"whether :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"Les classes de caractères telles que ``\\w`` ou ``\\S`` (définies ci-"
"dessous) sont aussi acceptées à l'intérieur d'un ensemble, bien que les "
"caractères correspondant dépendent de quel mode est actif entre :const:"
"`ASCII` et :const:`LOCALE`."

#: ../Doc/library/re.rst:193
msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"Les caractères qui ne sont pas dans un intervalle peuvent être trouvés avec "
"l'ensemble complémentaire (:dfn:`complementing`).  Si le premier caractère "
"de l'ensemble est ``'^'``, tous les caractères qui *ne sont pas* dans "
"l'ensemble seront validés.  Par exemple, ``[^5]`` correspondra à tout "
"caractère autre que ``'5'``, et ``[^^]`` validera n'importe quel caractère "
"excepté ``'^'``.  ``^`` n'a pas de sens particulier s'il n'est pas le "
"premier caractère de l'ensemble."

#: ../Doc/library/re.rst:200
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""
"Pour insérer un ``']'`` littéral dans un ensemble, il faut le précéder d'un "
"*backslash* ou le placer au début de l'ensemble.  Par exemple, ``[()[\\]"
"{}]`` et ``[]()[{}]`` vont tous deux correspondre à une parenthèse, un "
"crochet ou une accolade."

#: ../Doc/library/re.rst:213
msgid "``'|'``"
msgstr "``'|'``"

#: ../Doc/library/re.rst:205
msgid ""
"``A|B``, where A and B can be arbitrary REs, creates a regular expression "
"that will match either A or B.  An arbitrary number of REs can be separated "
"by the ``'|'`` in this way.  This can be used inside groups (see below) as "
"well.  As the target string is scanned, REs separated by ``'|'`` are tried "
"from left to right. When one pattern completely matches, that branch is "
"accepted. This means that once ``A`` matches, ``B`` will not be tested "
"further, even if it would produce a longer overall match.  In other words, "
"the ``'|'`` operator is never greedy.  To match a literal ``'|'``, use ``\\|"
"``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``, où A et B peuvent être deux expressions rationnelles arbitraires, "
"crée une expression rationnelle qui validera à la fois A et B.  Un nombre "
"arbitraire d'expressions peuvent être séparées de cette façon par des "
"``'|'``.  Cela peut aussi être utilisé au sein de groupes (voir ci-"
"dessous).  Quand une chaîne cible est analysée, les expressions séparées par "
"``'|'`` sont essayées de la gauche vers la droite. Quand un motif correspond "
"complètement, cette branche est acceptée. Cela signifie qu'une fois que "
"``A`` correspond, ``B`` ne sera pas testée plus loin, même si elle pourrait "
"provoquer une plus ample correspondance.  En d'autres termes, l'opérateur "
"``'|'`` n'est jamais gourmand.  Pour valider un ``'|'`` littéral, utilisez ``"
"\\|``, ou enveloppez-le dans une classe de caractères, comme ``[|]``."

#: ../Doc/library/re.rst:220
msgid "``(...)``"
msgstr "``(...)``"

#: ../Doc/library/re.rst:216
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(] [)]``."
msgstr ""
"Valide n'importe quelle expression rationnelle comprise entre les "
"parenthèses, et indique le début et la fin d'un groupe ; le contenu d'un "
"groupe peut être récupéré après qu'une analyse a été effectuée, et peut être "
"réutilisé plus loin dans la chaîne avec une séquence spéciale ``\\number``, "
"décrite ci-dessous.  Pour écrire des ``'('`` ou ``')'`` littéraux, utilisez "
"``\\(`` ou ``\\)``, ou enveloppez-les dans une classe de caractères : ``[(] "
"[)]``."

#: ../Doc/library/re.rst:227
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../Doc/library/re.rst:223
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"Il s'agit d'une notation pour les extensions (un ``'?'`` suivant une ``'('`` "
"n'a pas de sens autrement).  Le premier caractère après le ``'?'`` détermine "
"quel sens donner à l'expression. Les extensions ne créent généralement pas "
"de nouveaux groupes ; ``(?P<name>...)`` est la seule exception à la règle. "
"Retrouvez ci-dessous la liste des extensions actuellement supportées."

#: ../Doc/library/re.rst:240
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../Doc/library/re.rst:230
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters "
"set the corresponding flags: :const:`re.A` (ASCII-only matching), :const:`re."
"I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` (multi-"
"line), :const:`re.S` (dot matches all), and :const:`re.X` (verbose), for the "
"entire regular expression. (The flags are described in :ref:`contents-of-"
"module-re`.) This is useful if you wish to include the flags as part of the "
"regular expression, instead of passing a *flag* argument to the :func:`re."
"compile` function.  Flags should be used first in the expression string."
msgstr ""
"(Une lettre ou plus de l'ensemble ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  Le groupe valide la chaîne vide ; les lettres "
"activent les modes correspondant : :const:`re.A` (validation *ASCII* "
"seulement), :const:`re.I` (ignorer la casse)`, :const:`re.L` (dépendant de "
"la locale), :const:`re.M` (multi-ligne), :const:`re.S` (les points "
"correspondent à tous les caractères) et :const:`re.X` (verbeux), pour "
"l'ensemble de l'expression rationnelle. (Les options dans décrites dans la "
"section :ref:`contents-of-module-re`.)  C'est utile si vous souhaitez "
"préciser l'option dans l'expression rationnelle, plutôt qu'en passant un "
"argument *flag* à la fonction :func:`re.compile`.  Les options devraient "
"être spécifiées en premier dans la chaîne de l'expression."

#: ../Doc/library/re.rst:246
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../Doc/library/re.rst:243
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"Une version non capturante des parenthèses habituelles.  Valide n'importe "
"quelle expression rationnelle à l'intérieur des parenthèses, mais la sous-"
"chaîne correspondant au groupe *ne peut pas* être récupérée après l'analyse "
"ou être référencée plus loin dans le motif."

#: ../Doc/library/re.rst:256
msgid "``(?imsx-imsx:...)``"
msgstr "``(?imsx-imsx:...)``"

#: ../Doc/library/re.rst:249
msgid ""
"(Zero or more letters from the set ``'i'``, ``'m'``, ``'s'``, ``'x'``, "
"optionally followed by ``'-'`` followed by one or more letters from the same "
"set.)  The letters set or removes the corresponding flags: :const:`re.I` "
"(ignore case), :const:`re.M` (multi-line), :const:`re.S` (dot matches all), "
"and :const:`re.X` (verbose), for the part of the expression.  (The flags are "
"described in :ref:`contents-of-module-re`.)"
msgstr ""
"(Zéro lettres ou plus de l'ensemble ``'i'``, ``'m'``, ``'s'``, ``'x'``, "
"optionnellement suivies par ``'-'`` ainsi qu'une ou plusieurs lettres du "
"même ensemble.)  Les lettres activent ou désactivent les options "
"correspondantes : :const:`re.I` (ignorer la casse), :const:`re.M` (multi-"
"ligne), :const:`re.S` (les points correspondent à tous les caractères) et :"
"const:`re.X` (verbeux), pour cette partie de l'expression.  (Les options "
"sont décrites dans la section :ref:`contents-of-module-re`.)"

#: ../Doc/library/re.rst:281
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../Doc/library/re.rst:259
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"Similaires aux parenthèses habituelles, mais la sous-chaîne validée par le "
"groupe est accessible via le nom *name* du groupe symbolique.  Les noms de "
"groupes doivent être des identifiants Python valides, et chaque nom de "
"groupe ne doit être défini qu'une seule fois dans une expression "
"rationnelle.  Un groupe symbolique est aussi un groupe numéroté, de la même "
"manière que si le groupe n'était pas nommé."

#: ../Doc/library/re.rst:265
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"Les groupes nommés peuvent être référencés dans trois contextes.  Si le "
"motif est ``(?P<quote>['\"]).*?(?P=quote)`` (i.e. correspondant à une chaîne "
"entourée de guillemets simples ou doubles)."

#: ../Doc/library/re.rst:270
msgid "Context of reference to group \"quote\""
msgstr "Contexte de référence au groupe \"quote\""

#: ../Doc/library/re.rst:270
msgid "Ways to reference it"
msgstr "Manières de le référencer"

#: ../Doc/library/re.rst:272
msgid "in the same pattern itself"
msgstr "lui-même dans le même motif"

#: ../Doc/library/re.rst:272
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (comme vu)"

#: ../Doc/library/re.rst:273 ../Doc/library/re.rst:280
msgid "``\\1``"
msgstr "``\\1``"

#: ../Doc/library/re.rst:275
msgid "when processing match object ``m``"
msgstr "en analysant l'objet résultat ``m``"

#: ../Doc/library/re.rst:275
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../Doc/library/re.rst:276
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (etc.)"

#: ../Doc/library/re.rst:278
msgid "in a string passed to the ``repl`` argument of ``re.sub()``"
msgstr "dans une chaîne passée à l'argument ``repl`` de ``re.sub()``"

#: ../Doc/library/re.rst:278
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../Doc/library/re.rst:279
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../Doc/library/re.rst:285
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../Doc/library/re.rst:284
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"Une référence arrière à un groupe nommé ; elle correspond à n'importe quel "
"texte validé plus tôt par le groupe nommé *name*."

#: ../Doc/library/re.rst:288
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../Doc/library/re.rst:288
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "Un commentaire ; le contenu des parenthèses est simplement ignoré."

#: ../Doc/library/re.rst:293
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../Doc/library/re.rst:291
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a lookahead assertion.  For example, ``Isaac (?=Asimov)`` "
"will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"Valide si ``...`` valide la suite, mais ne consomme rien de la chaîne.  On "
"appelle cela une assertion *lookahead*.  Par exemple, ``Isaac (?=Asimov)`` "
"correspondra à la chaîne ``'Isaac'`` seulement si elle est suivie par "
"``'Asimov'``."

#: ../Doc/library/re.rst:298
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../Doc/library/re.rst:296
msgid ""
"Matches if ``...`` doesn't match next.  This is a negative lookahead "
"assertion. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only if "
"it's *not* followed by ``'Asimov'``."
msgstr ""
"Valide si ``...`` ne valide pas la suite.  C'est une assertion *lookahead* "
"négative. Par exemple, ``Isaac (?!Asimov)`` correspondra à la chaîne "
"``'Isaac'`` seulement si elle *n'est pas* suivie par ``'Asimov'``."

#: ../Doc/library/re.rst:323
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../Doc/library/re.rst:301
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``abcdef``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than the :"
"func:`match` function:"
msgstr ""
"Valide si la position courante dans la chaîne est précédée par une "
"correspondance sur ``...`` qui se termine à la position courante.  On "
"appelle cela une :dfn:`positive lookbehind assertion`. ``(?<=abc)def`` "
"cherchera une correspondance dans ``abcdef``, puisque le *lookbehind** "
"mettra de côté 3 caractères et vérifiera que le motif contenu correspond.  "
"Le motif ne devra correspondre qu'à des chaînes de taille fixe, cela veut "
"dire que ``abc`` ou ``a|b` sont autorisées, mais pas ``a*`` ou ``a{3,4}``.  "
"Notez que les motifs qui commencent par des assertions *lookbehind* "
"positives ne peuvent pas correspondre au début de la chaîne analysée ; vous "
"préférerez sûrement utiliser la fonction :func:`search` plutôt que la "
"fonction :func:`match` :"

#: ../Doc/library/re.rst:316
msgid "This example looks for a word following a hyphen:"
msgstr "Cet exemple recherche un mot suivi d'un trait d'union :"

#: ../Doc/library/re.rst:322
msgid "Added support for group references of fixed length."
msgstr "Ajout du support des références aux groupes de taille fixe."

#: ../Doc/library/re.rst:330
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../Doc/library/re.rst:326
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"Valide si la position courante dans la chaîne n'est pas précédée par une "
"correspondance sur ``...``.  On appelle cela une :dfn:`negative lookbehind "
"assertion`.  À la manière des assertions *lookbehind* positives, le motif "
"contenu ne peut que correspondre à des chaînes de taille fixe.  Les motifs "
"débutant par une assertion *lookbehind* négative peuvent correspondre au "
"début de la chaîne analysée."

#: ../Doc/library/re.rst:339
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../Doc/library/re.rst:333
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"Essaiera de faire la correspondance avec ``yes-pattern`` si le groupe "
"indiqué par *id* ou *name* existe, et avec ``no-pattern`` s'il n'existe pas. "
"``no-pattern`` est optionnel et peut être omis. Par exemple, ``(<)?(\\w+@\\w"
"+(?:\\.\\w+)+)(?(1)>|$)`` est un motif simpliste pour identifier une adresse "
"courriel, qui validera ``'<user@host.com>'`` ainsi que ``'user@host.com'`` "
"mais pas ``'<user@host.com'`` ni ``'user@host.com>'``."

#: ../Doc/library/re.rst:341
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"Les séquences spéciales sont composées de ``'\\'`` et d'un caractère de la "
"liste qui suit. Si le caractère ordinaire n'est pas un chiffre *ASCII* ou "
"une lettre *ASCII*, alors l'expression rationnelle résultante validera le "
"second caractère de la séquence.  Par exemple, ``\\$`` correspond au "
"caractère ``'$'``."

#: ../Doc/library/re.rst:354
msgid "``\\number``"
msgstr "``\\number``"

#: ../Doc/library/re.rst:347
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"Correspond au contenu du groupe du même nombre. Les groupes sont numérotés à "
"partir de 1.  Par exemple, ``(.+) \\1`` correspond à ``'the the'`` ou ``'55 "
"55'``, mais pas à ``'thethe'`` (notez l'espace après le groupe).  Cette "
"séquence spéciale ne peut être utilisée que pour faire référence aux 99 "
"premiers groupes.  Si le premier chiffre de *number* est 0, ou si *number* "
"est un nombre octal de 3 chiffres, il ne sera pas interprété comme une "
"référence à un groupe, mais comme le caractère à la valeur octale *number*. "
"À l'intérieur des ``'['`` et ``']'`` d'une classe de caractères, tous les "
"échappements numériques sont traités comme des caractères."

#: ../Doc/library/re.rst:357
msgid "``\\A``"
msgstr "``\\A``"

#: ../Doc/library/re.rst:357
msgid "Matches only at the start of the string."
msgstr "Correspond uniquement au début d'une chaîne de caractères."

#: ../Doc/library/re.rst:372
msgid "``\\b``"
msgstr "``\\b``"

#: ../Doc/library/re.rst:360
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of Unicode alphanumeric or underscore characters, "
"so the end of a word is indicated by whitespace or a non-alphanumeric, non-"
"underscore Unicode character.  Note that formally, ``\\b`` is defined as the "
"boundary between a ``\\w`` and a ``\\W`` character (or vice versa), or "
"between ``\\w`` and the beginning/end of the string. This means that "
"``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo "
"baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"Correspond à la chaîne vide, mais uniquement au début ou à la fin d'un mot. "
"Un mot est défini comme une séquence de caractères Unicode alphanumériques "
"ou de tirets bas, la fin d'un mot est ainsi indiquée par une espace ou un "
"caractère qui n'est ni alphanumérique ni un tiret bas.  Notez que "
"formellement, ``\\b`` est défini comme la liaison entre ``\\w`` et ``\\W`` "
"(et inversement), ou entre ``\\w`` et le début/fin d'un mot. Cela signifie "
"que ``r'\\bfoo\\b'`` validera ``'foo'``, ``'foo.'``, ``'(foo)'`` ou ``'bar "
"foo baz'`` mais pas ``'foobar'`` ou ``'foo3'``."

#: ../Doc/library/re.rst:369
msgid ""
"By default Unicode alphanumerics are the ones used, but this can  be changed "
"by using the :const:`ASCII` flag.  Inside a character range, ``\\b`` "
"represents the backspace character, for compatibility with Python's string "
"literals."
msgstr ""
"Les caractères alphanumériques Unicode sont utilisés par défaut, mais cela "
"peut être changé en utilisant l'option :const:`ASCII`.  À l'intérieur d'un "
"intervalle de caractères, ``\\b`` représente le caractère *backspace*, par "
"compatibilité avec les chaînes littérales Python."

#: ../Doc/library/re.rst:380
msgid "``\\B``"
msgstr "``\\B``"

#: ../Doc/library/re.rst:375
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters are Unicode alphanumerics or the "
"underscore, although this can be changed by using the :const:`ASCII` flag."
msgstr ""
"Correspond à la chaîne vide, mais uniquement quand elle *n'est pas* au début "
"ou à la fin d'un mot.  Cela signifie que ``r'py\\B'`` valide ``'python'``, "
"``'py3'`` ou ``'py2'``, mais pas ``'py'``, ``'py.'`` ou ``'py!'``. ``\\B`` "
"est simplement l'opposé de ``\\b``, donc les caractères de mots sont les "
"alphanumériques et tirets bas Unicode, bien que cela puisse être changé avec "
"l'option :const:`ASCII`."

#: ../Doc/library/re.rst:391
msgid "``\\d``"
msgstr "``\\d``"

#: ../Doc/library/re.rst:388 ../Doc/library/re.rst:408
#: ../Doc/library/re.rst:427
msgid "For Unicode (str) patterns:"
msgstr "Pour les motifs Unicode (str) :"

#: ../Doc/library/re.rst:384
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched (but the flag affects the entire regular expression, so in such "
"cases using an explicit ``[0-9]`` may be a better choice)."
msgstr ""
"Valide n'importe quel chiffre décimal Unicode (soit tout caractère Unicode "
"de catégorie [Nd]).  Cela inclue ``[0-9]``, mais aussi bien d'autres "
"caractères de chiffres.  Si l'option :const:`ASCII` est utilisée, seuls les "
"caractères de la classe ``[0-9]`` correspondront (mais l'option affectant "
"l'expression rationnelle entière, il peut être préférable dans ce genre de "
"cas d'utiliser un ``[0-9]`` explicite)."

#: ../Doc/library/re.rst:391 ../Doc/library/re.rst:412
#: ../Doc/library/re.rst:431
msgid "For 8-bit (bytes) patterns:"
msgstr "Pour les motifs 8-bit (bytes) :"

#: ../Doc/library/re.rst:391
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "Valide n'importe quel chiffre décimal ; équivalent à ``[0-9]``."

#: ../Doc/library/re.rst:398
msgid "``\\D``"
msgstr "``\\D``"

#: ../Doc/library/re.rst:394
msgid ""
"Matches any character which is not a Unicode decimal digit. This is the "
"opposite of ``\\d``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^0-9]`` (but the flag affects the entire regular "
"expression, so in such cases using an explicit ``[^0-9]`` may be a better "
"choice)."
msgstr ""
"Valide tout caractère qui n'est pas un chiffre décimal Unicode. C'est "
"l'opposé de ``\\d``. Si l'option :const:`ASCII` est utilisée, cela devient "
"équivalent à ``[^0-9]`` (mais l'option affectant l'expression rationnelle "
"entière, il peut être préférable dans ce genre de cas d'utiliser un "
"``[^0-9]`` explicite)."

#: ../Doc/library/re.rst:412
msgid "``\\s``"
msgstr "``\\s``"

#: ../Doc/library/re.rst:402
msgid ""
"Matches Unicode whitespace characters (which includes ``[ \\t\\n\\r\\f"
"\\v]``, and also many other characters, for example the non-breaking spaces "
"mandated by typography rules in many languages). If the :const:`ASCII` flag "
"is used, only ``[ \\t\\n\\r\\f\\v]`` is matched (but the flag affects the "
"entire regular expression, so in such cases using an explicit ``[ \\t\\n\\r"
"\\f\\v]`` may be a better choice)."
msgstr ""
"Valide les caractères d'espacement Unicode (qui incluent ``[ \\t\\n\\r\\f"
"\\v]`` et bien d'autres, comme les espaces insécables requises par les "
"règles typographiques de beaucoup de langues). Si l'option :const:`ASCII` "
"est utilisée, seuls les caractères de la classe ``[ \\t\\n\\r\\f\\v]`` sont "
"validés (mais l'option affectant l'expression rationnelle entière, il peut "
"être préférable dans ce genre de cas d'utiliser un ``[ \\t\\n\\r\\f\\v]`` "
"explicite)."

#: ../Doc/library/re.rst:411
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Valide les caractères considérés comme des espacements dans la table ASCII ; "
"équivalent à ``[ \\t\\n\\r\\f\\v]``."

#: ../Doc/library/re.rst:419
msgid "``\\S``"
msgstr "``\\S``"

#: ../Doc/library/re.rst:415
msgid ""
"Matches any character which is not a Unicode whitespace character. This is "
"the opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]`` (but the flag affects the entire "
"regular expression, so in such cases using an explicit ``[^ \\t\\n\\r\\f"
"\\v]`` may be a better choice)."
msgstr ""
"Valide tout caractère qui n'est pas un caractère d'espacement Unicode. c'est "
"l'opposé de ``\\s``. Si l'option :const:`ASCII` est utilisée, cela devient "
"équivalent à ``[^ \\t\\n\\r\\f\\v]`` (mais l'option affectant l'expression "
"rationnelle entière, il peut être préférable dans ce genre de cas d'utiliser "
"un ``[^ \\t\\n\\r\\f\\v]`` explicite)."

#: ../Doc/library/re.rst:431
msgid "``\\w``"
msgstr "``\\w``"

#: ../Doc/library/re.rst:423
msgid ""
"Matches Unicode word characters; this includes most characters that can be "
"part of a word in any language, as well as numbers and the underscore. If "
"the :const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched (but the "
"flag affects the entire regular expression, so in such cases using an "
"explicit ``[a-zA-Z0-9_]`` may be a better choice)."
msgstr ""
"Valide les caractères Unicode de mot ; cela inclut la plupart des caractères "
"qui peuvent être compris dans un mot d'une quelconque langue, aussi bien que "
"les nombres et les tirets bas. Si l'option :const:`ASCII` est utilisée, "
"seuls les caractères de la classe ``[a-zA-Z0-9_]`` sont validés (mais "
"l'option affectant l'expression rationnelle entière, il peut être préférable "
"dans ce genre de cas d'utiliser un ``[a-zA-Z0-9_]`` explicite)."

#: ../Doc/library/re.rst:430
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``."
msgstr ""
"Valide les caractères alphanumériques de la table ASCII ; équivalent à ``[a-"
"zA-Z0-9_]``."

#: ../Doc/library/re.rst:438
msgid "``\\W``"
msgstr "``\\W``"

#: ../Doc/library/re.rst:434
msgid ""
"Matches any character which is not a Unicode word character. This is the "
"opposite of ``\\w``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^a-zA-Z0-9_]`` (but the flag affects the entire regular "
"expression, so in such cases using an explicit ``[^a-zA-Z0-9_]`` may be a "
"better choice)."
msgstr ""
"Valide tout caractère qui n'est pas un caractère Unicode de mot. C'est "
"l'opposé de ``\\w``. Si l'option :const:`ASCII` est utilisée, cela devient "
"équivalent à ``[^a-zA-Z0-9_]`` (mais l'option affectant l'expression "
"rationnelle entière, il peut être préférable dans ce genre de cas d'utiliser "
"un ``[^a-zA-Z0-9_]`` explicite)."

#: ../Doc/library/re.rst:441
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../Doc/library/re.rst:441
msgid "Matches only at the end of the string."
msgstr "Correspond uniquement à la fin d'une chaîne de caractères."

#: ../Doc/library/re.rst:443
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr ""
"La plupart des échappements standards supportés par les chaînes littérales "
"sont aussi acceptés par le parseur d'expressions rationnelles: ::"

#: ../Doc/library/re.rst:450
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(Notez que ``\\b`` est utilisé pour représenter les bornes d'un mot, et "
"signifie « *backspace* » uniquement à l'intérieur d'une classe de "
"caractères.)"

#: ../Doc/library/re.rst:453
msgid ""
"``'\\u'`` and ``'\\U'`` escape sequences are only recognized in Unicode "
"patterns.  In bytes patterns they are not treated specially."
msgstr ""
"Les séquences d'échappement ``'\\u'`` et ``'\\U'`` sont seulement reconnues "
"dans les motifs Unicode.  Aucun traitement spécifique ne leur est porté dans "
"les motifs 8-bit."

#: ../Doc/library/re.rst:456
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"Les séquences octales d'échappement sont inclues dans une forme limitée.  Si "
"le premier chiffre est un 0, ou s'il y a trois chiffres octaux, la séquence "
"est considérée comme octale. Autrement, il s'agit d'une référence vers un "
"groupe.  Comme pour les chaînes littérales, les séquences octales ne font "
"jamais plus de 3 caractères de long."

#: ../Doc/library/re.rst:461
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "Les séquences d'échappement ``'\\u'`` et ``'\\U'`` ont été ajoutées."

#: ../Doc/library/re.rst:464
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr ""
"Les séquences inconnues composées de ``'\\'`` et d'une lettre ASCII sont "
"maintenant des erreurs."

#: ../Doc/library/re.rst:472
msgid "Mastering Regular Expressions"
msgstr "Maîtriser les expression rationnelles"

#: ../Doc/library/re.rst:471
msgid ""
"Book on regular expressions by Jeffrey Friedl, published by O'Reilly.  The "
"second edition of the book no longer covers Python at all, but the first "
"edition covered writing good regular expression patterns in great detail."
msgstr ""
"Livre sur les expressions rationnelles par Jeffrey Friedl, publié chez "
"OReilly.  La seconde édition de ce livre ne couvre plus du tout Python, mais "
"la première version explique en détails comment écrire de bonnes expressions "
"rationnelles."

#: ../Doc/library/re.rst:480
msgid "Module Contents"
msgstr "Contenu du module"

#: ../Doc/library/re.rst:482
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"Le module définit plusieurs fonctions, constantes, et une exception. "
"Certaines fonctions sont des versions simplifiées des méthodes plus "
"complètes des expressions rationnelles compilées.  La plupart des "
"applications non triviales utilisent toujours la version compilée."

#: ../Doc/library/re.rst:487
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"Les constantes d'options sont maintenant des instances de :class:"
"`RegexFlag`, sous-classe de :class:`enum.IntFlag`."

#: ../Doc/library/re.rst:493
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its :func:`~regex."
"match`, :func:`~regex.search` and other methods, described below."
msgstr ""
"Compile un motif vers une :ref:`expression rationnelle <re-objects>` "
"compilée, dont les méthodes :func:`~regex.match` et :func:`~regex.search`, "
"décrites ci-dessous, peuvent être utilisées pour analyser des textes."

#: ../Doc/library/re.rst:498
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""
"Le comportement des expressions peut être modifié en spécifiant une valeur "
"*flags*. Les valeurs sont comprises dans les variables suivantes, et peuvent "
"être combinées avec un *ou* bit-à-bit (opérateur ``|``)."

#: ../Doc/library/re.rst:502
msgid "The sequence ::"
msgstr "La séquence : ::"

#: ../Doc/library/re.rst:507
msgid "is equivalent to ::"
msgstr "est équivalente à : ::"

#: ../Doc/library/re.rst:511
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"mais utiliser :func:`re.compile` et sauvegarder l'expression rationnelle "
"renvoyée pour la réutiliser est plus efficace quand l'expression est amenée "
"à être utilisée plusieurs fois dans un même programme."

#: ../Doc/library/re.rst:517
msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"compile` and the module-level matching functions are cached, so programs "
"that use only a few regular expressions at a time needn't worry about "
"compiling regular expressions."
msgstr ""
"Les versions compilées des motifs les plus récents passés à :func:`re."
"compile` et autres fonctions d'analyse du module sont mises en cache, ainsi "
"les programmes qui n'utilisent que quelques expressions rationnelles en même "
"temps n'ont pas à s'inquiéter de la compilation de ces expressions."

#: ../Doc/library/re.rst:526
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and ``"
"\\S`` perform ASCII-only matching instead of full Unicode matching.  This is "
"only meaningful for Unicode patterns, and is ignored for byte patterns."
msgstr ""
"Fait correspondre à ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``"
"\\s`` et ``\\s`` des caractères ASCII seulement, plutôt qu'Unicode.  Cela "
"n'a du sens que pour les motifs Unicode, et est ignoré pour les motifs 8-bit."

#: ../Doc/library/re.rst:530
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart ``(?"
"u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"Notez que par compatibilité envers les versions précédentes, l'option :const:"
"`re.U` existe toujours (ainsi que son synonyme :const:`re.UNICODE` et sa "
"version embarquée ``(?u)``), mais elles sont redondantes en Python 3 depuis "
"que l'analyse est faite en Unicode par défaut pour les chaînes de caractères "
"(et que l'analyse Unicode n'est pas permise pour les chaînes 8-bit)."

#: ../Doc/library/re.rst:539
msgid "Display debug information about compiled expression."
msgstr "Affiche des informations de debug à propos de l'expression compilée."

#: ../Doc/library/re.rst:545
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  The current locale does not change the effect of "
"this flag.  Full Unicode matching (such as ``Ü`` matching ``ü``) also works "
"unless the :const:`re.ASCII` flag is also used to disable non-ASCII matches."
msgstr ""
"Effectue une analyse indépendante de la casse. Les motifs tels que ``[A-Z]`` "
"accepteront donc les caractères minuscules. La locale courante n'affecte pas "
"cette option. Les correspondances Unicode (telles que ``Ü`` correspondant à "
"``ü``) fonctionnent aussi, sauf si l'option :const:`re.ASCII` est utilisée "
"pour désactiver explicitement les correspondances non-ASCII."

#: ../Doc/library/re.rst:555
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` dependent on "
"the current locale. The use of this flag is discouraged as the locale "
"mechanism is very unreliable, and it only handles one \"culture\" at a time "
"anyway; you should use Unicode matching instead, which is the default in "
"Python 3 for Unicode (str) patterns. This flag can be used only with bytes "
"patterns."
msgstr ""
"Fait dépendre ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` et ``\\S`` de la "
"locale courante. L'utilisation de cette option est déconseillée à cause du "
"mécanisme de locale très peu fiable, et ne gérant qu'une « culture » à la "
"fois ; vous devriez à la place utiliser l'analyse Unicode, qui est le défaut "
"en Python 3 pour les motifs Unicode (str). Cette option ne peut être "
"utilisée qu'avec les motifs 8-bit."

#: ../Doc/library/re.rst:561
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ""
":const:`re.LOCALE`` ne peut être utilisée qu'avec les motifs 8-bit et n'est "
"pas compatible avec :const:`re.ASCII`."

#: ../Doc/library/re.rst:569
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string."
msgstr ""
"Quand spécifiée, le caractère ``'^'`` correspond au début d'une chaîne et au "
"début d'une ligne (caractère suivant directement le saut de ligne) ; et le "
"caractère ``'$'`` correspond à la fin d'une chaîne et à la fin d'une ligne "
"(juste avant le saut de ligne).  Par défaut, ``'^'`` correspond uniquement "
"au début de la chaîne, et ``'$'`` uniquement à la fin de la chaîne, ou "
"immédiatement avant le saut de ligne (s'il y a) à la fin de la chaîne."

#: ../Doc/library/re.rst:580
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Fait correspondre tous les caractères possibles à ``'.'``, incluant le saut "
"de ligne ; sans cette option, ``'.'`` correspondrait à tout caractère à "
"l'exception du saut de ligne."

#: ../Doc/library/re.rst:587
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class or when preceded by an unescaped backslash. When a "
"line contains a ``#`` that is not in a character class and is not preceded "
"by an unescaped backslash, all characters from the leftmost such ``#`` "
"through the end of the line are ignored."
msgstr ""
"Cette option vous autorise à écrire des expressions rationnelles qui "
"présentent mieux et sont plus lisibles en vous permettant de séparer "
"visuellement les sections logiques du motif et d'ajouter des commentaires. "
"Les caractères d'espacement à l'intérieur du motif sont ignorés, sauf à "
"l'intérieur des classes de caractères ou quand précédés d'un *backslash* non "
"échappé. Quand une ligne contient un ``#`` qui n'est pas dans une classe de "
"caractères ou précédé d'un *backslash* non échappé, tous les caractères "
"depuis le ``#`` le plus à gauche jusqu'à la fin de la ligne sont ignorés."

#: ../Doc/library/re.rst:595
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""
"Cela signifie que les deux expressions rationnelles suivantes qui valident "
"un nombre décimal sont fonctionnellement égales : ::"

#: ../Doc/library/re.rst:608
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :ref:"
"`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"Analyse *string* à la recherche du premier emplacement où l'expression "
"rationnelle *pattern* trouve une correspondance, et renvoie l':ref:`objet de "
"correspondance <match-objects>` trouvé.  Renvoie ``None`` si aucune position "
"dans la chaîne ne valide le motif ; notez que cela est différent de trouver "
"une correspondance avec une chaîne vide à un certain endroit de la chaîne."

#: ../Doc/library/re.rst:617
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""
"Si zéro ou plus caractères au début de *string* correspondent à l'expression "
"rationnelle *pattern*, renvoie l':ref:`objet de correspondance <match-"
"objects>` trouvé.  Renvoie ``None`` si la chaîne ne correspond pas au "
"motif ; notez que cela est différent d'une correspondance avec une chaîne "
"vide."

#: ../Doc/library/re.rst:622
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
"Notez que même en mode :const:`MULTILINE`, :func:`re.match` ne validera "
"qu'au début de la chaîne et non au début de chaque ligne."

#: ../Doc/library/re.rst:625
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"Si vous voulez trouver une correspondance n'importe où dans *string*, "
"utilisez plutôt :func:`search` (voir aussi :ref:`search-vs-match`)."

#: ../Doc/library/re.rst:631
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"Si l'entièreté de la chaîne *string* correspond à l'expression rationnelle "
"*pattern*, renvoie l':ref:`objet de correspondance <match-objects>` trouvé.  "
"Renvoie ``None`` si la chaîne ne correspond pas au motif ; notez que cela "
"est différent d'une correspondance avec une chaîne vide."

#: ../Doc/library/re.rst:641
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"Sépare *string* selon les occurrences de *pattern*.  Si des parenthèses "
"capturantes sont utilisées dans *pattern*, alors les textes des groupes du "
"motif sont aussi renvoyés comme éléments de la liste résultante. Si "
"*maxsplit* est différent de zéro, il ne pourra y avoir plus de *maxsplit* "
"séparations, et le reste de la chaîne sera renvoyé comme le dernier élément "
"de la liste. : ::"

#: ../Doc/library/re.rst:656
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string:"
msgstr ""
"S'il y a des groupes capturants dans le séparateur et qu'ils trouvent une "
"correspondance au début de la chaîne, le résultat commencera par une chaîne "
"vide.  La même chose se produit pour la fin de la chaîne :"

#: ../Doc/library/re.rst:663
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr ""
"De cette manière, les séparateurs sont toujours trouvés aux mêmes indices "
"relatifs dans la liste résultante."

#: ../Doc/library/re.rst:668
msgid ""
":func:`split` doesn't currently split a string on an empty pattern match. "
"For example:"
msgstr ""
":func:`split` ne sépare actuellement pas une chaîne sur une correspondance "
"vide. Par exemple :"

#: ../Doc/library/re.rst:674
msgid ""
"Even though ``'x*'`` also matches 0 'x' before 'a', between 'b' and 'c', and "
"after 'c', currently these matches are ignored.  The correct behavior (i.e. "
"splitting on empty matches too and returning ``['', 'a', 'b', 'c', '']``) "
"will be implemented in future versions of Python, but since this is a "
"backward incompatible change, a :exc:`FutureWarning` will be raised in the "
"meanwhile."
msgstr ""
"Même si ``'x*'`` correspond aussi à 0 'x' avant 'a', entre 'b' et 'c', et "
"après 'c', ces correspondances sont actuellement ignorées.  Le comportement "
"correct (i.e. découper aussi sur les correspondances vides et renvoyer "
"``['', 'a', 'b', 'c', '']``) sera implémenté dans les futures versions de "
"Python, mais comme cela constitue un changement incompatible avec les "
"précédentes, une :exc:`FutureWarning` sera levée pendant la transition."

#: ../Doc/library/re.rst:681
msgid ""
"Patterns that can only match empty strings currently never split the "
"string.  Since this doesn't match the expected behavior, a :exc:`ValueError` "
"will be raised starting from Python 3.5::"
msgstr ""
"Les motifs qui ne peuvent correspondre qu'à des chaînes vides ne permettent "
"actuellement pas de découper la chaîne.  Puisque cela ne correspond pas au "
"comportement voulu, une :exc:`ValueError` sera levée à partir de Python "
"3.5 : ::"

#: ../Doc/library/re.rst:691 ../Doc/library/re.rst:763
#: ../Doc/library/re.rst:783
msgid "Added the optional flags argument."
msgstr "Ajout de l'argument optionnel *flags*"

#: ../Doc/library/re.rst:694
msgid ""
"Splitting on a pattern that could match an empty string now raises a "
"warning.  Patterns that can only match empty strings are now rejected."
msgstr ""
"Découper sur un motif qui peut correspondre à une chaîne vide lève "
"maintenant un avertissement.  Les motifs qui ne peuvent correspondre qu'à "
"des chaînes vides sont maintenant rejetés."

#: ../Doc/library/re.rst:700
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings.  The *string* is scanned left-to-right, and matches are returned in "
"the order found.  If one or more groups are present in the pattern, return a "
"list of groups; this will be a list of tuples if the pattern has more than "
"one group.  Empty matches are included in the result unless they touch the "
"beginning of another match."
msgstr ""
"Renvoie toutes les correspondances de *pattern* dans *string* qui ne se "
"chevauchent pas, sous forme d'une liste de chaînes.  Le chaîne *string* est "
"analysée de la gauche vers la droite, et les correspondances sont renvoyées "
"dans l'ordre où elles sont trouvées.  Si un groupe ou plus sont présents "
"dans le motif, renvoie une liste de groupes ; il s'agira d'une liste de "
"*tuples* si le motif a plus d'un groupe.  Les correspondances vides sont "
"inclues dans le résultat sauf si elles touchent le début d'une autre "
"correspondance."

#: ../Doc/library/re.rst:710
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result unless they touch the "
"beginning of another match."
msgstr ""
"Renvoie un :term:`iterator` produisant des :ref:`objets de correspondance "
"<match-objects>` pour toutes les correspondances non chevauchantes de "
"l'expression rationnelle *pattern* sur la chaîne *string*.  *string* est "
"analysée de la gauche vers la droite, et les correspondances sont renvoyées "
"dans l'ordre où elles sont trouvées.  Les correspondances vides sont inclues "
"dans le résultat sauf si elles touchent le début d'une autre correspondance."

#: ../Doc/library/re.rst:719
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, ``"
"\\r`` is converted to a carriage return, and so forth.  Unknown escapes such "
"as ``\\&`` are left alone.  Backreferences, such as ``\\6``, are replaced "
"with the substring matched by group 6 in the pattern. For example:"
msgstr ""
"Renvoie la chaîne obtenue en remplaçant les occurrences (sans chevauchement) "
"les plus à gauche de *pattern* dans *string* par le remplacement *repl*.  Si "
"le motif n'est pas trouvé, *string* est renvoyée inchangée.  *repl* peut "
"être une chaîne de caractères ou une fonction ; si c'est une chaîne, toutes "
"les séquences d'échappement qu'elle contient sont traduites.  Ainsi, ``\\n`` "
"est convertie en un simple saut de ligne, ``\\r`` en un retour chariot, et "
"ainsi de suite.  Les séquences inconnues telles que ``\\&`` sont laissées "
"intactes.  Les références arrières, telles que ``\\6``, sont remplacées par "
"la sous-chaîne correspondant au groupe 6 dans le motif. Par exemple :"

#: ../Doc/library/re.rst:733
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single match object argument, and "
"returns the replacement string.  For example:"
msgstr ""
"Si *repl* est une fonction, elle est appelée pour chaque occurrence non "
"chevauchante de *pattern*.  La fonction prend comme argument un objet de "
"correspondance, et renvoie la chaîne de remplacement.  Par exemple :"

#: ../Doc/library/re.rst:745
msgid "The pattern may be a string or an RE object."
msgstr ""
"Le motif peut être une chaîne de caractères ou un objet expression "
"rationnelle."

#: ../Doc/library/re.rst:747
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous match, so ``sub('x*', '-', 'abc')`` "
"returns ``'-a-b-c-'``."
msgstr ""
"L'argument optionnel *count* est le nombre maximum d'occurrences du motif à "
"remplacer : *count* ne doit pas être un nombre négatif.  Si omis ou nul, "
"toutes les occurrences seront remplacées. Les correspondances vides avec le "
"motif sont remplacées uniquement quand elles ne sont pas adjacentes à une "
"précédente correspondance, ainsi ``sub('x*', '-', 'abc')`` renvoie ``'-a-b-"
"c-'``."

#: ../Doc/library/re.rst:753
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. ``"
"\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as ``"
"\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not a "
"reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"Dans les arguments *repl* de type *string*, en plus des séquences "
"d'échappement et références arrières décrites au-dessus, ``\\g<name>`` "
"utilisera la sous-chaîne correspondant au groupe nommé ``name``, comme "
"défini par la syntaxe ``(?P<name>...)``. ``\\g<number>`` utilise le groupe "
"numéroté associé ; ``\\g<2>`` est ainsi équivalent à ``\\2``, mais n'est pas "
"ambigu dans un remplacement tel que ``\\g<2>0``, ``\\20`` serait interprété "
"comme une référence au groupe 20, et non une référence au groupe 2 suivie "
"par un caractère littéral ``'0'``.  La référence arrière ``\\g<0>`` est "
"remplacée par la sous-chaîne entière validée par l'expression rationnelle."

#: ../Doc/library/re.rst:766 ../Doc/library/re.rst:786
#: ../Doc/library/re.rst:998
msgid "Unmatched groups are replaced with an empty string."
msgstr "Les groupes sans correspondance sont remplacés par une chaîne vide."

#: ../Doc/library/re.rst:769
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""
"Les séquences d'échappement inconnues dans *pattern* formées par ``'\\'`` et "
"une lettre ASCII sont maintenant des erreurs."

#: ../Doc/library/re.rst:775
msgid ""
"Deprecated since version 3.5, will be removed in version 3.7: Unknown "
"escapes in repl consisting of '\\' and an ASCII letter now raise a "
"deprecation warning and will be forbidden in Python 3.7."
msgstr ""
"Déprécié depuis la version 3.5, sera supprimé dans la 3.7 : Les séquences "
"d'échappement dans *repl* formées d'un '\\' et d'une lettre ASCII lèvent "
"maintenant un avertissement de dépréciation et seront interdites en Python "
"3.7."

#: ../Doc/library/re.rst:775
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now "
"raise a deprecation warning and will be forbidden in Python 3.7."
msgstr ""
"Les séquences d'échappement dans *repl* formées d'un ``'\\'`` et d'une "
"lettre ASCII lèvent maintenant un avertissement de dépréciation et seront "
"interdites en Python 3.7."

#: ../Doc/library/re.rst:780
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""
"Réalise la même opération que :func:`sub`, mais renvoie un *tuple* "
"``(nouvelle_chaîne, nombre_de_substitutions_réalisées)``."

#: ../Doc/library/re.rst:792
msgid ""
"Escape all the characters in *pattern* except ASCII letters, numbers and "
"``'_'``. This is useful if you want to match an arbitrary literal string "
"that may have regular expression metacharacters in it.  For example::"
msgstr ""
"Échappe tous les caractères de *pattern* à l'exception des lettres ASCII, "
"des nombres et de ``'_'``. Cela est utile si vous voulez valider une "
"quelconque chaîne littérale qui pourrait contenir des métacaractères "
"d'expressions rationnelles.  Par exemple : ::"

#: ../Doc/library/re.rst:807
msgid "The ``'_'`` character is no longer escaped."
msgstr "Le caractère ``'_'`` n'est plus échappé."

#: ../Doc/library/re.rst:813
msgid "Clear the regular expression cache."
msgstr "Vide le cache d'expressions rationnelles."

#: ../Doc/library/re.rst:818
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The error instance has the following additional attributes:"
msgstr ""
"Exception levée quand une chaîne passée à l'une des fonctions ici présentes "
"n'est pas une expression rationnelle valide (contenant par exemple une "
"parenthèse non fermée) ou quand d'autres erreurs se produisent durant la "
"compilation ou l'analyse.  Il ne se produit jamais d'erreur si une chaîne ne "
"contient aucune correspondance pour un motif.  Les instances de l'erreur ont "
"les attributs additionnels suivants :"

#: ../Doc/library/re.rst:826
msgid "The unformatted error message."
msgstr "Le message d'erreur non formaté."

#: ../Doc/library/re.rst:830
msgid "The regular expression pattern."
msgstr "Le motif d'expression rationnelle."

#: ../Doc/library/re.rst:834
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr ""
"L'index dans *pattern* où la compilation a échoué (peut valoir ``None``)."

#: ../Doc/library/re.rst:838
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "La ligne correspondant à *pos* (peut valoir ``None``)."

#: ../Doc/library/re.rst:842
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "La colonne correspondant à *pos* (peut valoir ``None``)."

#: ../Doc/library/re.rst:844
msgid "Added additional attributes."
msgstr "Ajout des attributs additionnels."

#: ../Doc/library/re.rst:850
msgid "Regular Expression Objects"
msgstr "Objets d'expressions rationnelles"

#: ../Doc/library/re.rst:852
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr ""
"Les expressions rationnelles compilées supportent les méthodes et attributs "
"suivants :"

#: ../Doc/library/re.rst:857
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"Analyse *string* à la recherche du premier emplacement où l'expression "
"rationnelle trouve une correspondance, et envoie l':ref:`objet de "
"correspondance <match-objects>` trouvé.  Renvoie ``None`` si aucune position "
"dans la chaîne ne satisfait le motif ; notez que cela est différent que de "
"trouver une correspondance vide dans la chaîne."

#: ../Doc/library/re.rst:863
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"Le second paramètre *pos* (optionnel) donne l'index dans la chaîne où la "
"recherche doit débuter ; il vaut ``0`` par défaut.  Cela n'est pas "
"complètement équivalent à un *slicing* sur la chaîne ; le caractère de motif "
"``'^'`` correspond au début réel de la chaîne et aux positions juste après "
"un saut de ligne, mais pas nécessairement à l'index où la recherche commence."

#: ../Doc/library/re.rst:869
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``."
msgstr ""
"Le paramètre optionnel *endpos* limite la longueur sur laquelle la chaîne "
"sera analysée ; ce sera comme si la chaîne faisait *endpos* caractères de "
"long, donc uniquement les caractères de *pos* à ``endpos - 1`` seront "
"analysés pour trouver une correspondance.  Si *endpos* est inférieur à "
"*pos*, aucune correspondance ne sera trouvée ; dit autrement, avec *rx* une "
"expression rationnelle compilée, ``rx.search(string, 0, 50)`` est équivalent "
"à ``rx.search(string[:50], 0)``."

#: ../Doc/library/re.rst:884
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"Si zéro caractère ou plus au début de *string* correspondent à cette "
"expression rationnelle, renvoie l':ref:`objet de correspondance <match-"
"objects>` trouvé. Renvoie ``None`` si la chaîne ne correspond pas au motif ; "
"notez que cela est différent d'une correspondance vide."

#: ../Doc/library/re.rst:889 ../Doc/library/re.rst:907
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~regex.search` method."
msgstr ""
"Les paramètres optionnels *pos* et *endpos* ont le même sens que pour la "
"méthode :meth:`~regex.search`."

#: ../Doc/library/re.rst:897
msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~regex."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"Si vous voulez une recherche n'importe où dans *string*, utilisez plutôt :"
"meth:`~regex.search` (voir aussi :ref:`search-vs-match`)."

#: ../Doc/library/re.rst:903
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"Si la chaîne *string* entière valide l'expression rationnelle, renvoie l':"
"ref:`object de correspondance <match-objects>` associé.  Renvoie ``None`` si "
"la chaîne ne correspond pas au motif ; notez que cela est différent d'une "
"correspondance vide."

#: ../Doc/library/re.rst:921
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr "Identique à la fonction :func:`split`, en utilisant le motif compilé."

#: ../Doc/library/re.rst:926
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`match`."
msgstr ""
"Similaire à la fonction :func:`findall`, en utilisant le motif compilé, mais "
"accepte aussi des paramètres *pos* et *endpos* optionnels qui limitent la "
"région de recherche comme pour :meth:`match`."

#: ../Doc/library/re.rst:933
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`match`."
msgstr ""
"Similaire à la fonction :func:`finditer`, en utilisant le motif compilé, "
"mais accepte aussi des paramètres *pos* et *endpos* optionnels qui limitent "
"la région de recherche comme pour :meth:`match`."

#: ../Doc/library/re.rst:940
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr "Identique à la fonction :func:`sub`, en utilisant le motif compilé."

#: ../Doc/library/re.rst:945
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr "Identique à la fonction :func:`subn`, en utilisant le motif compilé."

#: ../Doc/library/re.rst:950
msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile`, any ``(?...)`` inline flags in the pattern, and implicit flags "
"such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""
"Les options de validation de l'expression rationnelle.  Il s'agit d'une "
"combinaison des options données à :func:`compile`, des potentielles options "
"``(?...)`` dans le motif, et des options implicites comme :data:`UNICODE` si "
"le motif est une chaîne Unicode."

#: ../Doc/library/re.rst:957
msgid "The number of capturing groups in the pattern."
msgstr "Le nombre de groupes capturants dans le motif."

#: ../Doc/library/re.rst:962
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"Un dictionnaire associant les noms de groupes symboliques définis par ``(?"
"P<id>)`` aux groupes numérotés.  Le dictionnaire est vide si aucun groupe "
"symbolique n'est utilisé dans le motif."

#: ../Doc/library/re.rst:969
msgid "The pattern string from which the RE object was compiled."
msgstr ""
"La chaîne de motif depuis laquelle l'objet expression rationnelle a été "
"compilé."

#: ../Doc/library/re.rst:975
msgid "Match Objects"
msgstr "Objets de correspondance"

#: ../Doc/library/re.rst:977
msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~regex."
"match` and :meth:`~regex.search` return ``None`` when there is no match, you "
"can test whether there was a match with a simple ``if`` statement::"
msgstr ""
"Les objets de correspondance ont toujours une valeur booléenne ``True``. "
"Puisque :meth:`~regex.match` et :meth:`~regex.search` renvoient ``None`` "
"quand il n'y a pas de correspondance, vous pouvez tester s'il y a eu "
"correspondance avec une simple instruction ``if`` : ::"

#: ../Doc/library/re.rst:986
msgid "Match objects support the following methods and attributes:"
msgstr ""
"Les objets de correspondance supportent les méthodes et attributs suivants :"

#: ../Doc/library/re.rst:991
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~regex.sub` method. Escapes such as "
"``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, ``"
"\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""
"Renvoie la chaîne obtenue en substituant les séquences d'échappement du "
"gabarit *template*, comme réalisé par la méthode :meth:`~regex.sub`. Les "
"séquences comme ``\\n`` sont converties vers les caractères appropriés, et "
"les références arrières numériques (``\\1``, ``\\2``) et nommées (``"
"\\g<1>``, ``\\g<name>``) sont remplacées par les contenus des groupes "
"correspondant."

#: ../Doc/library/re.rst:1003
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned."
msgstr ""
"Renvoie un ou plus sous-groupes de la correspondance.  Si un seul argument "
"est donné, le résultat est une chaîne simple ; s'il y a plusieurs arguments, "
"le résultat est un *tuple* comprenant un élément par argument. Sans "
"arguments, *group1* vaut par défaut zéro (la correspondance entière est "
"renvoyée). Si un argument *groupN* vaut zéro, l'élément associé sera la "
"chaîne de correspondance entière ; s'il est dans l'intervalle fermé [1..99], "
"c'est la correspondance avec le groupe de parenthèses associé.  Si un numéro "
"de groupe est négatif ou supérieur au nombre de groupes définis dans le "
"motif, une exception :exc:`indexError` est levée. Si un groupe est contenu "
"dans une partie du motif qui n'a aucune correspondance, l'élément associé "
"sera ``None``. Si un groupe est contenu dans une partie du motif qui a "
"plusieurs correspondances, seule la dernière correspondance est renvoyée."

#: ../Doc/library/re.rst:1025
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""
"Si l'expression rationnelle utilise la syntaxe ``(?P<name>...)``, les "
"arguments *groupN* peuvent alors aussi être des chaînes identifiant les "
"groupes par leurs noms.  Si une chaîne donnée en argument n'est pas utilisée "
"comme nom de groupe dans le motif, une exception :exc:`IndexError` est levée."

#: ../Doc/library/re.rst:1030
msgid "A moderately complicated example:"
msgstr "Un exemple modérément compliqué :"

#: ../Doc/library/re.rst:1038
msgid "Named groups can also be referred to by their index:"
msgstr "Les groupes nommés peuvent aussi être référencés par leur index :"

#: ../Doc/library/re.rst:1045
msgid "If a group matches multiple times, only the last match is accessible:"
msgstr ""
"Si un groupe a plusieurs correspondances, seule la dernière est accessible :"

#: ../Doc/library/re.rst:1054
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match:"
msgstr ""
"Cela est identique à ``m.group(g)``.  Cela permet un accès plus facile à un "
"groupe individuel depuis une correspondance :"

#: ../Doc/library/re.rst:1070
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"Renvoie un *tuple* contenant tous les sous-groupes de la correspondance, de "
"1 jusqu'au nombre de groupes dans le motif.  L'argument *default* est "
"utilisé pour les groupes sans correspondance ; il vaut ``None`` par défaut."

#: ../Doc/library/re.rst:1074
msgid "For example:"
msgstr "Par exemple : ::"

#: ../Doc/library/re.rst:1080
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given:"
msgstr ""
"Si on rend la partie décimale et tout ce qui la suit optionnels, tous les "
"groupes ne figureront pas dans la correspondance.  Ces groupes sans "
"correspondance vaudront ``None`` sauf si une autre valeur est donnée à "
"l'argument *default* :"

#: ../Doc/library/re.rst:1093
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example:"
msgstr ""
"Renvoie un dictionnaire contenant tous les sous-groupes *nommés* de la "
"correspondance, accessibles par leurs noms.  L'argument *default* est "
"utilisé pour les groupes qui ne figurent pas dans la correspondance ; il "
"vaut ``None`` par défaut.  Par exemple :"

#: ../Doc/library/re.rst:1105
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"Renvoie les indices de début et de fin de la sous-chaîne correspondant au "
"groupe *group* ; *group* vaut par défaut zéro (pour récupérer les indices de "
"la correspondance complète). Renvoie ``-1`` si *group* existe mais ne figure "
"pas dans la correspondance.  Pour un objet de correspondance *m*, et un "
"groupe *g* qui y figure, la sous-chaîne correspondant au groupe *g* "
"(équivalente à ``m.group(g)``) est : ::"

#: ../Doc/library/re.rst:1113
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"Notez que ``m.start(group)`` sera égal à ``m.end(group)`` si *group* "
"correspond à une chaîne vide.  Par exemple, après ``m = re.search('b(c?)', "
"'cba')``, ``m.start(0)`` vaut 1, ``m.end(0)`` vaut 2, ``m.start(1)`` et ``m."
"end(1)`` valent tous deux 2, et ``m.start(2)`` lève une exception :exc:"
"`IndexError`."

#: ../Doc/library/re.rst:1118
msgid "An example that will remove *remove_this* from email addresses:"
msgstr "Un exemple qui supprimera *remove_this* d'une adresse email :"

#: ../Doc/library/re.rst:1128
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"Pour un objet de correspondance *m*, renvoie le *tuple* ``(m.start(group), m."
"end(group))``. Notez que si *group* ne figure pas dans la correspondance, "
"``(-1, -1)`` est renvoyé. *group* vaut par défaut zéro, pour la "
"correspondance entière."

#: ../Doc/library/re.rst:1135
msgid ""
"The value of *pos* which was passed to the :meth:`~regex.search` or :meth:"
"`~regex.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""
"La valeur de *pos* qui a été passée à la méthode :meth:`~regex.search` ou :"
"meth:`~regex.match` d'un :ref:`objet expression rationnelle <re-objects>`.  "
"C'est l'index dans la chaîne à partir duquel le moteur d'expressions "
"rationnelles recherche une correspondance."

#: ../Doc/library/re.rst:1142
msgid ""
"The value of *endpos* which was passed to the :meth:`~regex.search` or :meth:"
"`~regex.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string beyond which the RE engine will not go."
msgstr ""
"La valeur de *endpos* qui a été passée à la méthode :meth:`~regex.search` "
"ou :meth:`~regex.match` d'un :ref:`objet expression rationnelle <re-"
"objects>`.  C'est l'index dans la chaîne que le moteur d'expressions "
"rationnelles ne dépassera pas."

#: ../Doc/library/re.rst:1149
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""
"L'index entier du dernier groupe de capture validé, ou ``None`` si aucun "
"groupe ne correspondait. Par exemple, les expressions ``(a)b``, ``((a)(b))`` "
"et ``((ab))`` auront un ``lastindex == 1`` si appliquées à la chaîne "
"``'ab'``, alors que l'expression ``(a)(b)`` aura un ``lastindex == 2`` si "
"appliquée à la même chaîne."

#: ../Doc/library/re.rst:1158
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"Le nom du dernier groupe capturant validé, ou ``None`` si le groupe n'a pas "
"de nom, ou si aucun groupe ne correspondait."

#: ../Doc/library/re.rst:1164
msgid ""
"The regular expression object whose :meth:`~regex.match` or :meth:`~regex."
"search` method produced this match instance."
msgstr ""
"L'expression rationnelle dont la méthode :meth:`~regex.match` ou :meth:"
"`~regex.search` a produit cet objet de correspondance."

#: ../Doc/library/re.rst:1170
msgid "The string passed to :meth:`~regex.match` or :meth:`~regex.search`."
msgstr "La chaîne passée à :meth:`~regex.match` ou :meth:`~regex.search`."

#: ../Doc/library/re.rst:1176
msgid "Regular Expression Examples"
msgstr "Exemples d'expressions rationnelles"

#: ../Doc/library/re.rst:1180
msgid "Checking for a Pair"
msgstr "Rechercher une paire"

#: ../Doc/library/re.rst:1182
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully:"
msgstr ""
"Dans cet exemple, nous utiliserons cette fonction de facilité pour afficher "
"les objets de correspondance sous une meilleure forme :"

#: ../Doc/library/re.rst:1192
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"Supposez que vous écriviez un jeu de poker où la main d'un joueur est "
"représentée par une chaîne de 5 caractères avec chaque caractère "
"représentant une carte, \"a\" pour l'as, \"k\" pour le roi (*king*), \"q\" "
"pour la reine (*queen*), \"j\" pour le valet (*jack*), \"t\" pour 10 "
"(*ten*), et les caractères de \"2\" à \"9\" représentant les cartes avec ces "
"valeurs."

#: ../Doc/library/re.rst:1197
msgid "To see if a given string is a valid hand, one could do the following:"
msgstr ""
"Pour vérifier qu'une chaîne donnée est une main valide, on pourrait faire "
"comme suit :"

#: ../Doc/library/re.rst:1207
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such:"
msgstr ""
"La dernière main, ``\"727ak\"``, contenait une paire, deux cartes de la même "
"valeur. Pour valider cela avec une expression rationnelle, on pourrait "
"utiliser des références arrière comme :"

#: ../Doc/library/re.rst:1217
msgid ""
"To find out what card the pair consists of, one could use the :meth:`~match."
"group` method of the match object in the following manner:"
msgstr ""
"Pour trouver de quelle carte est composée la paire, on pourrait utiliser la "
"méthode :meth:`~match.group` de l'objet de correspondance de la manière "
"suivante :"

#: ../Doc/library/re.rst:1237
msgid "Simulating scanf()"
msgstr "Simuler scanf()"

#: ../Doc/library/re.rst:1241
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python n'a actuellement pas d'équivalent à la fonction C :c:func:`scanf`.  "
"Les expressions rationnelles sont généralement plus puissantes, mais aussi "
"plus verbeuses, que les chaînes de format :c:func:`scanf`.  Le tableau "
"suivant présente des expressions rationnelles plus ou moins équivalentes aux "
"éléments de formats de :c:func:`scanf`."

#: ../Doc/library/re.rst:1248
msgid ":c:func:`scanf` Token"
msgstr "Élément de :c:func:`scanf`"

#: ../Doc/library/re.rst:1248
msgid "Regular Expression"
msgstr "Expression rationnelle"

#: ../Doc/library/re.rst:1250
msgid "``%c``"
msgstr "``%c``"

#: ../Doc/library/re.rst:1250
msgid "``.``"
msgstr "``.``"

#: ../Doc/library/re.rst:1252
msgid "``%5c``"
msgstr "``%5c``"

#: ../Doc/library/re.rst:1252
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../Doc/library/re.rst:1254
msgid "``%d``"
msgstr "``%d``"

#: ../Doc/library/re.rst:1254
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../Doc/library/re.rst:1256
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../Doc/library/re.rst:1256
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../Doc/library/re.rst:1258
msgid "``%i``"
msgstr "``%i``"

#: ../Doc/library/re.rst:1258
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../Doc/library/re.rst:1260
msgid "``%o``"
msgstr "``%o``"

#: ../Doc/library/re.rst:1260
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../Doc/library/re.rst:1262
msgid "``%s``"
msgstr "``%s``"

#: ../Doc/library/re.rst:1262
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../Doc/library/re.rst:1264
msgid "``%u``"
msgstr "``%u``"

#: ../Doc/library/re.rst:1264
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../Doc/library/re.rst:1266
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../Doc/library/re.rst:1266
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../Doc/library/re.rst:1269
msgid "To extract the filename and numbers from a string like ::"
msgstr ""
"Pour extraire le nom de fichier et les nombres depuis une chaîne comme : ::"

#: ../Doc/library/re.rst:1273
msgid "you would use a :c:func:`scanf` format like ::"
msgstr "vous utiliseriez un format :c:func:`scanf` comme : ::"

#: ../Doc/library/re.rst:1277
msgid "The equivalent regular expression would be ::"
msgstr "L'expression rationnelle équivalente serait : ::"

#: ../Doc/library/re.rst:1285
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../Doc/library/re.rst:1289
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""
"Python offre deux opérations primitives basées sur les expressions "
"rationnelles : :func:`re.match` cherche une correspondance uniquement au "
"début de la chaîne, tandis que :func:`re.search` en recherche une n'importe "
"où dans la chaîne (ce que fait Perl par défaut)."

#: ../Doc/library/re.rst:1294
msgid "For example::"
msgstr "Par exemple : ::"

#: ../Doc/library/re.rst:1300
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""
"Les expressions rationnelles commençant par ``'^'`` peuvent être utilisées "
"avec :func:`search` pour restreindre la recherche au début de la chaîne : ::"

#: ../Doc/library/re.rst:1308
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each line."
msgstr ""
"Notez cependant qu'en mode :const:`MULTILINE`, :func:`match` ne recherche "
"qu'au début de la chaîne, alors que :func:`search` avec une expression "
"rationnelle commençant par ``'^'`` recherchera au début de chaque ligne."

#: ../Doc/library/re.rst:1318
msgid "Making a Phonebook"
msgstr "Construire un répertoire téléphonique"

#: ../Doc/library/re.rst:1320
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` découpe une chaîne en une liste délimitée par le motif donné.  "
"La méthode est inestimable pour convertir des données textuelles vers des "
"structures de données qui peuvent être lues et modifiées par Python comme "
"démontré dans l'exemple suivant qui crée un répertoire téléphonique."

#: ../Doc/library/re.rst:1325
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax:"
msgstr ""
"Premièrement, voici l'entrée.  Elle provient normalement d'un fichier, nous "
"utilisons ici une chaîne à guillemets triples :"

#: ../Doc/library/re.rst:1336
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""
"Les entrées sont séparées par un saut de ligne ou plus. Nous convertissons "
"maintenant la chaîne en une liste où chaque ligne non vide aura sa propre "
"entrée :"

#: ../Doc/library/re.rst:1349
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"Finalement, on sépare chaque entrée en une liste avec prénom, nom, numéro de "
"téléphone et adresse.  Nous utilisons le paramètre ``maxsplit`` de :func:"
"`split` parce que l'adresse contient des espaces, qui sont notre motif de "
"séparation :"

#: ../Doc/library/re.rst:1362
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"Le motif ``:?`` trouve les deux points derrière le nom de famille, pour "
"qu'ils n'apparaissent pas dans la liste résultante.  Avec un ``maxsplit`` de "
"``4``, nous pourrions séparer le numéro du nom de la rue."

#: ../Doc/library/re.rst:1377
msgid "Text Munging"
msgstr "Mélanger les lettres des mots"

#: ../Doc/library/re.rst:1379
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` remplace toutes les occurrences d'un motif par une chaîne ou le "
"résultat d'une fonction.  Cet exemple le montre, en utilisant :func:`sub` "
"avec une fonction qui mélange aléatoirement les caractères de chaque mot "
"dans une phrase (à l'exception des premiers et derniers caractères) : ::"

#: ../Doc/library/re.rst:1396
msgid "Finding all Adverbs"
msgstr "Trouver tous les adverbes"

#: ../Doc/library/re.rst:1398
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if one was a writer and wanted to "
"find all of the adverbs in some text, he or she might use :func:`findall` in "
"the following manner:"
msgstr ""
":func:`findall` trouve *toutes* les occurrences d'un motif, pas juste la "
"première comme le fait :func:`search`.  Par exemple, si un(e) écrivain(e) "
"voulait trouver tous les adverbes dans un texte, il/elle devrait utiliser :"
"func:`findall` de la manière suivante :"

#: ../Doc/library/re.rst:1409
msgid "Finding all Adverbs and their Positions"
msgstr "Trouver tous les adverbes et leurs positions"

#: ../Doc/library/re.rst:1411
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if one was a writer who wanted to find all of the adverbs *and their "
"positions* in some text, he or she would use :func:`finditer` in the "
"following manner:"
msgstr ""
"Pour obtenir plus d'informations sur les correspondances que juste le texte "
"trouvé, :func:`finditer` est utile en fournissant des :ref:`objets de "
"correspondance <match-objects>` plutôt que des chaînes.  En continuant avec "
"le précédent exemple, si l'écrivain(e) voulait trouver tous les adverbes *et "
"leurs positions* dans un texte, il/elle utiliserait :func:`finditer` de la "
"manière suivante :"

#: ../Doc/library/re.rst:1425
msgid "Raw String Notation"
msgstr "Notation brutes de chaînes"

#: ../Doc/library/re.rst:1427
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical:"
msgstr ""
"La notation brute de chaînes (``r\"text\"``) garde saines les expressions "
"rationnelles.  Sans elle, chaque *backslash* (``'\\'``) dans une expression "
"rationnelle devrait être préfixé d'un autre *backslash* pour l'échapper.  "
"Par exemple, les deux lignes de code suivantes sont fonctionnellement "
"identiques :"

#: ../Doc/library/re.rst:1437
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical:"
msgstr ""
"Pour rechercher un *backslash* littéral, il faut l'échapper dans "
"l'expression rationnelle.  Avec la notation brute, cela signifie ``r\"\\\\"
"\"``.  Sans elle, il faudrait utiliser ``\"\\\\\\\\\"``, faisant que les "
"deux lignes de code suivantes sont fonctionnellement identiques :"

#: ../Doc/library/re.rst:1449
msgid "Writing a Tokenizer"
msgstr "Écrire un analyseur lexical"

#: ../Doc/library/re.rst:1451
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"Un `analyseur lexical ou scanner <https://en.wikipedia.org/wiki/"
"Lexical_analysis>`_ analyse une chaîne pour catégoriser les groupes de "
"caractères.  C'est une première étape utile dans l'écriture d'un compilateur "
"ou d'un interpréteur."

#: ../Doc/library/re.rst:1455
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr ""
"Les catégories de texte sont spécifiées par des expressions rationnelles.  "
"La technique est de les combiner dans une unique expression rationnelle "
"maîtresse, et de boucler sur les correspondances successives : ::"

#: ../Doc/library/re.rst:1505
msgid "The tokenizer produces the following output::"
msgstr "L'analyseur produit la sortie suivante : ::"

#~ msgid ""
#~ "Perform case-insensitive matching; expressions like ``[A-Z]`` will match "
#~ "lowercase letters, too.  This is not affected by the current locale and "
#~ "works for Unicode characters as expected."
#~ msgstr ""
#~ "Réalise une analyse insensible à la classe ; les expressions comme ``[A-"
#~ "Z]`` valideront aussi les lettres minuscules.  Cela n'est pas affecté par "
#~ "la locale courante et fonctionne comme convenu avec les caractères "
#~ "Unicode."

#, fuzzy
#~ msgid "'.'"
#~ msgstr "``'.'``"

#, fuzzy
#~ msgid "'^'"
#~ msgstr "``'^'``"

#, fuzzy
#~ msgid "'$'"
#~ msgstr "``'$'``"

#, fuzzy
#~ msgid "'*'"
#~ msgstr "``'*'``"

#, fuzzy
#~ msgid "'+'"
#~ msgstr "``'+'``"

#, fuzzy
#~ msgid "'?'"
#~ msgstr "``'?'``"

#, fuzzy
#~ msgid "{m}"
#~ msgstr "``{m}``"

#, fuzzy
#~ msgid "'\\'"
#~ msgstr "``'\\'``"

#, fuzzy
#~ msgid "'|'"
#~ msgstr "``'|'``"
