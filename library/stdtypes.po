# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-04 10:00+0100\n"
"PO-Revision-Date: 2019-12-11 11:18+0100\n"
"Last-Translator: Jules Lasne <jules.lasne@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.1\n"

#: ../Doc/library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Types natifs"

#: ../Doc/library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"Les sections suivantes décrivent les types standards intégrés à "
"l'interpréteur."

#: ../Doc/library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"Les principaux types natifs sont les numériques, les séquences, les "
"dictionnaires, les classes, les instances et les exceptions."

#: ../Doc/library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Certaines classes de collection sont muables. Les méthodes qui ajoutent, "
"retirent, ou réorganisent leurs éléments sur place, et qui ne renvoient pas "
"un élément spécifique, ne renvoient jamais l'instance de la collection elle-"
"même, mais ``None``."

#: ../Doc/library/stdtypes.rst:22
#, fuzzy
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"Certaines opérations sont prises en charge par plusieurs types d'objets ; en "
"particulier, pratiquement tous les objets peuvent être comparés, testés "
"(valeur booléenne), et convertis en une chaîne (avec la fonction :func:"
"`repr` ou la fonction légèrement différente :func:`str`). Cette dernière est "
"implicitement utilisée quand un objet est écrit par la fonction :func:"
"`print`."

#: ../Doc/library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Valeurs booléennes"

#: ../Doc/library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Tout objet peut être comparé à une valeur booléenne, typiquement dans une "
"condition :keyword:`if` ou :keyword:`while` ou comme opérande des opérations "
"booléennes ci-dessous."

#: ../Doc/library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the "
"built-in objects considered false:"
msgstr ""
"Par défaut, tout objet est considéré vrai à moins que sa classe définisse "
"soit une méthode :meth:`__bool__` renvoyant ``False`` soit une méthode :meth:"
"`__len__` renvoyant zéro lorsqu'elle est appelée avec l'objet. [1]_ Voici la "
"majorité des objets natifs considérés comme étant faux :"

#: ../Doc/library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``."
msgstr "les constantes définies comme étant fausses : ``None`` et ``False``."

#: ../Doc/library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"zéro de tout type numérique : ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"

#: ../Doc/library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"les chaînes et collections vides : ``''``, ``()``, ``[]``, ``{}``, "
"``set()``, ``range(0)``"

#: ../Doc/library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Les opérations et fonctions natives dont le résultat est booléen donnent "
"toujours ``0`` ou ``False`` pour faux et ``1`` ou ``True`` pour vrai, sauf "
"indication contraire. (Exception importante : les opérations booléennes "
"``or`` et ``and`` renvoient toujours l'une de leurs opérandes.)"

#: ../Doc/library/stdtypes.rst:78
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr ""
"Opérations booléennes --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: ../Doc/library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Ce sont les opérations booléennes, classées par priorité ascendante :"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:143
#: ../Doc/library/stdtypes.rst:272 ../Doc/library/stdtypes.rst:361
#: ../Doc/library/stdtypes.rst:411 ../Doc/library/stdtypes.rst:861
#: ../Doc/library/stdtypes.rst:1056
msgid "Operation"
msgstr "Opération"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:272
#: ../Doc/library/stdtypes.rst:361 ../Doc/library/stdtypes.rst:411
#: ../Doc/library/stdtypes.rst:861 ../Doc/library/stdtypes.rst:1056
msgid "Result"
msgstr "Résultat"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:272
#: ../Doc/library/stdtypes.rst:411 ../Doc/library/stdtypes.rst:861
#: ../Doc/library/stdtypes.rst:1056 ../Doc/library/stdtypes.rst:2226
#: ../Doc/library/stdtypes.rst:3376
msgid "Notes"
msgstr "Notes"

#: ../Doc/library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: ../Doc/library/stdtypes.rst:87
msgid "if *x* is false, then *y*, else *x*"
msgstr "si *x* est faux, alors *y*, sinon *x*"

#: ../Doc/library/stdtypes.rst:87 ../Doc/library/stdtypes.rst:282
#: ../Doc/library/stdtypes.rst:863 ../Doc/library/stdtypes.rst:866
#: ../Doc/library/stdtypes.rst:1067 ../Doc/library/stdtypes.rst:2232
#: ../Doc/library/stdtypes.rst:3382
msgid "\\(1)"
msgstr "\\(1)"

#: ../Doc/library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: ../Doc/library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "si *x* est faux, alors *x*, sinon *y*"

#: ../Doc/library/stdtypes.rst:90 ../Doc/library/stdtypes.rst:285
#: ../Doc/library/stdtypes.rst:305 ../Doc/library/stdtypes.rst:1095
#: ../Doc/library/stdtypes.rst:2236 ../Doc/library/stdtypes.rst:2238
#: ../Doc/library/stdtypes.rst:3386 ../Doc/library/stdtypes.rst:3388
msgid "\\(2)"
msgstr "\\(2)"

#: ../Doc/library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: ../Doc/library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "si *x* est faux, alors ``True``, sinon ``False``"

#: ../Doc/library/stdtypes.rst:93 ../Doc/library/stdtypes.rst:875
#: ../Doc/library/stdtypes.rst:1098 ../Doc/library/stdtypes.rst:2240
#: ../Doc/library/stdtypes.rst:2242 ../Doc/library/stdtypes.rst:2244
#: ../Doc/library/stdtypes.rst:2246 ../Doc/library/stdtypes.rst:3390
#: ../Doc/library/stdtypes.rst:3392 ../Doc/library/stdtypes.rst:3394
#: ../Doc/library/stdtypes.rst:3396
msgid "\\(3)"
msgstr "\\(3)"

#: ../Doc/library/stdtypes.rst:102 ../Doc/library/stdtypes.rst:316
#: ../Doc/library/stdtypes.rst:429 ../Doc/library/stdtypes.rst:902
#: ../Doc/library/stdtypes.rst:1106 ../Doc/library/stdtypes.rst:2272
#: ../Doc/library/stdtypes.rst:3426
msgid "Notes:"
msgstr "Notes :"

#: ../Doc/library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Ceci est un opérateur court-circuit : il n'évalue le deuxième argument que "
"si le premier est faux."

#: ../Doc/library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Ceci est un opérateur court-circuit, il n'évalue le deuxième argument si le "
"premier est vrai."

#: ../Doc/library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` a une priorité inférieure à celle des opérateurs non-booléens, donc "
"``not a == b`` est interprété comme ``not (a == b)`` et ``a == not b`` est "
"une erreur de syntaxe."

#: ../Doc/library/stdtypes.rst:120
msgid "Comparisons"
msgstr "Comparaisons"

#: ../Doc/library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Il y a huit opérations de comparaison en Python. Elles ont toutes la même "
"priorité (qui est supérieure à celle des opérations booléennes). Les "
"comparaisons peuvent être enchaînées arbitrairement ; par exemple, ``x < y "
"<= z`` est équivalent à ``x < y and y <= z``, sauf que *y* n'est évalué "
"qu'une seule fois (mais dans les deux cas *z* n'est pas évalué du tout quand "
"``x < y`` est faux)."

#: ../Doc/library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "Ce tableau résume les opérations de comparaison :"

#: ../Doc/library/stdtypes.rst:143 ../Doc/library/stdtypes.rst:2203
#: ../Doc/library/stdtypes.rst:2226 ../Doc/library/stdtypes.rst:3353
#: ../Doc/library/stdtypes.rst:3376
msgid "Meaning"
msgstr "Signification"

#: ../Doc/library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../Doc/library/stdtypes.rst:145
msgid "strictly less than"
msgstr "strictement inférieur"

#: ../Doc/library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../Doc/library/stdtypes.rst:147
msgid "less than or equal"
msgstr "inférieur ou égal"

#: ../Doc/library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../Doc/library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "strictement supérieur"

#: ../Doc/library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../Doc/library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "supérieur ou égal"

#: ../Doc/library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../Doc/library/stdtypes.rst:153
msgid "equal"
msgstr "égal"

#: ../Doc/library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../Doc/library/stdtypes.rst:155
msgid "not equal"
msgstr "différent"

#: ../Doc/library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: ../Doc/library/stdtypes.rst:157
msgid "object identity"
msgstr "identité d'objet"

#: ../Doc/library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: ../Doc/library/stdtypes.rst:159
msgid "negated object identity"
msgstr "contraire de l'identité d'objet"

#: ../Doc/library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""

#: ../Doc/library/stdtypes.rst:180
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`__eq__` method."
msgstr ""
"Des instances différentes d'une classe sont normalement considérées "
"différentes à moins que la classe ne définisse la méthode :meth:`__eq__`."

#: ../Doc/library/stdtypes.rst:183
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, and :meth:"
"`__ge__` (in general, :meth:`__lt__` and :meth:`__eq__` are sufficient, if "
"you want the conventional meanings of the comparison operators)."
msgstr ""
"Les instances d'une classe ne peuvent pas être ordonnées par rapport à "
"d'autres instances de la même classe, ou d'autres types d'objets, à moins "
"que la classe ne définisse suffisamment de méthodes parmi :meth:`__lt__`, :"
"meth:`__le__`, :meth:`__gt__` et :meth:`__ge__` (en général, :meth:`__lt__` "
"et :meth:`__eq__` sont suffisantes, si vous voulez les significations "
"classiques des opérateurs de comparaison)."

#: ../Doc/library/stdtypes.rst:189
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"Le comportement des opérateurs :keyword:`is` et :keyword:`is not` ne peut "
"pas être personnalisé ; aussi ils peuvent être appliqués à deux objets "
"quelconques et ne lèvent jamais d'exception."

#: ../Doc/library/stdtypes.rst:197
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`__contains__` method."
msgstr ""
"Deux autres opérations avec la même priorité syntaxique, :keyword:`in` et :"
"keyword:`not in`, sont pris en charge par les types :term:`itérables "
"<iterable>` ou qui implémentent la méthode :meth:`__contains__`."

#: ../Doc/library/stdtypes.rst:204
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Types numériques — :class:`int`, :class:`float`, :class:`complex`"

#: ../Doc/library/stdtypes.rst:214
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:type:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"Il existe trois types numériques distincts: :dfn:`integers` (entiers), :dfn:"
"`floating point numbers` (nombres flottants) et :dfn:`complex numbers` "
"(nombres complexes). En outre, les booléens sont un sous-type des entiers. "
"Les entiers ont une précision illimitée. Les nombres à virgule flottante "
"sont généralement implémentés en utilisant des :c:type:`double` en C ; des "
"informations sur la précision et la représentation interne des nombres à "
"virgule flottante pour la machine sur laquelle le programme est en cours "
"d'exécution est disponible dans :data:`sys.float_info`. Les nombres "
"complexes ont une partie réelle et une partie imaginaire, qui sont chacune "
"des nombres à virgule flottante. Pour extraire ces parties d'un nombre "
"complexe *z*, utilisez ``z.real`` et ``z.imag``. (La bibliothèque standard "
"comprend les types numériques additionnels :mod:`fractions.Fraction` pour "
"les rationnels et :mod:`decimal.Decimal` pour les nombres à virgule "
"flottante avec une précision définissable par l'utilisateur.)"

#: ../Doc/library/stdtypes.rst:236
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"Les nombres sont créés par des littéraux numériques ou sont le résultat de "
"fonctions natives ou d'opérateurs. Les entiers littéraux basiques (y compris "
"leur forme hexadécimale, octale et binaire) donnent des entiers. Les nombres "
"littéraux contenant un point décimal ou un exposant donnent des nombres à "
"virgule flottante. Suffixer ``'j'`` ou ``'J'`` à un nombre littéral donne un "
"nombre imaginaire (un nombre complexe avec une partie réelle nulle) que vous "
"pouvez ajouter à un nombre entier ou un à virgule flottante pour obtenir un "
"nombre complexe avec une partie réelle et une partie imaginaire."

#: ../Doc/library/stdtypes.rst:261
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex.  Comparisons between numbers "
"of mixed type use the same rule. [2]_ The constructors :func:`int`, :func:"
"`float`, and :func:`complex` can be used to produce numbers of a specific "
"type."
msgstr ""
"Python gère pleinement l'arithmétique mixte : quand un opérateur "
"arithmétique binaire a des opérandes de types numériques différents, "
"l'opérande avec le type \"le plus étroit\" est élargie au type de l'autre, "
"où l'entier est plus étroit que la virgule flottante, qui est plus étroite "
"que les complexes. Les comparaisons entre des nombres de type mixte "
"utilisent la même règle. [2]_ Les constructeurs :func:`int`, :func:`float` "
"et :func:`complex` peuvent être utilisé pour produire des nombres d'un type "
"spécifique."

#: ../Doc/library/stdtypes.rst:268
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Tous les types numériques (sauf complexe) gèrent les opérations suivantes "
"(pour les priorités des opérations, voir :ref:`operator-summary`) :"

#: ../Doc/library/stdtypes.rst:272
msgid "Full documentation"
msgstr "Documentation complète"

#: ../Doc/library/stdtypes.rst:274
msgid "``x + y``"
msgstr "``x + y``"

#: ../Doc/library/stdtypes.rst:274
msgid "sum of *x* and *y*"
msgstr "somme de *x* et *y*"

#: ../Doc/library/stdtypes.rst:276
msgid "``x - y``"
msgstr "``x - y``"

#: ../Doc/library/stdtypes.rst:276
msgid "difference of *x* and *y*"
msgstr "différence de *x* et *y*"

#: ../Doc/library/stdtypes.rst:278
msgid "``x * y``"
msgstr "``x * y``"

#: ../Doc/library/stdtypes.rst:278
msgid "product of *x* and *y*"
msgstr "produit de *x* et *y*"

#: ../Doc/library/stdtypes.rst:280
msgid "``x / y``"
msgstr "``x / y``"

#: ../Doc/library/stdtypes.rst:280
msgid "quotient of *x* and *y*"
msgstr "quotient de *x* et *y*"

#: ../Doc/library/stdtypes.rst:282
msgid "``x // y``"
msgstr "``x // y``"

#: ../Doc/library/stdtypes.rst:282
msgid "floored quotient of *x* and *y*"
msgstr "quotient entier de *x* et *y*"

#: ../Doc/library/stdtypes.rst:285
msgid "``x % y``"
msgstr "``x % y``"

#: ../Doc/library/stdtypes.rst:285
msgid "remainder of ``x / y``"
msgstr "reste de ``x / y``"

#: ../Doc/library/stdtypes.rst:287
msgid "``-x``"
msgstr "``-x``"

#: ../Doc/library/stdtypes.rst:287
msgid "*x* negated"
msgstr "négatif de *x*"

#: ../Doc/library/stdtypes.rst:289
msgid "``+x``"
msgstr "``+x``"

#: ../Doc/library/stdtypes.rst:289
msgid "*x* unchanged"
msgstr "*x* inchangé"

#: ../Doc/library/stdtypes.rst:291
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../Doc/library/stdtypes.rst:291
msgid "absolute value or magnitude of *x*"
msgstr "valeur absolue de *x*"

#: ../Doc/library/stdtypes.rst:291
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../Doc/library/stdtypes.rst:294
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../Doc/library/stdtypes.rst:294
msgid "*x* converted to integer"
msgstr "*x* converti en nombre entier"

#: ../Doc/library/stdtypes.rst:294
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../Doc/library/stdtypes.rst:294
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../Doc/library/stdtypes.rst:296
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../Doc/library/stdtypes.rst:296
msgid "*x* converted to floating point"
msgstr "*x* converti en nombre à virgule flottante"

#: ../Doc/library/stdtypes.rst:296
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../Doc/library/stdtypes.rst:296
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../Doc/library/stdtypes.rst:298
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../Doc/library/stdtypes.rst:298
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"un nombre complexe avec *re* pour partie réelle et *im* pour partie "
"imaginaire. *im* vaut zéro par défaut."

#: ../Doc/library/stdtypes.rst:298 ../Doc/library/stdtypes.rst:1088
#: ../Doc/library/stdtypes.rst:2234 ../Doc/library/stdtypes.rst:3413
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/library/stdtypes.rst:298
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../Doc/library/stdtypes.rst:302
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../Doc/library/stdtypes.rst:302
msgid "conjugate of the complex number *c*"
msgstr "conjugué du nombre complexe *c*"

#: ../Doc/library/stdtypes.rst:305
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../Doc/library/stdtypes.rst:305
msgid "the pair ``(x // y, x % y)``"
msgstr "la paire ``(x // y, x % y)``"

#: ../Doc/library/stdtypes.rst:305
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../Doc/library/stdtypes.rst:307
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../Doc/library/stdtypes.rst:307 ../Doc/library/stdtypes.rst:309
msgid "*x* to the power *y*"
msgstr "*x* à la puissance *y*"

#: ../Doc/library/stdtypes.rst:307 ../Doc/library/stdtypes.rst:309
#: ../Doc/library/stdtypes.rst:1077 ../Doc/library/stdtypes.rst:1080
#: ../Doc/library/stdtypes.rst:2259 ../Doc/library/stdtypes.rst:2262
#: ../Doc/library/stdtypes.rst:2265 ../Doc/library/stdtypes.rst:3409
#: ../Doc/library/stdtypes.rst:3416
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/library/stdtypes.rst:307
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../Doc/library/stdtypes.rst:309
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../Doc/library/stdtypes.rst:319
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"Également appelé division entière. La valeur résultante est un nombre "
"entier, bien que le type du résultat ne soit pas nécessairement *int*. Le "
"résultat est toujours arrondi vers moins l'infini : ``1//2`` vaut ``0``, "
"``(-1)//2`` vaut ``-1``, ``1//(-2)`` vaut ``-1``, et ``(-1)//(-2)`` vaut "
"``0``."

#: ../Doc/library/stdtypes.rst:325
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Pas pour les nombres complexes. Convertissez-les plutôt en nombres flottants "
"à l'aide de :func:`abs` si c'est approprié."

#: ../Doc/library/stdtypes.rst:337
msgid ""
"Conversion from floating point to integer may round or truncate as in C; see "
"functions :func:`math.floor` and :func:`math.ceil` for well-defined "
"conversions."
msgstr ""
"La conversion de virgule flottante en entier peut arrondir ou tronquer comme "
"en C ; voir les fonctions :func:`math.floor` et :func:`math.ceil` pour des "
"conversions bien définies."

#: ../Doc/library/stdtypes.rst:342
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"*float* accepte aussi les chaînes *nan* et *inf* avec un préfixe optionnel ``"
"+`` ou ``-`` pour *Not a Number* (*NaN*) et les infinis positif ou négatif."

#: ../Doc/library/stdtypes.rst:346
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python définit ``pow(0, 0)`` et ``0 ** 0`` valant ``1``, puisque c'est "
"courant pour les langages de programmation, et logique."

#: ../Doc/library/stdtypes.rst:350
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"Les littéraux numériques acceptés comprennent les chiffres ``0`` à ``9`` ou "
"tout équivalent Unicode (caractères avec la propriété ``Nd``)."

#: ../Doc/library/stdtypes.rst:353
#, fuzzy
msgid ""
"See http://www.unicode.org/Public/12.1.0/ucd/extracted/DerivedNumericType."
"txt for a complete list of code points with the ``Nd`` property."
msgstr ""
"Voir http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType."
"txt pour une liste complète des caractères avec la propriété ``Nd``."

#: ../Doc/library/stdtypes.rst:357
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Tous types :class:`numbers.Real` (:class:`int` et :class:`float`) "
"comprennent également les opérations suivantes :"

#: ../Doc/library/stdtypes.rst:363
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../Doc/library/stdtypes.rst:363
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* tronqué à l':class:`~numbers.Integral`"

#: ../Doc/library/stdtypes.rst:366
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../Doc/library/stdtypes.rst:366
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* arrondi à *n* chiffres, arrondissant la moitié au pair. Si *n* est omis, "
"la valeur par défaut à 0."

#: ../Doc/library/stdtypes.rst:370
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../Doc/library/stdtypes.rst:370
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "le plus grand :class:`~numbers.Integral` <= *x*"

#: ../Doc/library/stdtypes.rst:373
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../Doc/library/stdtypes.rst:373
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "le plus petit :class:`~numbers.Integral` >= *x*"

#: ../Doc/library/stdtypes.rst:377
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Pour d'autres opérations numériques voir les modules :mod:`math` et :mod:"
"`cmath`."

#: ../Doc/library/stdtypes.rst:386
msgid "Bitwise Operations on Integer Types"
msgstr "Opérations sur les bits des nombres entiers"

#: ../Doc/library/stdtypes.rst:400
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Les opérations bit à bit n'ont de sens que pour les entiers relatifs. Le "
"résultat d'une opération bit à bit est calculé comme si elle était effectuée "
"en complément à deux avec un nombre infini de bits de signe."

#: ../Doc/library/stdtypes.rst:404
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"Les priorités de toutes les opération à deux opérandes sur des bits sont "
"inférieures aux opérations numériques et plus élevées que les comparaisons ; "
"l'opération unaire ``~`` a la même priorité que les autres opérations "
"numériques unaires (``+`` et ``-``)."

#: ../Doc/library/stdtypes.rst:408
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"Ce tableau répertorie les opérations binaires triées par priorité "
"ascendante :"

#: ../Doc/library/stdtypes.rst:413
msgid "``x | y``"
msgstr "``x | y``"

#: ../Doc/library/stdtypes.rst:413
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr ":dfn:`ou <or>` binaire de *x* et *y*"

#: ../Doc/library/stdtypes.rst:413 ../Doc/library/stdtypes.rst:416
#: ../Doc/library/stdtypes.rst:419 ../Doc/library/stdtypes.rst:1101
#: ../Doc/library/stdtypes.rst:2248 ../Doc/library/stdtypes.rst:2252
#: ../Doc/library/stdtypes.rst:3398 ../Doc/library/stdtypes.rst:3402
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/library/stdtypes.rst:416
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../Doc/library/stdtypes.rst:416
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr ":dfn:`ou <or>` exclusive binaire de *x* et *y*"

#: ../Doc/library/stdtypes.rst:419
msgid "``x & y``"
msgstr "``x & y``"

#: ../Doc/library/stdtypes.rst:419
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr ":dfn:`et binaire <and>` de *x* et *y*"

#: ../Doc/library/stdtypes.rst:422
msgid "``x << n``"
msgstr "``x << n``"

#: ../Doc/library/stdtypes.rst:422
msgid "*x* shifted left by *n* bits"
msgstr "*x* décalé vers la gauche de *n* bits"

#: ../Doc/library/stdtypes.rst:422
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../Doc/library/stdtypes.rst:424
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../Doc/library/stdtypes.rst:424
msgid "*x* shifted right by *n* bits"
msgstr "*x* décalé vers la droite de *n* bits"

#: ../Doc/library/stdtypes.rst:424
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../Doc/library/stdtypes.rst:426
msgid "``~x``"
msgstr "``~x``"

#: ../Doc/library/stdtypes.rst:426
msgid "the bits of *x* inverted"
msgstr "les bits de *x*, inversés"

#: ../Doc/library/stdtypes.rst:432
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""
"Des valeurs de décalage négatives sont illégales et provoquent une "
"exception :exc:`ValueError`."

#: ../Doc/library/stdtypes.rst:435
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)`` "
"without overflow check."
msgstr ""
"Un décalage à gauche de *n* bits est équivalent à la multiplication par "
"``pow(2, n)`` sans vérification de débordement."

#: ../Doc/library/stdtypes.rst:439
msgid ""
"A right shift by *n* bits is equivalent to division by ``pow(2, n)`` without "
"overflow check."
msgstr ""
"Un décalage à droite de *n* les bits est équivalent à la division par "
"``pow(2, n)`` sans vérification de débordement."

#: ../Doc/library/stdtypes.rst:443
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Effectuer ces calculs avec au moins un bit d'extension de signe "
"supplémentaire dans une représentation finie du complément à deux éléments "
"(une largeur de bit fonctionnelle de ``1 + max(x.bit_length(), y."
"bit_length()`` ou plus) est suffisante pour obtenir le même résultat que "
"s'il y avait un nombre infini de bits de signe."

#: ../Doc/library/stdtypes.rst:450
msgid "Additional Methods on Integer Types"
msgstr "Méthodes supplémentaires sur les entiers"

#: ../Doc/library/stdtypes.rst:452
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Le type *int* implémente la :term:`classe de base abstraite <abstract base "
"class>` :class:`numbers.Integral`. Il fournit aussi quelques autres "
"méthodes :"

#: ../Doc/library/stdtypes.rst:457
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Renvoie le nombre de bits nécessaires pour représenter un nombre entier en "
"binaire, à l'exclusion du signe et des zéros non significatifs ::"

#: ../Doc/library/stdtypes.rst:466
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Plus précisément, si ``x`` est différent de zéro, ``x.bit_length()`` est le "
"nombre entier positif unique, ``k`` tel que ``2**(k-1) <= abs(x) < 2**k``. "
"Équivalemment, quand ``abs(x)`` est assez petit pour avoir un logarithme "
"correctement arrondi, ``k = 1 + int(log(abs(x), 2))``. Si ``x`` est nul, "
"alors ``x.bit_length()`` donne ``0``."

#: ../Doc/library/stdtypes.rst:472
msgid "Equivalent to::"
msgstr "Équivalent à ::"

#: ../Doc/library/stdtypes.rst:483
msgid "Return an array of bytes representing an integer."
msgstr "Renvoie un tableau d'octets représentant un nombre entier."

#: ../Doc/library/stdtypes.rst:495
msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError` is "
"raised if the integer is not representable with the given number of bytes."
msgstr ""
"L'entier est représenté par *length* octets. Une exception :exc:"
"`OverflowError` est levée s'il n'est pas possible de représenter l'entier "
"avec le nombre d'octets donnés."

#: ../Doc/library/stdtypes.rst:499 ../Doc/library/stdtypes.rst:531
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at the "
"beginning of the byte array.  If *byteorder* is ``\"little\"``, the most "
"significant byte is at the end of the byte array.  To request the native "
"byte order of the host system, use :data:`sys.byteorder` as the byte order "
"value."
msgstr ""
"L'argument *byteorder* détermine l'ordre des octets utilisé pour représenter "
"le nombre entier. Si *byteorder* est ``\"big\"``, l'octet le plus "
"significatif est au début du tableau d'octets. Si *byteorder* est ``\"little"
"\"``, l'octet le plus significatif est à la fin du tableau d'octets. Pour "
"demander l'ordre natif des octets du système hôte, donnez :data:`sys."
"byteorder` comme *byteorder*."

#: ../Doc/library/stdtypes.rst:506
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"L'argument *signed* détermine si le complément à deux est utilisé pour "
"représenter le nombre entier. Si *signed* est ``False`` et qu'un entier "
"négatif est donné, une exception :exc:`OverflowError` est levée. La valeur "
"par défaut pour *signed* est ``False``."

#: ../Doc/library/stdtypes.rst:515
msgid "Return the integer represented by the given array of bytes."
msgstr "Donne le nombre entier représenté par le tableau d'octets fourni."

#: ../Doc/library/stdtypes.rst:528
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"L'argument *bytes* doit être soit un :term:`bytes-like object` soit un "
"itérable produisant des *bytes*."

#: ../Doc/library/stdtypes.rst:538
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"L'argument *signed* indique si le complément à deux est utilisé pour "
"représenter le nombre entier."

#: ../Doc/library/stdtypes.rst:545
#, fuzzy
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"integer and with a positive denominator. The integer ratio of integers "
"(whole numbers) is always the integer as the numerator and ``1`` as the "
"denominator."
msgstr ""
"Renvoie une paire de nombres entiers dont le rapport est exactement égal au "
"nombre d'origine et avec un dénominateur positif. Lève :exc:`OverflowError` "
"avec un infini et :exc:`ValueError` avec un NaN."

#: ../Doc/library/stdtypes.rst:553
msgid "Additional Methods on Float"
msgstr "Méthodes supplémentaires sur les nombres à virgule flottante"

#: ../Doc/library/stdtypes.rst:555
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"Le type *float* implémente la :term:`classe de base abstraite <abstract base "
"class>` :class:`numbers.Real` et a également les méthodes suivantes."

#: ../Doc/library/stdtypes.rst:560
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""
"Renvoie une paire de nombres entiers dont le rapport est exactement égal au "
"nombre d'origine et avec un dénominateur positif. Lève :exc:`OverflowError` "
"avec un infini et :exc:`ValueError` avec un NaN."

#: ../Doc/library/stdtypes.rst:567
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Donne ``True`` si l'instance de *float* est finie avec une valeur entière, "
"et ``False`` autrement ::"

#: ../Doc/library/stdtypes.rst:575
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Deux méthodes prennent en charge la conversion vers et à partir de chaînes "
"hexadécimales. Étant donné que les *float* de Python sont stockés en interne "
"sous forme de nombres binaires, la conversion d'un *float* depuis ou vers "
"une chaine décimale implique généralement une petite erreur d'arrondi. En "
"revanche, les chaînes hexadécimales permettent de représenter exactement les "
"nombres à virgule flottante. Cela peut être utile lors du débogage, et dans "
"un travail numérique."

#: ../Doc/library/stdtypes.rst:586
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Donne une représentation d'un nombre à virgule flottante sous forme de "
"chaîne hexadécimale. Pour les nombres à virgule flottante finis, cette "
"représentation comprendra toujours un préfixe ``0x``, un suffixe ``p``, et "
"un exposant."

#: ../Doc/library/stdtypes.rst:594
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Méthode de classe pour obtenir le *float* représenté par une chaîne de "
"caractères hexadécimale *s*. La chaîne *s* peut contenir des espaces avant "
"et après le chiffre."

#: ../Doc/library/stdtypes.rst:599
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Notez que :meth:`float.hex` est une méthode d'instance, alors que :meth:"
"`float.fromhex` est une méthode de classe."

#: ../Doc/library/stdtypes.rst:602
msgid "A hexadecimal string takes the form::"
msgstr "Une chaîne hexadécimale prend la forme ::"

#: ../Doc/library/stdtypes.rst:606
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"où ``sign`` peut être soit ``+`` soit ``-``, ``integer`` et ``fraction`` "
"sont des chaînes de chiffres hexadécimales, et ``exponent`` est un entier "
"décimal facultativement signé. La casse n'est pas significative, et il doit "
"y avoir au moins un chiffre hexadécimal soit dans le nombre entier soit dans "
"la fraction. Cette syntaxe est similaire à la syntaxe spécifiée dans la "
"section 6.4.4.2 de la norme C99, et est aussi la syntaxe utilisée à partir "
"de Java 1.5. En particulier, la sortie de :meth:`float.hex` est utilisable "
"comme valeur hexadécimale à virgule flottante littérale en C ou Java, et des "
"chaînes hexadécimales produites en C via un format ``%a`` ou Java via "
"``Double.toHexString`` sont acceptées par :meth:`float.fromhex`."

#: ../Doc/library/stdtypes.rst:619
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Notez que l'exposant est écrit en décimal plutôt qu'en hexadécimal, et qu'il "
"donne la puissance de 2 par lequel multiplier le coefficient. Par exemple, "
"la chaîne hexadécimale ``0x3.a7p10`` représente le nombre à virgule "
"flottante ``(3 + 10./16 + 7./16**2) *2.0**10``, ou ``3740.0`` ::"

#: ../Doc/library/stdtypes.rst:629
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"L'application de la conversion inverse à ``3740.0`` donne une chaîne "
"hexadécimale différente représentant le même nombre ::"

#: ../Doc/library/stdtypes.rst:639
msgid "Hashing of numeric types"
msgstr "Hachage des types numériques"

#: ../Doc/library/stdtypes.rst:641
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`__hash__` "
"method documentation for more details).  For ease of implementation and "
"efficiency across a variety of numeric types (including :class:`int`, :class:"
"`float`, :class:`decimal.Decimal` and :class:`fractions.Fraction`) Python's "
"hash for numeric types is based on a single mathematical function that's "
"defined for any rational number, and hence applies to all instances of :"
"class:`int` and :class:`fractions.Fraction`, and all finite instances of :"
"class:`float` and :class:`decimal.Decimal`.  Essentially, this function is "
"given by reduction modulo ``P`` for a fixed prime ``P``.  The value of ``P`` "
"is made available to Python as the :attr:`modulus` attribute of :data:`sys."
"hash_info`."
msgstr ""
"Pour deux nombres égaux ``x`` et ``y`` (``x == y``), pouvant être de "
"différents types, il est une requis que ``hash(x) == hash(y)`` (voir la "
"documentation de :meth:`__hash__`). Pour faciliter la mise en œuvre et "
"l'efficacité à travers une variété de types numériques (y compris :class:"
"`int`, :class:`float`, :class:`decimal.Decimal` et :class:`fractions."
"Fraction`) le hachage en Python pour les types numérique est basé sur une "
"fonction mathématique unique qui est définie pour tout nombre rationnel, et "
"donc s'applique à toutes les instances de :class:`int` et :class:`fractions."
"Fraction`, et toutes les instances finies de :class:`float` et :class:"
"`decimal.Decimal`. Essentiellement, cette fonction est donnée par la "
"réduction modulo ``P`` pour un nombre ``P`` premier fixe. La valeur de ``P`` "
"est disponible comme attribut :attr:`modulus` de :data:`sys.hash_info`."

#: ../Doc/library/stdtypes.rst:656
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"Actuellement, le premier utilisé est ``P = 2 ** 31 - 1`` sur des machines "
"dont les *longs* en C sont de 32 bits ``P = 2 ** 61 - 1`` sur des machines "
"dont les *longs* en C font 64 bits."

#: ../Doc/library/stdtypes.rst:659
msgid "Here are the rules in detail:"
msgstr "Voici les règles en détail :"

#: ../Doc/library/stdtypes.rst:661
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Si ``x = m / n`` est un nombre rationnel non négatif et ``n`` n'est pas "
"divisible par ``P``, définir ``hash(x)`` comme ``m * invmod(n, P) % P``, où "
"``invmod(n, P)`` donne l'inverse de ``n`` modulo ``P``."

#: ../Doc/library/stdtypes.rst:665
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Si ``x = m / n`` est un nombre rationnel non négatif et ``n`` est divisible "
"par ``P`` (mais ``m`` ne l'est pas), alors ``n`` n'a pas de modulo inverse "
"``P`` et la règle ci-dessus n'est pas applicable ; dans ce cas définir "
"``hash(x)`` comme étant la valeur de la constante ``sys.hash_info.inf``."

#: ../Doc/library/stdtypes.rst:670
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Si ``x = m / n`` est un nombre rationnel négatif définir ``hash(x)`` comme "
"``-hash(-x)``. Si le résultat est ``-1``, le remplacer par ``-2``."

#: ../Doc/library/stdtypes.rst:674
msgid ""
"The particular values ``sys.hash_info.inf``, ``-sys.hash_info.inf`` and "
"``sys.hash_info.nan`` are used as hash values for positive infinity, "
"negative infinity, or nans (respectively).  (All hashable nans have the same "
"hash value.)"
msgstr ""
"Les valeurs particulières ``sys.hash_info.inf``, ``-sys.hash_info.inf`` et "
"``sys.hash_info.nan`` sont utilisées comme valeurs de hachage pour l'infini "
"positif, l'infini négatif, ou *nans* (respectivement). (Tous les *nans* "
"hachables ont la même valeur de hachage.)"

#: ../Doc/library/stdtypes.rst:679
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Pour un nombre :class:`complexe <complex>` ``z``, les valeurs de hachage des "
"parties réelles et imaginaires sont combinées en calculant ``hash(z.real) + "
"sys.hash_info.imag * hash(z.imag)``, réduit au modulo ``2**sys.hash_info."
"width`` de sorte qu'il se trouve dans ``range(-2**(sys.hash_info.width - 1), "
"2**(sys.hash_info.width - 1))``. Encore une fois, si le résultat est ``-1``, "
"il est remplacé par ``-2``."

#: ../Doc/library/stdtypes.rst:687
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Afin de clarifier les règles ci-dessus, voici quelques exemples de code "
"Python, équivalent à la fonction de hachage native, pour calculer le hachage "
"d'un nombre rationnel,  d'un :class:`float`, ou d'un :class:`complex` ::"

#: ../Doc/library/stdtypes.rst:742
msgid "Iterator Types"
msgstr "Les types itérateurs"

#: ../Doc/library/stdtypes.rst:750
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python supporte un concept d'itération sur les conteneurs. C'est implémenté "
"en utilisant deux méthodes distinctes qui permettent aux classes définies "
"par l'utilisateur de devenir itérables. Les séquences, décrites plus bas en "
"détail, supportent toujours les méthodes d'itération."

#: ../Doc/library/stdtypes.rst:755
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr ""
"Une méthode doit être définie afin que les objets conteneurs  supportent "
"l'itération :"

#: ../Doc/library/stdtypes.rst:762
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Donne un objet itérateur. L'objet doit implémenter le protocole d'itération "
"décrit ci-dessous. Si un conteneur prend en charge différents types "
"d'itération, d'autres méthodes peuvent être fournies pour obtenir "
"spécifiquement les itérateurs pour ces types d'itération. (Exemple d'un "
"objet supportant plusieurs formes d'itération : une structure d'arbre "
"pouvant être parcourue en largeur ou en profondeur.) Cette méthode "
"correspond à l'attribut :c:member:`~PyTypeObject.tp_iter` de la structure du "
"type des objets Python dans l'API Python/C."

#: ../Doc/library/stdtypes.rst:771
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Les itérateurs eux-mêmes doivent implémenter les deux méthodes suivantes, "
"qui forment ensemble le :dfn:`protocole d'itérateur <iterator protocol>` :"

#: ../Doc/library/stdtypes.rst:777
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements. This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Donne l'objet itérateur lui-même. Cela est nécessaire pour permettre à la "
"fois à des conteneurs et des itérateurs d'être utilisés avec les "
"instructions :keyword:`for` et :keyword:`in`. Cette méthode correspond à "
"l'attribut :c:member:`~PyTypeObject.tp_iter` de la structure des types des "
"objets Python dans l'API Python/C."

#: ../Doc/library/stdtypes.rst:785
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iternext` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"Donne l'élément suivant du conteneur. S'il n'y a pas d'autres éléments, une "
"exception :exc:`StopIteration` est levée. Cette méthode correspond à "
"l'attribut :c:member:`PyTypeObject.tp_iternext` de la structure du type des "
"objets Python dans l'API Python/C."

#: ../Doc/library/stdtypes.rst:790
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python définit plusieurs objets itérateurs pour itérer sur les types "
"standards ou spécifiques de séquence, de  dictionnaires et d'autres formes "
"plus spécialisées. Les types spécifiques ne sont  pas importants au-delà de "
"leur implémentation du protocole d'itération."

#: ../Doc/library/stdtypes.rst:795
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Dès que la méthode :meth:`~iterator .__next__` lève une  exception :exc:"
"`StopIteration`, elle doit continuer à le faire lors des appels ultérieurs."
"Implémentations qui ne respectent pas cette propriété sont considérées "
"cassées."

#: ../Doc/library/stdtypes.rst:803
msgid "Generator Types"
msgstr "Types générateurs"

#: ../Doc/library/stdtypes.rst:805
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
"Les :term:`generator`\\s offrent un moyen pratique d'implémenter le "
"protocole d'itération. Si la méthode :meth:`__iter__` d'un objet conteneur "
"est implémentée comme un générateur, elle renverra automatiquement un objet "
"*iterator* (techniquement, un objet générateur) fournissant les méthodes :"
"meth:`__iter__`  et :meth:`~generator.__next__`. Plus d'informations sur les "
"générateurs peuvent être trouvés dans :ref:`la documentation de l'expression "
"yield <yieldexpr>`."

#: ../Doc/library/stdtypes.rst:817
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Types séquentiels — :class:`list`, :class:`tuple`, :class:`range`"

#: ../Doc/library/stdtypes.rst:819
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Il existe trois types séquentiels basiques: les *lists*,  *tuples* et les "
"*range*. D'autres types séquentiels  spécifiques au traitement de :ref:"
"`données binaires <binaryseq>` et :ref:`chaînes de caractères <textseq>` "
"sont décrits dans des sections dédiées."

#: ../Doc/library/stdtypes.rst:828
msgid "Common Sequence Operations"
msgstr "Opérations communes sur les séquences"

#: ../Doc/library/stdtypes.rst:832
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Les opérations dans le tableau ci-dessous sont pris en charge par la plupart "
"des types séquentiels, variables et immuables. La classe de base abstraite :"
"class:`collections.abc.Sequence` est fournie pour aider à implémenter "
"correctement ces opérations sur les types séquentiels personnalisés."

#: ../Doc/library/stdtypes.rst:837
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"Ce tableau répertorie les opérations sur les séquences  triées par priorité "
"ascendante. Dans le tableau, *s,* et *t* sont des séquences du même type, "
"*n*, *i*, *j* et *k* sont des nombres entiers et *x* est un objet arbitraire "
"qui répond à toutes les restrictions de type et de valeur imposée par *s*."

#: ../Doc/library/stdtypes.rst:842
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"Les opérations ``in`` et ``not in`` ont les mêmes priorités que les "
"opérations de comparaison. Les opérations ``+`` (concaténation) et ``*`` "
"(répétition) ont la même priorité que les opérations numériques "
"correspondantes. [3]_"

#: ../Doc/library/stdtypes.rst:863
msgid "``x in s``"
msgstr "``x in s``"

#: ../Doc/library/stdtypes.rst:863
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True`` si un élément de *s* est égal à *x*, sinon ``False``"

#: ../Doc/library/stdtypes.rst:866
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../Doc/library/stdtypes.rst:866
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False`` si un élément de *s* est égal à *x*, sinon ``True``"

#: ../Doc/library/stdtypes.rst:869
msgid "``s + t``"
msgstr "``s + t``"

#: ../Doc/library/stdtypes.rst:869
msgid "the concatenation of *s* and *t*"
msgstr "la concaténation de *s* et *t*"

#: ../Doc/library/stdtypes.rst:869
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../Doc/library/stdtypes.rst:872
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` or ``n * s``"

#: ../Doc/library/stdtypes.rst:872
msgid "equivalent to adding *s* to itself *n* times"
msgstr "équivalent à ajouter *s* *n* fois à lui même"

#: ../Doc/library/stdtypes.rst:872
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../Doc/library/stdtypes.rst:875
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../Doc/library/stdtypes.rst:875
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*i*\\ :sup:`e` élément de *s* en commençant par 0"

#: ../Doc/library/stdtypes.rst:877
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../Doc/library/stdtypes.rst:877
msgid "slice of *s* from *i* to *j*"
msgstr "tranche (*slice*) de *s* de *i* à *j*"

#: ../Doc/library/stdtypes.rst:877
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../Doc/library/stdtypes.rst:879
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../Doc/library/stdtypes.rst:879
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "tranche (*slice*) de *s* de *i* à *j* avec un pas de *k*"

#: ../Doc/library/stdtypes.rst:879
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../Doc/library/stdtypes.rst:882
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../Doc/library/stdtypes.rst:882
msgid "length of *s*"
msgstr "longueur de *s*"

#: ../Doc/library/stdtypes.rst:884
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../Doc/library/stdtypes.rst:884
msgid "smallest item of *s*"
msgstr "plus petit élément de *s*"

#: ../Doc/library/stdtypes.rst:886
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../Doc/library/stdtypes.rst:886
msgid "largest item of *s*"
msgstr "plus grand élément de *s*"

#: ../Doc/library/stdtypes.rst:888
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../Doc/library/stdtypes.rst:888
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"indice de la première occurrence de *x* dans *s* (à ou après l'indice *i* et "
"avant indice *j*)"

#: ../Doc/library/stdtypes.rst:888 ../Doc/library/stdtypes.rst:3384
msgid "\\(8)"
msgstr "\\(8)"

#: ../Doc/library/stdtypes.rst:892
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../Doc/library/stdtypes.rst:892
msgid "total number of occurrences of *x* in *s*"
msgstr "nombre total d'occurrences de *x* dans *s*"

#: ../Doc/library/stdtypes.rst:896
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Les séquences du même type supportent également la comparaison. En "
"particulier, les n-uplets et les listes sont comparés lexicographiquement en "
"comparant les éléments correspondants. Cela signifie que pour que deux "
"séquences soit égales, les éléments les constituant doivent être égaux deux "
"à deux et les deux séquences doivent être du même type et de la même "
"longueur. (Pour plus de détails voir :ref:`comparisons` dans la référence du "
"langage.)"

#: ../Doc/library/stdtypes.rst:905
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"Bien que les opérations ``in`` et ``not in`` ne soient généralement "
"utilisées que pour les tests d'appartenance simple, certaines séquences "
"spécialisées (telles que :class:`str`, :class:`bytes` et :class:`bytearray`) "
"les utilisent aussi pour tester l'existence de sous-séquences ::"

#: ../Doc/library/stdtypes.rst:914
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"Les valeurs de *n* plus petites que ``0`` sont traitées comme ``0`` (ce qui "
"donne une séquence vide du même type que *s*). Notez que les éléments de *s* "
"ne sont pas copiés ; ils sont référencés plusieurs fois. Cela hante souvent "
"de nouveaux développeurs Python, typiquement ::"

#: ../Doc/library/stdtypes.rst:926
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Ce qui est arrivé est que ``[[]]`` est une liste à un élément contenant une "
"liste vide, de sorte que les trois éléments de ``[[]] * 3`` sont des "
"références à cette seule liste vide. Modifier l'un des éléments de ``lists`` "
"modifie cette liste unique. Vous pouvez créer une liste des différentes "
"listes de cette façon ::"

#: ../Doc/library/stdtypes.rst:938
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"De plus amples explications sont disponibles dans la FAQ à la question :ref:"
"`faq-multidimensional-list`."

#: ../Doc/library/stdtypes.rst:942
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Si *i* ou *j* sont négatifs, l'indice est relatif à la fin de la séquence "
"*s* : ``len(s) + i`` ou ``len(s) + j`` est substitué. Mais notez que ``-0`` "
"est toujours ``0``."

#: ../Doc/library/stdtypes.rst:947
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"La tranche de *s* de *i* à *j* est définie comme la séquence d'éléments "
"d'indice *k* tels que ``i <= k < j``. Si *i* ou *j* est supérieur à "
"``len(s)``, ``len(s)`` est utilisé. Si *i* est omis ou ``None``, ``0`` est "
"utilisé. Si *j* est omis ou ``None``, ``len(s)`` est utilisé. Si *i* est "
"supérieure ou égale à *j*, la tranche est vide."

#: ../Doc/library/stdtypes.rst:954
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"La tranche de *s* de *i* à *j* avec un pas de *k* est définie comme la "
"séquence d'éléments d'indice ``x = i + n*k`` tels que ``0 <= n < (j-i)/k``. "
"En d'autres termes, les indices sont ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` et "
"ainsi de suite, en arrêtant lorsque *j* est atteint (mais jamais inclus). Si "
"*k* est positif, *i* et *j* sont réduits, s'ils sont plus grands, à "
"``len(s)``. Si *k* est négatif, *i* et *j* sont réduits à ``len(s) - 1`` "
"s'ils sont plus grands. Si *i* ou *j* sont omis ou sont ``None``, ils "
"deviennent des valeurs \"extrêmes\" (où l'ordre dépend du signe de *k*). "
"Remarquez, *k* ne peut pas valoir zéro. Si *k* est ``None``, il est traité "
"comme ``1``."

#: ../Doc/library/stdtypes.rst:965
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"Concaténer des séquences immuables donne toujours un nouvel objet. Cela "
"signifie que la construction d'une séquence par concaténations répétées aura "
"une durée d'exécution quadratique par rapport à la longueur de la séquence "
"totale. Pour obtenir un temps d'exécution linéaire, vous devez utiliser "
"l'une des alternatives suivantes :"

#: ../Doc/library/stdtypes.rst:970
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"si vous concaténez des :class:`str`, vous pouvez construire une liste puis "
"utiliser :meth:`str.join` à la fin, ou bien écrire dans une instance de :"
"class:`io.StringIO` et récupérer sa valeur lorsque vous avez terminé"

#: ../Doc/library/stdtypes.rst:974
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"si vous concaténez des :class:`bytes`, vous pouvez aussi utiliser :meth:"
"`bytes.join` ou :class:`io.BytesIO`, ou vous pouvez faire les concaténation "
"sur place avec un objet :class:`bytearray`. Les objets :class:`bytearray` "
"sont muables et ont un mécanisme de sur-allocation efficace"

#: ../Doc/library/stdtypes.rst:979
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"si vous concaténez des :class:`tuple`, utilisez plutôt *extend* sur une :"
"class:`list`"

#: ../Doc/library/stdtypes.rst:981
msgid "for other types, investigate the relevant class documentation"
msgstr ""
"pour d'autres types, cherchez dans la documentation de la classe concernée"

#: ../Doc/library/stdtypes.rst:985
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Certains types séquentiels (tels que :class:`range`) ne supportent que des "
"séquences qui suivent des modèles spécifiques, et donc ne prennent pas en "
"charge la concaténation ou la répétition."

#: ../Doc/library/stdtypes.rst:990
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"``index`` lève une exception :exc:`ValueError` quand *x* ne se trouve pas "
"dans *s*. Toutes les implémentations ne gèrent pas les deux paramètres "
"supplémentaires *i* et *j*. Ces deux arguments permettent de chercher "
"efficacement dans une sous-séquence de la séquence. Donner ces arguments est "
"plus ou moins équivalent à ``s[i:j].index(x)``, sans copier les données ; "
"l'indice renvoyé alors relatif au début de la séquence plutôt qu'au début de "
"la tranche."

#: ../Doc/library/stdtypes.rst:1001
msgid "Immutable Sequence Types"
msgstr "Types de séquences immuables"

#: ../Doc/library/stdtypes.rst:1008
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"La seule opération que les types de séquences immuables implémentent qui "
"n'est pas implémentée par les types de séquences muables est le support de "
"la fonction native :func:`hash`."

#: ../Doc/library/stdtypes.rst:1012
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Cette implémentation permet d'utiliser des séquences immuables, comme les "
"instances de :class:`tuple`, en tant que clés de :class:`dict` et stockées "
"dans les instances de :class:`set` et :class:`frozenset`."

#: ../Doc/library/stdtypes.rst:1016
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Essayer de hacher une séquence immuable qui contient des valeurs non-"
"hachables lèvera une :exc:`TypeError`."

#: ../Doc/library/stdtypes.rst:1023
msgid "Mutable Sequence Types"
msgstr "Types de séquences muables"

#: ../Doc/library/stdtypes.rst:1030
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Les opérations dans le tableau ci-dessous sont définies sur les types de "
"séquences muables. La classe de base abstraite :class:`collections.abc."
"MutableSequence` est prévue pour faciliter l'implémentation correcte de ces "
"opérations sur les types de séquence personnalisées."

#: ../Doc/library/stdtypes.rst:1034
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"Dans le tableau *s* est une instance d'un type de séquence muable, *t* est "
"un objet itérable et *x* est un objet arbitraire qui répond à toutes les "
"restrictions de type et de valeur imposées par *s* (par exemple, :class:"
"`bytearray` accepte uniquement des nombres entiers qui répondent à la "
"restriction de la valeur ``0 <= x <= 255``)."

#: ../Doc/library/stdtypes.rst:1058
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../Doc/library/stdtypes.rst:1058
msgid "item *i* of *s* is replaced by *x*"
msgstr "élément *i* de *s* est remplacé par *x*"

#: ../Doc/library/stdtypes.rst:1061
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../Doc/library/stdtypes.rst:1061
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"tranche de *s* de *i* à *j* est remplacée par le contenu de l'itérable *t*"

#: ../Doc/library/stdtypes.rst:1065
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../Doc/library/stdtypes.rst:1065
msgid "same as ``s[i:j] = []``"
msgstr "identique à ``s[i:j] = []``"

#: ../Doc/library/stdtypes.rst:1067
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../Doc/library/stdtypes.rst:1067
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "les éléments de ``s[i:j:k]`` sont remplacés par ceux de *t*"

#: ../Doc/library/stdtypes.rst:1070
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../Doc/library/stdtypes.rst:1070
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "supprime les éléments de ``s[i:j:k]`` de la liste"

#: ../Doc/library/stdtypes.rst:1073
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../Doc/library/stdtypes.rst:1073
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""
"ajoute *x* à la fin de la séquence (identique à ``s[len(s):len(s)] = [x]``)"

#: ../Doc/library/stdtypes.rst:1077
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../Doc/library/stdtypes.rst:1077
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "supprime tous les éléments de *s* (identique à ``del s[:]``)"

#: ../Doc/library/stdtypes.rst:1080
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../Doc/library/stdtypes.rst:1080
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "crée une copie superficielle de *s* (identique à ``s[:]``)"

#: ../Doc/library/stdtypes.rst:1083
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` or ``s += t``"

#: ../Doc/library/stdtypes.rst:1083
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr "étend *s* avec le contenu de *t* (proche de  ``s[len(s):len(s)] = t``)"

#: ../Doc/library/stdtypes.rst:1088
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../Doc/library/stdtypes.rst:1088
msgid "updates *s* with its contents repeated *n* times"
msgstr "met à jour *s* avec son contenu répété *n* fois"

#: ../Doc/library/stdtypes.rst:1091
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../Doc/library/stdtypes.rst:1091
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"insère *x* dans *s* à l'index donné par *i* (identique à ``s[i:i] = [x]``)"

#: ../Doc/library/stdtypes.rst:1095
msgid "``s.pop([i])``"
msgstr "``s.pop([i])``"

#: ../Doc/library/stdtypes.rst:1095
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "récupère l'élément à *i* et le supprime de *s*"

#: ../Doc/library/stdtypes.rst:1098
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../Doc/library/stdtypes.rst:1098
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "supprime le premier élément de *s* pour lequel ``s[i]`` est égal à *x*"

#: ../Doc/library/stdtypes.rst:1101
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../Doc/library/stdtypes.rst:1101
msgid "reverses the items of *s* in place"
msgstr "inverse sur place les éléments de *s*"

#: ../Doc/library/stdtypes.rst:1109
msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t* doit avoir la même longueur que la tranche qu'il remplace."

#: ../Doc/library/stdtypes.rst:1112
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"L'argument optionnel *i* vaut ``-1`` par défaut, afin que, par défaut, le "
"dernier élément soit retiré et renvoyé."

#: ../Doc/library/stdtypes.rst:1116
#, fuzzy
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""
"``remove`` lève une exception :exc:`ValueError` si *x* ne se trouve pas dans "
"*s*."

#: ../Doc/library/stdtypes.rst:1119
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"La méthode :meth:`reverse` modifie les séquence sur place pour économiser de "
"l'espace lors du traitement de grandes séquences. Pour rappeler aux "
"utilisateurs qu'elle a un effet de bord, elle ne renvoie pas la séquence "
"inversée."

#: ../Doc/library/stdtypes.rst:1124
#, fuzzy
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
":meth:`clear` et :meth:`!copy` sont incluses pour la compatibilité avec les "
"interfaces des conteneurs muables qui ne supportent pas les opérations de "
"découpage (comme :class:`dict` et :class:`set`)"

#: ../Doc/library/stdtypes.rst:1130
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr "méthodes :meth:`clear` et :meth:`!copy`."

#: ../Doc/library/stdtypes.rst:1134
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"La valeur *n* est un entier, ou un objet implémentant :meth:`~object."
"__index__`. Zéro et les valeurs négatives de *n* permettent d'effacer la "
"séquence. Les éléments dans la séquence ne sont pas copiés ; ils sont "
"référencés plusieurs fois, comme expliqué pour ``s * n`` dans :ref:`typesseq-"
"common`."

#: ../Doc/library/stdtypes.rst:1143
msgid "Lists"
msgstr "Listes"

#: ../Doc/library/stdtypes.rst:1147
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Les listes sont des séquences muables, généralement utilisées pour stocker "
"des collections d'éléments homogènes (où le degré de similitude variera "
"selon l'usage)."

#: ../Doc/library/stdtypes.rst:1153
msgid "Lists may be constructed in several ways:"
msgstr "Les listes peuvent être construites de différentes manières :"

#: ../Doc/library/stdtypes.rst:1155
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"En utilisant une paire de crochets pour indiquer une liste vide : ``[]``"

#: ../Doc/library/stdtypes.rst:1156
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Au moyen de crochets, séparant les éléments par des virgules : ``[a]``, "
"``[a, b, c]``"

#: ../Doc/library/stdtypes.rst:1157
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "En utilisant une liste en compréhension : ``[x for x in iterable]``"

#: ../Doc/library/stdtypes.rst:1158
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr ""
"En utilisant le constructeur du type : ``list()`` ou ``list(iterable)``"

#: ../Doc/library/stdtypes.rst:1160
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"Le constructeur crée une liste dont les éléments sont les mêmes et dans le "
"même ordre que les éléments d'*iterable*. *iterable* peut être soit une "
"séquence, un conteneur qui supporte l'itération, soit un itérateur. Si "
"*iterable* est déjà une liste, une copie est faite et renvoyée, comme avec "
"``iterable[:]``. Par exemple, ``list('abc')`` renvoie ``['a', 'b', 'c']`` et "
"``list( (1, 2, 3) )`` renvoie ``[1, 2, 3]``. Si aucun argument est donné, le "
"constructeur crée une nouvelle liste vide, ``[]``."

#: ../Doc/library/stdtypes.rst:1169
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"De nombreuses autres opérations produisent des listes, tel que la fonction "
"native :func:`sorted`."

#: ../Doc/library/stdtypes.rst:1172
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Les listes supportent toutes les opérations des séquences :ref:`communes "
"<typesseq-common>` et :ref:`muables <typesseq-mutable>`. Les listes "
"fournissent également la méthode supplémentaire suivante :"

#: ../Doc/library/stdtypes.rst:1178
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Cette méthode trie la liste sur place, en utilisant uniquement des "
"comparaisons ``<`` entre les éléments. Les exceptions ne sont pas supprimées "
"si n'importe quelle opération de comparaison échoue, le tri échouera (et la "
"liste sera probablement laissée dans un état partiellement modifié)."

#: ../Doc/library/stdtypes.rst:1183
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` accepte deux arguments qui ne peuvent être fournis que par mot-"
"clé (:ref:`keyword-only arguments <keyword-only_parameter>`):"

#: ../Doc/library/stdtypes.rst:1186
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* spécifie une fonction d'un argument utilisée pour extraire une clé de "
"comparaison de chaque élément de la liste (par exemple, ``key=str.lower``). "
"La clé correspondant à chaque élément de la liste n'est calculée qu'une "
"seule fois, puis utilisée durant tout le processus. La valeur par défaut, "
"``None``, signifie que les éléments sont triés directement sans en calculer "
"une valeur \"clé\" séparée."

#: ../Doc/library/stdtypes.rst:1193
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"La fonction utilitaire :func:`functools.cmp_to_key` est disponible pour "
"convertir une fonction *cmp* du style 2.x à une fonction *key*."

#: ../Doc/library/stdtypes.rst:1196
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse*, une valeur booléenne. Si elle est ``True``, la liste d'éléments "
"est triée comme si toutes les comparaisons étaient inversées."

#: ../Doc/library/stdtypes.rst:1199
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Cette méthode modifie la séquence sur place pour économiser de l'espace lors "
"du tri de grandes séquences. Pour rappeler aux utilisateurs cet effet de "
"bord, elle ne renvoie pas la séquence triée (utilisez :func:`sorted` pour "
"demander explicitement une nouvelle instance de liste triée)."

#: ../Doc/library/stdtypes.rst:1204
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"La méthode :meth:`sort` est garantie stable. Un tri est stable s'il garantit "
"de ne pas changer l'ordre relatif des éléments égaux --- cela est utile pour "
"trier en plusieurs passes (par exemple, trier par département, puis par "
"niveau de salaire)."

#: ../Doc/library/stdtypes.rst:1209
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Pour des exemples de tris et un bref tutoriel, consultez :ref:`sortinghowto`."

#: ../Doc/library/stdtypes.rst:1213
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"L'effet de tenter de modifier, ou même inspecter la liste pendant qu'elle se "
"fait trier est indéfini. L'implémentation C de Python fait apparaître la "
"liste comme vide pour la durée du traitement, et lève :exc:`ValueError` si "
"elle détecte que la liste a été modifiée au cours du tri."

#: ../Doc/library/stdtypes.rst:1222
msgid "Tuples"
msgstr "Tuples"

#: ../Doc/library/stdtypes.rst:1226
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Les tuples (*n-uplets* en français) sont des séquences immuables, "
"généralement utilisées pour stocker des collections de données hétérogènes "
"(tels que les tuples de deux éléments produits par la fonction native :func:"
"`enumerate`). Les tuples sont également utilisés dans des cas où une "
"séquence homogène et immuable de données  est nécessaire (pour, par exemple, "
"les stocker dans un :class:`set` ou un :class:`dict`)."

#: ../Doc/library/stdtypes.rst:1234
msgid "Tuples may be constructed in a number of ways:"
msgstr "Les tuples peuvent être construits de différentes façons :"

#: ../Doc/library/stdtypes.rst:1236
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"En utilisant une paire de parenthèses pour désigner le tuple vide : ``()``"

#: ../Doc/library/stdtypes.rst:1237
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""
"En utilisant une virgule, pour créer un tuple d'un élément : ``a,`` ou "
"``(a,)``"

#: ../Doc/library/stdtypes.rst:1238
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr ""
"En séparant les éléments avec des virgules : ``a, b, c`` ou ``(a, b, c)``"

#: ../Doc/library/stdtypes.rst:1239
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"En utilisant la fonction native :func:`tuple` : ``tuple()`` ou "
"``tuple(iterable)``"

#: ../Doc/library/stdtypes.rst:1241
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"Le constructeur construit un tuple dont les éléments sont les mêmes et dans "
"le même ordre que les éléments de *iterable*. *iterable* peut être soit une "
"séquence, un conteneur qui supporte l'itération, soit un itérateur. Si "
"*iterable* est déjà un tuple, il est renvoyé inchangé. Par exemple, "
"``tuple('abc')`` renvoie ``('a', 'b', 'c')`` et ``tuple( [1, 2, 3] )`` "
"renvoie ``(1, 2, 3)``. Si aucun argument est donné, le constructeur crée un "
"nouveau tuple vide, ``()``."

#: ../Doc/library/stdtypes.rst:1249
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Notez que c'est en fait la virgule qui fait un tuple et non les parenthèses. "
"Les parenthèses sont facultatives, sauf dans le cas du tuple vide, ou "
"lorsqu'elles sont nécessaires pour éviter l'ambiguïté syntaxique. Par "
"exemple, ``f(a, b, c)`` est un appel de fonction avec trois arguments, alors "
"que ``f((a, b, c))`` est un appel de fonction avec un tuple de trois "
"éléments comme unique argument."

#: ../Doc/library/stdtypes.rst:1255
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Les tuples implémentent toutes les opérations :ref:`communes <typesseq-"
"common>` des séquences."

#: ../Doc/library/stdtypes.rst:1258
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Pour les collections hétérogènes de données où l'accès par nom est plus "
"clair que l'accès par index, :func:`collections.namedtuple` peut être un "
"choix plus approprié qu'un simple tuple."

#: ../Doc/library/stdtypes.rst:1266
msgid "Ranges"
msgstr "*Ranges*"

#: ../Doc/library/stdtypes.rst:1270
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"Le type :class:`range` représente une séquence immuable de nombres et est "
"couramment utilisé pour itérer un certain nombre de fois dans les boucles :"
"keyword:`for`."

#: ../Doc/library/stdtypes.rst:1277
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the ``__index__`` special "
"method).  If the *step* argument is omitted, it defaults to ``1``. If the "
"*start* argument is omitted, it defaults to ``0``. If *step* is zero, :exc:"
"`ValueError` is raised."
msgstr ""
"Les arguments du constructeur de *range* doivent être des entiers (des :"
"class:`int` ou tout autre objet qui implémente la méthode spéciale "
"``__index__``). La valeur par défaut de l'argument *step* est ``1``. La "
"valeur par défaut de l'argument *start* est ``0``. Si *step* est égal à "
"zéro, une exception :exc:`ValueError` est levée."

#: ../Doc/library/stdtypes.rst:1283
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Pour un *step* positif, le contenu d'un *range* ``r`` est déterminé par la "
"formule ``r[i] = start + step*i`` où ``i >= 0`` et ``r[i] < stop``."

#: ../Doc/library/stdtypes.rst:1287
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"Pour un *step* négatif, le contenu du *range* est toujours déterminé par la "
"formule ``r[i] = start + step*i``, mais les contraintes sont ``i >= 0`` et "
"``r[i] > stop``."

#: ../Doc/library/stdtypes.rst:1291
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Un objet *range* sera vide si ``r[0]`` ne répond pas à la contrainte de "
"valeur. Les *range* prennent en charge les indices négatifs, mais ceux-ci "
"sont interprétées comme une indexation de la fin de la séquence déterminée "
"par les indices positifs."

#: ../Doc/library/stdtypes.rst:1296
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Les *range* contenant des valeurs absolues plus grandes que :data:`sys."
"maxsize` sont permises, mais certaines fonctionnalités (comme :func:`len`) "
"peuvent lever :exc:`OverflowError`."

#: ../Doc/library/stdtypes.rst:1300
msgid "Range examples::"
msgstr "Exemples avec *range* ::"

#: ../Doc/library/stdtypes.rst:1317
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"*range* implémente toutes les opérations :ref:`communes <typesseq-common>` "
"des séquences sauf la concaténation et la répétition (en raison du fait que "
"les *range* ne peuvent représenter que des séquences qui respectent un motif "
"strict et que la répétition et la concaténation les feraient dévier de ce "
"motif)."

#: ../Doc/library/stdtypes.rst:1324
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr ""
"La valeur du paramètre *start* (ou ``0`` si le paramètre n'a pas été fourni)"

#: ../Doc/library/stdtypes.rst:1329
msgid "The value of the *stop* parameter"
msgstr "La valeur du paramètre *stop*"

#: ../Doc/library/stdtypes.rst:1333
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr ""
"La valeur du paramètre *step* (ou ``1`` si le paramètre n'a pas été fourni)"

#: ../Doc/library/stdtypes.rst:1336
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"L'avantage du type :class:`range` sur une :class:`list` classique ou :class:"
"`tuple` est qu'un objet :class:`range` prendra toujours la même (petite) "
"quantité de mémoire, peu importe la taille de la gamme qu'elle représente "
"(car elle ne stocke que les valeurs ``start``, ``stop`` et ``step`` , le "
"calcul des éléments individuels et les sous-intervalles au besoin)."

#: ../Doc/library/stdtypes.rst:1342
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Les *range* implémentent la classe de base abstraite :class:`collections.abc."
"Sequence` et offrent des fonctionnalités telles que les tests d'appartenance "
"(avec *in*), de recherche par index, le tranchage et ils gèrent les indices "
"négatifs (voir :ref:`typesseq`):"

#: ../Doc/library/stdtypes.rst:1362
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"Comparer des *range* avec ``==`` et ``!=`` les compare comme des séquences. "
"Soit deux objets *range* sont considérées comme égaux si ils représentent la "
"même séquence de valeurs. (Notez que deux objets *range* dits égaux "
"pourraient avoir leurs attributs :attr:`~range.start`, :attr:`~range.stop` "
"et :attr:`~range.step` différents, par exemple ``range(0) == range(2, 1, "
"3)`` ou ``range(0, 3, 2) == range(0, 4, 2)``.)"

#: ../Doc/library/stdtypes.rst:1369
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Implémente la classe de base abstraite *Sequence*. Supporte le *slicing* et "
"les indices négatifs. Tester l'appartenance d'un :class:`int` en temps "
"constant au lieu d'itérer tous les éléments."

#: ../Doc/library/stdtypes.rst:1375
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"``==`` et ``!=`` comparent des *range* en fonction de la séquence de valeurs "
"qu'ils définissent (au lieu d'une comparaison fondée sur l'identité de "
"l'objet)."

#: ../Doc/library/stdtypes.rst:1380
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"Les attributs :attr:`~range.start`, :attr:`~range.stop` et :attr:`~range."
"step`."

#: ../Doc/library/stdtypes.rst:1386
msgid ""
"The `linspace recipe <http://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range suitable for floating point "
"applications."
msgstr ""
"La `recette linspace <http://code.activestate.com/recipes/579000/>`_ montre "
"comment implémenter une version paresseuse de *range* adaptée aux nombres à "
"virgule flottante."

#: ../Doc/library/stdtypes.rst:1398
msgid "Text Sequence Type --- :class:`str`"
msgstr "Type Séquence de Texte — :class:`str`"

#: ../Doc/library/stdtypes.rst:1400
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Les données textuelles en Python est manipulé avec des objets :class:`str` "
"ou :dfn:`strings`. Les chaînes sont  des :ref:`séquences <typesseq>` "
"immuables de points de code Unicode. Les chaînes littérales peuvent être "
"écrites de différentes manières :"

#: ../Doc/library/stdtypes.rst:1405
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Les guillemets simples : ``'autorisent les \"guillemets\"'``"

#: ../Doc/library/stdtypes.rst:1406
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``."
msgstr "Les guillemets : ``\"autorisent les guillemets 'simples'\"``."

#: ../Doc/library/stdtypes.rst:1407
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double quotes"
"\"\"\"``"
msgstr ""
"Guillemets triples : ``'''Trois guillemets simples'''``, ``\"\"\"Trois "
"guillemets\"\"\"``"

#: ../Doc/library/stdtypes.rst:1409
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Les chaînes entre triple guillemets peuvent couvrir plusieurs lignes, tous "
"les espaces associés seront inclus dans la chaîne littérale."

#: ../Doc/library/stdtypes.rst:1412
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Les chaînes littérales qui font partie d'une seule expression et ont "
"seulement des espaces entre elles sont implicitement converties en une seule "
"chaîne littérale. Autrement dit, ``(\"spam \" \"eggs\") == \"spam eggs\"``."

#: ../Doc/library/stdtypes.rst:1416
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""
"Voir :ref:`strings` pour plus d'informations sur les différentes formes de "
"chaînes littérales, y compris des séquences d'échappement prises en charge, "
"et le  préfixe ``r`` (*raw* (brut)) qui désactive la plupart des traitements "
"de séquence d'échappement."

#: ../Doc/library/stdtypes.rst:1420
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Les chaînes peuvent également être créés à partir d'autres objets à l'aide "
"du constructeur :class:`str`."

#: ../Doc/library/stdtypes.rst:1423
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Comme il n'y a pas de type \"caractère\" distinct, l'indexation d'une chaîne "
"produit des chaînes de longueur 1. Autrement dit, pour une chaîne non vide "
"*s*, ``s[0] == s[0:1]``."

#: ../Doc/library/stdtypes.rst:1429
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Il n'y a aucun type de chaîne muable, mais :meth:`str.join` ou :class:`io."
"StringIO` peuvent être utilisées pour construire efficacement des chaînes à "
"partir de plusieurs fragments."

#: ../Doc/library/stdtypes.rst:1433
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Pour une compatibilité ascendante avec la série Python 2, le préfixe ``u`` "
"est à nouveau autorisé sur les chaînes littérales. Elle n'a aucun effet sur "
"le sens des chaînes littérales et ne peut être combiné avec le préfixe ``r``."

#: ../Doc/library/stdtypes.rst:1445
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Renvoie une représentation :ref:`string <textseq>` de *object*. Si *object* "
"n'est pas fourni, renvoie une chaîne vide. Sinon, le comportement de "
"``str()`` dépend de si *encoding* ou *errors* sont donnés, voir l'exemple."

#: ../Doc/library/stdtypes.rst:1449
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`object.__str__() <object.__str__>`, which is the \"informal\" or nicely "
"printable string representation of *object*.  For string objects, this is "
"the string itself.  If *object* does not have a :meth:`~object.__str__` "
"method, then :func:`str` falls back to returning :meth:`repr(object) <repr>`."
msgstr ""
"Si ni *encoding* ni *errors* ne sont donnés, ``str(object)`` renvoie :meth:"
"`object.__str__() <object.__str__>`, qui est la représentation de chaîne "
"\"informelle\" ou bien affichable de *object*. Pour les chaînes, c'est la "
"chaîne elle-même. Si *object* n'a pas de méthode :meth:`~object.__str__`, :"
"func:`str` utilise  :meth:`repr(object) <repr>`."

#: ../Doc/library/stdtypes.rst:1460
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Si au moins un des deux arguments *encoding* ou *errors* est donné, *object* "
"doit être un :term:`bytes-like object` (par exemple :class:`bytes` ou :class:"
"`bytearray`). Dans ce cas, si *object* est un objet :class:`bytes` (ou :"
"class:`bytearray`), alors ``str(bytes, encoding, errors)`` est équivalent à :"
"meth:`bytes.decode(encoding, errors) <bytes.decode>`. Sinon, l'objet *bytes* "
"du *buffer* est obtenu avant d'appeler :meth:`bytes.decode`. Voir :ref:"
"`binaryseq` et :ref:`bufferobjects` pour plus d'informations sur les "
"*buffers*."

#: ../Doc/library/stdtypes.rst:1469
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Donner un objet :class:`bytes` à :func:`str` sans ni l'argument *encoding* "
"ni l'argument *errors* relève du premier cas, où la représentation "
"informelle de la chaîne est renvoyé (voir aussi l'option :option:`-b` de "
"Python). Par exemple ::"

#: ../Doc/library/stdtypes.rst:1477
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Pour plus d'informations sur la classe ``str`` et ses méthodes, voir les "
"sections :ref:`textseq` et :ref:`string-methods`. Pour formater des chaînes "
"de caractères, voir les sections :ref:`f-strings` et :ref:`formatstrings`. "
"La section :ref:`stringservices` contient aussi des informations."

#: ../Doc/library/stdtypes.rst:1489
msgid "String Methods"
msgstr "Méthodes de chaînes de caractères"

#: ../Doc/library/stdtypes.rst:1494
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Les chaînes implémentent toutes les opérations :ref:`communes des séquences "
"<typesseq-common>`, ainsi que les autres méthodes décrites ci-dessous."

#: ../Doc/library/stdtypes.rst:1497
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Les chaînes gèrent aussi deux styles de mise en forme, l'un fournissant une "
"grande flexibilité et de personnalisation (voir :meth:`str.format`, :ref:"
"`formatstrings` et :ref:`string-formatting`) et l'autre basée sur ``printf`` "
"du C qui gère une gamme plus étroite des types et est légèrement plus "
"difficile à utiliser correctement, mais il est souvent plus rapide pour les "
"cas, il peut gérer (:ref:`old-string-formatting`)."

#: ../Doc/library/stdtypes.rst:1504
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"La section :ref:`textservices` de la bibliothèque standard couvre un certain "
"nombre d'autres modules qui fournissent différents services relatifs au "
"texte (y compris les expressions régulières dans le module :mod:`re`)."

#: ../Doc/library/stdtypes.rst:1510
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"Renvoie une copie de la chaîne avec son premier caractère en majuscule et le "
"reste en minuscule."

#: ../Doc/library/stdtypes.rst:1513
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""

#: ../Doc/library/stdtypes.rst:1520
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Renvoie une copie *casefolded* de la chaîne. Les chaînes *casefolded* "
"peuvent être utilisées dans des comparaison insensibles à la casse."

#: ../Doc/library/stdtypes.rst:1523
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"Le *casefolding* est une technique agressive de mise en minuscule, car il "
"vise à éliminer toutes les distinctions de casse dans une chaîne. Par "
"exemple, la lettre minuscule ``'ß'`` de l'allemand équivaut à ``\"ss\"``. "
"Comme il est déjà minuscule, :meth:`lower` ferait rien à ``'ß'``; :meth:"
"`casefold` le convertit en ``\"ss\"``."

#: ../Doc/library/stdtypes.rst:1529
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"L'algorithme de *casefolding* est décrit dans la section 3.13 de la norme "
"Unicode."

#: ../Doc/library/stdtypes.rst:1537
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Donne la chaîne au centre d'une chaîne de longueur *width*. Le remplissage "
"est fait en utilisant l'argument *fillchar* (qui par défaut est un espace "
"ASCII). La chaîne d'origine est renvoyée si *width* est inférieur ou égale à "
"``len(s)``."

#: ../Doc/library/stdtypes.rst:1545
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Donne le nombre d'occurrences de *sub* ne se chevauchant pas dans le *range* "
"[*start*, *end*]. Les arguments facultatifs *start* et *end* sont "
"interprétés comme pour des *slices*."

#: ../Doc/library/stdtypes.rst:1552
msgid ""
"Return an encoded version of the string as a bytes object. Default encoding "
"is ``'utf-8'``. *errors* may be given to set a different error handling "
"scheme. The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`. Other possible values are ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and any other "
"name registered via :func:`codecs.register_error`, see section :ref:`error-"
"handlers`. For a list of possible encodings, see section :ref:`standard-"
"encodings`."
msgstr ""
"Donne une version encodée de la chaîne sous la forme d'un objet *bytes*. "
"L'encodage par défaut est ``'utf-8'``. *errors* peut être donné pour choisir "
"un autre système de gestion d'erreur. La valeur par défaut pour *errors* est "
"``'strict'``, ce qui signifie que les erreurs d'encodage lèvent une :exc:"
"`UnicodeError`. Les autres valeurs possibles sont ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` et tout autre "
"nom enregistré *via* :func:`codecs.register_error`, voir la section :ref:"
"`error-handlers`. Pour une liste des encodages possibles, voir la section :"
"ref:`standard-encodings`."

#: ../Doc/library/stdtypes.rst:1561
msgid "Support for keyword arguments added."
msgstr "Gestion des arguments par mot clef."

#: ../Doc/library/stdtypes.rst:1567
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Donne ``True`` si la chaîne se termine par *suffix*, sinon ``False``. "
"*suffix* peut aussi être un tuple de suffixes à rechercher. Si l'argument "
"optionnel *start* est donné, le test se fait à partir de cette position. Si "
"l'argument optionnel *end* est fourni, la comparaison s'arrête à cette "
"position."

#: ../Doc/library/stdtypes.rst:1575
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline (``"
"\\n``) or return (``\\r``), it is copied and the current column is reset to "
"zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"Donne une copie de la chaîne où toutes les tabulations sont remplacées par "
"un ou plusieurs espaces, en fonction de la colonne courante et de la taille "
"de tabulation donnée. Les positions des tabulations se trouvent tous les "
"*tabsize* caractères (8 par défaut, ce qui donne les positions de "
"tabulations aux colonnes 0, 8, 16 et ainsi de suite). Pour travailler sur la "
"chaîne, la colonne en cours est mise à zéro et la chaîne est examinée "
"caractère par caractère. Si le caractère est une tabulation (``\\t``), un ou "
"plusieurs caractères d'espacement sont insérés dans le résultat jusqu'à ce "
"que la colonne courante soit égale à la position de tabulation suivante. (Le "
"caractère tabulation lui-même n'est pas copié.) Si le caractère est un saut "
"de ligne (``\\n``) ou un retour chariot (``\\r``), il est copié et la "
"colonne en cours est remise à zéro. Tout autre caractère est copié inchangé "
"et la colonne en cours est incrémentée de un indépendamment de la façon dont "
"le caractère est représenté lors de l'affichage."

#: ../Doc/library/stdtypes.rst:1596
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Donne la première la position dans la chaîne où *sub* est trouvé dans le "
"*slice* ``s[start:end]``. Les arguments facultatifs *start* et *end* sont "
"interprétés comme dans la notation des *slice*. Donne ``-1`` si *sub* n'est "
"pas trouvé."

#: ../Doc/library/stdtypes.rst:1602
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"La méthode :meth:`~str.find` ne doit être utilisée que si vous avez besoin "
"de connaître la position de *sub*. Pour vérifier si *sub* est une sous "
"chaine ou non, utilisez l'opérateur :keyword:`in` ::"

#: ../Doc/library/stdtypes.rst:1612
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Formate une chaîne. La chaîne sur laquelle cette méthode est appelée peut "
"contenir du texte littéral ou des emplacements de remplacement délimités par "
"des accolades ``{}``. Chaque champ de remplacement contient soit l'indice "
"numérique d'un argument positionnel, ou le nom d'un argument donné par mot-"
"clé. Renvoie une copie de la chaîne où chaque champ de remplacement est "
"remplacé par la valeur de chaîne de l'argument correspondant."

#: ../Doc/library/stdtypes.rst:1622
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Voir :ref:`formatstrings` pour une description des options de formatage qui "
"peuvent être spécifiées dans les chaînes de format."

#: ../Doc/library/stdtypes.rst:1626
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"Lors du formatage avec le format ``n`` (comme ``'{:n}'.format(1234)``) d'un "
"nombre (:class:`int`, :class:`float`, :class:`complex`, :class:`decimal."
"Decimal` et dérivées), la fonction met temporairement la variable "
"``LC_CTYPE`` à la valeur de ``LC_NUMERIC`` pour décoder correctement les "
"attributs ``decimal_point`` et ``thousands_sep`` de :c:func:`localeconv`, "
"s'ils ne sont pas en ASCII ou font plus d'un octet, et que ``LC_NUMERIC`` "
"est différent de ``LC_CTYPE``. Ce changement temporaire affecte les autres "
"fils d'exécution."

#: ../Doc/library/stdtypes.rst:1635
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Lors du formatage d'un nombre avec le format ``n``, la fonction change "
"temporairement ``LC_CTYPE`` par la valeur de ``LC_NUMERIC`` dans certains "
"cas."

#: ../Doc/library/stdtypes.rst:1643
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Semblable à ``str.format(**mapping)``, sauf que ``mapping`` est utilisé "
"directement et non copié dans un :class:`dict`. C'est utile si, par exemple "
"``mapping`` est une sous-classe de ``dict`` :"

#: ../Doc/library/stdtypes.rst:1659
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
"Comme :meth:`~str.find`, mais lève une :exc:`ValueError` lorsque la chaîne "
"est introuvable."

#: ../Doc/library/stdtypes.rst:1665
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Donne ``True`` si tous les caractères de la chaîne sont alphanumériques et "
"qu'il y a au moins un caractère, sinon ``False``. Un caractère ``c`` est "
"alphanumérique si l'un des tests suivants est vrais : ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()`` ou ``c.isnumeric()``."

#: ../Doc/library/stdtypes.rst:1673
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", \"Lu"
"\", \"Ll\", or \"Lo\".  Note that this is different from the \"Alphabetic\" "
"property defined in the Unicode Standard."
msgstr ""
"Donne ``True`` si tous les caractères de la chaîne sont alphabétiques et "
"qu'elle contient au moins un caractère, sinon ``False``. Les caractères "
"alphabétiques sont les caractères définis dans la base de données de "
"caractères Unicode comme *Letter*, à savoir, ceux qui ont \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", ou \"Lo\" comme catégorie générale. Notez que ceci est "
"différent de la propriété *Alphabetic* définie dans la norme Unicode."

#: ../Doc/library/stdtypes.rst:1682
#, fuzzy
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range U"
"+0000-U+007F."
msgstr ""
"Donne ``True`` si la chaîne est vide ou ne contient que des caractères "
"ASCII, ``False`` sinon. Les caractères ASCII ont un code dans l'intervalle ``"
"\"U+0000\"``\\ ---\\ ``\"U+007F\"``."

#: ../Doc/library/stdtypes.rst:1691
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"Renvoie vrai si tous les caractères de la chaîne sont des caractères "
"décimaux et qu'elle contient au moins un caractère, sinon faux. Les "
"caractères décimaux sont ceux pouvant être utilisés pour former des nombres "
"en base 10, tels que U+0660, ARABIC-INDIC DIGIT ZERO.  Spécifiquement, un "
"caractère décimal est un caractère dans la catégorie Unicode générale \"Nd\"."

#: ../Doc/library/stdtypes.rst:1701
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Renvoie vrai si tous les caractères de la chaîne sont des chiffres et "
"qu'elle contient au moins un caractère, faux sinon. Les chiffres incluent "
"des caractères décimaux et des chiffres qui nécessitent une manipulation "
"particulière, tels que les *compatibility superscript digits*. Ça couvre les "
"chiffres qui ne peuvent pas être utilisés pour construire des nombres en "
"base 10, tel que les nombres de Kharosthi. Spécifiquement, un chiffre est un "
"caractère dont la valeur de la propriété *Numeric_Type* est *Digit* ou "
"*Decimal*."

#: ../Doc/library/stdtypes.rst:1711
#, fuzzy
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
"Donne ``True`` si la chaîne est un identifiant valide selon la définition du "
"langage, section :ref:`identifiers`."

#: ../Doc/library/stdtypes.rst:1714
#, fuzzy
msgid ""
"Call :func:`keyword.iskeyword` to test whether string ``s`` is a reserved "
"identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
"Utilisez :func:`keyword.iskeyword` pour savoir si un identifiant est "
"réservé, tels que :keyword:`def` et :keyword:`class`."

#: ../Doc/library/stdtypes.rst:1717
#, fuzzy
msgid "Example: ::"
msgstr "Par exemple ::"

#: ../Doc/library/stdtypes.rst:1730
#, fuzzy
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Donne ``True`` si tous les caractères capitalisables [4]_ de la chaîne sont "
"en minuscules et qu'elle contient au moins un caractère capitalisable. Donne "
"``False`` dans le cas contraire."

#: ../Doc/library/stdtypes.rst:1736
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Donne ``True`` si tous les caractères de la chaîne sont des caractères "
"numériques, et qu'elle contient au moins un caractère, sinon ``False``. Les "
"caractères numériques comprennent les chiffres, et tous les caractères  qui "
"ont la propriété Unicode *numeric value*, par exemple U+2155, *VULGAR "
"FRACTION OF FIFTH*. Formellement, les caractères numériques sont ceux avec "
"les priorités *Numeric_Type=Digit*, *Numeric_Type=Decimal*, ou "
"*Numeric_Type=Numeric*."

#: ../Doc/library/stdtypes.rst:1746
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are printable or the string "
"is empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Donne ``True`` si tous les caractères de la chaîne sont affichables ou "
"qu'elle est vide sinon, ``False``. Les caractères non affichables sont les "
"caractères définis dans la base de données de caractères Unicode comme *"
"\"Other\"* ou *\"Separator\"*, à l'exception de l'espace ASCII (``0x20``) "
"qui est considéré comme affichable. (Notez que les caractères imprimables "
"dans ce contexte sont ceux qui ne devraient pas être protégés quand :func:"
"`repr` est invoquée sur une chaîne. Ça n'a aucune incidence sur le "
"traitement des chaînes écrites sur :data:`sys.stdout` ou :data:`sys.stderr`.)"

#: ../Doc/library/stdtypes.rst:1757
#, fuzzy
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"Donne ``True`` si tous les caractères capitalisables [4]_ de la chaîne sont "
"en minuscules et qu'elle contient au moins un caractère capitalisable. Donne "
"``False`` dans le cas contraire."

#: ../Doc/library/stdtypes.rst:1760
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, space"
"\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""

#: ../Doc/library/stdtypes.rst:1768
#, fuzzy
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"Donne ``True`` si la chaîne est une chaîne *titlecased* et qu'elle contient "
"au moins un caractère, par exemple les caractères majuscules ne peuvent "
"suivre les caractères non capitalisables et les caractères minuscules ne "
"peuvent suivre que des caractères capitalisables. Donne ``False`` dans le "
"cas contraire."

#: ../Doc/library/stdtypes.rst:1775
#, fuzzy
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Donne ``True`` si tous les caractères différentiables sur la casse [4]_ de "
"la chaîne sont en majuscules et il y a au moins un caractère différentiable "
"sur la casse, sinon ``False``."

#: ../Doc/library/stdtypes.rst:1781
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"Donne une chaîne qui est la concaténation des chaînes contenues dans "
"*iterable*. Une :exc:`TypeError` sera levée si une valeur d'*iterable* n'est "
"pas une chaîne, y compris pour les objets :class:`bytes`.  Le séparateur "
"entre les éléments est la chaîne fournissant cette méthode."

#: ../Doc/library/stdtypes.rst:1789
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Renvoie la chaîne justifiée à gauche dans une chaîne de longueur *width*. Le "
"rembourrage est fait en utilisant *fillchar* (qui par défaut est un espace "
"ASCII). La chaîne d'origine est renvoyée si *width* est inférieur ou égale à "
"``len(s)``."

#: ../Doc/library/stdtypes.rst:1796
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Renvoie une copie de la chaîne avec tous les caractères capitalisables [4]_ "
"convertis en minuscules."

#: ../Doc/library/stdtypes.rst:1799
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"L'algorithme de mise en minuscules utilisé est décrit dans la section 3.13 "
"de la norme Unicode."

#: ../Doc/library/stdtypes.rst:1805
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Renvoie une copie de la chaîne des caractères supprimés au début. L'argument "
"*chars* est une chaîne spécifiant le jeu de caractères à supprimer. En cas "
"d'omission ou ``None``, la valeur par défaut de *chars* permet de supprimer "
"des espaces. L'argument *chars* n'est pas un préfixe, toutes les "
"combinaisons de ses valeurs sont supprimées ::"

#: ../Doc/library/stdtypes.rst:1818
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Cette méthode statique renvoie une table de traduction utilisable pour :meth:"
"`str.translate`."

#: ../Doc/library/stdtypes.rst:1820
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Si un seul argument est fourni, ce soit être un dictionnaire faisant "
"correspondre des points de code Unicode (nombres entiers) ou des caractères "
"(chaînes de longueur 1) à des points de code Unicode."

#: ../Doc/library/stdtypes.rst:1825
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"Si deux arguments sont fournis, ce doit être deux chaînes de caractères de "
"même longueur. Le dictionnaire renvoyé fera correspondre pour chaque "
"caractère de x un caractère de y pris à la même place. Si un troisième "
"argument est fourni, ce doit être une chaîne dont chaque caractère "
"correspondra à ``None`` dans le résultat."

#: ../Doc/library/stdtypes.rst:1833
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Divise la chaîne à la première occurrence de *sep*, et donne un *tuple* de "
"trois éléments contenant la partie avant le séparateur, le séparateur lui-"
"même, et la partie après le séparateur. Si le séparateur n'est pas trouvé, "
"le *tuple* contiendra la chaîne elle-même, suivie de deux chaînes vides."

#: ../Doc/library/stdtypes.rst:1841
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"Renvoie une copie de la chaîne dont toutes les occurrences de la sous-"
"chaîne  *old* sont remplacés par *new*. Si l'argument optionnel *count* est "
"donné, seules les *count* premières occurrences sont remplacées."

#: ../Doc/library/stdtypes.rst:1848
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Donne l'indice le plus élevé dans la chaîne où la sous-chaîne *sub* se "
"trouve, de telle sorte que *sub* soit contenue dans ``s[start:end]``. Les "
"arguments facultatifs *start* et *end* sont interprétés comme dans la "
"notation des *slices*. Donne  ``-1`` en cas d'échec."

#: ../Doc/library/stdtypes.rst:1855
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Comme :meth:`rfind` mais lève une exception :exc:`ValueError` lorsque la "
"sous-chaîne *sub* est introuvable."

#: ../Doc/library/stdtypes.rst:1861
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Renvoie la chaîne justifié à droite dans une chaîne de longueur *width*. Le "
"rembourrage est fait en utilisant le caractère spécifié par *fillchar* (par "
"défaut est un espace ASCII). La chaîne d'origine est renvoyée si *width* est "
"inférieure ou égale à ``len(s)``."

#: ../Doc/library/stdtypes.rst:1868
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Divise la chaîne à la dernière occurrence de *sep*, et donne un tuple de "
"trois éléments contenant la partie avant le séparateur, le séparateur lui-"
"même, et la partie après le séparateur. Si le séparateur n'est pas trouvé, "
"le *tuple* contiendra deux chaînes vides, puis par la chaîne elle-même."

#: ../Doc/library/stdtypes.rst:1876
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Renvoie une liste des mots de la chaîne, en utilisant *sep* comme "
"séparateur. Si *maxsplit* est donné, c'est le nombre maximum de divisions "
"qui pourront être faites, celles \"à droite\". Si *sep* est pas spécifié ou "
"est ``None``, tout espace est un séparateur. En dehors du fait qu'il découpe "
"par la droite, :meth:`rsplit` se comporte comme :meth:`split` qui est décrit "
"en détail ci-dessous."

#: ../Doc/library/stdtypes.rst:1885
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Renvoie une copie de la chaîne avec des caractères finaux supprimés. "
"L'argument *chars* est une chaîne spécifiant le jeu de caractères à "
"supprimer. En cas d'omission ou ``None``, les espaces sont supprimés. "
"L'argument *chars* n'est pas un suffixe : toutes les combinaisons de ses "
"valeurs sont retirées ::"

#: ../Doc/library/stdtypes.rst:1898
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Renvoie une liste des mots de la chaîne, en utilisant *sep* comme séparateur "
"de mots. Si *maxsplit* est donné, c'est le nombre maximum de divisions qui "
"pourront être effectuées, (donnant ainsi une liste de longueur ``maxsplit"
"+1``). Si *maxsplit* n'est pas fourni, ou vaut ``-1``, le nombre de découpes "
"n'est pas limité (Toutes les découpes possibles sont faites)."

#: ../Doc/library/stdtypes.rst:1904
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"Si *sep* est donné, les délimiteurs consécutifs ne sont pas regroupés et "
"ainsi délimitent des chaînes vides (par exemple, ``'1,,2'.split(',')`` donne "
"``['1', '', '2']``). L'argument *sep* peut contenir plusieurs caractères "
"(par exemple, ``'1<>2<>3'.split('<>')`` renvoie ``['1', '2', '3']``). "
"Découper une chaîne vide en spécifiant *sep* donne ``['']``."

#: ../Doc/library/stdtypes.rst:1910 ../Doc/library/stdtypes.rst:1926
#: ../Doc/library/stdtypes.rst:1978 ../Doc/library/stdtypes.rst:2046
#: ../Doc/library/stdtypes.rst:2109 ../Doc/library/stdtypes.rst:2888
#: ../Doc/library/stdtypes.rst:2904 ../Doc/library/stdtypes.rst:2995
#: ../Doc/library/stdtypes.rst:3011 ../Doc/library/stdtypes.rst:3036
#: ../Doc/library/stdtypes.rst:3050 ../Doc/library/stdtypes.rst:3078
#: ../Doc/library/stdtypes.rst:3092 ../Doc/library/stdtypes.rst:3110
#: ../Doc/library/stdtypes.rst:3137 ../Doc/library/stdtypes.rst:3160
#: ../Doc/library/stdtypes.rst:3187 ../Doc/library/stdtypes.rst:3229
#: ../Doc/library/stdtypes.rst:3253
msgid "For example::"
msgstr "Par exemple ::"

#: ../Doc/library/stdtypes.rst:1919
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Si *sep* n'est pas spécifié ou est ``None``, un autre algorithme de "
"découpage est appliqué : les espaces consécutifs sont considérés comme un "
"seul séparateur, et le résultat ne contiendra pas les chaînes vides de début "
"ou de la fin si la chaîne est préfixée ou suffixé d'espaces. Par conséquent, "
"diviser une chaîne vide ou une chaîne composée d'espaces avec un séparateur "
"``None`` renvoie ``[]``."

#: ../Doc/library/stdtypes.rst:1941
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Renvoie les lignes de la chaîne sous forme de liste, la découpe se fait au "
"niveau des limites des lignes. Les sauts de ligne ne sont pas inclus dans la "
"liste des résultats, sauf si *keepends* est donné, et est vrai."

#: ../Doc/library/stdtypes.rst:1945
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Cette méthode découpe sur les limites de ligne suivantes. Ces limites sont "
"un sur ensemble de :term:`universal newlines`."

#: ../Doc/library/stdtypes.rst:1949
msgid "Representation"
msgstr "Représentation"

#: ../Doc/library/stdtypes.rst:1949
msgid "Description"
msgstr "Description"

#: ../Doc/library/stdtypes.rst:1951
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/library/stdtypes.rst:1951
msgid "Line Feed"
msgstr "Saut de ligne"

#: ../Doc/library/stdtypes.rst:1953
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/library/stdtypes.rst:1953
msgid "Carriage Return"
msgstr "Retour chariot"

#: ../Doc/library/stdtypes.rst:1955
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../Doc/library/stdtypes.rst:1955
msgid "Carriage Return + Line Feed"
msgstr "Retour chariot + saut de ligne"

#: ../Doc/library/stdtypes.rst:1957
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` or ``\\x0b``"

#: ../Doc/library/stdtypes.rst:1957
msgid "Line Tabulation"
msgstr "Tabulation verticale"

#: ../Doc/library/stdtypes.rst:1959
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` or ``\\x0c``"

#: ../Doc/library/stdtypes.rst:1959
msgid "Form Feed"
msgstr "Saut de page"

#: ../Doc/library/stdtypes.rst:1961
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../Doc/library/stdtypes.rst:1961
msgid "File Separator"
msgstr "Séparateur de fichiers"

#: ../Doc/library/stdtypes.rst:1963
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../Doc/library/stdtypes.rst:1963
msgid "Group Separator"
msgstr "Séparateur de groupes"

#: ../Doc/library/stdtypes.rst:1965
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../Doc/library/stdtypes.rst:1965
msgid "Record Separator"
msgstr "Séparateur d'enregistrements"

#: ../Doc/library/stdtypes.rst:1967
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../Doc/library/stdtypes.rst:1967
msgid "Next Line (C1 Control Code)"
msgstr "Ligne suivante (code de contrôle *C1*)"

#: ../Doc/library/stdtypes.rst:1969
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../Doc/library/stdtypes.rst:1969
msgid "Line Separator"
msgstr "Séparateur de ligne"

#: ../Doc/library/stdtypes.rst:1971
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../Doc/library/stdtypes.rst:1971
msgid "Paragraph Separator"
msgstr "Séparateur de paragraphe"

#: ../Doc/library/stdtypes.rst:1976
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` et ``\\f`` ajoutés à la liste des limites de lignes."

#: ../Doc/library/stdtypes.rst:1985
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Contrairement à :meth:`~str.split` lorsque *sep* est fourni, cette méthode "
"renvoie une liste vide pour la chaîne vide, et un saut de ligne à la fin ne "
"se traduit pas par une ligne supplémentaire ::"

#: ../Doc/library/stdtypes.rst:1994
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "À titre de comparaison, ``split('\\n')`` donne ::"

#: ../Doc/library/stdtypes.rst:2004
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Donne ``True`` si la chaîne commence par *prefix*, sinon  ``False``. "
"*prefix* peut aussi être un tuple de préfixes à rechercher. Lorsque *start* "
"est donné, la comparaison commence à cette position, et lorsque *end* est "
"donné, la comparaison s'arrête à celle ci."

#: ../Doc/library/stdtypes.rst:2012
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Donne une copie de la chaîne dont des caractères initiaux et finaux sont "
"supprimés. L'argument *chars* est une chaîne spécifiant le jeu de caractères "
"à supprimer. En cas d'omission ou ``None``, les espaces sont supprimés. "
"L'argument *chars* est pas un préfixe ni un suffixe, toutes les combinaisons "
"de ses valeurs sont supprimées ::"

#: ../Doc/library/stdtypes.rst:2023
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"Les caractères de *char* sont retirés du début et de la fin de la chaîne. "
"Les caractères sont retirés de la gauche jusqu'à atteindre un caractère ne "
"figurant pas dans le jeu de caractères dans *chars*. La même opération à "
"lieu par la droite. Par exemple ::"

#: ../Doc/library/stdtypes.rst:2036
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Renvoie une copie de la chaîne dont les caractères majuscules sont  "
"convertis en minuscules et vice versa. Notez qu'il est pas nécessairement "
"vrai que ``s.swapcase().swapcase() == s``."

#: ../Doc/library/stdtypes.rst:2043
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Renvoie une version en initiales majuscules de la chaîne où les mots "
"commencent par une capitale et les caractères restants sont en minuscules."

#: ../Doc/library/stdtypes.rst:2051 ../Doc/library/stdtypes.rst:3197
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"Pour l'algorithme, la notion de mot est définie simplement et indépendamment "
"de la langue comme un groupe de lettres consécutives. La définition "
"fonctionne dans de nombreux contextes, mais cela signifie que les "
"apostrophes (typiquement de la forme possessive en Anglais) forment les "
"limites de mot, ce qui n'est pas toujours le résultat souhaité ::"

#: ../Doc/library/stdtypes.rst:2059 ../Doc/library/stdtypes.rst:3205
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Une solution pour contourner le problème des apostrophes peut être obtenue "
"en utilisant des expressions rationnelles ::"

#: ../Doc/library/stdtypes.rst:2073
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or :term:"
"`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"Renvoie une copie de la chaîne dans laquelle chaque caractère a été changé "
"selon la table de traduction donnée. La table doit être un objet qui "
"implémente l'indexation via :meth:`__getitem__`, typiquement un :term:"
"`mapping` ou une :term:`sequence`. Pour un ordinal Unicode (un entier), la "
"table peut donner soit un ordinal Unicode ou une chaîne pour faire "
"correspondre un ou plusieurs caractère au caractère donné, soit ``None`` "
"pour supprimer le caractère de la chaîne de renvoyée soit lever une "
"exception :exc:`LookupError` pour ne pas changer le caractère."

#: ../Doc/library/stdtypes.rst:2082
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"Vous pouvez utiliser :meth:`str.maketrans` pour créer une table de "
"correspondances de caractères dans différents formats."

#: ../Doc/library/stdtypes.rst:2085
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Voir aussi le module :mod:`codecs` pour une approche plus souple de "
"changements de caractères par correspondance."

#: ../Doc/library/stdtypes.rst:2091
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Renvoie une copie de la chaîne où tous les caractères capitalisables [4]_ "
"ont été convertis en capitales. Notez que ``s.upper().isupper()`` peut être "
"``False`` si ``s`` contient des caractères non capitalisables ou si la "
"catégorie Unicode d'un caractère du résultat n'est pas \"Lu\" (*Letter*, "
"*uppercase*), mais par exemple \"Lt\" (*Letter*, *titlecase*)."

#: ../Doc/library/stdtypes.rst:2097
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"L'algorithme de capitalisation utilisé est décrit dans la section 3.13 de la "
"norme Unicode."

#: ../Doc/library/stdtypes.rst:2103
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Renvoie une copie de la chaîne remplie par la gauche du chiffre (le "
"caractère ASCII) ``'0'`` pour faire une chaîne de longueur *width*. Un "
"préfixe (``'+'`` / ``'-'``) est permis par l'insertion du caractère de "
"rembourrage *après* le caractère désigne plutôt qu'avant. La chaîne "
"d'origine est renvoyée si *width* est inférieur ou égale à ``len(s)``."

#: ../Doc/library/stdtypes.rst:2121
msgid "``printf``-style String Formatting"
msgstr "Formatage de chaines à la ``printf``"

#: ../Doc/library/stdtypes.rst:2134
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""
"Ces opérations de mise en forme contiennent des bizarreries menant à de "
"nombreuses erreurs classiques (telles que ne pas réussir à afficher des "
"*tuples* ou des dictionnaires correctement).  Utiliser les :ref:`formatted "
"string literals <f-strings>`, la méthode :meth:`str.format` ou les :ref:"
"`template strings <template-strings>` aide à éviter ces erreurs.  Chacune de "
"ces alternatives apporte son lot d'avantages et inconvénients en matière de "
"simplicité, de flexibilité et/ou de généralisation possible."

#: ../Doc/library/stdtypes.rst:2142
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"Les objets *str* n'exposent qu'une opération : L'opérateur ``%`` (modulo). "
"Aussi connu sous le nom d'opérateur de formatage, ou opérateur "
"d'interpolation. Étant donné ``format % values`` (où *format* est une "
"chaîne),  les marqueurs ``%`` de *format* sont remplacés par zéro ou "
"plusieurs éléments de *values*. L'effet est similaire à la fonction :c:func:"
"`sprintf` du langage C."

#: ../Doc/library/stdtypes.rst:2148
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Si *format* ne nécessite qu'un seul argument, *values* peut être un objet "
"unique. [5]_ Si *values* est un tuple, il doit contenir exactement le nombre "
"d'éléments spécifiés par la chaîne de format, ou un seul objet de "
"correspondances ( *mapping object*, par exemple, un dictionnaire)."

#: ../Doc/library/stdtypes.rst:2158 ../Doc/library/stdtypes.rst:3308
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Un indicateur de conversion contient deux ou plusieurs caractères et "
"comporte les éléments suivants, qui doivent apparaître dans cet ordre :"

#: ../Doc/library/stdtypes.rst:2161 ../Doc/library/stdtypes.rst:3311
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Le caractère ``'%'``, qui marque le début du marqueur."

#: ../Doc/library/stdtypes.rst:2163 ../Doc/library/stdtypes.rst:3313
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"La clé de correspondance (facultative), composée d'une suite de caractères "
"entre parenthèse (par exemple, ``(somename)``)."

#: ../Doc/library/stdtypes.rst:2166 ../Doc/library/stdtypes.rst:3316
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Des options de conversion, facultatives, qui affectent le résultat de "
"certains types de conversion."

#: ../Doc/library/stdtypes.rst:2169 ../Doc/library/stdtypes.rst:3319
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Largeur minimum (facultative). Si elle vaut ``'*'`` (astérisque), la largeur "
"est lue de l'élément suivant du tuple *values*, et l'objet à convertir vient "
"après la largeur de champ minimale et la précision facultative."

#: ../Doc/library/stdtypes.rst:2173 ../Doc/library/stdtypes.rst:3323
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Précision (facultatif), donnée sous la forme d'un ``'.'`` (point) suivi de "
"la précision. Si la précision est ``'*'`` (un astérisque), la précision est "
"lue à partir de l'élément suivant du tuple *values* et la valeur à convertir "
"vient ensuite."

#: ../Doc/library/stdtypes.rst:2178 ../Doc/library/stdtypes.rst:3328
msgid "Length modifier (optional)."
msgstr "Modificateur de longueur (facultatif)."

#: ../Doc/library/stdtypes.rst:2180 ../Doc/library/stdtypes.rst:3330
msgid "Conversion type."
msgstr "Type de conversion."

#: ../Doc/library/stdtypes.rst:2182
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Lorsque l'argument de droite est un dictionnaire (ou un autre type de "
"*mapping*), les marqueurs dans la chaîne *doivent* inclure une clé présente "
"dans le dictionnaire, écrite entre parenthèses,  immédiatement après le "
"caractère ``'%'``. La clé indique quelle valeur du dictionnaire doit être "
"formatée. Par exemple :"

#: ../Doc/library/stdtypes.rst:2191 ../Doc/library/stdtypes.rst:3341
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"Dans ce cas, aucune ``*`` ne peuvent se trouver dans le format (car ces "
"``*`` nécessitent une liste (accès séquentiel) de paramètres)."

#: ../Doc/library/stdtypes.rst:2194 ../Doc/library/stdtypes.rst:3344
msgid "The conversion flag characters are:"
msgstr "Les caractères indicateurs de conversion sont :"

#: ../Doc/library/stdtypes.rst:2203 ../Doc/library/stdtypes.rst:3353
msgid "Flag"
msgstr "Option"

#: ../Doc/library/stdtypes.rst:2205 ../Doc/library/stdtypes.rst:3355
msgid "``'#'``"
msgstr "``'#'``"

#: ../Doc/library/stdtypes.rst:2205 ../Doc/library/stdtypes.rst:3355
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr "La conversion utilisera la \"forme alternative\" (définie ci-dessous)."

#: ../Doc/library/stdtypes.rst:2208 ../Doc/library/stdtypes.rst:3358
msgid "``'0'``"
msgstr "``'0'``"

#: ../Doc/library/stdtypes.rst:2208 ../Doc/library/stdtypes.rst:3358
msgid "The conversion will be zero padded for numeric values."
msgstr "Les valeurs numériques converties seront complétée de zéros."

#: ../Doc/library/stdtypes.rst:2210 ../Doc/library/stdtypes.rst:3360
msgid "``'-'``"
msgstr "``'-'``"

#: ../Doc/library/stdtypes.rst:2210 ../Doc/library/stdtypes.rst:3360
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"La valeur convertie est ajustée à gauche (remplace la conversion ``'0'`` si "
"les deux sont données)."

#: ../Doc/library/stdtypes.rst:2213 ../Doc/library/stdtypes.rst:3363
msgid "``' '``"
msgstr "``' '``"

#: ../Doc/library/stdtypes.rst:2213 ../Doc/library/stdtypes.rst:3363
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(un espace) Un espace doit être laissé avant un nombre positif (ou chaîne "
"vide) produite par la conversion d'une valeur signée."

#: ../Doc/library/stdtypes.rst:2216 ../Doc/library/stdtypes.rst:3366
msgid "``'+'``"
msgstr "``'+'``"

#: ../Doc/library/stdtypes.rst:2216 ../Doc/library/stdtypes.rst:3366
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Un caractère de signe (``'+'`` ou ``'-'``) précède la valeur convertie "
"(remplace le marqueur \"espace\")."

#: ../Doc/library/stdtypes.rst:2220 ../Doc/library/stdtypes.rst:3370
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Un modificateur de longueur (``h``, ``l`` ou ``L``) peut être présent, mais "
"est ignoré car il est pas nécessaire pour Python, donc par exemple ``%ld`` "
"est identique à ``%d``."

#: ../Doc/library/stdtypes.rst:2223 ../Doc/library/stdtypes.rst:3373
msgid "The conversion types are:"
msgstr "Les types utilisables dans les conversion sont :"

#: ../Doc/library/stdtypes.rst:2226 ../Doc/library/stdtypes.rst:3376
msgid "Conversion"
msgstr "Conversion"

#: ../Doc/library/stdtypes.rst:2228 ../Doc/library/stdtypes.rst:3378
msgid "``'d'``"
msgstr "``'d'``"

#: ../Doc/library/stdtypes.rst:2228 ../Doc/library/stdtypes.rst:2230
#: ../Doc/library/stdtypes.rst:3378 ../Doc/library/stdtypes.rst:3380
msgid "Signed integer decimal."
msgstr "Entier décimal signé."

#: ../Doc/library/stdtypes.rst:2230 ../Doc/library/stdtypes.rst:3380
msgid "``'i'``"
msgstr "``'i'``"

#: ../Doc/library/stdtypes.rst:2232 ../Doc/library/stdtypes.rst:3382
msgid "``'o'``"
msgstr "``'o'``"

#: ../Doc/library/stdtypes.rst:2232 ../Doc/library/stdtypes.rst:3382
msgid "Signed octal value."
msgstr "Valeur octale signée."

#: ../Doc/library/stdtypes.rst:2234 ../Doc/library/stdtypes.rst:3384
msgid "``'u'``"
msgstr "``'u'``"

#: ../Doc/library/stdtypes.rst:2234 ../Doc/library/stdtypes.rst:3384
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Type obsolète — identique à ``'d'``."

#: ../Doc/library/stdtypes.rst:2236 ../Doc/library/stdtypes.rst:3386
msgid "``'x'``"
msgstr "``'x'``"

#: ../Doc/library/stdtypes.rst:2236 ../Doc/library/stdtypes.rst:3386
msgid "Signed hexadecimal (lowercase)."
msgstr "Hexadécimal signé (en minuscules)."

#: ../Doc/library/stdtypes.rst:2238 ../Doc/library/stdtypes.rst:3388
msgid "``'X'``"
msgstr "``'X'``"

#: ../Doc/library/stdtypes.rst:2238 ../Doc/library/stdtypes.rst:3388
msgid "Signed hexadecimal (uppercase)."
msgstr "Hexadécimal signé (capitales)."

#: ../Doc/library/stdtypes.rst:2240 ../Doc/library/stdtypes.rst:3390
msgid "``'e'``"
msgstr "``'e'``"

#: ../Doc/library/stdtypes.rst:2240 ../Doc/library/stdtypes.rst:3390
msgid "Floating point exponential format (lowercase)."
msgstr "Format exponentiel pour un *float* (minuscule)."

#: ../Doc/library/stdtypes.rst:2242 ../Doc/library/stdtypes.rst:3392
msgid "``'E'``"
msgstr "``'E'``"

#: ../Doc/library/stdtypes.rst:2242 ../Doc/library/stdtypes.rst:3392
msgid "Floating point exponential format (uppercase)."
msgstr "Format exponentiel pour un *float* (en capitales)."

#: ../Doc/library/stdtypes.rst:2244 ../Doc/library/stdtypes.rst:3394
msgid "``'f'``"
msgstr "``'f'``"

#: ../Doc/library/stdtypes.rst:2244 ../Doc/library/stdtypes.rst:2246
#: ../Doc/library/stdtypes.rst:3394 ../Doc/library/stdtypes.rst:3396
msgid "Floating point decimal format."
msgstr "Format décimal pour un *float*."

#: ../Doc/library/stdtypes.rst:2246 ../Doc/library/stdtypes.rst:3396
msgid "``'F'``"
msgstr "``'F'``"

#: ../Doc/library/stdtypes.rst:2248 ../Doc/library/stdtypes.rst:3398
msgid "``'g'``"
msgstr "``'g'``"

#: ../Doc/library/stdtypes.rst:2248 ../Doc/library/stdtypes.rst:3398
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Format *float*. Utilise le format exponentiel minuscules si l'exposant est "
"inférieur à ``-4`` ou pas plus petit que la précision, sinon le format "
"décimal."

#: ../Doc/library/stdtypes.rst:2252 ../Doc/library/stdtypes.rst:3402
msgid "``'G'``"
msgstr "``'G'``"

#: ../Doc/library/stdtypes.rst:2252 ../Doc/library/stdtypes.rst:3402
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Format *float*. Utilise le format exponentiel en capitales si l'exposant est "
"inférieur à ``-4`` ou pas plus petit que la précision, sinon le format "
"décimal."

#: ../Doc/library/stdtypes.rst:2256 ../Doc/library/stdtypes.rst:3406
msgid "``'c'``"
msgstr "``'c'``"

#: ../Doc/library/stdtypes.rst:2256
msgid "Single character (accepts integer or single character string)."
msgstr ""
"Un seul caractère (accepte des entiers ou une chaîne d'un seul caractère)."

#: ../Doc/library/stdtypes.rst:2259 ../Doc/library/stdtypes.rst:3419
msgid "``'r'``"
msgstr "``'r'``"

#: ../Doc/library/stdtypes.rst:2259
msgid "String (converts any Python object using :func:`repr`)."
msgstr "String (convertit n'importe quel objet Python avec :func:`repr`)."

#: ../Doc/library/stdtypes.rst:2262 ../Doc/library/stdtypes.rst:3413
msgid "``'s'``"
msgstr "``'s'``"

#: ../Doc/library/stdtypes.rst:2262
msgid "String (converts any Python object using :func:`str`)."
msgstr "String (convertit n'importe quel objet Python avec :func:`str`)."

#: ../Doc/library/stdtypes.rst:2265 ../Doc/library/stdtypes.rst:3416
msgid "``'a'``"
msgstr "``'a'``"

#: ../Doc/library/stdtypes.rst:2265
msgid "String (converts any Python object using :func:`ascii`)."
msgstr ""
"String (convertit n'importe quel objet Python en utilisant :func:`ascii`)."

#: ../Doc/library/stdtypes.rst:2268 ../Doc/library/stdtypes.rst:3422
msgid "``'%'``"
msgstr "``'%'``"

#: ../Doc/library/stdtypes.rst:2268 ../Doc/library/stdtypes.rst:3422
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Aucun argument n'est converti, donne un caractère de ``'%'`` dans le "
"résultat."

#: ../Doc/library/stdtypes.rst:2275 ../Doc/library/stdtypes.rst:3429
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"La forme alternative entraîne l'insertion d'un préfixe octal (``'0o'``) "
"avant le premier chiffre."

#: ../Doc/library/stdtypes.rst:2279 ../Doc/library/stdtypes.rst:3433
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"La forme alternative entraîne l'insertion d'un préfixe ``'0x'`` ou ``'0X'`` "
"(respectivement pour les formats ``'x'`` et ``'X'``) avant le premier "
"chiffre."

#: ../Doc/library/stdtypes.rst:2283 ../Doc/library/stdtypes.rst:3437
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"La forme alternative implique la présence d'un point décimal, même si aucun "
"chiffre ne le suit."

#: ../Doc/library/stdtypes.rst:2286 ../Doc/library/stdtypes.rst:3440
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"La précision détermine le nombre de chiffres après la virgule, 6 par défaut."

#: ../Doc/library/stdtypes.rst:2290 ../Doc/library/stdtypes.rst:3444
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"La forme alternative implique la présence d'un point décimal et les zéros "
"non significatifs sont conservés (ils ne le seraient pas autrement)."

#: ../Doc/library/stdtypes.rst:2293 ../Doc/library/stdtypes.rst:3447
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"La précision détermine le nombre de chiffres significatifs avant et après la "
"virgule. 6 par défaut."

#: ../Doc/library/stdtypes.rst:2297 ../Doc/library/stdtypes.rst:3451
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Si la précision est ``N``, la sortie est tronquée à ``N`` caractères."

#: ../Doc/library/stdtypes.rst:2300 ../Doc/library/stdtypes.rst:3460
msgid "See :pep:`237`."
msgstr "Voir la :pep:`237`."

#: ../Doc/library/stdtypes.rst:2302
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Puisque les chaînes Python ont une longueur explicite, les conversions ``"
"%s`` ne considèrent pas ``'\\0'`` comme la fin de la chaîne."

#: ../Doc/library/stdtypes.rst:2307
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"Les conversions ``%f`` pour nombres dont la valeur absolue est supérieure à "
"``1e50`` ne sont plus remplacés par des conversions ``%g``."

#: ../Doc/library/stdtypes.rst:2318
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Séquences Binaires --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"

#: ../Doc/library/stdtypes.rst:2326
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"Les principaux types natifs pour manipuler des données binaires sont :class:"
"`bytes` et :class:`bytearray`. Ils sont supportés par :class:`memoryview` "
"qui utilise le :ref:`buffer protocol <bufferobjects>` pour accéder à la "
"mémoire d'autres objets binaires sans avoir besoin d'en faire une copie."

#: ../Doc/library/stdtypes.rst:2331
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"Le module :mod:`array` permet le stockage efficace de types basiques comme "
"les entiers de 32 bits et les *float* double précision IEEE754."

#: ../Doc/library/stdtypes.rst:2337
msgid "Bytes Objects"
msgstr "Objets *bytes*"

#: ../Doc/library/stdtypes.rst:2341
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Les *bytes* sont des séquences immuables d'octets. Comme beaucoup de "
"protocoles binaires utilisent l'ASCII, les objets *bytes* offrent plusieurs "
"méthodes qui ne sont valables que lors de la manipulation de données ASCII "
"et sont étroitement liés aux objets *str* dans bien d'autres aspects."

#: ../Doc/library/stdtypes.rst:2348
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"Tout d'abord, la syntaxe des *bytes* littéraux est en grande partie la même "
"que pour les chaînes littérales, en dehors du préfixe ``b`` :"

#: ../Doc/library/stdtypes.rst:2351
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr ""
"Les guillemets simples : ``b'autorisent aussi les guillemets \"doubles\"'``"

#: ../Doc/library/stdtypes.rst:2352
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``."
msgstr ""
"Les guillemets doubles : ``b\"permettent aussi les guillemets 'simples'\"``."

#: ../Doc/library/stdtypes.rst:2353
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Les guillemets triples : ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes"
"\"\"\"``"

#: ../Doc/library/stdtypes.rst:2355
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"Seuls les caractères ASCII sont autorisés dans les littéraux de *bytes* "
"(quel que soit l'encodage du code source déclaré). Toutes les valeurs au "
"delà de 127 doivent être entrés dans littéraux de *bytes* en utilisant une "
"séquence d'échappement appropriée."

#: ../Doc/library/stdtypes.rst:2359
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Comme avec les chaînes littérales, les *bytes* littéraux peuvent également "
"utiliser un préfixe ``r`` pour désactiver le traitement des séquences "
"d'échappement. Voir :ref:`strings` pour plus d'informations sur les "
"différentes formes littérales de *bytes*, y compris les séquences "
"d'échappement supportées."

#: ../Doc/library/stdtypes.rst:2363
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"Bien que les *bytes* littéraux, et leurs représentation, soient basés sur du "
"texte ASCII, les *bytes* se comportent en fait comme des séquences immuables "
"de nombres entiers, dont les valeurs sont restreintes dans ``0 <= x < 256`` "
"(ne pas respecter cette restriction lève une :exc:`ValueError`. Ceci est "
"fait délibérément afin de souligner que, bien que de nombreux encodages "
"binaires soient compatibles avec l'ASCII, et peuvent être manipulés avec des "
"algorithmes orientés texte, ce n'est généralement pas le cas pour les "
"données binaires arbitraires (appliquer aveuglément des algorithmes de texte "
"sur des données binaires qui ne sont pas compatibles ASCII conduit "
"généralement à leur corruption)."

#: ../Doc/library/stdtypes.rst:2373
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"En plus des formes littérales, des objets *bytes* peuvent être créés par de "
"nombreux moyens :"

#: ../Doc/library/stdtypes.rst:2376
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr ""
"Un objet *bytes* rempli de zéros d'une longueur spécifiée : ``bytes(10)``"

#: ../Doc/library/stdtypes.rst:2377
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "D'un itérable d'entiers : ``bytes(range(20))``"

#: ../Doc/library/stdtypes.rst:2378
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Copier des données binaires existantes via le *buffer protocol* : "
"``bytes(obj)``"

#: ../Doc/library/stdtypes.rst:2380
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Voir aussi la fonction native :ref:`bytes <func-bytes>`."

#: ../Doc/library/stdtypes.rst:2382
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Puisque 2 chiffres hexadécimaux correspondent précisément à un seul octet, "
"les nombres hexadécimaux sont un format couramment utilisé pour décrire les "
"données binaires. Par conséquent, le type *bytes* a une méthode de classe "
"pour lire des données dans ce format :"

#: ../Doc/library/stdtypes.rst:2388
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Cette méthode de la classe :class:`bytes` renvoie un objet *bytes*, décodant "
"la chaîne donnée.  La chaîne doit contenir deux chiffres hexadécimaux par "
"octet, les espaces ASCII sont ignorés."

#: ../Doc/library/stdtypes.rst:2395
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytes.fromhex` saute maintenant dans la chaîne tous les caractères "
"ASCII \"blancs\", pas seulement les espaces."

#: ../Doc/library/stdtypes.rst:2399
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Une fonction de conversion inverse existe pour transformer un objet *bytes* "
"en sa représentation hexadécimale."

#: ../Doc/library/stdtypes.rst:2404 ../Doc/library/stdtypes.rst:2498
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Renvoie une chaîne contenant deux chiffres hexadécimaux pour chaque octet du "
"*byte*."

#: ../Doc/library/stdtypes.rst:2410
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default "
"between each byte.  A second optional *bytes_per_sep* parameter controls the "
"spacing.  Positive values calculate the separator position from the right, "
"negative values from the left."
msgstr ""

#: ../Doc/library/stdtypes.rst:2426
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""

#: ../Doc/library/stdtypes.rst:2430
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Comme les objets *bytes* sont des séquences d'entiers (semblables à un "
"tuple), pour une instance de *bytes* *b*, ``b[0]`` sera un entier, tandis "
"que``b[0:1]`` sera un objet *bytes* de longueur 1. (Cela contraste avec les "
"chaînes, où l'indexation et le *slicing* donne une chaîne de longueur 1)"

#: ../Doc/library/stdtypes.rst:2435
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"La représentation des *bytes* utilise le format littéral (``b'...'``) car il "
"est souvent plus utile que par exemple ``bytes([46, 46, 46])``. Vous pouvez "
"toujours convertir un *bytes* en liste d'entiers en utilisant ``list(b)``."

#: ../Doc/library/stdtypes.rst:2440
msgid ""
"For Python 2.x users: In the Python 2.x series, a variety of implicit "
"conversions between 8-bit strings (the closest thing 2.x offers to a built-"
"in binary data type) and Unicode strings were permitted. This was a "
"backwards compatibility workaround to account for the fact that Python "
"originally only supported 8-bit text, and Unicode text was a later addition. "
"In Python 3.x, those implicit conversions are gone - conversions between 8-"
"bit binary data and Unicode text must be explicit, and bytes and string "
"objects will always compare unequal."
msgstr ""
"Pour les utilisateurs de Python 2.x : Dans la série 2.x de Python, une "
"variété de conversions implicites entre les chaînes 8-bit (la chose la plus "
"proche d'un type natif de données binaires offert par Python 2)  et des "
"chaînes Unicode étaient permises. C'était une solution de contournement, "
"pour garder la rétro-compatibilité, considérant que Python ne prenait "
"initialement en charge que le texte 8 bits, le texte Unicode est un ajout "
"ultérieur. En Python 3.x, ces conversions implicites ont disparues, les "
"conversions entre les données binaires et texte Unicode doivent être "
"explicites, et les *bytes* sont toujours différents des chaînes."

#: ../Doc/library/stdtypes.rst:2453
msgid "Bytearray Objects"
msgstr "Objets *bytearray*"

#: ../Doc/library/stdtypes.rst:2457
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
"Les objets :class:`bytearray` sont l'équivalent muable des objets :class:"
"`bytes`."

#: ../Doc/library/stdtypes.rst:2462
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Il n'y a pas de syntaxe littérale dédiée aux *bytearray*, ils sont toujours "
"créés en appelant le constructeur :"

#: ../Doc/library/stdtypes.rst:2465
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Créer une instance vide: ``bytearray()``"

#: ../Doc/library/stdtypes.rst:2466
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""
"Créer une instance remplie de zéros d'une longueur donnée : ``bytearray(10)``"

#: ../Doc/library/stdtypes.rst:2467
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "À partir d'un itérable d'entiers : ``bytearray(range(20))``"

#: ../Doc/library/stdtypes.rst:2468
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Copie des données binaires existantes via le *buffer protocol* : "
"``bytearray(b'Hi!')``"

#: ../Doc/library/stdtypes.rst:2470
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Comme les *bytearray* sont muables, ils prennent en charge les opérations de "
"séquence :ref:`muables <typesseq-mutable>` en plus des opérations communes "
"de *bytes* et *bytearray* décrites dans :ref:`bytes-methods`."

#: ../Doc/library/stdtypes.rst:2474
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "Voir aussi la fonction native :ref:`bytearray <func-bytearray>`."

#: ../Doc/library/stdtypes.rst:2476
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Puisque 2 chiffres hexadécimaux correspondent précisément à un octet, les "
"nombres hexadécimaux sont un format couramment utilisé pour décrire les "
"données binaires. Par conséquent, le type *bytearray* a une méthode de "
"classe pour lire les données dans ce format :"

#: ../Doc/library/stdtypes.rst:2482
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Cette méthode de la classe :class:`bytearray` renvoie un objet *bytearray*, "
"décodant la chaîne donnée.  La chaîne doit contenir deux chiffres "
"hexadécimaux par octet, les espaces ASCII sont ignorés."

#: ../Doc/library/stdtypes.rst:2489
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
":meth:`bytearray.fromhex` saute maintenant tous les caractères \"blancs\" "
"ASCII dans la chaîne, pas seulement les espaces."

#: ../Doc/library/stdtypes.rst:2493
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"Une fonction de conversion inverse existe pour transformer un objet "
"*bytearray* en sa représentation hexadécimale."

#: ../Doc/library/stdtypes.rst:2506
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Comme les *bytearray* sont des séquences d'entiers (semblables à une liste), "
"pour un objet *bytearray* *b*, ``b[0]`` sera un entier, tandis que "
"``b[0:1]`` sera un objet *bytearray* de longueur 1. (Ceci contraste avec les "
"chaînes de texte, où l'indexation et le *slicing* produit une chaîne de "
"longueur 1)"

#: ../Doc/library/stdtypes.rst:2511
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"La représentation des objets *bytearray* utilise le format littéral des "
"*bytes* (``bytearray(b'...')``) car il est souvent plus utile que par "
"exemple ``bytearray([46, 46, 46])``. Vous pouvez toujours convertir un objet "
"*bytearray* en une liste de nombres entiers en utilisant ``list(b)``."

#: ../Doc/library/stdtypes.rst:2520
msgid "Bytes and Bytearray Operations"
msgstr "Opérations sur les *bytes* et *bytearray*"

#: ../Doc/library/stdtypes.rst:2525
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"*bytes* et *bytearray* prennent en charge les opérations :ref:`communes "
"<typesseq-common>` des séquences. Ils interagissent non seulement avec des "
"opérandes de même type, mais aussi avec les :term:`bytes-like object`. En "
"raison de cette flexibilité, ils peuvent être mélangés librement dans  des "
"opérations sans provoquer d'erreurs. Cependant, le type du résultat peut "
"dépendre de l'ordre des opérandes."

#: ../Doc/library/stdtypes.rst:2533
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"Les méthodes sur les *bytes* et les *bytearray* n'acceptent pas les chaînes "
"comme arguments, tout comme les méthodes sur les chaînes n'acceptent pas les "
"*bytes* comme arguments. Par exemple, vous devez écrire ::"

#: ../Doc/library/stdtypes.rst:2540
msgid "and::"
msgstr "et ::"

#: ../Doc/library/stdtypes.rst:2545
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Quelques opérations de *bytes* et *bytesarray* supposent l'utilisation de "
"formats binaires compatibles ASCII, et donc doivent être évités lorsque vous "
"travaillez avec des données binaires arbitraires. Ces restrictions sont "
"couvertes ci-dessous."

#: ../Doc/library/stdtypes.rst:2550
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"Utiliser ces opérations basées sur l'ASCII pour manipuler des données "
"binaires qui ne sont pas au format ASCII peut les corrompre."

#: ../Doc/library/stdtypes.rst:2553
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"Les méthodes suivantes sur les *bytes* et *bytearray* peuvent être utilisées "
"avec des données binaires arbitraires."

#: ../Doc/library/stdtypes.rst:2559
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Renvoie le nombre d'occurrences qui ne se chevauchent pas de la  sous-"
"séquence *sub* dans l'intervalle [*start*, *end*]. Les arguments facultatifs "
"*start* et *end* sont interprétés comme pour un *slice*."

#: ../Doc/library/stdtypes.rst:2563 ../Doc/library/stdtypes.rst:2610
#: ../Doc/library/stdtypes.rst:2632 ../Doc/library/stdtypes.rst:2698
#: ../Doc/library/stdtypes.rst:2711
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"La sous-séquence à rechercher peut être un quelconque :term:`bytes-like "
"object` ou un nombre entier compris entre 0 et 255."

#: ../Doc/library/stdtypes.rst:2566 ../Doc/library/stdtypes.rst:2622
#: ../Doc/library/stdtypes.rst:2635 ../Doc/library/stdtypes.rst:2701
#: ../Doc/library/stdtypes.rst:2714
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""
"Accepte aussi un nombre entier compris entre 0 et 255 comme sous-séquence."

#: ../Doc/library/stdtypes.rst:2573
msgid ""
"Return a string decoded from the given bytes.  Default encoding is "
"``'utf-8'``. *errors* may be given to set a different error handling "
"scheme.  The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`.  Other possible values are ``'ignore'``, "
"``'replace'`` and any other name registered via :func:`codecs."
"register_error`, see section :ref:`error-handlers`. For a list of possible "
"encodings, see section :ref:`standard-encodings`."
msgstr ""
"Décode les octets donnés, et le renvoie sous forme d'une chaîne de "
"caractères. L'encodage par défaut est ``'utf-8'``. *errors* peut être donné "
"pour changer de système de gestion des erreurs. Sa valeur par défaut est "
"``'strict'``, ce qui signifie que les erreurs d'encodage lèvent une :exc:"
"`UnicodeError`. Les autres valeurs possibles sont ``'ignore'``, "
"``'replace'`` et tout autre nom enregistré via :func:`codecs."
"register_error`, voir la section :ref:`error-handlers`. Pour une liste des "
"encodages possibles, voir la section :ref:`standard-encodings`."

#: ../Doc/library/stdtypes.rst:2583
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary bytes or "
"bytearray object."
msgstr ""
"Passer l'argument *encoding* à :class:`str` permet de décoder tout :term:"
"`bytes-like object` directement, sans avoir besoin d'utiliser un *bytes* ou "
"*bytearray* temporaire."

#: ../Doc/library/stdtypes.rst:2587
msgid "Added support for keyword arguments."
msgstr "Gère les arguments nommés."

#: ../Doc/library/stdtypes.rst:2594
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Donne ``True`` si les octets se terminent par *suffix*, sinon ``False``. "
"*suffix* peut aussi être un tuple de suffixes à rechercher. Avec l'argument "
"optionnel *start*, la recherche se fait à partir de cette position. Avec "
"l'argument optionnel *end*, la comparaison s'arrête à cette position."

#: ../Doc/library/stdtypes.rst:2599
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Les suffixes à rechercher peuvent être n'importe quel :term:`bytes-like "
"object`."

#: ../Doc/library/stdtypes.rst:2605
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Donne la première position où le *sub* se trouve dans les données,  de telle "
"sorte que *sub* soit contenue dans ``s[start:end]``. Les arguments "
"facultatifs *start* et *end* sont interprétés comme dans la notation des "
"*slices*. Donne ``-1`` si *sub* n'est pas trouvé."

#: ../Doc/library/stdtypes.rst:2615
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"La méthode :meth:`~bytes.find` ne doit être utilisée que si vous avez besoin "
"de connaître la position de *sub*. Pour vérifier si *sub* est présent ou "
"non, utilisez l'opérateur :keyword:`in` ::"

#: ../Doc/library/stdtypes.rst:2629
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Comme :meth:`~bytes.find`, mais lève une :exc:`ValueError` lorsque la "
"séquence est introuvable."

#: ../Doc/library/stdtypes.rst:2642
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Donne un *bytes* ou *bytearray* qui est la concaténation des séquences de "
"données binaires dans *iterable*.  Une exception :exc:`TypeError` est levée "
"si une valeur d'*iterable* n'est pas un :term:`bytes-like objects <bytes-"
"like object>`, y compris pour des :class:`str`.  Le séparateur entre les "
"éléments est le contenu du *bytes* ou du *bytearray* depuis lequel cette "
"méthode est appelée."

#: ../Doc/library/stdtypes.rst:2653
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Cette méthode statique renvoie une table de traduction utilisable par :meth:"
"`bytes.translate` qui permettra de changer chaque caractère de *from* par un "
"caractère à la même position dans *to*; *from* et *to* doivent tous deux "
"être des :term:`bytes-like objects <bytes-like object>` et avoir la même "
"longueur."

#: ../Doc/library/stdtypes.rst:2664
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"Divise la séquence à la première occurrence de *sep*, et renvoie un 3-tuple "
"contenant la partie précédant le séparateur, le séparateur lui même (ou sa "
"copie en *byterray*), et la partie suivant le séparateur. Si le séparateur "
"est pas trouvé, le 3-tuple renvoyé contiendra une copie de la séquence "
"d'origine, suivi de deux *bytes* ou *bytearray* vides."

#: ../Doc/library/stdtypes.rst:2671 ../Doc/library/stdtypes.rst:2728
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr "Le séparateur à rechercher peut être tout :term:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2677
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Renvoie une copie de la séquence dont toutes les occurrences de la sous-"
"séquence *old* sont remplacées par *new*. Si l'argument optionnel *count* "
"est donné, seules les *count* premières occurrences de sont remplacés."

#: ../Doc/library/stdtypes.rst:2681
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"La sous-séquence à rechercher et son remplacement peuvent être  n'importe "
"quel :term:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2686 ../Doc/library/stdtypes.rst:2779
#: ../Doc/library/stdtypes.rst:2793 ../Doc/library/stdtypes.rst:2817
#: ../Doc/library/stdtypes.rst:2831 ../Doc/library/stdtypes.rst:2866
#: ../Doc/library/stdtypes.rst:2936 ../Doc/library/stdtypes.rst:2954
#: ../Doc/library/stdtypes.rst:2982 ../Doc/library/stdtypes.rst:3121
#: ../Doc/library/stdtypes.rst:3176 ../Doc/library/stdtypes.rst:3219
#: ../Doc/library/stdtypes.rst:3240 ../Doc/library/stdtypes.rst:3262
#: ../Doc/library/stdtypes.rst:3464
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"La version *bytearray* de cette méthode *ne modifie pas* les octets,  elle "
"produit toujours un nouvel objet, même si aucune modification n'a été "
"effectuée."

#: ../Doc/library/stdtypes.rst:2693
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Donne la plus grande position de *sub* dans la séquence, de telle sorte que "
"*sub* soit dans ``s[start:end]``. Les arguments facultatifs *start* et *end* "
"sont interprétés comme dans la notation des *slices*. Donne ``-1`` si *sub* "
"n'est pas trouvable."

#: ../Doc/library/stdtypes.rst:2708
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Semblable à :meth:`~bytes.rfind` mais lève une :exc:`ValueError` lorsque "
"*sub* est introuvable."

#: ../Doc/library/stdtypes.rst:2721
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"Coupe la séquence à la dernière occurrence de *sep*, et renvoie un triplet "
"de trois éléments contenant la partie précédent le séparateur, le séparateur "
"lui même (ou sa copie, un *bytearray*), et la partie suivant le séparateur. "
"Si le séparateur n'est pas trouvé, le triplet contiendra deux *bytes* ou "
"*bytesarray* vides suivi d’une copie de la séquence d'origine."

#: ../Doc/library/stdtypes.rst:2734
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Donne ``True`` si les données binaires commencent par le *prefix* spécifié, "
"sinon ``False``. *prefix* peut aussi être un tuple de préfixes à rechercher. "
"Avec l'argument *start* la recherche commence à cette position. Avec "
"l'argument *end* option, la recherche s'arrête à cette position."

#: ../Doc/library/stdtypes.rst:2739
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Le préfixe(s) à rechercher peuvent être n'importe quel :term:`bytes-like "
"object`."

#: ../Doc/library/stdtypes.rst:2745
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Renvoie une copie du *bytes* ou *bytearray* dont tous les octets de  "
"*delete* sont supprimés, et les octets restants changés par la table de "
"correspondance donnée, qui doit être un objet *bytes* d'une longueur de 256."

#: ../Doc/library/stdtypes.rst:2750
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Vous pouvez utiliser la méthode :func:`bytes.maketrans` pour créer une table "
"de correspondance."

#: ../Doc/library/stdtypes.rst:2753
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Donnez ``None`` comme *table* pour seulement supprimer des caractères ::"

#: ../Doc/library/stdtypes.rst:2759
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* est maintenant accepté comme argument nommé."

#: ../Doc/library/stdtypes.rst:2763
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"Les méthodes suivantes sur les *bytes* et *bytearray* supposent  par défaut "
"que les données traitées sont compatibles ASCII, mais  peuvent toujours être "
"utilisées avec des données binaires, arbitraires, en passant des arguments "
"appropriés.  Notez que toutes les méthodes de *bytearray* de cette section "
"ne travaillent jamais sur l'objet lui même, mais renvoient un nouvel objet."

#: ../Doc/library/stdtypes.rst:2772
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Renvoie une copie de l'objet centrée dans une séquence de longueur *width*. "
"Le remplissage est fait en utilisant *fillbyte* (qui par défaut est un "
"espace ASCII). Pour les objets :class:`bytes`, la séquence initiale est "
"renvoyée si *width* est inférieur ou égal à ``len(s)``."

#: ../Doc/library/stdtypes.rst:2786
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Renvoie une copie de l'objet aligné à gauche dans une séquence de longueur "
"*width*. Le remplissage est fait en utilisant *fillbyte* (par défaut un "
"espace ASCII). Pour les objets :class:`bytes`, la séquence initiale est "
"renvoyée si *width* est inférieure ou égale à ``len(s)``."

#: ../Doc/library/stdtypes.rst:2800
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Renvoie une copie de la séquence dont certains préfixes ont été supprimés. "
"L’argument *chars* est une séquence binaire spécifiant le jeu d'octets à "
"supprimer. Ce nom se réfère au fait de cette méthode est généralement "
"utilisée avec des caractères ASCII. En cas d’omission ou ``None``, la valeur "
"par défaut de *chars* permet de supprimer des espaces ASCII. L’argument "
"*chars* n’est pas un préfixe, toutes les combinaisons de ses valeurs sont "
"supprimées ::"

#: ../Doc/library/stdtypes.rst:2812 ../Doc/library/stdtypes.rst:2861
#: ../Doc/library/stdtypes.rst:2931
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"La séquence de valeurs à supprimer peut être tout :term:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2824
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Renvoie une copie de l'objet justifié à droite dans une séquence de longueur "
"*width*. Le remplissage est fait en utilisant le caractère *fillbyte* (par "
"défaut est un espace ASCII). Pour les objets :class:`bytes`, la séquence "
"d'origine est renvoyée si *width* est inférieure ou égale à ``len(s)``."

#: ../Doc/library/stdtypes.rst:2838
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Divise la séquence d'octets en sous-séquences du même type, en utilisant "
"*sep* comme séparateur. Si *maxsplit* est donné, c'est le nombre maximum de "
"divisions qui pourront être faites, celles \"à droite\". Si *sep* est pas "
"spécifié ou est ``None``, toute sous-séquence composée uniquement d'espaces "
"ASCII est un séparateur. En dehors du fait qu'il découpe par la droite, :"
"meth:`rsplit` se comporte comme :meth:`split` qui est décrit en détail ci-"
"dessous."

#: ../Doc/library/stdtypes.rst:2849
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Renvoie une copie de la séquence dont des octets finaux sont supprimés. "
"L'argument *chars* est une séquence d'octets spécifiant le jeu de caractères "
"à supprimer. En cas d'omission ou ``None``, les espaces ASCII sont "
"supprimés. L'argument *chars* n'est pas un suffixe : toutes les combinaisons "
"de ses valeurs sont retirées ::"

#: ../Doc/library/stdtypes.rst:2873
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Divise la séquence en sous-séquences du même type, en utilisant *sep* comme "
"séparateur. Si *maxsplit* est donné, c'est le nombre maximum de divisions "
"qui pourront être faites (la liste aura donc au plus ``maxsplit+1`` "
"éléments), Si *maxsplit* n'est pas spécifié ou faut ``-1``, il n'y a aucune "
"limite au nombre de découpes (elles sont toutes effectuées)."

#: ../Doc/library/stdtypes.rst:2879
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""
"Si *sep* est donné, les délimiteurs consécutifs ne sont pas regroupés et "
"ainsi délimitent ainsi des chaînes vides (par exemple, ``b'1,,2'."
"split(b',')`` donne ``[b'1', b'', b'2']``). L'argument *sep* peut contenir "
"plusieurs sous séquences (par exemple, ``b'1<>2<>3'.split(b'<>')`` renvoie "
"``[b'1', b'2', b'3']``). Découper une chaîne vide en spécifiant *sep* donne "
"``[b'']`` ou ``[bytearray(b'')]`` en fonction du type de l'objet découpé. "
"L'argument *sep* peut être n'importe quel :term:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2897
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Si *sep* n'est pas spécifié ou est ``None``, un autre algorithme de découpe "
"est appliqué : les espaces ASCII consécutifs sont considérés comme un seul "
"séparateur, et le résultat ne contiendra pas les chaînes vides de début ou "
"de la fin si la chaîne est préfixée ou suffixé d'espaces. Par conséquent, "
"diviser une séquence vide ou une séquence composée d'espaces ASCII avec un "
"séparateur ``None`` renvoie ``[]``."

#: ../Doc/library/stdtypes.rst:2918
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Renvoie une copie de la séquence dont des caractères initiaux et finaux sont "
"supprimés. L'argument *chars* est une séquence spécifiant le jeu d'octets à "
"supprimer, le nom se réfère au fait de cette méthode est généralement "
"utilisée avec des caractères ASCII. En cas d'omission ou ``None``, les "
"espaces ASCII sont supprimés. L'argument *chars* n'est ni un préfixe ni un "
"suffixe, toutes les combinaisons de ses valeurs sont supprimées ::"

#: ../Doc/library/stdtypes.rst:2940
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"Les méthodes suivantes sur les *bytes* et *bytearray* supposent "
"l'utilisation d'un format binaire compatible ASCII, et donc doivent être "
"évités lorsque vous travaillez avec des données binaires arbitraires. Notez "
"que toutes les méthodes de *bytearray* de cette section *ne modifient pas* "
"les octets, ils produisent de nouveaux objets."

#: ../Doc/library/stdtypes.rst:2948
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Renvoie une copie de la séquence dont chaque octet est interprété comme un "
"caractère ASCII, le premier octet en capitale et le reste en minuscules. Les "
"octets non ASCII ne sont pas modifiés."

#: ../Doc/library/stdtypes.rst:2961
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Renvoie une copie de la séquence où toutes les tabulations ASCII sont "
"remplacées par un ou plusieurs espaces ASCII, en fonction de la colonne "
"courante et de la taille de tabulation donnée. Les positions des tabulations "
"se trouvent tous les *tabsize* caractères (8 par défaut, ce qui donne les "
"positions de tabulations aux colonnes 0, 8, 16 et ainsi de suite). Pour "
"travailler sur la séquence, la colonne en cours est mise à zéro et la "
"séquence est examinée octets par octets. Si l'octet est une tabulation ASCII "
"(``b'\t'``), un ou plusieurs espaces sont insérés au résultat jusqu’à ce que "
"la colonne courante soit égale à la position de tabulation suivante. (Le "
"caractère tabulation lui-même n’est pas copié.) Si l'octet courant est un "
"saut de ligne ASCII (``b'\n"
"'``) ou un retour chariot (``b'\\r'``), il est copié et la colonne en cours "
"est remise à zéro. Tout autre octet est copié inchangé et la colonne en "
"cours est incrémentée de un indépendamment de la façon dont l'octet est "
"représenté lors de l’affichage ::"

#: ../Doc/library/stdtypes.rst:2989
#, fuzzy
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Donne ``True`` si tous les caractères de la chaîne sont des caractères ASCII "
"alphabétiques ou chiffres. et que la séquence n'est pas vide, sinon "
"``False``. Les caractères ASCII alphabétiques sont les suivants "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` et les "
"chiffres : ``b'0123456789'``."

#: ../Doc/library/stdtypes.rst:3006
#, fuzzy
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Donne ``True`` si tous les octets dans la séquence sont des caractères "
"alphabétiques ASCII et la que la séquence n'est pas vide, sinon ``False``. "
"Les caractères ASCIIalphabétiques sont : "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../Doc/library/stdtypes.rst:3022
#, fuzzy
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Renvoie ``True`` si la séquence est vide, ou si tous ses octets sont des "
"octets ASCII, renvoie faux dans le cas contraire. Les octets ASCII dans "
"l'intervalle ``0``---``0x7F``."

#: ../Doc/library/stdtypes.rst:3032
#, fuzzy
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Donne ``True`` si tous les octets de la séquence sont des chiffres  ASCII et "
"que la séquence n'est pas vide, sinon ``False``. Les chiffres ASCII sont "
"``b'0123456789'``."

#: ../Doc/library/stdtypes.rst:3047
#, fuzzy
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"Donne ``True`` s'il y a au moins un caractère ASCII minuscule dans la "
"séquence et aucune capitale, sinon ``False``."

#: ../Doc/library/stdtypes.rst:3057 ../Doc/library/stdtypes.rst:3099
#: ../Doc/library/stdtypes.rst:3115 ../Doc/library/stdtypes.rst:3165
#: ../Doc/library/stdtypes.rst:3234
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Les caractères ASCII minuscules sont ``b'abcdefghijklmnopqrstuvwxyz'``. Les "
"capitales ASCII sont ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../Doc/library/stdtypes.rst:3065
#, fuzzy
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Donne ``True`` si tous les octets de la séquence sont des espaces  ASCII et "
"que la séquence n'est pas vide, sinon ``False``. Les espèces ASCII sont ``b' "
"\\t\\n\\r\\x0b\\f'`` (espace, tabulation,saut de ligne, retour chariot, "
"tabulation verticale,  *form feed*)."

#: ../Doc/library/stdtypes.rst:3074
#, fuzzy
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Donne ``True`` si la séquence ASCII est *titlecased*, et qu'elle ne soit pas "
"vide, sinon ``False``. Voir :meth:`bytes.title` pour plus de détails sur la "
"définition de *titlecase*."

#: ../Doc/library/stdtypes.rst:3089
#, fuzzy
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""
"Donne ``True`` s'il y a au moins un caractère alphabétique majuscule  ASCII "
"dans la séquence et aucun caractères ASCII minuscules, sinon ``False``."

#: ../Doc/library/stdtypes.rst:3107
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Renvoie une copie de la séquence dont tous les caractères ASCII en "
"majuscules sont convertis en leur équivalent en minuscules."

#: ../Doc/library/stdtypes.rst:3132
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Renvoie une liste des lignes de la séquence d'octets, découpant au niveau "
"des fin de lignes ASCII. Cette méthode utilise l'approche :term:`universal "
"newlines` pour découper les lignes. Les fins de ligne ne sont pas inclus "
"dans la liste des résultats, sauf si *keepends* est donné et vrai."

#: ../Doc/library/stdtypes.rst:3144
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Contrairement à :meth:`~bytes.split` lorsque le délimiteur *sep* est fourni, "
"cette méthode renvoie une liste vide pour la chaîne vide, et un saut de "
"ligne à la fin ne se traduit pas par une ligne supplémentaire ::"

#: ../Doc/library/stdtypes.rst:3157
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Renvoie une copie de la séquence dont tous les caractères ASCII minuscules "
"sont convertis en majuscules et vice-versa."

#: ../Doc/library/stdtypes.rst:3169
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"Contrairement à :func:`str.swapcase()`,  ``bin.swapcase().swapcase() == "
"bin`` est toujours vrai. Les conversions majuscule/minuscule en ASCII étant "
"toujours symétrique, ce qui n'est pas toujours vrai avec Unicode."

#: ../Doc/library/stdtypes.rst:3183
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Renvoie une version *titlecased* de la séquence d'octets où les mots "
"commencent par un caractère ASCII majuscule et les caractères restants sont "
"en minuscules. Les octets non capitalisables ne sont pas modifiés."

#: ../Doc/library/stdtypes.rst:3192
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"Les caractères ASCII minuscules sont ``b'abcdefghijklmnopqrstuvwxyz'``. Les "
"caractères ASCII majuscules sont ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Aucun "
"autre octet n'est capitalisable."

#: ../Doc/library/stdtypes.rst:3226
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Renvoie une copie de la séquence dont tous les caractères ASCII minuscules "
"sont convertis en leur équivalent majuscule."

#: ../Doc/library/stdtypes.rst:3247
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Renvoie une copie de la séquence remplie par la gauche du chiffre ``b'0'`` "
"pour en faire une séquence de longueur *width*. Un préfixe (``b'+'`` / "
"``b'-'``) est permis par l'insertion du caractère de remplissage *après* le "
"caractère de signe plutôt qu'avant. Pour les objets :class:`bytes` la "
"séquence d'origine est renvoyée si *width* est inférieur ou égale à "
"``len(seq)``."

#: ../Doc/library/stdtypes.rst:3269
msgid "``printf``-style Bytes Formatting"
msgstr "Formatage de *bytes* a la ``printf``"

#: ../Doc/library/stdtypes.rst:3286
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"Les opérations de formatage décrites ici présentent une variété de "
"bizarreries qui conduisent à un certain nombre d’erreurs classiques "
"(typiquement, échouer à afficher des tuples ou des dictionnaires "
"correctement). Si la valeur à afficher peut être un tuple ou un "
"dictionnaire, mettez le a l'intérieur d'un autre tuple."

#: ../Doc/library/stdtypes.rst:3291
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Les objets *bytes* (``bytes`` et ``bytearray``) ont un unique opérateur : "
"l'opérateur ``%`` (modulo). Il est aussi connu sous le nom d'opérateur de "
"mise en forme. Avec ``format % values`` (où *format* est un objet *bytes*), "
"les marqueurs de conversion ``%`` dans *format* sont remplacés par zéro ou "
"plus de *values*. L'effet est similaire à la fonction :c:func:`sprintf` du "
"langage C."

#: ../Doc/library/stdtypes.rst:3298
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Si *format* ne nécessite qu'un seul argument, *values* peut être un objet "
"unique. [5]_ Si *values* est un tuple, il doit contenir exactement le nombre "
"d'éléments spécifiés dans le format en *bytes*, ou un seul objet de "
"correspondances ( *mapping object*, par exemple, un dictionnaire)."

#: ../Doc/library/stdtypes.rst:3332
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Lorsque l'argument de droite est un dictionnaire (ou un autre type de "
"*mapping*), les marqueurs dans le *bytes* *doivent* inclure une clé présente "
"dans le dictionnaire, écrite entre parenthèses,  immédiatement après le "
"caractère ``'%'``. La clé indique quelle valeur du dictionnaire doit être "
"formatée. Par exemple :"

#: ../Doc/library/stdtypes.rst:3406
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Octet simple (Accepte un nombre entier ou un seul objet *byte*)."

#: ../Doc/library/stdtypes.rst:3409
msgid "``'b'``"
msgstr "``'b'``"

#: ../Doc/library/stdtypes.rst:3409
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""
"*Bytes* (tout objet respectant le :ref:`buffer protocol <bufferobjects>` ou "
"ayant la méthode :meth:`__bytes__`)."

#: ../Doc/library/stdtypes.rst:3413
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'s'`` est un alias de ``'b'`` et ne devrait être utilisé que pour du code "
"Python2/3."

#: ../Doc/library/stdtypes.rst:3416
msgid ""
"Bytes (converts any Python object using ``repr(obj)."
"encode('ascii','backslashreplace)``)."
msgstr ""
"*Bytes* (convertis n'importe quel objet Python en utilisant ``repr(obj)."
"encode('ascii', 'backslashreplace)``)."

#: ../Doc/library/stdtypes.rst:3419
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'r'`` est un alias de ``'a'`` et ne devrait être utilise que dans du code "
"Python2/3."

#: ../Doc/library/stdtypes.rst:3419
msgid "\\(7)"
msgstr "\\(7)"

#: ../Doc/library/stdtypes.rst:3454
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` est obsolète, mais ne sera pas retiré des version 3.x."

#: ../Doc/library/stdtypes.rst:3457
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` est obsolète mais ne sera pas retiré dans Python 3.x."

#: ../Doc/library/stdtypes.rst:3469
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` -- Ajout du formatage via % aux *bytes* et *bytesarray*"

#: ../Doc/library/stdtypes.rst:3476
msgid "Memory Views"
msgstr "Vues de mémoires"

#: ../Doc/library/stdtypes.rst:3478
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
"Les :class:`memoryview` permettent a du code Python d'accéder sans copie aux "
"données internes d'un objet pendant en charge le :ref:`buffer protocol "
"<bufferobjects>`."

#: ../Doc/library/stdtypes.rst:3484
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support the "
"buffer protocol.  Built-in objects that support the buffer protocol include :"
"class:`bytes` and :class:`bytearray`."
msgstr ""
"Crée une :class:`memoryview` faisant référence à *obj*. *obj* doit supporter "
"le *buffer protocol*. Les objets natifs pendant en charge le *buffer "
"protocol* sont :class:`bytes` et :class:`bytearray`."

#: ../Doc/library/stdtypes.rst:3488
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating object *obj*.  For many simple types "
"such as :class:`bytes` and :class:`bytearray`, an element is a single byte, "
"but other types such as :class:`array.array` may have bigger elements."
msgstr ""
"Une :class:`memoryview` a la notion d'*element*, qui est l'unité de  mémoire "
"atomique géré par l'objet *obj* d'origine. Pour de nombreux types simples "
"comme :class:`bytes` et :class:`bytearray`, l'élément est l'octet, mais pour "
"d'autres types tels que :class:`array.array` les éléments peuvent être plus "
"grands."

#: ../Doc/library/stdtypes.rst:3494
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view. "
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"``len(view)`` est égal à la grandeur de :class:`~memoryview.tolist`. Si "
"``view.ndim = 0``, la longueur vaut 1. Si ``view.ndim = 1``, la longueur est "
"égale au nombre d'éléments de la vue. Pour les dimensions plus grandes, la "
"longueur est égale à la longueur de la sous-liste représentée par la vue. "
"L'attribut :class:`~memoryview.itemsize` vous donnera la taille en octets "
"d'un élément."

#: ../Doc/library/stdtypes.rst:3501
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
"Une :class:`memoryview` autorise le découpage et l'indiçage de ses données. "
"Découper sur une dimension donnera une sous-vue ::"

#: ../Doc/library/stdtypes.rst:3514
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Si le :class:`~memoryview.format` est un des formats natif du module :mod:"
"`struct`, indexer avec un nombre entier ou un *tuple* de nombres entiers est "
"aussi autorisé et renvoie un seul *element* du bon type.  Les *memoryview* à "
"une dimension peuvent être indexées avec un nombre entier ou un *tuple* d'un "
"entier.  Les *memoryview* multi-dimensionnelles peuvent être indexées avec "
"des *tuples* d'exactement *ndim* entiers où *ndim* est le nombre de "
"dimensions.  Les *memoryviews* à zéro dimension peuvent être indexées avec "
"un *tuple* vide."

#: ../Doc/library/stdtypes.rst:3523
msgid "Here is an example with a non-byte format::"
msgstr "Voici un exemple avec un autre format que *byte* ::"

#: ../Doc/library/stdtypes.rst:3535
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Si l'objet sous-jacent est accessible en écriture, la *memoryview* "
"autorisera les assignations de tranches à une dimension. Redimensionner "
"n'est cependant pas autorisé ::"

#: ../Doc/library/stdtypes.rst:3556
msgid ""
"One-dimensional memoryviews of hashable (read-only) types with formats 'B', "
"'b' or 'c' are also hashable. The hash is defined as ``hash(m) == hash(m."
"tobytes())``::"
msgstr ""
"Les *memoryviews* à une dimension de types hachables (lecture seule) avec "
"les formats 'B', 'b', ou 'c' sont aussi hachables. La fonction de hachage "
"est définie tel que ``hash(m) == hash(m.tobytes())`` ::"

#: ../Doc/library/stdtypes.rst:3568
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now hashable."
msgstr ""
"Les *memoryviews* à une dimension peuvent aussi être découpées. Les "
"*memoryviews* à une dimension avec les formats 'B', 'b', ou 'c' sont "
"maintenant hachables."

#: ../Doc/library/stdtypes.rst:3572
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"*memoryview* est maintenant enregistrée automatiquement avec :class:"
"`collections.abc.Sequence`"

#: ../Doc/library/stdtypes.rst:3576
msgid "memoryviews can now be indexed with tuple of integers."
msgstr ""
"les *memoryviews* peut maintenant être indexées par un n-uplet d'entiers."

#: ../Doc/library/stdtypes.rst:3579
msgid ":class:`memoryview` has several methods:"
msgstr "La :class:`memoryview` dispose de plusieurs méthodes :"

#: ../Doc/library/stdtypes.rst:3583
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Une *memoryview* et un *exporter* de la :pep:`3118` sont égaux si leurs "
"formes sont équivalentes et si toutes les valeurs correspondantes sont "
"égales, le format respectifs des opérandes étant interprétés en utilisant la "
"syntaxe de :mod:`struct`."

#: ../Doc/library/stdtypes.rst:3587
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Pour le sous-ensemble des formats de :mod:`struct` supportés  par :meth:"
"`tolist`, ``v`` et ``w`` sont égaux si ``v.tolist() ==w.tolist()`` ::"

#: ../Doc/library/stdtypes.rst:3606
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Si l'un des format n'est pas supporté par le module de :mod:`struct`, les "
"objets seront toujours considérés différents  (même si les formats et les "
"valeurs contenues sont identiques) ::"

#: ../Doc/library/stdtypes.rst:3622
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"Notez que pour les *memoryview*, comme pour les nombres à virgule flottante, "
"``v is w`` *n'implique pas* ``v == w``."

#: ../Doc/library/stdtypes.rst:3625
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Les versions précédentes comparaient la mémoire brute sans tenir compte du "
"format de l'objet ni de sa structure logique."

#: ../Doc/library/stdtypes.rst:3631
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Renvoie les données du *buffer* sous forme de *bytes*. Cela  équivaut à "
"appeler le constructeur :class:`bytes` sur le *memoryview*. ::"

#: ../Doc/library/stdtypes.rst:3640
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"Pour les listes non contiguës le résultat est égal à la représentation en "
"liste aplatie dont tous les éléments sont convertis en octets. :meth:"
"`tobytes` supporte toutes les chaînes de format, y compris celles qui ne "
"sont pas connues du module :mod:`struct`."

#: ../Doc/library/stdtypes.rst:3645
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""

#: ../Doc/library/stdtypes.rst:3654
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""
"Renvoie une chaîne contenant deux chiffres hexadécimaux pour chaque octet de "
"la mémoire. ::"

#: ../Doc/library/stdtypes.rst:3665
msgid "Return the data in the buffer as a list of elements. ::"
msgstr ""
"Renvoie les données de la mémoire sous la forme d'une liste d'éléments. ::"

#: ../Doc/library/stdtypes.rst:3675
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`tolist` prend désormais en charge tous les formats d'un caractère du "
"module :mod:`struct` ainsi que des représentations multidimensionnelles."

#: ../Doc/library/stdtypes.rst:3682
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""

#: ../Doc/library/stdtypes.rst:3701
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"Libère le tampon sous-jacent exposé par l'objet *memoryview*.  Beaucoup "
"d'objets prennent des initiatives particulières lorsqu'ils sont liés à une "
"vue (par exemple, un :class:`bytearray` refusera temporairement de se faire "
"redimensionner). Par conséquent, appeler *release()* peut être pratique pour "
"lever ces restrictions (et en libérer les ressources liées) aussi tôt que "
"possible."

#: ../Doc/library/stdtypes.rst:3707
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""
"Après le premier appel de cette méthode, toute nouvelle opération  sur la "
"*view* lève une :class:`ValueError` (sauf :meth:`release()` elle-même qui "
"peut être appelée plusieurs fois) ::"

#: ../Doc/library/stdtypes.rst:3718
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"Le protocole de gestion de contexte peut être utilisé pour obtenir un effet "
"similaire, via l'instruction ``with`` ::"

#: ../Doc/library/stdtypes.rst:3734
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"Change le format ou la forme d'une *memoryview*. Par défaut *shape* vaut "
"``[byte_length//new_itemsize]``, ce qui signifie que la vue résultante "
"n'aura qu'une dimension. La valeur renvoyée est une nouvelle *memoryview*, "
"mais la mémoire elle-même n'est pas copiée. Les changements supportés sont "
"une dimension vers C-:term:`contiguous` et *C-contiguous* vers une dimension."

#: ../Doc/library/stdtypes.rst:3740
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
msgstr ""
"Le format de destination est limité à un seul élément natif de la syntaxe du "
"module :mod:`struct`. L'un des formats doit être un *byte* ('B', 'b', ou "
"'c'). La longueur du résultat en octets doit être la même que la longueur "
"initiale."

#: ../Doc/library/stdtypes.rst:3745
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "Transforme *1D/long* en *1D/unsigned bytes* ::"

#: ../Doc/library/stdtypes.rst:3768
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "Transforme *1D/unsigned bytes* en *1D/char* ::"

#: ../Doc/library/stdtypes.rst:3781
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Transforme *1D/bytes* en *3D/ints* en *1D/signed char* ::"

#: ../Doc/library/stdtypes.rst:3807
#, fuzzy
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "Transforme *1D/unsigned char* en *2D/unsigned long* ::"

#: ../Doc/library/stdtypes.rst:3821
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"Le format de la source n'est plus restreint lors de la transformation vers "
"une vue d'octets."

#: ../Doc/library/stdtypes.rst:3824
msgid "There are also several readonly attributes available:"
msgstr "Plusieurs attributs en lecture seule sont également disponibles :"

#: ../Doc/library/stdtypes.rst:3828
msgid "The underlying object of the memoryview::"
msgstr "L'objet sous-jacent de la *memoryview* ::"

#: ../Doc/library/stdtypes.rst:3839
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. Ceci est "
"l'espace que la liste utiliserait en octets, dans une représentation "
"contiguë. Ce n'est pas nécessairement égale à ``len(m)`` ::"

#: ../Doc/library/stdtypes.rst:3858
msgid "Multi-dimensional arrays::"
msgstr "Tableaux multidimensionnels ::"

#: ../Doc/library/stdtypes.rst:3875
msgid "A bool indicating whether the memory is read only."
msgstr "Un booléen indiquant si la mémoire est en lecture seule."

#: ../Doc/library/stdtypes.rst:3879
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"Une chaîne contenant le format (dans le style de :mod:`struct`) pour chaque "
"élément de la vue. Une *memoryview* peut être crée depuis des exportateurs "
"de formats arbitraires, mais certaines méthodes (comme :meth:`tolist`) sont "
"limitées aux formats natifs à un seul élément."

#: ../Doc/library/stdtypes.rst:3884
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"le format ``'B'`` est maintenant traité selon la syntaxe du module *struct*. "
"Cela signifie que ``memoryview(b'abc')[0] == b'abc'[0] == 97``."

#: ../Doc/library/stdtypes.rst:3890
msgid "The size in bytes of each element of the memoryview::"
msgstr "La taille en octets de chaque élément d'une *memoryview* ::"

#: ../Doc/library/stdtypes.rst:3903
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Un nombre entier indiquant le nombre de dimensions d'un tableau multi-"
"dimensionnel représenté par la *memoryview*."

#: ../Doc/library/stdtypes.rst:3908
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Un *tuple* d'entiers de longueur :attr:`ndim` donnant la forme de la "
"*memoryview* sous forme d'un tableau à N dimensions."

#: ../Doc/library/stdtypes.rst:3911 ../Doc/library/stdtypes.rst:3919
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Un *tuple* vide au lieu de ``None`` lorsque *ndim = 0*."

#: ../Doc/library/stdtypes.rst:3916
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Un *tuple* d'entiers de longueur :attr:`ndim` donnant la taille en octets "
"permettant d'accéder à chaque dimensions du tableau."

#: ../Doc/library/stdtypes.rst:3924
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"Détail de l'implémentation des *PIL-style arrays*. La valeur n'est donné "
"qu'a titre d'information."

#: ../Doc/library/stdtypes.rst:3928
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "Un booléen indiquant si la mémoire est C-:term:`contiguous`."

#: ../Doc/library/stdtypes.rst:3934
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "Un booléen indiquant si la mémoire est Fortran :term:`contiguous`."

#: ../Doc/library/stdtypes.rst:3940
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Un booléen indiquant si la mémoire est :term:`contiguous`."

#: ../Doc/library/stdtypes.rst:3948
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Types d'ensembles — :class:`set`, :class:`frozenset`"

#: ../Doc/library/stdtypes.rst:3952
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Un objet :dfn:`set` est une collection non-triée d'objets :term:`hashable` "
"distincts. Les utilisations classiques sont le test d'appartenance, la "
"déduplication d'une séquence, ou le calcul d'opérations mathématiques telles "
"que l'intersection, l'union, la différence, ou la différence symétrique. "
"(Pour les autres conteneurs, voir les classes natives :class:`dict`, :class:"
"`list`, et :class:`tuple`, ainsi que le module :mod:`collections`.)"

#: ../Doc/library/stdtypes.rst:3959
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Comme pour les autres collections, les ensembles supportent ``x in set``, "
"``len(set)``, et ``for x in set``. En tant que collection non-triée, les "
"ensembles n'enregistrent pas la position des éléments ou leur ordre "
"d'insertion.  En conséquence, les *sets* n'autorisent ni l'indexation, ni le "
"découpage, ou tout autre comportement de séquence."

#: ../Doc/library/stdtypes.rst:3964
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"Il existe actuellement deux types natifs pour les ensembles, :class:`set` "
"et :class:`fronzenset`. Le type :class:`set` est muable --- son contenu peut "
"changer en utilisant des méthodes comme :meth:`~set.add` et :meth:`~set."
"remove`. Puisqu'il est muable, il n'a pas de valeur de hachage et ne peut "
"donc pas être utilisé ni comme clef de dictionnaire ni comme élément d'un "
"autre ensemble. Le type :class:`frozenset` est immuable et :term:`hashable` "
"--- son contenu ne peut être modifié après sa création, il peut ainsi être "
"utilisé comme clef de dictionnaire ou élément d'un autre *set*."

#: ../Doc/library/stdtypes.rst:3972
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Des *sets* (mais pas des *frozensets*) peuvent être crées par une liste "
"d'éléments séparés par des virgules et entre accolades, par exemple : "
"``{'jack', 'sjoerd'}``, en plus du constructeur de la classe :class:`set`."

#: ../Doc/library/stdtypes.rst:3976
msgid "The constructors for both classes work the same:"
msgstr "Les constructeurs des deux classes fonctionnent pareil :"

#: ../Doc/library/stdtypes.rst:3981
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Renvoie un nouveau *set* ou *frozenset* dont les éléments viennent "
"d'*iterable*.  Les éléments d'un *set* doivent être :term:`hashable`.  Pour "
"représenter des *sets* de *sets* les *sets* intérieurs doivent être des :"
"class:`frozenset`.  Si *iterable* n'est pas spécifié, un nouveau *set* vide "
"est renvoyé."

#: ../Doc/library/stdtypes.rst:3987
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Les instances de :class:`set` et :class:`frozenset` fournissent les "
"opérations suivantes :"

#: ../Doc/library/stdtypes.rst:3992
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "Donne le nombre d'éléments dans le *set* *s* (cardinalité de *s*)."

#: ../Doc/library/stdtypes.rst:3996
msgid "Test *x* for membership in *s*."
msgstr "Test d'appartenance de *x* dans *s*."

#: ../Doc/library/stdtypes.rst:4000
msgid "Test *x* for non-membership in *s*."
msgstr "Test de non-appartenance de *x* dans *s*."

#: ../Doc/library/stdtypes.rst:4004
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Renvoie ``True`` si l'ensemble n'a aucun élément en commun avec *other*.  "
"Les ensembles sont disjoints si et seulement si leurs intersection est un "
"ensemble vide."

#: ../Doc/library/stdtypes.rst:4010
msgid "Test whether every element in the set is in *other*."
msgstr "Teste si tous les éléments du set sont dans *other*."

#: ../Doc/library/stdtypes.rst:4014
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Teste si l'ensemble est un sous-ensemble de *other*, c'est-à-dire, ``set <= "
"other and set != other``."

#: ../Doc/library/stdtypes.rst:4020
msgid "Test whether every element in *other* is in the set."
msgstr "Teste si tous les éléments de *other* sont dans l'ensemble."

#: ../Doc/library/stdtypes.rst:4024
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Teste si l'ensemble est un sur-ensemble de *other*, c'est-à-dire, ``set >= "
"other and set != other``."

#: ../Doc/library/stdtypes.rst:4030
msgid "Return a new set with elements from the set and all others."
msgstr ""
"Renvoie un nouvel ensemble dont les éléments viennent de l'ensemble et de "
"tous les autres."

#: ../Doc/library/stdtypes.rst:4035
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Renvoie un nouvel ensemble dont les éléments sont commun à l'ensemble et à "
"tous les autres."

#: ../Doc/library/stdtypes.rst:4040
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"Renvoie un nouvel ensemble dont les éléments sont dans l'ensemble mais ne "
"sont dans aucun des autres."

#: ../Doc/library/stdtypes.rst:4045
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Renvoie un nouvel ensemble dont les éléments sont soit dans l'ensemble, soit "
"dans les autres, mais pas dans les deux."

#: ../Doc/library/stdtypes.rst:4049
msgid "Return a shallow copy of the set."
msgstr "Renvoie une copie de surface du dictionnaire."

#: ../Doc/library/stdtypes.rst:4052
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and :"
"meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Remarque : Les méthodes  :meth:`union`, :meth:`intersection`, :meth:"
"`difference`, et :meth:`symmetric_difference`, :meth:`issubset`, et :meth:"
"`issuperset` acceptent n'importe quel itérable comme argument, contrairement "
"aux opérateurs équivalents qui n'acceptent que des *sets*. Il est donc "
"préférable d'éviter les constructions comme ``set('abc') & 'cbs'``, sources "
"typiques d'erreurs, en faveur d'une construction plus lisible : ``set('abc')."
"intersection('cbs')``."

#: ../Doc/library/stdtypes.rst:4059
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Les classes :class:`set` et :class:`frozenset` supportent les comparaisons "
"d'ensemble à ensemble. Deux ensembles sont égaux si et seulement si chaque "
"éléments de chaque ensemble est contenu dans l'autre (autrement dit que "
"chaque ensemble est un sous-ensemble de l'autre). Un ensemble est plus petit "
"qu'un autre ensemble si et seulement si le premier est un sous-ensemble du "
"second (un sous-ensemble, mais pas égal). Un ensemble est plus grand qu'un "
"autre ensemble si et seulement si le premier est un sur-ensemble du second "
"(est un sur-ensemble mais n'est pas égal)."

#: ../Doc/library/stdtypes.rst:4066
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Les instances de :class:`set` se comparent aux instances de :class:"
"`frozenset` en fonction de leurs membres.  Par exemple, ``set('abc') == "
"frozenset('abc')`` envoie ``True``, ainsi que ``set('abc') in "
"set([frozenset('abc')])``."

#: ../Doc/library/stdtypes.rst:4070
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"Les comparaisons de sous-ensemble et d'égalité ne se généralisent pas en une "
"fonction donnant un ordre total.  Par exemple, deux ensemble disjoints non "
"vides ne sont ni égaux et ni des sous-ensembles l'un de l'autre, donc toutes "
"ces comparaisons donnent ``False`` : ``a<b``, ``a==b``, et ``a>b``."

#: ../Doc/library/stdtypes.rst:4075
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Puisque les *sets* ne définissent qu'un ordre partiel (par leurs relations "
"de sous-ensembles), la sortie de la méthode :meth:`list.sort` n'est pas "
"définie pour des listes d'ensembles."

#: ../Doc/library/stdtypes.rst:4078
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"Les éléments des *sets*, comme les clefs de dictionnaires, doivent être :"
"term:`hashable`."

#: ../Doc/library/stdtypes.rst:4080
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Les opérations binaires mélangeant des instances de :class:`set` et :class:"
"`frozenset` renvoient le type de la première opérande.  Par exemple : "
"``frozenset('ab') | set('bc')`` renvoie une instance de :class:`frozenset`."

#: ../Doc/library/stdtypes.rst:4084
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"La table suivante liste les opérations disponibles pour les :class:`set` "
"mais qui ne s'appliquent pas aux instances de :class:`frozenset` :"

#: ../Doc/library/stdtypes.rst:4090
msgid "Update the set, adding elements from all others."
msgstr "Met à jour l'ensemble, ajoutant les éléments de tous les autres."

#: ../Doc/library/stdtypes.rst:4095
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Met à jour l'ensemble, ne gardant que les éléments trouvés dans tous les "
"autres."

#: ../Doc/library/stdtypes.rst:4100
msgid "Update the set, removing elements found in others."
msgstr "Met à jour l'ensemble, retirant les éléments trouvés dans les autres."

#: ../Doc/library/stdtypes.rst:4105
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Met à jour le set, ne gardant que les éléments trouvés dans un des ensembles "
"mais pas dans les deux."

#: ../Doc/library/stdtypes.rst:4109
msgid "Add element *elem* to the set."
msgstr "Ajoute l'élément *elem* au set."

#: ../Doc/library/stdtypes.rst:4113
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Retire l'élément *elem* de l'ensemble. Lève une exception :exc:`KeyError` si "
"*elem* n'est pas dans l'ensemble."

#: ../Doc/library/stdtypes.rst:4118
msgid "Remove element *elem* from the set if it is present."
msgstr "Retire l'élément *elem* de l'ensemble s'il y est."

#: ../Doc/library/stdtypes.rst:4122
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Retire et renvoie un élément arbitraire de l'ensemble. Lève une exception :"
"exc:`KeyError` si l'ensemble est vide."

#: ../Doc/library/stdtypes.rst:4127
msgid "Remove all elements from the set."
msgstr "Supprime tous les éléments du *set*."

#: ../Doc/library/stdtypes.rst:4130
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Notez que les versions non-opérateurs des méthodes :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, et :meth:"
"`symmetric_difference_update` acceptent n'importe quel itérable comme "
"argument."

#: ../Doc/library/stdtypes.rst:4135
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
"Notez que l'argument *elem* des méthodes :meth:`__contains__`, :meth:"
"`remove`, et :meth:`discard` peut être un ensemble.  Pour supporter la "
"recherche d'un *frozenset* équivalent, un *frozenset* temporaire est crée "
"depuis *elem*."

#: ../Doc/library/stdtypes.rst:4143
msgid "Mapping Types --- :class:`dict`"
msgstr "Les types de correspondances — :class:`dict`"

#: ../Doc/library/stdtypes.rst:4153
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Un objet :term:`mapping` fait correspondre des valeurs :term:`hashable` à "
"des objets arbitraires. Les *mappings* sont des objets muables.  Il n'existe "
"pour le moment qu'un type de *mapping* standard, le :dfn:`dictionary`.  "
"(Pour les autres conteneurs, voir les types natifs :class:`list`, :class:"
"`set`, et :class:`tuple`, ainsi que le module :mod:`collections`.)"

#: ../Doc/library/stdtypes.rst:4159
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""
"Les clefs d'un dictionnaire sont *presque* des données arbitraires. Les "
"valeurs qui ne sont pas :term:`hashable`, c'est-à-dire qui contiennent les "
"listes, des dictionnaires ou autre type muable (qui sont comparés par valeur "
"plutôt que par leur identité) ne peuvent pas être utilisées comme clef de "
"dictionnaire. Les types numériques utilisés comme clef obéissent aux règles "
"classiques en ce qui concerne les comparaisons : si deux nombres sont égaux "
"(comme ``1`` et ``1.0``) ils peuvent tous les deux être utilisés pour "
"obtenir la même entrée d'un dictionnaire.  (Notez cependant que puisque les "
"ordinateurs stockent les nombres à virgule flottante sous forme "
"d'approximations, il est généralement imprudent de les utiliser comme clefs "
"de dictionnaires.)"

#: ../Doc/library/stdtypes.rst:4168
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}`` "
"or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""
"Il est possible de créer des dictionnaires en plaçant entre accolades une "
"liste de paires de ``key: value`` séparés par des virgules, par exemple: "
"``{'jack': 4098, 'sjoerd': 4127}`` ou ``{4098: 'jack', 4127: 'sjoerd'}``, ou "
"en utilisant le constructeur de :class:`dict`."

#: ../Doc/library/stdtypes.rst:4176
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Renvoie un nouveau dictionnaire initialisé depuis un argument positionnel "
"optionnel, et un ensemble (vide ou non) d'arguments par mot clef."

#: ../Doc/library/stdtypes.rst:4179
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"Si aucun argument positionnel n'est donné, un dictionnaire vide est crée. Si "
"un argument positionnel est donné et est un *mapping object*, un "
"dictionnaire est crée avec les mêmes paires de clef-valeurs que le *mapping* "
"donné. Autrement, l'argument positionnel doit être un objet :term:"
"`iterable`. Chaque élément de cet itérable doit lui même être un itérable "
"contenant exactement deux objets.  Le premier objet de chaque élément "
"devient la une clef du nouveau dictionnaire, et le second devient sa valeur "
"correspondante.  Si une clef apparaît plus d'une fois, la dernière valeur "
"pour cette clef devient la valeur correspondante à cette clef dans le "
"nouveau dictionnaire."

#: ../Doc/library/stdtypes.rst:4189
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Si des arguments nommés sont donnés, ils sont ajoutés au dictionnaire créé "
"depuis l'argument positionnel.  Si une clef est déjà présente, la valeur de "
"l'argument nommé remplace la valeur reçue par l'argument positionnel."

#: ../Doc/library/stdtypes.rst:4194
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Typiquement, les exemples suivants renvoient tous un dictionnaire valant "
"``{\"one\": 1, \"two\": 2, \"three\": 3}`` ::"

#: ../Doc/library/stdtypes.rst:4205
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Fournir les arguments nommés comme dans le premier exemple en fonctionne que "
"pour des clefs qui sont des identifiants valide en Python.  Dans les autres "
"cas, toutes les clefs valides sont utilisables."

#: ../Doc/library/stdtypes.rst:4209
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Voici les opérations gérées par les dictionnaires, (par conséquent, d'autres "
"types de *mapping* peuvent les gérer aussi) :"

#: ../Doc/library/stdtypes.rst:4214
#, fuzzy
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "Renvoie le nombre d'éléments dans le dictionnaire *d*."

#: ../Doc/library/stdtypes.rst:4218
msgid "Return the number of items in the dictionary *d*."
msgstr "Renvoie le nombre d'éléments dans le dictionnaire *d*."

#: ../Doc/library/stdtypes.rst:4222
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Donne l'élément de *d* dont la clef est *key*. Lève une exception :exc:"
"`KeyError` si *key* n'est pas dans le dictionnaire."

#: ../Doc/library/stdtypes.rst:4227
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"Si une sous-classe de *dict* définit une méthode :meth:`__missing__` et que "
"*key* manque, l'opération ``d[key]`` appelle cette méthode avec la clef "
"*key* en argument. L'opération ``d[key]`` renverra la valeur, ou lèvera "
"l'exception renvoyée ou levée par l'appel à ``__missing__(key)``. Aucune "
"autre opération ni méthode n'appellent :meth:`__missing__`. If :meth:"
"`__missing__` n'est pas définie, une exception :exc:`KeyError` est levée. :"
"meth:`__missing__` doit être une méthode; ça ne peut être une variable "
"d'instance ::"

#: ../Doc/library/stdtypes.rst:4245
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"L'exemple ci-dessus montre une partie de l'implémentation de :class:"
"`collections.Counter`.  :class:`collections.defaultdict` implémente aussi "
"``__missing__``."

#: ../Doc/library/stdtypes.rst:4251
msgid "Set ``d[key]`` to *value*."
msgstr "Assigne ``d[key]`` à *value*."

#: ../Doc/library/stdtypes.rst:4255
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Supprime ``d[key]`` de *d*.  Lève une exception :exc:`KeyError` si *key* "
"n'est pas dans le dictionnaire."

#: ../Doc/library/stdtypes.rst:4260
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "Renvoie ``True`` si *d* a la clef *key*, sinon ``False``."

#: ../Doc/library/stdtypes.rst:4264
msgid "Equivalent to ``not key in d``."
msgstr "Équivalent à ``not key in d``."

#: ../Doc/library/stdtypes.rst:4268
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Renvoie un itérateur sur les clefs du dictionnaire.  C'est un raccourci pour "
"``iter(d.keys())``."

#: ../Doc/library/stdtypes.rst:4273
msgid "Remove all items from the dictionary."
msgstr "Supprime tous les éléments du dictionnaire."

#: ../Doc/library/stdtypes.rst:4277
msgid "Return a shallow copy of the dictionary."
msgstr "Renvoie une copie de surface du dictionnaire."

#: ../Doc/library/stdtypes.rst:4281
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"Crée un nouveau dictionnaire avec les clefs de *iterable* et les valeurs à "
"*value*."

#: ../Doc/library/stdtypes.rst:4283
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""

#: ../Doc/library/stdtypes.rst:4291
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Renvoie la valeur de *key* si *key* est dans le dictionnaire, sinon "
"*default*. Si *default* n'est pas donné, il vaut ``None`` par défaut, de "
"manière à ce que cette méthode ne lève jamais :exc:`KeyError`."

#: ../Doc/library/stdtypes.rst:4297
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Renvoie une nouvelle vue des éléments du dictionnaire (paires de ``(key, "
"value)``). Voir la :ref:`documentation des vues <dict-views>`."

#: ../Doc/library/stdtypes.rst:4302
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Renvoie une nouvelle vue des clefs du dictionnaire. Voir la :ref:"
"`documentation des vues <dict-views>`."

#: ../Doc/library/stdtypes.rst:4307
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Si *key* est dans le dictionnaire elle est supprimée et sa valeur est "
"renvoyée, sinon renvoie *default*.  Si *default* n'est pas donné et que "
"*key* n'est pas dans le dictionnaire, une :exc:`KeyError` est levée."

#: ../Doc/library/stdtypes.rst:4313
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Supprime et renvoie une paire ``(key, value)`` du dictionnaire. Les paires "
"sont renvoyées dans un ordre :abbr:`LIFO (dernière entrée, prenière sortie)`."

#: ../Doc/library/stdtypes.rst:4316
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` est pratique pour itérer un dictionnaire de manière "
"destructive, comme souvent dans les algorithmes sur les ensembles.  Si le "
"dictionnaire est vide, appeler :meth:`popitem` lève une :exc:`KeyError`."

#: ../Doc/library/stdtypes.rst:4320
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"L'ordre \"dernier entré, premier sorti\" (LIFO) est désormais assuré. Dans "
"les versions précédentes, :meth:`popitem` renvoyait une paire clé/valeur "
"arbitraire."

#: ../Doc/library/stdtypes.rst:4326
#, fuzzy
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""
"Renvoie un itérateur sur les clefs du dictionnaire.  C'est un raccourci pour "
"``iter(d.keys())``."

#: ../Doc/library/stdtypes.rst:4333
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Si *key* est dans le dictionnaire, sa valeur est renvoyée. Sinon, insère "
"*key* avec comme valeur *default* et renvoie *default*.  *default* vaut "
"``None`` par défaut."

#: ../Doc/library/stdtypes.rst:4339
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Met à jour le dictionnaire avec les paires de clef/valeur d'*other*, "
"écrasant les clefs existantes. Renvoie ``None``."

#: ../Doc/library/stdtypes.rst:4342
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` accepte aussi bien un autre dictionnaire qu'un itérable de "
"clef/valeurs (sous forme de *tuples* ou autre itérables de longueur deux).  "
"Si des paramètres par mot-clef sont donnés, le dictionnaire et ensuite mis à "
"jour avec ces pairs de clef/valeurs : ``d.update(red=1, blue=2)``."

#: ../Doc/library/stdtypes.rst:4349
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Renvoie une nouvelle vue des valeurs du dictionnaire.  Voir la :ref:"
"`documentation des vues <dict-views>`."

#: ../Doc/library/stdtypes.rst:4352
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""

#: ../Doc/library/stdtypes.rst:4360
#, fuzzy
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`."
msgstr ""
"Deux dictionnaires sont égaux si et seulement si ils ont les mêmes paires de "
"clef-valeur.  Les comparaisons d'ordre (``<``, ``<=``, ``>=``, ``>``) lèvent "
"une :exc:`TypeError`."

#: ../Doc/library/stdtypes.rst:4364
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"Les dictionnaires préservent l'ordre des insertions. Notez que modifier une "
"clé n'affecte pas l'ordre. Les clés ajoutées après un effacement sont "
"insérées à la fin. ::"

#: ../Doc/library/stdtypes.rst:4382
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"L'ordre d'un dictionnaire est toujours l'ordre des insertions. Ce "
"comportement était un détail d'implémentation de CPython depuis la version "
"3.6."

#: ../Doc/library/stdtypes.rst:4386
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr ""

#: ../Doc/library/stdtypes.rst:4398
msgid "Dictionaries are now reversible."
msgstr ""

#: ../Doc/library/stdtypes.rst:4403
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
":class:`types.MappingProxyType` peut être utilisé pour créer une vue en "
"lecture seule d'un :class:`dict`."

#: ../Doc/library/stdtypes.rst:4410
msgid "Dictionary view objects"
msgstr "Les vues de dictionnaires"

#: ../Doc/library/stdtypes.rst:4412
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"Les objets renvoyés par :meth:`dict.keys`, :meth:`dict.values` et :meth:"
"`dict.items` sont des *vues*.  Ils fournissent une vue dynamique des "
"éléments du dictionnaire, ce qui signifie que si le dictionnaire change, la "
"vue reflète ces changements."

#: ../Doc/library/stdtypes.rst:4417
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Les vues de dictionnaires peuvent être itérées et ainsi renvoyer les données "
"du dictionnaire, elle gèrent aussi les tests de présence :"

#: ../Doc/library/stdtypes.rst:4422
msgid "Return the number of entries in the dictionary."
msgstr "Renvoie le nombre d'entrées du dictionnaire."

#: ../Doc/library/stdtypes.rst:4426
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Renvoie un itérateur sur les clefs, les valeurs, ou les éléments "
"(représentés par des *tuples* de ``(key, value)`` du dictionnaire."

#: ../Doc/library/stdtypes.rst:4429
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"Les clefs et les valeurs sont itérées dans l'ordre de leur insertion. Ceci "
"permet la création de paires de ``(key, value)`` en utilisant :func:`zip` : "
"``pairs = zip(d.values(), d.keys())``.  Un autre moyen de construire la même "
"liste est ``pairs = [(v, k) for (k, v) in d.items()]``."

#: ../Doc/library/stdtypes.rst:4434
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Parcourir des vues tout en ajoutant ou supprimant des entrées dans un "
"dictionnaire peut lever une :exc:`RuntimeError` ou ne pas fournir toutes les "
"entrées."

#: ../Doc/library/stdtypes.rst:4437
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "L'ordre d'un dictionnaire est toujours l'ordre des insertions."

#: ../Doc/library/stdtypes.rst:4442
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Renvoie ``True`` si *x* est dans les clefs, les valeurs, ou les éléments du "
"dictionnaire sous-jacent (dans le dernier cas, *x* doit être un *tuple* "
"``(key, value)``)."

#: ../Doc/library/stdtypes.rst:4447
#, fuzzy
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""
"Renvoie un itérateur sur les clefs, les valeurs, ou les éléments "
"(représentés par des *tuples* de ``(key, value)`` du dictionnaire."

#: ../Doc/library/stdtypes.rst:4450
#, fuzzy
msgid "Dictionary views are now reversible."
msgstr "Les vues de dictionnaires"

#: ../Doc/library/stdtypes.rst:4454
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all "
"values are hashable, so that ``(key, value)`` pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  For set-like views, all "
"of the operations defined for the abstract base class :class:`collections."
"abc.Set` are available (for example, ``==``, ``<``, or ``^``)."
msgstr ""
"Les vues de clefs sont semblables à des ensembles puisque leurs entrées sont "
"uniques et hachables.  Si toutes les valeurs sont hachables, et qu'ainsi "
"toutes les paires de ``(key, value`` sont uniques et hachables, alors la vue "
"donnée par *items()* est aussi semblable à un ensemble.  (Les vues données "
"par *items()* ne sont généralement pas traitées comme des ensembles, car "
"leurs valeurs ne sont généralement pas uniques.)  Pour les vues semblables "
"aux ensembles, toutes les opérations définies dans la classe de base "
"abstraite  :class:`collections.abc.Set` sont disponibles (comme ``==``, "
"``<``, ou ``^``)."

#: ../Doc/library/stdtypes.rst:4461
msgid "An example of dictionary view usage::"
msgstr "Exemple d'utilisation de vue de dictionnaire ::"

#: ../Doc/library/stdtypes.rst:4496
msgid "Context Manager Types"
msgstr "Le type gestionnaire de contexte"

#: ../Doc/library/stdtypes.rst:4503
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"L'instruction :keyword:`with` permet l'existence de contextes définis à "
"l'exécution par des gestionnaires de contextes. C'est implémenté via une "
"paire de méthodes permettant de définir un contexte, à l'exécution, qui est "
"entré avant l'exécution du corps de l'instruction, et qui est quitté lorsque "
"l'instruction se termine :"

#: ../Doc/library/stdtypes.rst:4511
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Entre dans le contexte à l'exécution, soit se renvoyant lui-même, soit en "
"renvoyant un autre objet en lien avec ce contexte. La valeur renvoyée par "
"cette méthode est liée à l'identifiant donné au :keyword:`!as` de "
"l'instruction :keyword:`with` utilisant ce gestionnaire de contexte."

#: ../Doc/library/stdtypes.rst:4516
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Un exemple de gestionnaire de contexte se renvoyant lui-même est :term:`file "
"object`. Les *file objects* se renvoient eux-même depuis ``__enter__()`` et "
"autorisent :func:`open` à être utilisé comme contexte à une instruction :"
"keyword:`with`."

#: ../Doc/library/stdtypes.rst:4520
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"Un exemple de gestionnaire de contexte renvoyant un objet connexe est celui "
"renvoyé par :func:`decimal.localcontext`. Ces gestionnaires remplacent le "
"contexte décimal courant par une copie de l'original, copie qui est "
"renvoyée. Ça permet de changer le contexte courant dans le corps du :keyword:"
"`with` sans affecter le code en dehors de l'instruction :keyword:`!with`."

#: ../Doc/library/stdtypes.rst:4530
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Sort du contexte et renvoie un booléen indiquant si une exception survenue "
"doit être supprimée.  Si une exception est survenue lors de l'exécution du "
"corps de l'instruction :keyword:`with`, les arguments contiennent le type de "
"l'exception, sa valeur, et la trace de la pile (*traceback*). Sinon les "
"trois arguments valent ``None``."

#: ../Doc/library/stdtypes.rst:4535
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"L'instruction :keyword:`with` inhibera l'exception si cette méthode renvoie "
"une valeur vraie, l'exécution continuera ainsi à l'instruction suivant "
"immédiatement l'instruction :keyword:`!with`. Sinon, l'exception continuera "
"de se propager après la fin de cette méthode. Les exceptions se produisant "
"pendant l'exécution de cette méthode remplaceront toute exception qui s'est "
"produite dans le corps du :keyword:`!with`."

#: ../Doc/library/stdtypes.rst:4542
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`__exit__` "
"method has actually failed."
msgstr ""
"L'exception reçue ne doit jamais être relancée explicitement, cette méthode "
"devrait plutôt renvoyer une valeur fausse pour indiquer que son exécution "
"s'est terminée avec succès et qu'elle ne veut pas supprimer l'exception. "
"Ceci permet au code de gestion du contexte de comprendre si une méthode :"
"meth:`__exit__` a échoué."

#: ../Doc/library/stdtypes.rst:4548
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python définit plusieurs gestionnaires de contexte pour faciliter la "
"synchronisation des fils d'exécution, la fermeture des fichiers ou d'autres "
"objets, et la configuration du contexte arithmétique décimal. Ces types "
"spécifiques ne sont pas traités différemment, ils respectent simplement le "
"protocole de gestion du contexte. Voir les exemples dans la documentation du "
"module :mod:`contextlib`."

#: ../Doc/library/stdtypes.rst:4554
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`__enter__` and :meth:`__exit__` methods, rather than the iterator produced "
"by an undecorated generator function."
msgstr ""
"Les :term:`generator`\\s de Python et le décorateur :class:`contextlib."
"contextmanager` permettent d'implémenter simplement ces protocoles.  Si un "
"générateur est décoré avec :class:`contextlib. contextmanager`, elle "
"renverra un gestionnaire de contexte implémentant les méthodes :meth:"
"`__enter__` et :meth:`__exit__`, plutôt que l'itérateur produit par un "
"générateur non décoré."

#: ../Doc/library/stdtypes.rst:4561
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Notez qu'il n'y a pas d'emplacement spécifique pour ces méthodes dans la "
"structure de type pour les objets Python dans l'API Python/C. Les types "
"souhaitant définir ces méthodes doivent les fournir comme une méthode "
"accessible en Python. Comparé au coût de la mise en place du contexte "
"d'exécution, les le coût d'un accès au dictionnaire d'une classe unique est "
"négligeable."

#: ../Doc/library/stdtypes.rst:4571
msgid "Other Built-in Types"
msgstr "Autres types natifs"

#: ../Doc/library/stdtypes.rst:4573
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"L'interpréteur gère aussi d'autres types d'objets, la plupart ne supportant "
"cependant qu'une ou deux opérations."

#: ../Doc/library/stdtypes.rst:4580
msgid "Modules"
msgstr "Modules"

#: ../Doc/library/stdtypes.rst:4582
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"La seule opération spéciale sur un module est l'accès à ses attributs : ``m."
"name``, où *m* est un module et *name* donne accès un nom défini dans la "
"table des symboles de *m*.  Il est possible d'assigner un attribut de "
"module.  (Notez que l'instruction :keyword:`import` n'est pas strictement "
"une opération sur un objet module. ``import foo`` ne nécessite pas qu'un "
"objet module nommé *foo* existe, il nécessite cependant une *définition* "
"(externe) d'un module nommé *foo* quelque part.)"

#: ../Doc/library/stdtypes.rst:4589
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Un attribut spécial à chaque module est :attr:`~object.__dict__`. C'est le "
"dictionnaire contenant la table des symbole du module. Modifier ce "
"dictionnaire changera la table des symboles du module, mais assigner "
"directement :attr:`~object.__dict__` n'est pas possible (vous pouvez écrire "
"``m.__dict__['a'] = 1``, qui donne ``1`` comme valeur pour ``m.a``, mais "
"vous ne pouvez pas écrire ``m.__dict__ = {}``). Modifier :attr:`~object."
"__dict__` directement n'est pas recommandé."

#: ../Doc/library/stdtypes.rst:4597
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Les modules natifs à l'interpréteur sont représentés ``<module 'sys' (built-"
"in)>``.  S'ils sont chargés depuis un fichier, ils sont représentés "
"``<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."

#: ../Doc/library/stdtypes.rst:4605
msgid "Classes and Class Instances"
msgstr "Les classes et instances de classes"

#: ../Doc/library/stdtypes.rst:4607
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Voir :ref:`objects` et :ref:`class`."

#: ../Doc/library/stdtypes.rst:4613
msgid "Functions"
msgstr "Fonctions"

#: ../Doc/library/stdtypes.rst:4615
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Les objets fonctions sont crées par les définitions de fonctions.  La seule "
"opération applicable à un objet fonction est de l'appeler : ``func(argument-"
"list)``."

#: ../Doc/library/stdtypes.rst:4618
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Il existe en fait deux catégories d'objets fonctions : Les fonctions natives "
"et les fonctions définies par l'utilisateur.  Les deux gèrent les mêmes "
"opérations (l'appel à la fonction), mais leur implémentation est différente, "
"d'où les deux types distincts."

#: ../Doc/library/stdtypes.rst:4622
msgid "See :ref:`function` for more information."
msgstr "Voir :ref:`function` pour plus d'information."

#: ../Doc/library/stdtypes.rst:4628
msgid "Methods"
msgstr "Méthodes"

#: ../Doc/library/stdtypes.rst:4632
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"Les méthodes sont des fonctions appelées via la notation d'attribut.  Il en "
"existe deux variantes : Les méthodes natives (tel que :meth:`append` sur les "
"listes), et les méthodes d'instances de classes. Les méthodes natives sont "
"représentées avec le type qui les supporte."

#: ../Doc/library/stdtypes.rst:4637
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Si vous accédez à une méthode (une fonction définie dans l'espace de nommage "
"d'une classe) via une instance, vous obtenez un objet spécial, une :dfn:"
"`bound method` (aussi appelée :dfn:`instance method`). Lorsqu'elle est "
"appelée, elle ajoute l'argument ``self`` à la liste des arguments.  Les "
"méthodes liées ont deux attributs spéciaux, en lecture seule : ``m."
"__self__`` est l'objet sur lequel la méthode travaille, et ``m.__func__`` "
"est la fonction implémentant la méthode. Appeler ``m(arg-1, arg-2, …, arg-"
"n)`` est tout à fait équivalent à appeler ``m.__func__(m.__self__, arg-1, "
"arg-2, …, arg-n)``."

#: ../Doc/library/stdtypes.rst:4646
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""
"Comme les objets fonctions, les objets méthodes, liées, acceptent des "
"attributs arbitraires. Cependant, puisque les attributs de méthodes doivent "
"être stockés dans la fonction sous-jacente (``meth.__func__``), affecter des "
"attributs à des objets *bound method* est interdit. Toute tentative "
"d'affecter un attribut sur un objet *bound method* lèvera une :exc:"
"`AttributeError`. Pour affecter l'attribut, vous devrez explicitement "
"l'affecter à sa fonction sous-jacente ::"

#: ../Doc/library/stdtypes.rst:4666 ../Doc/library/stdtypes.rst:4694
msgid "See :ref:`types` for more information."
msgstr "Voir :ref:`types` pour plus d'information."

#: ../Doc/library/stdtypes.rst:4674
msgid "Code Objects"
msgstr "Objets code"

#: ../Doc/library/stdtypes.rst:4680
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Les objets code sont utilisés par l'implémentation pour représenter du code "
"Python \"pseudo-compilé\", comme un corps de fonction. Ils sont différents "
"des objets fonction dans le sens où ils ne contiennent pas de référence à "
"leur environnement global d'exécution. Les objets code sont renvoyés par la "
"fonction native :func:`compile` et peuvent être obtenus des objets fonction "
"via leur attribut :attr:`__code__`. Voir aussi le module :mod:`code`."

#: ../Doc/library/stdtypes.rst:4691
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Les objets code peuvent être exécutés ou évalués en les passant (au lieu "
"d'une chaîne contenant du code) aux fonction natives :func:`exec` ou :func:"
"`eval`."

#: ../Doc/library/stdtypes.rst:4700
msgid "Type Objects"
msgstr "Objets type"

#: ../Doc/library/stdtypes.rst:4706
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Les objets types représentent les différents types d'objets. Le type d'un "
"objet est obtenu via la fonction native :func:`type`. Il n'existe aucune "
"opération spéciale sur les types. Le module standard :mod:`types` définit "
"les noms de tous les types natifs."

#: ../Doc/library/stdtypes.rst:4711
msgid "Types are written like this: ``<class 'int'>``."
msgstr "Les types sont représentés : ``<class 'int'>``."

#: ../Doc/library/stdtypes.rst:4717
msgid "The Null Object"
msgstr "L'objet Null"

#: ../Doc/library/stdtypes.rst:4719
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Cet objet est renvoyé par les fonctions ne renvoyant pas explicitement une "
"valeur. Il ne supporte aucune opération spéciale. Il existe exactement un "
"objet *null* nommé ``None`` (c'est un nom natif). ``type(None)()``."

#: ../Doc/library/stdtypes.rst:4723
msgid "It is written as ``None``."
msgstr "C'est écrit ``None``."

#: ../Doc/library/stdtypes.rst:4730
msgid "The Ellipsis Object"
msgstr "L'objet points de suspension"

#: ../Doc/library/stdtypes.rst:4732
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Cet objet est utilisé classiquement lors des découpes (voir :ref:"
"`slicings`). Il ne supporte aucune opération spéciale. Il n'y a qu'un seul "
"objet *ellipsis*, nommé :const:`Ellipsis` (un nom natif). ``type(Ellipsis)"
"()`` produit le *singleton* :const:`Ellipsis`."

#: ../Doc/library/stdtypes.rst:4737
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "C'est écrit ``Ellipsis`` ou ``...``."

#: ../Doc/library/stdtypes.rst:4743
msgid "The NotImplemented Object"
msgstr "L'objet *NotImplemented*"

#: ../Doc/library/stdtypes.rst:4745
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"Cet objet est renvoyé depuis des comparaisons ou des opérations binaires "
"effectuées sur des types qu'elles ne supportent pas. Voir :ref:`comparisons` "
"pour plus d'informations. Il n'y a qu'un seul objet ``NotImplemented``. "
"``type(NotImplemented)()`` renvoie un *singleton*."

#: ../Doc/library/stdtypes.rst:4750
msgid "It is written as ``NotImplemented``."
msgstr "C'est écrit ``NotImplemented``."

#: ../Doc/library/stdtypes.rst:4756
msgid "Boolean Values"
msgstr "Valeurs booléennes"

#: ../Doc/library/stdtypes.rst:4758
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""
"Les valeurs booléennes sont les deux objets constants ``False`` et ``True``. "
"Ils sont utilisés pour représenter les valeurs de vérité (bien que d'autres "
"valeurs peuvent être considérées vraies ou fausses). Dans des contextes "
"numériques (par exemple en argument d'un opérateur arithmétique), ils se "
"comportent comme les nombres entiers 0 et 1, respectivement.  La fonction "
"native :func:`bool` peut être utilisée pour convertir n'importe quelle "
"valeur en booléen tant que la valeur peut être interprétée en une valeur de "
"vérité (voir :ref:`truth` au dessus)."

#: ../Doc/library/stdtypes.rst:4771
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "Ils s'écrivent ``False`` et ``True``, respectivement."

#: ../Doc/library/stdtypes.rst:4777
msgid "Internal Objects"
msgstr "Objets internes"

#: ../Doc/library/stdtypes.rst:4779
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"Voir :ref:`types`. Ils décrivent les objets *stack frame*, *traceback*, et "
"*slice*."

#: ../Doc/library/stdtypes.rst:4786
msgid "Special Attributes"
msgstr "Attributs spéciaux"

#: ../Doc/library/stdtypes.rst:4788
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"L'implémentation ajoute quelques attributs spéciaux et en lecture seule, à "
"certains types, lorsque ça a du sens. Certains ne sont *pas* listés par la "
"fonction native :func:`dir`."

#: ../Doc/library/stdtypes.rst:4795
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Un dictionnaire ou un autre *mapping object* utilisé pour stocker les "
"attributs (modifiables) de l'objet."

#: ../Doc/library/stdtypes.rst:4801
msgid "The class to which a class instance belongs."
msgstr "La classe de l'instance de classe."

#: ../Doc/library/stdtypes.rst:4806
msgid "The tuple of base classes of a class object."
msgstr "Le *tuple* des classes parentes d'un objet classe."

#: ../Doc/library/stdtypes.rst:4811
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr "Le nom de la classe, fonction, méthode, descripteur, ou générateur."

#: ../Doc/library/stdtypes.rst:4817
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"Le :term:`qualified name` de la classe, fonction, méthode, descripteur, ou "
"générateur."

#: ../Doc/library/stdtypes.rst:4825
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"Cet attribut est un *tuple* contenant les classes parents prises en compte "
"lors de la résolution de méthode."

#: ../Doc/library/stdtypes.rst:4831
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"Cette méthode peut être surchargée par une méta-classe pour personnaliser "
"l'ordre de la recherche de méthode pour ses instances.  Elle est appelée à "
"la l'initialisation de la classe, et son résultat est stocké dans "
"l'attribut :attr:`~class.__mro__`."

#: ../Doc/library/stdtypes.rst:4838
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive. Example::"
msgstr ""
"Chaque classe garde une liste de références faibles à ses classes filles "
"immédiates. Cette méthode renvoie la liste de toutes ces références encore "
"valables. Exemple ::"

#: ../Doc/library/stdtypes.rst:4847
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/library/stdtypes.rst:4848
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Plus d'informations sur ces méthodes spéciales peuvent être trouvées dans le "
"*Python Reference Manual* (:ref:`customization`)."

#: ../Doc/library/stdtypes.rst:4851
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Par conséquent, la liste ``[1, 2]`` est considérée égale à ``[1.0, 2.0]``. "
"Idem avec des tuples."

#: ../Doc/library/stdtypes.rst:4854
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Nécessairement, puisque l'analyseur ne peut pas discerner le type des "
"opérandes."

#: ../Doc/library/stdtypes.rst:4856
msgid ""
"Cased characters are those with general category property being one of \"Lu"
"\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Les caractères capitalisables sont ceux dont la propriété Unicode *general "
"category* est soit \"Lu\" (pour *Letter*, *uppercase*), soit \"Ll\" (pour "
"*Letter*, *lowercase*), soit \"Lt\" (pour *Letter*, *titlecase*)."

#: ../Doc/library/stdtypes.rst:4859
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Pour insérer un *tuple*, vous devez donc donner un *tuple* d'un seul "
"élément, contenant le *tuple* à insérer."

#~ msgid ""
#~ "Objects of different types, except different numeric types, never compare "
#~ "equal. Furthermore, some types (for example, function objects) support "
#~ "only a degenerate notion of comparison where any two objects of that type "
#~ "are unequal.  The ``<``, ``<=``, ``>`` and ``>=`` operators will raise a :"
#~ "exc:`TypeError` exception when comparing a complex number with another "
#~ "built-in numeric type, when the objects are of different types that "
#~ "cannot be compared, or in other cases where there is no defined ordering."
#~ msgstr ""
#~ "Les objets de différents types, à l'exception de différents types "
#~ "numériques, ne peuvent en aucun cas être égaux. En outre, certains types "
#~ "(par exemple, les objets fonction) ne gèrent qu'une une notion dégénérée "
#~ "de la comparaison où deux objets de ce type sont inégaux. Les opérateurs "
#~ "``<``, ``<=``, ``>`` et ``>=`` lèvent une exception :exc:`TypeError` "
#~ "lorsqu'on  compare un nombre complexe avec un autre type natif numérique, "
#~ "lorsque les objets sont de différents types qui ne peuvent pas être "
#~ "comparés, ou dans d'autres cas où il n'y a pas d'ordre défini."

#~ msgid ""
#~ "Return true if there are only whitespace characters in the string and "
#~ "there is at least one character, false otherwise.  Whitespace characters  "
#~ "are those characters defined in the Unicode character database as \"Other"
#~ "\" or \"Separator\" and those with bidirectional property being one of "
#~ "\"WS\", \"B\", or \"S\"."
#~ msgstr ""
#~ "Donne ``True`` s'il n'y a que des caractères blancs dans la chaîne et il "
#~ "y a au moins un caractère, sinon ``False``. Les caractères blancs sont "
#~ "les caractères définis dans la base de données de caractères Unicode "
#~ "comme *\"Other\"* ou *\"Separator\"* ainsi que ceux ayant la propriété "
#~ "bidirectionnelle valant \"WS\", \"B\" ou \"S\"."

#~ msgid ""
#~ ":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
#~ "defaults to ``None``."
#~ msgstr ""
#~ ":meth:`fromkeys` est une *class method* qui renvoie un nouveau "
#~ "dictionnaire. *value* vaut ``None`` par défaut."

#~ msgid "Return a new set with a shallow copy of *s*."
#~ msgstr "Renvoie un nouvel ensemble, copie de surface de *s*."

#~ msgid ""
#~ "Bitwise operations only make sense for integers.  Negative numbers are "
#~ "treated as their 2's complement value (this assumes that there are enough "
#~ "bits so that no overflow occurs during the operation)."
#~ msgstr ""
#~ "Les opérations sur les bits n'ont de sens que pour les entiers. Les "
#~ "nombres négatifs sont traités comme leur complément à 2 (ce qui suppose "
#~ "un assez grand nombre de bits afin qu'aucun débordement ne se produise "
#~ "pendant l'opération)."

#~ msgid ":pep:`461`."
#~ msgstr ":pep:`461`."

#~ msgid "``None``"
#~ msgstr "``None``"

#~ msgid "``False``"
#~ msgstr "``False``"

#~ msgid "any empty sequence, for example, ``''``, ``()``, ``[]``."
#~ msgstr "toute séquence vide, par exemple, ``''``, ``()``, ``[]``."

#~ msgid "any empty mapping, for example, ``{}``."
#~ msgstr "toute dictionnaire vide, par exemple, ``{}``."

#~ msgid ""
#~ "instances of user-defined classes, if the class defines a :meth:"
#~ "`__bool__` or :meth:`__len__` method, when that method returns the "
#~ "integer zero or :class:`bool` value ``False``. [1]_"
#~ msgstr ""
#~ "pour les instances de classes définies par l'utilisateur, si la classe "
#~ "définit une méthode :meth:`__bool__` ou :meth:`__len__`, lorsque cette "
#~ "méthode renvoie le nombre entier zéro ou la valeur ``False`` de la "
#~ "classe :class:`bool`. [1]_"

#~ msgid ""
#~ "All other values are considered true --- so objects of many types are "
#~ "always true."
#~ msgstr ""
#~ "Toutes les autres valeurs sont considérées comme vraies --- donc des "
#~ "objets de beaucoup de types sont toujours vrais."

#~ msgid "Bytes"
#~ msgstr "Bytes"

#~ msgid ""
#~ "The alternate form causes a leading zero (``'0'``) to be inserted between "
#~ "left-hand padding and the formatting of the number if the leading "
#~ "character of the result is not already a zero."
#~ msgstr ""
#~ "La forme alternative insère un zéro (``'0'``) entre le rembourrage gauche "
#~ "et le formatage du nombre si son premier caractère n'est pas déjà un zéro."
