# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-08-01 13:21+0200\n"
"PO-Revision-Date: 2017-09-22 10:16+0200\n"
"Last-Translator: Julien Palard <julien@palard.fr>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.0.4\n"

#: ../Doc/library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Types natifs"

#: ../Doc/library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"Les sections suivantes décrivent les types standards intégrés à "
"l'interpréteur."

#: ../Doc/library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"Les principaux types natifs sont les numériques, les séquences, les "
"dictionnaires, les classes, les instances et les exceptions."

#: ../Doc/library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Certaines classes de collection sont mutables. Les méthodes qui ajoutent, "
"retirent, ou réorganisent leurs éléments sur place, et qui ne renvoient pas "
"un élément spécifique, ne renvoient jamais l'instance de la collection elle-"
"même, mais ``None``."

#: ../Doc/library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared, tested for truth value, and "
"converted to a string (with the :func:`repr` function or the slightly "
"different :func:`str` function).  The latter function is implicitly used "
"when an object is written by the :func:`print` function."
msgstr ""
"Certaines opérations sont prises en charge par plusieurs types d'objets; en "
"particulier, pratiquement tous les objets peuvent être comparés, testés "
"(valeur booléenne), et convertis en une chaîne (avec la fonction :func:"
"`repr` ou la fonction légèrement différente :func:`str`). Cette dernière est "
"implicitement utilisée quand un objet est écrit par la fonction :func:"
"`print`."

#: ../Doc/library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Valeurs booléennes"

#: ../Doc/library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Tout objet peut être comparé à une valeur booléenne, typiquement dans une "
"condition :keyword:`if` ou :keyword:`while` ou comme opérande des opérations "
"booléennes ci-dessous."

#: ../Doc/library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the "
"built-in objects considered false:"
msgstr ""
"Par défaut, tout objet est considéré vrai à moins que sa classe définisse "
"soit une méthode :meth:`__bool__` renvoyant ``False`` soit une méthode :meth:"
"`__len__` renvoyant zéro lorsqu'elle est appelée avec l'objet. [1]_  Voici "
"la majorité des objets natifs considérés comme étant faux :"

#: ../Doc/library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``."
msgstr "les constantes définies comme étant fausses : ``None`` et ``False``."

#: ../Doc/library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"zéro de tout type numérique: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"

#: ../Doc/library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"Les chaînes et collections vides : ``''``, ``()``, ``[]``, ``{}``, "
"``set()``, ``range(0)``"

#: ../Doc/library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Les opérations et fonctions natives dont le résultat est booléen donnent "
"toujours ``0`` ou ``False`` pour faux et ``1`` ou ``True`` pour vrai, sauf "
"indication contraire. (Exception importante : les opérations booléennes "
"``or`` et ``and`` renvoient toujours l'une de leurs opérandes.)"

#: ../Doc/library/stdtypes.rst:78
msgid "Boolean Operations --- :keyword:`and`, :keyword:`or`, :keyword:`not`"
msgstr ""
"Opérations booléennes --- :keyword:`and`, :keyword:`or`, :keyword:`not`"

#: ../Doc/library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Ce sont les opérations booléennes, classées par priorité ascendante :"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:143
#: ../Doc/library/stdtypes.rst:271 ../Doc/library/stdtypes.rst:360
#: ../Doc/library/stdtypes.rst:410 ../Doc/library/stdtypes.rst:846
#: ../Doc/library/stdtypes.rst:1041
msgid "Operation"
msgstr "Opération"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:271
#: ../Doc/library/stdtypes.rst:360 ../Doc/library/stdtypes.rst:410
#: ../Doc/library/stdtypes.rst:846 ../Doc/library/stdtypes.rst:1041
msgid "Result"
msgstr "Résultat"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:271
#: ../Doc/library/stdtypes.rst:410 ../Doc/library/stdtypes.rst:846
#: ../Doc/library/stdtypes.rst:1041 ../Doc/library/stdtypes.rst:2154
#: ../Doc/library/stdtypes.rst:3256
msgid "Notes"
msgstr "Notes"

#: ../Doc/library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: ../Doc/library/stdtypes.rst:87
msgid "if *x* is false, then *y*, else *x*"
msgstr "si *x* est faux, alors *y*, sinon *x*"

#: ../Doc/library/stdtypes.rst:87 ../Doc/library/stdtypes.rst:281
#: ../Doc/library/stdtypes.rst:848 ../Doc/library/stdtypes.rst:851
#: ../Doc/library/stdtypes.rst:1052 ../Doc/library/stdtypes.rst:2160
#: ../Doc/library/stdtypes.rst:3262
msgid "\\(1)"
msgstr "\\(1)"

#: ../Doc/library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: ../Doc/library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "si *x* est faux, alors *x*, sinon *y*"

#: ../Doc/library/stdtypes.rst:90 ../Doc/library/stdtypes.rst:284
#: ../Doc/library/stdtypes.rst:304 ../Doc/library/stdtypes.rst:1080
#: ../Doc/library/stdtypes.rst:2164 ../Doc/library/stdtypes.rst:2166
#: ../Doc/library/stdtypes.rst:3266 ../Doc/library/stdtypes.rst:3268
msgid "\\(2)"
msgstr "\\(2)"

#: ../Doc/library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: ../Doc/library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "si *x* est faux, alors ``True``, sinon ``False``"

#: ../Doc/library/stdtypes.rst:93 ../Doc/library/stdtypes.rst:860
#: ../Doc/library/stdtypes.rst:1083 ../Doc/library/stdtypes.rst:2168
#: ../Doc/library/stdtypes.rst:2170 ../Doc/library/stdtypes.rst:2172
#: ../Doc/library/stdtypes.rst:2174 ../Doc/library/stdtypes.rst:3270
#: ../Doc/library/stdtypes.rst:3272 ../Doc/library/stdtypes.rst:3274
#: ../Doc/library/stdtypes.rst:3276
msgid "\\(3)"
msgstr "\\(3)"

#: ../Doc/library/stdtypes.rst:102 ../Doc/library/stdtypes.rst:315
#: ../Doc/library/stdtypes.rst:428 ../Doc/library/stdtypes.rst:887
#: ../Doc/library/stdtypes.rst:1091 ../Doc/library/stdtypes.rst:2200
#: ../Doc/library/stdtypes.rst:3306
msgid "Notes:"
msgstr "Notes : "

#: ../Doc/library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Ceci est un opérateur court-circuit : il n'évalue le deuxième argument que "
"si le premier est faux."

#: ../Doc/library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Ceci est un opérateur court-circuit, il n'évalue le deuxième argument si le "
"premier est vrai."

#: ../Doc/library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` a une priorité inférieure à celle des opérateurs non-booléens, donc "
"``not a == b`` est interprété comme ``not (a == b)`` et ``a == not b`` est "
"une erreur de syntaxe."

#: ../Doc/library/stdtypes.rst:120
msgid "Comparisons"
msgstr "Comparaisons"

#: ../Doc/library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Il y a huit opérations de comparaison en Python. Elles ont toutes la même "
"priorité (qui est supérieure à celle des opérations booléennes). Les "
"comparaisons peuvent être enchaînées arbitrairement; par exemple, ``x < y <= "
"z`` est équivalent à ``x < y and y <= z``, sauf que *y* n'est évalué qu'une "
"seule fois (mais dans les deux cas *z* n'est pas évalué du tout quand ``x < "
"y`` est faux)."

#: ../Doc/library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "Ce tableau résume les opérations de comparaison :"

#: ../Doc/library/stdtypes.rst:143 ../Doc/library/stdtypes.rst:2131
#: ../Doc/library/stdtypes.rst:2154 ../Doc/library/stdtypes.rst:3233
#: ../Doc/library/stdtypes.rst:3256
msgid "Meaning"
msgstr "Signification"

#: ../Doc/library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../Doc/library/stdtypes.rst:145
msgid "strictly less than"
msgstr "strictement inférieur"

#: ../Doc/library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../Doc/library/stdtypes.rst:147
msgid "less than or equal"
msgstr "inférieur ou égal"

#: ../Doc/library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../Doc/library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "strictement supérieur"

#: ../Doc/library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../Doc/library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "supérieur ou égal"

#: ../Doc/library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../Doc/library/stdtypes.rst:153
msgid "equal"
msgstr "égal"

#: ../Doc/library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../Doc/library/stdtypes.rst:155
msgid "not equal"
msgstr "différent"

#: ../Doc/library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: ../Doc/library/stdtypes.rst:157
msgid "object identity"
msgstr "identité d'objet"

#: ../Doc/library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: ../Doc/library/stdtypes.rst:159
msgid "negated object identity"
msgstr "contraire de l'identité d'objet"

#: ../Doc/library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. Furthermore, some types (for example, function objects) support only "
"a degenerate notion of comparison where any two objects of that type are "
"unequal.  The ``<``, ``<=``, ``>`` and ``>=`` operators will raise a :exc:"
"`TypeError` exception when comparing a complex number with another built-in "
"numeric type, when the objects are of different types that cannot be "
"compared, or in other cases where there is no defined ordering."
msgstr ""
"Les objets de différents types, à l'exception de différents types "
"numériques, ne peuvent en aucun cas être égaux. En outre, certains types "
"(par exemple, les objets fonction) ne gèrent qu'une une notion dégénérée de "
"la comparaison où deux objets de ce type sont inégaux. Les opérateurs ``<``, "
"``<=``, ``>`` et ``>=`` lèvent une exception :exc:`TypeError` lorsqu'on  "
"compare un nombre complexe avec un autre type natif numérique, lorsque les "
"objets sont de différents types qui ne peuvent pas être comparés, ou dans "
"d'autres cas où il n'y a pas d'ordre défini."

#: ../Doc/library/stdtypes.rst:182
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`__eq__` method."
msgstr ""
"Des instances différentes d'une classe sont normalement considérées "
"différentes à moins que la classe ne définisse la méthode :meth:`__eq__`."

#: ../Doc/library/stdtypes.rst:185
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, and :meth:"
"`__ge__` (in general, :meth:`__lt__` and :meth:`__eq__` are sufficient, if "
"you want the conventional meanings of the comparison operators)."
msgstr ""
"Les instances d'une classe ne peuvent pas être ordonnées par rapport à "
"d'autres instances de la même classe, ou d'autres types d'objets, à moins "
"que la classe ne définisse suffisamment de méthodes parmi :meth:`__lt__`, :"
"meth:`__le__`, :meth:`__gt__` et :meth:`__ge__` (en général, :meth:`__lt__` "
"et :meth:`__eq__` sont suffisantes, si vous voulez les significations "
"classiques des opérateurs de comparaison)."

#: ../Doc/library/stdtypes.rst:191
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"Le comportement des opérateurs :keyword:`is` et :keyword:`is not` ne peut "
"pas être personnalisé ; aussi ils peuvent être appliqués à deux objets "
"quelconques et ne soulèvent jamais d'exception."

#: ../Doc/library/stdtypes.rst:199
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported only by sequence types (below)."
msgstr ""
"Deux autres opérations avec la même priorité syntaxique, :keyword:`in` et :"
"keyword:`not in`, sont pris en charge uniquement par des types séquence (ci-"
"dessous)."

#: ../Doc/library/stdtypes.rst:206
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Types numériques --- :class:`int`, :class:`float`, :class:`complex`"

#: ../Doc/library/stdtypes.rst:216
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:type:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes additional "
"numeric types, :mod:`fractions` that hold rationals, and :mod:`decimal` that "
"hold floating-point numbers with user-definable precision.)"
msgstr ""
"Il existe trois types numériques distincts: :dfn:`integers` (entiers), :dfn:"
"`floating point numbers` (nombres flottants) et :dfn:`complex numbers` "
"(nombres complexes). En outre, les booléens sont un sous-type des entiers. "
"Les entiers ont une précision illimitée. Les nombres à virgule flottante "
"sont généralement implémentés en utilisant des :c:type:`double` en C ; des "
"informations sur la précision et la représentation interne des nombres à "
"virgule flottante pour la machine sur laquelle le programme est en cours "
"d'exécution est disponible dans :data:`sys.float_info`. Les nombres "
"complexes ont une partie réelle et une partie imaginaire, qui sont chacunes "
"des nombres à virgule flottante. Pour extraire ces parties d'un nombre "
"complexe *z*, utilisez ``z.real`` et ``z.imag``. (La bibliothèque standard "
"comprend d'autres types numériques, :mod:`fractions` qui stocke des "
"rationnels et :mod:`decimal` qui stocke les nombres à virgule flottante avec "
"une précision définissable par l'utilisateur.)"

#: ../Doc/library/stdtypes.rst:238
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"Les nombres sont créés par des littéraux numériques ou sont le résultat de "
"fonctions natives ou d'opérateurs. Les entiers littéraux basiques (y compris "
"leur forme hexadécimale, octale et binaire) donnent des entiers. Les nombres "
"littéraux contenant un point décimal ou un exposant donnent des nombres à "
"virgule flottante. Suffixer ``'j'`` ou ``'J'`` à un nombre littéral donne un "
"nombre imaginaire (un nombre complexe avec une partie réelle nulle) que vous "
"pouvez ajouter à un nombre entier ou un à virgule flottante pour obtenir un "
"nombre complexe avec une partie réelle et une partie imaginaire."

#: ../Doc/library/stdtypes.rst:259
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex.  Comparisons between numbers "
"of mixed type use the same rule. [2]_ The constructors :func:`int`, :func:"
"`float`, and :func:`complex` can be used to produce numbers of a specific "
"type."
msgstr ""
"Python gère pleinement l'arithmétique mixte : quand un opérateur "
"arithmétique binaire a des opérandes de types numériques différents, "
"l'opérande avec le type \"le plus étroit\" est élargie au type de l'autre, "
"où l'entier est plus étroit que la virgule flottante, qui est plus étroite "
"que les complexes. Les comparaisons entre des nombres de type mixte "
"utilisent la même règle. [2]_ Les constructeurs :func:`int`, :func:`float` "
"et :func:`complex` peuvent être utilisé pour produire des nombres d'un type "
"spécifique."

#: ../Doc/library/stdtypes.rst:266
msgid ""
"All numeric types (except complex) support the following operations, sorted "
"by ascending priority (all numeric operations have a higher priority than "
"comparison operations):"
msgstr ""
"Tous les types numériques (sauf complexe) gèrent les opérations suivantes, "
"classées par priorité ascendante (toutes les opérations numériques ont une "
"priorité plus élevée que les opérations de comparaison) :"

#: ../Doc/library/stdtypes.rst:271
msgid "Full documentation"
msgstr "Documentation complète"

#: ../Doc/library/stdtypes.rst:273
msgid "``x + y``"
msgstr "``x + y``"

#: ../Doc/library/stdtypes.rst:273
msgid "sum of *x* and *y*"
msgstr "somme de *x* et *y*"

#: ../Doc/library/stdtypes.rst:275
msgid "``x - y``"
msgstr "``x - y``"

#: ../Doc/library/stdtypes.rst:275
msgid "difference of *x* and *y*"
msgstr "différence de *x* et *y*"

#: ../Doc/library/stdtypes.rst:277
msgid "``x * y``"
msgstr "``x * y``"

#: ../Doc/library/stdtypes.rst:277
msgid "product of *x* and *y*"
msgstr "produit de *x* et *y*"

#: ../Doc/library/stdtypes.rst:279
msgid "``x / y``"
msgstr "``x / y``"

#: ../Doc/library/stdtypes.rst:279
msgid "quotient of *x* and *y*"
msgstr "quotient de *x* et *y*"

#: ../Doc/library/stdtypes.rst:281
msgid "``x // y``"
msgstr "``x // y``"

#: ../Doc/library/stdtypes.rst:281
msgid "floored quotient of *x* and *y*"
msgstr "quotient entier de *x* et *y*"

#: ../Doc/library/stdtypes.rst:284
msgid "``x % y``"
msgstr "``x % y``"

#: ../Doc/library/stdtypes.rst:284
msgid "remainder of ``x / y``"
msgstr "reste de ``x / y``"

#: ../Doc/library/stdtypes.rst:286
msgid "``-x``"
msgstr "``-x``"

#: ../Doc/library/stdtypes.rst:286
msgid "*x* negated"
msgstr "négatif de *x*"

#: ../Doc/library/stdtypes.rst:288
msgid "``+x``"
msgstr "``+x``"

#: ../Doc/library/stdtypes.rst:288
msgid "*x* unchanged"
msgstr "*x* inchangé"

#: ../Doc/library/stdtypes.rst:290
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../Doc/library/stdtypes.rst:290
msgid "absolute value or magnitude of *x*"
msgstr "valeur absolue de *x*"

#: ../Doc/library/stdtypes.rst:290
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../Doc/library/stdtypes.rst:293
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../Doc/library/stdtypes.rst:293
msgid "*x* converted to integer"
msgstr "*x* converti en nombre entier"

#: ../Doc/library/stdtypes.rst:293
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../Doc/library/stdtypes.rst:293
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../Doc/library/stdtypes.rst:295
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../Doc/library/stdtypes.rst:295
msgid "*x* converted to floating point"
msgstr "*x* converti en nombre à virgule flottante"

#: ../Doc/library/stdtypes.rst:295
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../Doc/library/stdtypes.rst:295
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../Doc/library/stdtypes.rst:297
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../Doc/library/stdtypes.rst:297
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"un nombre complexe avec *re* pour partie réelle et *im* pour partie "
"imaginaire. *im* vaut zéro par défaut."

#: ../Doc/library/stdtypes.rst:297 ../Doc/library/stdtypes.rst:1073
#: ../Doc/library/stdtypes.rst:2162 ../Doc/library/stdtypes.rst:3293
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/library/stdtypes.rst:297
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../Doc/library/stdtypes.rst:301
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../Doc/library/stdtypes.rst:301
msgid "conjugate of the complex number *c*"
msgstr "conjugué du nombre complexe *c*"

#: ../Doc/library/stdtypes.rst:304
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../Doc/library/stdtypes.rst:304
msgid "the pair ``(x // y, x % y)``"
msgstr "la paire ``(x // y, x % y)``"

#: ../Doc/library/stdtypes.rst:304
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../Doc/library/stdtypes.rst:306
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../Doc/library/stdtypes.rst:306 ../Doc/library/stdtypes.rst:308
msgid "*x* to the power *y*"
msgstr "*x* à la puissance *y*"

#: ../Doc/library/stdtypes.rst:306 ../Doc/library/stdtypes.rst:308
#: ../Doc/library/stdtypes.rst:1062 ../Doc/library/stdtypes.rst:1065
#: ../Doc/library/stdtypes.rst:2187 ../Doc/library/stdtypes.rst:2190
#: ../Doc/library/stdtypes.rst:2193 ../Doc/library/stdtypes.rst:3289
#: ../Doc/library/stdtypes.rst:3296
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/library/stdtypes.rst:306
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../Doc/library/stdtypes.rst:308
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../Doc/library/stdtypes.rst:318
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"Également appelé division entière. La valeur résultante est un nombre "
"entier, bien que le type du résultat ne soit pas nécessairement *int*. Le "
"résultat est toujours arrondi vers moins l'infini : ``1//2`` vaut ``0``, "
"``(-1)//2`` vaut ``-1``, ``1//(-2)`` vaut ``-1``, et ``(-1)//(-2)`` vaut "
"``0``."

#: ../Doc/library/stdtypes.rst:324
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Pas pour les nombres complexes. Convertissez-les plutôt en nombres flottants "
"à l'aide de :func:`abs` si c'est approprié."

#: ../Doc/library/stdtypes.rst:336
msgid ""
"Conversion from floating point to integer may round or truncate as in C; see "
"functions :func:`math.floor` and :func:`math.ceil` for well-defined "
"conversions."
msgstr ""
"La conversion de virgule flottante en entier peut arrondir ou tronquer comme "
"en C ; voir les fonctions :func:`math.floor` et :func:`math.ceil` pour des "
"conversions bien définies."

#: ../Doc/library/stdtypes.rst:341
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float accepte aussi les chaînes \"nan\" et \"inf\" avec un préfixe optionnel "
"\"+\" ou \"-\" pour *Not a Number* (NaN) et les infinis positif ou négatif."

#: ../Doc/library/stdtypes.rst:345
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python définit ``pow(0, 0)`` et ``0 ** 0`` valant ``1``, ​puisque c'est "
"courant pour les langages de programmation, et logique."

#: ../Doc/library/stdtypes.rst:349
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"Les littéraux numériques acceptés comprennent les chiffres ``0`` à ``9`` ou "
"tout équivalent Unicode (caractères avec la propriété ``Nd``)."

#: ../Doc/library/stdtypes.rst:352
msgid ""
"See http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt "
"for a complete list of code points with the ``Nd`` property."
msgstr ""
"Voir http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType."
"txt pour une liste complète des caractères avec la propriété ``Nd``."

#: ../Doc/library/stdtypes.rst:356
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Tous types :class:`numbers.Real` (:class:`int` et :class:`float`) "
"comprennent également les opérations suivantes :"

#: ../Doc/library/stdtypes.rst:362
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../Doc/library/stdtypes.rst:362
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* tronqué à l':class:`~numbers.Integral`"

#: ../Doc/library/stdtypes.rst:365
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../Doc/library/stdtypes.rst:365
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* arrondi à *n* chiffres, arrondissant la moitié au pair. Si *n* est omis, "
"la valeur par défaut à 0."

#: ../Doc/library/stdtypes.rst:369
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../Doc/library/stdtypes.rst:369
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "le plus grand :class:`~numbers.Integral` <= *x*"

#: ../Doc/library/stdtypes.rst:372
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../Doc/library/stdtypes.rst:372
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "le plus petit :class:`~numbers.Integral` >= *x*"

#: ../Doc/library/stdtypes.rst:376
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Pour d'autres opérations numériques voir les modules :mod:`math` et :mod:"
"`cmath`."

#: ../Doc/library/stdtypes.rst:385
msgid "Bitwise Operations on Integer Types"
msgstr "Opérations sur les bits des nombres entiers"

#: ../Doc/library/stdtypes.rst:399
msgid ""
"Bitwise operations only make sense for integers.  Negative numbers are "
"treated as their 2's complement value (this assumes that there are enough "
"bits so that no overflow occurs during the operation)."
msgstr ""
"Les opérations sur les bits n'ont de sens que pour les entiers. Les nombres "
"négatifs sont traités comme leur complément à 2 (ce qui suppose un assez "
"grand nombre de bits afin qu'aucun débordement ne se produise pendant "
"l'opération)."

#: ../Doc/library/stdtypes.rst:403
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"Les priorités de toutes les opération à deux opérandes sur des bits sont "
"inférieures aux opérations numériques et plus élevées que les comparaisons ; "
"l'opération unaire ``~`` a la même priorité que les autres opérations "
"numériques unaires (``+`` et ``-``)."

#: ../Doc/library/stdtypes.rst:407
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"Ce tableau répertorie les opérations binaires triées par priorité "
"ascendante :"

#: ../Doc/library/stdtypes.rst:412
msgid "``x | y``"
msgstr "``x | y``"

#: ../Doc/library/stdtypes.rst:412
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr ":dfn:`ou <or>` binaire de *x* et *y*"

#: ../Doc/library/stdtypes.rst:415
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../Doc/library/stdtypes.rst:415
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr ":dfn:`ou <or>` exclusive binaire de *x* et *y*"

#: ../Doc/library/stdtypes.rst:418
msgid "``x & y``"
msgstr "``x & y``"

#: ../Doc/library/stdtypes.rst:418
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr ":dfn:`et binaire <and>` de *x* et *y*"

#: ../Doc/library/stdtypes.rst:421
msgid "``x << n``"
msgstr "``x << n``"

#: ../Doc/library/stdtypes.rst:421
msgid "*x* shifted left by *n* bits"
msgstr "*x* décalé vers la gauche de *n* bits"

#: ../Doc/library/stdtypes.rst:421
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../Doc/library/stdtypes.rst:423
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../Doc/library/stdtypes.rst:423
msgid "*x* shifted right by *n* bits"
msgstr "*x* décalé vers la droite de *n* bits"

#: ../Doc/library/stdtypes.rst:423
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../Doc/library/stdtypes.rst:425
msgid "``~x``"
msgstr "``~x``"

#: ../Doc/library/stdtypes.rst:425
msgid "the bits of *x* inverted"
msgstr "les bits de *x*, inversés"

#: ../Doc/library/stdtypes.rst:431
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""
"Des valeurs de décalage négatives sont illégales et provoquent une "
"exception :exc:`ValueError`."

#: ../Doc/library/stdtypes.rst:434
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)`` "
"without overflow check."
msgstr ""
"Un décalage à gauche de *n* bits est équivalent à la multiplication par "
"``pow(2, n)`` sans vérification de débordement."

#: ../Doc/library/stdtypes.rst:438
msgid ""
"A right shift by *n* bits is equivalent to division by ``pow(2, n)`` without "
"overflow check."
msgstr ""
"Un décalage à droite de *n* les bits est équivalent à la division par "
"``pow(2, n)`` sans vérification de débordement."

#: ../Doc/library/stdtypes.rst:443
msgid "Additional Methods on Integer Types"
msgstr "Méthodes supplémentaires sur les entiers"

#: ../Doc/library/stdtypes.rst:445
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Le type int implémente la :term:`classe de base abstraite <abstract base "
"class>` :class:`numbers.Integral`. Il fournit aussi quelques autres "
"méthodes :"

#: ../Doc/library/stdtypes.rst:450
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Renvoie le nombre de bits nécessaires pour représenter un nombre entier en "
"binaire, à l'exclusion du signe et des zéros non significatifs : ::"

#: ../Doc/library/stdtypes.rst:459
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Plus précisément, si ``x`` est différent de zéro, ``x.bit_length()`` est le "
"nombre entier positif unique, ``k`` tel que ``2**(k-1) <= abs(x) < 2**k``. "
"Équivalemment, quand ``abs(x)`` est assez petit pour avoir un logarithme "
"correctement arrondi, ``k = 1 + int(log(abs(x), 2))``. Si ``x`` est nul, "
"alors ``x.bit_length()`` donne ``0``."

#: ../Doc/library/stdtypes.rst:465
msgid "Equivalent to::"
msgstr "Équivalent à : ::"

#: ../Doc/library/stdtypes.rst:476
msgid "Return an array of bytes representing an integer."
msgstr "Renvoie un tableau d'octets représentant un nombre entier."

#: ../Doc/library/stdtypes.rst:488
msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError` is "
"raised if the integer is not representable with the given number of bytes."
msgstr ""
"L'entier est représenté par *length* octets. Une exception :exc:"
"`OverflowError` est levée s'il n'est pas possible de représenter l'entier "
"avec le nombre d'octets donnés."

#: ../Doc/library/stdtypes.rst:492 ../Doc/library/stdtypes.rst:524
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at the "
"beginning of the byte array.  If *byteorder* is ``\"little\"``, the most "
"significant byte is at the end of the byte array.  To request the native "
"byte order of the host system, use :data:`sys.byteorder` as the byte order "
"value."
msgstr ""
"L'argument *byteorder* détermine l'ordre des octets utilisé pour représenter "
"le nombre entier. Si *byteorder* est ``\"big\"``, l'octet le plus "
"significatif est au début du tableau d'octets. Si *byteorder* est ``\"little"
"\"``, l'octet le plus significatif est à la fin du tableau d'octets. Pour "
"demander l'ordre natif des octets du système hôte, donnez :data:`sys."
"byteorder` comme *byteorder*."

#: ../Doc/library/stdtypes.rst:499
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"L'argument *signed* détermine si le complément à deux est utilisé pour "
"représenter le nombre entier. Si *signed* est ``False`` et qu'un entier "
"négatif est donné, une exception :exc:`OverflowError` est levée. La valeur "
"par défaut pour *signed* est ``False``."

#: ../Doc/library/stdtypes.rst:508
msgid "Return the integer represented by the given array of bytes."
msgstr "Done le nombre entier représenté par le tableau d'octets fourni."

#: ../Doc/library/stdtypes.rst:521
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"L'argument *bytes* doit être soit un :term:`bytes-like object` soit un "
"itérable produisant des *bytes*."

#: ../Doc/library/stdtypes.rst:531
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"L'argument *signed* indique si le complément à deux est utilisé pour "
"représenter le nombre entier."

#: ../Doc/library/stdtypes.rst:538
msgid "Additional Methods on Float"
msgstr "Méthodes supplémentaires sur les nombres à virgule flottante"

#: ../Doc/library/stdtypes.rst:540
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"Le type *float* implémente la :term:`classe de base abstraite <abstract base "
"class>` :class:`numbers.Real` et a également les méthodes suivantes."

#: ../Doc/library/stdtypes.rst:545
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""
"Renvoie une paire de nombres entiers dont le rapport est exactement égal au "
"nombre d'origine et avec un dénominateur positif. Lève :exc:`OverflowError` "
"avec un infini et :exc:`ValueError` avec un NaN."

#: ../Doc/library/stdtypes.rst:552
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Donne ``True`` si l'instance de *float* est finie avec une valeur entière, "
"et ``False`` autrement : ::"

#: ../Doc/library/stdtypes.rst:560
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Deux méthodes prennent en charge la conversion vers et à partir de chaînes "
"hexadécimales. Étant donné que les *float* de Python sont stockés en interne "
"sous forme de nombres binaires, la conversion d'un *float* depuis ou vers "
"une chaine décimale implique généralement une petite erreur d'arrondi. En "
"revanche, les chaînes hexadécimales permettent de représenter exactement les "
"nombres à virgule flottante. Cela peut être utile lors du débogage, et dans "
"un travail numérique."

#: ../Doc/library/stdtypes.rst:571
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Donne une représentation d'un nombre à virgule flottante sous forme de "
"chaîne hexadécimale. Pour les nombres à virgule flottante finis, cette "
"représentation comprendra toujours un préfixe ``0x``, un suffixe ``p``, et "
"un exposant."

#: ../Doc/library/stdtypes.rst:579
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Méthode de classe pour obtenir le *float* représenté par une chaîne de "
"caractères hexadécimale *s*. La chaîne *s* peut contenir des espaces avant "
"et après le chiffre."

#: ../Doc/library/stdtypes.rst:584
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Notez que :meth:`float.hex` est une méthode d'instance, alors que :meth:"
"`float.fromhex` est une méthode de classe."

#: ../Doc/library/stdtypes.rst:587
msgid "A hexadecimal string takes the form::"
msgstr "Une chaîne hexadécimale prend la forme : ::"

#: ../Doc/library/stdtypes.rst:591
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"où ``sign`` peut être soit ``+`` soit ``-``, ``integer`` et ``fraction`` "
"sont des chaînes de chiffres hexadécimales, et ``exponent`` est un entier "
"décimal facultativement signé. La casse n'est pas significative, et il doit "
"y avoir au moins un chiffre hexadécimal soit dans le nombre entier soit dans "
"la fraction. Cette syntaxe est similaire à la syntaxe spécifiée dans la "
"section 6.4.4.2 de la norme C99, et est aussi la syntaxe utilisée à partir "
"de Java 1.5. En particulier, la sortie de :meth:`float.hex` est utilisable "
"comme valeur hexadécimale à virgule flottante littérale en C ou Java, et des "
"chaînes hexadécimales produites en C via un format ``%a`` ou Java via "
"``Double.toHexString`` sont acceptées par :meth:`float.fromhex`."

#: ../Doc/library/stdtypes.rst:604
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Notez que l'exposant est écrit en décimal plutôt qu'en hexadécimal, et qu'il "
"donne la puissance de 2 par lequel multiplier le coefficient. Par exemple, "
"la chaîne hexadécimale ``0x3.a7p10`` représente le nombre à virgule "
"flottante ``(3 + 10./16 + 7./16**2) *2.0**10``, ou ``3740.0`` ::"

#: ../Doc/library/stdtypes.rst:614
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"L'application de la conversion inverse à ``3740.0`` donne une chaîne "
"hexadécimale différente représentant le même nombre ::"

#: ../Doc/library/stdtypes.rst:624
msgid "Hashing of numeric types"
msgstr "Hachage des types numériques"

#: ../Doc/library/stdtypes.rst:626
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`__hash__` "
"method documentation for more details).  For ease of implementation and "
"efficiency across a variety of numeric types (including :class:`int`, :class:"
"`float`, :class:`decimal.Decimal` and :class:`fractions.Fraction`) Python's "
"hash for numeric types is based on a single mathematical function that's "
"defined for any rational number, and hence applies to all instances of :"
"class:`int` and :class:`fractions.Fraction`, and all finite instances of :"
"class:`float` and :class:`decimal.Decimal`.  Essentially, this function is "
"given by reduction modulo ``P`` for a fixed prime ``P``.  The value of ``P`` "
"is made available to Python as the :attr:`modulus` attribute of :data:`sys."
"hash_info`."
msgstr ""
"Pour deux nombres égaux ``x`` et ``y`` (``x == y``), pouvant être de "
"différents types, il est une requis que ``hash(x) == hash(y)`` (voir la "
"documentation de :meth:`__hash__`). Pour faciliter la mise en œuvre et "
"l'efficacité à travers une variété de types numériques (y compris :class:"
"`int`, :class:`float`, :class:`decimal.Decimal` et :class:`fractions."
"Fraction`) le hachage en Python pour les types numérique est basé sur une "
"fonction mathématique unique qui est définie pour tout nombre rationnel, et "
"donc s'applique à toutes les instances de :class:`int` et :class:`fractions."
"Fraction`, et toutes les instances finies de :class:`float` et :class:"
"`decimal.Decimal`. Essentiellement, cette fonction est donnée par la "
"réduction modulo ``P`` pour un nombre ``P`` premier fixe. La valeur de ``P`` "
"est disponible comme attribut :attr:`modulus` de :data:`sys.hash_info`."

#: ../Doc/library/stdtypes.rst:641
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"Actuellement, le premier utilisé est ``P = 2 ** 31 - 1`` sur des machines "
"dont les *longs* en C sont de 32 bits ``P = 2 ** 61 - 1`` sur des machines "
"dont les *longs* en C font 64 bits."

#: ../Doc/library/stdtypes.rst:644
msgid "Here are the rules in detail:"
msgstr "Voici les règles en détail :"

#: ../Doc/library/stdtypes.rst:646
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Si ``x = m / n`` est un nombre rationnel non négatif et ``n`` n'est pas "
"divisible par ``P``, définir ``hash(x)`` comme ``m * invmod(n, P) % P``, où "
"``invmod(n, P)`` donne l'inverse de ``n`` modulo ``P``."

#: ../Doc/library/stdtypes.rst:650
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Si ``x = m / n`` est un nombre rationnel non négatif et ``n`` est divisible "
"par ``P`` (mais ``m`` ne l'est pas), alors ``n`` n'a pas de modulo inverse "
"``P`` et la règle ci-dessus n'est pas applicable ; dans ce cas définir "
"``hash(x)`` comme étant la valeur de la constante ``sys.hash_info.inf``."

#: ../Doc/library/stdtypes.rst:655
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Si ``x = m / n`` est un nombre rationnel négatif définir ``hash(x)`` comme "
"``-hash(-x)``. Si le résultat est ``-1``, le remplacer par ``-2``."

#: ../Doc/library/stdtypes.rst:659
msgid ""
"The particular values ``sys.hash_info.inf``, ``-sys.hash_info.inf`` and "
"``sys.hash_info.nan`` are used as hash values for positive infinity, "
"negative infinity, or nans (respectively).  (All hashable nans have the same "
"hash value.)"
msgstr ""
"Les valeurs particulières ``sys.hash_info.inf``, ``-sys.hash_info.inf`` et "
"``sys.hash_info.nan`` sont utilisées comme valeurs de hachage pour l'infini "
"positif, l'infini négatif, ou *nans* (respectivement). (Tous les *nans* "
"hachables ont la même valeur de hachage.)"

#: ../Doc/library/stdtypes.rst:664
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Pour un nombre :class:`complexe <complex>` ``z``, les valeurs de hachage des "
"parties réelles et imaginaires sont combinées en calculant ``hash(z.real) + "
"sys.hash_info.imag * hash(z.imag)``, réduit au modulo ``2**sys.hash_info."
"width`` de sorte qu'il se trouve dans ``range(-2**(sys.hash_info.width - 1), "
"2**(sys.hash_info.width - 1))``. Encore une fois, si le résultat est ``-1``, "
"il est remplacé par ``-2``."

#: ../Doc/library/stdtypes.rst:672
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Afin de clarifier les règles ci-dessus, voici quelques exemples de code "
"Python, équivalent à la fonction de hachage native, pour calculer le hachage "
"d'un nombre rationnel,  d'un :class:`float`, ou d'un :class:`complex` ::"

#: ../Doc/library/stdtypes.rst:727
msgid "Iterator Types"
msgstr "Les types Itérateurs"

#: ../Doc/library/stdtypes.rst:735
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python supporte un concept d'itération sur les conteneurs. C'est implémenté "
"en utilisant deux méthodes distinctes qui permettent aux classes définies "
"par l'utilisateur de devenir itérables. Les séquences, décrites plus bas en "
"détail, supportent toujours les méthodes d'itération."

#: ../Doc/library/stdtypes.rst:740
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr ""
"Une méthode doit être définie afin que les objets conteneurs  supportent "
"l'itération :"

#: ../Doc/library/stdtypes.rst:747
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Donne un objet itérateur. L'objet doit implémenter le protocole d'itération "
"décrit ci-dessous. Si un conteneur prend en charge différents types "
"d'itération, d'autres méthodes peuvent être fournies pour obtenir "
"spécifiquement les itérateurs pour ces types d'itération. (Exemple d'un "
"objet supportant plusieurs formes d'itération : une structure d'arbre "
"pouvant être parcourue en largeur ou en profondeur.) Cette méthode "
"correspond à l'attribut :c:member:`~PyTypeObject.tp_iter` de la structure du "
"type des objets Python dans l'API Python/C."

#: ../Doc/library/stdtypes.rst:756
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Les itérateurs eux-mêmes doivent implémenter les deux méthodes suivantes, "
"qui forment ensemble le :dfn:`protocole d'itérateur <iterator protocol>` :"

#: ../Doc/library/stdtypes.rst:762
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements. This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Donne l'objet itérateur lui-même. Cela est nécessaire pour permettre à la "
"fois à des conteneurs et des itérateurs d'être utilisés avec les "
"instructions :keyword:`for` et :keyword:`in`. Cette méthode correspond à "
"l'attribut :c:member:`~PyTypeObject.tp_iter` de la structure des types des "
"objets Python dans l'API Python/C."

#: ../Doc/library/stdtypes.rst:770
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iternext` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"Donne l'élément suivant du conteneur. S'il n'y a pas d'autres éléments, une "
"exception :exc:`StopIteration` est levée. Cette méthode correspond à "
"l'attribut :c:member:`PyTypeObject.tp_iternext` de la structure du type des "
"objets Python dans l'API Python/C."

#: ../Doc/library/stdtypes.rst:775
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python définit plusieurs objets itérateurs pour itérer sur les types "
"standards ou spécifiques de séquence, de  dictionnaires et d'autres formes "
"plus spécialisées. Les types spécifiques ne sont  pas importants au-delà de "
"leur implémentation du protocole d'itération."

#: ../Doc/library/stdtypes.rst:780
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Dès que la méthode :meth:`~iterator .__next__` lève une  exception :exc:"
"`StopIteration`, elle doit continuer à le faire lors des appels ultérieurs."
"Implémentations qui ne respectent pas cette propriété sont considérées "
"cassées."

#: ../Doc/library/stdtypes.rst:788
msgid "Generator Types"
msgstr "Types Générateurs"

#: ../Doc/library/stdtypes.rst:790
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
"Les :term:`generator`\\s offrent un moyen pratique d'implémenter le "
"protocole d'itération. Si la méthode :meth:`__iter__` d'un objet conteneur "
"est implémentée comme un générateur, elle renverra automatiquement un objet "
"*iterator* (techniquement, un objet générateur) fournissant les méthodes :"
"meth:`__iter__`  et :meth:`~generator.__next__`. Plus d'informations sur les "
"générateurs peuvent être trouvés dans :ref:`la documentation de l'expression "
"yield <yieldexpr>`."

#: ../Doc/library/stdtypes.rst:802
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Types séquentiels --- :class:`list`, :class:`tuple`, :class:`range`"

#: ../Doc/library/stdtypes.rst:804
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Il existe trois types séquentiels basiques: les *lists*,  *tuples* et les "
"*range*. D'autres types séquentiels  spécifiques au traitement de :ref:"
"`données binaires <binaryseq>` et :ref:`chaînes de caractères <textseq>` "
"sont décrits dans des sections dédiées."

#: ../Doc/library/stdtypes.rst:813
msgid "Common Sequence Operations"
msgstr "Opérations communes sur les séquences"

#: ../Doc/library/stdtypes.rst:817
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Les opérations dans le tableau ci-dessous sont pris en charge par la plupart "
"des types séquentiels, variables et immuables. La classe de base abstraite :"
"class:`collections.abc.Sequence` est fournie pour aider à implémenter "
"correctement ces opérations sur les types séquentiels personnalisés."

#: ../Doc/library/stdtypes.rst:822
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"Ce tableau répertorie les opérations sur les séquences  triées par priorité "
"ascendante. Dans le tableau, *s,* et *t* sont des séquences du même type, "
"*n*, *i*, *j* et *k* sont des nombres entiers et *x* est un objet arbitraire "
"qui répond à toutes les restrictions de type et de valeur imposée par *s*."

#: ../Doc/library/stdtypes.rst:827
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"Les opérations ``in`` et ``not in`` ont les mêmes priorités que les "
"opérations de comparaison. Les opérations ``+`` (concaténation) et ``*`` "
"(répétition) ont la même priorité que les opérations numériques "
"correspondantes. [3]_"

#: ../Doc/library/stdtypes.rst:848
msgid "``x in s``"
msgstr "``x in s``"

#: ../Doc/library/stdtypes.rst:848
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True`` si un élément de *s* est égal à *x*, sinon ``False``"

#: ../Doc/library/stdtypes.rst:851
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../Doc/library/stdtypes.rst:851
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False`` si un élément de *s* est égal à *x*, sinon ``True``"

#: ../Doc/library/stdtypes.rst:854
msgid "``s + t``"
msgstr "``s + t``"

#: ../Doc/library/stdtypes.rst:854
msgid "the concatenation of *s* and *t*"
msgstr "la concaténation de *s* et *t*"

#: ../Doc/library/stdtypes.rst:854
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../Doc/library/stdtypes.rst:857
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` or ``n * s``"

#: ../Doc/library/stdtypes.rst:857
msgid "equivalent to adding *s* to itself *n* times"
msgstr "équivalent à ajouter *s* *n* fois à lui même"

#: ../Doc/library/stdtypes.rst:857
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../Doc/library/stdtypes.rst:860
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../Doc/library/stdtypes.rst:860
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*i*\\ ème élément de *s* en commençant par 0"

#: ../Doc/library/stdtypes.rst:862
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../Doc/library/stdtypes.rst:862
msgid "slice of *s* from *i* to *j*"
msgstr "tranche (*slice*) de *s* de *i* à *j*"

#: ../Doc/library/stdtypes.rst:862
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../Doc/library/stdtypes.rst:864
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../Doc/library/stdtypes.rst:864
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "tranche (*slice*) de *s* de *i* à *j* avec un pas de *k*"

#: ../Doc/library/stdtypes.rst:864
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../Doc/library/stdtypes.rst:867
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../Doc/library/stdtypes.rst:867
msgid "length of *s*"
msgstr "longueur de *s*"

#: ../Doc/library/stdtypes.rst:869
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../Doc/library/stdtypes.rst:869
msgid "smallest item of *s*"
msgstr "plus petit élément de *s*"

#: ../Doc/library/stdtypes.rst:871
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../Doc/library/stdtypes.rst:871
msgid "largest item of *s*"
msgstr "plus grand élément de *s*"

#: ../Doc/library/stdtypes.rst:873
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../Doc/library/stdtypes.rst:873
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"indice de la première occurrence de *x* dans *s* (à ou après l'indice *i* et "
"avant indice *j*)"

#: ../Doc/library/stdtypes.rst:873 ../Doc/library/stdtypes.rst:3264
msgid "\\(8)"
msgstr "\\(8)"

#: ../Doc/library/stdtypes.rst:877
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../Doc/library/stdtypes.rst:877
msgid "total number of occurrences of *x* in *s*"
msgstr "nombre total d'occurrences de *x* dans *s*"

#: ../Doc/library/stdtypes.rst:881
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Les séquences du même type supportent également la comparaison. En "
"particulier, les *tuples* et les listes sont comparées lexicographiquement "
"en comparant les éléments correspondants. Cela signifie que pour être "
"égales, chaques éléments doivent être égaux deux à deux et les deux "
"séquences doivent être du même type et de la même longueur. (Pour plus de "
"détails voir :ref:`comparisons` dans la référence du langage.)"

#: ../Doc/library/stdtypes.rst:890
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"Bien que les opérations ``in`` et ``not in`` ne soient généralement "
"utilisées que pour les tests d'appartenance simple, certaines séquences "
"spécialisées (telles que :class:`str`, :class:`bytes` et :class:`bytearray`) "
"les utilisent aussi pour tester l'existence de sous-séquences : ::"

#: ../Doc/library/stdtypes.rst:899
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"Les valeurs de *n* plus petites que ``0`` sont traités comme ``0`` (ce qui "
"donne une séquence vide du même type que *s*). Notez que les éléments de *s* "
"ne sont pas copiés ; ils sont référencés plusieurs fois. Cela hante souvent "
"de nouveaux développeurs Python, typiquement : ::"

#: ../Doc/library/stdtypes.rst:911
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Ce qui est arrivé est que ``[[]]`` est une liste à un élément contenant une "
"liste vide, de sorte que les trois éléments de ``[[]] * 3`` sont des "
"références à cette seule liste vide. Modifier l'un des éléments de ``lists`` "
"modifie cette liste unique. Vous pouvez créer une liste des différentes "
"listes de cette façon : ::"

#: ../Doc/library/stdtypes.rst:923
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"De plus amples explications sont disponibles dans la FAQ à la question :ref:"
"`faq-multidimensional-list`."

#: ../Doc/library/stdtypes.rst:927
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Si *i* ou *j* sont négatifs, l'indice est relatif à la fin de la séquence "
"*s* : ``len(s) + i`` ou ``len(s) + j`` est substitué. Mais notez que ``-0`` "
"est toujours ``0``."

#: ../Doc/library/stdtypes.rst:932
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"La tranche de *s* de *i* à *j* est définie comme la séquence d'éléments "
"d'indice *k* tels que ``i <= k < j``. Si *i* ou *j* est supérieur à "
"``len(s)``, ``len(s)`` est utilisé. Si *i* est omis ou ``None``, ``0`` est "
"utilisé. Si *j* est omis ou ``None``, ``len(s)`` est utilisé. Si *i* est "
"supérieure ou égale à *j*, la tranche est vide."

#: ../Doc/library/stdtypes.rst:939
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"La tranche de *s* de *i* à *j* avec un pas de *k* est définie comme la "
"séquence d'éléments d'indice ``x = i + n*k`` tels que ``0 <= n < (j-i)/k``. "
"En d'autres termes, les indices sont ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` et "
"ainsi de suite, en arrêtant lorsque *j* est atteint (mais jamais inclus). Si "
"*k* est positif, *i* et *j* sont réduits, s'ils sont plus grands, à "
"``len(s)``. Si *k* est négatif, *i* et *j* sont réduits à ``len(s) - 1`` "
"s'ils sont plus grands. Si *i* ou *j* sont omis ou sont ``None``, ils "
"deviennent des valeurs \"extrêmes\" (où l'ordre dépend du signe de *k*). "
"Remarquez, *k* ne peut pas valoir zéro. Si *k* est ``None``, il est traité "
"comme ``1``."

#: ../Doc/library/stdtypes.rst:950
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"Concaténer des séquences immuables donne toujours un nouvel objet. Cela "
"signifie que la construction d'une séquence par concaténations répétées aura "
"une durée d'exécution quadratique par rapport à la longueur de la séquence "
"totale. Pour obtenir un temps d'exécution linéaire, vous devez utiliser "
"l'une des alternatives suivantes :"

#: ../Doc/library/stdtypes.rst:955
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"si vous concatennez des :class:`str`, vous pouvez construire une liste puis "
"utiliser :meth:`str.join` à la fin, ou bien écrire dans une instance de :"
"class:`io.StringIO` et récupérer sa valeur lorsque vous avez terminé"

#: ../Doc/library/stdtypes.rst:959
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"si vous concatennez des :class:`bytes`, vous pouvez aussi utiliser :meth:"
"`bytes.join` ou :class:`io.BytesIO`, ou vous pouvez faire les concaténation "
"sur place avec un objet :class:`bytearray`. Les objets :class:`bytearray` "
"sont mutables et ont un mécanisme de sur-allocation efficace"

#: ../Doc/library/stdtypes.rst:964
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"si vous concatennez des :class:`tuple`, utilisez plutôt *extend* sur une :"
"class:`list`"

#: ../Doc/library/stdtypes.rst:966
msgid "for other types, investigate the relevant class documentation"
msgstr ""
"pour d'autres types, cherchez dans la documentation de la classe concernée"

#: ../Doc/library/stdtypes.rst:970
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Certains types séquenciels (tels que :class:`range`) ne supportent que des "
"séquences qui suivent des modèles spécifiques, et donc ne prennent pas en "
"charge la concaténation ou la répétition."

#: ../Doc/library/stdtypes.rst:975
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. When "
"supported, the additional arguments to the index method allow efficient "
"searching of subsections of the sequence. Passing the extra arguments is "
"roughly equivalent to using ``s[i:j].index(x)``, only without copying any "
"data and with the returned index being relative to the start of the sequence "
"rather than the start of the slice."
msgstr ""
"``index`` lève une exception :exc:`ValueError` quand *x* ne se trouve pas "
"dans *s*. Lorsqu'ils sont supportés, les arguments supplémentaires de la "
"méthode ``index`` permettent une recherche efficace des sous-sequences dans "
"la séquence. Donner ces arguments est plus ou moins équivalent à ``s[i:j]."
"index(x)``, sans copier les données; l'indice renvoyé alors relatif au début "
"de la séquence plutôt qu'au début de la tranche."

#: ../Doc/library/stdtypes.rst:986
msgid "Immutable Sequence Types"
msgstr "Types de Séquences Immuables"

#: ../Doc/library/stdtypes.rst:993
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"La seule opération que les types de séquences immutables implémentent qui "
"n'est pas implémentée par les types de séquences mutables est le support de "
"la fonction native :func:`hash`."

#: ../Doc/library/stdtypes.rst:997
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Cette implémentation permet d'utiliser des séquences immutables, comme les "
"instances de :class:`tuple`, en tant que clés de :class:`dict` et stockées "
"dans les instances de :class:`set` et :class:`frozenset`."

#: ../Doc/library/stdtypes.rst:1001
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Essayer de hacher une séquence immuable qui contient des valeurs non-"
"hachables lèvera une :exc:`TypeError`."

#: ../Doc/library/stdtypes.rst:1008
msgid "Mutable Sequence Types"
msgstr "Types de séquences mutables"

#: ../Doc/library/stdtypes.rst:1015
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Les opérations dans le tableau ci-dessous sont définies sur les types de "
"séquences mutables. La classe de base abstraite :class:`collections.abc."
"MutableSequence` est prévue pour faciliter l'implémentation correcte de ces "
"opérations sur les types de séquence personnalisées."

#: ../Doc/library/stdtypes.rst:1019
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"Dans le tableau *s* est une instance d'un type de séquence mutable, *t* est "
"un objet itérable et *x* est un objet arbitraire qui répond à toutes les "
"restrictions de type et de valeur imposées par *s* (par exemple, :class:"
"`bytearray` accepte uniquement des nombres entiers qui répondent à la "
"restriction de la valeur ``0 <= x <= 255``)."

#: ../Doc/library/stdtypes.rst:1043
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../Doc/library/stdtypes.rst:1043
msgid "item *i* of *s* is replaced by *x*"
msgstr "element *i* de *s* est remplacé par *x*"

#: ../Doc/library/stdtypes.rst:1046
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../Doc/library/stdtypes.rst:1046
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"tranche de *s* de *i* à *j* est remplacée par le contenu de l'itérable *t*"

#: ../Doc/library/stdtypes.rst:1050
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../Doc/library/stdtypes.rst:1050
msgid "same as ``s[i:j] = []``"
msgstr "identique à ``s[i:j] = []``"

#: ../Doc/library/stdtypes.rst:1052
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../Doc/library/stdtypes.rst:1052
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "les éléments de ``s[i:j:k]`` sont remplacés par ceux de *t*"

#: ../Doc/library/stdtypes.rst:1055
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../Doc/library/stdtypes.rst:1055
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "supprime les éléments de ``s[i:j:k]`` de la liste"

#: ../Doc/library/stdtypes.rst:1058
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../Doc/library/stdtypes.rst:1058
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""
"ajoute *x* à la fin de la séquence (identique à ``s[len(s):len(s)] = [x]``)"

#: ../Doc/library/stdtypes.rst:1062
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../Doc/library/stdtypes.rst:1062
msgid "removes all items from ``s`` (same as ``del s[:]``)"
msgstr "supprime tous les éléments de ``s`` (identique à ``del s[:]``)"

#: ../Doc/library/stdtypes.rst:1065
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../Doc/library/stdtypes.rst:1065
msgid "creates a shallow copy of ``s`` (same as ``s[:]``)"
msgstr "crée une copie superficielle de ``s`` (identique à ``s[:]``)"

#: ../Doc/library/stdtypes.rst:1068
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` or ``s += t``"

#: ../Doc/library/stdtypes.rst:1068
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr "étend *s* avec le contenu de *t* (proche de  ``s[len(s):len(s)] = t``)"

#: ../Doc/library/stdtypes.rst:1073
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../Doc/library/stdtypes.rst:1073
msgid "updates *s* with its contents repeated *n* times"
msgstr "met à jour *s* avec son contenu répété *n* fois"

#: ../Doc/library/stdtypes.rst:1076
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../Doc/library/stdtypes.rst:1076
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"insère *x* dans *s* à l'index donné par *i* (identique à ``s[i:i] = [x]``)"

#: ../Doc/library/stdtypes.rst:1080
msgid "``s.pop([i])``"
msgstr "``s.pop([i])``"

#: ../Doc/library/stdtypes.rst:1080
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "récupère l'élément à *i* et le supprime de *s*"

#: ../Doc/library/stdtypes.rst:1083
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../Doc/library/stdtypes.rst:1083
msgid "remove the first item from *s* where ``s[i] == x``"
msgstr "supprime le premier élément de *s* pour qui ``s[i] == x``"

#: ../Doc/library/stdtypes.rst:1086
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../Doc/library/stdtypes.rst:1086
msgid "reverses the items of *s* in place"
msgstr "inverse sur place les éléments de *s*"

#: ../Doc/library/stdtypes.rst:1086 ../Doc/library/stdtypes.rst:2176
#: ../Doc/library/stdtypes.rst:2180 ../Doc/library/stdtypes.rst:3278
#: ../Doc/library/stdtypes.rst:3282
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/library/stdtypes.rst:1094
msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t* doit avoir la même longueur que la tranche qu'il remplace."

#: ../Doc/library/stdtypes.rst:1097
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"L'argument optionnel *i* vaut ``-1`` par défaut, afin que, par défaut, le "
"dernier élément soit retiré et renvoyé."

#: ../Doc/library/stdtypes.rst:1101
msgid "``remove`` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""
"``remove`` lève une exception :exc:`ValueError` si *x* ne se trouve pas dans "
"*s*."

#: ../Doc/library/stdtypes.rst:1104
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"La méthode :meth:`reverse` modifie les séquence sur place pour économiser de "
"l'espace lors du traitement de grandes séquences. Pour rappeler aux "
"utilisateurs qu'elle a un effet de bord, elle ne renvoie pas la séquence "
"inversée."

#: ../Doc/library/stdtypes.rst:1109
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`)"
msgstr ""
":meth:`clear` et :meth:`!copy` sont inclues pour la compatibilité avec les "
"interfaces des conteneurs mutables qui ne supportent pas les opérations de "
"découpage (comme :class:`dict` et :class:`set`)"

#: ../Doc/library/stdtypes.rst:1113
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr "méthodes :meth:`clear` et :meth:`!copy`."

#: ../Doc/library/stdtypes.rst:1117
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"La valeur *n* est un entier, ou un objet implémentant :meth:`~object."
"__index__`. Zéro et les valeurs négatives de *n* permettent d'effacer la "
"séquence. Les éléments dans la séquence ne sont pas copiés ; ils sont "
"référencés plusieurs fois, comme expliqué pour ``s * n`` dans :ref:`typesseq-"
"common`."

#: ../Doc/library/stdtypes.rst:1126
msgid "Lists"
msgstr "Les listes"

#: ../Doc/library/stdtypes.rst:1130
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Les listes sont des séquences mutables, généralement utilisées pour stocker "
"des collections d'éléments homogènes (où le degré de similitude variera "
"selon l'usage)."

#: ../Doc/library/stdtypes.rst:1136
msgid "Lists may be constructed in several ways:"
msgstr "Les listes peuvent être construites de différentes manières :"

#: ../Doc/library/stdtypes.rst:1138
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"En utilisant une paire de crochets pour indiquer une liste vide : ``[]``"

#: ../Doc/library/stdtypes.rst:1139
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Au moyen de crochets, séparant les éléments par des virgules : ``[a]``, "
"``[a, b, c]``"

#: ../Doc/library/stdtypes.rst:1140
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "En utilisant une liste en compréhension : ``[x for x in iterable]``"

#: ../Doc/library/stdtypes.rst:1141
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr ""
"En utilisant le constructeur du type : ``list()`` ou ``list(iterable)``"

#: ../Doc/library/stdtypes.rst:1143
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"Le constructeur crée une liste dont les éléments sont les mêmes et dans le "
"même ordre que les éléments d'*iterable*. *iterable* peut être soit une "
"séquence, un conteneur qui supporte l'itération, soit un itérateur. Si "
"*iterable* est déjà une liste, une copie est faite et renvoyée, comme avec "
"``iterable[:]``. Par exemple, ``list('abc')`` renvoie ``['a', 'b', 'c']`` et "
"``list( (1, 2, 3) )`` renvoie ``[1, 2, 3]``. Si aucun argument est donné, le "
"constructeur crée une nouvelle liste vide, ``[]``."

#: ../Doc/library/stdtypes.rst:1152
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"De nombreuses autres opérations produisent des listes, tel que la fonction "
"native :func:`sorted`."

#: ../Doc/library/stdtypes.rst:1155
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Les listes supportent toutes les opérations des séquences :ref:`communes "
"<typesseq-common>` et :ref:`mutables <typesseq-mutable>`. Les listes "
"fournissent également la méthode supplémentaire suivante :"

#: ../Doc/library/stdtypes.rst:1161
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Cette méthode trie la liste sur place, en utilisant uniquement des "
"comparaisons ``<`` entre les éléments. Les exceptions ne sont pas supprimées "
"- si n'importe quelle opération de comparaison échoue, le tri échouera (et "
"la liste sera probablement laissée dans un état partiellement modifié)."

#: ../Doc/library/stdtypes.rst:1166
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` accepte deux arguments qui ne peuvent être fournis que par mot-"
"clé (:ref:`keyword-only arguments <keyword-only_parameter>`):"

#: ../Doc/library/stdtypes.rst:1169
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* spécifie une fonction d'un argument utilisée pour extraire une clé de "
"comparaison de chaque élément de la liste (par exemple, ``key=str.lower``). "
"La clé correspondant à chaque élément de la liste n'est calculée qu'une "
"seule fois, puis utilisée durant tout le processus. La valeur par défaut, "
"``None``, signifie que les éléments sont triés directement sans en calculer "
"une valeur \"clé\" séparée."

#: ../Doc/library/stdtypes.rst:1176
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"La fonction utilitaire :func:`functools.cmp_to_key` est disponible pour "
"convertir une fonction *cmp* du style 2.x à une fonction *key*."

#: ../Doc/library/stdtypes.rst:1179
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse*, une valeur booléenne. Si elle est ``True``, la liste d'éléments "
"est triée comme si toutes les comparaisons étaient inversées."

#: ../Doc/library/stdtypes.rst:1182
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Cette méthode modifie la séquence sur place pour économiser de l'espace lors "
"du tri de grandes séquences. Pour rappeler aux utilisateurs cet effet de "
"bord, elle ne renvoie pas la séquence triée (utilisez :func:`sorted` pour "
"demander explicitement une nouvelle instance de liste triée)."

#: ../Doc/library/stdtypes.rst:1187
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"La méthode :meth:`sort` est garantie stable. Un tri est stable s'il garantit "
"de ne pas changer l'ordre relatif des éléments égaux --- cela est utile pour "
"trier en plusieurs passes (par exemple, trier par département, puis par "
"niveau de salaire)."

#: ../Doc/library/stdtypes.rst:1194
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"L'effet de tenter de modifier, ou même inspecter la liste pendant qu'elle se "
"fait trier est indéfini. L'implémentation C de Python fait apparaître la "
"liste comme vide pour la durée du traitement, et soulève :exc:`ValueError` "
"si elle détecte que la liste a été modifiée au cours du tri."

#: ../Doc/library/stdtypes.rst:1203
msgid "Tuples"
msgstr "Tuples"

#: ../Doc/library/stdtypes.rst:1207
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Les tuples (*uplets* en français) sont des séquences immuables, généralement "
"utilisées pour stocker des collections de données hétérogènes (tels que les "
"tuples de deux éléments produits par la fonction native :func:`enumerate`). "
"Les tuples sont également utilisés dans des cas où une séquence homogène et "
"immuable de données  est nécessaire (pour, par exemple, les stocker dans un :"
"class:`set` ou un :class:`dict`)."

#: ../Doc/library/stdtypes.rst:1215
msgid "Tuples may be constructed in a number of ways:"
msgstr "Les tuples peuvent être construits de différentes façons :"

#: ../Doc/library/stdtypes.rst:1217
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"En utilisant une paire de parenthèses pour désigner le tuple vide : ``()``"

#: ../Doc/library/stdtypes.rst:1218
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""
"En utilisant une virgule, pour créer un tuple d'un élément : ``a,`` ou "
"``(a,)``"

#: ../Doc/library/stdtypes.rst:1219
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr ""
"En séparant les éléments avec des virgules : ``a, b, c`` ou ``(a, b, c)``"

#: ../Doc/library/stdtypes.rst:1220
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"En utilisant la fonction native :func:`tuple` : ``tuple()`` ou "
"``tuple(iterable)``"

#: ../Doc/library/stdtypes.rst:1222
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"Le constructeur construit un tuple dont les éléments sont les mêmes et dans "
"le même ordre que les éléments de *iterable*. *iterable* peut être soit une "
"séquence, un conteneur qui supporte l'itération, soit un itérateur. Si "
"*iterable* est déjà un tuple, il est renvoyé inchangé. Par exemple, "
"``tuple('abc')`` renvoie ``('a', 'b', 'c')`` et ``tuple( [1, 2, 3] )`` "
"renvoie ``(1, 2, 3)``. Si aucun argument est donné, le constructeur crée un "
"nouveau tuple vide, ``()``."

#: ../Doc/library/stdtypes.rst:1230
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Notez que c'est en fait la virgule qui fait un tuple et non les parenthèses. "
"Les parenthèses sont facultatives, sauf dans le cas du tuple vide, ou "
"lorsqu'elles sont nécessaires pour éviter l'ambiguïté syntaxique. Par "
"exemple, ``f(a, b, c)`` est un appel de fonction avec trois arguments, alors "
"que ``f((a, b, c))`` est un appel de fonction avec un tuple de trois "
"éléments comme unique argument."

#: ../Doc/library/stdtypes.rst:1236
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Les tuples implémentent toutes les opérations :ref:`communes <typesseq-"
"common>` des séquences."

#: ../Doc/library/stdtypes.rst:1239
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Pour les collections hétérogènes de données où l'accès par nom est plus "
"clair que l'accès par index, :func:`collections.namedtuple` peut être un "
"choix plus approprié qu'un simple tuple."

#: ../Doc/library/stdtypes.rst:1247
msgid "Ranges"
msgstr "*Ranges*"

#: ../Doc/library/stdtypes.rst:1251
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"Le type :class:`range` représente une séquence immuable de nombres et est "
"couramment utilisé pour itérer un certain nombre de fois dans les boucles :"
"keyword:`for`."

#: ../Doc/library/stdtypes.rst:1258
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the ``__index__`` special "
"method).  If the *step* argument is omitted, it defaults to ``1``. If the "
"*start* argument is omitted, it defaults to ``0``. If *step* is zero, :exc:"
"`ValueError` is raised."
msgstr ""
"Les arguments du constructeur de *range* doivent être des entiers (des :"
"class:`int` ou tout autre objet qui implémente la méthode spéciale "
"``__index__``). La valeur par défaut de l'argument *step* est ``1``. La "
"valeur par défaut de l'argument *start* est ``0``. Si *step* est égal à "
"zéro, une exception :exc:`ValueError` est levée."

#: ../Doc/library/stdtypes.rst:1264
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Pour un *step* positif, le contenu d'un *range* ``r`` est déterminé par la "
"formule ``r[i] = start + step*i`` où ``i >= 0`` et ``r[i] < stop``."

#: ../Doc/library/stdtypes.rst:1268
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"Pour un *step* négatif, le contenu du *range* est toujours déterminé par la "
"formule ``r[i] = start + step*i``, mais les contraintes sont ``i >= 0`` et "
"``r[i] > stop``."

#: ../Doc/library/stdtypes.rst:1272
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Un objet *range* sera vide si ``r[0]`` ne répond pas à la contrainte de "
"valeur. Les *range* prennent en charge les indices négatifs, mais ceux-ci "
"sont interprétées comme une indexation de la fin de la séquence déterminée "
"par les indices positifs."

#: ../Doc/library/stdtypes.rst:1277
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Les *range* contenant des valeurs absolues plus grandes que :data:`sys."
"maxsize` sont permises, mais certaines fonctionnalités (comme :func:`len`) "
"peuvent lever :exc:`OverflowError`."

#: ../Doc/library/stdtypes.rst:1281
msgid "Range examples::"
msgstr "Exemples avec *range* ::"

#: ../Doc/library/stdtypes.rst:1298
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"*range* implémente toutes les opérations :ref:`communes <typesseq-common>` "
"des séquences sauf la concaténation et la répétition (en raison du fait que "
"les *range* ne peuvent représenter que des séquences qui respectent un motif "
"strict et que la répétition et la concaténation les feraient dévier de ce "
"motif)."

#: ../Doc/library/stdtypes.rst:1305
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr ""
"La valeur du paramètre *start* (ou ``0`` si le paramètre n'a pas été fourni)"

#: ../Doc/library/stdtypes.rst:1310
msgid "The value of the *stop* parameter"
msgstr "La valeur du paramètre *stop*"

#: ../Doc/library/stdtypes.rst:1314
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr ""
"La valeur du paramètre *step* (ou ``1`` si le paramètre n'a pas été fourni)"

#: ../Doc/library/stdtypes.rst:1317
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"L'avantage du type :class:`range` sur une :class:`list` classique ou :class:"
"`tuple` est qu'un objet :class:`range` prendra toujours la même (petite) "
"quantité de mémoire, peu importe la taille de la gamme qu'elle représente "
"(car elle ne stocke que les valeurs ``start``, ``stop`` et ``step`` , le "
"calcul des éléments individuels et les sous-*range* au besoin)."

#: ../Doc/library/stdtypes.rst:1323
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Les *range* implémentent la classe de base abstraite :class:`collections.abc."
"Sequence` et offrent des fonctionnalités telles que les tests d'appartenance "
"(avec *in*), de recherche par index, le tranchage et ils gerent les indices "
"négatifs (voir :ref:`typesseq`):"

#: ../Doc/library/stdtypes.rst:1343
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"Comparer des *range* avec ``==`` et ``!=`` les compare comme des séquences. "
"Soit deux objets *range* sont considérées comme égaux si ils représentent la "
"même séquence de valeurs. (Notez que deux objets *range* dits égaux "
"pourraient avoir leurs attributs :attr:`~range.start`, :attr:`~range.stop` "
"et :attr:`~range.step` différents, par exemple ``range(0) == range(2, 1, "
"3)`` ou ``range(0, 3, 2) == range(0, 4, 2)``.)"

#: ../Doc/library/stdtypes.rst:1350
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Implémente la classe de base abstraite *Sequence*. Supporte le *slicing* et "
"les indices négatifs. Tester l'appartenance d'un :class:`int` en temps "
"constant au lieu d'itérer tous les éléments."

#: ../Doc/library/stdtypes.rst:1356
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"'==' et '!=' comparent des *range* en fonction de la séquence de valeurs "
"qu'ils définissent (au lieu d'une comparaison fondée sur l'identité de "
"l'objet)."

#: ../Doc/library/stdtypes.rst:1361
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"Les attributs :attr:`~range.start`, :attr:`~range.stop` et :attr:`~range."
"step`."

#: ../Doc/library/stdtypes.rst:1367
msgid ""
"The `linspace recipe <http://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range that suitable for floating point "
"applications."
msgstr ""
"La `recette linspace <http://code.activestate.com/recipes/579000/>`_ montre "
"comment implémenter une version paresseuse de *range* adaptée aux nombres à "
"virgule flottante."

#: ../Doc/library/stdtypes.rst:1379
msgid "Text Sequence Type --- :class:`str`"
msgstr "Type Séquence de Texte --- :class:`str`"

#: ../Doc/library/stdtypes.rst:1381
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Les données textuelles en Python est manipulé avec des objets :class:`str` "
"ou :dfn:`strings`. Les chaînes sont  des :ref:`séquences <typesseq>` "
"immuables de points de code Unicode. Les chaînes littérales peuvent être "
"écrites de différentes manières :"

#: ../Doc/library/stdtypes.rst:1386
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Les guillemets simples : ``'autorisent les \"guillemets\"'``"

#: ../Doc/library/stdtypes.rst:1387
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``."
msgstr "Les guillemets : ``\"autorisent les guillemets 'simples'\"``."

#: ../Doc/library/stdtypes.rst:1388
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double quotes"
"\"\"\"``"
msgstr ""
"Guillemets triples : ``'''Trois guillemets simples'''``, ``\"\"\"Trois "
"guillemets\"\"\"``"

#: ../Doc/library/stdtypes.rst:1390
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Les chaînes entre triple guillemets peuvent couvrir plusieurs lignes - tous "
"les espaces associés seront inclus dans la chaîne littérale."

#: ../Doc/library/stdtypes.rst:1393
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Les chaînes littérales qui font partie d'une seule expression et ont "
"seulement des espaces entre elles sont implicitement converties en une seule "
"chaîne littérale. Autrement dit, ``(\"spam \" \"eggs\") == \"spam eggs\"``."

#: ../Doc/library/stdtypes.rst:1397
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""
"Voir :ref:`strings` pour plus d'informations sur les différentes formes de "
"chaînes littérales, y compris des séquences d'échappement prises en charge, "
"et le  préfixe ``r`` (*raw* (brut)) qui désactive la plupart des traitements "
"de séquence d'échappement."

#: ../Doc/library/stdtypes.rst:1401
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Les chaînes peuvent également être créés à partir d'autres objets à l'aide "
"du constructeur :class:`str`."

#: ../Doc/library/stdtypes.rst:1404
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Comme il n'y a pas de type \"caractère\" distinct, l'indexation d'une chaîne "
"produit des chaînes de longueur 1. Autrement dit, pour une chaîne non vide "
"*s*, ``s[0] == s[0:1]``."

#: ../Doc/library/stdtypes.rst:1410
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Il n'y a aucun type de chaîne mutable, mais :meth:`str.join` ou :class:`io."
"StringIO` peuvent être utilisées pour construire efficacement des chaînes à "
"partir de plusieurs fragments."

#: ../Doc/library/stdtypes.rst:1414
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Pour une compatibilité ascendante avec la série Python 2, le préfixe ``u`` "
"est à nouveau autorisé sur les chaînes littérales. Elle n'a aucun effet sur "
"le sens des chaînes littérales et ne peut être combiné avec le préfixe ``r``."

#: ../Doc/library/stdtypes.rst:1426
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Renvoie une représentation :ref:`string <textseq>` de *object*. Si *object* "
"n'est pas fourni, renvoie une chaîne vide. Sinon, le comportement de "
"``str()`` dépend de si *encoding* ou *errors* sont donnés, voir l'exemple."

#: ../Doc/library/stdtypes.rst:1430
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`object.__str__() <object.__str__>`, which is the \"informal\" or nicely "
"printable string representation of *object*.  For string objects, this is "
"the string itself.  If *object* does not have a :meth:`~object.__str__` "
"method, then :func:`str` falls back to returning :meth:`repr(object) <repr>`."
msgstr ""
"Si ni *encoding* ni *errors* ne sont donnés, ``str(object)`` renvoie :meth:"
"`object.__str__() <object.__str__>`, qui est la représentation de chaîne "
"\"informelle\" ou bien affichable de *object*. Pour les chaînes, c'est la "
"chaîne elle-même. Si *object* n'a pas de méthode :meth:`~object.__str__`, :"
"func:`str` utilise  :meth:`repr(object) <repr>`."

#: ../Doc/library/stdtypes.rst:1441
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Si au moins un des deux arguments *encoding* ou *errors* est donné, *object* "
"doit être un :term:`bytes-like object` (par exemple :class:`bytes` ou :class:"
"`bytearray`). Dans ce cas, si *object* est un objet :class:`bytes` (ou :"
"class:`bytearray`), alors ``str(bytes, encoding, errors)`` est équivalent à :"
"meth:`bytes.decode(encoding, errors) <bytes.decode>`. Sinon, l'objet *bytes* "
"du buffer est obtenu avant d'appeler :meth:`bytes.decode`. Voir :ref:"
"`binaryseq` et :ref:`bufferobjects` pour plus d'informations sur les buffers."

#: ../Doc/library/stdtypes.rst:1450
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Donner un objet :class:`bytes` à :func:`str` sans ni l'argument *encoding* "
"ni l'argument *errors* relève du premier cas, où la représentation "
"informelle de la chaîne est renvoyé (voir aussi l'option :option:`-b` de "
"Python). Par exemple : ::"

#: ../Doc/library/stdtypes.rst:1458
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Pour plus d'informations sur la classe ``str`` et ses méthodes, voir les "
"sections :ref:`textseq` et :ref:`string-methods`. Pour formatter des chaînes "
"de caractères, voir les sections :ref:`f-strings` et :ref:`formatstrings`. "
"La section :ref:`stringservices` contient aussi des informations."

#: ../Doc/library/stdtypes.rst:1470
msgid "String Methods"
msgstr "Méthodes de chaînes de caractères"

#: ../Doc/library/stdtypes.rst:1475
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Les chaînes implémentent toutes les opérations :ref:`communes des séquences "
"<typesseq-common>`, ainsi que les autres méthodes décrites ci-dessous."

#: ../Doc/library/stdtypes.rst:1478
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Les chaînes gèrent aussi deux styles de mise en forme, l'un fournissant une "
"grande flexibilité et de personnalisation (voir :meth:`str.format`, :ref:"
"`formatstrings` et :ref:`string-formatting`) et l'autre basée sur ``printf`` "
"du C qui gère une gamme plus étroite des types et est légèrement plus "
"difficile à utiliser correctement, mais il est souvent plus rapide pour les "
"cas, il peut gérer (:ref:`old-string-formatting`)."

#: ../Doc/library/stdtypes.rst:1485
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"La section :ref:`textservices` de la bibliothèque standard couvre un certain "
"nombre d'autres modules qui fournissent différents services relatifs au "
"texte (y compris les expressions régulières dans le module :mod:`re`)."

#: ../Doc/library/stdtypes.rst:1491
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"Renvoie une copie de la chaîne avec son premier caractère en majuscule et le "
"reste en minuscule."

#: ../Doc/library/stdtypes.rst:1497
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Renvoie une copie *casefolded* de la chaîne. Les chaînes *casefolded* "
"peuvent être utilisées dans des comparaison insensibles à la casse."

#: ../Doc/library/stdtypes.rst:1500
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"Le *casefolding* est une technique agressive de mise en minuscule, car il "
"vise à éliminer toutes les distinctions de casse dans une chaîne. Par "
"exemple, la lettre minuscule ``'ß'`` de l'allemand équivaut à ``\"ss\"``. "
"Comme il est déjà minuscule, :meth:`lower` ferait rien à ``'ß'``; :meth:"
"`casefold` le convertit en ``\"ss\"``."

#: ../Doc/library/stdtypes.rst:1506
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"L'algorithme de *casefolding* est décrit dans la section 3.13 de la norme "
"Unicode."

#: ../Doc/library/stdtypes.rst:1514
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Donne la chaîne au centre d'une chaîne de longueur *width*. Le remplissage "
"est fait enutilisant l'argument *fillchar* (qui par défaut est un espace "
"ASCII). La chaîne d'origine est renvoyée si *width* est inférieur ou égale à "
"``len(s)``."

#: ../Doc/library/stdtypes.rst:1522
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Donne le nombre d'occurrences de *sub* ne se chevauchant pas dans le *range* "
"[*start*, *end*]. Les arguments facultatifs *start* et *end* sont "
"interprétés comme pour des *slices*."

#: ../Doc/library/stdtypes.rst:1529
msgid ""
"Return an encoded version of the string as a bytes object. Default encoding "
"is ``'utf-8'``. *errors* may be given to set a different error handling "
"scheme. The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`. Other possible values are ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and any other "
"name registered via :func:`codecs.register_error`, see section :ref:`error-"
"handlers`. For a list of possible encodings, see section :ref:`standard-"
"encodings`."
msgstr ""
"Donne une version encodée de la chaîne sous la forme d'un objet *bytes*. "
"L'encodage par défaut est ``'utf-8'``. *errors* peut être donné pour choisir "
"un autre système de gestion d'erreur. La valeur par défaut pour *errors* est "
"``'strict'``, ce qui signifie que les erreurs d'encodage soulèvent une :exc:"
"`UnicodeError`. Les autres valeurs possibles sont ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` et tout autre "
"nom enregistré via :func:`codecs.register_error`, voir la section :ref:"
"`error-handlers`. Pour une liste des encodages possibles, voir la section :"
"ref:`standard-encodings`."

#: ../Doc/library/stdtypes.rst:1538
msgid "Support for keyword arguments added."
msgstr "Gestion des arguments par mot clef."

#: ../Doc/library/stdtypes.rst:1544
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Donne ``True`` si la chaîne se termine par *suffix*, sinon ``False``. "
"*suffix* peut aussi être un tuple de suffixes à rechercher. Si l'argument "
"optionnel *start* est donné, le test se fait à partir de cette position. Si "
"l'argument optionnel *end* est fourni, la comparaison s'arrête à cette "
"position."

#: ../Doc/library/stdtypes.rst:1552
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline (``"
"\\n``) or return (``\\r``), it is copied and the current column is reset to "
"zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"Donne une copie de la chaîne où toutes les tabulations sont remplacées par "
"un ou plusieurs espaces, en fonction de la colonne courante et de la taille "
"de tabulation donnée. Les positions des tabulations se trouvent tous les "
"*tabsize* caractères (8 par défaut, ce qui donne les positions de "
"tabulations aux colonnes 0, 8, 16 et ainsi de suite). Pour travailler sur la "
"chaîne, la colonne en cours est mise à zéro et la chaîne est examinée "
"caractère par caractère. Si le caractère est une tabulation (``\\t``), un ou "
"plusieurs caractères d'espacement sont insérés dans le résultat jusqu'à ce "
"que la colonne courante soit égale à la position de tabulation suivante. (Le "
"caractère tabulation lui-même n'est pas copié.) Si le caractère est un saut "
"de ligne (``\\n``) ou un retour chariot (``\\r``), il est copié et la "
"colonne en cours est remise à zéro. Tout autre caractère est copié inchangé "
"et la colonne en cours est incrémentée de un indépendamment de la façon dont "
"le caractère est représenté lors de l'affichage."

#: ../Doc/library/stdtypes.rst:1573
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Donne la première la position dans la chaîne où *sub* est trouvé dans le "
"*slice* ``s[start:end]``. Les arguments facultatifs *start* et *end* sont "
"interprétés comme dans la notation des *slice*. Donne ``-1`` si *sub* n'est "
"pas trouvé."

#: ../Doc/library/stdtypes.rst:1579
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"La méthode :meth:`~str.find` ne doit être utilisée que si vous avez besoin "
"de connaître la position de *sub*. Pour vérifier si *sub* est une sous "
"chaine ou non, utilisez l'opérateur :keyword:`in` ::"

#: ../Doc/library/stdtypes.rst:1589
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Formatte une chaîne. La chaîne sur laquelle cette méthode est appelée peut "
"contenir du texte littéral ou des emplacements de remplacement délimités par "
"des accolades ``{}``. Chaque champ de remplacement contient soit l'indice "
"numérique d'un argument positionnel, ou le nom d'un argument donné par mot-"
"clé. Renvoie une copie de la chaîne où chaque champ de remplacement est "
"remplacé par la valeur de chaîne de l'argument correspondant."

#: ../Doc/library/stdtypes.rst:1599
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Voir :ref:`formatstrings` pour une description des options de formatage qui "
"peuvent être spécifiées dans les chaînes de format."

#: ../Doc/library/stdtypes.rst:1605
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Semblable à ``str.format(**mapping)``, sauf que ``mapping`` est utilisé "
"directement et non copié dans un :class:`dict`. C'est utile si, par exemple "
"``mapping`` est une sous-classe de dict :"

#: ../Doc/library/stdtypes.rst:1621
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
"Comme :meth:`~str.find`, mais lève une :exc:`ValueError` lorsque la chaîne "
"est introuvable."

#: ../Doc/library/stdtypes.rst:1627
msgid ""
"Return true if all characters in the string are alphanumeric and there is at "
"least one character, false otherwise.  A character ``c`` is alphanumeric if "
"one of the following returns ``True``: ``c.isalpha()``, ``c.isdecimal()``, "
"``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Donne ``True`` si tous les caractères de la chaîne sont alphanumériques et "
"qu'il y a au moins un caractère, sinon ``False``. Un caractère ``c`` est "
"alphanumérique si l'un des tests suivants est vrais : ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()`` ou ``c.isnumeric()``."

#: ../Doc/library/stdtypes.rst:1635
msgid ""
"Return true if all characters in the string are alphabetic and there is at "
"least one character, false otherwise.  Alphabetic characters are those "
"characters defined in the Unicode character database as \"Letter\", i.e., "
"those with general category property being one of \"Lm\", \"Lt\", \"Lu\", "
"\"Ll\", or \"Lo\".  Note that this is different from the \"Alphabetic\" "
"property defined in the Unicode Standard."
msgstr ""
"Donne ``True`` si tous les caractères de la chaîne sont alphabétiques et "
"qu'elle contient au moins un caractère, sinon ``False``. Les caractères "
"alphabétiques sont les caractères définis dans la base de données de "
"caractères Unicode comme *Letter*, à savoir, ceux qui ont \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", ou \"Lo\" comme catégorie générale. Notez que ceci est "
"différent de la propriété *Alphabetic* définie dans la norme Unicode."

#: ../Doc/library/stdtypes.rst:1644
msgid ""
"Return true if all characters in the string are decimal characters and there "
"is at least one character, false otherwise. Decimal characters are those "
"that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT "
"ZERO.  Formally a decimal character is a character in the Unicode General "
"Category \"Nd\"."
msgstr ""
"Renvoie vrai si tous les caractères de la chaîne sont des caractères "
"décimaux et qu'elle contient au moins un caractère, sinon faux. Les "
"caractères décimaux sont ceux pouvant être utilisés pour former des nombres "
"en base 10, tels que U+0660, ARABIC-INDIC DIGIT ZERO.  Spécifiquement, un "
"caractère décimal est un caractère dans la catégorie unicode générale \"Nd\"."

#: ../Doc/library/stdtypes.rst:1654
msgid ""
"Return true if all characters in the string are digits and there is at least "
"one character, false otherwise.  Digits include decimal characters and "
"digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Renvoie vrai si tous les caractères de la chaîne sont des chiffres et "
"qu'elle contient au moins un caractère, faux sinon. Les chiffres incluent "
"des caractères décimaux et des chiffres qui nécessitent une manipulation "
"particulière, tels que les *compatibility superscript digits*. Ça couvre les "
"chiffres qui ne peuvent pas être utilisés pour construire des nombres en "
"base 10, tel que les nombres de Kharosthi. Spécifiquement, un chiffre est un "
"caractère dont la valeur de la propriété *Numeric_Type* est *Digit* ou "
"*Decimal*."

#: ../Doc/library/stdtypes.rst:1664
msgid ""
"Return true if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`."
msgstr ""
"Donne ``True`` si la chaîne est un identifiant valide selon la définition du "
"langage, section :ref:`identifiers`."

#: ../Doc/library/stdtypes.rst:1667
msgid ""
"Use :func:`keyword.iskeyword` to test for reserved identifiers such as :"
"keyword:`def` and :keyword:`class`."
msgstr ""
"Utilisez :func:`keyword.iskeyword` pour savoir si un identifiant est "
"réservé, tels que :keyword:`def` et :keyword:`class`."

#: ../Doc/library/stdtypes.rst:1672
msgid ""
"Return true if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, false otherwise."
msgstr ""
"Donne ``True`` si tous les caractères capitalisables [4]_ de la chaîne sont "
"en minuscules et qu'elle contient au moins un caractère capitalisable. Donne "
"``False`` dans le cas contraire."

#: ../Doc/library/stdtypes.rst:1678
msgid ""
"Return true if all characters in the string are numeric characters, and "
"there is at least one character, false otherwise. Numeric characters include "
"digit characters, and all characters that have the Unicode numeric value "
"property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Donne ``True`` si tous les caractères de la chaîne sont des caractères "
"numériques, et qu'elle contient au moins un caractère, sinon ``False``. Les "
"caractères numériques comprennent les chiffres, et tous les caractères  qui "
"ont la propriété Unicode *numeric value*, par exemple U+2155, *VULGAR "
"FRACTION OF FIFTH*. Formellement, les caractères numériques sont ceux avec "
"les priorités *Numeric_Type=Digit*, *Numeric_Type=Decimal*, ou "
"*Numeric_Type=Numeric*."

#: ../Doc/library/stdtypes.rst:1688
msgid ""
"Return true if all characters in the string are printable or the string is "
"empty, false otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Donne ``True`` si tous les caractères de la chaîne sont affichables ou "
"qu'elle est vide sinon, ``False``. Les caractères non affichables sont les "
"caractères définis dans la base de données de caractères Unicode comme *"
"\"Other\"* ou *\"Separator\"*, à l'exception de l'espace ASCII (0x20) qui "
"est considéré comme affichable. (Notez que les caractères imprimables dans "
"ce contexte sont ceux qui ne devraient pas être protégés quand :func:`repr` "
"est invoquée sur une chaîne. Ça n'a aucune incidence sur le traitement des "
"chaînes écrites sur :data:`sys.stdout` ou :data:`sys.stderr`.)"

#: ../Doc/library/stdtypes.rst:1699
msgid ""
"Return true if there are only whitespace characters in the string and there "
"is at least one character, false otherwise.  Whitespace characters  are "
"those characters defined in the Unicode character database as \"Other\" or "
"\"Separator\" and those with bidirectional property being one of \"WS\", \"B"
"\", or \"S\"."
msgstr ""
"Donne ``True`` s'il n'y a que des caractères blancs dans la chaîne et il y a "
"au moins un caractère, sinon ``False``. Les caractères blancs sont les "
"caractères définis dans la base de données de caractères Unicode comme *"
"\"Other\"* ou *\"Separator\"* ainsi que ceux ayant la propriété "
"bidirectionnelle valant \"WS\", \"B\" ou \"S\"."

#: ../Doc/library/stdtypes.rst:1706
msgid ""
"Return true if the string is a titlecased string and there is at least one "
"character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return false otherwise."
msgstr ""
"Donne ``True`` si la chaîne est une chaîne *titlecased* et qu'elle contient "
"au moins un caractère, par exemple les caractères majuscules ne peuvent "
"suivre les caractères non capitalisables et les caractères minuscules ne "
"peuvent suivre que des caractères capitalisables. Donne ``False`` dans le "
"cas contraire."

#: ../Doc/library/stdtypes.rst:1713
msgid ""
"Return true if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, false otherwise."
msgstr ""
"Donne ``True`` si tous les caractères différentiables sur la casse [4]_ de "
"la chaîne sont en majuscules et il y a au moins un caractère différentiable "
"sur la casse, sinon ``False``."

#: ../Doc/library/stdtypes.rst:1719
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"Donne une chaîne qui est la concaténation des chaînes contenues dans "
"*iterable*. Une :exc:`TypeError` sera levée si une valeur d'*iterable* n'est "
"pas une chaîne, y compris pour les objets :class:`bytes`.  Le séparateur "
"entre les éléments est la chaîne fournissant cette méthode."

#: ../Doc/library/stdtypes.rst:1727
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Renvoie la chaîne justifiée à gauche dans une chaîne de longueur *width*. Le "
"rembourrage est fait en utilisant *fillchar* (qui par défaut est un espace "
"ASCII). La chaîne d'origine est renvoyée si *width* est inférieur ou égale à "
"``len(s)``."

#: ../Doc/library/stdtypes.rst:1734
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Renvoie une copie de la chaîne avec tous les caractères capitalisables [4]_ "
"convertis en minuscules."

#: ../Doc/library/stdtypes.rst:1737
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"L'algorithme de mise en minuscules utilisé est décrit dans la section 3.13 "
"de la norme Unicode."

#: ../Doc/library/stdtypes.rst:1743
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Renvoie une copie de la chaîne des caractères supprimés au début. L'argument "
"*chars* est une chaîne spécifiant le jeu de caractères à supprimer. En cas "
"d'omission ou ``None``, la valeur par défaut de *chars* permet de supprimer "
"des espaces. L'argument *chars* n'est pas un préfixe, toutes les "
"combinaisons de ses valeurs sont supprimées ::"

#: ../Doc/library/stdtypes.rst:1756
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Cette méthode statique renvoie une table de traduction utilisable pour :meth:"
"`str.translate`."

#: ../Doc/library/stdtypes.rst:1758
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Si un seul argument est fourni, ce soit être un dictionnaire faisant "
"correspondre des points de code Unicode (nombres entiers) ou des caractères "
"(chaînes de longueur 1) à des points de code Unicode"

#: ../Doc/library/stdtypes.rst:1763
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"Si deux arguments sont fournis, ce doit être deux chaînes de caractères de "
"même longueur. Le dictionnaire renvoyé fera correspondre pour chaque "
"caractère de x un caractère de y pris à la même place. Si un troisième "
"argument est fourni, ce doit être une chaîne dont chaque caractère "
"correspondra à ``None`` dans le résultat."

#: ../Doc/library/stdtypes.rst:1771
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Divise la chaîne à la première occurrence de *sep*, et donne un *tuple* de "
"trois éléments contenant la partie avant le séparateur, le séparateur lui-"
"même, et la partie après le séparateur. Si le séparateur n'est pas trouvé, "
"le *tuple* contiendra la chaîne elle-même, suivie de deux chaînes vides."

#: ../Doc/library/stdtypes.rst:1779
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"Renvoie une copie de la chaîne dont toutes les occurrences de la sous-"
"chaîne  *old* sont remplacés par *new*. Si l'argument optionnel *count* est "
"donné, seules les *count* premières occurrences sont remplacées."

#: ../Doc/library/stdtypes.rst:1786
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Donne l'indice le plus élevé dans la chaîne où la sous-chaîne *sub* se "
"trouve, de telle sorte que *sub* soit contenue dans ``s[start:end]``. Les "
"arguments facultatifs *start* et *end* sont interprétés comme dans la "
"notation des *slices*. Donne  ``-1`` en cas d'échec."

#: ../Doc/library/stdtypes.rst:1793
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Comme :meth:`rfind` mais lève une exception :exc:`ValueError` lorsque la "
"sous-chaîne *sub* est introuvable."

#: ../Doc/library/stdtypes.rst:1799
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Renvoie la chaîne justifié à droite dans une chaîne de longueur *width*. Le "
"rembourrage est fait en utilisant le caractère spécifié par *fillchar* (par "
"défaut est un espace ASCII). La chaîne d'origine est renvoyée si *width* est "
"inférieure ou égale à ``len(s)``."

#: ../Doc/library/stdtypes.rst:1806
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Divise la chaîne à la dernière occurrence de *sep*, et donne un tuple de "
"trois éléments contenant la partie avant le séparateur, le séparateur lui-"
"même, et la partie après le séparateur. Si le séparateur n'est pas trouvé, "
"le tuple contindra deux chaînes vides, puis par la chaîne elle-même."

#: ../Doc/library/stdtypes.rst:1814
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Renvoie une liste des mots de la chaîne, en utilisant *sep* comme "
"séparateur. Si *maxsplit* est donné, c'est le nombre maximum de divisions "
"qui pourront être faites, celles \"à droite\". Si *sep* est pas spécifié ou "
"est ``None``, tout espace est un séparateur. En dehors du fait qu'il découpe "
"par la droite, :meth:`rsplit` se comporte comme :meth:`split` qui est décrit "
"en détail ci-dessous."

#: ../Doc/library/stdtypes.rst:1823
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Renvoie une copie de la chaîne avec des caractères finaux supprimés. "
"L'argument *chars* est une chaîne spécifiant le jeu de caractères à "
"supprimer. En cas d'omission ou ``None``, les espaces sont supprimés. "
"L'argument *chars* n'est pas un suffixe : toutes les combinaisons de ses "
"valeurs sont retirées : ::"

#: ../Doc/library/stdtypes.rst:1836
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Renvoie une liste des mots de la chaîne, en utilisant *sep* comme séparateur "
"de mots. Si *maxsplit* est donné, c'est le nombre maximum de divisionsqui "
"pourront être effectuées, (donnant ainsi une liste de longueur ``maxsplit"
"+1``). Si *maxsplit* n'est pas fourni, ou vaut ``-1``, le nombre de découpes "
"n'est pas limité (Toutes les découpes possibles sont faites)."

#: ../Doc/library/stdtypes.rst:1842
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"Si *sep* est donné, les délimiteurs consécutifs ne sont pas regroupés et "
"ainsi délimitent des chaînes vides (par exemple, ``'1,,2'.split(',')`` donne "
"``['1', '', '2']``). L'argument *sep* peut contenir plusieurs caractères "
"(par exemple, ``'1<>2<>3'.split('<>')`` renvoie ``['1', '2', '3']``). "
"Découper une chaîne vide en spécifiant *sep* donne ``['']``."

#: ../Doc/library/stdtypes.rst:1848 ../Doc/library/stdtypes.rst:1864
#: ../Doc/library/stdtypes.rst:1916 ../Doc/library/stdtypes.rst:1984
#: ../Doc/library/stdtypes.rst:2048 ../Doc/library/stdtypes.rst:2788
#: ../Doc/library/stdtypes.rst:2804 ../Doc/library/stdtypes.rst:2895
#: ../Doc/library/stdtypes.rst:2911 ../Doc/library/stdtypes.rst:2926
#: ../Doc/library/stdtypes.rst:2940 ../Doc/library/stdtypes.rst:2968
#: ../Doc/library/stdtypes.rst:2982 ../Doc/library/stdtypes.rst:3000
#: ../Doc/library/stdtypes.rst:3027 ../Doc/library/stdtypes.rst:3050
#: ../Doc/library/stdtypes.rst:3077 ../Doc/library/stdtypes.rst:3119
#: ../Doc/library/stdtypes.rst:3143
msgid "For example::"
msgstr "Par exemple : ::"

#: ../Doc/library/stdtypes.rst:1857
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Si *sep* n'est pas spécifié ou est ``None``, un autre algorithme de "
"découpage est appliqué : les espaces consécutifs sont considérés comme un "
"seul séparateur, et le résultat ne contiendra pas les chaînes vides de début "
"ou de la fin si la chaîne est préfixée ou suffixé d'espaces. Par conséquent, "
"diviser une chaîne vide ou une chaîne composée d'espaces avec un séparateur "
"``None`` renvoie ``[]``."

#: ../Doc/library/stdtypes.rst:1879
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Renvoie les lignes de la chaîne sous forme de liste, la découpe se fait au "
"niveau deslimites des lignes. Les sauts de ligne ne sont pas inclus dans la "
"liste des résultats, sauf si *keepends* est donné, et est vrai."

#: ../Doc/library/stdtypes.rst:1883
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Cette méthode découpe sur les limites de ligne suivantes. Ces limites sont "
"un sur ensemble de :term:`universal newlines`."

#: ../Doc/library/stdtypes.rst:1887
msgid "Representation"
msgstr "Représentation"

#: ../Doc/library/stdtypes.rst:1887
msgid "Description"
msgstr "Description"

#: ../Doc/library/stdtypes.rst:1889
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/library/stdtypes.rst:1889
msgid "Line Feed"
msgstr "Saut de ligne"

#: ../Doc/library/stdtypes.rst:1891
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/library/stdtypes.rst:1891
msgid "Carriage Return"
msgstr "Retour Chariot"

#: ../Doc/library/stdtypes.rst:1893
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../Doc/library/stdtypes.rst:1893
msgid "Carriage Return + Line Feed"
msgstr "Retour Chariot + Saut de Ligne"

#: ../Doc/library/stdtypes.rst:1895
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` or ``\\x0b``"

#: ../Doc/library/stdtypes.rst:1895
msgid "Line Tabulation"
msgstr "Tabulation Verticale"

#: ../Doc/library/stdtypes.rst:1897
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` or ``\\x0c``"

#: ../Doc/library/stdtypes.rst:1897
msgid "Form Feed"
msgstr "Saut de Page"

#: ../Doc/library/stdtypes.rst:1899
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../Doc/library/stdtypes.rst:1899
msgid "File Separator"
msgstr "Séparateur de Fichiers"

#: ../Doc/library/stdtypes.rst:1901
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../Doc/library/stdtypes.rst:1901
msgid "Group Separator"
msgstr "Séparateur de groupes"

#: ../Doc/library/stdtypes.rst:1903
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../Doc/library/stdtypes.rst:1903
msgid "Record Separator"
msgstr "Séparateur d'enregistrements"

#: ../Doc/library/stdtypes.rst:1905
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../Doc/library/stdtypes.rst:1905
msgid "Next Line (C1 Control Code)"
msgstr "Ligne Suivante (code de contrôle C1)"

#: ../Doc/library/stdtypes.rst:1907
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../Doc/library/stdtypes.rst:1907
msgid "Line Separator"
msgstr "Séparateur de Ligne"

#: ../Doc/library/stdtypes.rst:1909
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../Doc/library/stdtypes.rst:1909
msgid "Paragraph Separator"
msgstr "Séparateur de Paragraphe"

#: ../Doc/library/stdtypes.rst:1914
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` et ``\\f`` ajoutés à la liste des limites de lignes."

#: ../Doc/library/stdtypes.rst:1923
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Contrairement à :meth:`~str.split` lorsque *sep* est fourni, cette méthode "
"renvoie une liste vide pour la chaîne vide, et un saut de ligne à la fin ne "
"se traduit pas par une ligne supplémentaire : ::"

#: ../Doc/library/stdtypes.rst:1932
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "À titre de comparaison, ``split('\\n')`` donne : ::"

#: ../Doc/library/stdtypes.rst:1942
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Donne ``True`` si la chaîne commence par *prefix*, sinon  ``False``. "
"*prefix* peut aussi être un tuple de préfixes à rechercher. Lorsque *start* "
"est donné, la comparaison commence à cette position, et lorsque *end* est "
"donné, la comparaison s'arrête à celle ci."

#: ../Doc/library/stdtypes.rst:1950
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Donne une copie de la chaîne dont des caractères initiaux et finaux sont "
"supprimés. L'argument *chars* est une chaîne spécifiant le jeu de caractères "
"à supprimer. En cas d'omission ou ``None``, les espaces sont supprimés. "
"L'argument *chars* est pas un préfixe ni un suffixe, toutes les combinaisons "
"de ses valeurs sont supprimées : ::"

#: ../Doc/library/stdtypes.rst:1961
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"Les caractères de *char* sont retirés du début et de la fin de la chaîne. "
"Les caractères sont retirés de la gauche jusqu'à atteindre un caractère ne "
"figurant pas dans le jeu de caractères dans *chars*. La même opération à "
"lieu par la droite. Par exemple : ::"

#: ../Doc/library/stdtypes.rst:1974
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Renvoie une copie de la chaîne dont les caractères majuscules sont  "
"convertis en minuscules et vice versa. Notez qu'il est pas nécessairement "
"vrai que ``s.swapcase().swapcase() == s``."

#: ../Doc/library/stdtypes.rst:1981
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Renvoie une version en initiales majuscules de la chaîne où les mots "
"commencent par une capitale et les caractères restants sont en minuscules."

#: ../Doc/library/stdtypes.rst:1989 ../Doc/library/stdtypes.rst:3087
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"Pour l'algorithme, la notion de mot est définie simplement et indépendamment "
"de la langue comme un groupe de lettres consécutives. La définition "
"fonctionnedans de nombreux contextes, mais cela signifie que les apostrophes "
"(typiquement dela forme possessive en Anglais) forment les limites de mot, "
"ce qui n'est pas toujours le résultat souhaité : ::"

#: ../Doc/library/stdtypes.rst:1997 ../Doc/library/stdtypes.rst:3095
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Une solution pour contourner le problème des apostrophes peut être obtenue "
"en utilisant des expressions rationnelles : ::"

#: ../Doc/library/stdtypes.rst:2012
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or :term:"
"`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"Renvoie une copie de la chaîne dans laquelle chaque caractère a été changé "
"selon la table de traduction donnée. La table doit être un objet qui "
"implémente l'indexation via :meth:`__getitem__`, typiquement un :term:"
"`mapping` ou une :term:`sequence`. Pour un ordinal Unicode (un entier), la "
"table peut donner soit un ordinal Unicode ou une chaîne pour faire "
"correspondre un ou plusieurs caractère au caractère donné, soit ``None`` "
"pour supprimer le caractère de la chaîne de renvoyée soit lever une "
"exception :exc:`LookupError` pour ne pas changer le caractère."

#: ../Doc/library/stdtypes.rst:2021
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"Vous pouvez utiliser :meth:`str.maketrans` pour créer une table de "
"correspondances de caractères dans différentsformats."

#: ../Doc/library/stdtypes.rst:2024
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Voir aussi le module :mod:`codecs` pour une approche plus souple de "
"changements de caractères par correspondance."

#: ../Doc/library/stdtypes.rst:2030
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``str.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Renvoie une copie de la chaîne dont tous les caractères capitalisables [4]_ "
"sontconvertis en capitales. Notez que ``str.upper().isupper()`` pourrait "
"être ``False`` si ``s`` contient des caractères non capitalisables ou si la "
"catégorieUnicode d'un caractère du résultant est pas \"Lu\" (Lettre, "
"majuscule), mais par exemple \"Lt\" (Lettre, titlecase)."

#: ../Doc/library/stdtypes.rst:2036
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"L'algorithme de capitalisation utilisé est décrit dans la section 3.13 de la "
"norme Unicode."

#: ../Doc/library/stdtypes.rst:2042
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Renvoie une copie de la chaîne remplie par la gauche du chiffre (le "
"caractère ASCII) ``'0'`` pour faire une chaîne de longueur *width*. Un "
"préfixe (``'+'`` / ``'-'``) est permis par l'insertion du caractère de "
"rembourrage *après* le caractère designe plutôt qu'avant. La chaîne "
"d'origine est renvoyée si *width* est inférieur ou égale à ``len(s)``."

#: ../Doc/library/stdtypes.rst:2060
msgid "``printf``-style String Formatting"
msgstr "Formattage de chaines à la ``printf``"

#: ../Doc/library/stdtypes.rst:2074
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>` or the :meth:`str.format` interface helps avoid these errors.  "
"These alternatives also provide more powerful, flexible and extensible "
"approaches to formatting text."
msgstr ""
"Ces opérations de mise en forme contiennent des bizarreries menant à de "
"nombreuses erreurs classiques (tel que ne pas réussir à afficher des "
"*tuples* ou des dictionnaires correctement).  Utiliser les :ref:`formatted "
"string literals <f-strings>` ou la méthode :meth:`str.format` aide à éviter "
"ces erreurs.  Ces alternatives offrent aussi une approche plus puissante, "
"flexible, et extensible de la mise en forme."

#: ../Doc/library/stdtypes.rst:2081
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"Les objets *str* n'exposent qu'une opération : L'opérateur ``%`` (modulo). "
"Aussi connu sous le nom d'opérateur de *formatting* ouopérateur "
"d'*interpolation*. Étant donné ``format % values`` (où *format* est une "
"chaîne),  les marqueurs ``%`` de *format* sont remplacés par zéro ou "
"plusieurs éléments de *values*. L'effet est similaire à la fonction :c:func:"
"`sprintf` du langage C."

#: ../Doc/library/stdtypes.rst:2087
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Si *format* ne nécessite qu'un seul argument, *values* peut être un objet "
"unique. [5]_ Si *values* est un tuple, il doit contenir exactement le nombre "
"d'éléments spécifiés par la chaîne de format, ou un seul objet de "
"correspondances ( *mapping object*, par exemple, un dictionnaire)."

#: ../Doc/library/stdtypes.rst:2092 ../Doc/library/stdtypes.rst:3194
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Un indicateur de conversion contient deux ou plusieurs caractères et "
"comporte les éléments suivants, qui doivent apparaître dans cet ordre :"

#: ../Doc/library/stdtypes.rst:2095 ../Doc/library/stdtypes.rst:3197
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Le caractère ``'%'``, qui marque le début du marqueur."

#: ../Doc/library/stdtypes.rst:2097 ../Doc/library/stdtypes.rst:3199
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"La clé de correspondance (facultative), composée d'une suite de caractères "
"entre parenthèse (par exemple, ``(somename)``)."

#: ../Doc/library/stdtypes.rst:2100 ../Doc/library/stdtypes.rst:3202
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Des options de conversion, facultatives, qui affectent le résultat de "
"certains types de conversion."

#: ../Doc/library/stdtypes.rst:2103 ../Doc/library/stdtypes.rst:3205
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Largeur minimum (facultative). Si elle vaut ``'*'`` (astérisque), la largeur "
"est lue de l'élément suivant du tuple *values*, et l'objet à convertir vient "
"après la largeur de champ minimale et la précision facultative."

#: ../Doc/library/stdtypes.rst:2107 ../Doc/library/stdtypes.rst:3209
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Précision (facultatif), donnée sous la forme d'un '``'.'`` (point) suivi de "
"la précision. Si la précision est ``'*'`` (un astérisque), la précision est "
"lue à partir de l'élément suivant du tuple *values* et la valeur à convertir "
"vient ensuite."

#: ../Doc/library/stdtypes.rst:2112 ../Doc/library/stdtypes.rst:3214
msgid "Length modifier (optional)."
msgstr "Modificateur de longueur (facultatif)."

#: ../Doc/library/stdtypes.rst:2114 ../Doc/library/stdtypes.rst:3216
msgid "Conversion type."
msgstr "Type de conversion."

#: ../Doc/library/stdtypes.rst:2116
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Lorsque l'argument de droite est un dictionnaire (ou un autre type de "
"*mapping*), les marqueurs dans la chaîne *doivent* inclure une clé présente "
"dans le dictionnaire, écrite entre parenthèses,  immédiatement après le "
"caractère ``'%'``. La clé indique quelle valeur du dictionnaire doit être "
"formatée. Par exemple :"

#: ../Doc/library/stdtypes.rst:2125 ../Doc/library/stdtypes.rst:3227
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"Dans ce cas, aucune ``*`` ne peuvent se trouver dans le format (car ces "
"``*`` nécessitent une liste (accès séquentiel) de paramètres)."

#: ../Doc/library/stdtypes.rst:2128 ../Doc/library/stdtypes.rst:3230
msgid "The conversion flag characters are:"
msgstr "Les caractères indicateurs de conversion sont :"

#: ../Doc/library/stdtypes.rst:2131 ../Doc/library/stdtypes.rst:3233
msgid "Flag"
msgstr "Option"

#: ../Doc/library/stdtypes.rst:2133 ../Doc/library/stdtypes.rst:3235
msgid "``'#'``"
msgstr "``'#'``"

#: ../Doc/library/stdtypes.rst:2133 ../Doc/library/stdtypes.rst:3235
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr "La conversion utilisera la \"forme alternative\" (définie ci-dessous)."

#: ../Doc/library/stdtypes.rst:2136 ../Doc/library/stdtypes.rst:3238
msgid "``'0'``"
msgstr "``'0'``"

#: ../Doc/library/stdtypes.rst:2136 ../Doc/library/stdtypes.rst:3238
msgid "The conversion will be zero padded for numeric values."
msgstr "Les valeurs numériques converties seront complétée de zéros."

#: ../Doc/library/stdtypes.rst:2138 ../Doc/library/stdtypes.rst:3240
msgid "``'-'``"
msgstr "``'-'``"

#: ../Doc/library/stdtypes.rst:2138 ../Doc/library/stdtypes.rst:3240
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"La valeur convertie est ajustée à gauche (remplace la conversion ``'0'`` si "
"les deux sont données)."

#: ../Doc/library/stdtypes.rst:2141 ../Doc/library/stdtypes.rst:3243
msgid "``' '``"
msgstr "``' '``"

#: ../Doc/library/stdtypes.rst:2141 ../Doc/library/stdtypes.rst:3243
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(un espace) Un espace doit être laissé avant un nombre positif (ou chaîne "
"vide) produite par la conversion d'une valeur signée."

#: ../Doc/library/stdtypes.rst:2144 ../Doc/library/stdtypes.rst:3246
msgid "``'+'``"
msgstr "``'+'``"

#: ../Doc/library/stdtypes.rst:2144 ../Doc/library/stdtypes.rst:3246
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Un caractère de signe (``'+'`` ou ``'-'``) précéde la valeur convertie "
"(remplace le marqueur \"espace\")."

#: ../Doc/library/stdtypes.rst:2148 ../Doc/library/stdtypes.rst:3250
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Un modificateur de longueur (``h``, ``l`` ou ``L``) peut être présent, mais "
"est ignoré car il est pas nécessaire pour Python - donc par exemple ``%ld`` "
"est identique à ``%d``."

#: ../Doc/library/stdtypes.rst:2151 ../Doc/library/stdtypes.rst:3253
msgid "The conversion types are:"
msgstr "Les types utilisables dans les conversion sont :"

#: ../Doc/library/stdtypes.rst:2154 ../Doc/library/stdtypes.rst:3256
msgid "Conversion"
msgstr "Conversion"

#: ../Doc/library/stdtypes.rst:2156 ../Doc/library/stdtypes.rst:3258
msgid "``'d'``"
msgstr "``'d'``"

#: ../Doc/library/stdtypes.rst:2156 ../Doc/library/stdtypes.rst:2158
#: ../Doc/library/stdtypes.rst:3258 ../Doc/library/stdtypes.rst:3260
msgid "Signed integer decimal."
msgstr "Entier décimal signé."

#: ../Doc/library/stdtypes.rst:2158 ../Doc/library/stdtypes.rst:3260
msgid "``'i'``"
msgstr "``'i'``"

#: ../Doc/library/stdtypes.rst:2160 ../Doc/library/stdtypes.rst:3262
msgid "``'o'``"
msgstr "``'o'``"

#: ../Doc/library/stdtypes.rst:2160 ../Doc/library/stdtypes.rst:3262
msgid "Signed octal value."
msgstr "Valeur octale signée."

#: ../Doc/library/stdtypes.rst:2162 ../Doc/library/stdtypes.rst:3264
msgid "``'u'``"
msgstr "``'u'``"

#: ../Doc/library/stdtypes.rst:2162 ../Doc/library/stdtypes.rst:3264
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Type obsolète - identique à ``'d'``."

#: ../Doc/library/stdtypes.rst:2164 ../Doc/library/stdtypes.rst:3266
msgid "``'x'``"
msgstr "``'x'``"

#: ../Doc/library/stdtypes.rst:2164 ../Doc/library/stdtypes.rst:3266
msgid "Signed hexadecimal (lowercase)."
msgstr "Hexadécimal signé (en minuscules)."

#: ../Doc/library/stdtypes.rst:2166 ../Doc/library/stdtypes.rst:3268
msgid "``'X'``"
msgstr "``'X'``"

#: ../Doc/library/stdtypes.rst:2166 ../Doc/library/stdtypes.rst:3268
msgid "Signed hexadecimal (uppercase)."
msgstr "Hexadécimal signé (capitales)."

#: ../Doc/library/stdtypes.rst:2168 ../Doc/library/stdtypes.rst:3270
msgid "``'e'``"
msgstr "``'e'``"

#: ../Doc/library/stdtypes.rst:2168 ../Doc/library/stdtypes.rst:3270
msgid "Floating point exponential format (lowercase)."
msgstr "Format exponentiel pour un *float* (minuscule)."

#: ../Doc/library/stdtypes.rst:2170 ../Doc/library/stdtypes.rst:3272
msgid "``'E'``"
msgstr "``'E'``"

#: ../Doc/library/stdtypes.rst:2170 ../Doc/library/stdtypes.rst:3272
msgid "Floating point exponential format (uppercase)."
msgstr "Format exponentiel pour un *float* (en capitales)."

#: ../Doc/library/stdtypes.rst:2172 ../Doc/library/stdtypes.rst:3274
msgid "``'f'``"
msgstr "``'f'``"

#: ../Doc/library/stdtypes.rst:2172 ../Doc/library/stdtypes.rst:2174
#: ../Doc/library/stdtypes.rst:3274 ../Doc/library/stdtypes.rst:3276
msgid "Floating point decimal format."
msgstr "Format décimal pour un *float*."

#: ../Doc/library/stdtypes.rst:2174 ../Doc/library/stdtypes.rst:3276
msgid "``'F'``"
msgstr "``'F'``"

#: ../Doc/library/stdtypes.rst:2176 ../Doc/library/stdtypes.rst:3278
msgid "``'g'``"
msgstr "``'g'``"

#: ../Doc/library/stdtypes.rst:2176 ../Doc/library/stdtypes.rst:3278
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Format *float*. Utilise le format exponentiel minuscules si l'exposant est "
"inférieur à -4 ou pas plus petit que la précision, sinon le format décimal."

#: ../Doc/library/stdtypes.rst:2180 ../Doc/library/stdtypes.rst:3282
msgid "``'G'``"
msgstr "``'G'``"

#: ../Doc/library/stdtypes.rst:2180 ../Doc/library/stdtypes.rst:3282
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Format *float*. Utilise le format exponentiel en capitales si l'exposant est "
"inférieur à -4 ou pas plus petit que la précision, sinon le format décimal."

#: ../Doc/library/stdtypes.rst:2184 ../Doc/library/stdtypes.rst:3286
msgid "``'c'``"
msgstr "``'c'``"

#: ../Doc/library/stdtypes.rst:2184
msgid "Single character (accepts integer or single character string)."
msgstr ""
"Un seul caractère (accepte des entiers ou une chaîne d'un seul caractère)."

#: ../Doc/library/stdtypes.rst:2187 ../Doc/library/stdtypes.rst:3299
msgid "``'r'``"
msgstr "``'r'``"

#: ../Doc/library/stdtypes.rst:2187
msgid "String (converts any Python object using :func:`repr`)."
msgstr "String (convertit n'importe quel objet Python avec :func:`repr`)."

#: ../Doc/library/stdtypes.rst:2190 ../Doc/library/stdtypes.rst:3293
msgid "``'s'``"
msgstr "``'s'``"

#: ../Doc/library/stdtypes.rst:2190
msgid "String (converts any Python object using :func:`str`)."
msgstr "String (convertit n'importe quel objet Python avec :func:`str`)."

#: ../Doc/library/stdtypes.rst:2193 ../Doc/library/stdtypes.rst:3296
msgid "``'a'``"
msgstr "``'a'``"

#: ../Doc/library/stdtypes.rst:2193
msgid "String (converts any Python object using :func:`ascii`)."
msgstr ""
"String (convertit n'importe quel objet Python en utilisant :func:`ascii`)."

#: ../Doc/library/stdtypes.rst:2196 ../Doc/library/stdtypes.rst:3302
msgid "``'%'``"
msgstr "``'%'``"

#: ../Doc/library/stdtypes.rst:2196 ../Doc/library/stdtypes.rst:3302
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Aucun argument n'est converti, donne un caractère de ``'%'`` dans le "
"résultat."

#: ../Doc/library/stdtypes.rst:2203 ../Doc/library/stdtypes.rst:3309
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"La forme alternative entraîne l'insertion d'un préfix octal (``'0o'``) avant "
"le premier chiffre."

#: ../Doc/library/stdtypes.rst:2207 ../Doc/library/stdtypes.rst:3313
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"La forme alternative entraîne l'insertion d'un préfixe ``'0x'`` ou ``'0X'`` "
"(respectivement pour les formats ``'x'`` et ``'X'``) avant le premier "
"chiffre."

#: ../Doc/library/stdtypes.rst:2211 ../Doc/library/stdtypes.rst:3317
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"La forme alternative implique la présence d'un point décimal, même si aucun "
"chiffre ne le suit."

#: ../Doc/library/stdtypes.rst:2214 ../Doc/library/stdtypes.rst:3320
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"La précision détermine le nombre de chiffres après la virgule, 6 par défaut."

#: ../Doc/library/stdtypes.rst:2218 ../Doc/library/stdtypes.rst:3324
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"La forme alternative implique la présence d'un point décimal et les zéros "
"non significatifs sont conservés (ils ne le seraient pas autrement)."

#: ../Doc/library/stdtypes.rst:2221 ../Doc/library/stdtypes.rst:3327
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"La précision détermine le nombre de chiffres significatifs avant et après la "
"virgule. 6 par défaut."

#: ../Doc/library/stdtypes.rst:2225 ../Doc/library/stdtypes.rst:3331
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Si la précision est ``N``, la sortie est tronquée à ``N`` caractères."

#: ../Doc/library/stdtypes.rst:2228 ../Doc/library/stdtypes.rst:3340
msgid "See :pep:`237`."
msgstr "Voir la :pep:`237`."

#: ../Doc/library/stdtypes.rst:2230
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Puisque les chaînes Python ont une longueur explicite, les conversions ``"
"%s`` ne considèrent pas ``'\\0'`` comme la fin de la chaîne."

#: ../Doc/library/stdtypes.rst:2235
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"Les conversions ``%f`` pour nombres dont la valeur absolue est supérieure à "
"1e50 ne sont plus remplacés par des conversions ``%g``."

#: ../Doc/library/stdtypes.rst:2246
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Séquences Binaires --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"

#: ../Doc/library/stdtypes.rst:2254
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"Les principaux types natifs pour manipuler des données binaires sont :class:"
"`bytes` et :class:`bytearray`. Ils sont supportés par :class:`memoryview` "
"qui utilise le :ref:`buffer protocol <bufferobjects>` pour accéder à la "
"mémoire d'autres objets binaires sans avoir besoin d'en faire une copie."

#: ../Doc/library/stdtypes.rst:2259
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"Le module :mod:`array` permet le stockage efficace de types basiques comme "
"les entiers de 32 bits et les *float* double precision IEEE754."

#: ../Doc/library/stdtypes.rst:2265
msgid "Bytes Objects"
msgstr "Objets *Bytes*"

#: ../Doc/library/stdtypes.rst:2269
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Les *Bytes* sont des séquences immuables d'octets. Comme beaucoup de "
"protocoles binaires utilisent l'ASCII, les objets *Bytes* offrent plusieurs "
"méthodes qui ne sont valables que lors de la manipulation de données ASCII "
"et sont étroitement liés aux objets *str* dans moulte autres aspects."

#: ../Doc/library/stdtypes.rst:2276
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"Tout d'abord, la syntaxe des *bytes* littéraux est en grande partie la même "
"que pour les chaînes littérales, en dehors du préfixe ``b`` :"

#: ../Doc/library/stdtypes.rst:2279
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr ""
"Les guillemets simples : ``b'autorisent aussi les guillemets \"doubles\"'``"

#: ../Doc/library/stdtypes.rst:2280
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``."
msgstr ""
"Les guillemets doubles : ``b\"permettent aussi les guillemets 'simples'\"``."

#: ../Doc/library/stdtypes.rst:2281
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Les guillemets triples : ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes"
"\"\"\"``"

#: ../Doc/library/stdtypes.rst:2283
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"Seuls les caractères ASCII sont autorisés dans les littéraux de *bytes* "
"(quel que soit l'encodage du code source déclaré). Toutes les valeurs au "
"delà de 127 doivent être entrés dans littéraux de *bytes* en utilisant une "
"séquence d'échappement appropriée."

#: ../Doc/library/stdtypes.rst:2287
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Comme avec les chaînes littérales, les *bytes* littéraux peuvent également "
"utiliser un préfixe ``r`` pour désactiver le traitement des séquences "
"d'échappement. Voir :ref:`strings` pour plus d'informations sur les "
"différentes formes littérales de *bytes*, y compris les séquences "
"d'échappement supportées."

#: ../Doc/library/stdtypes.rst:2291
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`. This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"Bien que les *bytes* littéraux, et leurs représentation, soient basés sur du "
"texte ASCII, les *bytes* se comportent en fait comme des séquences immuables "
"de nombres entiers, dont les valeurs sont restreintes dans ``0 <= x < 256`` "
"(ne pas respecter cette restriction lève une :exc:`ValueError`. Ceci est "
"fait délibérément afin de souligner que, bien que de nombreux encodages "
"binaires soient compatibles avec l'ASCII, et peuvent être manipulés avec des "
"algorithmes orientés texte, ce n'est généralement pas le cas pour les "
"données binaires arbitraires (appliquer aveuglément des algorithmes de texte "
"sur des données binaires qui ne sont pas compatibles ASCII conduit "
"généralement à leur corruption)."

#: ../Doc/library/stdtypes.rst:2301
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"En plus des formes littérales, des objets *bytes* peuvent être créés par de "
"nombreux moyens :"

#: ../Doc/library/stdtypes.rst:2304
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr ""
"Un objet *bytes* rempli de zéros d'une longueur spécifiée : ``bytes(10)``"

#: ../Doc/library/stdtypes.rst:2305
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "D'un itérable d'entiers : ``bytes(range(20))``"

#: ../Doc/library/stdtypes.rst:2306
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Copier des données binaires existantes via le *buffer protocol* : "
"``bytes(obj)``"

#: ../Doc/library/stdtypes.rst:2308
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Voir aussi la fonction native :ref:`bytes <func-bytes>`."

#: ../Doc/library/stdtypes.rst:2310
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Puisque 2 chiffres hexadécimaux correspondent précisément à un seul octet, "
"les nombres hexadécimaux sont un format couramment utilisé pour décrire les "
"données binaires. Par conséquent, le type *bytes* a une méthode de classe "
"pour lire des données dans ce format :"

#: ../Doc/library/stdtypes.rst:2316
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Cette méthode de la classe :class:`bytes` renvoie un objet *bytes*, décodant "
"la chaîne donnée.  La chaîne doit contenir deux chiffres hexadécimaux par "
"octet, les espaces ASCII sont ignorés."

#: ../Doc/library/stdtypes.rst:2323
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Une fonction de conversion inverse existe pour transformer un objet *bytes* "
"en sa représentation hexadécimale."

#: ../Doc/library/stdtypes.rst:2328 ../Doc/library/stdtypes.rst:2400
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Renvoie une chaîne contenant deux chiffres hexadécimaux pour chaque octet du "
"*byte*."

#: ../Doc/library/stdtypes.rst:2336
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Comme les objets *bytes* sont des séquences d'entiers (semblables à un "
"tuple), pour une instance de *bytes* *b*, ``b[0]`` sera un entier, tandis "
"que``b[0:1]`` sera un objet *bytes* de longueur 1. (Cela contraste avec les "
"chaînes, où l'indexation et le *slicing* donne une chaîne de longueur 1)"

#: ../Doc/library/stdtypes.rst:2341
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"La représentation des *bytes* utilise le format littéral (``b'...'``) car il "
"est souvent plus utile que par exemple ``bytes([46, 46, 46])``. Vous pouvez "
"toujours convertir un *bytes* en liste d'entiers en utilisant ``list(b)``."

#: ../Doc/library/stdtypes.rst:2346
msgid ""
"For Python 2.x users: In the Python 2.x series, a variety of implicit "
"conversions between 8-bit strings (the closest thing 2.x offers to a built-"
"in binary data type) and Unicode strings were permitted. This was a "
"backwards compatibility workaround to account for the fact that Python "
"originally only supported 8-bit text, and Unicode text was a later addition. "
"In Python 3.x, those implicit conversions are gone - conversions between 8-"
"bit binary data and Unicode text must be explicit, and bytes and string "
"objects will always compare unequal."
msgstr ""
"Pour les utilisateurs de Python 2.x : Dans la série 2.x de Python, une "
"variété de conversions implicites entre les chaînes 8-bit (la chose la plus "
"proche d'un type natif de données binaires offert par Python 2)  et des "
"chaînes Unicode étaient permises. C'était solution de  contournement, pour "
"garder la rétro-compatibilité, par rapport au fait que Python ne prenait "
"initialement en charge que le texte 8 bits, le texte Unicode est un ajout "
"ultérieur. En Python 3.x, ces conversions implicites ont disparues - les "
"conversions entre les données binaires et texte Unicode doivent être "
"explicites, et les *bytes* sont toujours différents des chaînes."

#: ../Doc/library/stdtypes.rst:2359
msgid "Bytearray Objects"
msgstr "Objets *bytearray*"

#: ../Doc/library/stdtypes.rst:2363
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
"Les objets :class:`bytearray` sont l'équivalent mutable des objets :class:"
"`bytes`."

#: ../Doc/library/stdtypes.rst:2368
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Il n'y a pas de syntaxe littérale dédiée aux *bytearray*, ils sont toujours "
"créés en appelant le constructeur :"

#: ../Doc/library/stdtypes.rst:2371
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Créer une instance vide: ``bytearray()``"

#: ../Doc/library/stdtypes.rst:2372
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""
"Créer une instance remplie de zéros d'une longueur donnée : ``bytearray(10)``"

#: ../Doc/library/stdtypes.rst:2373
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "À partir d'un itérable d'entiers : ``bytearray(range(20))``"

#: ../Doc/library/stdtypes.rst:2374
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Copie des données binaires existantes via le *buffer protocol* : "
"``bytearray(b'Hi!')``"

#: ../Doc/library/stdtypes.rst:2376
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Comme les *bytearray* sont mutables, ils prennent en charge les opérations "
"de séquence :ref:`mutables <typesseq-mutable>` en plus des opérations "
"communes de *bytes* et *bytearray* décrites dans :ref:`bytes-methods`."

#: ../Doc/library/stdtypes.rst:2380
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "Voir aussi la fonction native :ref:`bytearray <func-bytearray>`."

#: ../Doc/library/stdtypes.rst:2382
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Puisque 2 chiffres hexadécimaux correspondent précisément à un octet, les "
"nombres hexadécimaux sont un format couramment utilisé pour décrire les "
"données binaires. Par conséquent, le type *bytearray* a une méthode de "
"classe pour lire les données dans ce format :"

#: ../Doc/library/stdtypes.rst:2388
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Cette méthode de la classe :class:`bytearray` renvoie un objet *bytearray*, "
"décodant la chaîne donnée.  La chaîne doit contenir deux chiffres "
"hexadécimaux par octet, les espaces ASCII sont ignorés."

#: ../Doc/library/stdtypes.rst:2395
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"Une fonction de conversion inverse existe pour transformer un objet "
"*bytearray* en sa représentation hexadécimale."

#: ../Doc/library/stdtypes.rst:2408
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Comme les *bytearray* sont des séquences d'entiers (semblables à une liste), "
"pour un objet *bytearray* *b*, ``b[0]`` sera un entier, tandis que "
"``b[0:1]`` sera un objet *bytearray* de longueur 1. (Ceci contraste avec les "
"chaînes de texte, où l'indexation et le *slicing* produit une chaîne de "
"longueur 1)"

#: ../Doc/library/stdtypes.rst:2413
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"La représentation des objets *bytearray* utilise le format littéral des "
"*bytes* (``bytearray(b'...')``) car il est souvent plus utile que par "
"exemple ``bytearray([46, 46, 46])``. Vous pouvez toujours convertir un objet "
"*bytearray* en une liste de nombres entiers en utilisant ``list(b)``."

#: ../Doc/library/stdtypes.rst:2422
msgid "Bytes and Bytearray Operations"
msgstr "Opérations sur les *bytes* et *bytearray*"

#: ../Doc/library/stdtypes.rst:2427
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"*bytes* et *bytearray* prennent en charge les opérations :ref:`communes "
"<typesseq-common>` des séquences. Ils interagissent non seulement avec des "
"opérandes de même type, mais aussi avec les :term:`bytes-like object`. En "
"raison de cette flexibilité, ils peuvent être mélangés librement dans  des "
"opérations sans provoquer d'erreurs. Cependant, le type du résultat peut "
"dépendre de l'ordre des opérandes."

#: ../Doc/library/stdtypes.rst:2435
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"Les méthodes sur les *bytes* et les *bytearray* n'acceptent pas les chaînes "
"comme arguments, tout comme les méthodes sur les chaînes n'acceptent pas les "
"*bytes* comme arguments. Par exemple, vous devez écrire ::"

#: ../Doc/library/stdtypes.rst:2442
msgid "and::"
msgstr "et  : ::"

#: ../Doc/library/stdtypes.rst:2447
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Quelques opérations de *bytes* et *bytesarray* supposent l'utilisation de "
"formats binaires compatibles ASCII, et donc doivent être évités lorsque vous "
"travaillez avec des données binaires arbitraires. Ces restrictions sont "
"couvertes ci-dessous."

#: ../Doc/library/stdtypes.rst:2452
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"Utiliser ces opérations basées sur l'ASCII pour manipuler des données "
"binaires qui ne sont pas au format ASCII peut les corrompre."

#: ../Doc/library/stdtypes.rst:2455
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"Les méthodes suivantes sur les *bytes* et *bytearray* peuvent être utilisées "
"avec des données binaires arbitraires."

#: ../Doc/library/stdtypes.rst:2461
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Renvoie le nombre d'occurrences qui ne se chevauchent pas de la  sous-"
"séquence *sub* dans l'intervalle [*start*, *end*]. Les arguments facultatifs "
"*start* et *end* sont interprétés comme pour un *slice*."

#: ../Doc/library/stdtypes.rst:2465 ../Doc/library/stdtypes.rst:2512
#: ../Doc/library/stdtypes.rst:2534 ../Doc/library/stdtypes.rst:2599
#: ../Doc/library/stdtypes.rst:2612
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"La sous-séquence à rechercher peut être un quelconque :term:`bytes-like "
"object` ou un nombre entier compris entre 0 et 255."

#: ../Doc/library/stdtypes.rst:2468 ../Doc/library/stdtypes.rst:2524
#: ../Doc/library/stdtypes.rst:2537 ../Doc/library/stdtypes.rst:2602
#: ../Doc/library/stdtypes.rst:2615
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""
"Accepte aussi un nombre entier compris entre 0 et 255 comme sous-séquence."

#: ../Doc/library/stdtypes.rst:2475
msgid ""
"Return a string decoded from the given bytes.  Default encoding is "
"``'utf-8'``. *errors* may be given to set a different error handling "
"scheme.  The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`.  Other possible values are ``'ignore'``, "
"``'replace'`` and any other name registered via :func:`codecs."
"register_error`, see section :ref:`error-handlers`. For a list of possible "
"encodings, see section :ref:`standard-encodings`."
msgstr ""
"Décode les octets donnés, et le renvoie sous forme d'une chaîne de "
"caractères. L'encodage par défaut est ``'utf-8'``. *errors* peut être donné "
"pour changer de système de gestion des erreurs. Sa valeur par défaut est "
"``'strict'``, ce qui signifie que les erreurs d'encodage lèvent une :exc:"
"`UnicodeError`. Les autres valeurs possibles sont ``'ignore'``, "
"``'replace'`` et tout autre nom enregistré via :func:`codecs."
"register_error`, voir la section :ref:`error-handlers`. Pour une liste des "
"encodages possibles, voir la section :ref:`standard-encodings`."

#: ../Doc/library/stdtypes.rst:2485
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary bytes or "
"bytearray object."
msgstr ""
"Passer l'argument *encoding* à :class:`str` permet de décoder tout :term:"
"`bytes-like object` directement, sans avoir besoin d'utiliser un *bytes* ou "
"*bytearray* temporaire."

#: ../Doc/library/stdtypes.rst:2489
msgid "Added support for keyword arguments."
msgstr "Gère les arguments nommés."

#: ../Doc/library/stdtypes.rst:2496
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Donne ``True`` si les octets se terminent par *suffix*, sinon ``False``. "
"*suffix* peut aussi être un tuple de suffixes à rechercher. Avec l'argument "
"optionnel *start*, la recherche se fait à partir de cette position. Avec "
"l'argument optionnel *end*, la comparaison s'arrête à cette position."

#: ../Doc/library/stdtypes.rst:2501
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Les suffixes à rechercher peuvent être n'importe quel :term:`bytes-like "
"object`."

#: ../Doc/library/stdtypes.rst:2507
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Donne la première position où le *sub* se trouve dans les données,  de telle "
"sorte que *sub* soit contenue dans ``s[start:end]``. Les arguments "
"facultatifs *start* et *end* sont interprétés comme dans la notation des "
"*slices*. Donne ``-1`` si *sub* n'est pas trouvé."

#: ../Doc/library/stdtypes.rst:2517
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"La méthode :meth:`~bytes.find` ne doit être utilisée que si vous avez besoin "
"de connaître la position de *sub*. Pour vérifier si *sub* est présent ou "
"non, utilisez l'opérateur :keyword:`in` ::"

#: ../Doc/library/stdtypes.rst:2531
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Comme :meth:`~bytes.find`, mais lève une :exc:`ValueError` lorsque la "
"séquence est introuvable."

#: ../Doc/library/stdtypes.rst:2544
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Donne un *bytes* ou *bytearray* qui est la concaténation des séquences de "
"données binaires dans *iterable*.  Une exception :exc:`TypeError` est levée "
"si une valeur d'*iterable* n'est pas un :term:`bytes-like objects <bytes-"
"like object>`, y compris pour des :class:`str`.  Le séparateur entre les "
"éléments est le contenu du *bytes* ou du *bytearray* depuis lequel cette "
"méthode est appelée."

#: ../Doc/library/stdtypes.rst:2555
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Cette méthode statique renvoie une table de traduction utilisable par :meth:"
"`bytes.translate` qui permettra de changer chaque caractère de *from* par un "
"caractère à la même position dans *to*; *from* et *to* doivent tous deux "
"être des :term:`bytes-like objects <bytes-like object>` et avoir la même "
"longueur."

#: ../Doc/library/stdtypes.rst:2566
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator, and the part after "
"the separator.  If the separator is not found, return a 3-tuple containing a "
"copy of the original sequence, followed by two empty bytes or bytearray "
"objects."
msgstr ""
"Divise la séquence à la première occurrence de *sep*, et renvoie un 3-tuple "
"contenant la partie précédant le séparateur, le séparateur, et la partie "
"suivant le séparateur. Si le séparateur est pas trouvé, le 3-tuple renvoyé "
"contiendra une copie de la séquence d'origine, suivi de deux *bytes* ou "
"*bytearray* vides."

#: ../Doc/library/stdtypes.rst:2572 ../Doc/library/stdtypes.rst:2628
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr "Le séparateur à rechercher peut être tout :term:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2578
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Renvoie une copie de la séquence dont toutes les occurrences de la sous-"
"séquence *old* sont remplacées par *new*. Si l'argument optionnel *count* "
"est donné, seules les *count* premières occurrences de sont remplacés."

#: ../Doc/library/stdtypes.rst:2582
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"La sous-séquence à rechercher et son remplacement peuvent être  n'importe "
"quel :term:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2587 ../Doc/library/stdtypes.rst:2679
#: ../Doc/library/stdtypes.rst:2693 ../Doc/library/stdtypes.rst:2717
#: ../Doc/library/stdtypes.rst:2731 ../Doc/library/stdtypes.rst:2766
#: ../Doc/library/stdtypes.rst:2836 ../Doc/library/stdtypes.rst:2854
#: ../Doc/library/stdtypes.rst:2882 ../Doc/library/stdtypes.rst:3011
#: ../Doc/library/stdtypes.rst:3066 ../Doc/library/stdtypes.rst:3109
#: ../Doc/library/stdtypes.rst:3130 ../Doc/library/stdtypes.rst:3152
#: ../Doc/library/stdtypes.rst:3344
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"La version *bytearray* de cette méthode *ne modifie pas* les octets,  elle "
"produit toujours un nouvel objet, même si aucune modification n'a été "
"effectuée."

#: ../Doc/library/stdtypes.rst:2594
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Donne la plus grande position de *sub* dans la séquence, de telle sorte que "
"*sub* soit dans ``s[start:end]``. Les arguments facultatifs *start* et *end* "
"sont interprétés comme dans lanotation des *slices*. Donne ``-1`` si *sub* "
"n'est pas trouvable."

#: ../Doc/library/stdtypes.rst:2609
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Semblable à :meth:`~bytes.rfind` mais lève une :exc:`ValueError` lorsque "
"*sub* est introuvable."

#: ../Doc/library/stdtypes.rst:2622
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator, and the part after "
"the separator.  If the separator is not found, return a 3-tuple containing a "
"copy of the original sequence, followed by two empty bytes or bytearray "
"objects."
msgstr ""
"Coupe la séquence à la dernière occurrence de *sep*, et renvoie un tuple de "
"trois elements contenant la partie précédent le séparateur, le séparateur, "
"et la partie suivant le séparateur. Si le séparateur n'est pas trouvé, le "
"tuple contiendra une copie de la séquence d'origine, suivi de deux *bytes* "
"ou *bytesarray* vides."

#: ../Doc/library/stdtypes.rst:2634
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Donne ``True`` si les données binaires commencent par le *prefix* spécifié, "
"sinon ``False``. *prefix* peut aussi être un tuple de préfixes à rechercher. "
"Avec l'argument *start* la recherche commence à cette position. Avec "
"l'argument *end* option, la recherche s'arrête à cette position."

#: ../Doc/library/stdtypes.rst:2639
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Le préfixe(s) à rechercher peuvent être n'importe quel :term:`bytes-like "
"object`."

#: ../Doc/library/stdtypes.rst:2645
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Renvoie une copie du *bytes* ou *bytearray* dont tous les octets de  "
"*delete* sont supprimés, et les octets restants changés par la table de "
"correspondance donnée, qui doit être un objet *bytes* d'une longueur de 256."

#: ../Doc/library/stdtypes.rst:2650
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Vous pouvez utiliser la méthode :func:`bytes.maketrans` pour créer une table "
"de correspondance."

#: ../Doc/library/stdtypes.rst:2653
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Donnez ``None`` comme *table* pour seulement supprimer des caractères : ::"

#: ../Doc/library/stdtypes.rst:2659
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* est maintenant accepté comme argument nommé"

#: ../Doc/library/stdtypes.rst:2663
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"Les méthodes suivantes sur les *bytes* et *bytearray* supposent  par défaut "
"que les données traitées sont compatible ASCII, mais  peuvent toujours être "
"utilisées avec des données binaires, arbitraires, en passant des arguments "
"appropriés.  Notez que toutes les méthodes de *bytearray* de cette section "
"ne travaillent jamais sur l'objet lui même, mais renvoient un nouvel objet."

#: ../Doc/library/stdtypes.rst:2672
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Renvoie une copie de l'objet centrée dans une séquence de longueur *width*. "
"Le remplissage est fait en utilisant *fillbyte* (qui par défaut est un "
"espace ASCII). Pour les objets :class:`bytes`, la séquence initiale est "
"renvoyée si *width* est inférieur ou égal à ``len(s)``."

#: ../Doc/library/stdtypes.rst:2686
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Renvoie une copie de l'objet aligné à gauche dans une séquence de longueur "
"*width*. Le remplissage est fait en utilisant *fillbyte* (par défaut un "
"espace ASCII). Pour les objets :class:`bytes`, la séquence initiale est "
"renvoyée si *width* est inférieure ou égale à ``len(s)``."

#: ../Doc/library/stdtypes.rst:2700
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Renvoie une copie de la séquence dont certains préfixes ont été supprimés. "
"L’argument *chars* est une séquence binaire spécifiant le jeu d'octets à "
"supprimer. Ce nom se réfère au fait de cette méthode est généralement "
"utilisée avec des caractères ASCII. En cas d’omission ou ``None``, la valeur "
"par défaut de *chars* permet de supprimer des espaces ASCII. L’argument "
"*chars* n’est pas un préfixe, toutes les combinaisons de ses valeurs sont "
"supprimées ::"

#: ../Doc/library/stdtypes.rst:2712 ../Doc/library/stdtypes.rst:2761
#: ../Doc/library/stdtypes.rst:2831
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"La séquence de valeurs à supprimer peut être tout :term:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2724
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Renvoie une copie de l'objet justifié à droite dans une séquence de longueur "
"*width*. Le remplissage est fait en utilisant le caractère *fillbyte* (par "
"défaut est un espace ASCII). Pour les objets :class:`bytes`, la séquence "
"d'origine est renvoyée si *width* est inférieure ou égale à ``len(s)``."

#: ../Doc/library/stdtypes.rst:2738
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Divise la séquence d'octets en sous-séquences du même type, en utilisant "
"*sep* comme séparateur. Si *maxsplit* est donné, c'est le nombre maximum de "
"divisions qui pourront être faites, celles \"à droite\". Si *sep* est pas "
"spécifié ou est ``None``, toute sous-séquence composée uniquement d'espaces "
"ASCII est un séparateur. En dehors du fait qu'il découpe par la droite, :"
"meth:`rsplit` se comporte comme :meth:`split` qui est décrit en détail ci-"
"dessous."

#: ../Doc/library/stdtypes.rst:2749
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Renvoie une copie de la séquence dont des octets finaux sont supprimés. "
"L'argument *chars* est une séquence d'octets spécifiant le jeu de caractères "
"à supprimer - . En cas d'omission ou ``None``, les espaces ASCII sont "
"supprimés. L'argument *chars* n'est pas un suffixe : toutes les combinaisons "
"de ses valeurs sont retirées : ::"

#: ../Doc/library/stdtypes.rst:2773
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Divise la séquence en sous-séquences du même type, en utilisant *sep* comme "
"séparateur. Si *maxsplit* est donné, c'est le nombre maximum de divisions "
"qui pourront être faites (la liste aura donc au plus ``maxsplit+1`` "
"éléments), Si *maxsplit* n'est pas spécifié ou faut ``-1``, il n'y a aucune "
"limite au nombre de découpes (elles sont toutes effectuées)."

#: ../Doc/library/stdtypes.rst:2779
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""
"Si *sep* est donné, les délimiteurs consécutifs ne sont pas regroupés et "
"ainsi délimitent ainsi des chaînes vides (par exemple, ``b'1,,2'."
"split(b',')`` donne ``[b'1', b'', b'2']``). L'argument *sep* peut contenir "
"plusieurs sous séquences (par exemple, ``b'1<>2<>3'.split(b'<>')`` renvoie "
"``[b'1', b'2', b'3']``). Découper une chaîne vide en spécifiant *sep* donne "
"``[b'']`` ou ``[bytearray(b'')]`` en fonction du type de l'objet découpé. "
"L'argument *sep* peut être n'importe quel :term:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2797
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Si *sep* n'est pas spécifié ou est ``None``, un autre algorithme de découpe "
"est appliqué : les espaces ASCII consécutifs sont considérés comme un seul "
"séparateur, et le résultat ne contiendra pas les chaînes vides de début ou "
"de la fin si la chaîne est préfixée ou suffixé d'espaces. Par conséquent, "
"diviser une séquence vide ou une séquence composée d'espaces ASCII avec un "
"séparateur ``None`` renvoie ``[]``."

#: ../Doc/library/stdtypes.rst:2818
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Renvoie une copie de la séquence dont des caractères initiaux et finaux sont "
"supprimés. L'argument *chars* est une séquence spécifiant le jeu d'octets à "
"supprimer - le nom se réfère au fait de cette méthode est généralement "
"utilisée avec des caractères ASCII. En cas d'omission ou ``None``, les "
"espaces ASCII sont supprimés. L'argument *chars* n'est ni un préfixe ni un "
"suffixe, toutes les combinaisons de ses valeurs sont supprimées : ::"

#: ../Doc/library/stdtypes.rst:2840
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"Les méthodes suivantes sur les *bytes* et *bytearray* supposent "
"l'utilisation d'un format binaire compatible ASCII, et donc doivent être "
"évités lorsque vous travaillez avec des données binaires arbitraires. Notez "
"que toutes les méthodes de *bytearray* de cette section *ne modifient pas* "
"les octets, ils produisent de nouveaux objets."

#: ../Doc/library/stdtypes.rst:2848
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Renvoie une copie de la séquence dont chaque octet est interprété comme un "
"caractère ASCII, le premier octet en capitale et le reste en minuscules. Les "
"octets non-ASCII ne sont pas modifiés."

#: ../Doc/library/stdtypes.rst:2861
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Renvoie une copie de la séquence où toutes les tabulations ASCII sont "
"remplacées par un ou plusieurs espaces ASCII, en fonction de la colonne "
"courante et de la taille de tabulation donnée. Les positions des tabulations "
"se trouvent tous les *tabsize* caractères (8 par défaut, ce qui donne les "
"positions de tabulations aux colonnes 0, 8, 16 et ainsi de suite). Pour "
"travailler sur la séquence, la colonne en cours est mise à zéro et la "
"séquence est examinée octets par octets. Si l'octet est une tabulation ASCII "
"(``b'\t'``), un ou plusieurs espaces sont insérés au résultat jusqu’à ce que "
"la colonne courante soit égale à la position de tabulation suivante. (Le "
"caractère tabulation lui-même n’est pas copié.) Si l'octet courant est un "
"saut de ligne ASCII (``b'\n"
"'``) ou un retour chariot (``b'\\r'``), il est copié et la colonne en cours "
"est remise à zéro. Tout autre octet est copié inchangé et la colonne en "
"cours est incrémentée de un indépendamment de la façon dont l'octet est "
"représenté lors de l’affichage : ::"

#: ../Doc/library/stdtypes.rst:2889
msgid ""
"Return true if all bytes in the sequence are alphabetical ASCII characters "
"or ASCII decimal digits and the sequence is not empty, false otherwise. "
"Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Donne ``True`` si tous les caractères de la chaîne sont des caractères ASCII "
"alphabetiques ou chiffres. et que la séquence n'est pas vide, sinon "
"``False``. Les caractères ASCII alphabétiques sont les suivants "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` et les "
"chiffres : ``b'0123456789'``."

#: ../Doc/library/stdtypes.rst:2906
msgid ""
"Return true if all bytes in the sequence are alphabetic ASCII characters and "
"the sequence is not empty, false otherwise.  Alphabetic ASCII characters are "
"those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Donne ``True`` si tous les octets dans la séquence sont des caractères "
"alphabétiques ASCII et la que la séquence n'est pas vide, sinon ``False``. "
"Les caractères ASCIIalphabétiques sont : "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../Doc/library/stdtypes.rst:2922
msgid ""
"Return true if all bytes in the sequence are ASCII decimal digits and the "
"sequence is not empty, false otherwise. ASCII decimal digits are those byte "
"values in the sequence ``b'0123456789'``."
msgstr ""
"Donne ``True`` si tous les octets de la séquence sont des chiffres  ASCII et "
"que la séquence n'est pas vide, sinon ``False``. Les chiffres ASCII sont "
"``b'0123456789'``."

#: ../Doc/library/stdtypes.rst:2937
msgid ""
"Return true if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, false otherwise."
msgstr ""
"Donne ``True`` s'il y a au moins un caractère ASCII minuscule dans la "
"séquence et aucune capitale, sinon ``False``."

#: ../Doc/library/stdtypes.rst:2947 ../Doc/library/stdtypes.rst:2989
#: ../Doc/library/stdtypes.rst:3005 ../Doc/library/stdtypes.rst:3055
#: ../Doc/library/stdtypes.rst:3124
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Lea caractères ASCII minuscules sont  ``b'abcdefghijklmnopqrstuvwxyz'``. Les "
"capitales ASCII sont ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../Doc/library/stdtypes.rst:2955
msgid ""
"Return true if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, false otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Donne ``True`` si tous les octets de la séquence sont des espaces  ASCII et "
"que la séquence n'est pas vide, sinon ``False``. Les espèces ASCII sont ``b' "
"\\t\\n\\r\\x0b\\f'`` (espace, tabulation,saut de ligne, retour chariot, "
"tabulation verticale,  *form feed*)."

#: ../Doc/library/stdtypes.rst:2964
msgid ""
"Return true if the sequence is ASCII titlecase and the sequence is not "
"empty, false otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Donne ``True`` si la séquence ASCII est *titlecased*, et qu'elle ne soit pas "
"vide, sinon ``False``. Voir :meth:`bytes.title` pour plus de détails sur "
"ladéfinition de *titlecase*."

#: ../Doc/library/stdtypes.rst:2979
msgid ""
"Return true if there is at least one uppercase alphabetic ASCII character in "
"the sequence and no lowercase ASCII characters, false otherwise."
msgstr ""
"Donne ``True`` s'il y a au moins un caractère alphabétique majuscule  ASCII "
"dans la séquence et aucun caractères ASCII minuscules, sinon ``False``."

#: ../Doc/library/stdtypes.rst:2997
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Renvoie une copie de la séquence dont tous les caractères ASCII en "
"majuscules sont convertis en leur équivalent en minuscules."

#: ../Doc/library/stdtypes.rst:3022
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Renvoie une liste des lignes de la séquence d'octets, découpant au niveau "
"des fin de lignes ASCII. Cette méthode utilise l'approche :term:`universal "
"newlines` pour découper les lignes. Les fins de ligne ne sont pas inclus "
"dans la liste des résultats, sauf si *keepends* est donné et vrai."

#: ../Doc/library/stdtypes.rst:3034
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Contrairement à :meth:`~bytes.split` lorsque le délimiteur *sep* est fourni, "
"cette méthode renvoie une liste vide pour la chaîne vide, et un saut de "
"ligne à la fin ne se traduit pas par une ligne supplémentaire : ::"

#: ../Doc/library/stdtypes.rst:3047
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Renvoie une copie de la séquence dont tous les caractères ASCII minuscules "
"sont convertis en majuscules et vice-versa."

#: ../Doc/library/stdtypes.rst:3059
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"Contrairement à :func:`str.swapcase()`,  ``bin.swapcase().swapcase() == "
"bin`` est toujours vrai. Les conversions majuscule/minuscule en ASCII étant "
"toujours symétrique, ce qui n'est pas toujours vrai avec Unicode."

#: ../Doc/library/stdtypes.rst:3073
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Renvoie une version *titlecased* de la séquence d'octets où les mots "
"commencent par un caractère ASCII majuscule et les caractères restants sont "
"en minuscules. Les octets non capitalisables ne sont pas modifiés."

#: ../Doc/library/stdtypes.rst:3082
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"Les caractères ASCII minuscules sont ``b'abcdefghijklmnopqrstuvwxyz'``. Les "
"caractères ASCII majuscules sont ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Aucun "
"autre octet n'est capitalisable."

#: ../Doc/library/stdtypes.rst:3116
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Renvoie une copie de la séquence dont tous les caractères ASCII minuscules "
"sont convertis en leur équivalent majuscule."

#: ../Doc/library/stdtypes.rst:3137
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'`` is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Renvoie une copie de la séquence remplie par la gauche du chiffre ``b'0'`` "
"pour en faire une séquence de longueur *width*. Un préfixe (``b'+'`` / "
"``b'-'``) est permis par l'insertion du caractère de remplissage *après* le "
"caractère de signe plutôt qu'avant. Pour les objets :class:`bytes` la "
"séquence d'origine est renvoyée si *width* est inférieur ou égale à "
"``len(seq)``."

#: ../Doc/library/stdtypes.rst:3159
msgid "``printf``-style Bytes Formatting"
msgstr "Formatage de *bytes* a la ``printf``"

#: ../Doc/library/stdtypes.rst:3177
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"Les opérations de formatage décrites ici présentent une variété de "
"bizarreries qui conduisent à un certain nombre d’erreurs classiques "
"(typiquement, échouer à afficher des tuples ou des dictionnaires "
"correctement). Si la valeur à afficher peut être un tuple ou un "
"dictionnaire, mettez le a l'intérieur d'un autre tuple."

#: ../Doc/library/stdtypes.rst:3182
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Les objets *bytes* (``bytes`` et ``bytearray``) ont un unique opérateur : "
"l'opérateur ``%`` (modulo). Il est aussi connu sous le nom d'opérateur de "
"mise en forme. Avec ``format % values`` (où *format* est un objet *bytes*), "
"les marqueurs de conversion ``%`` dans *format* sont remplacés par zéro ou "
"plus de *values*. L'effet est similaire à la fonction :c:func:`sprintf` du "
"langage C."

#: ../Doc/library/stdtypes.rst:3189
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Si *format* ne nécessite qu'un seul argument, *values* peut être un objet "
"unique. [5]_ Si *values* est un tuple, il doit contenir exactement le nombre "
"d'éléments spécifiés dans le format en *bytes*, ou un seul objet de "
"correspondances ( *mapping object*, par exemple, un dictionnaire)."

#: ../Doc/library/stdtypes.rst:3218
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Lorsque l'argument de droite est un dictionnaire (ou un autre type de "
"*mapping*), les marqueurs dans le *bytes* *doivent* inclure une clé présente "
"dans le dictionnaire, écrite entre parenthèses,  immédiatement après le "
"caractère ``'%'``. La clé indique quelle valeur du dictionnaire doit être "
"formatée. Par exemple :"

#: ../Doc/library/stdtypes.rst:3286
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Octet simple (Accepte un nombre entier ou un seul objet *byte*)."

#: ../Doc/library/stdtypes.rst:3289
msgid "``'b'``"
msgstr "``'b'``"

#: ../Doc/library/stdtypes.rst:3289
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""
"*Bytes* (tout objet respectant le :ref:`buffer protocol <bufferobjects>` ou "
"ayant la méthode :meth:`__bytes__`)."

#: ../Doc/library/stdtypes.rst:3293
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'s'`` est un alias de ``'b'`` et ne devrait être utilisé que pour du code "
"Python2/3."

#: ../Doc/library/stdtypes.rst:3296
msgid ""
"Bytes (converts any Python object using ``repr(obj)."
"encode('ascii','backslashreplace)``)."
msgstr ""
"*Bytes* (convertis n'importe quel objet Python en utilisant ``repr(obj)."
"encode('ascii', 'backslashreplace)``)."

#: ../Doc/library/stdtypes.rst:3299
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'r'`` est un alias de ``'a'`` et ne devrait être utilise que dans du code "
"Python2/3."

#: ../Doc/library/stdtypes.rst:3299
msgid "\\(7)"
msgstr "\\(7)"

#: ../Doc/library/stdtypes.rst:3334
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` est déprécié, mais ne sera pas retiré des version 3.x."

#: ../Doc/library/stdtypes.rst:3337
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` est déprécié mais ne sera pas retiré dans Python 3.x."

#: ../Doc/library/stdtypes.rst:3347
msgid ":pep:`461`."
msgstr ":pep:`461`."

#: ../Doc/library/stdtypes.rst:3353
msgid "Memory Views"
msgstr "Memory Views"

#: ../Doc/library/stdtypes.rst:3355
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
"Les :class:`memoryview` permettent a du code Python d'accéder sans copie aux "
"données internes d'un objet pendant en charge le :ref:`buffer protocol "
"<bufferobjects>`."

#: ../Doc/library/stdtypes.rst:3361
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support the "
"buffer protocol.  Built-in objects that support the buffer protocol include :"
"class:`bytes` and :class:`bytearray`."
msgstr ""
"Crée une :class:`memoryview` faisant référence à *obj*. *obj* doit supporter "
"le *buffer protocol*. Les objets natifs pendant en charge le *buffer "
"protocol* sont :class:`bytes` et :class:`bytearray`."

#: ../Doc/library/stdtypes.rst:3365
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating object *obj*.  For many simple types "
"such as :class:`bytes` and :class:`bytearray`, an element is a single byte, "
"but other types such as :class:`array.array` may have bigger elements."
msgstr ""
"Une :class:`memoryview` a la notion d'*element*, qui est l'unité de  mémoire "
"atomique géré par l'objet *obj* d'origine. Pour de nombreux types simples "
"comme :class:`bytes` et :class:`bytearray`, l'élément est l'octet, mais pour "
"d'autres types tels que :class:`array.array` les éléments peuvent être plus "
"grands."

#: ../Doc/library/stdtypes.rst:3371
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view. "
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"``len(view)`` est égal à la grandeur de :class:`~memoryview.tolist`. Si "
"``view.ndim = 0``, la longueur vaut 1. Si ``view.ndim = 1``, la longueur est "
"égale au nombre d'éléments de la vue. Pour les dimensions plus grandes, la "
"longueur est égale à la longueur de la sous-liste représentée par la vue. "
"L'attribut :class:`~memoryview.itemsize` vous donnera la taille en octets "
"d'un élément."

#: ../Doc/library/stdtypes.rst:3378
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
"Une :class:`memoryview` autorise le découpage et l'indicage de ses données. "
"Découper sur une dimension donnera une sous-vue::"

#: ../Doc/library/stdtypes.rst:3391
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Si le :class:`~memoryview.format` est un des formats natif du module :mod:"
"`struct`, indexer avec un nombre entier ou un *tuple* de nombres entiers est "
"aussi autorisé et renvoie un seul *element* du bon type.  Les *memoryview* à "
"une dimension peuvent être indexées avec un nombre entier ou un *tuple* d'un "
"entier.  Les *memoryview* multi-dimensionnelles peuvent être indexées avec "
"des *tuples* d'exactement *ndim* entiers où *ndim* est le nombre de "
"dimensions.  Les *memoryviews* à zéro dimension peuvent être indexées avec "
"un *tuple* vide."

#: ../Doc/library/stdtypes.rst:3400
msgid "Here is an example with a non-byte format::"
msgstr "Voici un exemple avec un autre format que *byte*::"

#: ../Doc/library/stdtypes.rst:3412
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Si l'objet sous-jacent est accessible en écriture, la *memoryview* "
"autorisera les assignations de tranches à une dimension. Redimensionner "
"n'est cependant pas autorisé::"

#: ../Doc/library/stdtypes.rst:3433
msgid ""
"One-dimensional memoryviews of hashable (read-only) types with formats 'B', "
"'b' or 'c' are also hashable. The hash is defined as ``hash(m) == hash(m."
"tobytes())``::"
msgstr ""
"Les *memoryviews* à une dimension de types hachables (lecture seule) avec "
"les formats 'B', 'b', ou 'c' sont aussi hachables. La fonction de hachage "
"est définie tel que ``hash(m) == hash(m.tobytes())``::"

#: ../Doc/library/stdtypes.rst:3445
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now hashable."
msgstr ""
"Les *memoryviews* à une dimension peuvent aussi être découpées. Les "
"*memoryviews* à une dimension avec les formats 'B', 'b', ou 'c' sont "
"mainteannt hachables."

#: ../Doc/library/stdtypes.rst:3449
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"*memoryview* est maintenant enregistrée automatiquement avec :class:"
"`collections.abc.Sequence`"

#: ../Doc/library/stdtypes.rst:3453
msgid "memoryviews can now be indexed with tuple of integers."
msgstr ""
"Les *memoryviews* peut maintenant être indexées par un tuple d'entiers."

#: ../Doc/library/stdtypes.rst:3456
msgid ":class:`memoryview` has several methods:"
msgstr "La :class:`memoryview` dispose de plusieurs méthodes :"

#: ../Doc/library/stdtypes.rst:3460
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Une *memoryview* et un *exporter* de la :pep:`3118` sont égaux si leurs "
"formes sont équivalentes et si toutes les valeurs correspondantes sont "
"égales, le format respectifs des opérandes étant interprétés en utilisant la "
"syntaxe de :mod:`struct`."

#: ../Doc/library/stdtypes.rst:3464
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Pour le sous-ensemble des formats de :mod:`struct` supportés  par :meth:"
"`tolist`, ``v`` et ``w`` sont égaux si ``v.tolist() ==w.tolist()`` ::"

#: ../Doc/library/stdtypes.rst:3483
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Si l'un des format n'est pas supporté par le module de :mod:`struct`, les "
"objets seront toujours considérés différents  (même si les formats et les "
"valeurs contenues sont identiques) : ::"

#: ../Doc/library/stdtypes.rst:3499
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"Notez que pour les *memoryview*, comme pour les nombres à virgule flottante, "
"``v is w`` *n'implique pas* ``v == w``."

#: ../Doc/library/stdtypes.rst:3502
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Les versions précédentes comparaient la mémoire brute sans tenir compte du "
"format de l'objet ni de sa structure logique."

#: ../Doc/library/stdtypes.rst:3508
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Renvoie les données du *buffer* sous forme de *bytes*. Cela  équivaut à "
"appeler le constructeur :class:`bytes` sur le memoryview. ::"

#: ../Doc/library/stdtypes.rst:3517
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"Pour les arrays non contigus le résultat est égal à la représentation en "
"liste aplatie dont tous les éléments sont convertis en octets. :meth:"
"`tobytes` supporte toutes les chaînes de format, y compris celles qui ne "
"sont pas connues du module :mod:`struct`."

#: ../Doc/library/stdtypes.rst:3524
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""
"Renvoie une chaîne contenant deux chiffres hexadécimaux pour chaque octet du "
"buffer. ::"

#: ../Doc/library/stdtypes.rst:3535
msgid "Return the data in the buffer as a list of elements. ::"
msgstr ""
"Renvoie les données du buffer suus la forme d'une liste d'éléments. ::::"

#: ../Doc/library/stdtypes.rst:3545
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`tolist` prend désormais en charge tous les formats d'un caractère du "
"module :mod:`struct` ainsi que des représentationsmultidimensionnelles."

#: ../Doc/library/stdtypes.rst:3552
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"Libère le tampon sous-jacent exposé par l'objet *memoryview*.  Beaucoup "
"d'objets prennent des initiatives particulières lorsqu'ils sont liés à une "
"vue (par exemple, un :class:`bytearray` refusera temporairement de se faire "
"redimensionner). Par conséquent, appeler *release()* peut être pratique pour "
"lever ces restrictions (et en libérer les resources liées) aussi tôt que "
"possible."

#: ../Doc/library/stdtypes.rst:3558
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""
"Après le premier appel de cette méthode, toute nouvelle opération  sur la "
"*view* léve une :class:`ValueError` (sauf :meth:`release()` elle-même qui "
"peut être appelée plusieurs fois) : ::"

#: ../Doc/library/stdtypes.rst:3569
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"Le protocole de gestion de contexte peut être utilisé pour obtenir un effet "
"similaire, via l'instruction ``with`` : ::"

#: ../Doc/library/stdtypes.rst:3585
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"Change le format ou la forme d'une *memoryview*. Par défaut *shape* vaut "
"``[byte_length//new_itemsize]``, ce qui signifie que la vue résultante "
"n'aura qu'une dimension. La valeur renvoyee est une nouvelle *memoryview*, "
"mais buffer lui-même est pas copié. Les changements supportés sont 1D -> C-:"
"term:`contiguous` et *C-contiguous* -> 1D."

#: ../Doc/library/stdtypes.rst:3591
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
msgstr ""
"Le format de destination est limité à un seul élément natif de la syntaxe du "
"module :mod:`struct`. L'un des formats doit être un *byte* ('B', 'b', ou "
"'c'). La longueur du résultat en octets doit être la même que la longueur "
"initiale."

#: ../Doc/library/stdtypes.rst:3596
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "Transforme *1D/long* en *1D/unsigned bytes* : ::"

#: ../Doc/library/stdtypes.rst:3619
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "Transforme *1D/unsigned bytes* en *1D/char* : ::"

#: ../Doc/library/stdtypes.rst:3632
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Transforme *1D/bytes* en *3D/ints* en *1D/signed char* : ::"

#: ../Doc/library/stdtypes.rst:3658
msgid "Cast 1D/unsigned char to 2D/unsigned long::"
msgstr "Transforme *1D/unsigned char* en *2D/unsigned long* : ::"

#: ../Doc/library/stdtypes.rst:3672
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"Le format de la source n'est plus restreint lors de la transformation vers "
"une vue d'octets."

#: ../Doc/library/stdtypes.rst:3675
msgid "There are also several readonly attributes available:"
msgstr "Plusieurs attributs en lecture seule sont également disponibles :"

#: ../Doc/library/stdtypes.rst:3679
msgid "The underlying object of the memoryview::"
msgstr "L'objet sous-jacent de la *memoryview* : ::"

#: ../Doc/library/stdtypes.rst:3690
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to len(m)::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. Ceci est "
"l'espace que l'array utiliserait en octets, dans unereprésentation contiguë. "
"Ce n'est pas nécessairement égale à ``len(m)`` : ::"

#: ../Doc/library/stdtypes.rst:3709
msgid "Multi-dimensional arrays::"
msgstr "Tableaux multidimensionnels : ::"

#: ../Doc/library/stdtypes.rst:3726
msgid "A bool indicating whether the memory is read only."
msgstr "Un booléen indiquant si la mémoire est en lecture seule."

#: ../Doc/library/stdtypes.rst:3730
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"Une chaîne contenant le format (dans le style de :mod:`struct`) pour chaque "
"élément de la vue. Une *memoryview* peut être crée depuis des exportateurs "
"de formats arbitraires, mais certaines méthodes (comme :meth:`tolist`) sont "
"limitées aux formats natifs à un seul élément."

#: ../Doc/library/stdtypes.rst:3735
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"Le format ``'B'`` est maintenant traité selon la syntaxe du module *struct*. "
"Cela signifie que ``memoryview(b'abc')[0] == b'abc'[0] == 97``."

#: ../Doc/library/stdtypes.rst:3741
msgid "The size in bytes of each element of the memoryview::"
msgstr "La taille en octets de chaque élément d'une *memoryview*::"

#: ../Doc/library/stdtypes.rst:3754
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Un nombre entier indiquant le nombre de dimensions d'un tableau multi-"
"dimensionnel représenté par la *memoryview*."

#: ../Doc/library/stdtypes.rst:3759
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Un *tuple* d'entiers de longueur :attr:`ndim` donnant la forme de la "
"*memoryview* sous forme d'un tableau à N dimensions."

#: ../Doc/library/stdtypes.rst:3762 ../Doc/library/stdtypes.rst:3770
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Un *tuple* vide au lieu de ``None`` lorsque *ndim = 0*."

#: ../Doc/library/stdtypes.rst:3767
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Un *tuple* d'entiers de longueur :attr:`ndim` donnant la taille en octets "
"permettant d'accéder à chaque dimensions du tableau."

#: ../Doc/library/stdtypes.rst:3775
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"Détail de l'implémentation des *PIL-style arrays*. La valeur n'est donné "
"qu'a titre d'information."

#: ../Doc/library/stdtypes.rst:3779
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "Un booléen indiquant si la mémoire est C-:term:`contiguous`."

#: ../Doc/library/stdtypes.rst:3785
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "Un booléen indiquant si la mémoire est Fortran :term:`contiguous`."

#: ../Doc/library/stdtypes.rst:3791
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Un booléen indiquant si la mémoire est :term:`contiguous`."

#: ../Doc/library/stdtypes.rst:3799
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Types d'ensembles --- :class:`set`, :class:`frozenset`"

#: ../Doc/library/stdtypes.rst:3803
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Un objet :dfn:`set` est une collection non-triée d'objets :term:`hashable` "
"distincts. Les utilisations classiques sont le test d'appartenance, la "
"déduplication d'une séquence, ou le calcul d'opérations mathématiques telles "
"que l'intersection, l'union, la différence, ou la différence symétrique. "
"(Pour les autres conteneurs, voir les classes natives :class:`dict`, :class:"
"`list`, et :class:`tuple`, ainsi que le module :mod:`collections`.)"

#: ../Doc/library/stdtypes.rst:3810
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Comme pour les autres collections, les ensembles supportent ``x in set``, "
"``len(set)``, et ``for x in set``. En temps que collection non-triée, les "
"ensembles n'enregistrent pas la position des éléments ou leur ordre "
"d'insertion.  En conséquence, les *sets* n'autorisent ni l'indexation, ni le "
"découpage, ou tout autre comportement de séquence."

#: ../Doc/library/stdtypes.rst:3815
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"Il existe actuellement deux types natifs pour les ensembles, :class:`set` "
"et :class:`fronzenset`. Le type :class:`set` est mutable --- son contenu "
"peut changer en utilisant des méthodes comme :meth:`~set.add` et :meth:`~set."
"remove`. Puisqu'il est mutable, il n'a pas de valeur de hachage et ne peut "
"donc pas être utilisé ni comme clef de dictionnaire ni comme élément d'un "
"autre ensemble. Le type :class:`frozenset` est immuable et :term:`hashable` "
"--- son contenu ne peut être modifié après sa création, il peut ainsi être "
"utilisé comme clef de dictionnaire ou élément d'un autre *set*."

#: ../Doc/library/stdtypes.rst:3823
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Des *sets* (mais pas des *frozensets*) peuvent être crées par une liste "
"d'éléments séparés par des virgules et entre accolades, par exemple : "
"``{'jack', 'sjoerd'}``, en plus du constructeur de la classe :class:`set`."

#: ../Doc/library/stdtypes.rst:3827
msgid "The constructors for both classes work the same:"
msgstr "Les constructeurs des deux classes fonctionnent pareil :"

#: ../Doc/library/stdtypes.rst:3832
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Renvoie un nouveau *set* ou *frozenset* dont les éléments viennent "
"d'*iterable*.  Les éléments d'un *set* doivent être :term:`hashable`.  Pour "
"représenter des *sets* de *sets* les *sets* intérieurs doivent être des :"
"class:`frozenset`.  Si *iterable* n'est pas spécifié, un nouveau *set* vide "
"est renvoyé."

#: ../Doc/library/stdtypes.rst:3838
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Les instances de :class:`set` et :class:`frozenset` fournissent les "
"opérations suivantes :"

#: ../Doc/library/stdtypes.rst:3843
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "Donne le nombre d'éléments dans le *set* *s* (cardinalité de *s*)."

#: ../Doc/library/stdtypes.rst:3847
msgid "Test *x* for membership in *s*."
msgstr "Test d'appartenance de *x* dans *s*."

#: ../Doc/library/stdtypes.rst:3851
msgid "Test *x* for non-membership in *s*."
msgstr "Test de non-appartenance de *x* dans *s*."

#: ../Doc/library/stdtypes.rst:3855
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Renvoie ``True`` si l'ensemble n'a aucun élément en commun avec *other*.  "
"Les ensembles sont disjoints si et seulement si leurs intersection est un "
"ensemble vide."

#: ../Doc/library/stdtypes.rst:3861
msgid "Test whether every element in the set is in *other*."
msgstr "Teste si tous les éléments du set sont dans *other*."

#: ../Doc/library/stdtypes.rst:3865
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Teste si l'ensemble est un sous-ensemble de *other*, c'est-à-dire, ``set <= "
"other and set != other``."

#: ../Doc/library/stdtypes.rst:3871
msgid "Test whether every element in *other* is in the set."
msgstr "Teste si tous les éléments de *other* sont dans l'ensemble."

#: ../Doc/library/stdtypes.rst:3875
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Teste si l'ensemble est un sur-ensemble de *other*, c'est-à-dire, ``set >= "
"other and set != other``."

#: ../Doc/library/stdtypes.rst:3881
msgid "Return a new set with elements from the set and all others."
msgstr ""
"Renvoie un nouvel ensemble dont les éléments viennent de l'ensemble et de "
"tous les autres."

#: ../Doc/library/stdtypes.rst:3886
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Renvoie un nouvel ensemble dont les éléments sont commun à l'ensemble et à "
"tous les autres."

#: ../Doc/library/stdtypes.rst:3891
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"Renvoie un nouvel ensemble dont les éléments sont dans l'ensemble mais ne "
"sont dans aucun des autres."

#: ../Doc/library/stdtypes.rst:3896
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Renvoie un nouvel ensemble dont les éléments sont soit dans l'ensemble, soit "
"dans les autres, mais pas dans les deux."

#: ../Doc/library/stdtypes.rst:3900
msgid "Return a new set with a shallow copy of *s*."
msgstr "Renvoie un nouvel ensemble, copie de surface de *s*."

#: ../Doc/library/stdtypes.rst:3903
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and :"
"meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Remarque : Les méthodes  :meth:`union`, :meth:`intersection`, :meth:"
"`difference`, et :meth:`symmetric_difference`, :meth:`issubset`, et :meth:"
"`issuperset`acceptent n'importe quel itérable comme argument, contrairement "
"aux opérateurs équivalents qui n'acceptent que des *sets*. Il est donc "
"préférable d'éviter les constructions comme ``set('abc') & 'cbs'``, sources "
"typiques d'erreurs, en faveur d'une construction plus lisible : ``set('abc')."
"intersection('cbs')``."

#: ../Doc/library/stdtypes.rst:3910
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Les classes :class:`set` et :class:`frozenset` supportent les comparaisons "
"d'ensemble à ensemble. Deux ensembles sont égaux si et seulement si chaque "
"éléments de chaque ensemble est contenu dans l'autre (autrement dit que "
"chaque ensemble est un sous-ensemble de l'autre). Un ensemble est plus petit "
"qu'un autre ensemble si et seulement si le premier est un sous-ensemble du "
"second (un sous-ensemble, mais pas égal). Un ensemble est plus grand qu'un "
"autre ensemble si et seulement si le premier est un sur-ensemble du second "
"(est un sur-ensemble mais n'est pas égal)."

#: ../Doc/library/stdtypes.rst:3917
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Les instances de :class:`set` se comparent aux instances de :class:"
"`frozenset` en fonction de leurs membres.  Par exemple, ``set('abc') == "
"frozenset('abc')`` envoie ``True``, ainsi que ``set('abc') in "
"set([frozenset('abc')])``."

#: ../Doc/library/stdtypes.rst:3921
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"Les comparaisons de sous-ensemble et d'égalité ne se généralisent pas en une "
"fonction donnant un ordre total.  Par exemple, deux ensemble disjoints non "
"vides ne sont ni égaux et ni des sous-ensembles l'un de l'autre, donc toutes "
"ces comparaisons donnent ``False`` : ``a<b``, ``a==b``, et ``a>b``."

#: ../Doc/library/stdtypes.rst:3926
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Puisque les *sets* ne définissent qu'un ordre partiel (par leurs relations "
"de sous-ensembles), la sortie de la méthode :meth:`list.sort` n'est pas "
"définie pour des listes d'ensembles."

#: ../Doc/library/stdtypes.rst:3929
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"Les éléments des *sets*, comme les clefs de dictionnaires, doivent être :"
"term:`hashable`."

#: ../Doc/library/stdtypes.rst:3931
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Les opérations binaires mélangeant des instances de :class:`set` et :class:"
"`frozenset` renvoient le type de la première opérande.  Par exemple : "
"``frozenset('ab') | set('bc')`` renvoie une instance de :class:`frozenset`."

#: ../Doc/library/stdtypes.rst:3935
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"La table suivante liste les opérations disponibles pour les :class:`set` "
"mais qui ne s'appliquent pas aux instances de :class:`frozenset` :"

#: ../Doc/library/stdtypes.rst:3941
msgid "Update the set, adding elements from all others."
msgstr "Met à jour l'ensemble, ajoutant les éléments de tous les autres."

#: ../Doc/library/stdtypes.rst:3946
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Met à jour l'ensemble, ne gardant que les éléments trouvés dans tous les "
"autres."

#: ../Doc/library/stdtypes.rst:3951
msgid "Update the set, removing elements found in others."
msgstr "Met à jour l'ensemble, retirant les éléments trouvés dans les autres."

#: ../Doc/library/stdtypes.rst:3956
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Met à jour le set, ne gardant que les éléments trouvés dans un des ensembles "
"mais pas dans les deux."

#: ../Doc/library/stdtypes.rst:3960
msgid "Add element *elem* to the set."
msgstr "Ajoute l'élément *elem* au set."

#: ../Doc/library/stdtypes.rst:3964
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Retire l'élément *elem* de l'ensemble. Lève une exception :exc:`KeyError` si "
"*elem* n'est pas dans l'ensemble."

#: ../Doc/library/stdtypes.rst:3969
msgid "Remove element *elem* from the set if it is present."
msgstr "Retire l'élément *elem* de l'ensemble s'il y est."

#: ../Doc/library/stdtypes.rst:3973
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Retire et renvoie un élément arbitraire de l'ensemble. Lève une exception :"
"exc:`KeyError` si l'ensemble est vide."

#: ../Doc/library/stdtypes.rst:3978
msgid "Remove all elements from the set."
msgstr "Supprime tous les éléments du *set*."

#: ../Doc/library/stdtypes.rst:3981
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Notez que les versions non-opérateurs des méthodes :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, et :meth:"
"`symmetric_difference_update` acceptent n'importe quel itérable comme "
"argument."

#: ../Doc/library/stdtypes.rst:3986
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
"Notez que l'argument *elem* des méthodes :meth:`__contains__`, :meth:"
"`remove`, et :meth:`discard` peut être un ensemble.  Pour supporter la "
"recherche d'un *frozenset* équivalent, un *frozenset* temporaire est crée "
"depuis *elem*."

#: ../Doc/library/stdtypes.rst:3994
msgid "Mapping Types --- :class:`dict`"
msgstr "Les types de correspondances --- :class:`dict`"

#: ../Doc/library/stdtypes.rst:4004
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Un objet :term:`mapping` fait correspondre des valeurs :term:`hashable` à "
"des objets arbitraires. Les *mappings* sont des objets mutables.  Il "
"n'existe pour le moment qu'un type de *mapping* standard, le :dfn:"
"`dictionary`.  (Pour les autres conteneurs, voir les types natifs :class:"
"`list`, :class:`set`, and :class:`tuple`, et le module :mod:`collections`.)"

#: ../Doc/library/stdtypes.rst:4010
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""
"Les clefs d'un dictionnaire sont *presque* des données arbitraires. Les "
"valeurs qui ne sont pas :term:`hashable`, c'est-à-dire qui contiennent les "
"listes, des dictionnaires ou autre type mutable (qui sont comparés par "
"valeur plutôt que par leur identité) ne peuvent pas être utilisées comme "
"clef de dictionnaire. Les types numériques utilisés comme clef obéissent aux "
"règles classiques en ce qui concerne les comparaisons : si deux nombres sont "
"égaux (comme ``1`` et ``1.0``) ils peuvent tous les deux être utilisés pour "
"obtenir la même entrée d'un dictionnaire.  (Notez cependant que puisque les "
"ordinateurs stockent les nombres à virgule flottante sous forme "
"d'approximations, il est généralement imprudent de les utiliser comme clefs "
"de dictionnaires.)"

#: ../Doc/library/stdtypes.rst:4019
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}`` "
"or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""
"Il est possible de créer des dictionnaires en plaçant entre accolades une "
"liste de paires de ``key: value`` séparés par des virgules, par exemple: "
"``{'jack': 4098, 'sjoerd': 4127}`` ou ``{4098: 'jack', 4127: 'sjoerd'}``, ou "
"en utilisant le constructeur de :class:`dict`."

#: ../Doc/library/stdtypes.rst:4027
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Renvoie un nouveau dictionnaire initialisé depuis un argument positionnel "
"optionnel, et un ensemble (vide ou non) d'arguments par mot clef."

#: ../Doc/library/stdtypes.rst:4030
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"Si aucun arument positionnel n'est donné, un dictionnaire vide est crée. Si "
"un argument positionnel est donné et est un *mapping object*, un "
"dictionnaire est crée avec les mêmes paires de clef-valeurs que le *mapping* "
"donné. Autrement, l'argument positionnel doit être un objet :term:"
"`iterable`. Chaque élément de cet itérable doit lui même être un itérable "
"contenant exactement deux objets.  Le premier objet de chaque élément "
"devient la une clef du nouveau dictionnaire, et le second devient sa valeur "
"correspondante.  Si une clef apparaît plus d'une fois, la dernière valeur "
"pour cette clef devient la valeur correspondante à cette clef dans le "
"nouveau dictionnaire."

#: ../Doc/library/stdtypes.rst:4040
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Si des arguments nommés sont donnés, ils sont ajoutés au dictionnaire crée "
"depuis l'argument positionnel.  Si une clef est déjà présente, la valeur de "
"l'argument nommé remplace la valeur reçue par l'argument positionnel."

#: ../Doc/library/stdtypes.rst:4045
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Typiquement, les exemples suivants renvoient tous un dictionnaire valant "
"``{\"one\": 1, \"two\": 2, \"three\": 3}`` : ::"

#: ../Doc/library/stdtypes.rst:4056
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Fournir les arguments nommés comme dans le premier exemple en fonctionne que "
"pour des clefs qui sont des identifiants valide en Python.  Dans les autres "
"cas, toutes les clefs valides sont utilisables."

#: ../Doc/library/stdtypes.rst:4060
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Voici les opérations gérées par les dictionnaires, (par conséquent, d'autres "
"types de *mapping* peuvent les gérer aussi) :"

#: ../Doc/library/stdtypes.rst:4065
msgid "Return the number of items in the dictionary *d*."
msgstr "Renvoie le nombre d'éléments dans le dictionnaire *d*."

#: ../Doc/library/stdtypes.rst:4069
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Donne l'élément de *d* dont la clef est *key*. Lève une exception :exc:"
"`KeyError` si *key* n'est pas dans le dictionnaire."

#: ../Doc/library/stdtypes.rst:4074
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"Si une sous-classe de *dict* définit une méthode :meth:`__missing__` et que "
"*key* manque, l'opération ``d[key]`` appelle cette méthode avec la clef "
"*key* en argument. L'opération ``d[key]`` renverra la valeur, ou lèvera "
"l'exception renvoyée ou levée par l'appel à ``__missing__(key)``. Aucune "
"autre opération ni méthode n'appellent :meth:`__missing__`. If :meth:"
"`__missing__` n'est pas définie, une exception :exc:`KeyError` est levée. :"
"meth:`__missing__` doit être une méthode; ça ne peut être une variable "
"d'instance."

#: ../Doc/library/stdtypes.rst:4092
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"L'exemple ci-dessus montre une partie de l'implémentation de :class:"
"`collections.Counter`.  :class:`collections.defaultdict` implémente aussi "
"``__missing__``."

#: ../Doc/library/stdtypes.rst:4098
msgid "Set ``d[key]`` to *value*."
msgstr "Assigne ``d[key]`` à *value*."

#: ../Doc/library/stdtypes.rst:4102
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Supprime ``d[key]`` de *d*.  Lève une exception :exc:`KeyError` si *key* "
"n'est pas dans le dictionnaire."

#: ../Doc/library/stdtypes.rst:4107
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "Renvoie ``True`` si *d* a la clef *key*, sinon ``False``."

#: ../Doc/library/stdtypes.rst:4111
msgid "Equivalent to ``not key in d``."
msgstr "Équivalent à ``not key in d``."

#: ../Doc/library/stdtypes.rst:4115
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Renvoie un itérateur sur les clefs du dictionnaire.  C'est un raccourci pour "
"``iter(d.keys())``."

#: ../Doc/library/stdtypes.rst:4120
msgid "Remove all items from the dictionary."
msgstr "Supprime tous les éléments du dictionnaire."

#: ../Doc/library/stdtypes.rst:4124
msgid "Return a shallow copy of the dictionary."
msgstr "Renvoie une copie de surface du dictionnaire."

#: ../Doc/library/stdtypes.rst:4128
msgid "Create a new dictionary with keys from *seq* and values set to *value*."
msgstr ""
"Crée un nouveau dictionnaire avec les clefs de *seq* et les valeurs à "
"*value*."

#: ../Doc/library/stdtypes.rst:4130
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``."
msgstr ""
":meth:`fromkeys` est une *class method* qui renvoie un nouveau dictionnaire. "
"*value* vaut ``None`` par défaut."

#: ../Doc/library/stdtypes.rst:4135
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Renvoie la valeur de *key* si *key* est dans le dictionnaire, sinon "
"*default*. Si *default* n'est pas donné, il vaut ``None`` par défaut, de "
"manière à ce que cette méthode ne lève jamais :exc:`KeyError`."

#: ../Doc/library/stdtypes.rst:4141
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Renvoie une nouvelle vue des éléments du dictionnaire (paires de ``(key, "
"value)``). Voir la :ref:`documentation des vues <dict-views>`."

#: ../Doc/library/stdtypes.rst:4146
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Renvoie une nouvelle vue des clefs du dictionnaire. Voir la :ref:"
"`documentation des vues <dict-views>`."

#: ../Doc/library/stdtypes.rst:4151
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Si *key* est dans le dictionnaire elle est supprimée et sa valeur est "
"renvoyée, sinon renvoie *default*.  Si *default* n'est pas donné et que "
"*key* n'est pas dans le dictionnaire, une :exc:`KeyError` est levée."

#: ../Doc/library/stdtypes.rst:4157
msgid ""
"Remove and return an arbitrary ``(key, value)`` pair from the dictionary."
msgstr "Supprime et renvoie une ``(key, value)`` arbitraire du dictionnaire."

#: ../Doc/library/stdtypes.rst:4159
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` est pratique pour itérer un dictionnaire de manière "
"destrictive, comme souvent dans les algorithmes sur les ensembles.  Si le "
"dictionnaire est vide, appeler :meth:`popitem` lève une :exc:`KeyError`."

#: ../Doc/library/stdtypes.rst:4165
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Si *key* est dans le dictionnaire, sa valeur est renvoyée. Sinon, insère "
"*key* avec comme valeur *default* et renvoie *default*.  *default* vaut "
"``None`` par défaut."

#: ../Doc/library/stdtypes.rst:4171
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Met à jour le dictionnaire avec les paires de clef/valeur d'*other*, "
"écrasant les clefs existantes. Renvoie ``None``."

#: ../Doc/library/stdtypes.rst:4174
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` accepte aussi bien un autre dictionnaire qu'un itérable de "
"clef/valeurs (sous forme de *tuples* ou autre itérables de longueur deux).  "
"Si des paramètres par mot-clef sont donnés, le dictionnaire et ensuite mis à "
"jour avec ces pairs de clef/valeurs : ``d.update(red=1, blue=2)``."

#: ../Doc/library/stdtypes.rst:4181
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Renvoie une nouvelle vue des valeurs du dictionnaire.  Voir la :ref:"
"`documentation des vues <dict-views>`."

#: ../Doc/library/stdtypes.rst:4184
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs. Order comparisons ('<', '<=', '>=', '>') raise :exc:"
"`TypeError`."
msgstr ""
"Deux dictionnaires sont égaux si et seulement si ils ont les mêmes paires de "
"clef-valeur.  Les comparaisons d'ordre ('<', '<=', '>=', '>') lèvent une :"
"exc:`TypeError`."

#: ../Doc/library/stdtypes.rst:4189
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
":class:`types.MappingProxyType` peut être utilisé pour créer une vue en "
"lecture seule d'un :class:`dict`."

#: ../Doc/library/stdtypes.rst:4196
msgid "Dictionary view objects"
msgstr "Les vues de dictionnaires"

#: ../Doc/library/stdtypes.rst:4198
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"Les objets renvoyés par :meth:`dict.keys`, :meth:`dict.values` et :meth:"
"`dict.items` sont des *vues*.  Ils fournissent une vue dynamique des "
"éléments du dictionnaire, ce qui signifie que si le dictionnaire change, la "
"vue reflète ces changements."

#: ../Doc/library/stdtypes.rst:4203
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Les vues de dictonnaires peuvent être itérées et ainsi renvoyer les données "
"du dictionnaire, elle gèrent aussi les tests de présence :"

#: ../Doc/library/stdtypes.rst:4208
msgid "Return the number of entries in the dictionary."
msgstr "Renvoie le nombre d'entrées du dictionnaire."

#: ../Doc/library/stdtypes.rst:4212
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Renvoie un itérateur sur les clefs, les valeurs, ou les éléments "
"(représentés par des *tuples* de ``(key, value)`` du dictionnaire."

#: ../Doc/library/stdtypes.rst:4215
msgid ""
"Keys and values are iterated over in an arbitrary order which is non-random, "
"varies across Python implementations, and depends on the dictionary's "
"history of insertions and deletions. If keys, values and items views are "
"iterated over with no intervening modifications to the dictionary, the order "
"of items will directly correspond.  This allows the creation of ``(value, "
"key)`` pairs using :func:`zip`: ``pairs = zip(d.values(), d.keys())``.  "
"Another way to create the same list is ``pairs = [(v, k) for (k, v) in d."
"items()]``."
msgstr ""
"Les clefs et les valeurs sont itérées dans un ordre arbitraire qui n'est pas "
"aléatoire, qui peut varier d'une implémentation de Python à l'autre, et qui "
"dépend de l'historique d'insertion et de suppressions d'éléments. Si les "
"vues de clefs, de valeurs, et d'éléments sont parcourues sans que le "
"dictionnaire ne soit modifié, l'ordre des éléments correspondra "
"directement.  Ceci permet la création de paires de ``(key, value)`` en "
"utilisant :func:`zip` : ``pairs = zip(d.values(), d.keys())``.  Un autre "
"moyen de construire la même liste est  ``pairs = [(v, k) for (k, v) in d."
"items()]``."

#: ../Doc/library/stdtypes.rst:4223
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Parcourir des vues tout en ajoutant ou supprimant des entrées dans un "
"dictionnaire peut lever une :exc:`RuntimeError` ou ne pas fournir toutes les "
"entrées."

#: ../Doc/library/stdtypes.rst:4228
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Renvioie ``True`` si *x* est dans les clefs, les valeurs, ou les éléments du "
"dictionnaire sous-jacent (dans le dernier cas, *x* doit être un *tuple* "
"``(key, value)``)."

#: ../Doc/library/stdtypes.rst:4232
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all "
"values are hashable, so that ``(key, value)`` pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  For set-like views, all "
"of the operations defined for the abstract base class :class:`collections."
"abc.Set` are available (for example, ``==``, ``<``, or ``^``)."
msgstr ""
"Les vues de clefs sont semblables à des ensembles puisque leurs entrées sont "
"uniques et hachables.  Si toutes les valeurs sont hachables, et qu'ainsi "
"toutes les paires de ``(key, value`` sont uniques et hachables, alors la vue "
"donnée par *items()* est aussi semblable à un ensemble.  (Les vues données "
"par *items()* ne sont généralement pas traitées comme des ensembles, car "
"leurs valeurs ne sont généralement pas uniques.)  Pour les vues semblables "
"aux ensembles, toutes les opérations définies dans la classe de base "
"abstraite  :class:`collections.abc.Set` sont disponnibles (comme ``==``, "
"``<``, ou ``^``)."

#: ../Doc/library/stdtypes.rst:4239
msgid "An example of dictionary view usage::"
msgstr "Exemple d'utilisation de vue de dictionnaire : ::"

#: ../Doc/library/stdtypes.rst:4274
msgid "Context Manager Types"
msgstr "Le type Gestionnaire de Contexte"

#: ../Doc/library/stdtypes.rst:4281
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"L'instruction :keyword:`with` permet l'existance de contextes définis à "
"l'exécution par des gestionnaires de contextes.  C'est implémenté via une "
"paire de méthodes permettant de définir un contexte, à l'exécution, qui est "
"entré avant l'exécution du corps de l'instruction, et qui est quitté lorsque "
"l'instruction se termine :"

#: ../Doc/library/stdtypes.rst:4289
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Entre dans le contexte à l'exécution, soit se renvoyant lui-même, soit en "
"renvoyant un autre objet en lien avec ce contexte.  La valeur renvoyée par "
"cette méthode est liée à l'indentifiant donné au :keyword:`as` de "
"l'instruction :keyword:`with` utilisant ce gestionnaire de contexte."

#: ../Doc/library/stdtypes.rst:4294
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Un exemple de gestionnaire de contexte se renvoyant lui-même est :term:`file "
"object`. Les *file objects* se renvoient eux-même depuis __enter__() et "
"autorisent :func:`open` à être utilisé comme contexte à une instruction :"
"keyword:`with`."

#: ../Doc/library/stdtypes.rst:4298
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`with` statement."
msgstr ""
"Un exemple de gestionnaire de contexte renvoyant un objet connexe est celui "
"renvoyé par :func:`decimal.localcontext`. Ces gestionnaires remplacent le "
"contexte décimal courant par une copie de l'original, copie qui est "
"renvoyée. Ça permet de changer le contexte courant dans le corps du :keyword:"
"`with` sans affecter le code en dehors de l'instruction :keyword:`with`."

#: ../Doc/library/stdtypes.rst:4308
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Sort du contexte et renvoie un booléen indiquant si une exception survenue "
"doit être supprimée.  Si une exception est survenue lors de l'exécution du "
"corps de l'instruction :keyword:`with`, les arguments contiennent le type de "
"l'exception, sa valeur, et la trace de la pile (*traceback*). Sinon les "
"trois arguments valent ``None``."

#: ../Doc/library/stdtypes.rst:4313
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`with` statement. Otherwise the "
"exception continues propagating after this method has finished executing. "
"Exceptions that occur during execution of this method will replace any "
"exception that occurred in the body of the :keyword:`with` statement."
msgstr ""
"L'instruction :keyword:`with` inhibera l'exception si cette méthode renvoie "
"une valeur vraie, l'execution continura ainsi à l'instruction suivant "
"immédiatement l'instruction :keyword:`with`. Sinon, l'exception continura de "
"se propager après la fin de cette méthode. Les exceptions se produiseant "
"pendant l'exécution de cette méthode remplaceront toute exception qui s'est "
"produite dans le corps du :keyword:`with`."

#: ../Doc/library/stdtypes.rst:4320
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`__exit__` "
"method has actually failed."
msgstr ""
"L'exception reçue ne doit jamais être relancée explicitement - cette méthode "
"devrait plutôt renvoyer une valeur fausse pour indiquer que son exécution "
"s'est terminée avec succès et qu'elle ne veut pas supprimer l'exception. "
"Ceci permet au code de gestion du contexte de comprendre si une méthode :"
"meth: `__exit__` a échoué."

#: ../Doc/library/stdtypes.rst:4326
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python définit plusieurs gestionnaires de contexte pour faciliter la "
"synchronisation des threads, la fermeture des fichiers ou d'autres objets, "
"et la configuration du contexte arithmétique décimal. Ces types spécifiques "
"ne sont pas traités différement, ils respectement simplement le protocole de "
"gestion du contexte. Voir les examples dans la documentation du module :mod:"
"`contextlib`."

#: ../Doc/library/stdtypes.rst:4332
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`__enter__` and :meth:`__exit__` methods, rather than the iterator produced "
"by an undecorated generator function."
msgstr ""
"Les :term:`generator`\\s de Python et le décorateur :class:`contextlib."
"contextmanager` permettent d'implémenter simplement ces protocoles.  Si un "
"générateur est décoré avec :class:`contextlib. contextmanager`, elle "
"renverra un gestionnaire de contexte implémentant les méthodes :meth:"
"`__enter__` et :meth:`__exit__`, plutôt que l'itérateur produit par un "
"générateur non décoré."

#: ../Doc/library/stdtypes.rst:4339
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Notez qu'il n'y a pas de slot spécifique pour ces méthodes dans la structure "
"de type pour les objets Python dans l'API Python/C. Les types souhaitant "
"définir ces méthodes doivent les fournir comme une méthode accessible en "
"Python. Comparé au coût de la mise en place du contexte d'exécution, les le "
"coût d'un accès au dictionnaire d'une classe unique est négligeable."

#: ../Doc/library/stdtypes.rst:4349
msgid "Other Built-in Types"
msgstr "Autres types natifs"

#: ../Doc/library/stdtypes.rst:4351
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"L'interpréteur gère aussi d'autres types d'objets, la pluspart ne supportant "
"cependant qu'une ou deux opérations."

#: ../Doc/library/stdtypes.rst:4358
msgid "Modules"
msgstr "Modules"

#: ../Doc/library/stdtypes.rst:4360
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"La seule opération spéciale sur un module est l'accès à ses attributs : ``m."
"name``, où *m* est un module et *name* donne accès un nom défini dans la "
"table des symboles de *m*.  Il est possible d'assigner un attribut de "
"module.  (Notez que l'instruction :keyword:`import` n'est pas strictement "
"une opération sur un objet module. ``import foo`` ne nécessite pas qu'un "
"objet module nommé *foo* existe, il nécessite cependant une *définition* "
"(externe) d'un module nommé *foo* quelque part.)"

#: ../Doc/library/stdtypes.rst:4367
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Un attribut spécial à chaque module est :attr:`~object.__dict__`. C'est le "
"dictionnaire contenant la table des symbole du module. Modifier ce "
"dictionnaire changera la table des symboles du module, mais assigner "
"directement :attr:`~object.__dict__` n'est pas possible (vous pouvez écrire "
"``m.__dict__['a'] = 1``, qui donne ``1`` comme valeur pour ``m.a``, mais "
"vous ne pouvez pas écrire ``m.__dict__ = {}``). Modifier :attr:`~object."
"__dict__` directement n'est pas recommandé."

#: ../Doc/library/stdtypes.rst:4375
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Les modules natifs à l'interpréteur sont représentés ``<module 'sys' (built-"
"in)>``.  S'ils sont chargés depuis un fichier, ils sont représentés "
"``<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."

#: ../Doc/library/stdtypes.rst:4383
msgid "Classes and Class Instances"
msgstr "Les Classes et Instances de Classes"

#: ../Doc/library/stdtypes.rst:4385
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Voir :ref:`objects` et :ref:`class`."

#: ../Doc/library/stdtypes.rst:4391
msgid "Functions"
msgstr "Fonctions"

#: ../Doc/library/stdtypes.rst:4393
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Les objets fonctions sont crées par les définitions de fonctions.  La seule "
"opération applicable à un objet fonction est de l'appeler : ``func(argument-"
"list)``."

#: ../Doc/library/stdtypes.rst:4396
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Il existe en fait deux catégories d'objets fonctions : Les fonctions natives "
"et les fonctions définies par l'utilisateur.  Les deux gèrent les mêmes "
"opérations (l'appel à la fonction), mais leur implémentation est différente, "
"d'où les deux types distincts."

#: ../Doc/library/stdtypes.rst:4400
msgid "See :ref:`function` for more information."
msgstr "Voir :ref:`function` pour plus d'information."

#: ../Doc/library/stdtypes.rst:4406
msgid "Methods"
msgstr "Méthodes"

#: ../Doc/library/stdtypes.rst:4410
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"Les méthodes sont des fonctions appelées via la notation d'attribut.  Il en "
"existe deux variantes : Les méthodes natives (tel que :meth:`append` sur les "
"listes), et les méthodes d'instances de classes. Les méthodes natives sont "
"représentées avec le type qui les supporte."

#: ../Doc/library/stdtypes.rst:4415
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Si vous accédez à une méthode (une fonction définie dans l'espace de nom "
"d'une classe) via une instance, vous obtenez un objet spécial, une :dfn:"
"`bound method` (aussi appellée :dfn:`instance method`). Lorsqu'elle est "
"appelée, elle ajoute l'argument ``self`` à la liste des arguments.  Les "
"méthodes liées ont deux attributs spéciaux, en lecture seule : ``m."
"__self__`` est l'objet sur lequel la méthode travaille, et ``m.__func__`` "
"est la fonction implémentant la méthode. Appeler ``m(arg-1, arg-2, …, arg-"
"n)`` est tout à fait équivalent à appeler ``m.__func__(m.__self__, arg-1, "
"arg-2, …, arg-n)``."

#: ../Doc/library/stdtypes.rst:4424
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""
"Comme les objets fonctions, les objets méthodes, liées, acceptent des "
"attributs arbitraires. Cependant, puisque les attributs de méthodes doivent "
"être stockés dans la fonction sous-jacente (``meth.__func__``), affecter des "
"attributs à des objets *bound method* est interdit. Toute tentative "
"d'affecter un attribut sur un objet *bound method* lèvera une :exc:"
"`AttributeError`. Pour affecter l'attribut, vous devrez explicitement "
"l'affecter à sa fonction sous-jascente::"

#: ../Doc/library/stdtypes.rst:4444 ../Doc/library/stdtypes.rst:4472
msgid "See :ref:`types` for more information."
msgstr "Voir :ref:`types` pour plus d'information."

#: ../Doc/library/stdtypes.rst:4452
msgid "Code Objects"
msgstr "Objets Code"

#: ../Doc/library/stdtypes.rst:4458
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Les objets code sont utilisés par l'implémentation pour représenter du code "
"Python \"pseudo-compilé\", comme un corps de fonction. Ils sont différents "
"des objets fonction dans le sens où ils ne contiennent pas de référence à "
"leur environnement global d'exécution. Les objets code sont renvoyés par la "
"fonction native :func:`compile` et peuvent être obtenus des objets fonction "
"via leur attribut :attr:`__code__`. Voir aussi le module :mod:`code`."

#: ../Doc/library/stdtypes.rst:4469
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Les objets code peuvent être exécutés ou évalués en les passant (au lieu "
"d'une chaîne contenant du code) aux fonction natives :func:`exec` ou :func:"
"`eval`."

#: ../Doc/library/stdtypes.rst:4478
msgid "Type Objects"
msgstr "Objets Type"

#: ../Doc/library/stdtypes.rst:4484
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Les objets types représentent les différents types d'objets. Le type d'un "
"objet est obtenu via la fonction native :func:`type`. Il n'existe aucune "
"opération spéciale sur les types. Le module standard :mod:`types` définit "
"les noms de tous les types natifs."

#: ../Doc/library/stdtypes.rst:4489
msgid "Types are written like this: ``<class 'int'>``."
msgstr "Les types sont représentés : ``<class 'int'>``."

#: ../Doc/library/stdtypes.rst:4495
msgid "The Null Object"
msgstr "L'objet Null"

#: ../Doc/library/stdtypes.rst:4497
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Cet objet est renvoyé par les fonctions ne renvoyant pas explicitement une "
"valeur. Il ne supporte aucune opération spéciale. Il existe exactement un "
"objet *null* nommé ``None`` (c'est un nom natif). ``type(None)()``."

#: ../Doc/library/stdtypes.rst:4501
msgid "It is written as ``None``."
msgstr "C'est écrit ``None``."

#: ../Doc/library/stdtypes.rst:4507
msgid "The Ellipsis Object"
msgstr "L'objet Points de Suspension"

#: ../Doc/library/stdtypes.rst:4509
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Cet objet est utilisé classiquement lors des découpes (voir :ref:"
"`slicings`). Il ne supporte aucune opération spéciale. Il n'y a qu'un seul "
"objet *ellipsis*, nommé :const:`Ellipsis` (un nom natif). ``type(Ellipsis)"
"()`` produit le *singleton* :const:`Ellipsis`."

#: ../Doc/library/stdtypes.rst:4514
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "C'est écrit ``Ellipsis`` ou ``...``."

#: ../Doc/library/stdtypes.rst:4520
msgid "The NotImplemented Object"
msgstr "L'objet *NotImplemented*"

#: ../Doc/library/stdtypes.rst:4522
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"Cet objet est renvoyé depuis des comparaisons ou des opérations binaires "
"effectées sur des types qu'elles ne supportent pas. Voir :ref:`comparisons` "
"pour plus d'informations. Il n'y a qu'un seul objet ``NotImplemented``. "
"``type(NotImplemented)()`` renvoit un *singleton*."

#: ../Doc/library/stdtypes.rst:4527
msgid "It is written as ``NotImplemented``."
msgstr "C'est écrit ``NotImplemented``."

#: ../Doc/library/stdtypes.rst:4533
msgid "Boolean Values"
msgstr "Valeurs Booléennes"

#: ../Doc/library/stdtypes.rst:4535
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""
"Les valeurs booléennes sont les deux objet constants ``False`` et ``True``. "
"Ils son utilisés pour représenter les valeurs de vérité (bien que d'autres "
"valeurs peuvent être considérées vraies ou fausses). Dans des contextes "
"numériques (par exemple en argument d'un opérateur arithmétique), ils se "
"comportent comme les nombres entiers 0 et 1, respectivement.  La fonction "
"native :func:`bool` peut être utilisée pour convertir n'importe quelle "
"valeur en booléen tant que la valeur peut être interprétée en une valeur de "
"vérité (voir :ref:`truth` au dessus)."

#: ../Doc/library/stdtypes.rst:4548
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "Ils s'écrivent ``False`` et ``True``, respectivement."

#: ../Doc/library/stdtypes.rst:4554
msgid "Internal Objects"
msgstr "Objets Internes"

#: ../Doc/library/stdtypes.rst:4556
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"Voir :ref:`types`. Ils décrivent les objets *stack frame*, *traceback*, et "
"*slice*."

#: ../Doc/library/stdtypes.rst:4563
msgid "Special Attributes"
msgstr "Attributs Spéciaux"

#: ../Doc/library/stdtypes.rst:4565
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"L'implémentation ajoute quelques attributs spéciaux et en lecture seule, à "
"certains types, lorsque ça a du sens. Certains ne sont *pas* listés par la "
"fonction native :func:`dir`."

#: ../Doc/library/stdtypes.rst:4572
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Un dictionnaire ou un autre *mapping object* utilisé pour stocker les "
"attributs (modifiables) de l'objet."

#: ../Doc/library/stdtypes.rst:4578
msgid "The class to which a class instance belongs."
msgstr "La classe de l'instance de classe."

#: ../Doc/library/stdtypes.rst:4583
msgid "The tuple of base classes of a class object."
msgstr "Le *tuple* des classes parentes d'un objet classe."

#: ../Doc/library/stdtypes.rst:4588
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr "Le nom de la classe, fonction, méthode, descripteur, ou générateur."

#: ../Doc/library/stdtypes.rst:4594
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"Le :term:`qualified name` de la classe, fonction, méthode, descripteur, ou "
"générateur."

#: ../Doc/library/stdtypes.rst:4602
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"Cet attribut est un *tuple* contenant les classes parents prises en compte "
"lors de la résolution de méthode."

#: ../Doc/library/stdtypes.rst:4608
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"Cette méthode peut être surchargée par une meta-classe pour personnaliser "
"l'ordre de la recherche de méthode pour ses instances.  Elle est appelée à "
"la l'initialisation de la classe, et son résultat est stocké dans "
"l'attribut :attr:`~class.__mro__`."

#: ../Doc/library/stdtypes.rst:4615
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive. Example::"
msgstr ""
"Chaque classe garde une liste de références faibles à ses classes filles "
"immédiates. Cette méthode renvoie la liste de toutes ces références encore "
"valables. Exemple : ::"

#: ../Doc/library/stdtypes.rst:4624
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/library/stdtypes.rst:4625
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Plus d'informations sur ces méthodes spéciales peuvent être trouvées dans le "
"*Python Reference Manual* (:ref:`customization`)"

#: ../Doc/library/stdtypes.rst:4628
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Par conséquent, la liste ``[1, 2]`` est considérée égale à ``[1.0, 2.0]``. "
"Idem avec des tuples."

#: ../Doc/library/stdtypes.rst:4631
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Nécessairement, puisque le parseur ne peut pas discerner le type des "
"opérandes."

#: ../Doc/library/stdtypes.rst:4633
msgid ""
"Cased characters are those with general category property being one of \"Lu"
"\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Les caractères capitalisables sont ceux dont la propriété unicode *general "
"category* est soit \"Lu\" (pour *Letter*, *uppercase*), soit \"Ll\" (pour "
"*Letter*, *lowercase*), soit \"Lt\" (pour *Letter*, *titlecase*)."

#: ../Doc/library/stdtypes.rst:4636
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Pour insérer un *tuple*, vous devez donc donner un *tuple* d'un seul "
"élément, contenant le *tuple* à insérer."

#~ msgid "``None``"
#~ msgstr "``None``"

#~ msgid "``False``"
#~ msgstr "``False``"

#~ msgid "any empty sequence, for example, ``''``, ``()``, ``[]``."
#~ msgstr "toute séquence vide, par exemple, ``''``, ``()``, ``[]``."

#~ msgid "any empty mapping, for example, ``{}``."
#~ msgstr "toute dictionnaire vide, par exemple, ``{}``."

#~ msgid ""
#~ "instances of user-defined classes, if the class defines a :meth:"
#~ "`__bool__` or :meth:`__len__` method, when that method returns the "
#~ "integer zero or :class:`bool` value ``False``. [1]_"
#~ msgstr ""
#~ "pour les instances de classes définies par l'utilisateur, si la classe "
#~ "définit une méthode :meth:`__bool__` ou :meth:`__len__`, lorsque cette "
#~ "méthode renvoie le nombre entier zéro ou la valeur ``False`` de la "
#~ "classe :class:`bool`. [1]_"

#~ msgid ""
#~ "All other values are considered true --- so objects of many types are "
#~ "always true."
#~ msgstr ""
#~ "Toutes les autres valeurs sont considérées comme vraies --- donc des "
#~ "objets de beaucoup de types sont toujours vrais."

#~ msgid "Bytes"
#~ msgstr "Bytes"

#~ msgid ""
#~ "The alternate form causes a leading zero (``'0'``) to be inserted between "
#~ "left-hand padding and the formatting of the number if the leading "
#~ "character of the result is not already a zero."
#~ msgstr ""
#~ "La forme alternative insère un zéro (``'0'``) entre le rembourrage gauche "
#~ "et le formatage du nombre si son premier caractère n'est pas déjà un zéro."
