# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 22:40+0100\n"
"PO-Revision-Date: 2023-07-24 13:50+0200\n"
"Last-Translator: Jean Abou Samra <jean@abou-samra.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.3.1\n"

#: library/zipimport.rst:2
#, fuzzy
msgid ":mod:`!zipimport` --- Import modules from Zip archives"
msgstr ":mod:`zipimport` — Import de modules à partir d'archives Zip"

#: library/zipimport.rst:9
msgid "**Source code:** :source:`Lib/zipimport.py`"
msgstr "**Code source :** :source:`Lib/zipimport.py`"

#: library/zipimport.rst:13
msgid ""
"This module adds the ability to import Python modules (:file:`\\*.py`, :file:"
"`\\*.pyc`) and packages from ZIP-format archives. It is usually not needed "
"to use the :mod:`zipimport` module explicitly; it is automatically used by "
"the built-in :keyword:`import` mechanism for :data:`sys.path` items that are "
"paths to ZIP archives."
msgstr ""
"Ce module ajoute la possibilité d'importer des modules Python (:file:`\\*."
"py`, :file:`\\*.pyc`) et des paquets depuis des archives au format ZIP. Il "
"n'est généralement pas nécessaire d'utiliser explicitement le module :mod:"
"`zipimport` ; il est automatiquement utilisé par le mécanisme intégré de :"
"keyword:`import` pour les éléments de :data:`sys.path` qui sont des chemins "
"vers des archives ZIP."

#: library/zipimport.rst:19
msgid ""
"Typically, :data:`sys.path` is a list of directory names as strings.  This "
"module also allows an item of :data:`sys.path` to be a string naming a ZIP "
"file archive. The ZIP archive can contain a subdirectory structure to "
"support package imports, and a path within the archive can be specified to "
"only import from a subdirectory.  For example, the path :file:`example.zip/"
"lib/` would only import from the :file:`lib/` subdirectory within the "
"archive."
msgstr ""
"En général, :data:`sys.path` est une liste de noms de répertoires sous forme "
"de chaînes.  Ce module permet également à un élément de :data:`sys.path` "
"d'être une chaîne nommant une archive de fichier ZIP. L'archive peut "
"contenir une arborescence de répertoires pour prendre en charge les "
"importations de paquets, et un chemin dans l'archive peut être donné pour "
"importer uniquement à partir d'un sous-répertoire.  Par exemple, le chemin "
"d'accès :file:`example.zip/lib/` importerait uniquement depuis le sous-"
"répertoire :file:`lib/` dans l'archive."

#: library/zipimport.rst:26
msgid ""
"Any files may be present in the ZIP archive, but importers are only invoked "
"for :file:`.py` and :file:`.pyc` files.  ZIP import of dynamic modules (:"
"file:`.pyd`, :file:`.so`) is disallowed. Note that if an archive only "
"contains :file:`.py` files, Python will not attempt to modify the archive by "
"adding the corresponding :file:`.pyc` file, meaning that if a ZIP archive "
"doesn't contain :file:`.pyc` files, importing may be rather slow."
msgstr ""
"Tous les fichiers peuvent être présents dans l'archive ZIP, mais les "
"importateurs ne sont invoqués que pour les fichiers :file:`.py` et :file:`."
"pyc`.  L'importation ZIP de modules dynamiques (:file:`.py`, :file:`.so`) "
"n'est pas permise. Notez que si une archive ne contient que des fichiers :"
"file:`.py`, Python n'essaiera pas de modifier l'archive en ajoutant le "
"fichier :file:`.pyc` correspondant, ce qui signifie que si une archive ZIP "
"ne contient pas de fichiers :file:`.pyc`, l'importation peut être assez "
"lente."

#: library/zipimport.rst:33
msgid "ZIP64 is supported"
msgstr ""

#: library/zipimport.rst:36
msgid "Previously, ZIP archives with an archive comment were not supported."
msgstr ""
"auparavant, les archives ZIP avec un commentaire d’archive n’étaient pas "
"prises en charge."

#: library/zipimport.rst:41
msgid ""
"`PKZIP Application Note <https://pkware.cachefly.net/webdocs/casestudies/"
"APPNOTE.TXT>`_"
msgstr ""
"`PKZIP Application Note <https://pkware.cachefly.net/webdocs/casestudies/"
"APPNOTE.TXT>`_"

#: library/zipimport.rst:42
msgid ""
"Documentation on the ZIP file format by Phil Katz, the creator of the format "
"and algorithms used."
msgstr ""
"Documentation sur le format de fichier ZIP par Phil Katz, créateur du format "
"et des algorithmes utilisés."

#: library/zipimport.rst:45
msgid ":pep:`273` - Import Modules from Zip Archives"
msgstr ":pep:`273` — Importation de modules depuis des archives ZIP"

#: library/zipimport.rst:46
msgid ""
"Written by James C. Ahlstrom, who also provided an implementation. Python "
"2.3 follows the specification in :pep:`273`, but uses an implementation "
"written by Just van Rossum that uses the import hooks described in :pep:"
"`302`."
msgstr ""
"Écrit par James C. Ahlstrom, qui a également fourni une mise en œuvre. "
"Python 2.3 suit les spécifications de :pep:`273`, mais utilise une "
"implémentation écrite par Just van Rossum qui utilise les crochets "
"d'importation décrits dans :pep:`302`."

#: library/zipimport.rst:50
msgid ":mod:`importlib` - The implementation of the import machinery"
msgstr ":mod:`importlib` — Implémentation du système d'importation"

#: library/zipimport.rst:51
msgid ""
"Package providing the relevant protocols for all importers to implement."
msgstr ""
"Paquet qui définit les protocoles que doivent implémenter tous les objets "
"importateurs."

#: library/zipimport.rst:55
msgid "This module defines an exception:"
msgstr "Ce module définit une exception :"

#: library/zipimport.rst:59
msgid ""
"Exception raised by zipimporter objects. It's a subclass of :exc:"
"`ImportError`, so it can be caught as :exc:`ImportError`, too."
msgstr ""
"Exception levée par les objets *zipimporter*. C'est une sous-classe de :exc:"
"`ImportError`, donc elle peut être aussi interceptée comme une :exc:"
"`ImportError`."

#: library/zipimport.rst:66
msgid "zipimporter Objects"
msgstr "Objets *zimporter*"

#: library/zipimport.rst:68
msgid ":class:`zipimporter` is the class for importing ZIP files."
msgstr ":class:`zipimporter` est la classe pour importer des fichiers ZIP."

#: library/zipimport.rst:72
msgid ""
"Create a new zipimporter instance. *archivepath* must be a path to a ZIP "
"file, or to a specific path within a ZIP file.  For example, an "
"*archivepath* of :file:`foo/bar.zip/lib` will look for modules in the :file:"
"`lib` directory inside the ZIP file :file:`foo/bar.zip` (provided that it "
"exists)."
msgstr ""
"Classe d'objets qui importent depuis les archives. Dans le constructeur, "
"*archivepath* doit être un chemin vers un fichier ZIP, éventuellement "
"augmenté d'un chemin à l'intérieur de l'archive.  Par exemple, un "
"*archivepath* de :file:`foo/bar.zip/lib` cherchera les modules dans le "
"répertoire :file:`lib` du fichier ZIP :file:`foo/bar.zip` (à supposer que ce "
"répertoire existe)."

#: library/zipimport.rst:77
msgid ""
":exc:`ZipImportError` is raised if *archivepath* doesn't point to a valid "
"ZIP archive."
msgstr ""
":exc:`ZipImportError` est levée si *archivepath* ne pointe pas vers une "
"archive ZIP valide."

#: library/zipimport.rst:82
msgid ""
"Methods ``find_loader()`` and ``find_module()``, deprecated in 3.10 are now "
"removed.  Use :meth:`find_spec` instead."
msgstr ""

#: library/zipimport.rst:87
msgid ""
"Implementation of :meth:`importlib.abc.Loader.create_module` that returns :"
"const:`None` to explicitly request the default semantics."
msgstr ""
"Implémentation de :meth:`importlib.abc.Loader.create_module`. Elle renvoie "
"toujours :const:`None`, ce qui déclenche le mécanisme standard."

#: library/zipimport.rst:95
msgid "Implementation of :meth:`importlib.abc.Loader.exec_module`."
msgstr "Implémentation de :meth:`importlib.abc.Loader.exec_module`."

#: library/zipimport.rst:102
msgid "An implementation of :meth:`importlib.abc.PathEntryFinder.find_spec`."
msgstr "Implémentation de :meth:`importlib.abc.PathEntryFinder.find_spec`."

#: library/zipimport.rst:109
msgid ""
"Return the code object for the specified module. Raise :exc:`ZipImportError` "
"if the module couldn't be imported."
msgstr ""
"Renvoie l'objet de code pour le module spécifié. Lève :exc:`ZipImportError` "
"si l'importation a échoué."

#: library/zipimport.rst:115
msgid ""
"Return the data associated with *pathname*. Raise :exc:`OSError` if the file "
"wasn't found."
msgstr ""
"Renvoie les données associées à *pathname*. Lève :exc:`OSError` si le "
"fichier n'a pas été trouvé."

#: library/zipimport.rst:118
#, fuzzy
msgid ":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr ""
"précédemment, c'était l'exception :exc:`IOError` qui était levée, au lieu "
"de :exc:`OSError`."

#: library/zipimport.rst:124
msgid ""
"Return the value ``__file__`` would be set to if the specified module was "
"imported. Raise :exc:`ZipImportError` if the module couldn't be imported."
msgstr ""
"Renvoie la valeur ``__file____`` qui serait définie si le module spécifié "
"était importé. Lève :exc:`ZipImportError` si l'importation a échoué."

#: library/zipimport.rst:133
msgid ""
"Return the source code for the specified module. Raise :exc:`ZipImportError` "
"if the module couldn't be found, return :const:`None` if the archive does "
"contain the module, but has no source for it."
msgstr ""
"Renvoie le code source du module spécifié. Lève :exc:`ZipImportError` si le "
"module n'a pas pu être trouvé, renvoie :const:`None` si l'archive contient "
"le module, mais n'en a pas la source."

#: library/zipimport.rst:141
msgid ""
"Return ``True`` if the module specified by *fullname* is a package. Raise :"
"exc:`ZipImportError` if the module couldn't be found."
msgstr ""
"Renvoie ``True`` si le module spécifié par *fullname* est un paquet. Lève :"
"exc:`ZipImportError` si le module n'a pas pu être trouvé."

#: library/zipimport.rst:147
msgid ""
"Load the module specified by *fullname*. *fullname* must be the fully "
"qualified (dotted) module name. Returns the imported module on success, "
"raises :exc:`ZipImportError` on failure."
msgstr ""
"Charge et renvoie le module spécifié par *fullname*, qui doit être le nom du "
"module entièrement qualifié (avec des points). Lève :exc:`ZipImportError` si "
"l'importation a échoué."

#: library/zipimport.rst:153
msgid "Use :meth:`exec_module` instead."
msgstr "utilisez plutôt :meth:`exec_module`."

#: library/zipimport.rst:158
msgid ""
"Clear out the internal cache of information about files found within the ZIP "
"archive."
msgstr ""
"Efface le cache interne des informations sur les fichiers à l'intérieur de "
"l'archive ZIP."

#: library/zipimport.rst:166
msgid ""
"The file name of the importer's associated ZIP file, without a possible "
"subpath."
msgstr ""
"Le nom de fichier de l'archive ZIP associé à l'importateur, sans sous-chemin "
"à l'intérieur."

#: library/zipimport.rst:172
msgid ""
"The subpath within the ZIP file where modules are searched.  This is the "
"empty string for zipimporter objects which point to the root of the ZIP file."
msgstr ""
"Le sous-chemin du fichier ZIP où les modules sont recherchés.  C'est la "
"chaîne vide pour les objets *zipimporter* qui pointent vers la racine du "
"fichier ZIP."

#: library/zipimport.rst:176
msgid ""
"The :attr:`archive` and :attr:`prefix` attributes, when combined with a "
"slash, equal the original *archivepath* argument given to the :class:"
"`zipimporter` constructor."
msgstr ""
"On a schématiquement :attr:`archive` + ``'/'`` + :attr:`prefix` == "
"*archivepath*, où *archivepath* est l'argument donné au constructeur :class:"
"`zipimporter`."

#: library/zipimport.rst:184
msgid "Examples"
msgstr "Exemples"

#: library/zipimport.rst:186
msgid ""
"Here is an example that imports a module from a ZIP archive - note that the :"
"mod:`zipimport` module is not explicitly used."
msgstr ""
"Voici un exemple qui importe un module d'une archive ZIP — notez que le "
"module :mod:`zipimport` n'est pas explicitement utilisé."

#: library/zipimport.rst:189
msgid ""
"$ unzip -l example.zip\n"
"Archive:  example.zip\n"
"  Length     Date   Time    Name\n"
" --------    ----   ----    ----\n"
"     8467  11-26-02 22:30   jwzthreading.py\n"
" --------                   -------\n"
"     8467                   1 file\n"
"$ ./python\n"
"Python 2.3 (#1, Aug 1 2003, 19:54:32)\n"
">>> import sys\n"
">>> sys.path.insert(0, 'example.zip')  # Add .zip file to front of path\n"
">>> import jwzthreading\n"
">>> jwzthreading.__file__\n"
"'example.zip/jwzthreading.py'"
msgstr ""

#~ msgid ""
#~ "An implementation of :meth:`importlib.abc.PathEntryFinder.find_loader`."
#~ msgstr ""
#~ "Implémentation de :meth:`importlib.abc.PathEntryFinder.find_loader`."

#~ msgid "Use :meth:`find_spec` instead."
#~ msgstr "utilisez plutôt :meth:`find_spec`."

#~ msgid ""
#~ "Search for a module specified by *fullname*. *fullname* must be the fully "
#~ "qualified (dotted) module name. It returns the zipimporter instance "
#~ "itself if the module was found, or :const:`None` if it wasn't. The "
#~ "optional *path* argument is ignored---it's there for compatibility with "
#~ "the importer protocol."
#~ msgstr ""
#~ "Recherche un module spécifié par *fullname*, qui doit être le nom du "
#~ "module entièrement qualifié (avec des points). La valeur renvoyée est "
#~ "l'instance de *zipimporter* elle-même si le module a été trouvé, ou :"
#~ "const:`None` si ce n'est pas le cas. L'argument optionnel *path* est "
#~ "ignoré ; il est là pour la compatibilité avec le protocole de "
#~ "l'importateur."

#~ msgid ":pep:`302` - New Import Hooks"
#~ msgstr ":pep:`302` — Nouveaux crochets d'importation"

#~ msgid "The PEP to add the import hooks that help this module work."
#~ msgstr ""
#~ "Le PEP pour ajouter les crochets d'importation qui aident ce module à "
#~ "fonctionner."
