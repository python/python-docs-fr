# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-01 00:16+0100\n"
"PO-Revision-Date: 2023-06-11 22:26+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/asyncio-queue.rst:7
msgid "Queues"
msgstr "Files d'attente (*queues*)"

#: library/asyncio-queue.rst:9
msgid "**Source code:** :source:`Lib/asyncio/queues.py`"
msgstr "**Code source :** :source:`Lib/asyncore.py`"

#: library/asyncio-queue.rst:13
msgid ""
"asyncio queues are designed to be similar to classes of the :mod:`queue` "
"module.  Although asyncio queues are not thread-safe, they are designed to "
"be used specifically in async/await code."
msgstr ""
"Les files d'attente *asyncio* sont conçues pour être similaires aux classes "
"du module :mod:`queue`. Bien que les files d'attente *asyncio* ne soient pas "
"compatibles avec les programmes à multiples fils d'exécution, elles sont "
"conçues pour être utilisées spécifiquement dans le code *async/await*."

#: library/asyncio-queue.rst:17
msgid ""
"Note that methods of asyncio queues don't have a *timeout* parameter; use :"
"func:`asyncio.wait_for` function to do queue operations with a timeout."
msgstr ""
"Notez que les méthodes des files d'attente *asyncio* n'ont pas de paramètre "
"*timeout* ; utilisez la fonction :func:`asyncio.wait_for` pour effectuer des "
"opérations de file d'attente avec un délai d'attente."

#: library/asyncio-queue.rst:21
msgid "See also the `Examples`_ section below."
msgstr "Voir également la section `Exemples`_ ci-dessous."

#: library/asyncio-queue.rst:24
msgid "Queue"
msgstr "File d'attente (*queue*)"

#: library/asyncio-queue.rst:28
msgid "A first in, first out (FIFO) queue."
msgstr ""
"File d'attente premier entré, premier sorti (FIFO pour *fist in, first out*)."

#: library/asyncio-queue.rst:30
msgid ""
"If *maxsize* is less than or equal to zero, the queue size is infinite.  If "
"it is an integer greater than ``0``, then ``await put()`` blocks when the "
"queue reaches *maxsize* until an item is removed by :meth:`get`."
msgstr ""
"Si *maxsize* est inférieur ou égal à zéro, la taille de la file d'attente "
"est infinie. Si c'est un entier supérieur à ``0``, alors ``await put()`` se "
"bloque lorsque la file d'attente atteint *maxsize* jusqu'à ce qu'un élément "
"soit supprimé par :meth:`get`."

#: library/asyncio-queue.rst:35
msgid ""
"Unlike the standard library threading :mod:`queue`, the size of the queue is "
"always known and can be returned by calling the :meth:`qsize` method."
msgstr ""
"Contrairement à la bibliothèque standard multi-fils :mod:`queue`, la taille "
"de la file d'attente est toujours connue et peut être renvoyée en appelant "
"la méthode :meth:`qsize`."

# suit un :
#: library/asyncio-queue.rst:39
msgid "Removed the *loop* parameter."
msgstr "suppression du paramètre *loop*."

#: library/asyncio-queue.rst:43
msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"Cette classe n'est :ref:`pas compatible avec les fils d'exécution multiples "
"<asyncio-multithreading>`."

#: library/asyncio-queue.rst:47
msgid "Number of items allowed in the queue."
msgstr "Nombre d'éléments autorisés dans la file d'attente."

#: library/asyncio-queue.rst:51
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Renvoie ``True`` si la file d'attente est vide, ``False`` sinon."

#: library/asyncio-queue.rst:55
msgid "Return ``True`` if there are :attr:`maxsize` items in the queue."
msgstr ""
"Renvoie ``True`` s'il y a :attr:`maxsize` éléments dans la file d'attente."

#: library/asyncio-queue.rst:57
#, fuzzy
msgid ""
"If the queue was initialized with ``maxsize=0`` (the default), then :meth:"
"`full` never returns ``True``."
msgstr ""
"Si la file d'attente a été initialisée avec ``maxsize=0`` (la valeur par "
"défaut), alors :meth:`full()` ne renvoie jamais ``True``."

#: library/asyncio-queue.rst:62
msgid ""
"Remove and return an item from the queue. If queue is empty, wait until an "
"item is available."
msgstr ""
"Supprime et renvoie un élément de la file d'attente. Si la file d'attente "
"est vide, attend qu'un élément soit disponible."

#: library/asyncio-queue.rst:65
msgid ""
"Raises :exc:`QueueShutDown` if the queue has been shut down and is empty, or "
"if the queue has been shut down immediately."
msgstr ""

#: library/asyncio-queue.rst:70
msgid ""
"Return an item if one is immediately available, else raise :exc:`QueueEmpty`."
msgstr ""
"Renvoie un élément s'il y en a un immédiatement disponible, sinon lève :exc:"
"`QueueEmpty`."

#: library/asyncio-queue.rst:75
msgid "Block until all items in the queue have been received and processed."
msgstr ""
"Bloque jusqu'à ce que tous les éléments de la file d'attente aient été "
"récupérés et traités."

#: library/asyncio-queue.rst:77
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer coroutine calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""
"Le nombre de tâches inachevées augmente chaque fois qu'un élément est ajouté "
"à la file. Ce nombre diminue chaque fois qu'un fil d'exécution consommateur "
"appelle :meth:`task_done` pour indiquer que l'élément a été extrait et que "
"tout le travail à effectuer dessus est terminé. Lorsque le nombre de tâches "
"non terminées devient nul, :meth:`join` débloque."

#: library/asyncio-queue.rst:85
msgid ""
"Put an item into the queue. If the queue is full, wait until a free slot is "
"available before adding the item."
msgstr ""
"Met un élément dans la file d'attente. Si la file d'attente est pleine, "
"attend qu'un emplacement libre soit disponible avant d'ajouter l'élément."

#: library/asyncio-queue.rst:88
msgid "Raises :exc:`QueueShutDown` if the queue has been shut down."
msgstr ""

#: library/asyncio-queue.rst:92
msgid "Put an item into the queue without blocking."
msgstr "Ajoute un élément dans la file d'attente sans bloquer."

#: library/asyncio-queue.rst:94
msgid "If no free slot is immediately available, raise :exc:`QueueFull`."
msgstr ""
"Si aucun emplacement libre n'est immédiatement disponible, lève :exc:"
"`QueueFull`."

#: library/asyncio-queue.rst:98
msgid "Return the number of items in the queue."
msgstr "Renvoie le nombre d'éléments dans la file d'attente."

#: library/asyncio-queue.rst:102
msgid ""
"Shut down the queue, making :meth:`~Queue.get` and :meth:`~Queue.put` raise :"
"exc:`QueueShutDown`."
msgstr ""

#: library/asyncio-queue.rst:105
msgid ""
"By default, :meth:`~Queue.get` on a shut down queue will only raise once the "
"queue is empty. Set *immediate* to true to make :meth:`~Queue.get` raise "
"immediately instead."
msgstr ""

#: library/asyncio-queue.rst:109
msgid ""
"All blocked callers of :meth:`~Queue.put` and :meth:`~Queue.get` will be "
"unblocked. If *immediate* is true, a task will be marked as done for each "
"remaining item in the queue, which may unblock callers of :meth:`~Queue."
"join`."
msgstr ""

#: library/asyncio-queue.rst:118
msgid "Indicate that a formerly enqueued task is complete."
msgstr "Indique qu'une tâche précédemment mise en file d'attente est terminée."

#: library/asyncio-queue.rst:120
msgid ""
"Used by queue consumers. For each :meth:`~Queue.get` used to fetch a task, a "
"subsequent call to :meth:`task_done` tells the queue that the processing on "
"the task is complete."
msgstr ""
"Utilisé par les consommateurs de file d'attente. Pour chaque :meth:`~Queue."
"get` utilisé pour récupérer une tâche, un appel ultérieur à :meth:"
"`task_done` indique à la file d'attente que le traitement de la tâche est "
"terminé."

#: library/asyncio-queue.rst:124
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Si un :meth:`join` est actuellement bloquant, on reprendra lorsque tous les "
"éléments auront été traités (ce qui signifie qu'un appel à :meth:`task_done` "
"a été effectué pour chaque élément qui a été :meth:`put` dans la file)."

#: library/asyncio-queue.rst:129
msgid ""
"``shutdown(immediate=True)`` calls :meth:`task_done` for each remaining item "
"in the queue."
msgstr ""

#: library/asyncio-queue.rst:132
msgid ""
"Raises :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Lève une exception :exc:`ValueError` si elle est appelée plus de fois qu'il "
"n'y avait d'éléments dans la file."

#: library/asyncio-queue.rst:137
msgid "Priority Queue"
msgstr "File avec priorité"

#: library/asyncio-queue.rst:141
msgid ""
"A variant of :class:`Queue`; retrieves entries in priority order (lowest "
"first)."
msgstr ""
"Une variante de :class:`Queue` ; récupère les entrées par ordre de priorité "
"(la plus basse en premier)."

#: library/asyncio-queue.rst:144
msgid "Entries are typically tuples of the form ``(priority_number, data)``."
msgstr ""
"Les entrées sont généralement des *n*-uplets de la forme ``(priority_number, "
"data)``."

#: library/asyncio-queue.rst:149
msgid "LIFO Queue"
msgstr "Pile (LIFO)"

#: library/asyncio-queue.rst:153
msgid ""
"A variant of :class:`Queue` that retrieves most recently added entries first "
"(last in, first out)."
msgstr ""
"Une variante de :class:`Queue` qui récupère en premier les entrées les plus "
"récemment ajoutées (dernier entré, premier sorti)."

#: library/asyncio-queue.rst:158
msgid "Exceptions"
msgstr "Exceptions"

#: library/asyncio-queue.rst:162
msgid ""
"This exception is raised when the :meth:`~Queue.get_nowait` method is called "
"on an empty queue."
msgstr ""
"Cette exception est levée  lorsque la méthode :meth:`~Queue.get_nowait` est "
"appelée sur une file d'attente vide."

#: library/asyncio-queue.rst:168
msgid ""
"Exception raised when the :meth:`~Queue.put_nowait` method is called on a "
"queue that has reached its *maxsize*."
msgstr ""
"Exception levée lorsque la méthode :meth:`~Queue.put_nowait` est appelée sur "
"une file d'attente qui a atteint sa *maxsize*."

#: library/asyncio-queue.rst:174
#, fuzzy
msgid ""
"Exception raised when :meth:`~Queue.put` or :meth:`~Queue.get` is called on "
"a queue which has been shut down."
msgstr ""
"Exception levée lorsque la méthode :meth:`~Queue.put_nowait` est appelée sur "
"une file d'attente qui a atteint sa *maxsize*."

#: library/asyncio-queue.rst:181
msgid "Examples"
msgstr "Exemples"

#: library/asyncio-queue.rst:185
msgid ""
"Queues can be used to distribute workload between several concurrent tasks::"
msgstr ""
"Les files d'attente peuvent être utilisées pour répartir la charge de "
"travail entre plusieurs tâches simultanées ::"
