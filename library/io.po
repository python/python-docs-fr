# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/library/io.rst:2
msgid ":mod:`io` --- Core tools for working with streams"
msgstr ""

#: ../Doc/library/io.rst:16
msgid ""
"The :mod:`io` module provides the Python interfaces to stream handling. "
"Under Python 2.x, this is proposed as an alternative to the built-in :class:"
"`file` object, but in Python 3.x it is the default interface to access files "
"and streams."
msgstr ""

#: ../Doc/library/io.rst:23
msgid ""
"Since this module has been designed primarily for Python 3.x, you have to be "
"aware that all uses of \"bytes\" in this document refer to the :class:`str` "
"type (of which :class:`bytes` is an alias), and all uses of \"text\" refer "
"to the :class:`unicode` type.  Furthermore, those two types are not "
"interchangeable in the :mod:`io` APIs."
msgstr ""

#: ../Doc/library/io.rst:29
msgid ""
"At the top of the I/O hierarchy is the abstract base class :class:`IOBase`.  "
"It defines the basic interface to a stream.  Note, however, that there is no "
"separation between reading and writing to streams; implementations are "
"allowed to raise an :exc:`IOError` if they do not support a given operation."
msgstr ""

#: ../Doc/library/io.rst:34
msgid ""
"Extending :class:`IOBase` is :class:`RawIOBase` which deals simply with the "
"reading and writing of raw bytes to a stream.  :class:`FileIO` subclasses :"
"class:`RawIOBase` to provide an interface to files in the machine's file "
"system."
msgstr ""

#: ../Doc/library/io.rst:39
msgid ""
":class:`BufferedIOBase` deals with buffering on a raw byte stream (:class:"
"`RawIOBase`).  Its subclasses, :class:`BufferedWriter`, :class:"
"`BufferedReader`, and :class:`BufferedRWPair` buffer streams that are "
"readable, writable, and both readable and writable. :class:`BufferedRandom` "
"provides a buffered interface to random access streams.  :class:`BytesIO` is "
"a simple stream of in-memory bytes."
msgstr ""

#: ../Doc/library/io.rst:46
msgid ""
"Another :class:`IOBase` subclass, :class:`TextIOBase`, deals with streams "
"whose bytes represent text, and handles encoding and decoding from and to :"
"class:`unicode` strings.  :class:`TextIOWrapper`, which extends it, is a "
"buffered text interface to a buffered raw stream (:class:`BufferedIOBase`). "
"Finally, :class:`StringIO` is an in-memory stream for unicode text."
msgstr ""

#: ../Doc/library/io.rst:53
msgid ""
"Argument names are not part of the specification, and only the arguments of :"
"func:`.open` are intended to be used as keyword arguments."
msgstr ""

#: ../Doc/library/io.rst:58
msgid "Module Interface"
msgstr ""

#: ../Doc/library/io.rst:62
msgid ""
"An int containing the default buffer size used by the module's buffered I/O "
"classes.  :func:`.open` uses the file's blksize (as obtained by :func:`os."
"stat`) if possible."
msgstr ""

#: ../Doc/library/io.rst:68
msgid ""
"Open *file* and return a corresponding stream.  If the file cannot be "
"opened, an :exc:`IOError` is raised."
msgstr ""

#: ../Doc/library/io.rst:71
msgid ""
"*file* is either a string giving the pathname (absolute or relative to the "
"current working directory) of the file to be opened or an integer file "
"descriptor of the file to be wrapped.  (If a file descriptor is given, it is "
"closed when the returned I/O object is closed, unless *closefd* is set to "
"``False``.)"
msgstr ""

#: ../Doc/library/io.rst:77
msgid ""
"*mode* is an optional string that specifies the mode in which the file is "
"opened.  It defaults to ``'r'`` which means open for reading in text mode. "
"Other common values are ``'w'`` for writing (truncating the file if it "
"already exists), and ``'a'`` for appending (which on *some* Unix systems, "
"means that *all* writes append to the end of the file regardless of the "
"current seek position).  In text mode, if *encoding* is not specified the "
"encoding used is platform dependent. (For reading and writing raw bytes use "
"binary mode and leave *encoding* unspecified.)  The available modes are:"
msgstr ""

#: ../Doc/library/io.rst:87
msgid "Character"
msgstr "Caractère"

#: ../Doc/library/io.rst:87
msgid "Meaning"
msgstr "Signification"

#: ../Doc/library/io.rst:89
msgid "``'r'``"
msgstr "``'r'``"

#: ../Doc/library/io.rst:89
msgid "open for reading (default)"
msgstr "ouvre en lecture (par défaut)"

#: ../Doc/library/io.rst:90
msgid "``'w'``"
msgstr "``'w'``"

#: ../Doc/library/io.rst:90
msgid "open for writing, truncating the file first"
msgstr "ouvre en écriture, tronquant le fichier"

#: ../Doc/library/io.rst:91
msgid "``'a'``"
msgstr "``'a'``"

#: ../Doc/library/io.rst:91
msgid "open for writing, appending to the end of the file if it exists"
msgstr "ouvre en écriture, ajoutant à la fin du fichier s'il existe"

#: ../Doc/library/io.rst:92
msgid "``'b'``"
msgstr "``'b'``"

#: ../Doc/library/io.rst:92
msgid "binary mode"
msgstr "mode binaire"

#: ../Doc/library/io.rst:93
msgid "``'t'``"
msgstr "``'t'``"

#: ../Doc/library/io.rst:93
msgid "text mode (default)"
msgstr "mode texte (par défaut)"

#: ../Doc/library/io.rst:94
msgid "``'+'``"
msgstr "``'+'``"

#: ../Doc/library/io.rst:94
msgid "open a disk file for updating (reading and writing)"
msgstr "ouvre un fichier pour le modifier (lire et écrire)"

#: ../Doc/library/io.rst:95
msgid "``'U'``"
msgstr "``'U'``"

#: ../Doc/library/io.rst:95
msgid ""
"universal newlines mode (for backwards compatibility; should not be used in "
"new code)"
msgstr ""

#: ../Doc/library/io.rst:99
msgid ""
"The default mode is ``'rt'`` (open for reading text).  For binary random "
"access, the mode ``'w+b'`` opens and truncates the file to 0 bytes, while "
"``'r+b'`` opens the file without truncation."
msgstr ""

#: ../Doc/library/io.rst:103
msgid ""
"Python distinguishes between files opened in binary and text modes, even "
"when the underlying operating system doesn't.  Files opened in binary mode "
"(including ``'b'`` in the *mode* argument) return contents as :class:`bytes` "
"objects without any decoding.  In text mode (the default, or when ``'t'`` is "
"included in the *mode* argument), the contents of the file are returned as :"
"class:`unicode` strings, the bytes having been first decoded using a "
"platform-dependent encoding or using the specified *encoding* if given."
msgstr ""

#: ../Doc/library/io.rst:111
msgid ""
"*buffering* is an optional integer used to set the buffering policy. Pass 0 "
"to switch buffering off (only allowed in binary mode), 1 to select line "
"buffering (only usable in text mode), and an integer > 1 to indicate the "
"size of a fixed-size chunk buffer.  When no *buffering* argument is given, "
"the default buffering policy works as follows:"
msgstr ""

#: ../Doc/library/io.rst:117
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is "
"chosen using a heuristic trying to determine the underlying device's \"block "
"size\" and falling back on :attr:`DEFAULT_BUFFER_SIZE`. On many systems, the "
"buffer will typically be 4096 or 8192 bytes long."
msgstr ""

#: ../Doc/library/io.rst:122
msgid ""
"\"Interactive\" text files (files for which :meth:`isatty` returns True) use "
"line buffering.  Other text files use the policy described above for binary "
"files."
msgstr ""

#: ../Doc/library/io.rst:126
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file. "
"This should only be used in text mode.  The default encoding is platform "
"dependent (whatever :func:`locale.getpreferredencoding` returns), but any "
"encoding supported by Python can be used.  See the :mod:`codecs` module for "
"the list of supported encodings."
msgstr ""

#: ../Doc/library/io.rst:132
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled--this cannot be used in binary mode.  Pass "
"``'strict'`` to raise a :exc:`ValueError` exception if there is an encoding "
"error (the default of ``None`` has the same effect), or pass ``'ignore'`` to "
"ignore errors.  (Note that ignoring encoding errors can lead to data loss.) "
"``'replace'`` causes a replacement marker (such as ``'?'``) to be inserted "
"where there is malformed data.  When writing, ``'xmlcharrefreplace'`` "
"(replace with the appropriate XML character reference) or "
"``'backslashreplace'`` (replace with backslashed escape sequences) can be "
"used.  Any other error handling name that has been registered with :func:"
"`codecs.register_error` is also valid."
msgstr ""

#: ../Doc/library/io.rst:147
msgid ""
"*newline* controls how :term:`universal newlines` works (it only applies to "
"text mode).  It can be ``None``, ``''``, ``'\\n'``, ``'\\r'``, and ``'\\r"
"\\n'``. It works as follows:"
msgstr ""

#: ../Doc/library/io.rst:151
msgid ""
"On input, if *newline* is ``None``, universal newlines mode is enabled. "
"Lines in the input can end in ``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and "
"these are translated into ``'\\n'`` before being returned to the caller.  If "
"it is ``''``, universal newlines mode is enabled, but line endings are "
"returned to the caller untranslated.  If it has any of the other legal "
"values, input lines are only terminated by the given string, and the line "
"ending is returned to the caller untranslated."
msgstr ""

#: ../Doc/library/io.rst:159 ../Doc/library/io.rst:805
msgid ""
"On output, if *newline* is ``None``, any ``'\\n'`` characters written are "
"translated to the system default line separator, :data:`os.linesep`.  If "
"*newline* is ``''``, no translation takes place.  If *newline* is any of the "
"other legal values, any ``'\\n'`` characters written are translated to the "
"given string."
msgstr ""

#: ../Doc/library/io.rst:165
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename was "
"given, the underlying file descriptor will be kept open when the file is "
"closed.  If a filename is given *closefd* has no effect and must be ``True`` "
"(the default)."
msgstr ""

#: ../Doc/library/io.rst:170
msgid ""
"The type of file object returned by the :func:`.open` function depends on "
"the mode.  When :func:`.open` is used to open a file in a text mode "
"(``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass of :"
"class:`TextIOBase` (specifically :class:`TextIOWrapper`).  When used to open "
"a file in a binary mode with buffering, the returned class is a subclass of :"
"class:`BufferedIOBase`.  The exact class varies: in read binary mode, it "
"returns a :class:`BufferedReader`; in write binary and append binary modes, "
"it returns a :class:`BufferedWriter`, and in read/write mode, it returns a :"
"class:`BufferedRandom`.  When buffering is disabled, the raw stream, a "
"subclass of :class:`RawIOBase`, :class:`FileIO`, is returned."
msgstr ""

#: ../Doc/library/io.rst:181
msgid ""
"It is also possible to use an :class:`unicode` or :class:`bytes` string as a "
"file for both reading and writing.  For :class:`unicode` strings :class:"
"`StringIO` can be used like a file opened in text mode, and for :class:"
"`bytes` a :class:`BytesIO` can be used like a file opened in a binary mode."
msgstr ""

#: ../Doc/library/io.rst:190
msgid ""
"Error raised when blocking would occur on a non-blocking stream.  It "
"inherits :exc:`IOError`."
msgstr ""

#: ../Doc/library/io.rst:193
msgid ""
"In addition to those of :exc:`IOError`, :exc:`BlockingIOError` has one "
"attribute:"
msgstr ""

#: ../Doc/library/io.rst:198
msgid ""
"An integer containing the number of characters written to the stream before "
"it blocked."
msgstr ""

#: ../Doc/library/io.rst:204
msgid ""
"An exception inheriting :exc:`IOError` and :exc:`ValueError` that is raised "
"when an unsupported operation is called on a stream."
msgstr ""

#: ../Doc/library/io.rst:209
msgid "I/O Base Classes"
msgstr ""

#: ../Doc/library/io.rst:213
msgid ""
"The abstract base class for all I/O classes, acting on streams of bytes. "
"There is no public constructor."
msgstr ""

#: ../Doc/library/io.rst:216
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr ""

#: ../Doc/library/io.rst:221
msgid ""
"Even though :class:`IOBase` does not declare :meth:`read`, :meth:`readinto`, "
"or :meth:`write` because their signatures will vary, implementations and "
"clients should consider those methods part of the interface.  Also, "
"implementations may raise an :exc:`IOError` when operations they do not "
"support are called."
msgstr ""

#: ../Doc/library/io.rst:227
msgid ""
"The basic type used for binary data read from or written to a file is :class:"
"`bytes` (also known as :class:`str`).  Method arguments may also be :class:"
"`bytearray` or :class:`memoryview` of arrays of bytes. In some cases, such "
"as :meth:`~RawIOBase.readinto`, a writable object such as :class:`bytearray` "
"is required. Text I/O classes work with :class:`unicode` data."
msgstr ""

#: ../Doc/library/io.rst:234
msgid "Implementations should support :class:`memoryview` arguments."
msgstr ""

#: ../Doc/library/io.rst:237
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`IOError` in this case."
msgstr ""

#: ../Doc/library/io.rst:240
msgid ""
"IOBase (and its subclasses) support the iterator protocol, meaning that an :"
"class:`IOBase` object can be iterated over yielding the lines in a stream. "
"Lines are defined slightly differently depending on whether the stream is a "
"binary stream (yielding :class:`bytes`), or a text stream (yielding :class:"
"`unicode` strings).  See :meth:`~IOBase.readline` below."
msgstr ""

#: ../Doc/library/io.rst:246
msgid ""
"IOBase is also a context manager and therefore supports the :keyword:`with` "
"statement.  In this example, *file* is closed after the :keyword:`with` "
"statement's suite is finished---even if an exception occurs::"
msgstr ""

#: ../Doc/library/io.rst:253
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ""

#: ../Doc/library/io.rst:257
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise a :exc:`ValueError`."
msgstr ""

#: ../Doc/library/io.rst:261
msgid ""
"As a convenience, it is allowed to call this method more than once; only the "
"first call, however, will have an effect."
msgstr ""

#: ../Doc/library/io.rst:266
msgid "True if the stream is closed."
msgstr ""

#: ../Doc/library/io.rst:270
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`IOError` is raised if the IO object does not use a file "
"descriptor."
msgstr ""

#: ../Doc/library/io.rst:276
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing for "
"read-only and non-blocking streams."
msgstr ""

#: ../Doc/library/io.rst:281
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a terminal/"
"tty device)."
msgstr ""

#: ../Doc/library/io.rst:286
msgid ""
"Return ``True`` if the stream can be read from.  If ``False``, :meth:`read` "
"will raise :exc:`IOError`."
msgstr ""

#: ../Doc/library/io.rst:291
msgid ""
"Read and return one line from the stream.  If *limit* is specified, at most "
"*limit* bytes will be read."
msgstr ""

#: ../Doc/library/io.rst:294
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text files, "
"the *newline* argument to :func:`.open` can be used to select the line "
"terminator(s) recognized."
msgstr ""

#: ../Doc/library/io.rst:300
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified to "
"control the number of lines read: no more lines will be read if the total "
"size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr ""

#: ../Doc/library/io.rst:304
msgid ""
"Note that it's already possible to iterate on file objects using ``for line "
"in file: ...`` without calling ``file.readlines()``."
msgstr ""

#: ../Doc/library/io.rst:309
msgid ""
"Change the stream position to the given byte *offset*.  *offset* is "
"interpreted relative to the position indicated by *whence*.  The default "
"value for *whence* is :data:`SEEK_SET`.  Values for *whence* are:"
msgstr ""

#: ../Doc/library/io.rst:313
msgid ""
":data:`SEEK_SET` or ``0`` -- start of the stream (the default); *offset* "
"should be zero or positive"
msgstr ""

#: ../Doc/library/io.rst:315
msgid ""
":data:`SEEK_CUR` or ``1`` -- current stream position; *offset* may be "
"negative"
msgstr ""

#: ../Doc/library/io.rst:317
msgid ""
":data:`SEEK_END` or ``2`` -- end of the stream; *offset* is usually negative"
msgstr ""

#: ../Doc/library/io.rst:320
msgid "Return the new absolute position."
msgstr ""

#: ../Doc/library/io.rst:322
msgid "The ``SEEK_*`` constants"
msgstr ""

#: ../Doc/library/io.rst:327
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, :meth:"
"`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`IOError`."
msgstr ""

#: ../Doc/library/io.rst:332
msgid "Return the current stream position."
msgstr ""

#: ../Doc/library/io.rst:336
msgid ""
"Resize the stream to the given *size* in bytes (or the current position if "
"*size* is not specified).  The current stream position isn't changed. This "
"resizing can extend or reduce the current file size.  In case of extension, "
"the contents of the new file area depend on the platform (on most systems, "
"additional bytes are zero-filled, on Windows they're undetermined).  The new "
"file size is returned."
msgstr ""

#: ../Doc/library/io.rst:345
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, :meth:`write` "
"and :meth:`truncate` will raise :exc:`IOError`."
msgstr ""

#: ../Doc/library/io.rst:350
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so it "
"is usual for each of the lines provided to have a line separator at the end."
msgstr ""

#: ../Doc/library/io.rst:356
msgid ""
"Prepare for object destruction. :class:`IOBase` provides a default "
"implementation of this method that calls the instance's :meth:`~IOBase."
"close` method."
msgstr ""

#: ../Doc/library/io.rst:363
msgid ""
"Base class for raw binary I/O.  It inherits :class:`IOBase`.  There is no "
"public constructor."
msgstr ""

#: ../Doc/library/io.rst:366
msgid ""
"Raw binary I/O typically provides low-level access to an underlying OS "
"device or API, and does not try to encapsulate it in high-level primitives "
"(this is left to Buffered I/O and Text I/O, described later in this page)."
msgstr ""

#: ../Doc/library/io.rst:370
msgid ""
"In addition to the attributes and methods from :class:`IOBase`, RawIOBase "
"provides the following methods:"
msgstr ""

#: ../Doc/library/io.rst:375
msgid ""
"Read up to *n* bytes from the object and return them.  As a convenience, if "
"*n* is unspecified or -1, :meth:`readall` is called.  Otherwise, only one "
"system call is ever made.  Fewer than *n* bytes may be returned if the "
"operating system call returns fewer than *n* bytes."
msgstr ""

#: ../Doc/library/io.rst:380
msgid ""
"If 0 bytes are returned, and *n* was not 0, this indicates end of file. If "
"the object is in non-blocking mode and no bytes are available, ``None`` is "
"returned."
msgstr ""

#: ../Doc/library/io.rst:386
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr ""

#: ../Doc/library/io.rst:391
msgid ""
"Read up to len(b) bytes into *b*, and return the number of bytes read.  The "
"object *b* should be a pre-allocated, writable array of bytes, either :class:"
"`bytearray` or :class:`memoryview`. If the object is in non-blocking mode "
"and no bytes are available, ``None`` is returned."
msgstr ""

#: ../Doc/library/io.rst:399
msgid ""
"Write *b* to the underlying raw stream, and return the number of bytes "
"written.  The object *b* should be an array of bytes, either :class:"
"`bytes`, :class:`bytearray`, or :class:`memoryview`.  The return value can "
"be less than ``len(b)``, depending on specifics of the underlying raw "
"stream, and especially if it is in non-blocking mode.  ``None`` is returned "
"if the raw stream is set not to block and no single byte could be readily "
"written to it.  The caller may release or mutate *b* after this method "
"returns, so the implementation should only access *b* during the method call."
msgstr ""

#: ../Doc/library/io.rst:413
msgid ""
"Base class for binary streams that support some kind of buffering. It "
"inherits :class:`IOBase`. There is no public constructor."
msgstr ""

#: ../Doc/library/io.rst:416
msgid ""
"The main difference with :class:`RawIOBase` is that methods :meth:`read`, :"
"meth:`readinto` and :meth:`write` will try (respectively) to read as much "
"input as requested or to consume all given output, at the expense of making "
"perhaps more than one system call."
msgstr ""

#: ../Doc/library/io.rst:421
msgid ""
"In addition, those methods can raise :exc:`BlockingIOError` if the "
"underlying raw stream is in non-blocking mode and cannot take or give enough "
"data; unlike their :class:`RawIOBase` counterparts, they will never return "
"``None``."
msgstr ""

#: ../Doc/library/io.rst:426
msgid ""
"Besides, the :meth:`read` method does not have a default implementation that "
"defers to :meth:`readinto`."
msgstr ""

#: ../Doc/library/io.rst:429
msgid ""
"A typical :class:`BufferedIOBase` implementation should not inherit from a :"
"class:`RawIOBase` implementation, but wrap one, like :class:`BufferedWriter` "
"and :class:`BufferedReader` do."
msgstr ""

#: ../Doc/library/io.rst:433
msgid ""
":class:`BufferedIOBase` provides or overrides these methods and attribute in "
"addition to those from :class:`IOBase`:"
msgstr ""

#: ../Doc/library/io.rst:438
msgid ""
"The underlying raw stream (a :class:`RawIOBase` instance) that :class:"
"`BufferedIOBase` deals with.  This is not part of the :class:"
"`BufferedIOBase` API and may not exist on some implementations."
msgstr ""

#: ../Doc/library/io.rst:444
msgid "Separate the underlying raw stream from the buffer and return it."
msgstr ""

#: ../Doc/library/io.rst:446
msgid ""
"After the raw stream has been detached, the buffer is in an unusable state."
msgstr ""

#: ../Doc/library/io.rst:449
msgid ""
"Some buffers, like :class:`BytesIO`, do not have the concept of a single raw "
"stream to return from this method.  They raise :exc:`UnsupportedOperation`."
msgstr ""

#: ../Doc/library/io.rst:457
msgid ""
"Read and return up to *n* bytes.  If the argument is omitted, ``None``, or "
"negative, data is read and returned until EOF is reached.  An empty bytes "
"object is returned if the stream is already at EOF."
msgstr ""

#: ../Doc/library/io.rst:461
msgid ""
"If the argument is positive, and the underlying raw stream is not "
"interactive, multiple raw reads may be issued to satisfy the byte count "
"(unless EOF is reached first).  But for interactive raw streams, at most one "
"raw read will be issued, and a short result does not imply that EOF is "
"imminent."
msgstr ""

#: ../Doc/library/io.rst:467 ../Doc/library/io.rst:486
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream is in non "
"blocking-mode, and has no data available at the moment."
msgstr ""

#: ../Doc/library/io.rst:472
msgid ""
"Read and return up to *n* bytes, with at most one call to the underlying raw "
"stream's :meth:`~RawIOBase.read` method.  This can be useful if you are "
"implementing your own buffering on top of a :class:`BufferedIOBase` object."
msgstr ""

#: ../Doc/library/io.rst:479
msgid ""
"Read up to len(b) bytes into *b*, and return the number of bytes read. The "
"object *b* should be a pre-allocated, writable array of bytes, either :class:"
"`bytearray` or :class:`memoryview`."
msgstr ""

#: ../Doc/library/io.rst:483
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is 'interactive'."
msgstr ""

#: ../Doc/library/io.rst:491
msgid ""
"Write *b*, and return the number of bytes written (always equal to "
"``len(b)``, since if the write fails an :exc:`IOError` will be raised).  The "
"object *b* should be an array of bytes, either :class:`bytes`, :class:"
"`bytearray`, or :class:`memoryview`.  Depending on the actual "
"implementation, these bytes may be readily written to the underlying stream, "
"or held in a buffer for performance and latency reasons."
msgstr ""

#: ../Doc/library/io.rst:499
msgid ""
"When in non-blocking mode, a :exc:`BlockingIOError` is raised if the data "
"needed to be written to the raw stream but it couldn't accept all the data "
"without blocking."
msgstr ""

#: ../Doc/library/io.rst:503
msgid ""
"The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr ""

#: ../Doc/library/io.rst:508
msgid "Raw File I/O"
msgstr ""

#: ../Doc/library/io.rst:512
msgid ""
":class:`FileIO` represents an OS-level file containing bytes data. It "
"implements the :class:`RawIOBase` interface (and therefore the :class:"
"`IOBase` interface, too)."
msgstr ""

#: ../Doc/library/io.rst:516
msgid "The *name* can be one of two things:"
msgstr ""

#: ../Doc/library/io.rst:518
msgid "a string representing the path to the file which will be opened;"
msgstr ""

#: ../Doc/library/io.rst:519
msgid ""
"an integer representing the number of an existing OS-level file descriptor "
"to which the resulting :class:`FileIO` object will give access."
msgstr ""

#: ../Doc/library/io.rst:522
msgid ""
"The *mode* can be ``'r'``, ``'w'`` or ``'a'`` for reading (default), "
"writing, or appending.  The file will be created if it doesn't exist when "
"opened for writing or appending; it will be truncated when opened for "
"writing.  Add a ``'+'`` to the mode to allow simultaneous reading and "
"writing."
msgstr ""

#: ../Doc/library/io.rst:527
msgid ""
"The :meth:`read` (when called with a positive argument), :meth:`readinto` "
"and :meth:`write` methods on this class will only make one system call."
msgstr ""

#: ../Doc/library/io.rst:530
msgid ""
"In addition to the attributes and methods from :class:`IOBase` and :class:"
"`RawIOBase`, :class:`FileIO` provides the following data attributes and "
"methods:"
msgstr ""

#: ../Doc/library/io.rst:536
msgid "The mode as given in the constructor."
msgstr ""

#: ../Doc/library/io.rst:540
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr ""

#: ../Doc/library/io.rst:545
msgid "Buffered Streams"
msgstr ""

#: ../Doc/library/io.rst:547
msgid ""
"Buffered I/O streams provide a higher-level interface to an I/O device than "
"raw I/O does."
msgstr ""

#: ../Doc/library/io.rst:552
msgid ""
"A stream implementation using an in-memory bytes buffer.  It inherits :class:"
"`BufferedIOBase`."
msgstr ""

#: ../Doc/library/io.rst:555
msgid ""
"The optional argument *initial_bytes* is a :class:`bytes` object that "
"contains initial data."
msgstr ""

#: ../Doc/library/io.rst:558
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those "
"from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""

#: ../Doc/library/io.rst:563
msgid "Return ``bytes`` containing the entire contents of the buffer."
msgstr ""

#: ../Doc/library/io.rst:567
msgid "In :class:`BytesIO`, this is the same as :meth:`read`."
msgstr ""

#: ../Doc/library/io.rst:572
msgid ""
"A buffer providing higher-level access to a readable, sequential :class:"
"`RawIOBase` object.  It inherits :class:`BufferedIOBase`. When reading data "
"from this object, a larger amount of data may be requested from the "
"underlying raw stream, and kept in an internal buffer. The buffered data can "
"then be returned directly on subsequent reads."
msgstr ""

#: ../Doc/library/io.rst:578
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, :data:"
"`DEFAULT_BUFFER_SIZE` is used."
msgstr ""

#: ../Doc/library/io.rst:582
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""

#: ../Doc/library/io.rst:587
msgid ""
"Return bytes from the stream without advancing the position.  At most one "
"single read on the raw stream is done to satisfy the call. The number of "
"bytes returned may be less or more than requested."
msgstr ""

#: ../Doc/library/io.rst:593
msgid ""
"Read and return *n* bytes, or if *n* is not given or negative, until EOF or "
"if the read call would block in non-blocking mode."
msgstr ""

#: ../Doc/library/io.rst:598
msgid ""
"Read and return up to *n* bytes with only one call on the raw stream.  If at "
"least one byte is buffered, only buffered bytes are returned. Otherwise, one "
"raw stream read call is made."
msgstr ""

#: ../Doc/library/io.rst:605
msgid ""
"A buffer providing higher-level access to a writeable, sequential :class:"
"`RawIOBase` object.  It inherits :class:`BufferedIOBase`. When writing to "
"this object, data is normally held into an internal buffer.  The buffer will "
"be written out to the underlying :class:`RawIOBase` object under various "
"conditions, including:"
msgstr ""

#: ../Doc/library/io.rst:611
msgid "when the buffer gets too small for all pending data;"
msgstr ""

#: ../Doc/library/io.rst:612
msgid "when :meth:`flush()` is called;"
msgstr ""

#: ../Doc/library/io.rst:613
msgid ""
"when a :meth:`seek()` is requested (for :class:`BufferedRandom` objects);"
msgstr ""

#: ../Doc/library/io.rst:614
msgid "when the :class:`BufferedWriter` object is closed or destroyed."
msgstr ""

#: ../Doc/library/io.rst:616
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable "
"*raw* stream.  If the *buffer_size* is not given, it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""

#: ../Doc/library/io.rst:620 ../Doc/library/io.rst:649
msgid ""
"A third argument, *max_buffer_size*, is supported, but unused and deprecated."
msgstr ""

#: ../Doc/library/io.rst:622
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""

#: ../Doc/library/io.rst:627
msgid ""
"Force bytes held in the buffer into the raw stream.  A :exc:"
"`BlockingIOError` should be raised if the raw stream blocks."
msgstr ""

#: ../Doc/library/io.rst:632
msgid ""
"Write *b*, and return the number of bytes written. The object *b* should be "
"an array of bytes, either :class:`bytes`, :class:`bytearray`, or :class:"
"`memoryview`. When in non-blocking mode, a :exc:`BlockingIOError` is raised "
"if the buffer needs to be written out but the raw stream blocks."
msgstr ""

#: ../Doc/library/io.rst:641
msgid ""
"A buffered interface to random access streams.  It inherits :class:"
"`BufferedReader` and :class:`BufferedWriter`, and further supports :meth:"
"`seek` and :meth:`tell` functionality."
msgstr ""

#: ../Doc/library/io.rst:645
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, given "
"in the first argument.  If the *buffer_size* is omitted it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""

#: ../Doc/library/io.rst:651
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or :"
"class:`BufferedWriter` can do."
msgstr ""

#: ../Doc/library/io.rst:657
msgid ""
"A buffered I/O object combining two unidirectional :class:`RawIOBase` "
"objects -- one readable, the other writeable -- into a single bidirectional "
"endpoint.  It inherits :class:`BufferedIOBase`."
msgstr ""

#: ../Doc/library/io.rst:661
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable and "
"writeable respectively.  If the *buffer_size* is omitted it defaults to :"
"data:`DEFAULT_BUFFER_SIZE`."
msgstr ""

#: ../Doc/library/io.rst:665
msgid ""
"A fourth argument, *max_buffer_size*, is supported, but unused and "
"deprecated."
msgstr ""

#: ../Doc/library/io.rst:668
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods except for :meth:`~BufferedIOBase.detach`, which raises :exc:"
"`UnsupportedOperation`."
msgstr ""

#: ../Doc/library/io.rst:674
msgid ""
":class:`BufferedRWPair` does not attempt to synchronize accesses to its "
"underlying raw streams.  You should not pass it the same object as reader "
"and writer; use :class:`BufferedRandom` instead."
msgstr ""

#: ../Doc/library/io.rst:680 ../Doc/library/io.rst:896
msgid "Text I/O"
msgstr ""

#: ../Doc/library/io.rst:684
msgid ""
"Base class for text streams.  This class provides a unicode character and "
"line based interface to stream I/O.  There is no :meth:`readinto` method "
"because Python's :class:`unicode` strings are immutable. It inherits :class:"
"`IOBase`.  There is no public constructor."
msgstr ""

#: ../Doc/library/io.rst:689
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and methods "
"in addition to those from :class:`IOBase`:"
msgstr ""

#: ../Doc/library/io.rst:694
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, and "
"to encode strings into bytes."
msgstr ""

#: ../Doc/library/io.rst:699
msgid "The error setting of the decoder or encoder."
msgstr ""

#: ../Doc/library/io.rst:703
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far.  Depending on the implementation and the initial "
"constructor flags, this may not be available."
msgstr ""

#: ../Doc/library/io.rst:709
msgid ""
"The underlying binary buffer (a :class:`BufferedIOBase` instance) that :"
"class:`TextIOBase` deals with.  This is not part of the :class:`TextIOBase` "
"API and may not exist on some implementations."
msgstr ""

#: ../Doc/library/io.rst:715
msgid ""
"Separate the underlying binary buffer from the :class:`TextIOBase` and "
"return it."
msgstr ""

#: ../Doc/library/io.rst:718
msgid ""
"After the underlying buffer has been detached, the :class:`TextIOBase` is in "
"an unusable state."
msgstr ""

#: ../Doc/library/io.rst:721
msgid ""
"Some :class:`TextIOBase` implementations, like :class:`StringIO`, may not "
"have the concept of an underlying buffer and calling this method will raise :"
"exc:`UnsupportedOperation`."
msgstr ""

#: ../Doc/library/io.rst:729
msgid ""
"Read and return at most *n* characters from the stream as a single :class:"
"`unicode`.  If *n* is negative or ``None``, reads until EOF."
msgstr ""

#: ../Doc/library/io.rst:734
msgid ""
"Read until newline or EOF and return a single ``unicode``.  If the stream is "
"already at EOF, an empty string is returned."
msgstr ""

#: ../Doc/library/io.rst:737
msgid "If *limit* is specified, at most *limit* characters will be read."
msgstr ""

#: ../Doc/library/io.rst:741
msgid ""
"Change the stream position to the given *offset*.  Behaviour depends on the "
"*whence* parameter.  The default value for *whence* is :data:`SEEK_SET`."
msgstr ""

#: ../Doc/library/io.rst:745
msgid ""
":data:`SEEK_SET` or ``0``: seek from the start of the stream (the default); "
"*offset* must either be a number returned by :meth:`TextIOBase.tell`, or "
"zero.  Any other *offset* value produces undefined behaviour."
msgstr ""

#: ../Doc/library/io.rst:749
msgid ""
":data:`SEEK_CUR` or ``1``: \"seek\" to the current position; *offset* must "
"be zero, which is a no-operation (all other values are unsupported)."
msgstr ""

#: ../Doc/library/io.rst:752
msgid ""
":data:`SEEK_END` or ``2``: seek to the end of the stream; *offset* must be "
"zero (all other values are unsupported)."
msgstr ""

#: ../Doc/library/io.rst:755
msgid "Return the new absolute position as an opaque number."
msgstr ""

#: ../Doc/library/io.rst:757
msgid "The ``SEEK_*`` constants."
msgstr ""

#: ../Doc/library/io.rst:762
msgid ""
"Return the current stream position as an opaque number.  The number does not "
"usually represent a number of bytes in the underlying binary storage."
msgstr ""

#: ../Doc/library/io.rst:768
msgid ""
"Write the :class:`unicode` string *s* to the stream and return the number of "
"characters written."
msgstr ""

#: ../Doc/library/io.rst:774
msgid ""
"A buffered text stream over a :class:`BufferedIOBase` binary stream. It "
"inherits :class:`TextIOBase`."
msgstr ""

#: ../Doc/library/io.rst:777
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded or "
"encoded with.  It defaults to :func:`locale.getpreferredencoding`."
msgstr ""

#: ../Doc/library/io.rst:780
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError` "
"exception if there is an encoding error (the default of ``None`` has the "
"same effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring "
"encoding errors can lead to data loss.)  ``'replace'`` causes a replacement "
"marker (such as ``'?'``) to be inserted where there is malformed data.  When "
"writing, ``'xmlcharrefreplace'`` (replace with the appropriate XML character "
"reference) or ``'backslashreplace'`` (replace with backslashed escape "
"sequences) can be used.  Any other error handling name that has been "
"registered with :func:`codecs.register_error` is also valid."
msgstr ""

#: ../Doc/library/io.rst:794
msgid ""
"*newline* controls how line endings are handled.  It can be ``None``, "
"``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as follows:"
msgstr ""

#: ../Doc/library/io.rst:797
msgid ""
"On input, if *newline* is ``None``, :term:`universal newlines` mode is "
"enabled.  Lines in the input can end in ``'\\n'``, ``'\\r'``, or ``'\\r"
"\\n'``, and these are translated into ``'\\n'`` before being returned to the "
"caller.  If it is ``''``, universal newlines mode is enabled, but line "
"endings are returned to the caller untranslated.  If it has any of the other "
"legal values, input lines are only terminated by the given string, and the "
"line ending is returned to the caller untranslated."
msgstr ""

#: ../Doc/library/io.rst:811
msgid ""
"If *line_buffering* is ``True``, :meth:`flush` is implied when a call to "
"write contains a newline character."
msgstr ""

#: ../Doc/library/io.rst:814
msgid ""
":class:`TextIOWrapper` provides one attribute in addition to those of :class:"
"`TextIOBase` and its parents:"
msgstr ""

#: ../Doc/library/io.rst:819
msgid "Whether line buffering is enabled."
msgstr ""

#: ../Doc/library/io.rst:824
msgid ""
"An in-memory stream for unicode text.  It inherits :class:`TextIOWrapper`."
msgstr ""

#: ../Doc/library/io.rst:826
msgid ""
"The initial value of the buffer can be set by providing *initial_value*. If "
"newline translation is enabled, newlines will be encoded as if by :meth:"
"`~TextIOBase.write`.  The stream is positioned at the start of the buffer."
msgstr ""

#: ../Doc/library/io.rst:831
msgid ""
"The *newline* argument works like that of :class:`TextIOWrapper`. The "
"default is to consider only ``\\n`` characters as ends of lines and to do no "
"newline translation.  If *newline* is set to ``None``, newlines are written "
"as ``\\n`` on all platforms, but universal newline decoding is still "
"performed when reading."
msgstr ""

#: ../Doc/library/io.rst:837
msgid ""
":class:`StringIO` provides this method in addition to those from :class:"
"`TextIOWrapper` and its parents:"
msgstr ""

#: ../Doc/library/io.rst:842
msgid ""
"Return a ``unicode`` containing the entire contents of the buffer at any "
"time before the :class:`StringIO` object's :meth:`close` method is called.  "
"Newlines are decoded as if by :meth:`~TextIOBase.read`, although the stream "
"position is not changed."
msgstr ""

#: ../Doc/library/io.rst:847
msgid "Example usage::"
msgstr ""

#: ../Doc/library/io.rst:869
msgid ""
"A helper codec that decodes newlines for :term:`universal newlines` mode. It "
"inherits :class:`codecs.IncrementalDecoder`."
msgstr ""

#: ../Doc/library/io.rst:874
msgid "Advanced topics"
msgstr ""

#: ../Doc/library/io.rst:876
msgid ""
"Here we will discuss several advanced topics pertaining to the concrete I/O "
"implementations described above."
msgstr ""

#: ../Doc/library/io.rst:880
msgid "Performance"
msgstr "Performances"

#: ../Doc/library/io.rst:883
msgid "Binary I/O"
msgstr ""

#: ../Doc/library/io.rst:885
msgid ""
"By reading and writing only large chunks of data even when the user asks for "
"a single byte, buffered I/O is designed to hide any inefficiency in calling "
"and executing the operating system's unbuffered I/O routines.  The gain will "
"vary very much depending on the OS and the kind of I/O which is performed "
"(for example, on some contemporary OSes such as Linux, unbuffered disk I/O "
"can be as fast as buffered I/O).  The bottom line, however, is that buffered "
"I/O will offer you predictable performance regardless of the platform and "
"the backing device.  Therefore, it is most always preferable to use buffered "
"I/O rather than unbuffered I/O."
msgstr ""

#: ../Doc/library/io.rst:898
msgid ""
"Text I/O over a binary storage (such as a file) is significantly slower than "
"binary I/O over the same storage, because it implies conversions from "
"unicode to binary data using a character codec.  This can become noticeable "
"if you handle huge amounts of text data (for example very large log files). "
"Also, :meth:`TextIOWrapper.tell` and :meth:`TextIOWrapper.seek` are both "
"quite slow due to the reconstruction algorithm used."
msgstr ""

#: ../Doc/library/io.rst:905
msgid ""
":class:`StringIO`, however, is a native in-memory unicode container and will "
"exhibit similar speed to :class:`BytesIO`."
msgstr ""

#: ../Doc/library/io.rst:909
msgid "Multi-threading"
msgstr "Fils d'exécution"

#: ../Doc/library/io.rst:911
msgid ""
":class:`FileIO` objects are thread-safe to the extent that the operating "
"system calls (such as ``read(2)`` under Unix) they are wrapping are thread-"
"safe too."
msgstr ""

#: ../Doc/library/io.rst:915
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) "
"protect their internal structures using a lock; it is therefore safe to call "
"them from multiple threads at once."
msgstr ""

#: ../Doc/library/io.rst:920
msgid ":class:`TextIOWrapper` objects are not thread-safe."
msgstr ""

#: ../Doc/library/io.rst:923
msgid "Reentrancy"
msgstr ""

#: ../Doc/library/io.rst:925
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) are "
"not reentrant.  While reentrant calls will not happen in normal situations, "
"they can arise if you are doing I/O in a :mod:`signal` handler.  If it is "
"attempted to enter a buffered object again while already being accessed "
"*from the same thread*, then a :exc:`RuntimeError` is raised."
msgstr ""

#: ../Doc/library/io.rst:932
msgid ""
"The above implicitly extends to text files, since the :func:`open()` "
"function will wrap a buffered object inside a :class:`TextIOWrapper`.  This "
"includes standard streams and therefore affects the built-in function :func:"
"`print()` as well."
msgstr ""
