# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-21 09:48+0100\n"
"PO-Revision-Date: 2019-04-12 00:15+0200\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Last-Translator: Mathieu Dupuy <deronnax@gmail.com>\n"
"X-Generator: Poedit 2.2.1\n"

#: ../Doc/library/threading.rst:2
msgid ":mod:`threading` --- Thread-based parallelism"
msgstr ""
":mod:`threading` — Parallélisme basé sur les fils d’exécution (*threads*)"

#: ../Doc/library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**Code source:** :source:`Lib/threading.py`"

#: ../Doc/library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the lower "
"level :mod:`_thread` module.  See also the :mod:`queue` module."
msgstr ""
"Ce module élabore des interfaces haut-niveau de fils d'exécutions multiples "
"(*threading*) conçues en s'appuyant sur le module bas-niveau :mod:"
"`_thread`.  Voir aussi le module :mod:`queue`."

#: ../Doc/library/threading.rst:14
msgid "This module used to be optional, it is now always available."
msgstr ""
"Ce module était auparavant optionnel, il est maintenant toujours disponible."

#: ../Doc/library/threading.rst:19
msgid ""
"While they are not listed below, the ``camelCase`` names used for some "
"methods and functions in this module in the Python 2.x series are still "
"supported by this module."
msgstr ""
"Bien qu'ils ne soient pas listés ci-dessous, les noms en ``camelCase`` "
"utilisés pour certaines méthodes et fonctions de ce module dans la série "
"Python 2.x sont toujours supportés par ce module."

#: ../Doc/library/threading.rst:24
msgid "This module defines the following functions:"
msgstr "Ce module définit les fonctions suivantes :"

#: ../Doc/library/threading.rst:29
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""
"Renvoie le nombre d'objets :class:`Thread` actuellement vivants.  Le compte "
"renvoyé est égal à la longueur de la liste renvoyée par :func:`.enumerate`."

#: ../Doc/library/threading.rst:35
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"Renvoie l'objet :class:`Thread` courant, correspondant au fil de contrôle "
"de l'appelant.  Si le fil de contrôle de l'appelant n'a pas été créé via le "
"module :mod:`Thread`, un objet *thread* factice aux fonctionnalités limitées "
"est renvoyé."

#: ../Doc/library/threading.rst:43
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"Renvoie l'\"identificateur de fil\" du fil d'exécution courant.  C'est un "
"entier non nul.  Sa valeur n'a pas de signification directe ; il est destiné "
"à être utilisé comme valeur magique opaque, par exemple comme clef de "
"dictionnaire de données pour chaque fil.  Les identificateurs de fils "
"peuvent être recyclés lorsqu'un fil se termine et qu'un autre fil est créé."

#: ../Doc/library/threading.rst:54
msgid ""
"Return a list of all :class:`Thread` objects currently alive.  The list "
"includes daemonic threads, dummy thread objects created by :func:"
"`current_thread`, and the main thread.  It excludes terminated threads and "
"threads that have not yet been started."
msgstr ""
"Retourne une liste de tous les objets fil d'exécution :class:`Thread` "
"actuellement vivants.  La liste inclut les fils démons, les fils factices "
"créés par :func:`current_thread`, et le fil principal.  Il exclut les fils "
"terminés et les fils qui n'ont pas encore été lancés."

#: ../Doc/library/threading.rst:62
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr ""
"Retourne l'objet fil d'exécution :class:`Thread` principal.  Dans des "
"conditions normales, le fil principal est le fil à partir duquel "
"l'interpréteur Python a été lancé."

#: ../Doc/library/threading.rst:73
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
"Attache une fonction de traçage pour tous les fils d'exécution démarrés "
"depuis le module :mod:`Thread`. La fonction *func* sera passée à :func:`sys."
"settrace` pour chaque fil, avant que sa méthode :meth:`~Thread.run` soit "
"appelée."

#: ../Doc/library/threading.rst:82
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
"Attache une fonction de profilage pour tous les fils d'exécution démarrés "
"depuis le module :mod:`Threading`. La fonction *func* sera passée à :func:"
"`sys.setprofile` pour chaque fil, avant que sa méthode :meth:`~Thread.run` "
"soit appelée."

#: ../Doc/library/threading.rst:89
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"Retourne la taille de la pile d'exécution utilisée lors de la création de "
"nouveau fils d'exécution. L'argument optionnel *size* spécifie la taille de "
"pile à utiliser pour les fils créés ultérieurement, et doit être 0 (pour "
"utiliser la taille de la plate-forme ou la valeur configurée par défaut) ou "
"un entier positif d'au moins 32 768 (32 KiB). Si *size* n'est pas spécifié, "
"0 est utilisé.  Si la modification de la taille de la pile de fils n'est pas "
"prise en charge, une :exc:`RuntimeError` est levée.  Si la taille de pile "
"spécifiée n'est pas valide, une :exc:`ValueError` est levée et la taille de "
"pile n'est pas modifiée.  32 KiB est actuellement la valeur minimale de "
"taille de pile prise en charge pour garantir un espace de pile suffisant "
"pour l'interpréteur lui-même.  Notez que certaines plates-formes peuvent "
"avoir des restrictions particulières sur les valeurs de taille de la pile, "
"telles que l'exigence d'une taille de pile minimale > 32 Ko ou d'une "
"allocation en multiples de la taille de page de la mémoire du système – la "
"documentation de la plate-forme devrait être consultée pour plus "
"d'informations (4 Ko sont courantes ; en l'absence de renseignements plus "
"spécifiques, l'approche proposée est l'utilisation de multiples de 4 096 "
"pour la taille de la pile)."

#: ../Doc/library/threading.rst:104
msgid ""
":ref:`Availability <availability>`: Windows, systems with POSIX threads."
msgstr ""
":ref:`Disponibilité <availability>` : Windows et systèmes gérant les fils "
"d'exécution POSIX."

#: ../Doc/library/threading.rst:107
msgid "This module also defines the following constant:"
msgstr "Ce module définit également la constante suivante :"

#: ../Doc/library/threading.rst:111
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr ""
"La valeur maximale autorisée pour le paramètre *timeout* des fonctions "
"bloquantes (:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition."
"wait`, etc.). Spécifier un délai d'attente supérieur à cette valeur lèvera "
"une :exc:`OverflowError`."

#: ../Doc/library/threading.rst:119
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr ""
"Ce module définit un certain nombre de classes, qui sont détaillées dans les "
"sections ci-dessous."

#: ../Doc/library/threading.rst:122
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread` "
"class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"La conception de ce module est librement basée sur le modèle des fils "
"d'exécution de Java. Cependant, là où Java fait des verrous et des variables "
"de condition le comportement de base de chaque objet, ils sont des objets "
"séparés en Python.  La classe Python :class:`Thread` prend en charge un sous-"
"ensemble du comportement de la classe *Thread* de Java ; actuellement, il "
"n'y a aucune priorité, aucun groupe de fils d'exécution, et les fils ne "
"peuvent être détruits, arrêtés, suspendus, repris, ou interrompus.  Les "
"méthodes statiques de la classe *Thread* de Java, lorsqu'elles sont "
"implémentées, correspondent à des fonctions au niveau du module."

#: ../Doc/library/threading.rst:130
msgid "All of the methods described below are executed atomically."
msgstr ""
"Toutes les méthodes décrites ci-dessous sont exécutées de manière atomique."

#: ../Doc/library/threading.rst:134
msgid "Thread-Local Data"
msgstr "Données locales au fil d'exécution"

#: ../Doc/library/threading.rst:136
msgid ""
"Thread-local data is data whose values are thread specific.  To manage "
"thread-local data, just create an instance of :class:`local` (or a subclass) "
"and store attributes on it::"
msgstr ""
"Les données de locales au fil d'exécution (*thread-local data*) sont des "
"données dont les valeurs sont propres à chaque fil.  Pour gérer les données "
"locales au fil, il suffit de créer une instance de :class:`local` (ou une "
"sous-classe) et d'y stocker des données : ::"

#: ../Doc/library/threading.rst:143
msgid "The instance's values will be different for separate threads."
msgstr ""
"Les valeurs dans l'instance seront différentes pour des *threads* différents."

#: ../Doc/library/threading.rst:148
msgid "A class that represents thread-local data."
msgstr "Une classe qui représente les données locales au fil d'exécution."

#: ../Doc/library/threading.rst:150
msgid ""
"For more details and extensive examples, see the documentation string of "
"the :mod:`_threading_local` module."
msgstr ""
"Pour plus de détails et de nombreux exemples, voir la chaîne de "
"documentation du module :mod:`_threading_local`."

#: ../Doc/library/threading.rst:157
msgid "Thread Objects"
msgstr "Objets *Threads*"

#: ../Doc/library/threading.rst:159
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a "
"callable object to the constructor, or by overriding the :meth:`~Thread.run` "
"method in a subclass.  No other methods (except for the constructor) should "
"be overridden in a subclass.  In other words, *only*  override the :meth:"
"`~Thread.__init__` and :meth:`~Thread.run` methods of this class."
msgstr ""
"La classe fil d'exécution :class:`Thread` représente une activité qui est "
"exécutée dans un fil d'exécution séparé.  Il y a deux façons de spécifier "
"l'activité : en passant un objet appelable au constructeur, ou en ré-"
"implémentant la méthode :meth:`~Thread.run` dans une sous-classe.  Aucune "
"autre méthode (à l'exception du constructeur) ne doit être remplacée dans "
"une sous-classe.  En d'autres termes, réimplémentez *seulement* les "
"méthodes :meth:`~Thread.__init__` et :meth:`~Thread.run` de cette classe."

#: ../Doc/library/threading.rst:166
msgid ""
"Once a thread object is created, its activity must be started by calling the "
"thread's :meth:`~Thread.start` method.  This invokes the :meth:`~Thread.run` "
"method in a separate thread of control."
msgstr ""
"Une fois qu'un objet fil d'exécution est créé, son activité doit être lancée "
"en appelant la méthode :meth:`~Thread.start` du fil.  Ceci invoque la "
"méthode :meth:`~Thread.run` dans un fil d'exécution séparé."

#: ../Doc/library/threading.rst:170
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The :meth:`~Thread."
"is_alive` method tests whether the thread is alive."
msgstr ""
"Une fois que l'activité du fil d'exécution est lancée, le fil est considéré "
"comme \" vivant \". Il cesse d'être vivant lorsque sa méthode :meth:`~Thread."
"run` se termine -- soit normalement, soit en levant une exception non "
"gérée.  La méthode :meth:`~Thread.is_alive` teste si le fil est vivant."

#: ../Doc/library/threading.rst:175
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"D'autres fils d'exécution peuvent appeler la méthode :meth:`~Thread.join` "
"d'un fil.  Ceci bloque le fil appelant jusqu'à ce que le fil dont la "
"méthode :meth:`~Thread.join` est appelée soit terminé."

#: ../Doc/library/threading.rst:179
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or "
"changed through the :attr:`~Thread.name` attribute."
msgstr ""
"Un fil d'exécution a un nom.  Le nom peut être passé au constructeur, et lu "
"ou modifié via l'attribut :attr:`~Thread.name`."

#: ../Doc/library/threading.rst:182
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"Un fil d'exécution peut être marqué comme \"fil démon\".  Un programme "
"Python se termine quand il ne reste plus que des fils démons.  La valeur "
"initiale est héritée du fil d'exécution qui l'a créé.  Cette option peut "
"être définie par la propriété :attr:`~Thread.daemon` ou par l'argument "
"*daemon* du constructeur."

#: ../Doc/library/threading.rst:189
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"Les fils d'exécution démons sont brusquement terminés à l'arrêt du programme "
"Python.  Leurs ressources (fichiers ouverts, transactions de base de "
"données, etc.) peuvent ne pas être libérées correctement. Si vous voulez que "
"vos fils s'arrêtent gracieusement, faites en sorte qu'ils ne soient pas "
"démoniques et utilisez un mécanisme de signalisation approprié tel qu'un "
"objet évènement :class:`Event`."

#: ../Doc/library/threading.rst:194
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of "
"control in the Python program.  It is not a daemon thread."
msgstr ""
"Il y a un objet \"fil principal\", qui correspond au fil de contrôle initial "
"dans le programme Python.  Ce n'est pas un fil démon."

#: ../Doc/library/threading.rst:197
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code.  "
"Dummy thread objects have limited functionality; they are always considered "
"alive and daemonic, and cannot be :meth:`~Thread.join`\\ ed.  They are never "
"deleted, since it is impossible to detect the termination of alien threads."
msgstr ""
"Il y a une possibilité que des objets fil d'exécution \"fictifs\" soit "
"créés. Ce sont des objets correspondant à des fils d'exécution \"étrangers"
"\", qui sont des fils de contrôle démarrés en dehors du module de "
"*threading*, par exemple directement depuis le code C.  Les objets fils "
"d'exécution fictifs ont des fonctionnalités limitées ; ils sont toujours "
"considérés comme vivants et démoniques, et ne peuvent pas être attendus via :"
"meth:`~Thread.join`.  Ils ne sont jamais supprimés, car il est impossible de "
"détecter la fin des fils d'exécution étrangers."

#: ../Doc/library/threading.rst:208
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr ""
"Ce constructeur doit toujours être appelé avec des arguments nommés.  Les "
"arguments sont :"

#: ../Doc/library/threading.rst:211
msgid ""
"*group* should be ``None``; reserved for future extension when a :class:"
"`ThreadGroup` class is implemented."
msgstr ""
"*group* devrait être ``None`` ; cet argument est réservé pour une extension "
"future lorsqu'une classe :class:`ThreadGroup` sera implémentée."

#: ../Doc/library/threading.rst:214
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target* est l'objet appelable qui doit être invoqué par la méthode :meth:"
"`run`. La valeur par défaut est ``None``, ce qui signifie que rien n'est "
"appelé."

#: ../Doc/library/threading.rst:217
msgid ""
"*name* is the thread name.  By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number."
msgstr ""
"*name* est le nom du fil d'exécution.  Par défaut, un nom unique est "
"construit sous la forme \"Thread–*N*\" où *N* est un petit nombre décimal."

#: ../Doc/library/threading.rst:220
msgid ""
"*args* is the argument tuple for the target invocation.  Defaults to ``()``."
msgstr ""
"*args* est le tuple d'arguments pour l'invocation de l'objet appelable.  La "
"valeur par défaut est ``()``."

#: ../Doc/library/threading.rst:222
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr ""
"*kwargs* est un dictionnaire d'arguments nommés pour l'invocation de l'objet "
"appelable. La valeur par défaut est ``{}}``."

#: ../Doc/library/threading.rst:225
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If "
"``None`` (the default), the daemonic property is inherited from the current "
"thread."
msgstr ""
"S'il ne vaut pas ``None```, *daemon* définit explicitement si le fil "
"d'exécution est démonique ou pas. S'il vaut ``None`` (par défaut), la valeur "
"est héritée du fil courant."

#: ../Doc/library/threading.rst:229
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to "
"the thread."
msgstr ""
"Si la sous-classe réimplémente le constructeur, elle doit s'assurer "
"d'appeler le constructeur de la classe de base (``Thread.__init__()``) avant "
"de faire autre chose au fil d'exécution."

#: ../Doc/library/threading.rst:233
msgid "Added the *daemon* argument."
msgstr "Ajout de l'argument *daemon*."

#: ../Doc/library/threading.rst:238
msgid "Start the thread's activity."
msgstr "Lance l'activité du fil d'exécution."

#: ../Doc/library/threading.rst:240
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr ""
"Doit être appelé au plus une fois par objet de fil.  Fait en sorte que la "
"méthode :meth:`~Thread.run` de l'objet soit invoquée dans un fil d'exécution."

#: ../Doc/library/threading.rst:244
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the "
"same thread object."
msgstr ""
"Cette méthode lève une :exc:`RuntimeError` si elle est appelée plus d'une "
"fois sur le même objet fil d'exécution."

#: ../Doc/library/threading.rst:249
msgid "Method representing the thread's activity."
msgstr "Méthode représentant l'activité du fil d'exécution."

#: ../Doc/library/threading.rst:251
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with sequential and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"Vous pouvez remplacer cette méthode dans une sous-classe.  La méthode "
"standard :meth:`run` invoque l'objet appelable passé au constructeur de "
"l'objet en tant qu'argument *target*, le cas échéant, avec des arguments "
"séquentiels et des arguments nommés tirés respectivement des arguments "
"*args* et *kwargs*."

#: ../Doc/library/threading.rst:258
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"Attendre que le fil d'exécution se termine. Ceci bloque le fil appelant "
"jusqu'à ce que le fil dont la méthode :meth:`~Thread.join` est appelée se "
"termine -- soit normalement soit par une exception non gérée -- ou jusqu'à "
"ce que le délai optionnel *timeout* soit atteint."

#: ../Doc/library/threading.rst:263
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the :meth:"
"`~Thread.join` call timed out."
msgstr ""
"Lorsque l'argument *timeout* est présent et ne vaut pas ``None``, il doit "
"être un nombre en virgule flottante spécifiant un délai pour l'opération en "
"secondes (ou fractions de secondes). Comme :meth:`~Thread.join` renvoie "
"toujours ``None``, vous devez appeler :meth:`~Thread.is_alive` après :meth:"
"`~Thread.join` pour déterminer si le délai a expiré -- si le fil d'exécution "
"est toujours vivant, l'appel à :meth:`~Thread.join` a expiré."

#: ../Doc/library/threading.rst:270
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr ""
"Lorsque l'argument *timeout* n'est pas présent ou vaut ``None``, l'opération "
"se bloque jusqu'à ce que le fil d'exécution se termine."

#: ../Doc/library/threading.rst:273
msgid "A thread can be :meth:`~Thread.join`\\ ed many times."
msgstr ""
"Un fil d'exécution peut être attendu via :meth:`~Thread.join` de nombreuses "
"fois."

#: ../Doc/library/threading.rst:275
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
":meth:`~Thread.join` lève une :exc:`RuntimeError` si une tentative est faite "
"pour attendre le fil d'exécution courant car cela causerait une impasse. "
"C'est aussi une erreur d'attendre via :meth:`~Thread.join` un fil "
"d'exécution avant qu'il n'ait été lancé et tenter de le faire lèvera la même "
"exception."

#: ../Doc/library/threading.rst:282
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the "
"constructor."
msgstr ""
"Une chaîne de caractères utilisée à des fins d'identification seulement. "
"Elle n'a pas de sémantique. Plusieurs fils d'exécution peuvent porter le "
"même nom.  Le nom initial est défini par le constructeur."

#: ../Doc/library/threading.rst:289
msgid ""
"Old getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr ""
"Anciens *getter*/*setter* pour :attr:`~Thread.name` ; utilisez plutôt ce "
"dernier directement."

#: ../Doc/library/threading.rst:294
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"L'\"identificateur de fil d'exécution\" de ce fil ou ``None`` si le fil n'a "
"pas été lancé.  C'est un entier non nul.  Voyez également la fonction :func:"
"`get_ident`.  Les identificateurs de fils peuvent être recyclés lorsqu'un "
"fil se termine et qu'un autre fil est créé.  L'identifiant est disponible "
"même après que le fil ait terminé."

#: ../Doc/library/threading.rst:302
msgid "Return whether the thread is alive."
msgstr "Renvoie si le fil d'exécution est vivant ou pas."

#: ../Doc/library/threading.rst:304
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"Cette méthode renvoie ``True`` juste avant le démarrage de la méthode :meth:"
"`~Thread.run` jusqu'à juste après que la méthode :meth:`~Thread.run` se "
"termine.  La fonction :func:`.enumerate` du module retourne une liste de "
"tous les fils d'exécution vivants."

#: ../Doc/library/threading.rst:310
msgid ""
"A boolean value indicating whether this thread is a daemon thread (True) or "
"not (False).  This must be set before :meth:`~Thread.start` is called, "
"otherwise :exc:`RuntimeError` is raised.  Its initial value is inherited "
"from the creating thread; the main thread is not a daemon thread and "
"therefore all threads created in the main thread default to :attr:`~Thread."
"daemon` = ``False``."
msgstr ""
"Booléen indiquant si ce fil  d'exécution est un fil démon (``True``) ou "
"non (``False``).  Celui-ci doit être défini avant que :meth:`~Thread.start` "
"ne soit appelé, sinon :exc:`RuntimeError` est levée.  Sa valeur initiale est "
"héritée du fil d'exécution créateur ; le fil principal n'est pas un fil "
"démon et donc tous les fils créés dans ce fil principal ont par défaut la valeur :attr:"
"`~Thread.daemon` = ``False``."

#: ../Doc/library/threading.rst:317
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr ""
"Le programme Python se termine lorsqu'il ne reste plus de fils d'exécution "
"non-démons vivants."

#: ../Doc/library/threading.rst:322
msgid ""
"Old getter/setter API for :attr:`~Thread.daemon`; use it directly as a "
"property instead."
msgstr ""
"Anciens accesseur et mutateur pour :attr:`~Thread.daemon` ; utilisez plutôt ce "
"dernier directement."

#: ../Doc/library/threading.rst:328
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock`, only one thread can "
"execute Python code at once (even though certain performance-oriented "
"libraries might overcome this limitation). If you want your application to "
"make better use of the computational resources of multi-core machines, you "
"are advised to use :mod:`multiprocessing` or :class:`concurrent.futures."
"ProcessPoolExecutor`. However, threading is still an appropriate model if "
"you want to run multiple I/O-bound tasks simultaneously."
msgstr ""
"En CPython, en raison du verrou global de l'interpréteur (:term:`Global "
"Interpreter Lock`), un seul fil d'exécution peut exécuter du code Python à "
"la fois (même si certaines bibliothèques orientées performance peuvent "
"surmonter cette limitation). Si vous voulez que votre application fasse un "
"meilleur usage des ressources de calcul des machines multi-cœurs, nous vous "
"conseillons d'utiliser :mod:`multiprocessing` ou :class:`concurrent.futures."
"ProcessPoolExecutor`. Néanmoins, les fils d'exécutions multiples restent un "
"modèle approprié si vous souhaitez exécuter simultanément plusieurs tâches "
"limitées par les performances des entrées-sorties."

#: ../Doc/library/threading.rst:341
msgid "Lock Objects"
msgstr ""

#: ../Doc/library/threading.rst:343
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the :mod:"
"`_thread` extension module."
msgstr ""

#: ../Doc/library/threading.rst:348
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, :meth:`~Lock."
"acquire` and :meth:`~Lock.release`.  When the state is unlocked, :meth:"
"`~Lock.acquire` changes the state to locked and returns immediately.  When "
"the state is locked, :meth:`~Lock.acquire` blocks until a call to :meth:"
"`~Lock.release` in another thread changes it to unlocked, then the :meth:"
"`~Lock.acquire` call resets it to locked and returns.  The :meth:`~Lock."
"release` method should only be called in the locked state; it changes the "
"state to unlocked and returns immediately. If an attempt is made to release "
"an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""

#: ../Doc/library/threading.rst:359
msgid "Locks also support the :ref:`context management protocol <with-locks>`."
msgstr ""

#: ../Doc/library/threading.rst:361
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a :meth:`~Lock."
"release` call resets the state to unlocked; which one of the waiting threads "
"proceeds is not defined, and may vary across implementations."
msgstr ""

#: ../Doc/library/threading.rst:366
msgid "All methods are executed atomically."
msgstr ""

#: ../Doc/library/threading.rst:371
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a "
"lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr ""

#: ../Doc/library/threading.rst:375
msgid ""
"Note that ``Lock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete Lock class that is supported "
"by the platform."
msgstr ""

#: ../Doc/library/threading.rst:382 ../Doc/library/threading.rst:457
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Acquiert un verrou, bloquant ou non bloquant."

#: ../Doc/library/threading.rst:384
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""

#: ../Doc/library/threading.rst:387
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If "
"a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""

#: ../Doc/library/threading.rst:391
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is false."
msgstr ""

#: ../Doc/library/threading.rst:397
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not (for example if the *timeout* expired)."
msgstr ""

#: ../Doc/library/threading.rst:400 ../Doc/library/threading.rst:479
#: ../Doc/library/threading.rst:724
msgid "The *timeout* parameter is new."
msgstr "Le paramètre *timeout* est nouveau."

#: ../Doc/library/threading.rst:403
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr ""

#: ../Doc/library/threading.rst:410
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr ""

#: ../Doc/library/threading.rst:413
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""

#: ../Doc/library/threading.rst:417
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""

#: ../Doc/library/threading.rst:419 ../Doc/library/threading.rst:495
msgid "There is no return value."
msgstr "Il n'y a pas de valeur de retour."

#: ../Doc/library/threading.rst:425
msgid "RLock Objects"
msgstr ""

#: ../Doc/library/threading.rst:427
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked "
"state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""

#: ../Doc/library/threading.rst:433
msgid ""
"To lock the lock, a thread calls its :meth:`~RLock.acquire` method; this "
"returns once the thread owns the lock.  To unlock the lock, a thread calls "
"its :meth:`~Lock.release` method. :meth:`~Lock.acquire`/:meth:`~Lock."
"release` call pairs may be nested; only the final :meth:`~Lock.release` "
"(the :meth:`~Lock.release` of the outermost pair) resets the lock to "
"unlocked and allows another thread blocked in :meth:`~Lock.acquire` to "
"proceed."
msgstr ""

#: ../Doc/library/threading.rst:440
msgid ""
"Reentrant locks also support the :ref:`context management protocol <with-"
"locks>`."
msgstr ""

#: ../Doc/library/threading.rst:445
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""

#: ../Doc/library/threading.rst:450
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete RLock class that is supported "
"by the platform."
msgstr ""

#: ../Doc/library/threading.rst:459
msgid ""
"When invoked without arguments: if this thread already owns the lock, "
"increment the recursion level by one, and return immediately.  Otherwise, if "
"another thread owns the lock, block until the lock is unlocked.  Once the "
"lock is unlocked (not owned by any thread), then grab ownership, set the "
"recursion level to one, and return.  If more than one thread is blocked "
"waiting until the lock is unlocked, only one at a time will be able to grab "
"ownership of the lock. There is no return value in this case."
msgstr ""

#: ../Doc/library/threading.rst:467
msgid ""
"When invoked with the *blocking* argument set to true, do the same thing as "
"when called without arguments, and return true."
msgstr ""

#: ../Doc/library/threading.rst:470
msgid ""
"When invoked with the *blocking* argument set to false, do not block.  If a "
"call without an argument would block, return false immediately; otherwise, "
"do the same thing as when called without arguments, and return true."
msgstr ""

#: ../Doc/library/threading.rst:474
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  Return true if the lock has been "
"acquired, false if the timeout has elapsed."
msgstr ""

#: ../Doc/library/threading.rst:485
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it "
"is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""

#: ../Doc/library/threading.rst:491
msgid ""
"Only call this method when the calling thread owns the lock. A :exc:"
"`RuntimeError` is raised if this method is called when the lock is unlocked."
msgstr ""

#: ../Doc/library/threading.rst:501
msgid "Condition Objects"
msgstr ""

#: ../Doc/library/threading.rst:503
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part "
"of the condition object: you don't have to track it separately."
msgstr ""

#: ../Doc/library/threading.rst:508
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and :meth:"
"`~Condition.release` methods also call the corresponding methods of the "
"associated lock."
msgstr ""

#: ../Doc/library/threading.rst:514
msgid ""
"Other methods must be called with the associated lock held.  The :meth:"
"`~Condition.wait` method releases the lock, and then blocks until another "
"thread awakens it by calling :meth:`~Condition.notify` or :meth:`~Condition."
"notify_all`.  Once awakened, :meth:`~Condition.wait` re-acquires the lock "
"and returns.  It is also possible to specify a timeout."
msgstr ""

#: ../Doc/library/threading.rst:520
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for "
"the condition variable, if any are waiting.  The :meth:`~Condition."
"notify_all` method wakes up all threads waiting for the condition variable."
msgstr ""

#: ../Doc/library/threading.rst:524
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""

#: ../Doc/library/threading.rst:530
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call :meth:"
"`~Condition.notify` or :meth:`~Condition.notify_all` when they change the "
"state in such a way that it could possibly be a desired state for one of the "
"waiters.  For example, the following code is a generic producer-consumer "
"situation with unlimited buffer capacity::"
msgstr ""

#: ../Doc/library/threading.rst:550
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and "
"the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The :"
"meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""

#: ../Doc/library/threading.rst:562
msgid ""
"To choose between :meth:`~Condition.notify` and :meth:`~Condition."
"notify_all`, consider whether one state change can be interesting for only "
"one or several waiting threads.  E.g. in a typical producer-consumer "
"situation, adding one item to the buffer only needs to wake up one consumer "
"thread."
msgstr ""

#: ../Doc/library/threading.rst:570
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another thread."
msgstr ""

#: ../Doc/library/threading.rst:573
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock` "
"or :class:`RLock` object, and it is used as the underlying lock.  Otherwise, "
"a new :class:`RLock` object is created and used as the underlying lock."
msgstr ""

#: ../Doc/library/threading.rst:577 ../Doc/library/threading.rst:699
#: ../Doc/library/threading.rst:742 ../Doc/library/threading.rst:794
#: ../Doc/library/threading.rst:863
msgid "changed from a factory function to a class."
msgstr ""

#: ../Doc/library/threading.rst:582
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr ""

#: ../Doc/library/threading.rst:587
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr ""

#: ../Doc/library/threading.rst:592
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not "
"acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""

#: ../Doc/library/threading.rst:596
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs.  "
"Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""

#: ../Doc/library/threading.rst:601
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""

#: ../Doc/library/threading.rst:605
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its :"
"meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""

#: ../Doc/library/threading.rst:613
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case "
"it is ``False``."
msgstr ""

#: ../Doc/library/threading.rst:616 ../Doc/library/threading.rst:828
msgid "Previously, the method always returned ``None``."
msgstr ""

#: ../Doc/library/threading.rst:621
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""

#: ../Doc/library/threading.rst:625
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""

#: ../Doc/library/threading.rst:630
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr ""

#: ../Doc/library/threading.rst:636
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr ""

#: ../Doc/library/threading.rst:644
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""

#: ../Doc/library/threading.rst:648
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr ""

#: ../Doc/library/threading.rst:651
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""

#: ../Doc/library/threading.rst:656
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call "
"until it can reacquire the lock.  Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""

#: ../Doc/library/threading.rst:662
msgid ""
"Wake up all threads waiting on this condition.  This method acts like :meth:"
"`notify`, but wakes up all waiting threads instead of one. If the calling "
"thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""

#: ../Doc/library/threading.rst:671
msgid "Semaphore Objects"
msgstr ""

#: ../Doc/library/threading.rst:673
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of :meth:`~Semaphore."
"acquire` and :meth:`~Semaphore.release`)."
msgstr ""

#: ../Doc/library/threading.rst:678
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`~Semaphore.acquire` call and incremented by each :meth:`~Semaphore.release` "
"call.  The counter can never go below zero; when :meth:`~Semaphore.acquire` "
"finds that it is zero, it blocks, waiting until some other thread calls :"
"meth:`~Semaphore.release`."
msgstr ""

#: ../Doc/library/threading.rst:684
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr ""

#: ../Doc/library/threading.rst:689
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number "
"of :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative. "
"If not given, *value* defaults to 1."
msgstr ""

#: ../Doc/library/threading.rst:695
msgid ""
"The optional argument gives the initial *value* for the internal counter; it "
"defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is "
"raised."
msgstr ""

#: ../Doc/library/threading.rst:704
msgid "Acquire a semaphore."
msgstr ""

#: ../Doc/library/threading.rst:706
msgid "When invoked without arguments:"
msgstr ""

#: ../Doc/library/threading.rst:708
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return true immediately."
msgstr ""

#: ../Doc/library/threading.rst:710
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to :"
"meth:`~Semaphore.release`.  Once awoken (and the counter is greater than 0), "
"decrement the counter by 1 and return true.  Exactly one thread will be "
"awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""

#: ../Doc/library/threading.rst:716
msgid ""
"When invoked with *blocking* set to false, do not block.  If a call without "
"an argument would block, return false immediately; otherwise, do the same "
"thing as when called without arguments, and return true."
msgstr ""

#: ../Doc/library/threading.rst:720
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most "
"*timeout* seconds.  If acquire does not complete successfully in that "
"interval, return false.  Return true otherwise."
msgstr ""

#: ../Doc/library/threading.rst:729
msgid ""
"Release a semaphore, incrementing the internal counter by one.  When it was "
"zero on entry and another thread is waiting for it to become larger than "
"zero again, wake up that thread."
msgstr ""

#: ../Doc/library/threading.rst:736
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to "
"make sure its current value doesn't exceed its initial value.  If it does, :"
"exc:`ValueError` is raised. In most situations semaphores are used to guard "
"resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""

#: ../Doc/library/threading.rst:749
msgid ":class:`Semaphore` Example"
msgstr ""

#: ../Doc/library/threading.rst:751
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource "
"is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""

#: ../Doc/library/threading.rst:760
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""

#: ../Doc/library/threading.rst:770
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr ""

#: ../Doc/library/threading.rst:777
msgid "Event Objects"
msgstr ""

#: ../Doc/library/threading.rst:779
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr ""

#: ../Doc/library/threading.rst:782
msgid ""
"An event object manages an internal flag that can be set to true with the :"
"meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""

#: ../Doc/library/threading.rst:789
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the :meth:"
"`clear` method.  The :meth:`wait` method blocks until the flag is true. The "
"flag is initially false."
msgstr ""

#: ../Doc/library/threading.rst:799
msgid "Return true if and only if the internal flag is true."
msgstr ""

#: ../Doc/library/threading.rst:803
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are "
"awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""

#: ../Doc/library/threading.rst:809
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait` "
"will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""

#: ../Doc/library/threading.rst:815
msgid ""
"Block until the internal flag is true.  If the internal flag is true on "
"entry, return immediately.  Otherwise, block until another thread calls :"
"meth:`.set` to set the flag to true, or until the optional timeout occurs."
msgstr ""

#: ../Doc/library/threading.rst:819
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""

#: ../Doc/library/threading.rst:823
msgid ""
"This method returns true if and only if the internal flag has been set to "
"true, either before the wait call or after the wait starts, so it will "
"always return ``True`` except if a timeout is given and the operation times "
"out."
msgstr ""

#: ../Doc/library/threading.rst:835
msgid "Timer Objects"
msgstr ""

#: ../Doc/library/threading.rst:837
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of :"
"class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""

#: ../Doc/library/threading.rst:841
msgid ""
"Timers are started, as with threads, by calling their :meth:`~Timer.start` "
"method.  The timer can be stopped (before its action has begun) by calling "
"the :meth:`~Timer.cancel` method.  The interval the timer will wait before "
"executing its action may not be exactly the same as the interval specified "
"by the user."
msgstr ""

#: ../Doc/library/threading.rst:847
msgid "For example::"
msgstr "Par exemple ::"

#: ../Doc/library/threading.rst:858
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""

#: ../Doc/library/threading.rst:868
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr ""

#: ../Doc/library/threading.rst:873
msgid "Barrier Objects"
msgstr ""

#: ../Doc/library/threading.rst:877
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""

#: ../Doc/library/threading.rst:883
msgid ""
"The barrier can be reused any number of times for the same number of threads."
msgstr ""

#: ../Doc/library/threading.rst:885
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr ""

#: ../Doc/library/threading.rst:905
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""

#: ../Doc/library/threading.rst:912
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""

#: ../Doc/library/threading.rst:917
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""

#: ../Doc/library/threading.rst:926
msgid ""
"If an *action* was provided to the constructor, one of the threads will have "
"called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr ""

#: ../Doc/library/threading.rst:930
msgid "If the call times out, the barrier is put into the broken state."
msgstr ""

#: ../Doc/library/threading.rst:932
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a thread is waiting."
msgstr ""

#: ../Doc/library/threading.rst:937
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""

#: ../Doc/library/threading.rst:940
msgid ""
"Note that using this function may can require some external synchronization "
"if there are other threads whose state is unknown.  If a barrier is broken "
"it may be better to just leave it and create a new one."
msgstr ""

#: ../Doc/library/threading.rst:946
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for "
"example if one of the needs to abort, to avoid deadlocking the application."
msgstr ""

#: ../Doc/library/threading.rst:951
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr ""

#: ../Doc/library/threading.rst:957
msgid "The number of threads required to pass the barrier."
msgstr ""

#: ../Doc/library/threading.rst:961
msgid "The number of threads currently waiting in the barrier."
msgstr ""

#: ../Doc/library/threading.rst:965
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr ""

#: ../Doc/library/threading.rst:970
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""

#: ../Doc/library/threading.rst:977
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr ""

#: ../Doc/library/threading.rst:979
msgid ""
"All of the objects provided by this module that have :meth:`acquire` and :"
"meth:`release` methods can be used as context managers for a :keyword:`with` "
"statement.  The :meth:`acquire` method will be called when the block is "
"entered, and :meth:`release` will be called when the block is exited.  "
"Hence, the following snippet::"
msgstr ""

#: ../Doc/library/threading.rst:988
msgid "is equivalent to::"
msgstr "est équivalente à ::"

#: ../Doc/library/threading.rst:996
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore`, and :class:`BoundedSemaphore` objects may be used as :keyword:"
"`with` statement context managers."
msgstr ""
