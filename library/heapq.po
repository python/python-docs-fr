# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-09 17:54+0200\n"
"PO-Revision-Date: 2019-09-16 12:04+0200\n"
"Last-Translator: \n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.1\n"

#: ../Doc/library/heapq.rst:2
msgid ":mod:`heapq` --- Heap queue algorithm"
msgstr ":mod:`heapq` — File de priorité basée sur un tas"

#: ../Doc/library/heapq.rst:12
msgid "**Source code:** :source:`Lib/heapq.py`"
msgstr "**Code source :** :source:`Lib/heapq.py`"

#: ../Doc/library/heapq.rst:16
msgid ""
"This module provides an implementation of the heap queue algorithm, also "
"known as the priority queue algorithm."
msgstr ""
"Ce module expose une implémentation de l'algorithme de file de priorité, "
"basée sur un tas."

#: ../Doc/library/heapq.rst:19
msgid ""
"Heaps are binary trees for which every parent node has a value less than or "
"equal to any of its children.  This implementation uses arrays for which "
"``heap[k] <= heap[2*k+1]`` and ``heap[k] <= heap[2*k+2]`` for all *k*, "
"counting elements from zero.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that its smallest element is always the root, ``heap[0]``."
msgstr ""
"Les tas sont des arbres binaires pour lesquels chaque valeur portée par un "
"nœud est inférieure ou égale à celle de ses deux fils. Cette implémentation "
"utilise des tableaux pour lesquels ``tas[k] <= tas[2*k+1]`` et ``tas[k] <= "
"tas[2*k+2]`` pour tout *k*, en commençant la numérotation à zéro.  Pour "
"contenter l'opérateur de comparaison, les éléments inexistants sont "
"considérés comme porteur d'une valeur infinie. L'intérêt du tas est que son "
"plus petit élément est toujours la racine, ``tas[0]``."

#: ../Doc/library/heapq.rst:26
msgid ""
"The API below differs from textbook heap algorithms in two aspects: (a) We "
"use zero-based indexing.  This makes the relationship between the index for "
"a node and the indexes for its children slightly less obvious, but is more "
"suitable since Python uses zero-based indexing. (b) Our pop method returns "
"the smallest item, not the largest (called a \"min heap\" in textbooks; a "
"\"max heap\" is more common in texts because of its suitability for in-place "
"sorting)."
msgstr ""
"L'API ci-dessous diffère de la file de priorité classique par deux aspects : "
"(a) L'indiçage commence à zéro. Cela complexifie légèrement la relation "
"entre l'indice d'un nœud et les indices de ses fils mais est alignée avec "
"l'indiçage commençant à zéro que Python utilise. (b) La méthode *pop* "
"renvoie le plus petit élément et non le plus grand (appelé « tas-min » dans "
"les manuels scolaires ; le  « tas-max » étant généralement plus courant dans "
"la littérature car il permet le classement sans tampon)."

#: ../Doc/library/heapq.rst:33
msgid ""
"These two make it possible to view the heap as a regular Python list without "
"surprises: ``heap[0]`` is the smallest item, and ``heap.sort()`` maintains "
"the heap invariant!"
msgstr ""
"Ces deux points permettent d'aborder le tas comme une liste Python standard "
"sans surprise : ``heap[0]`` est le plus petit élément tandis que ``heap."
"sort()`` ne modifie pas le tas !"

#: ../Doc/library/heapq.rst:37
msgid ""
"To create a heap, use a list initialized to ``[]``, or you can transform a "
"populated list into a heap via function :func:`heapify`."
msgstr ""
"Pour créer un tas, utilisez une liste initialisée à ``[]`` ou bien utilisez "
"une liste existante et transformez la en tas à l'aide de la fonction :func:"
"`heapify`."

#: ../Doc/library/heapq.rst:40
msgid "The following functions are provided:"
msgstr "Les fonctions suivantes sont fournies :"

#: ../Doc/library/heapq.rst:45
msgid "Push the value *item* onto the *heap*, maintaining the heap invariant."
msgstr ""
"Introduit la valeur *item* dans le tas *heap*, en conservant l'invariance du "
"tas."

#: ../Doc/library/heapq.rst:50
msgid ""
"Pop and return the smallest item from the *heap*, maintaining the heap "
"invariant.  If the heap is empty, :exc:`IndexError` is raised.  To access "
"the smallest item without popping it, use ``heap[0]``."
msgstr ""
"Extraie le plus petit élément de *heap* en préservant l'invariant du tas. Si "
"le tas est vide, une exception :exc:`IndexError` est levée. Pour accéder au "
"plus petit élément sans le retirer, utilisez ``heap[0]``."

#: ../Doc/library/heapq.rst:57
msgid ""
"Push *item* on the heap, then pop and return the smallest item from the "
"*heap*.  The combined action runs more efficiently than :func:`heappush` "
"followed by a separate call to :func:`heappop`."
msgstr ""
"Introduit l'élément *item* dans le tas, puis extraie le plus petit élément "
"de *heap*. Cette action combinée est plus efficace que :func:`heappush` "
"suivie par un appel séparé à :func:`heappop`."

#: ../Doc/library/heapq.rst:64
msgid "Transform list *x* into a heap, in-place, in linear time."
msgstr ""
"Transforme une liste *x* en un tas, sans utiliser de tampon et en temps "
"linéaire."

#: ../Doc/library/heapq.rst:69
msgid ""
"Pop and return the smallest item from the *heap*, and also push the new "
"*item*. The heap size doesn't change. If the heap is empty, :exc:"
"`IndexError` is raised."
msgstr ""
"Extraie le plus petit élément de *heap* et introduit le nouvel élément "
"*item*. La taille du tas ne change pas. Si le tas est vide, une exception :"
"exc:`IndexError` est levée."

#: ../Doc/library/heapq.rst:72
msgid ""
"This one step operation is more efficient than a :func:`heappop` followed "
"by :func:`heappush` and can be more appropriate when using a fixed-size "
"heap. The pop/push combination always returns an element from the heap and "
"replaces it with *item*."
msgstr ""
"Cette opération en une étape est plus efficace qu'un appel à :func:`heappop` "
"suivi d'un appel à :func:`heappush` et est plus appropriée lorsque le tas "
"est de taille fixe. La combinaison *pop*/*push* renvoie toujours un élément "
"du tas et le remplace par *item*."

#: ../Doc/library/heapq.rst:77
msgid ""
"The value returned may be larger than the *item* added.  If that isn't "
"desired, consider using :func:`heappushpop` instead.  Its push/pop "
"combination returns the smaller of the two values, leaving the larger value "
"on the heap."
msgstr ""
"La valeur renvoyée peut être plus grande que l'élément *item* ajouté. Si "
"cela n'est pas souhaitable, utilisez plutôt :func:`heappushpop` à la place. "
"Sa combinaison *push*/*pop* renvoie le plus petit élément des deux valeurs "
"et laisse la plus grande sur le tas."

#: ../Doc/library/heapq.rst:83
msgid "The module also offers three general purpose functions based on heaps."
msgstr ""
"Ce module contient également trois fonctions génériques utilisant les tas."

#: ../Doc/library/heapq.rst:88
msgid ""
"Merge multiple sorted inputs into a single sorted output (for example, merge "
"timestamped entries from multiple log files).  Returns an :term:`iterator` "
"over the sorted values."
msgstr ""
"Fusionne plusieurs entrées ordonnées en une unique sortie ordonnée (par "
"exemple, fusionne des entrées datées provenant de multiples journaux "
"applicatifs). Renvoie un :term:`iterator` sur les valeurs ordonnées."

#: ../Doc/library/heapq.rst:92
msgid ""
"Similar to ``sorted(itertools.chain(*iterables))`` but returns an iterable, "
"does not pull the data into memory all at once, and assumes that each of the "
"input streams is already sorted (smallest to largest)."
msgstr ""
"Similaire à ``sorted(itertools.chain(*iterables))`` mais renvoie un "
"itérable, ne stocke pas toutes les données en mémoire en une fois et suppose "
"que chaque flux d'entrée est déjà classé (en ordre croissant)."

#: ../Doc/library/heapq.rst:96
msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr "A deux arguments optionnels qui doivent être fournis par mot clef."

#: ../Doc/library/heapq.rst:98
msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each input element.  The default value is "
"``None`` (compare the elements directly)."
msgstr ""
"*key* spécifie une :term:`key function` d'un argument utilisée pour extraire "
"une clef de comparaison de chaque élément de la liste. La valeur par défaut "
"est ``None`` (compare les éléments directement)."

#: ../Doc/library/heapq.rst:102
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the input elements "
"are merged as if each comparison were reversed. To achieve behavior similar "
"to ``sorted(itertools.chain(*iterables), reverse=True)``, all iterables must "
"be sorted from largest to smallest."
msgstr ""
"*reverse* est une valeur booléenne. Si elle est ``True``, la liste "
"d'éléments est fusionnée comme si toutes les comparaisons étaient inversées. "
"Pour obtenir un comportement similaire à ``sorted(itertools."
"chain(*iterables), reverse=True)``, tous les itérables doivent être classés "
"par ordre décroissant."

#: ../Doc/library/heapq.rst:107
msgid "Added the optional *key* and *reverse* parameters."
msgstr "Ajout des paramètres optionnels *key* et *reverse*."

#: ../Doc/library/heapq.rst:113
msgid ""
"Return a list with the *n* largest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key, "
"reverse=True)[:n]``."
msgstr ""
"Renvoie une liste contenant les *n* plus grands éléments du jeu de données "
"défini par *iterable*. Si l'option *key* est fournie, celle-ci spécifie une "
"fonction à un argument qui est utilisée pour extraire la clé de comparaison "
"de chaque élément dans *iterable* (par exemple, ``key=str.lower``). "
"Équivalent à : ``sorted(iterable, key=key, reverse=True)[:n]``."

#: ../Doc/library/heapq.rst:122
msgid ""
"Return a list with the *n* smallest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key)[:"
"n]``."
msgstr ""
"Renvoie une liste contenant les *n* plus petits éléments du jeu de données "
"défini par *iterable*. Si l'option *key* est fournie, celle-ci spécifie une "
"fonction à un argument qui est utilisée pour extraire la clé de comparaison "
"de chaque élément dans *iterable* (par exemple, ``key=str.lower``). "
"Équivalent à : ``sorted(iterable, key=key)[:n]``."

#: ../Doc/library/heapq.rst:128
msgid ""
"The latter two functions perform best for smaller values of *n*.  For larger "
"values, it is more efficient to use the :func:`sorted` function.  Also, when "
"``n==1``, it is more efficient to use the built-in :func:`min` and :func:"
"`max` functions.  If repeated usage of these functions is required, consider "
"turning the iterable into an actual heap."
msgstr ""
"Les deux fonctions précédentes sont les plus efficaces pour des petites "
"valeurs de *n*. Pour de grandes valeurs, il est préférable d'utiliser la "
"fonction :func:`sorted`. En outre, lorsque ``n==1``, il est plus efficace "
"d'utiliser les fonctions natives :func:`min` et :func:`max`. Si vous devez "
"utiliser ces fonctions de façon répétée, il est préférable de transformer "
"l'itérable en tas."

#: ../Doc/library/heapq.rst:136
msgid "Basic Examples"
msgstr "Exemples simples"

#: ../Doc/library/heapq.rst:138
msgid ""
"A `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ can be implemented by "
"pushing all values onto a heap and then popping off the smallest values one "
"at a time::"
msgstr ""
"Un `tri par tas <https://fr.wikipedia.org/wiki/Tri_par_tas>`_ peut être "
"implémenté en introduisant toutes les valeurs dans un tas puis en effectuant "
"l'extraction des éléments un par un ::"

#: ../Doc/library/heapq.rst:151
msgid ""
"This is similar to ``sorted(iterable)``, but unlike :func:`sorted`, this "
"implementation is not stable."
msgstr ""
"Ceci est similaire à ``sorted(iterable)`` mais, contrairement à :func:"
"`sorted`, cette implémentation n'est pas stable."

#: ../Doc/library/heapq.rst:154
msgid ""
"Heap elements can be tuples.  This is useful for assigning comparison values "
"(such as task priorities) alongside the main record being tracked::"
msgstr ""
"Les éléments d'un tas peuvent être des n-uplets. C'est pratique pour "
"assigner des valeurs de comparaison (par exemple, des priorités de tâches) "
"en plus de l'élément qui est suivi ::"

#: ../Doc/library/heapq.rst:167
msgid "Priority Queue Implementation Notes"
msgstr "Notes d'implémentation de la file de priorité"

#: ../Doc/library/heapq.rst:169
msgid ""
"A `priority queue <https://en.wikipedia.org/wiki/Priority_queue>`_ is common "
"use for a heap, and it presents several implementation challenges:"
msgstr ""
"Une `file de priorité <https://fr.wikipedia.org/wiki/File_de_priorit"
"%C3%A9>`_ est une application courante des tas et présente plusieurs défis "
"d'implémentation :"

#: ../Doc/library/heapq.rst:172
msgid ""
"Sort stability:  how do you get two tasks with equal priorities to be "
"returned in the order they were originally added?"
msgstr ""
"Stabilité du classement : comment s'assurer que deux tâches avec la même "
"priorité sont renvoyées dans l'ordre de leur ajout ?"

#: ../Doc/library/heapq.rst:175
msgid ""
"Tuple comparison breaks for (priority, task) pairs if the priorities are "
"equal and the tasks do not have a default comparison order."
msgstr ""
"La comparaison des couples (priorité, tâche) échoue si les priorités sont "
"identiques et que les tâches n'ont pas de relation d'ordre par défaut."

#: ../Doc/library/heapq.rst:178
msgid ""
"If the priority of a task changes, how do you move it to a new position in "
"the heap?"
msgstr ""
"Si la priorité d'une tâche change, comment la déplacer à sa nouvelle "
"position dans le tas ?"

#: ../Doc/library/heapq.rst:181
msgid ""
"Or if a pending task needs to be deleted, how do you find it and remove it "
"from the queue?"
msgstr ""
"Si une tâche en attente doit être supprimée, comment la trouver et la "
"supprimer de la file ?"

#: ../Doc/library/heapq.rst:184
msgid ""
"A solution to the first two challenges is to store entries as 3-element list "
"including the priority, an entry count, and the task.  The entry count "
"serves as a tie-breaker so that two tasks with the same priority are "
"returned in the order they were added. And since no two entry counts are the "
"same, the tuple comparison will never attempt to directly compare two tasks."
msgstr ""
"Une solution aux deux premiers problèmes consiste à stocker les entrées sous "
"forme de liste à 3 éléments incluant la priorité, le numéro d'ajout et la "
"tâche. Le numéro d'ajout sert à briser les égalités de telle sorte que deux "
"tâches avec la même priorité sont renvoyées dans l'ordre de leur insertion. "
"Puisque deux tâches ne peuvent jamais avoir le même numéro d'ajout, la "
"comparaison des triplets ne va jamais chercher à comparer des tâches entre "
"elles."

#: ../Doc/library/heapq.rst:190
msgid ""
"Another solution to the problem of non-comparable tasks is to create a "
"wrapper class that ignores the task item and only compares the priority "
"field::"
msgstr ""
"Une autre solution au fait que les tâches ne possèdent pas de relation "
"d'ordre est de créer une classe d'encapsulation qui ignore l'élément tâche "
"et ne compare que le champ priorité ::"

#: ../Doc/library/heapq.rst:201
msgid ""
"The remaining challenges revolve around finding a pending task and making "
"changes to its priority or removing it entirely.  Finding a task can be done "
"with a dictionary pointing to an entry in the queue."
msgstr ""
"Le problème restant consiste à trouver une tâche en attente et modifier sa "
"priorité ou la supprimer. Trouver une tâche peut être réalisé à l'aide d'un "
"dictionnaire pointant vers une entrée dans la file."

#: ../Doc/library/heapq.rst:205
msgid ""
"Removing the entry or changing its priority is more difficult because it "
"would break the heap structure invariants.  So, a possible solution is to "
"mark the entry as removed and add a new entry with the revised priority::"
msgstr ""
"Supprimer une entrée ou changer sa priorité est plus difficile puisque cela "
"romprait l'invariant de la structure de tas. Une solution possible est de "
"marquer l'entrée comme supprimée et d'ajouter une nouvelle entrée avec sa "
"priorité modifiée ::"

#: ../Doc/library/heapq.rst:239
msgid "Theory"
msgstr "Théorie"

#: ../Doc/library/heapq.rst:241
msgid ""
"Heaps are arrays for which ``a[k] <= a[2*k+1]`` and ``a[k] <= a[2*k+2]`` for "
"all *k*, counting elements from 0.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that ``a[0]`` is always its smallest element."
msgstr ""
"Les tas sont des tableaux pour lesquels ``a[k] <= a[2*k+1]`` et ``a[k] <= "
"a[2*k+2]`` pour tout *k* en comptant les éléments à partir de 0. Pour "
"simplifier la comparaison, les éléments inexistants sont considérés comme "
"étant infinis. L'intérêt des tas est que ``a[0]`` est toujours leur plus "
"petit élément."

#: ../Doc/library/heapq.rst:246
msgid ""
"The strange invariant above is meant to be an efficient memory "
"representation for a tournament.  The numbers below are *k*, not ``a[k]``::"
msgstr ""
"L'invariant étrange ci-dessus est une représentation efficace en mémoire "
"d'un tournoi. Les nombres ci-dessous sont *k* et non ``a[k]`` ::"

#: ../Doc/library/heapq.rst:259
msgid ""
"In the tree above, each cell *k* is topping ``2*k+1`` and ``2*k+2``. In a "
"usual binary tournament we see in sports, each cell is the winner over the "
"two cells it tops, and we can trace the winner down the tree to see all "
"opponents s/he had.  However, in many computer applications of such "
"tournaments, we do not need to trace the history of a winner. To be more "
"memory efficient, when a winner is promoted, we try to replace it by "
"something else at a lower level, and the rule becomes that a cell and the "
"two cells it tops contain three different items, but the top cell \"wins\" "
"over the two topped cells."
msgstr ""
"Dans l'arbre ci-dessus, chaque nœud *k* a pour enfants ``2*k+1`` et ``2*k"
"+2``. Dans les tournois binaires habituels dans les compétitions sportives, "
"chaque nœud est le vainqueur des deux nœuds inférieurs et nous pouvons "
"tracer le chemin du vainqueur le long de l'arbre afin de voir qui étaient "
"ses adversaires. Cependant, dans de nombreuses applications informatiques de "
"ces tournois, nous n'avons pas besoin de produire l'historique du vainqueur. "
"Afin d'occuper moins de mémoire, on remplace le vainqueur lors de sa "
"promotion par un autre élément à un plus bas niveau. La règle devient alors "
"qu'un nœud et les deux nœuds qu'il chapeaute contiennent trois éléments "
"différents, mais le nœud supérieur « gagne » contre les deux nœuds "
"inférieurs."

#: ../Doc/library/heapq.rst:268
msgid ""
"If this heap invariant is protected at all time, index 0 is clearly the "
"overall winner.  The simplest algorithmic way to remove it and find the "
"\"next\" winner is to move some loser (let's say cell 30 in the diagram "
"above) into the 0 position, and then percolate this new 0 down the tree, "
"exchanging values, until the invariant is re-established. This is clearly "
"logarithmic on the total number of items in the tree. By iterating over all "
"items, you get an O(n log n) sort."
msgstr ""
"Si cet invariant de tas est vérifié à tout instant, alors l'élément à "
"l'indice 0 est le vainqueur global. L'algorithme le plus simple pour le "
"retirer et trouver le vainqueur « suivant » consiste à déplacer un perdant "
"(par exemple le nœud 30 dans le diagramme ci-dessus) à la position 0, puis à "
"faire redescendre cette nouvelle racine dans l'arbre en échangeant sa valeur "
"avec celle d'un de ses fils jusqu'à ce que l'invariant soit rétabli. Cette "
"approche a un coût logarithmique par rapport au nombre total d'éléments dans "
"l'arbre. En itérant sur tous les éléments, le classement s'effectue en O(n "
"log n) opérations."

#: ../Doc/library/heapq.rst:275
msgid ""
"A nice feature of this sort is that you can efficiently insert new items "
"while the sort is going on, provided that the inserted items are not \"better"
"\" than the last 0'th element you extracted.  This is especially useful in "
"simulation contexts, where the tree holds all incoming events, and the \"win"
"\" condition means the smallest scheduled time.  When an event schedules "
"other events for execution, they are scheduled into the future, so they can "
"easily go into the heap.  So, a heap is a good structure for implementing "
"schedulers (this is what I used for my MIDI sequencer :-)."
msgstr ""
"Une propriété agréable de cet algorithme est qu'il possible d'insérer "
"efficacement de nouveaux éléments en cours de classement, du moment que les "
"éléments insérés ne sont pas « meilleurs » que le dernier élément qui a été "
"extrait. Ceci s'avère très utile dans des simulations où l'arbre contient la "
"liste des événements arrivants et que la condition de « victoire » est le "
"plus petit temps d'exécution planifié. Lorsqu'un événement programme "
"l'exécution d'autres événements, ceux-ci sont planifiés pour le futur et "
"peuvent donc rejoindre le tas. Ainsi, le tas est une bonne structure pour "
"implémenter un ordonnanceur (et c'est ce que j'ai utilisé pour mon "
"séquenceur MIDI ☺)."

#: ../Doc/library/heapq.rst:284
msgid ""
"Various structures for implementing schedulers have been extensively "
"studied, and heaps are good for this, as they are reasonably speedy, the "
"speed is almost constant, and the worst case is not much different than the "
"average case. However, there are other representations which are more "
"efficient overall, yet the worst cases might be terrible."
msgstr ""
"Plusieurs structures ont été étudiées en détail pour implémenter des "
"ordonnanceurs et les tas sont bien adaptés : ils sont raisonnablement "
"rapides, leur vitesse est presque constante et le pire cas ne diffère pas "
"trop du cas moyen. S'il existe des représentations qui sont plus efficaces "
"en général, les pires cas peuvent être terriblement mauvais."

#: ../Doc/library/heapq.rst:290
msgid ""
"Heaps are also very useful in big disk sorts.  You most probably all know "
"that a big sort implies producing \"runs\" (which are pre-sorted sequences, "
"whose size is usually related to the amount of CPU memory), followed by a "
"merging passes for these runs, which merging is often very cleverly "
"organised [#]_. It is very important that the initial sort produces the "
"longest runs possible.  Tournaments are a good way to achieve that.  If, "
"using all the memory available to hold a tournament, you replace and "
"percolate items that happen to fit the current run, you'll produce runs "
"which are twice the size of the memory for random input, and much better for "
"input fuzzily ordered."
msgstr ""
"Les tas sont également très utiles pour ordonner les données sur de gros "
"disques. Vous savez probablement qu'un gros tri implique la production de "
"séquences pré-classées (dont la taille est généralement liée à la quantité "
"de mémoire CPU disponible), suivie par une passe de fusion qui est "
"généralement organisée de façon très intelligente [#]_. Il est très "
"important que le classement initial produise des séquences les plus longues "
"possibles. Les tournois sont une bonne façon d'arriver à ce résultat. Si, en "
"utilisant toute la mémoire disponible pour stocker un tournoi, vous "
"remplacez et faites percoler les éléments qui s'avèrent acceptables pour la "
"séquence courante, vous produirez des séquences d'une taille égale au double "
"de la mémoire pour une entrée aléatoire et bien mieux pour une entrée "
"approximativement triée."

#: ../Doc/library/heapq.rst:300
msgid ""
"Moreover, if you output the 0'th item on disk and get an input which may not "
"fit in the current tournament (because the value \"wins\" over the last "
"output value), it cannot fit in the heap, so the size of the heap "
"decreases.  The freed memory could be cleverly reused immediately for "
"progressively building a second heap, which grows at exactly the same rate "
"the first heap is melting.  When the first heap completely vanishes, you "
"switch heaps and start a new run.  Clever and quite effective!"
msgstr ""
"Qui plus est, si vous écrivez l'élément 0 sur le disque et que vous recevez "
"en entrée un élément qui n'est pas adapté au tournoi actuel (parce que sa "
"valeur « gagne » par rapport à la dernière valeur de sortie), alors il ne "
"peut pas être stocké dans le tas donc la taille de ce dernier diminue. La "
"mémoire libérée peut être réutilisée immédiatement pour progressivement "
"construire un deuxième tas, qui croit à la même vitesse que le premier "
"décroît. Lorsque le premier tas a complètement disparu, vous échangez les "
"tas et démarrez une nouvelle séquence. Malin et plutôt efficace !"

#: ../Doc/library/heapq.rst:308
msgid ""
"In a word, heaps are useful memory structures to know.  I use them in a few "
"applications, and I think it is good to keep a 'heap' module around. :-)"
msgstr ""
"Pour résumer, les tas sont des structures de données qu'il est bon de "
"connaître. Je les utilise dans quelques applications et je pense qu'il est "
"bon de garder le module *heap* sous le coude. ☺"

#: ../Doc/library/heapq.rst:312
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/library/heapq.rst:313
msgid ""
"The disk balancing algorithms which are current, nowadays, are more annoying "
"than clever, and this is a consequence of the seeking capabilities of the "
"disks. On devices which cannot seek, like big tape drives, the story was "
"quite different, and one had to be very clever to ensure (far in advance) "
"that each tape movement will be the most effective possible (that is, will "
"best participate at \"progressing\" the merge).  Some tapes were even able "
"to read backwards, and this was also used to avoid the rewinding time. "
"Believe me, real good tape sorts were quite spectacular to watch! From all "
"times, sorting has always been a Great Art! :-)"
msgstr ""
"Les algorithmes de répartition de charge pour les disques, courants de nos "
"jours, sont plus embêtants qu'utiles, en raison de la capacité des disques à "
"réaliser des accès aléatoires. Sur les périphériques qui ne peuvent faire "
"que de la lecture séquentielle, comme les gros lecteurs à bandes, le besoin "
"était différent et il fallait être malin pour s'assurer (bien à l'avance) "
"que chaque mouvement de bande serait le plus efficace possible (c'est-à-dire "
"participerait au mieux à l'« avancée » de la fusion). Certaines cassettes "
"pouvaient même lire à l'envers et cela était aussi utilisé pour éviter de "
"remonter dans le temps. Croyez-moi, les bons tris sur bandes étaient "
"spectaculaires à regarder ! Depuis la nuit des temps, trier a toujours été "
"le Grand Art ! ☺"
