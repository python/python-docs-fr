# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 22:40+0100\n"
"PO-Revision-Date: 2024-03-15 22:32+0100\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/xml.etree.elementtree.rst:2
#, fuzzy
msgid ":mod:`!xml.etree.ElementTree` --- The ElementTree XML API"
msgstr ":mod:`xml.etree.ElementTree` — L'API *ElementTree* XML"

#: library/xml.etree.elementtree.rst:9
msgid "**Source code:** :source:`Lib/xml/etree/ElementTree.py`"
msgstr "**Code Source:** :source:`Lib/xml/etree/ElementTree.py`"

#: library/xml.etree.elementtree.rst:13
msgid ""
"The :mod:`xml.etree.ElementTree` module implements a simple and efficient "
"API for parsing and creating XML data."
msgstr ""
"Le  module :mod:`xml.etree.ElementTree` implémente une API simple et "
"efficace pour analyser et créer des données XML."

# suit un :
#: library/xml.etree.elementtree.rst:16
msgid "This module will use a fast implementation whenever available."
msgstr ""
"ce module utilise une implémentation rapide chaque fois que c'est possible."

# suit un :
#: library/xml.etree.elementtree.rst:19
#, fuzzy
msgid "The :mod:`!xml.etree.cElementTree` module is deprecated."
msgstr "le module :mod:`xml.etree.cElementTree` est obsolète."

# suit un :
#: library/xml.etree.elementtree.rst:25
msgid ""
"The :mod:`xml.etree.ElementTree` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data "
"see :ref:`xml-vulnerabilities`."
msgstr ""
"le module :mod:`xml.sax` n'est pas sécurisé contre les données construites "
"de façon malveillante. Si vous avez besoin d'analyser des données non "
"sécurisées ou non authentifiées, référez-vous à :ref:`xml-vulnerabilities`."

#: library/xml.etree.elementtree.rst:30
msgid "Tutorial"
msgstr "Tutoriel"

#: library/xml.etree.elementtree.rst:32
msgid ""
"This is a short tutorial for using :mod:`xml.etree.ElementTree` (``ET`` in "
"short).  The goal is to demonstrate some of the building blocks and basic "
"concepts of the module."
msgstr ""
"Ceci est un petit tutoriel pour utiliser :mod:`xml.etree.ElementTree` "
"(``ET``). Le but est de montrer quelques composants et les concepts basiques "
"du module."

#: library/xml.etree.elementtree.rst:37
msgid "XML tree and elements"
msgstr "Arborescence et éléments XML"

#: library/xml.etree.elementtree.rst:39
msgid ""
"XML is an inherently hierarchical data format, and the most natural way to "
"represent it is with a tree.  ``ET`` has two classes for this purpose - :"
"class:`ElementTree` represents the whole XML document as a tree, and :class:"
"`Element` represents a single node in this tree.  Interactions with the "
"whole document (reading and writing to/from files) are usually done on the :"
"class:`ElementTree` level.  Interactions with a single XML element and its "
"sub-elements are done on the :class:`Element` level."
msgstr ""
"XML est un format de données fondamentalement hiérarchique et la façon la "
"plus naturelle de le représenter est avec un arbre. ``ET`` a deux classes "
"pour ce but : :class:`ElementTree` représente l'ensemble du document XML "
"comme un arbre et :class:`Element` représente un simple nœud dans cet arbre. "
"Les interactions (lire et écrire vers et depuis des fichiers) sur le "
"document sont habituellement effectuées au niveau de :class:`ElementTree`. "
"Les interactions sur un seul élément XML et ses sous-éléments sont "
"effectuées au niveau de :class:`Element`."

#: library/xml.etree.elementtree.rst:50
msgid "Parsing XML"
msgstr "Analyse XML"

#: library/xml.etree.elementtree.rst:52
#, fuzzy
msgid ""
"We'll be using the fictive :file:`country_data.xml` XML document as the "
"sample data for this section:"
msgstr ""
"Nous utilisons le document XML suivant comme exemple pour cette section :"

#: library/xml.etree.elementtree.rst:54
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank>1</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank>4</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank>68</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""

#: library/xml.etree.elementtree.rst:80
msgid "We can import this data by reading from a file::"
msgstr "Nous pouvons importer ces données en lisant un fichier ::"

#: library/xml.etree.elementtree.rst:82
msgid ""
"import xml.etree.ElementTree as ET\n"
"tree = ET.parse('country_data.xml')\n"
"root = tree.getroot()"
msgstr ""

#: library/xml.etree.elementtree.rst:86
msgid "Or directly from a string::"
msgstr "Ou depuis une chaîne de caractères ::"

#: library/xml.etree.elementtree.rst:88
msgid "root = ET.fromstring(country_data_as_string)"
msgstr ""

#: library/xml.etree.elementtree.rst:90
msgid ""
":func:`fromstring` parses XML from a string directly into an :class:"
"`Element`, which is the root element of the parsed tree.  Other parsing "
"functions may create an :class:`ElementTree`.  Check the documentation to be "
"sure."
msgstr ""
":func:`fromstring` analyse les données XML depuis une chaîne de caractères "
"et produit un :class:`Element`, qui est l'élément racine de l'arbre "
"analysé.  D'autres fonctions d'analyse peuvent créer un :class:"
"`ElementTree`.  Vérifiez la documentation pour en être sûr."

#: library/xml.etree.elementtree.rst:94
msgid ""
"As an :class:`Element`, ``root`` has a tag and a dictionary of attributes::"
msgstr ""
"En tant qu':class:`Element`, ``root`` a une balise (*tag*) et un "
"dictionnaire d'attributs ::"

#: library/xml.etree.elementtree.rst:96
msgid ""
">>> root.tag\n"
"'data'\n"
">>> root.attrib\n"
"{}"
msgstr ""

#: library/xml.etree.elementtree.rst:101
msgid "It also has children nodes over which we can iterate::"
msgstr ""
"Il contient aussi des nœuds enfants sur lesquels nous pouvons itérer ::"

#: library/xml.etree.elementtree.rst:103
msgid ""
">>> for child in root:\n"
"...     print(child.tag, child.attrib)\n"
"...\n"
"country {'name': 'Liechtenstein'}\n"
"country {'name': 'Singapore'}\n"
"country {'name': 'Panama'}"
msgstr ""

#: library/xml.etree.elementtree.rst:110
msgid "Children are nested, and we can access specific child nodes by index::"
msgstr ""
"Les enfants sont imbriqués et nous pouvons accéder aux nœuds enfants "
"spécifiques *via* un indice ::"

#: library/xml.etree.elementtree.rst:112
msgid ""
">>> root[0][1].text\n"
"'2008'"
msgstr ""

# suit un :
#: library/xml.etree.elementtree.rst:118
msgid ""
"Not all elements of the XML input will end up as elements of the parsed "
"tree. Currently, this module skips over any XML comments, processing "
"instructions, and document type declarations in the input. Nevertheless, "
"trees built using this module's API rather than parsing from XML text can "
"have comments and processing instructions in them; they will be included "
"when generating XML output. A document type declaration may be accessed by "
"passing a custom :class:`TreeBuilder` instance to the :class:`XMLParser` "
"constructor."
msgstr ""
"les éléments du XML d'entrée ne sont pas tous considérés comme des éléments "
"de l'arborescence. Actuellement, le module ignore les commentaires XML, les "
"instructions de traitements et la déclaration du type de document dans "
"l'entrée. Néanmoins, les arborescences construites en utilisant l'API du "
"module plutôt que par l'analyse du texte XML peuvent contenir des "
"commentaires et des instructions de traitement ; ils seront inclus lors de "
"la génération du XML de sortie. La DTD du document est accessible en passant "
"une instance de :class:`TreeBuilder` au constructeur de :class:`XMLParser`."

#: library/xml.etree.elementtree.rst:132
msgid "Pull API for non-blocking parsing"
msgstr "API à flux tiré"

#: library/xml.etree.elementtree.rst:134
msgid ""
"Most parsing functions provided by this module require the whole document to "
"be read at once before returning any result.  It is possible to use an :"
"class:`XMLParser` and feed data into it incrementally, but it is a push API "
"that calls methods on a callback target, which is too low-level and "
"inconvenient for most needs.  Sometimes what the user really wants is to be "
"able to parse XML incrementally, without blocking operations, while enjoying "
"the convenience of fully constructed :class:`Element` objects."
msgstr ""
"La plupart des fonctions d'analyse fournies par ce module nécessitent que le "
"document entier soit lu en même temps avant de renvoyer un résultat. Il est "
"possible d'utiliser un :class:`XMLParser` et d'y introduire des données de "
"manière incrémentielle, mais il s'agit d'une API à flux poussé qui appelle "
"des méthodes par rappel automatique, ce qui est de trop bas niveau et peu "
"pratique pour la plupart des besoins. Parfois, ce que l'utilisateur souhaite "
"réellement, c'est pouvoir analyser du XML de manière incrémentielle, sans "
"bloquer les opérations, tout en bénéficiant de la commodité des objets :"
"class:`Element` entièrement construits."

#: library/xml.etree.elementtree.rst:142
msgid ""
"The most powerful tool for doing this is :class:`XMLPullParser`.  It does "
"not require a blocking read to obtain the XML data, and is instead fed with "
"data incrementally with :meth:`XMLPullParser.feed` calls.  To get the parsed "
"XML elements, call :meth:`XMLPullParser.read_events`.  Here is an example::"
msgstr ""
"L'outil le plus puissant pour ce faire est :class:`XMLPullParser`. Il ne "
"nécessite pas de lecture bloquante pour obtenir les données XML et est "
"plutôt alimenté en données de manière incrémentielle avec des appels à :meth:"
"`XMLPullParser.feed`. Pour obtenir les éléments XML analysés, appelez :meth:"
"`XMLPullParser.read_events`. Voici un exemple ::"

#: library/xml.etree.elementtree.rst:147
msgid ""
">>> parser = ET.XMLPullParser(['start', 'end'])\n"
">>> parser.feed('<mytag>sometext')\n"
">>> list(parser.read_events())\n"
"[('start', <Element 'mytag' at 0x7fa66db2be58>)]\n"
">>> parser.feed(' more text</mytag>')\n"
">>> for event, elem in parser.read_events():\n"
"...     print(event)\n"
"...     print(elem.tag, 'text=', elem.text)\n"
"...\n"
"end\n"
"mytag text= sometext more text"
msgstr ""

#: library/xml.etree.elementtree.rst:159
msgid ""
"The obvious use case is applications that operate in a non-blocking fashion "
"where the XML data is being received from a socket or read incrementally "
"from some storage device.  In such cases, blocking reads are unacceptable."
msgstr ""
"Le cas d'utilisation évident concerne les applications qui fonctionnent de "
"manière non bloquante dans lesquelles les données XML sont reçues à partir "
"d'un connecteur réseau ou lues de manière incrémentielle à partir d'un "
"périphérique de stockage. Dans de tels cas, le blocage des lectures est "
"inacceptable."

#: library/xml.etree.elementtree.rst:163
msgid ""
"Because it's so flexible, :class:`XMLPullParser` can be inconvenient to use "
"for simpler use-cases.  If you don't mind your application blocking on "
"reading XML data but would still like to have incremental parsing "
"capabilities, take a look at :func:`iterparse`.  It can be useful when "
"you're reading a large XML document and don't want to hold it wholly in "
"memory."
msgstr ""
"Parce qu'il est très flexible, :class:`XMLPullParser` peut être peu pratique "
"à utiliser pour des cas d'utilisation plus simples. Si cela ne vous dérange "
"pas que votre application se bloque pendant la lecture de données XML mais "
"que vous souhaitez tout de même disposer de capacités d'analyse "
"incrémentielle, jetez un œil à :func:`iterparse`. Cela peut être utile "
"lorsque vous lisez un document XML volumineux et que vous ne souhaitez pas "
"le conserver entièrement en mémoire."

#: library/xml.etree.elementtree.rst:169
msgid ""
"Where *immediate* feedback through events is wanted, calling method :meth:"
"`XMLPullParser.flush` can help reduce delay; please make sure to study the "
"related security notes."
msgstr ""

#: library/xml.etree.elementtree.rst:175
msgid "Finding interesting elements"
msgstr "Atteinte d'éléments d'intérêt"

#: library/xml.etree.elementtree.rst:177
msgid ""
":class:`Element` has some useful methods that help iterate recursively over "
"all the sub-tree below it (its children, their children, and so on).  For "
"example, :meth:`Element.iter`::"
msgstr ""
":class:`Element` a quelques méthodes très utiles qui aident à parcourir "
"récursivement tous les sous-arbres (ses enfants, leurs enfants et ainsi de "
"suite). Par exemple, :meth:`Element.iter` ::"

#: library/xml.etree.elementtree.rst:181
msgid ""
">>> for neighbor in root.iter('neighbor'):\n"
"...     print(neighbor.attrib)\n"
"...\n"
"{'name': 'Austria', 'direction': 'E'}\n"
"{'name': 'Switzerland', 'direction': 'W'}\n"
"{'name': 'Malaysia', 'direction': 'N'}\n"
"{'name': 'Costa Rica', 'direction': 'W'}\n"
"{'name': 'Colombia', 'direction': 'E'}"
msgstr ""

#: library/xml.etree.elementtree.rst:190
msgid ""
":meth:`Element.findall` finds only elements with a tag which are direct "
"children of the current element.  :meth:`Element.find` finds the *first* "
"child with a particular tag, and :attr:`Element.text` accesses the element's "
"text content.  :meth:`Element.get` accesses the element's attributes::"
msgstr ""
":meth:`Element.findall` récupère seulement les éléments avec une balise qui "
"sont les descendants directs de l'élément courant. :meth:`Element.find` "
"récupère le *premier* élément avec une balise particulière et :attr:`Element."
"text` accède au contenu textuel de l'élément.  :meth:`Element.get` accède "
"aux attributs de l'élément ::"

#: library/xml.etree.elementtree.rst:195
msgid ""
">>> for country in root.findall('country'):\n"
"...     rank = country.find('rank').text\n"
"...     name = country.get('name')\n"
"...     print(name, rank)\n"
"...\n"
"Liechtenstein 1\n"
"Singapore 4\n"
"Panama 68"
msgstr ""

#: library/xml.etree.elementtree.rst:204
msgid ""
"More sophisticated specification of which elements to look for is possible "
"by using :ref:`XPath <elementtree-xpath>`."
msgstr ""
"Une caractérisation plus sophistiquée des éléments à rechercher est possible "
"en utilisant :ref:`XPath <elementtree-xpath>`."

#: library/xml.etree.elementtree.rst:208
msgid "Modifying an XML File"
msgstr "Modification d'un fichier XML"

#: library/xml.etree.elementtree.rst:210
msgid ""
":class:`ElementTree` provides a simple way to build XML documents and write "
"them to files. The :meth:`ElementTree.write` method serves this purpose."
msgstr ""
":class:`ElementTree` fournit un moyen simple de créer des documents XML et "
"de les écrire dans des fichiers. La méthode :meth:`ElementTree.write` sert à "
"cet effet."

#: library/xml.etree.elementtree.rst:213
msgid ""
"Once created, an :class:`Element` object may be manipulated by directly "
"changing its fields (such as :attr:`Element.text`), adding and modifying "
"attributes (:meth:`Element.set` method), as well as adding new children (for "
"example with :meth:`Element.append`)."
msgstr ""
"Une fois créé, un objet :class:`Element` peut être manipulé en changeant "
"directement ses champs (tels que :attr:`Element.text`), en ajoutant et en "
"modifiant des attributs (méthode :meth:`Element.set`), ou en ajoutant de "
"nouveaux enfants (par exemple avec :meth:`Element.append`)."

#: library/xml.etree.elementtree.rst:218
msgid ""
"Let's say we want to add one to each country's rank, and add an ``updated`` "
"attribute to the rank element::"
msgstr ""
"Disons que nous voulons en ajouter un au classement de chaque pays, et "
"ajouter un attribut *updated* (« mis à jour ») à l'élément de classement ::"

#: library/xml.etree.elementtree.rst:221
msgid ""
">>> for rank in root.iter('rank'):\n"
"...     new_rank = int(rank.text) + 1\n"
"...     rank.text = str(new_rank)\n"
"...     rank.set('updated', 'yes')\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""

#: library/xml.etree.elementtree.rst:228 library/xml.etree.elementtree.rst:272
msgid "Our XML now looks like this:"
msgstr "Maintenant, notre XML ressemble à ceci :"

#: library/xml.etree.elementtree.rst:230
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank updated=\"yes\">69</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""

#: library/xml.etree.elementtree.rst:256
msgid ""
"We can remove elements using :meth:`Element.remove`.  Let's say we want to "
"remove all countries with a rank higher than 50::"
msgstr ""
"Nous pouvons supprimer des éléments en utilisant :meth:`Element.remove`. "
"Supposons que nous souhaitions supprimer tous les pays dont le classement "
"est supérieur à 50 ::"

#: library/xml.etree.elementtree.rst:259
msgid ""
">>> for country in root.findall('country'):\n"
"...     # using root.findall() to avoid removal during traversal\n"
"...     rank = int(country.find('rank').text)\n"
"...     if rank > 50:\n"
"...         root.remove(country)\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""

#: library/xml.etree.elementtree.rst:267
msgid ""
"Note that concurrent modification while iterating can lead to problems, just "
"like when iterating and modifying Python lists or dicts. Therefore, the "
"example first collects all matching elements with ``root.findall()``, and "
"only then iterates over the list of matches."
msgstr ""
"Notez que les modifications simultanées lors de l'itération peuvent "
"entraîner des problèmes, tout comme lors de l'itération et de la "
"modification de listes ou de dictionnaires Python. Par conséquent, l'exemple "
"collecte d'abord tous les éléments correspondants avec ``root.findall()``, "
"et après seulement parcourt la liste des correspondances."

#: library/xml.etree.elementtree.rst:274
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"</data>"
msgstr ""

#: library/xml.etree.elementtree.rst:294
msgid "Building XML documents"
msgstr "Création de documents XML"

#: library/xml.etree.elementtree.rst:296
msgid ""
"The :func:`SubElement` function also provides a convenient way to create new "
"sub-elements for a given element::"
msgstr ""
"La fonction :func:`SubElement` fournit également un moyen pratique de créer "
"de nouveaux sous-éléments pour un élément donné ::"

#: library/xml.etree.elementtree.rst:299
msgid ""
">>> a = ET.Element('a')\n"
">>> b = ET.SubElement(a, 'b')\n"
">>> c = ET.SubElement(a, 'c')\n"
">>> d = ET.SubElement(c, 'd')\n"
">>> ET.dump(a)\n"
"<a><b /><c><d /></c></a>"
msgstr ""

#: library/xml.etree.elementtree.rst:307
msgid "Parsing XML with Namespaces"
msgstr "Analyse d'un XML avec des espaces de noms"

#: library/xml.etree.elementtree.rst:309
msgid ""
"If the XML input has `namespaces <https://en.wikipedia.org/wiki/"
"XML_namespace>`__, tags and attributes with prefixes in the form ``prefix:"
"sometag`` get expanded to ``{uri}sometag`` where the *prefix* is replaced by "
"the full *URI*. Also, if there is a `default namespace <https://www.w3.org/"
"TR/xml-names/#defaulting>`__, that full URI gets prepended to all of the non-"
"prefixed tags."
msgstr ""
"Si l'entrée XML a des `espaces de noms <https://fr.wikipedia.org/wiki/"
"Espace_de_noms_XML>`__, les balises et les attributs avec des préfixes sous "
"la forme *préfixe:unebalise* sont étendus à ``{uri}unebalise`` où le "
"*préfixe* est remplacé par l'*URI* complet. De plus, s'il existe un `espace "
"de noms par défaut <https://www.w3.org/TR/xml-names/#defaulting>`__, cet URI "
"complet est ajouté au début de toutes les balises non préfixées."

#: library/xml.etree.elementtree.rst:317
msgid ""
"Here is an XML example that incorporates two namespaces, one with the prefix "
"\"fictional\" and the other serving as the default namespace:"
msgstr ""
"Voici un exemple XML qui intègre deux espaces de noms, l'un avec le préfixe "
"*fictional* et l'autre servant d'espace de noms par défaut :"

#: library/xml.etree.elementtree.rst:320
msgid ""
"<?xml version=\"1.0\"?>\n"
"<actors xmlns:fictional=\"http://characters.example.com\"\n"
"        xmlns=\"http://people.example.com\">\n"
"    <actor>\n"
"        <name>John Cleese</name>\n"
"        <fictional:character>Lancelot</fictional:character>\n"
"        <fictional:character>Archie Leach</fictional:character>\n"
"    </actor>\n"
"    <actor>\n"
"        <name>Eric Idle</name>\n"
"        <fictional:character>Sir Robin</fictional:character>\n"
"        <fictional:character>Gunther</fictional:character>\n"
"        <fictional:character>Commander Clement</fictional:character>\n"
"    </actor>\n"
"</actors>"
msgstr ""

#: library/xml.etree.elementtree.rst:338
msgid ""
"One way to search and explore this XML example is to manually add the URI to "
"every tag or attribute in the xpath of a :meth:`~Element.find` or :meth:"
"`~Element.findall`::"
msgstr ""
"Une façon de rechercher et d'explorer cet exemple XML consiste à ajouter "
"manuellement l'URI à chaque balise ou attribut dans le *xpath* d'une "
"recherche :meth:`~Element.find` ou :meth:`~Element.findall` ::"

#: library/xml.etree.elementtree.rst:342
msgid ""
"root = fromstring(xml_text)\n"
"for actor in root.findall('{http://people.example.com}actor'):\n"
"    name = actor.find('{http://people.example.com}name')\n"
"    print(name.text)\n"
"    for char in actor.findall('{http://characters.example.com}character'):\n"
"        print(' |-->', char.text)"
msgstr ""

#: library/xml.etree.elementtree.rst:349
msgid ""
"A better way to search the namespaced XML example is to create a dictionary "
"with your own prefixes and use those in the search functions::"
msgstr ""
"Une meilleure façon de rechercher dans l'exemple XML avec espace de noms "
"consiste à créer un dictionnaire avec vos propres préfixes et à les utiliser "
"dans les fonctions de recherche ::"

#: library/xml.etree.elementtree.rst:352
msgid ""
"ns = {'real_person': 'http://people.example.com',\n"
"      'role': 'http://characters.example.com'}\n"
"\n"
"for actor in root.findall('real_person:actor', ns):\n"
"    name = actor.find('real_person:name', ns)\n"
"    print(name.text)\n"
"    for char in actor.findall('role:character', ns):\n"
"        print(' |-->', char.text)"
msgstr ""

#: library/xml.etree.elementtree.rst:361
msgid "These two approaches both output::"
msgstr "Ces deux approches donnent le même résultat ::"

#: library/xml.etree.elementtree.rst:363
msgid ""
"John Cleese\n"
" |--> Lancelot\n"
" |--> Archie Leach\n"
"Eric Idle\n"
" |--> Sir Robin\n"
" |--> Gunther\n"
" |--> Commander Clement"
msgstr ""

#: library/xml.etree.elementtree.rst:375
msgid "XPath support"
msgstr "Prise en charge de *XPath*"

#: library/xml.etree.elementtree.rst:377
msgid ""
"This module provides limited support for `XPath expressions <https://www.w3."
"org/TR/xpath>`_ for locating elements in a tree.  The goal is to support a "
"small subset of the abbreviated syntax; a full XPath engine is outside the "
"scope of the module."
msgstr ""
"Ce module fournit une prise en charge limitée des `expressions XPath "
"<https://www.w3.org/TR/xpath>`_ pour localiser des éléments dans une "
"arborescence. L'objectif est de prendre en charge un petit sous-ensemble de "
"la syntaxe abrégée ; un moteur *XPath* complet sort du cadre du module."

#: library/xml.etree.elementtree.rst:383 library/xml.etree.elementtree.rst:782
msgid "Example"
msgstr "Exemple"

#: library/xml.etree.elementtree.rst:385
msgid ""
"Here's an example that demonstrates some of the XPath capabilities of the "
"module.  We'll be using the ``countrydata`` XML document from the :ref:"
"`Parsing XML <elementtree-parsing-xml>` section::"
msgstr ""
"Voici un exemple qui démontre certaines des fonctionnalités *XPath* du "
"module. Nous utilisons le document XML ``countrydata`` de la section :ref:"
"`Parsing XML <elementtree-parsing-xml>` ::"

#: library/xml.etree.elementtree.rst:389
msgid ""
"import xml.etree.ElementTree as ET\n"
"\n"
"root = ET.fromstring(countrydata)\n"
"\n"
"# Top-level elements\n"
"root.findall(\".\")\n"
"\n"
"# All 'neighbor' grand-children of 'country' children of the top-level\n"
"# elements\n"
"root.findall(\"./country/neighbor\")\n"
"\n"
"# Nodes with name='Singapore' that have a 'year' child\n"
"root.findall(\".//year/..[@name='Singapore']\")\n"
"\n"
"# 'year' nodes that are children of nodes with name='Singapore'\n"
"root.findall(\".//*[@name='Singapore']/year\")\n"
"\n"
"# All 'neighbor' nodes that are the second child of their parent\n"
"root.findall(\".//neighbor[2]\")"
msgstr ""

#: library/xml.etree.elementtree.rst:409
msgid ""
"For XML with namespaces, use the usual qualified ``{namespace}tag`` "
"notation::"
msgstr ""
"Pour du XML avec des espaces de noms, utilisez la notation qualifiée "
"habituelle ``{namespace}tag`` ::"

#: library/xml.etree.elementtree.rst:411
msgid ""
"# All dublin-core \"title\" tags in the document\n"
"root.findall(\".//{http://purl.org/dc/elements/1.1/}title\")"
msgstr ""

#: library/xml.etree.elementtree.rst:416
msgid "Supported XPath syntax"
msgstr "Prise en charge de la syntaxe *XPath*"

#: library/xml.etree.elementtree.rst:421
msgid "Syntax"
msgstr "Syntaxe"

#: library/xml.etree.elementtree.rst:421
msgid "Meaning"
msgstr "Signification"

#: library/xml.etree.elementtree.rst:423
msgid "``tag``"
msgstr "``tag``"

#: library/xml.etree.elementtree.rst:423
msgid ""
"Selects all child elements with the given tag. For example, ``spam`` selects "
"all child elements named ``spam``, and ``spam/egg`` selects all "
"grandchildren named ``egg`` in all children named ``spam``.  ``{namespace}"
"*`` selects all tags in the given namespace, ``{*}spam`` selects tags named "
"``spam`` in any (or no) namespace, and ``{}*`` only selects tags that are "
"not in a namespace."
msgstr ""
"Sélectionne tous les éléments enfants avec une balise donnée. Par exemple, "
"``spam`` sélectionne tous les éléments enfants nommés ``spam`` et ``spam/"
"egg`` sélectionne tous les petits-enfants nommés ``egg`` dans les enfants "
"nommés ``spam``. ``{namespace}*`` sélectionne toutes les balises dans "
"l'espace de noms donné, ``{*}spam`` sélectionne les balises nommées ``spam`` "
"dans n'importe quel (ou aucun) espace de noms et ``{}*`` sélectionne "
"seulement les balises qui ne sont pas dans un espace de noms."

# suit un :
#: library/xml.etree.elementtree.rst:432
msgid "Support for star-wildcards was added."
msgstr "la prise en charge des caractères génériques étoiles a été ajoutée."

#: library/xml.etree.elementtree.rst:435
msgid "``*``"
msgstr "``*``"

#: library/xml.etree.elementtree.rst:435
msgid ""
"Selects all child elements, including comments and processing instructions.  "
"For example, ``*/egg`` selects all grandchildren named ``egg``."
msgstr ""
"Sélectionne tous les éléments enfants, y compris les commentaires et les "
"instructions de traitement. Par exemple, ``*/egg`` sélectionne tous les "
"petits-enfants nommés ``egg``."

#: library/xml.etree.elementtree.rst:439
msgid "``.``"
msgstr "``.``"

#: library/xml.etree.elementtree.rst:439
msgid ""
"Selects the current node.  This is mostly useful at the beginning of the "
"path, to indicate that it's a relative path."
msgstr ""
"Sélectionne le nœud actuel. C'est surtout utile au début du chemin, pour "
"indiquer qu'il s'agit d'un chemin relatif."

#: library/xml.etree.elementtree.rst:443
msgid "``//``"
msgstr "``//``"

#: library/xml.etree.elementtree.rst:443
msgid ""
"Selects all subelements, on all levels beneath the current  element.  For "
"example, ``.//egg`` selects all ``egg`` elements in the entire tree."
msgstr ""
"Sélectionne tous les sous-éléments, à tous les niveaux situés sous l'élément "
"actuel. Par exemple, ``.//egg`` sélectionne tous les éléments ``egg`` dans "
"l'arborescence entière."

#: library/xml.etree.elementtree.rst:447
msgid "``..``"
msgstr "``..``"

#: library/xml.etree.elementtree.rst:447
msgid ""
"Selects the parent element.  Returns ``None`` if the path attempts to reach "
"the ancestors of the start element (the element ``find`` was called on)."
msgstr ""
"Sélectionne l'élément parent. Renvoie ``None`` si le chemin tente "
"d'atteindre les ancêtres de l'élément de départ (l'élément sur lequel "
"``find`` a été appelé)."

#: library/xml.etree.elementtree.rst:451
msgid "``[@attrib]``"
msgstr "``[@attrib]``"

#: library/xml.etree.elementtree.rst:451
msgid "Selects all elements that have the given attribute."
msgstr "Sélectionne tous les éléments qui ont l'attribut donné."

#: library/xml.etree.elementtree.rst:453
msgid "``[@attrib='value']``"
msgstr "``[@attrib='value']``"

#: library/xml.etree.elementtree.rst:453
msgid ""
"Selects all elements for which the given attribute has the given value.  The "
"value cannot contain quotes."
msgstr ""
"Sélectionne tous les éléments pour lesquels l'attribut donné a la valeur "
"donnée. La valeur ne peut pas contenir de guillemet simple (``'``)."

#: library/xml.etree.elementtree.rst:457
msgid "``[@attrib!='value']``"
msgstr "``[@attrib!='value']``"

#: library/xml.etree.elementtree.rst:457
msgid ""
"Selects all elements for which the given attribute does not have the given "
"value. The value cannot contain quotes."
msgstr ""
"Sélectionne tous les éléments pour lesquels l'attribut donné n'a pas la "
"valeur donnée. La valeur ne peut pas contenir de guillemet simple (``'``)."

#: library/xml.etree.elementtree.rst:463
msgid "``[tag]``"
msgstr "``[tag]``"

#: library/xml.etree.elementtree.rst:463
msgid ""
"Selects all elements that have a child named ``tag``.  Only immediate "
"children are supported."
msgstr ""
"Sélectionne tous les éléments qui ont un enfant nommé ``tag``. Seuls les "
"enfants immédiats sont pris en charge."

#: library/xml.etree.elementtree.rst:466
msgid "``[.='text']``"
msgstr "``[.='text']``"

#: library/xml.etree.elementtree.rst:466
msgid ""
"Selects all elements whose complete text content, including descendants, "
"equals the given ``text``."
msgstr ""
"Sélectionne tous les éléments dont le contenu textuel complet, y compris les "
"descendants, est égal au ``text`` donné."

#: library/xml.etree.elementtree.rst:471
msgid "``[.!='text']``"
msgstr "``[.!='text']``"

#: library/xml.etree.elementtree.rst:471
msgid ""
"Selects all elements whose complete text content, including descendants, "
"does not equal the given ``text``."
msgstr ""
"Sélectionne tous les éléments dont le contenu textuel complet, y compris les "
"descendants, n'est pas égal au ``text`` donné."

#: library/xml.etree.elementtree.rst:477
msgid "``[tag='text']``"
msgstr "``[tag='text']``"

#: library/xml.etree.elementtree.rst:477
msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, equals the given ``text``."
msgstr ""
"Sélectionne tous les éléments qui ont un enfant nommé ``tag`` dont le "
"contenu textuel complet, y compris les descendants, est égal au ``text`` "
"donné."

#: library/xml.etree.elementtree.rst:481
msgid "``[tag!='text']``"
msgstr "``[tag!='text']``"

#: library/xml.etree.elementtree.rst:481
msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, does not equal the given ``text``."
msgstr ""
"Sélectionne tous les éléments qui ont un enfant nommé ``tag`` dont le "
"contenu textuel complet, y compris les descendants, n'est pas égal au "
"``text`` donné."

#: library/xml.etree.elementtree.rst:487
msgid "``[position]``"
msgstr "``[position]``"

#: library/xml.etree.elementtree.rst:487
msgid ""
"Selects all elements that are located at the given position.  The position "
"can be either an integer (1 is the first position), the expression "
"``last()`` (for the last position), or a position relative to the last "
"position (e.g. ``last()-1``)."
msgstr ""
"Sélectionne tous les éléments situés à la position donnée. La position peut "
"être soit un entier (1 est la première position), l'expression ``last()`` "
"(pour la dernière position), ou une position relative à la dernière position "
"(par exemple ``last()-1``)."

#: library/xml.etree.elementtree.rst:494
msgid ""
"Predicates (expressions within square brackets) must be preceded by a tag "
"name, an asterisk, or another predicate.  ``position`` predicates must be "
"preceded by a tag name."
msgstr ""
"Les prédicats (expressions entre crochets) doivent être précédés d'un nom de "
"balise, d'un astérisque ou d'un autre prédicat. Les prédicats ``position`` "
"doivent être précédés d'un nom de balise."

#: library/xml.etree.elementtree.rst:499 library/xml.etree.elementtree.rst:834
msgid "Reference"
msgstr "Référence"

#: library/xml.etree.elementtree.rst:504 library/xml.etree.elementtree.rst:839
msgid "Functions"
msgstr "Fonctions"

#: library/xml.etree.elementtree.rst:508
msgid "`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ transformation function."
msgstr ""
"Fonction de transformation `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_."

#: library/xml.etree.elementtree.rst:510
#, fuzzy
msgid ""
"Canonicalization is a way to normalise XML output in a way that allows byte-"
"by-byte comparisons and digital signatures.  It reduces the freedom that XML "
"serializers have and instead generates a more constrained XML "
"representation.  The main restrictions regard the placement of namespace "
"declarations, the ordering of attributes, and ignorable whitespace."
msgstr ""
"La canonisation est un moyen de normaliser la sortie XML de manière à "
"permettre des comparaisons octet par octet et des signatures numériques. "
"Cela réduit la liberté dont disposent les outils de sérialisation XML et "
"génère à la place une représentation XML plus contrainte. Les principales "
"restrictions concernent le placement des déclarations d'espaces de noms, "
"l'ordre des attributs et les espaces à ignorer."

#: library/xml.etree.elementtree.rst:516
msgid ""
"This function takes an XML data string (*xml_data*) or a file path or file-"
"like object (*from_file*) as input, converts it to the canonical form, and "
"writes it out using the *out* file(-like) object, if provided, or returns it "
"as a text string if not.  The output file receives text, not bytes.  It "
"should therefore be opened in text mode with ``utf-8`` encoding."
msgstr ""
"Cette fonction prend une chaîne de données XML (*xml_data*) ou un chemin de "
"fichier ou un objet de type fichier (*from_file*) en entrée, la convertit "
"sous la forme canonique et l'écrit à l'aide de l'objet simili-fichier *out*, "
"s'il est fourni, ou le renvoie sous forme de chaîne de texte sinon. Le "
"fichier de sortie reçoit du texte, pas des octets. Il doit donc être ouvert "
"en mode texte avec l'encodage ``utf-8``."

#: library/xml.etree.elementtree.rst:523
msgid "Typical uses::"
msgstr "Utilisation typique ::"

#: library/xml.etree.elementtree.rst:525
msgid ""
"xml_data = \"<root>...</root>\"\n"
"print(canonicalize(xml_data))\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(xml_data, out=out_file)\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(from_file=\"inputfile.xml\", out=out_file)"
msgstr ""

#: library/xml.etree.elementtree.rst:534
msgid "The configuration *options* are as follows:"
msgstr "Les *options* de configuration sont les suivantes :"

#: library/xml.etree.elementtree.rst:536
msgid "*with_comments*: set to true to include comments (default: false)"
msgstr ""
"*with_comments* : définissez cet attribut à vrai pour inclure les "
"commentaires (par défaut : faux)"

#: library/xml.etree.elementtree.rst:537
msgid ""
"*strip_text*: set to true to strip whitespace before and after text content"
msgstr ""
"*strip_text* : définissez à vrai pour supprimer les espaces avant et après "
"le contenu du texte"

#: library/xml.etree.elementtree.rst:538 library/xml.etree.elementtree.rst:540
msgid "(default: false)"
msgstr "(par défaut : faux)"

#: library/xml.etree.elementtree.rst:539
msgid ""
"*rewrite_prefixes*: set to true to replace namespace prefixes by "
"\"n{number}\""
msgstr ""
"*rewrite_prefixes* : définissez à vrai pour remplacer les préfixes d'espace "
"de noms par « n{nombre} »"

#: library/xml.etree.elementtree.rst:541
msgid "*qname_aware_tags*: a set of qname aware tag names in which prefixes"
msgstr ""
"*qname_aware_tags* : ensemble de noms de balises prenant en charge les noms "
"qualifiés dans lesquels les préfixes"

#: library/xml.etree.elementtree.rst:542 library/xml.etree.elementtree.rst:544
msgid "should be replaced in text content (default: empty)"
msgstr "doivent être remplacés dans le contenu du texte (par défaut : vide)"

#: library/xml.etree.elementtree.rst:543
msgid ""
"*qname_aware_attrs*: a set of qname aware attribute names in which prefixes"
msgstr ""
"*qname_aware_attrs* : ensemble de noms d'attributs prenant en charge les "
"noms qualifiés dans lesquels les préfixes"

#: library/xml.etree.elementtree.rst:545
msgid "*exclude_attrs*: a set of attribute names that should not be serialised"
msgstr ""
"*exclude_attrs* : ensemble de noms d'attributs qui ne doivent pas être "
"sérialisés"

#: library/xml.etree.elementtree.rst:546
msgid "*exclude_tags*: a set of tag names that should not be serialised"
msgstr ""
"*exclude_tags* : ensemble de noms de balises qui ne doivent pas être "
"sérialisés"

#: library/xml.etree.elementtree.rst:548
msgid ""
"In the option list above, \"a set\" refers to any collection or iterable of "
"strings, no ordering is expected."
msgstr ""
"Dans la liste d'options ci-dessus, un « ensemble » fait référence à toute "
"collection ou itérable de chaînes, aucun ordre n'est attendu."

#: library/xml.etree.elementtree.rst:556
msgid ""
"Comment element factory.  This factory function creates a special element "
"that will be serialized as an XML comment by the standard serializer.  The "
"comment string can be either a bytestring or a Unicode string.  *text* is a "
"string containing the comment string.  Returns an element instance "
"representing a comment."
msgstr ""
"Fabrique d’éléments de commentaire. Cette fonction crée un élément spécial "
"qui sera sérialisé sous forme de commentaire XML par le sérialiseur "
"standard. La chaîne de commentaire peut être une chaîne d'octets ou une "
"chaîne Unicode. *text* est une chaîne contenant la chaîne de commentaire. "
"Renvoie une instance d'élément représentant un commentaire."

#: library/xml.etree.elementtree.rst:562
msgid ""
"Note that :class:`XMLParser` skips over comments in the input instead of "
"creating comment objects for them. An :class:`ElementTree` will only contain "
"comment nodes if they have been inserted into to the tree using one of the :"
"class:`Element` methods."
msgstr ""
"Notez que :class:`XMLParser` ignore les commentaires dans l'entrée au lieu "
"de créer des objets de commentaire pour eux. Un :class:`ElementTree` ne "
"contiendra que des nœuds de commentaires qui ont été insérés dans "
"l'arborescence à l'aide de l'une des méthodes d':class:`Element`."

#: library/xml.etree.elementtree.rst:569
msgid ""
"Writes an element tree or element structure to sys.stdout.  This function "
"should be used for debugging only."
msgstr ""
"Écrit une arborescence d'éléments ou une structure d'éléments dans *sys."
"stdout*. Cette fonction doit être utilisée uniquement pour le débogage."

#: library/xml.etree.elementtree.rst:572
msgid ""
"The exact output format is implementation dependent.  In this version, it's "
"written as an ordinary XML file."
msgstr ""
"Le format de sortie exact dépend de l’implémentation. Dans cette version, il "
"est écrit sous la forme d'un fichier XML ordinaire."

#: library/xml.etree.elementtree.rst:575
msgid "*elem* is an element tree or an individual element."
msgstr "*elem* est un élément de l'arborescence ou un élément individuel."

# suit un :
#: library/xml.etree.elementtree.rst:577
msgid ""
"The :func:`dump` function now preserves the attribute order specified by the "
"user."
msgstr ""
"la fonction :func:`dump` préserve désormais l'ordre des attributs spécifié "
"par l'utilisateur."

#: library/xml.etree.elementtree.rst:584
msgid ""
"Parses an XML section from a string constant.  Same as :func:`XML`.  *text* "
"is a string containing XML data.  *parser* is an optional parser instance. "
"If not given, the standard :class:`XMLParser` parser is used. Returns an :"
"class:`Element` instance."
msgstr ""
"Analyse une section XML à partir d'une constante de chaîne. Identique à :"
"func:`XML`. *text* est une chaîne contenant des données XML. *parser* est "
"une instance d'analyseur facultative. S'il n'est pas fourni, l'analyseur "
"standard :class:`XMLParser` est utilisé. Renvoie une instance d':class:"
"`Element`."

#: library/xml.etree.elementtree.rst:592
msgid ""
"Parses an XML document from a sequence of string fragments.  *sequence* is a "
"list or other sequence containing XML data fragments.  *parser* is an "
"optional parser instance.  If not given, the standard :class:`XMLParser` "
"parser is used.  Returns an :class:`Element` instance."
msgstr ""
"Analyse un document XML à partir d'une séquence de fragments de chaîne. "
"*séquence* est une liste ou une autre séquence contenant des fragments de "
"données XML. *parser* est une instance d'analyseur facultative. S'il n'est "
"pas fourni, l'analyseur standard :class:`XMLParser` est utilisé. Renvoie une "
"instance d':class:`Element`."

#: library/xml.etree.elementtree.rst:602
msgid ""
"Appends whitespace to the subtree to indent the tree visually. This can be "
"used to generate pretty-printed XML output. *tree* can be an Element or "
"ElementTree.  *space* is the whitespace string that will be inserted for "
"each indentation level, two space characters by default.  For indenting "
"partial subtrees inside of an already indented tree, pass the initial "
"indentation level as *level*."
msgstr ""
"Ajoute des espaces au sous-arbre pour indenter visuellement l'arborescence. "
"Cela peut être utilisé pour générer une sortie XML avec une mise en forme "
"agréable. *tree* peut être un élément ou un *ElementTree*. *espace* est la "
"chaîne d'espaces qui est insérée pour chaque niveau d'indentation, deux "
"caractères d'espace par défaut. Pour indenter des sous-arbres partiels à "
"l'intérieur d'un arbre déjà indenté, transmettez le niveau d'indentation "
"initial dans *level*."

#: library/xml.etree.elementtree.rst:614
msgid ""
"Check if an object appears to be a valid element object.  *element* is an "
"element instance.  Return ``True`` if this is an element object."
msgstr ""
"Vérifie si un objet semble être un objet élément valide. *element* est une "
"instance d'élément. Renvoie ``True`` s'il s'agit d'un objet élément."

#: library/xml.etree.elementtree.rst:620
#, fuzzy
msgid ""
"Parses an XML section into an element tree incrementally, and reports what's "
"going on to the user.  *source* is a filename or :term:`file object` "
"containing XML data.  *events* is a sequence of events to report back.  The "
"supported events are the strings ``\"start\"``, ``\"end\"``, "
"``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-ns\"`` (the \"ns\" "
"events are used to get detailed namespace information).  If *events* is "
"omitted, only ``\"end\"`` events are reported. *parser* is an optional "
"parser instance.  If not given, the standard :class:`XMLParser` parser is "
"used.  *parser* must be a subclass of :class:`XMLParser` and can only use "
"the default :class:`TreeBuilder` as a target. Returns an :term:`iterator` "
"providing ``(event, elem)`` pairs; it has a ``root`` attribute that "
"references the root element of the resulting XML tree once *source* is fully "
"read. The iterator has the :meth:`!close` method that closes the internal "
"file object if *source* is a filename."
msgstr ""
"Analyse progressivement une section XML pour produire une arborescence "
"d'éléments et rapporte ce qui se passe à l'utilisateur. *source* est un nom "
"de fichier ou un :term:`objet fichier <file object>` contenant des données "
"XML. *events* est une séquence d'événements à signaler. Les événements pris "
"en charge sont les chaînes ``\"start\"``, ``\"end\"``, ``\"comment\"``, "
"``\"pi\"``, ``\"start-ns\"`` et ``\"end-ns\"`` (les événements ``\"ns\"`` "
"sont utilisés pour obtenir des informations détaillées sur les espaces de "
"noms). Si *events* est omis, seuls les événements ``\"end\"`` sont "
"rapportés. *parser* (facultatif) est une instance d'analyseur. S'il n'est "
"pas fourni, l'analyseur standard :class:`XMLParser` est utilisé. *parser* "
"doit être une sous-classe de :class:`XMLParser` et ne peut utiliser que le :"
"class:`TreeBuilder` par défaut comme cible. Renvoie un :term:`itérateur "
"<iterator>` fournissant des paires ``(event, elem)``."

#: library/xml.etree.elementtree.rst:636
msgid ""
"Note that while :func:`iterparse` builds the tree incrementally, it issues "
"blocking reads on *source* (or the file it names).  As such, it's unsuitable "
"for applications where blocking reads can't be made.  For fully non-blocking "
"parsing, see :class:`XMLPullParser`."
msgstr ""
"Notez que même si :func:`iterparse` construit l'arborescence de manière "
"incrémentielle, il bloque pendant les lectures sur *source*. En tant que "
"tel, il ne convient pas aux applications dans lesquelles le blocage pendant "
"les lectures ne peut pas être effectué. Pour une analyse entièrement non "
"bloquante, voir :class:`XMLPullParser`."

#: library/xml.etree.elementtree.rst:643
msgid ""
":func:`iterparse` only guarantees that it has seen the \">\" character of a "
"starting tag when it emits a \"start\" event, so the attributes are defined, "
"but the contents of the text and tail attributes are undefined at that "
"point.  The same applies to the element children; they may or may not be "
"present."
msgstr ""
":func:`iterparse` garantit uniquement qu'il a vu le caractère ``\">\"`` "
"d'une balise de début lorsqu'il émet un événement ``\"start\"``, donc les "
"attributs sont définis mais le contenu des attributs *text* et *tail* n'est "
"pas défini à ce stade. La même chose s'applique aux nœuds enfants de "
"l'élément ; ils peuvent être présents ou non."

#: library/xml.etree.elementtree.rst:649 library/xml.etree.elementtree.rst:1522
msgid "If you need a fully populated element, look for \"end\" events instead."
msgstr ""
"Si vous avez besoin d'un élément entièrement rempli, recherchez plutôt les "
"événements ``\"end\"``."

# suit un :
#: library/xml.etree.elementtree.rst:651
msgid "The *parser* argument."
msgstr "l'argument *parser*."

# suit un :
#: library/xml.etree.elementtree.rst:654 library/xml.etree.elementtree.rst:1526
msgid "The ``comment`` and ``pi`` events were added."
msgstr "les évènements ``comment`` et ``pi`` ont été ajoutés."

#: library/xml.etree.elementtree.rst:657
msgid "Added the :meth:`!close` method."
msgstr ""

#: library/xml.etree.elementtree.rst:663
msgid ""
"Parses an XML section into an element tree.  *source* is a filename or file "
"object containing XML data.  *parser* is an optional parser instance.  If "
"not given, the standard :class:`XMLParser` parser is used.  Returns an :"
"class:`ElementTree` instance."
msgstr ""
"Analyse une section XML dans une arborescence d'éléments. *source* est un "
"nom de fichier ou un objet fichier contenant des données XML. *parser* "
"(facultatif) est une instance d'analyseur. S'il n'est pas fourni, "
"l'analyseur standard :class:`XMLParser` est utilisé. Renvoie une instance d':"
"class:`ElementTree`."

#: library/xml.etree.elementtree.rst:671
msgid ""
"PI element factory.  This factory function creates a special element that "
"will be serialized as an XML processing instruction.  *target* is a string "
"containing the PI target.  *text* is a string containing the PI contents, if "
"given.  Returns an element instance, representing a processing instruction."
msgstr ""
"Fabrique d’éléments *Processing Instruction* (PI). Cette fonction crée un "
"élément spécial qui sera sérialisé en tant qu'instruction de traitement XML. "
"*target* est une chaîne contenant la cible PI. *text* est une chaîne "
"contenant le contenu de l'instruction de traitement (ou PI), s'il est "
"fourni. Renvoie une instance d'élément, représentant l'instruction de "
"traitement."

#: library/xml.etree.elementtree.rst:676
#, fuzzy
msgid ""
"Note that :class:`XMLParser` skips over processing instructions in the input "
"instead of creating PI objects for them. An :class:`ElementTree` will only "
"contain processing instruction nodes if they have been inserted into to the "
"tree using one of the :class:`Element` methods."
msgstr ""
"Notez que :class:`XMLParser` ignore les instructions de traitement dans "
"l'entrée au lieu de créer des objets de commentaire pour elles. Un :class:"
"`ElementTree` ne contiendra que des nœuds d'instructions de traitement qui "
"ont été insérés dans l'arborescence à l'aide de l'une des méthodes d':class:"
"`Element`."

#: library/xml.etree.elementtree.rst:684
msgid ""
"Registers a namespace prefix.  The registry is global, and any existing "
"mapping for either the given prefix or the namespace URI will be removed. "
"*prefix* is a namespace prefix.  *uri* is a namespace uri.  Tags and "
"attributes in this namespace will be serialized with the given prefix, if at "
"all possible."
msgstr ""
"Enregistre un préfixe d'espace de noms. Le registre est global et toute "
"correspondance existante pour le préfixe donné ainsi que l'URI de l'espace "
"de noms sera supprimé. *prefix* est un préfixe d'espace de noms. *uri* est "
"un URI d'espace de noms. Les balises et les attributs de cet espace de noms "
"seront sérialisés avec le préfixe donné, si possible."

#: library/xml.etree.elementtree.rst:695
msgid ""
"Subelement factory.  This function creates an element instance, and appends "
"it to an existing element."
msgstr ""
"Fabrique de sous-élément. Cette fonction crée une instance d'élément et "
"l'ajoute à un élément existant."

#: library/xml.etree.elementtree.rst:698
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *parent* is the parent element.  *tag* is "
"the subelement name.  *attrib* is an optional dictionary, containing element "
"attributes.  *extra* contains additional attributes, given as keyword "
"arguments.  Returns an element instance."
msgstr ""
"Le nom de l'élément, les noms d'attributs et les valeurs d'attributs peuvent "
"être des chaînes d'octets ou des chaînes Unicode. *parent* est l'élément "
"parent. *tag* est le nom du sous-élément. *attrib* est un dictionnaire "
"facultatif contenant les attributs de l'élément. *extra* contient des "
"attributs supplémentaires, donnés sous forme d'arguments nommés. Renvoie une "
"instance d'élément."

#: library/xml.etree.elementtree.rst:709
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`. "
"Returns an (optionally) encoded string containing the XML data."
msgstr ""
"Génère une représentation sous forme de chaîne d'un élément XML, y compris "
"tous les sous-éléments. *element* est une instance de :class:`Element`. "
"*encoding* [1]_ est l'encodage de sortie (la valeur par défaut est US-"
"ASCII). Utilisez ``encoding=\"unicode\"`` pour générer une chaîne Unicode "
"(sinon, une chaîne d'octets est générée). *method* vaut ``\"xml\"``, "
"``\"html\"`` ou ``\"text\"`` (la valeur par défaut est ``\"xml\"``). "
"*xml_declaration*, *default_namespace* et *short_empty_elements* ont la même "
"signification que dans :meth:`ElementTree.write`. Renvoie une chaîne codée "
"(éventuellement) contenant les données XML."

# suit un :
#: library/xml.etree.elementtree.rst:718 library/xml.etree.elementtree.rst:745
#: library/xml.etree.elementtree.rst:1199
#, fuzzy
msgid "Added the *short_empty_elements* parameter."
msgstr "le paramètre *short_empty_elements*."

# suit un :
#: library/xml.etree.elementtree.rst:721 library/xml.etree.elementtree.rst:748
#, fuzzy
msgid "Added the *xml_declaration* and *default_namespace* parameters."
msgstr "les paramètres *xml_declaration* et *default_namespace*."

# suit un :
#: library/xml.etree.elementtree.rst:724
msgid ""
"The :func:`tostring` function now preserves the attribute order specified by "
"the user."
msgstr ""
"la fonction :func:`tostring` préserve désormais l'ordre des attributs "
"spécifié par l'utilisateur."

#: library/xml.etree.elementtree.rst:733
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`. "
"Returns a list of (optionally) encoded strings containing the XML data. It "
"does not guarantee any specific sequence, except that ``b\"\"."
"join(tostringlist(element)) == tostring(element)``."
msgstr ""
"Génère une représentation sous forme de chaîne d'un élément XML, y compris "
"tous les sous-éléments. *element* est une instance de :class:`Element`. "
"*encoding* [1]_ est l'encodage de sortie (la valeur par défaut est US-"
"ASCII). Utilisez ``encoding=\"unicode\"`` pour générer une chaîne Unicode "
"(sinon, une chaîne d'octets est générée). *method* vaut ``\"xml\"``, "
"``\"html\"`` ou ``\"text\"`` (la valeur par défaut est ``\"xml\"``). "
"*xml_declaration*, *default_namespace* et *short_empty_elements* ont la même "
"signification que dans :meth:`ElementTree.write`. Renvoie une liste de "
"chaînes codées (éventuellement) contenant les données XML. Elle ne garantit "
"aucune séquence spécifique, seulement ``b\"\".join(tostringlist(element)) == "
"tostring(element)``."

# suit un :
#: library/xml.etree.elementtree.rst:751
msgid ""
"The :func:`tostringlist` function now preserves the attribute order "
"specified by the user."
msgstr ""
"la fonction :func:`tostringlist` préserve désormais l'ordre des attributs "
"spécifié par l'utilisateur."

#: library/xml.etree.elementtree.rst:758
msgid ""
"Parses an XML section from a string constant.  This function can be used to "
"embed \"XML literals\" in Python code.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns an :class:`Element` instance."
msgstr ""
"Analyse une section XML à partir d'une constante de chaîne. Cette fonction "
"peut être utilisée pour intégrer des « littéraux XML » dans du code Python. "
"*text* est une chaîne contenant des données XML. *parser*, facultatif, est "
"une instance d'analyseur. S'il n'est pas fourni, l'analyseur standard :class:"
"`XMLParser` est utilisé. Renvoie une instance d':class:`Element`."

#: library/xml.etree.elementtree.rst:766
msgid ""
"Parses an XML section from a string constant, and also returns a dictionary "
"which maps from element id:s to elements.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns a tuple containing an :class:"
"`Element` instance and a dictionary."
msgstr ""
"Analyse une section XML à partir d'une constante de chaîne et renvoie "
"également un dictionnaire qui fait correspondre les identifiants d'éléments "
"aux éléments. *text* est une chaîne contenant des données XML. *parser*, "
"facultatif, est une instance d'analyseur. S'il n'est pas fourni, l'analyseur "
"standard :class:`XMLParser` est utilisé. Renvoie un *n*-uplet contenant une "
"instance d':class:`Element` et un dictionnaire."

#: library/xml.etree.elementtree.rst:776
msgid "XInclude support"
msgstr "Prise en charge de *XInclude*"

#: library/xml.etree.elementtree.rst:778
msgid ""
"This module provides limited support for `XInclude directives <https://www."
"w3.org/TR/xinclude/>`_, via the :mod:`xml.etree.ElementInclude` helper "
"module.  This module can be used to insert subtrees and text strings into "
"element trees, based on information in the tree."
msgstr ""
"Ce module fournit une prise en charge limitée des `directives XInclude "
"<https://www.w3.org/TR/xinclude/>`_, via le module d'assistance :mod:`xml."
"etree.ElementInclude`. Ce module peut être utilisé pour insérer des sous-"
"arbres et des chaînes de texte dans des arborescences d'éléments, en "
"fonction des informations contenues dans l'arborescence."

#: library/xml.etree.elementtree.rst:784
msgid ""
"Here's an example that demonstrates use of the XInclude module. To include "
"an XML document in the current document, use the ``{http://www.w3.org/2001/"
"XInclude}include`` element and set the **parse** attribute to ``\"xml\"``, "
"and use the **href** attribute to specify the document to include."
msgstr ""
"Voici un exemple qui montre l'utilisation du module *XInclude*. Pour inclure "
"un document XML dans le document actuel, utilisez l'élément ``{http://www.w3."
"org/2001/XInclude}include``, définissez l'attribut **parse** sur "
"``\"xml\"``  et utilisez l'attribut **href** pour spécifier le document à "
"inclure."

#: library/xml.etree.elementtree.rst:786
msgid ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <xi:include href=\"source.xml\" parse=\"xml\" />\n"
"</document>"
msgstr ""

#: library/xml.etree.elementtree.rst:793
msgid ""
"By default, the **href** attribute is treated as a file name. You can use "
"custom loaders to override this behaviour. Also note that the standard "
"helper does not support XPointer syntax."
msgstr ""
"Par défaut, l'attribut **href** est traité comme un nom de fichier. Vous "
"pouvez utiliser des chargeurs personnalisés pour remplacer ce comportement. "
"Notez également que l'assistant standard ne prend pas en charge la syntaxe "
"*XPointer*."

#: library/xml.etree.elementtree.rst:795
msgid ""
"To process this file, load it as usual, and pass the root element to the :"
"mod:`xml.etree.ElementTree` module:"
msgstr ""
"Pour traiter ce fichier, chargez-le comme d'habitude et passez l'élément "
"racine au module :mod:`xml.etree.ElementTree` :"

#: library/xml.etree.elementtree.rst:797
msgid ""
"from xml.etree import ElementTree, ElementInclude\n"
"\n"
"tree = ElementTree.parse(\"document.xml\")\n"
"root = tree.getroot()\n"
"\n"
"ElementInclude.include(root)"
msgstr ""

#: library/xml.etree.elementtree.rst:806
msgid ""
"The ElementInclude module replaces the ``{http://www.w3.org/2001/XInclude}"
"include`` element with the root element from the **source.xml** document. "
"The result might look something like this:"
msgstr ""
"Le module *ElementInclude* remplace l'élément ``{http://www.w3.org/2001/"
"XInclude}include`` par l'élément racine du document **source.xml**. Le "
"résultat pourrait ressembler à ceci :"

#: library/xml.etree.elementtree.rst:808
msgid ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <para>This is a paragraph.</para>\n"
"</document>"
msgstr ""

#: library/xml.etree.elementtree.rst:814
msgid ""
"If the **parse** attribute is omitted, it defaults to \"xml\". The href "
"attribute is required."
msgstr ""
"Si l'attribut **parse** est omis, sa valeur par défaut est ``\"xml\"``. "
"L'attribut *href* est obligatoire."

#: library/xml.etree.elementtree.rst:816
msgid ""
"To include a text document, use the ``{http://www.w3.org/2001/XInclude}"
"include`` element, and set the **parse** attribute to \"text\":"
msgstr ""
"Pour inclure un document texte, utilisez l'élément ``{http://www.w3.org/2001/"
"XInclude}include`` et définissez l'attribut **parse** sur ``\"text\"`` :"

#: library/xml.etree.elementtree.rst:818
msgid ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) <xi:include href=\"year.txt\" parse=\"text\" />.\n"
"</document>"
msgstr ""

#: library/xml.etree.elementtree.rst:825
msgid "The result might look something like:"
msgstr "Le résultat pourrait ressembler à ceci :"

#: library/xml.etree.elementtree.rst:827
msgid ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) 2003.\n"
"</document>"
msgstr ""

#: library/xml.etree.elementtree.rst:845
#, fuzzy
msgid ""
"Default loader. This default loader reads an included resource from disk. "
"*href* is a URL.  *parse* is for parse mode either \"xml\" or \"text\". "
"*encoding* is an optional text encoding.  If not given, encoding is "
"``utf-8``. Returns the expanded resource. If the parse mode is ``\"xml\"``, "
"this is an :class:`~xml.etree.ElementTree.Element` instance. If the parse "
"mode is ``\"text\"``, this is a string. If the loader fails, it can return "
"``None`` or raise an exception."
msgstr ""
"Chargeur par défaut. Ce chargeur par défaut lit une ressource incluse à "
"partir du disque. *href* est une URL. *parse* (le mode d'analyse) vaut soit "
"``\"xml\"``, soit ``\"text\"``. *encoding* est un encodage de texte "
"facultatif. S'il n'est pas indiqué, l'encodage est ``utf-8``. Renvoie la "
"ressource développée. Si le mode d'analyse est ``\"xml\"``, il s'agit d'une "
"instance d'``ElementTree``. Si le mode d'analyse est ``\"text\"``, il s'agit "
"d'une chaîne Unicode. Si le chargeur échoue, il peut renvoyer ``None`` ou "
"lever une exception."

#: library/xml.etree.elementtree.rst:856
#, fuzzy
msgid ""
"This function expands XInclude directives in-place in tree pointed by "
"*elem*. *elem* is either the root :class:`~xml.etree.ElementTree.Element` or "
"an :class:`~xml.etree.ElementTree.ElementTree` instance to find such "
"element. *loader* is an optional resource loader.  If omitted, it defaults "
"to :func:`default_loader`. If given, it should be a callable that implements "
"the same interface as :func:`default_loader`.  *base_url* is base URL of the "
"original file, to resolve relative include file references.  *max_depth* is "
"the maximum number of recursive inclusions.  Limited to reduce the risk of "
"malicious content explosion. Pass ``None`` to disable the limitation."
msgstr ""
"Cette fonction étend les directives *XInclude*. *elem* est l'élément racine. "
"*loader* est un chargeur de ressources facultatif. S'il est omis, la valeur "
"par défaut est :func:`default_loader`. S'il est donné, il doit s'agir d'un "
"appelable qui implémente la même interface que :func:`default_loader`. "
"*base_url* est l'URL de base du fichier d'origine, pour résoudre les "
"références relatives au fichier à inclure. *max_degree* est le nombre "
"maximum d'inclusions récursives. La limite existe pour réduire le risque "
"d’explosion de contenu malveillant. Passez une valeur négative pour "
"désactiver la limite."

# suit un :
#: library/xml.etree.elementtree.rst:866
#, fuzzy
msgid "Added the *base_url* and *max_depth* parameters."
msgstr "les paramètres *base_url* et *max_depth*."

#: library/xml.etree.elementtree.rst:873
msgid "Element Objects"
msgstr "Objets *Element*"

#: library/xml.etree.elementtree.rst:881
msgid ""
"Element class.  This class defines the Element interface, and provides a "
"reference implementation of this interface."
msgstr ""
"Classe Element.  Cette classe définit l'interface Element et fournit une "
"implémentation de référence de cette interface."

#: library/xml.etree.elementtree.rst:884
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *tag* is the element name.  *attrib* is an "
"optional dictionary, containing element attributes.  *extra* contains "
"additional attributes, given as keyword arguments."
msgstr ""
"Le nom de l'élément, les noms d'attributs et les valeurs d'attributs peuvent "
"être des chaînes d'octets ou des chaînes Unicode. *tag* est le nom de "
"l'élément. *attrib* est un dictionnaire facultatif contenant les attributs "
"des éléments. *extra* contient des attributs supplémentaires, donnés sous "
"forme d'arguments nommés."

#: library/xml.etree.elementtree.rst:892
msgid ""
"A string identifying what kind of data this element represents (the element "
"type, in other words)."
msgstr ""
"Chaîne identifiant le type de données que cet élément représente (en "
"d'autres termes, le type d'élément)."

#: library/xml.etree.elementtree.rst:899
msgid ""
"These attributes can be used to hold additional data associated with the "
"element.  Their values are usually strings but may be any application-"
"specific object.  If the element is created from an XML file, the *text* "
"attribute holds either the text between the element's start tag and its "
"first child or end tag, or ``None``, and the *tail* attribute holds either "
"the text between the element's end tag and the next tag, or ``None``.  For "
"the XML data"
msgstr ""
"Ces attributs peuvent être utilisés pour contenir des données "
"supplémentaires associées à l'élément. Leurs valeurs sont généralement des "
"chaînes mais peuvent être n'importe quel objet spécifique à une application. "
"Si l'élément est créé à partir d'un fichier XML, l'attribut *text* contient "
"soit le texte entre la balise de début de l'élément et sa première balise "
"enfant ou de fin, soit ``None`` ; l'attribut *tail* contient soit le texte "
"entre la balise de fin de l'élément et la balise suivante, soit ``None``. "
"Pour les données XML"

#: library/xml.etree.elementtree.rst:907
msgid "<a><b>1<c>2<d/>3</c></b>4</a>"
msgstr ""

#: library/xml.etree.elementtree.rst:911
msgid ""
"the *a* element has ``None`` for both *text* and *tail* attributes, the *b* "
"element has *text* ``\"1\"`` and *tail* ``\"4\"``, the *c* element has "
"*text* ``\"2\"`` and *tail* ``None``, and the *d* element has *text* "
"``None`` and *tail* ``\"3\"``."
msgstr ""
"les attributs *text* et *tail* de l'élément *a* valent ``None``, l'attribut "
"*text* de l'élément *b* vaut ``\"1\"`` et *tail* vaut ``\"4\"``, l'attribut "
"*text* de l'élément *c* vaut ``\"2\"`` et *tail* vaut ``None``, et "
"l'attribut *text* de l'élément *d* vaut ``None`` et *tail* vaut ``\"3\"``."

#: library/xml.etree.elementtree.rst:916
msgid ""
"To collect the inner text of an element, see :meth:`itertext`, for example "
"``\"\".join(element.itertext())``."
msgstr ""
"Pour récupérer le texte interne d'un élément, voir :meth:`itertext`, par "
"exemple ``\"\".join(element.itertext())``."

#: library/xml.etree.elementtree.rst:919
msgid "Applications may store arbitrary objects in these attributes."
msgstr ""
"Les applications peuvent stocker des objets arbitraires dans ces attributs."

#: library/xml.etree.elementtree.rst:924
msgid ""
"A dictionary containing the element's attributes.  Note that while the "
"*attrib* value is always a real mutable Python dictionary, an ElementTree "
"implementation may choose to use another internal representation, and create "
"the dictionary only if someone asks for it.  To take advantage of such "
"implementations, use the dictionary methods below whenever possible."
msgstr ""
"Dictionnaire contenant les attributs de l'élément. Notez que même si la "
"valeur *attrib* est toujours un véritable dictionnaire Python mutable, une "
"implémentation d'*ElementTree* peut choisir d'utiliser une autre "
"représentation interne et de créer le dictionnaire uniquement si quelqu'un "
"le demande. Pour profiter de telles implémentations, utilisez les méthodes "
"de dictionnaire ci-dessous autant que possible."

#: library/xml.etree.elementtree.rst:930
msgid "The following dictionary-like methods work on the element attributes."
msgstr ""
"Les méthodes dictionnaire-compatibles suivantes traitent les attributs de "
"l'élément."

#: library/xml.etree.elementtree.rst:935
msgid ""
"Resets an element.  This function removes all subelements, clears all "
"attributes, and sets the text and tail attributes to ``None``."
msgstr ""
"Réinitialise un élément. Cette fonction supprime tous les sous-éléments, "
"efface tous les attributs et définit les attributs *text* et *tail* sur "
"``None``."

#: library/xml.etree.elementtree.rst:941
msgid "Gets the element attribute named *key*."
msgstr "Accède à l'attribut de l'élément nommé *key*."

#: library/xml.etree.elementtree.rst:943
msgid ""
"Returns the attribute value, or *default* if the attribute was not found."
msgstr ""
"Renvoie la valeur de l'attribut ou *default* si l'attribut n'a pas été "
"trouvé."

#: library/xml.etree.elementtree.rst:948
msgid ""
"Returns the element attributes as a sequence of (name, value) pairs.  The "
"attributes are returned in an arbitrary order."
msgstr ""
"Renvoie les attributs de l'élément comme une séquence de paire (nom, "
"valeur). Les attributs sont renvoyés dans un ordre arbitraire."

#: library/xml.etree.elementtree.rst:954
msgid ""
"Returns the elements attribute names as a list.  The names are returned in "
"an arbitrary order."
msgstr ""
"Renvoie les noms d'attributs des éléments sous forme de liste. Les noms sont "
"renvoyés dans un ordre arbitraire."

#: library/xml.etree.elementtree.rst:960
msgid "Set the attribute *key* on the element to *value*."
msgstr "Change l'attribut *key* à l'élément *value*."

#: library/xml.etree.elementtree.rst:962
msgid "The following methods work on the element's children (subelements)."
msgstr "Les méthodes suivantes traitent les éléments enfants (sous-éléments)."

#: library/xml.etree.elementtree.rst:967
msgid ""
"Adds the element *subelement* to the end of this element's internal list of "
"subelements.  Raises :exc:`TypeError` if *subelement* is not an :class:"
"`Element`."
msgstr ""
"Ajoute l'élément *subelement* à la fin de la liste interne des sous-éléments "
"de cet élément. Lève une :exc:`TypeError` si *subelement* n'est pas un :"
"class:`Element`."

#: library/xml.etree.elementtree.rst:974
#, fuzzy
msgid ""
"Appends *subelements* from an iterable of elements. Raises :exc:`TypeError` "
"if a subelement is not an :class:`Element`."
msgstr ""
"Ajoute *subelements* à partir d'un objet séquence avec zéro ou plusieurs "
"éléments. Lève une :exc:`TypeError` si un sous-élément n'est pas un :class:"
"`Element`."

#: library/xml.etree.elementtree.rst:982
msgid ""
"Finds the first subelement matching *match*.  *match* may be a tag name or "
"a :ref:`path <elementtree-xpath>`.  Returns an element instance or "
"``None``.  *namespaces* is an optional mapping from namespace prefix to full "
"name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"Recherche le premier sous-élément correspondant à *match*. *match* peut être "
"un nom de balise ou un :ref:`path <elementtree-xpath>`. Renvoie une instance "
"d'élément ou ``None``. *namespaces* est un tableau de correspondances "
"facultatif de préfixes d'espaces de noms vers des noms complets. Passez "
"``''`` comme préfixe pour déplacer tous les noms de balises sans préfixe "
"dans l'expression dans l'espace de noms donné."

#: library/xml.etree.elementtree.rst:991
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns a list containing all matching elements in document "
"order.  *namespaces* is an optional mapping from namespace prefix to full "
"name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"Recherche tous les sous-éléments correspondants, par nom de balise ou :ref:"
"`path <elementtree-xpath>`. Renvoie une liste contenant tous les éléments "
"correspondants dans l'ordre du document. *namespaces* est un tableau de "
"correspondances facultatif de préfixes d'espaces de noms vers des noms "
"complets. Passez ``''`` comme préfixe pour déplacer tous les noms de balises "
"sans préfixe dans l'expression dans l'espace de noms donné."

#: library/xml.etree.elementtree.rst:1000
msgid ""
"Finds text for the first subelement matching *match*.  *match* may be a tag "
"name or a :ref:`path <elementtree-xpath>`.  Returns the text content of the "
"first matching element, or *default* if no element was found. Note that if "
"the matching element has no text content an empty string is returned. "
"*namespaces* is an optional mapping from namespace prefix to full name.  "
"Pass ``''`` as prefix to move all unprefixed tag names in the expression "
"into the given namespace."
msgstr ""
"Recherche le texte du premier sous-élément correspondant à *match*. *match* "
"peut être un nom de balise ou un :ref:`path <elementtree-xpath>`. Renvoie le "
"contenu textuel du premier élément correspondant, ou *default* si aucun "
"élément n'a été trouvé. Notez que si l'élément correspondant n'a pas de "
"contenu textuel, une chaîne vide est renvoyée. *namespaces* est un tableau "
"de correspondances facultatif de préfixes d'espaces de noms vers des noms "
"complets. Passez ``''`` comme préfixe pour déplacer tous les noms de balises "
"sans préfixe dans l'expression dans l'espace de noms donné."

#: library/xml.etree.elementtree.rst:1011
msgid ""
"Inserts *subelement* at the given position in this element.  Raises :exc:"
"`TypeError` if *subelement* is not an :class:`Element`."
msgstr ""
"Insère le *subelement* à la position donnée dans cet élément. Lève une :exc:"
"`TypeError` si *subelement* n'est pas un :class:`Element`."

#: library/xml.etree.elementtree.rst:1017
msgid ""
"Creates a tree :term:`iterator` with the current element as the root. The "
"iterator iterates over this element and all elements below it, in document "
"(depth first) order.  If *tag* is not ``None`` or ``'*'``, only elements "
"whose tag equals *tag* are returned from the iterator.  If the tree "
"structure is modified during iteration, the result is undefined."
msgstr ""
"Crée un :term:`itérateur <iterator>` sur l'arbre  avec l'élément actuel "
"comme racine. L'itérateur parcourt cet élément et tous les éléments situés "
"en dessous, dans l'ordre du document (profondeur en premier). Si *tag* n'est "
"pas ``None`` ou ``'*'``, seuls les éléments dont la balise est égale à *tag* "
"sont renvoyés par l'itérateur. Si l'arborescence est modifiée au cours de "
"l'itération, le résultat est indéfini."

#: library/xml.etree.elementtree.rst:1028
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns an iterable yielding all matching elements in document "
"order. *namespaces* is an optional mapping from namespace prefix to full "
"name."
msgstr ""
"Recherche tous les sous-éléments correspondants, par nom de balise ou :ref:"
"`path <elementtree-xpath>`. Renvoie un itérable donnant tous les éléments "
"correspondants dans l'ordre du document. *namespaces* est un tableau de "
"correspondances facultatif de préfixes d'espaces de noms vers des noms "
"complets."

#: library/xml.etree.elementtree.rst:1039
msgid ""
"Creates a text iterator.  The iterator loops over this element and all "
"subelements, in document order, and returns all inner text."
msgstr ""
"Crée un itérateur de texte. L'itérateur parcourt cet élément et tous les "
"sous-éléments, dans l'ordre du document, et renvoie tout le texte interne."

#: library/xml.etree.elementtree.rst:1047
msgid ""
"Creates a new element object of the same type as this element.  Do not call "
"this method, use the :func:`SubElement` factory function instead."
msgstr ""
"Crée un nouvel objet élément du même type que cet élément. N'appelez pas "
"cette méthode, utilisez plutôt la fonction de fabrique :func:`SubElement`."

#: library/xml.etree.elementtree.rst:1053
msgid ""
"Removes *subelement* from the element.  Unlike the find\\* methods this "
"method compares elements based on the instance identity, not on tag value or "
"contents."
msgstr ""
"Supprime le *subelement* de l'élément. Contrairement aux méthodes *find\\**, "
"cette méthode compare les éléments en fonction de l'identité de l'instance, "
"et non de la valeur ou du contenu de la balise."

#: library/xml.etree.elementtree.rst:1057
msgid ""
":class:`Element` objects also support the following sequence type methods "
"for working with subelements: :meth:`~object.__delitem__`, :meth:`~object."
"__getitem__`, :meth:`~object.__setitem__`, :meth:`~object.__len__`."
msgstr ""
"Les objets :class:`Element` prennent également en charge les méthodes de "
"type séquence suivantes pour travailler avec des sous éléments : :meth:"
"`~object.__delitem__`, :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__len__`."

#: library/xml.etree.elementtree.rst:1062
#, fuzzy
msgid ""
"Caution: Elements with no subelements will test as ``False``.  In a future "
"release of Python, all elements will test as ``True`` regardless of whether "
"subelements exist.  Instead, prefer explicit ``len(elem)`` or ``elem is not "
"None`` tests.::"
msgstr ""
"Attention : les éléments sans sous-élément sont évalués comme ``False``. Ce "
"comportement changera dans les versions futures. Utilisez plutôt un test "
"spécifique ``len(elem)`` ou ``elem is None``. ::"

#: library/xml.etree.elementtree.rst:1067
msgid ""
"element = root.find('foo')\n"
"\n"
"if not element:  # careful!\n"
"    print(\"element not found, or element has no subelements\")\n"
"\n"
"if element is None:\n"
"    print(\"element not found\")"
msgstr ""

#: library/xml.etree.elementtree.rst:1075
msgid "Testing the truth value of an Element emits :exc:`DeprecationWarning`."
msgstr ""

#: library/xml.etree.elementtree.rst:1078
msgid ""
"Prior to Python 3.8, the serialisation order of the XML attributes of "
"elements was artificially made predictable by sorting the attributes by "
"their name. Based on the now guaranteed ordering of dicts, this arbitrary "
"reordering was removed in Python 3.8 to preserve the order in which "
"attributes were originally parsed or created by user code."
msgstr ""
"Avant Python 3.8, l'ordre de sérialisation des attributs XML des éléments "
"était artificiellement rendu prévisible en classant les attributs par leur "
"nom. Sur la base de l'ordre désormais garanti des dictionnaires, cette "
"réorganisation arbitraire a été supprimée dans Python 3.8 pour préserver "
"l'ordre dans lequel les attributs ont été initialement analysés ou créés par "
"le code utilisateur."

#: library/xml.etree.elementtree.rst:1084
msgid ""
"In general, user code should try not to depend on a specific ordering of "
"attributes, given that the `XML Information Set <https://www.w3.org/TR/xml-"
"infoset/>`_ explicitly excludes the attribute order from conveying "
"information. Code should be prepared to deal with any ordering on input. In "
"cases where deterministic XML output is required, e.g. for cryptographic "
"signing or test data sets, canonical serialisation is available with the :"
"func:`canonicalize` function."
msgstr ""
"En général, le code utilisateur doit essayer de ne pas dépendre d'un ordre "
"spécifique des attributs, étant donné que la `documentation de référence XML "
"<https://www.w3.org/TR/xml-infoset/>`_ exclut explicitement que l'ordre des "
"attributs soit porteur d'information. Le code doit être prêt à gérer tout "
"ordre en entrée. Dans les cas où une sortie XML déterministe est requise, "
"par exemple pour la signature cryptographique ou les ensembles de données de "
"test, la sérialisation canonique est disponible avec la fonction :func:"
"`canonicalize`."

#: library/xml.etree.elementtree.rst:1092
msgid ""
"In cases where canonical output is not applicable but a specific attribute "
"order is still desirable on output, code should aim for creating the "
"attributes directly in the desired order, to avoid perceptual mismatches for "
"readers of the code. In cases where this is difficult to achieve, a recipe "
"like the following can be applied prior to serialisation to enforce an order "
"independently from the Element creation::"
msgstr ""
"Dans les cas où la sortie canonique n'est pas applicable mais où un ordre "
"d'attributs spécifique est quand même souhaitable en sortie, le code doit "
"viser à créer les attributs directement dans l'ordre souhaité, afin d'éviter "
"des inadéquations de perception pour les lecteurs du code. Dans les cas où "
"cela est difficile à réaliser, une recette comme ci-dessous peut être "
"appliquée avant la sérialisation pour appliquer un ordre indépendant de la "
"création de l'élément ::"

#: library/xml.etree.elementtree.rst:1099
msgid ""
"def reorder_attributes(root):\n"
"    for el in root.iter():\n"
"        attrib = el.attrib\n"
"        if len(attrib) > 1:\n"
"            # adjust attribute order, e.g. by sorting\n"
"            attribs = sorted(attrib.items())\n"
"            attrib.clear()\n"
"            attrib.update(attribs)"
msgstr ""

#: library/xml.etree.elementtree.rst:1112
msgid "ElementTree Objects"
msgstr "Objets *ElementTree*"

#: library/xml.etree.elementtree.rst:1117
msgid ""
"ElementTree wrapper class.  This class represents an entire element "
"hierarchy, and adds some extra support for serialization to and from "
"standard XML."
msgstr ""
"Classe enveloppant *ElementTree*. Cette classe représente une hiérarchie "
"d'éléments entière et ajoute une prise en charge supplémentaire pour la "
"sérialisation vers et depuis le XML standard."

#: library/xml.etree.elementtree.rst:1121
msgid ""
"*element* is the root element.  The tree is initialized with the contents of "
"the XML *file* if given."
msgstr ""
"*element* est l'élément racine. L'arborescence est initialisée avec le "
"contenu du fichier XML *file* s'il est fourni."

#: library/xml.etree.elementtree.rst:1127
msgid ""
"Replaces the root element for this tree.  This discards the current contents "
"of the tree, and replaces it with the given element.  Use with care.  "
"*element* is an element instance."
msgstr ""
"Remplace l'élément racine de cette arborescence. Cela supprime le contenu "
"actuel de l'arborescence et le remplace par l'élément donné. À utiliser avec "
"précaution. *element* est une instance d'élément."

#: library/xml.etree.elementtree.rst:1134
msgid "Same as :meth:`Element.find`, starting at the root of the tree."
msgstr "Comme :meth:`Element.find`, commence à la racine de l'arbre."

#: library/xml.etree.elementtree.rst:1139
msgid "Same as :meth:`Element.findall`, starting at the root of the tree."
msgstr ""
"Identique à :meth:`Element.findall`, en commençant à la racine de "
"l'arborescence."

#: library/xml.etree.elementtree.rst:1144
msgid "Same as :meth:`Element.findtext`, starting at the root of the tree."
msgstr ""
"Identique à :meth:`Element.findtext`, en commençant à la racine de "
"l'arborescence."

#: library/xml.etree.elementtree.rst:1149
msgid "Returns the root element for this tree."
msgstr "Renvoie l'élément racine de l'arbre."

#: library/xml.etree.elementtree.rst:1154
msgid ""
"Creates and returns a tree iterator for the root element.  The iterator "
"loops over all elements in this tree, in section order.  *tag* is the tag to "
"look for (default is to return all elements)."
msgstr ""
"Crée et renvoie un itérateur d'arborescence pour l'élément racine. "
"L'itérateur parcourt tous les éléments de cette arborescence, dans l'ordre "
"des sections. *tag* est la balise à rechercher (la valeur par défaut est de "
"renvoyer tous les éléments)."

#: library/xml.etree.elementtree.rst:1161
msgid "Same as :meth:`Element.iterfind`, starting at the root of the tree."
msgstr ""
"Identique à :meth:`Element.iterfind`, en commençant à la racine de "
"l'arborescence."

#: library/xml.etree.elementtree.rst:1168
msgid ""
"Loads an external XML section into this element tree.  *source* is a file "
"name or :term:`file object`.  *parser* is an optional parser instance. If "
"not given, the standard :class:`XMLParser` parser is used.  Returns the "
"section root element."
msgstr ""
"Charge une section XML externe dans cette arborescence d'éléments. *source* "
"est un nom de fichier ou un :term:`objet fichier <file object>`. *parser*, "
"facultatif, est une instance d'analyseur. S'il n'est pas fourni, l'analyseur "
"standard :class:`XMLParser` est utilisé. Renvoie l'élément racine de la "
"section."

#: library/xml.etree.elementtree.rst:1178
msgid ""
"Writes the element tree to a file, as XML.  *file* is a file name, or a :"
"term:`file object` opened for writing.  *encoding* [1]_ is the output "
"encoding (default is US-ASCII). *xml_declaration* controls if an XML "
"declaration should be added to the file.  Use ``False`` for never, ``True`` "
"for always, ``None`` for only if not US-ASCII or UTF-8 or Unicode (default "
"is ``None``). *default_namespace* sets the default XML namespace (for "
"\"xmlns\"). *method* is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` "
"(default is ``\"xml\"``). The keyword-only *short_empty_elements* parameter "
"controls the formatting of elements that contain no content.  If ``True`` "
"(the default), they are emitted as a single self-closed tag, otherwise they "
"are emitted as a pair of start/end tags."
msgstr ""
"Écrit l'arborescence des éléments dans un fichier, au format XML. *file* est "
"un nom de fichier ou un :term:`objet fichier <file object>` ouvert en "
"écriture. *encoding* [1]_ est l'encodage de sortie (la valeur par défaut est "
"US-ASCII). *xml_declaration* contrôle si une déclaration XML doit être "
"ajoutée au fichier. Utilisez ``False`` pour jamais, ``True`` pour toujours, "
"``None`` pour seulement si ce n'est pas de l'US-ASCII ou de l'UTF-8 ou de "
"l'Unicode (la valeur par défaut est ``None``). *default_namespace* définit "
"l'espace de noms XML par défaut (pour ``\"xmlns\"``). *method* vaut "
"``\"xml\"``, ``\"html\"`` ou ``\"text\"`` (la valeur par défaut est "
"``\"xml\"``). Le paramètre nommé (uniquement) *short_empty_elements* "
"contrôle le formatage des éléments qui ne contiennent aucun contenu. Si "
"c'est ``True`` (valeur par défaut), ils sont écrits sous la forme d'une "
"seule balise auto-fermée, sinon ils sont écrits sous la forme d'une paire de "
"balises de début-fin."

#: library/xml.etree.elementtree.rst:1192
msgid ""
"The output is either a string (:class:`str`) or binary (:class:`bytes`). "
"This is controlled by the *encoding* argument.  If *encoding* is "
"``\"unicode\"``, the output is a string; otherwise, it's binary.  Note that "
"this may conflict with the type of *file* if it's an open :term:`file "
"object`; make sure you do not try to write a string to a binary stream and "
"vice versa."
msgstr ""
"La sortie est une chaîne (:class:`str`) ou du binaire (:class:`bytes`). "
"C'est contrôlé par l'argument *encoding*. Si *encoding* est ``\"unicode\"``, "
"la sortie est une chaîne ; sinon, c'est binaire. Notez que cela peut entrer "
"en conflit avec le type de *fichier* s'il s'agit d'un :term:`objet fichier "
"<file object>` déjà ouvert ; assurez-vous de ne pas essayer d'écrire une "
"chaîne dans un flux binaire et vice versa."

# suit un :
#: library/xml.etree.elementtree.rst:1202
msgid ""
"The :meth:`write` method now preserves the attribute order specified by the "
"user."
msgstr ""
"la méthode :meth:`write` préserve désormais l'ordre des attributs spécifié "
"par l'utilisateur."

#: library/xml.etree.elementtree.rst:1207
msgid "This is the XML file that is going to be manipulated::"
msgstr "Voici le fichier XML à manipuler ::"

#: library/xml.etree.elementtree.rst:1209
msgid ""
"<html>\n"
"    <head>\n"
"        <title>Example page</title>\n"
"    </head>\n"
"    <body>\n"
"        <p>Moved to <a href=\"http://example.org/\">example.org</a>\n"
"        or <a href=\"http://example.com/\">example.com</a>.</p>\n"
"    </body>\n"
"</html>"
msgstr ""

#: library/xml.etree.elementtree.rst:1219
msgid ""
"Example of changing the attribute \"target\" of every link in first "
"paragraph::"
msgstr ""
"Exemple de modification de l'attribut *target* de chaque lien dans le "
"premier paragraphe ::"

#: library/xml.etree.elementtree.rst:1221
msgid ""
">>> from xml.etree.ElementTree import ElementTree\n"
">>> tree = ElementTree()\n"
">>> tree.parse(\"index.xhtml\")\n"
"<Element 'html' at 0xb77e6fac>\n"
">>> p = tree.find(\"body/p\")     # Finds first occurrence of tag p in body\n"
">>> p\n"
"<Element 'p' at 0xb77ec26c>\n"
">>> links = list(p.iter(\"a\"))   # Returns list of all links\n"
">>> links\n"
"[<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]\n"
">>> for i in links:             # Iterates through all found links\n"
"...     i.attrib[\"target\"] = \"blank\"\n"
"...\n"
">>> tree.write(\"output.xhtml\")"
msgstr ""

#: library/xml.etree.elementtree.rst:1239
msgid "QName Objects"
msgstr "Objets *QName*"

#: library/xml.etree.elementtree.rst:1244
msgid ""
"QName wrapper.  This can be used to wrap a QName attribute value, in order "
"to get proper namespace handling on output.  *text_or_uri* is a string "
"containing the QName value, in the form {uri}local, or, if the tag argument "
"is given, the URI part of a QName.  If *tag* is given, the first argument is "
"interpreted as a URI, and this argument is interpreted as a local name. :"
"class:`QName` instances are opaque."
msgstr ""
"Surcouche à *QName*. Cela peut être utilisé pour envelopper une valeur "
"d'attribut *QName*, afin d'obtenir une gestion appropriée de l'espace de "
"noms en sortie. *text_or_uri* est une chaîne contenant la valeur *QName*, "
"sous la forme *{uri}local* ou, si l'argument *tag* est donné, la partie URI "
"d'un *QName*. Si *tag* est donné, le premier argument est interprété comme "
"un URI et cet argument est interprété comme un nom local. Les instances :"
"class:`QName` sont opaques."

#: library/xml.etree.elementtree.rst:1256
msgid "TreeBuilder Objects"
msgstr "Objets *TreeBuilder*"

#: library/xml.etree.elementtree.rst:1262
msgid ""
"Generic element structure builder.  This builder converts a sequence of "
"start, data, end, comment and pi method calls to a well-formed element "
"structure.  You can use this class to build an element structure using a "
"custom XML parser, or a parser for some other XML-like format."
msgstr ""
"Générateur de structure d'éléments générique. Ce constructeur convertit une "
"séquence d'appels de méthode *start*, *data*, *end*, *comment* et *pi* en "
"une structure d'éléments bien formée. Vous pouvez utiliser cette classe pour "
"créer une structure d'éléments à l'aide d'un analyseur XML personnalisé ou "
"d'un analyseur pour un autre type de format XML."

#: library/xml.etree.elementtree.rst:1267
msgid ""
"*element_factory*, when given, must be a callable accepting two positional "
"arguments: a tag and a dict of attributes.  It is expected to return a new "
"element instance."
msgstr ""
"*element_factory*, lorsqu'il est donné, doit être un appelable acceptant "
"deux arguments positionnels : une balise et un dictionnaire d'attributs. "
"Elle est censée renvoyer une nouvelle instance d'élément."

#: library/xml.etree.elementtree.rst:1271
msgid ""
"The *comment_factory* and *pi_factory* functions, when given, should behave "
"like the :func:`Comment` and :func:`ProcessingInstruction` functions to "
"create comments and processing instructions.  When not given, the default "
"factories will be used.  When *insert_comments* and/or *insert_pis* is true, "
"comments/pis will be inserted into the tree if they appear within the root "
"element (but not outside of it)."
msgstr ""
"Les fonctions *comment_factory* et *pi_factory*, lorsqu'elles sont données, "
"doivent se comporter comme les fonctions :func:`Comment` et :func:"
"`ProcessingInstruction` pour créer des commentaires et des instructions de "
"traitement. Lorsqu’elles ne sont pas fournies, les fabriques par défaut sont "
"utilisées. Lorsque *insert_comments* ou *insert_pis* sont vraies, les "
"commentaires et instructions de traitement sont insérés dans l'arborescence "
"s'ils apparaissent dans l'élément racine (mais pas à l'extérieur de celui-"
"ci)."

#: library/xml.etree.elementtree.rst:1280
msgid ""
"Flushes the builder buffers, and returns the toplevel document element.  "
"Returns an :class:`Element` instance."
msgstr ""
"Vide les tampons du générateur et renvoie l'élément de document de niveau "
"supérieur. Renvoie une instance d':class:`Element`."

#: library/xml.etree.elementtree.rst:1286
msgid ""
"Adds text to the current element.  *data* is a string.  This should be "
"either a bytestring, or a Unicode string."
msgstr ""
"Ajoute du texte à l'élément courant.  *data* est une chaîne de caractères.  "
"Cela peut être une chaîne d'octets ou une chaîne Unicode."

#: library/xml.etree.elementtree.rst:1292
msgid ""
"Closes the current element.  *tag* is the element name.  Returns the closed "
"element."
msgstr ""
"Ferme l'élément courant.  *tag* est le nom de l'élément.  Renvoie l'élément "
"fermé."

#: library/xml.etree.elementtree.rst:1298
msgid ""
"Opens a new element.  *tag* is the element name.  *attrs* is a dictionary "
"containing element attributes.  Returns the opened element."
msgstr ""
"Ouvre un nouvel élément. *tag* est le nom de l'élément. *attrs* est un "
"dictionnaire contenant les attributs de l'élément. Renvoie l'élément ouvert."

#: library/xml.etree.elementtree.rst:1304
msgid ""
"Creates a comment with the given *text*.  If ``insert_comments`` is true, "
"this will also add it to the tree."
msgstr ""
"Crée un commentaire avec le *text* donné. Si ``insert_comments`` est vrai, "
"cela l'ajoute également à l'arborescence."

#: library/xml.etree.elementtree.rst:1312
#, fuzzy
msgid ""
"Creates a process instruction with the given *target* name and *text*. If "
"``insert_pis`` is true, this will also add it to the tree."
msgstr ""
"Crée un commentaire avec le nom *target* et le *text* donnés. Si "
"``insert_pis`` est vrai, cela l'ajoute également à l'arborescence."

#: library/xml.etree.elementtree.rst:1318
msgid ""
"In addition, a custom :class:`TreeBuilder` object can provide the following "
"methods:"
msgstr ""
"De plus, un objet :class:`TreeBuilder` personnalisé peut fournir les "
"méthodes suivantes :"

#: library/xml.etree.elementtree.rst:1323
msgid ""
"Handles a doctype declaration.  *name* is the doctype name.  *pubid* is the "
"public identifier.  *system* is the system identifier.  This method does not "
"exist on the default :class:`TreeBuilder` class."
msgstr ""
"Gère une déclaration *doctype*. *name* est le nom du type de document. "
"*pubid* est l'identifiant public. *system* est l'identifiant du système. "
"Cette méthode n'existe pas sur la classe par défaut :class:`TreeBuilder`."

#: library/xml.etree.elementtree.rst:1331
msgid ""
"Is called whenever the parser encounters a new namespace declaration, before "
"the ``start()`` callback for the opening element that defines it. *prefix* "
"is ``''`` for the default namespace and the declared namespace prefix name "
"otherwise.  *uri* is the namespace URI."
msgstr ""
"Est appelée chaque fois que l'analyseur rencontre une nouvelle déclaration "
"d'espace de noms, avant le rappel ``start()`` pour l'élément d'ouverture qui "
"le définit. *prefix* est ``''`` pour l'espace de noms par défaut et le nom "
"du préfixe d'espace de noms déclaré dans le cas contraire. *uri* est l'URI "
"de l'espace de noms."

#: library/xml.etree.elementtree.rst:1340
msgid ""
"Is called after the ``end()`` callback of an element that declared a "
"namespace prefix mapping, with the name of the *prefix* that went out of "
"scope."
msgstr ""
"Est appelée après le rappel ``end()`` d'un élément qui a déclaré une "
"correspondance de préfixe d'espace de noms, avec le nom du *prefix* qui "
"passe hors de portée."

#: library/xml.etree.elementtree.rst:1352
msgid ""
"A `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ writer.  Arguments are the "
"same as for the :func:`canonicalize` function.  This class does not build a "
"tree but translates the callback events directly into a serialised form "
"using the *write* function."
msgstr ""
"Écrivain `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_. Les arguments sont "
"les mêmes que pour la fonction :func:`canonicalize`. Cette classe ne "
"construit pas d'arborescence mais traduit les événements de rappel "
"directement sous une forme sérialisée à l'aide de la fonction *write*."

#: library/xml.etree.elementtree.rst:1363
msgid "XMLParser Objects"
msgstr "Objets *XMLParser*"

#: library/xml.etree.elementtree.rst:1368
msgid ""
"This class is the low-level building block of the module.  It uses :mod:`xml."
"parsers.expat` for efficient, event-based parsing of XML.  It can be fed XML "
"data incrementally with the :meth:`feed` method, and parsing events are "
"translated to a push API - by invoking callbacks on the *target* object.  If "
"*target* is omitted, the standard :class:`TreeBuilder` is used. If "
"*encoding* [1]_ is given, the value overrides the encoding specified in the "
"XML file."
msgstr ""
"Cette classe est l’élément de base du module. Elle utilise :mod:`xml.parsers."
"expat` pour une analyse efficace du XML et fonctionne à base d'événements. "
"Elle peut être alimentée en données XML de manière incrémentielle avec la "
"méthode :meth:`feed`, et les événements d'analyse sont traduits en une API à "
"flux poussé – en appelant les méthodes de rappel de l'objet *target*. Si "
"*target* est omis, le :class:`TreeBuilder` standard est utilisé. Si "
"*encoding* [1]_ est donné, la valeur remplace l'encodage spécifié dans le "
"fichier XML."

# suit un :
#: library/xml.etree.elementtree.rst:1376
#, fuzzy
msgid ""
"Parameters are now :ref:`keyword-only <keyword-only_parameter>`. The *html* "
"argument is no longer supported."
msgstr ""
"les paramètres sont désormais :ref:`nommés uniquement <keyword-"
"only_parameter>`. L'argument *html* n'est plus pris en charge."

#: library/xml.etree.elementtree.rst:1383
msgid ""
"Finishes feeding data to the parser.  Returns the result of calling the "
"``close()`` method of the *target* passed during construction; by default, "
"this is the toplevel document element."
msgstr ""
"Termine l'envoi des données à l'analyseur. Renvoie le résultat de l'appel de "
"la méthode ``close()`` de la *target* passée lors de la construction ; par "
"défaut, il s'agit de l'élément de plus haut niveau du document."

#: library/xml.etree.elementtree.rst:1390
msgid "Feeds data to the parser.  *data* is encoded data."
msgstr "Fournit des données à l’analyseur. *data* est une donnée encodée."

#: library/xml.etree.elementtree.rst:1395
#: library/xml.etree.elementtree.rst:1473
msgid ""
"Triggers parsing of any previously fed unparsed data, which can be used to "
"ensure more immediate feedback, in particular with Expat >=2.6.0. The "
"implementation of :meth:`flush` temporarily disables reparse deferral with "
"Expat (if currently enabled) and triggers a reparse. Disabling reparse "
"deferral has security consequences; please see :meth:`xml.parsers.expat."
"xmlparser.SetReparseDeferralEnabled` for details."
msgstr ""

#: library/xml.etree.elementtree.rst:1402
#: library/xml.etree.elementtree.rst:1480
msgid ""
"Note that :meth:`flush` has been backported to some prior releases of "
"CPython as a security fix.  Check for availability of :meth:`flush` using :"
"func:`hasattr` if used in code running across a variety of Python versions."
msgstr ""

#: library/xml.etree.elementtree.rst:1410
msgid ""
":meth:`XMLParser.feed` calls *target*\\'s ``start(tag, attrs_dict)`` method "
"for each opening tag, its ``end(tag)`` method for each closing tag, and data "
"is processed by method ``data(data)``.  For further supported callback "
"methods, see the :class:`TreeBuilder` class.  :meth:`XMLParser.close` calls "
"*target*\\'s method ``close()``. :class:`XMLParser` can be used not only for "
"building a tree structure. This is an example of counting the maximum depth "
"of an XML file::"
msgstr ""
":meth:`XMLParser.feed` appelle la méthode ``start(tag, attrs_dict)`` de "
"*target* pour chaque balise d'ouverture, sa méthode ``end(tag)`` pour chaque "
"balise de fermeture, et les données sont traitées par la méthode "
"``data(data)``. Pour d'autres méthodes de rappel prises en charge, consultez "
"la classe :class:`TreeBuilder`. :meth:`XMLParser.close` appelle la méthode "
"``close()`` de *target*. :class:`XMLParser` peut être utilisée pour autre "
"chose que seulement construire une structure arborescente. Voici un exemple "
"de comptage de la profondeur maximale d'un fichier XML ::"

#: library/xml.etree.elementtree.rst:1418
msgid ""
">>> from xml.etree.ElementTree import XMLParser\n"
">>> class MaxDepth:                     # The target object of the parser\n"
"...     maxDepth = 0\n"
"...     depth = 0\n"
"...     def start(self, tag, attrib):   # Called for each opening tag.\n"
"...         self.depth += 1\n"
"...         if self.depth > self.maxDepth:\n"
"...             self.maxDepth = self.depth\n"
"...     def end(self, tag):             # Called for each closing tag.\n"
"...         self.depth -= 1\n"
"...     def data(self, data):\n"
"...         pass            # We do not need to do anything with data.\n"
"...     def close(self):    # Called when all data has been parsed.\n"
"...         return self.maxDepth\n"
"...\n"
">>> target = MaxDepth()\n"
">>> parser = XMLParser(target=target)\n"
">>> exampleXml = \"\"\"\n"
"... <a>\n"
"...   <b>\n"
"...   </b>\n"
"...   <b>\n"
"...     <c>\n"
"...       <d>\n"
"...       </d>\n"
"...     </c>\n"
"...   </b>\n"
"... </a>\"\"\"\n"
">>> parser.feed(exampleXml)\n"
">>> parser.close()\n"
"4"
msgstr ""

#: library/xml.etree.elementtree.rst:1454
msgid "XMLPullParser Objects"
msgstr "Objets *XMLPullParser*"

#: library/xml.etree.elementtree.rst:1458
msgid ""
"A pull parser suitable for non-blocking applications.  Its input-side API is "
"similar to that of :class:`XMLParser`, but instead of pushing calls to a "
"callback target, :class:`XMLPullParser` collects an internal list of parsing "
"events and lets the user read from it. *events* is a sequence of events to "
"report back.  The supported events are the strings ``\"start\"``, "
"``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-"
"ns\"`` (the \"ns\" events are used to get detailed namespace information).  "
"If *events* is omitted, only ``\"end\"`` events are reported."
msgstr ""
"Analyseur à flux tiré adapté aux applications non bloquantes. Son API côté "
"entrée est similaire à celle de :class:`XMLParser`, mais au lieu de pousser "
"les appels vers une cible de rappel, :class:`XMLPullParser` collecte une "
"liste interne d'événements d'analyse et permet à l'utilisateur de la lire. "
"*events* est une séquence d'événements à signaler. Les événements pris en "
"charge sont les chaînes ``\"start\"``, ``\"end\"``, ``\"comment\"``, "
"``\"pi\"``, ``\"start-ns\"`` et ``\"end-ns\"`` (les événements ``\"ns\"`` "
"sont utilisés pour obtenir des informations détaillées sur les espaces de "
"noms). Si *events* est omis, seuls les événements ``\"end\"`` sont rapportés."

#: library/xml.etree.elementtree.rst:1469
msgid "Feed the given bytes data to the parser."
msgstr "Transmet les données d’octets à l’analyseur."

#: library/xml.etree.elementtree.rst:1489
msgid ""
"Signal the parser that the data stream is terminated. Unlike :meth:"
"`XMLParser.close`, this method always returns :const:`None`. Any events not "
"yet retrieved when the parser is closed can still be read with :meth:"
"`read_events`."
msgstr ""
"Signale à l'analyseur que le flux de données est terminé. Contrairement à :"
"meth:`XMLParser.close`, cette méthode renvoie toujours :const:`None`. Tous "
"les événements non encore récupérés lorsque l'analyseur est fermé peuvent "
"toujours être lus avec :meth:`read_events`."

#: library/xml.etree.elementtree.rst:1496
msgid ""
"Return an iterator over the events which have been encountered in the data "
"fed to the parser.  The iterator yields ``(event, elem)`` pairs, where "
"*event* is a string representing the type of event (e.g. ``\"end\"``) and "
"*elem* is the encountered :class:`Element` object, or other context value as "
"follows."
msgstr ""
"Renvoie un itérateur sur les événements qui ont été rencontrés dans les "
"données fournies à l'analyseur. L'itérateur génère des paires ``(event, "
"elem)``, où *event* est une chaîne représentant le type d'événement (par "
"exemple ``\"end\"``) et *elem* est l'objet :class:`Element` rencontré, ou "
"une autre valeur de contexte comme suit."

#: library/xml.etree.elementtree.rst:1502
msgid "``start``, ``end``: the current Element."
msgstr "``start``, ``end`` : l'élément actuel."

#: library/xml.etree.elementtree.rst:1503
msgid "``comment``, ``pi``: the current comment / processing instruction"
msgstr ""
"``comment``, ``pi`` : le commentaire ou l'instruction de traitement actuel"

#: library/xml.etree.elementtree.rst:1504
msgid ""
"``start-ns``: a tuple ``(prefix, uri)`` naming the declared namespace "
"mapping."
msgstr ""
"``start-ns`` : couple ``(prefix, uri)`` nommant la correspondance d'espace "
"de noms déclarée."

#: library/xml.etree.elementtree.rst:1506
msgid "``end-ns``: :const:`None` (this may change in a future version)"
msgstr "``end-ns`` : :const:`None` (cela peut changer dans une version future)"

#: library/xml.etree.elementtree.rst:1508
msgid ""
"Events provided in a previous call to :meth:`read_events` will not be "
"yielded again.  Events are consumed from the internal queue only when they "
"are retrieved from the iterator, so multiple readers iterating in parallel "
"over iterators obtained from :meth:`read_events` will have unpredictable "
"results."
msgstr ""
"Les événements fournis lors d'un appel précédent à :meth:`read_events` ne "
"seront plus renvoyés. Les événements sont consommés à partir de la file "
"d'attente interne uniquement lorsqu'ils sont récupérés de l'itérateur, donc "
"plusieurs lecteurs itérant en parallèle sur les itérateurs obtenus à partir "
"de :meth:`read_events` auront des résultats imprévisibles."

#: library/xml.etree.elementtree.rst:1516
msgid ""
":class:`XMLPullParser` only guarantees that it has seen the \">\" character "
"of a starting tag when it emits a \"start\" event, so the attributes are "
"defined, but the contents of the text and tail attributes are undefined at "
"that point.  The same applies to the element children; they may or may not "
"be present."
msgstr ""
":class:`XMLPullParser` garantit uniquement qu'il a vu le caractère ``\">\"`` "
"d'une balise de début lorsqu'il émet un événement ``\"start\"``, donc les "
"attributs sont définis, mais le contenu des attributs *text* et *tail* n'est "
"pas défini à ce stade. La même chose s'applique aux nœuds enfants de "
"l'élément ; ils peuvent être présents ou non."

#: library/xml.etree.elementtree.rst:1531
msgid "Exceptions"
msgstr "Exceptions"

#: library/xml.etree.elementtree.rst:1535
msgid ""
"XML parse error, raised by the various parsing methods in this module when "
"parsing fails.  The string representation of an instance of this exception "
"will contain a user-friendly error message.  In addition, it will have the "
"following attributes available:"
msgstr ""
"Erreur d'analyse XML, générée par les différentes méthodes d'analyse de ce "
"module lorsque l'analyse échoue. La représentation sous forme de chaîne "
"d'une instance de cette exception contient un message d'erreur convivial. De "
"plus, elle possède les attributs suivants :"

#: library/xml.etree.elementtree.rst:1542
msgid ""
"A numeric error code from the expat parser. See the documentation of :mod:"
"`xml.parsers.expat` for the list of error codes and their meanings."
msgstr ""
"Code d'erreur numérique de l'analyseur *expat*. Voir la documentation de :"
"mod:`xml.parsers.expat` pour la liste des codes d'erreur et leur "
"signification."

#: library/xml.etree.elementtree.rst:1547
msgid ""
"A tuple of *line*, *column* numbers, specifying where the error occurred."
msgstr ""
"Un *n*-uplet de numéros de *ligne* et *colonne* indiquant le lieu "
"d'apparition de l'erreur."

#: library/xml.etree.elementtree.rst:1550
msgid "Footnotes"
msgstr "Notes"

#: library/xml.etree.elementtree.rst:1551
msgid ""
"The encoding string included in XML output should conform to the appropriate "
"standards.  For example, \"UTF-8\" is valid, but \"UTF8\" is not.  See "
"https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl and https://"
"www.iana.org/assignments/character-sets/character-sets.xhtml."
msgstr ""
"La chaîne de caractères encodée inclue dans la sortie XML doit être conforme "
"aux standards. Par exemple, ``\"UTF-8\"`` est valide, mais pas "
"``\"UTF8\"``.  Voir https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-"
"EncodingDecl et https://www.iana.org/assignments/character-sets/character-"
"sets.xhtml."

#~ msgid ""
#~ "Returns the expanded resource.  If the parse mode is ``\"xml\"``, this is "
#~ "an ElementTree instance.  If the parse mode is \"text\", this is a "
#~ "Unicode string.  If the loader fails, it can return None or raise an "
#~ "exception."
#~ msgstr ""
#~ "Renvoie la ressource développée. Si le mode d'analyse est ``\"xml\"``, il "
#~ "s'agit d'une instance *ElementTree*. Si le mode d'analyse est "
#~ "``\"text\"``, il s'agit d'une chaîne Unicode. Si le chargeur échoue, il "
#~ "peut renvoyer ``None`` ou lever une exception."
