# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-01 00:16+0100\n"
"PO-Revision-Date: 2023-06-17 17:44+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/asyncio-policy.rst:8
msgid "Policies"
msgstr "Politiques"

#: library/asyncio-policy.rst:10
msgid ""
"An event loop policy is a global object used to get and set the current :ref:"
"`event loop <asyncio-event-loop>`, as well as create new event loops. The "
"default policy can be :ref:`replaced <asyncio-policy-get-set>` with :ref:"
"`built-in alternatives <asyncio-policy-builtin>` to use different event loop "
"implementations, or substituted by a :ref:`custom policy <asyncio-custom-"
"policies>` that can override these behaviors."
msgstr ""
"Une politique de boucle d'événements est un objet global utilisé pour "
"obtenir et définir la :ref:`boucle d'événements <asyncio-event-loop>` "
"actuelle, ainsi que créer de nouvelles boucles d'événements. La politique "
"par défaut peut être :ref:`remplacée <asyncio-policy-get-set>` par des :ref:"
"`alternatives intégrées <asyncio-policy-builtin>` afin d'utiliser d'autres "
"implémentations de boucles d'événements, ou remplacée par une :ref:"
"`politique personnalisée <asyncio-custom-policies>` qui peut remplacer ces "
"comportements."

#: library/asyncio-policy.rst:19
msgid ""
"The :ref:`policy object <asyncio-policy-objects>` gets and sets a separate "
"event loop per *context*. This is per-thread by default, though custom "
"policies could define *context* differently."
msgstr ""
"Un :ref:`objet politique <asyncio-policy-objects>` définit la notion de "
"*contexte* et gère une boucle d'événement distincte par contexte. Ceci est "
"valable fil par fil d'exécution par défaut, bien que les politiques "
"personnalisées puissent définir le *contexte* différemment."

#: library/asyncio-policy.rst:24
msgid ""
"Custom event loop policies can control the behavior of :func:"
"`get_event_loop`, :func:`set_event_loop`, and :func:`new_event_loop`."
msgstr ""
"En utilisant une politique de boucle d'événement personnalisée, le "
"comportement des fonctions :func:`get_event_loop`, :func:`set_event_loop` "
"et :func:`new_event_loop` peut être personnalisé."

#: library/asyncio-policy.rst:27
msgid ""
"Policy objects should implement the APIs defined in the :class:"
"`AbstractEventLoopPolicy` abstract base class."
msgstr ""
"Les objets politiques doivent implémenter les API définies dans la classe "
"mère abstraite :class:`AbstractEventLoopPolicy`."

#: library/asyncio-policy.rst:34
msgid "Getting and Setting the Policy"
msgstr "Obtenir et définir la politique"

#: library/asyncio-policy.rst:36
msgid ""
"The following functions can be used to get and set the policy for the "
"current process:"
msgstr ""
"Les fonctions suivantes peuvent être utilisées pour obtenir et définir la "
"politique du processus en cours :"

#: library/asyncio-policy.rst:41
msgid "Return the current process-wide policy."
msgstr "Renvoie la politique actuelle à l'échelle du processus."

#: library/asyncio-policy.rst:45
msgid "Set the current process-wide policy to *policy*."
msgstr ""
"Définit la politique actuelle sur l'ensemble du processus sur *policy*."

#: library/asyncio-policy.rst:47
msgid "If *policy* is set to ``None``, the default policy is restored."
msgstr ""
"Si *policy* est définie sur ``None``, la politique par défaut est restaurée."

#: library/asyncio-policy.rst:53
msgid "Policy Objects"
msgstr "Objets politiques"

#: library/asyncio-policy.rst:55
msgid "The abstract event loop policy base class is defined as follows:"
msgstr ""
"La classe mère abstraite de la politique de boucle d'événements est définie "
"comme suit :"

#: library/asyncio-policy.rst:59
msgid "An abstract base class for asyncio policies."
msgstr "Une classe de base abstraite pour les politiques *asyncio*."

#: library/asyncio-policy.rst:63
msgid "Get the event loop for the current context."
msgstr "Récupère la boucle d'évènements pour le contexte actuel."

#: library/asyncio-policy.rst:65
msgid ""
"Return an event loop object implementing the :class:`AbstractEventLoop` "
"interface."
msgstr ""
"Renvoie un objet de boucle d'événements en implémentant l'interface :class:"
"`AbstractEventLoop`."

#: library/asyncio-policy.rst:80
msgid "This method should never return ``None``."
msgstr "Cette méthode ne devrait jamais renvoyer ``None``."

#: library/asyncio-policy.rst:74
msgid "Set the event loop for the current context to *loop*."
msgstr "Définit la boucle d'événements du contexte actuel sur *loop*."

#: library/asyncio-policy.rst:78
msgid "Create and return a new event loop object."
msgstr "Crée et renvoie un nouvel objet de boucle d'événements."

#: library/asyncio-policy.rst:84
msgid "Get a child process watcher object."
msgstr "Récupère un objet observateur du processus enfant."

#: library/asyncio-policy.rst:86
msgid ""
"Return a watcher object implementing the :class:`AbstractChildWatcher` "
"interface."
msgstr ""
"Renvoie un objet observateur implémentant l'interface :class:"
"`AbstractChildWatcher`."

#: library/asyncio-policy.rst:97
msgid "This function is Unix specific."
msgstr "Cette fonction est spécifique à Unix."

#: library/asyncio-policy.rst:95
msgid "Set the current child process watcher to *watcher*."
msgstr "Définit l'observateur du processus enfant actuel à *watcher*."

#: library/asyncio-policy.rst:104
msgid "asyncio ships with the following built-in policies:"
msgstr "*asyncio* est livré avec les politiques intégrées suivantes :"

#: library/asyncio-policy.rst:109
msgid ""
"The default asyncio policy.  Uses :class:`SelectorEventLoop` on Unix and :"
"class:`ProactorEventLoop` on Windows."
msgstr ""
"La politique *asyncio* par défaut. Utilise :class:`SelectorEventLoop` sur "
"les plates-formes Unix et :class:`ProactorEventLoop` sur Windows."

#: library/asyncio-policy.rst:112
msgid ""
"There is no need to install the default policy manually. asyncio is "
"configured to use the default policy automatically."
msgstr ""
"Il n'est pas nécessaire d'installer la politique par défaut manuellement. "
"*asyncio* est configuré pour utiliser automatiquement la politique par "
"défaut."

#: library/asyncio-policy.rst:117
msgid "On Windows, :class:`ProactorEventLoop` is now used by default."
msgstr ""
"Sous Windows, :class:`ProactorEventLoop` est désormais utilisée par défaut."

#: library/asyncio-policy.rst:119
#, fuzzy
msgid ""
"The :meth:`get_event_loop` method of the default asyncio policy now emits a :"
"exc:`DeprecationWarning` if there is no current event loop set and it "
"decides to create one. In some future Python release this will become an "
"error."
msgstr ""
"Dans les versions Python 3.10.9, 3.11.1 et 3.12, la méthode :meth:"
"`get_event_loop` de la politique *asyncio* par défaut lève un :exc:"
"`DeprecationWarning` s'il n'y a pas de boucle d'événements en cours et "
"qu'aucune boucle actuelle n'est définie. Dans une future version de Python, "
"cela deviendra une erreur."

#: library/asyncio-policy.rst:128
msgid ""
"An alternative event loop policy that uses the :class:`SelectorEventLoop` "
"event loop implementation."
msgstr ""
"Politique de boucle d'événements alternative utilisant l'implémentation de "
"la boucle d'événements :class:`ProactorEventLoop`."

#: library/asyncio-policy.rst:139
msgid "Availability"
msgstr ""

#: library/asyncio-policy.rst:136
msgid ""
"An alternative event loop policy that uses the :class:`ProactorEventLoop` "
"event loop implementation."
msgstr ""
"Politique de boucle d'événements alternative utilisant l'implémentation de "
"la boucle d'événements :class:`ProactorEventLoop`."

#: library/asyncio-policy.rst:145
msgid "Process Watchers"
msgstr "Observateurs de processus"

#: library/asyncio-policy.rst:147
msgid ""
"A process watcher allows customization of how an event loop monitors child "
"processes on Unix. Specifically, the event loop needs to know when a child "
"process has exited."
msgstr ""
"Un observateur de processus permet de personnaliser la manière dont une "
"boucle d'événements surveille les processus enfants sous Unix. Plus "
"précisément, la boucle d'événements a besoin de savoir quand un processus "
"enfant s'est terminé."

#: library/asyncio-policy.rst:151
msgid ""
"In asyncio, child processes are created with :func:`create_subprocess_exec` "
"and :meth:`loop.subprocess_exec` functions."
msgstr ""
"Dans *asyncio*, les processus enfants sont créés avec les fonctions :func:"
"`create_subprocess_exec` et :meth:`loop.subprocess_exec`."

#: library/asyncio-policy.rst:155
msgid ""
"asyncio defines the :class:`AbstractChildWatcher` abstract base class, which "
"child watchers should implement, and has four different implementations: :"
"class:`ThreadedChildWatcher` (configured to be used by default), :class:"
"`MultiLoopChildWatcher`, :class:`SafeChildWatcher`, and :class:"
"`FastChildWatcher`."
msgstr ""
"*asyncio* définit la classe mère abstraite :class:`AbstractChildWatcher`, "
"que les observateurs enfants doivent implémenter et possède quatre "
"implémentations différentes : :class:`ThreadedChildWatcher` (configurée pour "
"être utilisé par défaut), :class:`MultiLoopChildWatcher`, :class:"
"`SafeChildWatcher` et :class:`FastChildWatcher`."

#: library/asyncio-policy.rst:161
msgid ""
"See also the :ref:`Subprocess and Threads <asyncio-subprocess-threads>` "
"section."
msgstr ""
"Voir aussi la section :ref:`sous-processus et fils d'exécution <asyncio-"
"subprocess-threads>`."

#: library/asyncio-policy.rst:164
msgid ""
"The following two functions can be used to customize the child process "
"watcher implementation used by the asyncio event loop:"
msgstr ""
"Les deux fonctions suivantes peuvent être utilisées pour personnaliser "
"l'implémentation de l'observateur de processus enfant utilisé par la boucle "
"d'événements *asyncio* :"

#: library/asyncio-policy.rst:169
msgid "Return the current child watcher for the current policy."
msgstr "Renvoie l'observateur enfant actuel pour la politique actuelle."

#: library/asyncio-policy.rst:175
msgid ""
"Set the current child watcher to *watcher* for the current policy.  "
"*watcher* must implement methods defined in the :class:"
"`AbstractChildWatcher` base class."
msgstr ""
"Définit l'observateur enfant actuel à *watcher* pour la politique actuelle. "
"*watcher* doit implémenter les méthodes définies dans la classe de base :"
"class:`AbstractChildWatcher`."

#: library/asyncio-policy.rst:182
msgid ""
"Third-party event loops implementations might not support custom child "
"watchers.  For such event loops, using :func:`set_child_watcher` might be "
"prohibited or have no effect."
msgstr ""
"Les implémentations de boucles d'événements tierces peuvent ne pas prendre "
"en charge les observateurs enfants personnalisés. Pour ces boucles "
"d'événements, utiliser :func:`set_child_watcher` pourrait être interdit ou "
"n'avoir aucun effet."

#: library/asyncio-policy.rst:190
msgid "Register a new child handler."
msgstr "Enregistre un nouveau gestionnaire."

#: library/asyncio-policy.rst:192
msgid ""
"Arrange for ``callback(pid, returncode, *args)`` to be called when a process "
"with PID equal to *pid* terminates.  Specifying another callback for the "
"same process replaces the previous handler."
msgstr ""
"Organise l'appel de ``callback(pid, returncode, * args)`` lorsqu'un "
"processus dont le *PID* est égal à *pid* se termine. La spécification d'un "
"autre rappel pour le même processus remplace le gestionnaire précédent."

#: library/asyncio-policy.rst:197
msgid "The *callback* callable must be thread-safe."
msgstr ""
"L'appelable *callback* doit être compatible avec les programmes à fils "
"d'exécution multiples."

#: library/asyncio-policy.rst:201
msgid "Removes the handler for process with PID equal to *pid*."
msgstr "Supprime le gestionnaire de processus avec un PID égal à *pid*."

#: library/asyncio-policy.rst:203
msgid ""
"The function returns ``True`` if the handler was successfully removed, "
"``False`` if there was nothing to remove."
msgstr ""
"La fonction renvoie ``True`` si le gestionnaire a été supprimé avec succès, "
"``False`` s'il n'y a rien à supprimer."

#: library/asyncio-policy.rst:208
msgid "Attach the watcher to an event loop."
msgstr "Attache l'observateur à une boucle d'événement."

#: library/asyncio-policy.rst:210
msgid ""
"If the watcher was previously attached to an event loop, then it is first "
"detached before attaching to the new loop."
msgstr ""
"Si l'observateur était précédemment attaché à une boucle d'événements, il "
"est d'abord détaché avant d'être rattaché à la nouvelle boucle."

#: library/asyncio-policy.rst:213
msgid "Note: loop may be ``None``."
msgstr "Remarque : la boucle peut être ``None``."

#: library/asyncio-policy.rst:217
msgid "Return ``True`` if the watcher is ready to use."
msgstr "Renvoie ``True`` si l'observateur est prêt à être utilisé."

#: library/asyncio-policy.rst:219
msgid ""
"Spawning a subprocess with *inactive* current child watcher raises :exc:"
"`RuntimeError`."
msgstr ""
"La création d'un sous-processus avec un observateur enfant actuel *inactif* "
"lève une :exc:`RuntimeError`."

#: library/asyncio-policy.rst:226
msgid "Close the watcher."
msgstr "Ferme l'observateur."

#: library/asyncio-policy.rst:228
msgid ""
"This method has to be called to ensure that underlying resources are cleaned-"
"up."
msgstr ""
"Cette méthode doit être appelée pour s'assurer que les ressources sous-"
"jacentes sont nettoyées."

#: library/asyncio-policy.rst:236
msgid ""
"This implementation starts a new waiting thread for every subprocess spawn."
msgstr ""
"Cette implémentation démarre un nouveau fil d'exécution en attente pour "
"chaque génération de sous-processus."

#: library/asyncio-policy.rst:238
msgid ""
"It works reliably even when the asyncio event loop is run in a non-main OS "
"thread."
msgstr ""
"Il fonctionne de manière fiable même lorsque la boucle d'événements "
"*asyncio* est exécutée dans un fil d'exécution non principal."

#: library/asyncio-policy.rst:240
#, fuzzy
msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O*\\ (1) each time a child terminates), but starting a thread per process "
"requires extra memory."
msgstr ""
"Il n'y a pas de surcharge visible lors de la manipulation d'un grand nombre "
"d'enfants (*O(1)* à chaque fois qu'un enfant se termine)."

#: library/asyncio-policy.rst:243
msgid "This watcher is used by default."
msgstr "Cet observateur est utilisé par défaut."

#: library/asyncio-policy.rst:249
msgid ""
"This implementation registers a :py:data:`SIGCHLD` signal handler on "
"instantiation. That can break third-party code that installs a custom "
"handler for :py:data:`SIGCHLD` signal."
msgstr ""
"Cette implémentation enregistre un gestionnaire de signal :py:data:`SIGCHLD` "
"lors de l'instanciation. Cela peut casser le code tiers qui installe un "
"gestionnaire personnalisé pour le signal :py:data:`SIGCHLD`."

#: library/asyncio-policy.rst:273
msgid ""
"The watcher avoids disrupting other code spawning processes by polling every "
"process explicitly on a :py:data:`SIGCHLD` signal."
msgstr ""
"L'observateur évite de perturber un autre code qui crée des processus en "
"interrogeant explicitement chaque processus sur un signal :py:data:`SIGCHLD`."

#: library/asyncio-policy.rst:256
msgid ""
"There is no limitation for running subprocesses from different threads once "
"the watcher is installed."
msgstr ""
"Il n'y a aucune limitation pour l'exécution de sous-processus à partir de "
"différents fils d'exécution une fois l'observateur installé."

#: library/asyncio-policy.rst:259
#, fuzzy
msgid ""
"The solution is safe but it has a significant overhead when handling a big "
"number of processes (*O*\\ (*n*) each time a :py:data:`SIGCHLD` is received)."
msgstr ""
"La solution est sûre mais elle a une surcharge importante lors de la gestion "
"d'un grand nombre de processus (*O(n)* chaque fois qu'un :py:data:`SIGCHLD` "
"est reçu)."

#: library/asyncio-policy.rst:269
msgid ""
"This implementation uses active event loop from the main thread to handle :"
"py:data:`SIGCHLD` signal. If the main thread has no running event loop "
"another thread cannot spawn a subprocess (:exc:`RuntimeError` is raised)."
msgstr ""
"Cette implémentation utilise une boucle d'événements active du fil "
"d'exécution principal pour gérer le signal :py:data:`SIGCHLD`. Si le fil "
"d'exécution principal n'a pas de boucle d'événements en cours d'exécution, "
"un autre fil ne pourra pas générer de sous-processus (une :exc:"
"`RuntimeError` est levée)."

#: library/asyncio-policy.rst:276
#, fuzzy
msgid ""
"This solution is as safe as :class:`MultiLoopChildWatcher` and has the same "
"*O*\\ (*n*) complexity but requires a running event loop in the main thread "
"to work."
msgstr ""
"Cette solution est aussi sûre que :class:`MultiLoopChildWatcher` et a la "
"même complexité en *O(N)* mais nécessite une boucle d'événements en cours "
"d'exécution dans le fil d'exécution principal pour fonctionner."

#: library/asyncio-policy.rst:283
msgid ""
"This implementation reaps every terminated processes by calling ``os."
"waitpid(-1)`` directly, possibly breaking other code spawning processes and "
"waiting for their termination."
msgstr ""
"Cette implémentation récupère tous les processus terminés en appelant "
"directement ``os.waitpid(-1)``, cassant éventuellement un autre code qui "
"génère des processus et attend leur fin."

#: library/asyncio-policy.rst:287
#, fuzzy
msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O*\\ (1) each time a child terminates)."
msgstr ""
"Il n'y a pas de surcharge visible lors de la manipulation d'un grand nombre "
"d'enfants (*O(1)* à chaque fois qu'un enfant se termine)."

#: library/asyncio-policy.rst:290
msgid ""
"This solution requires a running event loop in the main thread to work, as :"
"class:`SafeChildWatcher`."
msgstr ""
"Cette solution nécessite une boucle d'événements en cours d'exécution dans "
"le fil d'exécution principal pour fonctionner, comme :class:"
"`SafeChildWatcher`."

#: library/asyncio-policy.rst:297
msgid ""
"This implementation polls process file descriptors (pidfds) to await child "
"process termination. In some respects, :class:`PidfdChildWatcher` is a "
"\"Goldilocks\" child watcher implementation. It doesn't require signals or "
"threads, doesn't interfere with any processes launched outside the event "
"loop, and scales linearly with the number of subprocesses launched by the "
"event loop. The main disadvantage is that pidfds are specific to Linux, and "
"only work on recent (5.3+) kernels."
msgstr ""
"Cette implémentation interroge les descripteurs de fichiers de processus "
"(*pidfds*) pour attendre la fin du processus enfant. À certains égards, :"
"class:`PidfdChildWatcher` est une implémentation d'observateur d'enfants "
"*Goldilocks*. Elle ne nécessite ni signaux ni threads, n'interfère avec "
"aucun processus lancé en dehors de la boucle d'événements et évolue de "
"manière linéaire avec le nombre de sous-processus lancés par la boucle "
"d'événements. Le principal inconvénient est que les *pidfds* sont "
"spécifiques à Linux et ne fonctionnent que sur les noyaux récents (5.3+)."

#: library/asyncio-policy.rst:311
msgid "Custom Policies"
msgstr "Politiques personnalisées"

#: library/asyncio-policy.rst:313
msgid ""
"To implement a new event loop policy, it is recommended to subclass :class:"
"`DefaultEventLoopPolicy` and override the methods for which custom behavior "
"is wanted, e.g.::"
msgstr ""
"Pour implémenter une nouvelle politique de boucle d’événements, il est "
"recommandé de sous-classer :class:`DefaultEventLoopPolicy` et de "
"réimplémenter les méthodes pour lesquelles un comportement personnalisé est "
"souhaité, par exemple ::"

#~ msgid ":ref:`Availability <availability>`: Windows."
#~ msgstr ":ref:`Disponibilité <availability>` : Windows."

#~ msgid ""
#~ "An event loop policy is a global per-process object that controls the "
#~ "management of the event loop. Each event loop has a default policy, which "
#~ "can be changed and customized using the policy API."
#~ msgstr ""
#~ "Une stratégie de boucle d'événements est un objet global, pour chaque "
#~ "processus, qui contrôle la gestion de la boucle d'événement. Chaque "
#~ "boucle d'événement a une stratégie par défaut, qui peut être modifiée et "
#~ "personnalisée à l'aide de l'API de la stratégie."
