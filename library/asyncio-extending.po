# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2023-06-17 19:00+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/asyncio-extending.rst:6
msgid "Extending"
msgstr "Extension"

#: library/asyncio-extending.rst:8
msgid ""
"The main direction for :mod:`asyncio` extending is writing custom *event "
"loop* classes. Asyncio has helpers that could be used to simplify this task."
msgstr ""
"La direction principale pour l'extension d':mod:`asyncio` est l'écriture de "
"classes *event loop* personnalisées. *Asyncio* a des assistants qui peuvent "
"être utilisés pour simplifier cette tâche."

# suit un :
#: library/asyncio-extending.rst:13
msgid ""
"Third-parties should reuse existing asyncio code with caution, a new Python "
"version is free to break backward compatibility in *internal* part of API."
msgstr ""
"la réutilisation du code asynchrone existant doit se faire avec prudence, "
"une nouvelle version de Python est libre de rompre la compatibilité "
"descendante dans la partie *interne* de l'API."

#: library/asyncio-extending.rst:19
msgid "Writing a Custom Event Loop"
msgstr "Écriture d'une boucle d'événements personnalisée"

#: library/asyncio-extending.rst:21
msgid ""
":class:`asyncio.AbstractEventLoop` declares very many methods.  Implementing "
"all them from scratch is a tedious job."
msgstr ""
":class:`asyncio.AbstractEventLoop` déclare de très nombreuses méthodes. Les "
"mettre en œuvre à partir de zéro est un travail fastidieux."

#: library/asyncio-extending.rst:24
msgid ""
"A loop can get many common methods implementation for free by inheriting "
"from :class:`asyncio.BaseEventLoop`."
msgstr ""
"Une boucle d'événements peut obtenir gratuitement l'implémentation de "
"nombreuses méthodes courantes en héritant de :class:`asyncio.BaseEventLoop`."

#: library/asyncio-extending.rst:27
msgid ""
"In turn, the successor should implement a bunch of *private* methods "
"declared but not implemented in :class:`asyncio.BaseEventLoop`."
msgstr ""
"Le successeur doit, pour ce qui le concerne, implémenter un ensemble de "
"méthodes *privées* déclarées mais non implémentées dans :class:`asyncio."
"BaseEventLoop`."

#: library/asyncio-extending.rst:30
msgid ""
"For example, ``loop.create_connection()`` checks arguments, resolves DNS "
"addresses, and calls ``loop._make_socket_transport()`` that should be "
"implemented by inherited class. The ``_make_socket_transport()`` method is "
"not documented and is considered as an *internal* API."
msgstr ""
"Par exemple, ``loop.create_connection()`` vérifie les arguments, résout les "
"adresses DNS et appelle ``loop._make_socket_transport()`` qui doit être "
"implémentée par la classe héritée. La méthode ``_make_socket_transport()`` "
"n'est pas documentée et est considérée comme une API *interne*."

#: library/asyncio-extending.rst:38
msgid "Future and Task private constructors"
msgstr "Constructeurs privés *Future* et *Task*"

#: library/asyncio-extending.rst:40
msgid ""
":class:`asyncio.Future` and :class:`asyncio.Task` should be never created "
"directly, please use corresponding :meth:`loop.create_future` and :meth:"
"`loop.create_task`, or :func:`asyncio.create_task` factories instead."
msgstr ""
":class:`asyncio.Future` et :class:`asyncio.Task` ne doivent jamais être "
"créées directement, veuillez utiliser les correspondances :meth:`loop."
"create_future` et :meth:`loop.create_task`, ou les fabriques :func:`asyncio."
"create_task` à la place."

#: library/asyncio-extending.rst:44
msgid ""
"However, third-party *event loops* may *reuse* built-in future and task "
"implementations for the sake of getting a complex and highly optimized code "
"for free."
msgstr ""
"Cependant, les *boucles d'événements* tierces peuvent *réutiliser* les "
"implémentations de *Future* et de *Task* intégrées dans le but d'obtenir "
"gratuitement un code complexe et hautement optimisé."

#: library/asyncio-extending.rst:47
msgid "For this purpose the following, *private* constructors are listed:"
msgstr "À cette fin, les constructeurs *privés* suivants sont répertoriés :"

#: library/asyncio-extending.rst:51
msgid "Create a built-in future instance."
msgstr "Crée une instance de la *future* native."

#: library/asyncio-extending.rst:53
msgid "*loop* is an optional event loop instance."
msgstr "*loop* est une instance de boucle d'événements facultative."

#: library/asyncio-extending.rst:57
msgid "Create a built-in task instance."
msgstr "Crée une instance de la *Task* native."

#: library/asyncio-extending.rst:59
msgid ""
"*loop* is an optional event loop instance. The rest of arguments are "
"described in :meth:`loop.create_task` description."
msgstr ""
"*loop* est une instance de boucle d'événements facultative. Le reste des "
"arguments est décrit dans la description de :meth:`loop.create_task`."

# suit un :
#: library/asyncio-extending.rst:64
msgid "*context* argument is added."
msgstr "l'argument *contexte* a été ajouté."

#: library/asyncio-extending.rst:69
msgid "Task lifetime support"
msgstr "Prise en charge de la durée de vie des tâches"

#: library/asyncio-extending.rst:71
#, fuzzy
msgid ""
"A third party task implementation should call the following functions to "
"keep a task visible by :func:`asyncio.all_tasks` and :func:`asyncio."
"current_task`:"
msgstr ""
"Une implémentation tierce de tâche doit appeler les fonctions suivantes pour "
"garder une tâche visible par :func:`asyncio.get_tasks` et :func:`asyncio."
"current_task` :"

#: library/asyncio-extending.rst:76
msgid "Register a new *task* as managed by *asyncio*."
msgstr "Enregistre une nouvelle *tâche* comme gérée par *asyncio*."

#: library/asyncio-extending.rst:78
msgid "Call the function from a task constructor."
msgstr "Appelez la fonction à partir d'un constructeur de tâche."

#: library/asyncio-extending.rst:82
msgid "Unregister a *task* from *asyncio* internal structures."
msgstr "Désinscrit une *tâche* des structures internes *asyncio*."

#: library/asyncio-extending.rst:84
msgid "The function should be called when a task is about to finish."
msgstr ""
"La fonction doit être appelée lorsqu'une tâche est sur le point de se "
"terminer."

#: library/asyncio-extending.rst:88
msgid "Switch the current task to the *task* argument."
msgstr "Bascule la tâche en cours vers l'argument *task*."

#: library/asyncio-extending.rst:90
msgid ""
"Call the function just before executing a portion of embedded *coroutine* (:"
"meth:`coroutine.send` or :meth:`coroutine.throw`)."
msgstr ""
"Appelez la fonction juste avant d'exécuter une partie de la *coroutine* "
"intégrée (:meth:`coroutine.send` ou :meth:`coroutine.throw`)."

#: library/asyncio-extending.rst:95
msgid "Switch the current task back from *task* to ``None``."
msgstr "Rebascule la tâche en cours de *task* à ``None``."

#: library/asyncio-extending.rst:97
msgid ""
"Call the function just after :meth:`coroutine.send` or :meth:`coroutine."
"throw` execution."
msgstr ""
"Appelez la fonction juste après l'exécution de :meth:`coroutine.send` ou :"
"meth:`coroutine.throw`."
