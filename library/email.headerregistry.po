# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2024-03-17 22:00+0100\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/email.headerregistry.rst:2
#, fuzzy
msgid ":mod:`!email.headerregistry`: Custom Header Objects"
msgstr ":mod:`email.headerregistry` : objets d'en-tête personnalisés"

#: library/email.headerregistry.rst:10
msgid "**Source code:** :source:`Lib/email/headerregistry.py`"
msgstr "**Code source :** :source:`Lib/email/headerregistry.py`"

#: library/email.headerregistry.rst:14
msgid "[1]_"
msgstr "[1]_"

#: library/email.headerregistry.rst:16
msgid ""
"Headers are represented by customized subclasses of :class:`str`.  The "
"particular class used to represent a given header is determined by the :attr:"
"`~email.policy.EmailPolicy.header_factory` of the :mod:`~email.policy` in "
"effect when the headers are created.  This section documents the particular "
"``header_factory`` implemented by the email package for handling :RFC:`5322` "
"compliant email messages, which not only provides customized header objects "
"for various header types, but also provides an extension mechanism for "
"applications to add their own custom header types."
msgstr ""
"Les en-têtes sont représentés par des sous-classes personnalisées de :class:"
"`str`. La classe particulière utilisée pour représenter un en-tête donné est "
"déterminée par :attr:`~email.policy.EmailPolicy.header_factory` de la :mod:"
"`~email.policy` en vigueur lorsque les en-têtes sont créés. Cette section "
"documente la ``header_factory`` particulière implémentée par le paquet de "
"messagerie pour la gestion des messages électroniques conformes à la :RFC:"
"`5322`, qui fournit non seulement des objets d'en-tête personnalisés pour "
"différents types d'en-tête, mais fournit également un mécanisme d'extension "
"permettant aux applications d'ajouter leurs propres types d'en-tête "
"personnalisés."

#: library/email.headerregistry.rst:25
msgid ""
"When using any of the policy objects derived from :data:`~email.policy."
"EmailPolicy`, all headers are produced by :class:`.HeaderRegistry` and have :"
"class:`.BaseHeader` as their last base class.  Each header class has an "
"additional base class that is determined by the type of the header.  For "
"example, many headers have the class :class:`.UnstructuredHeader` as their "
"other base class.  The specialized second class for a header is determined "
"by the name of the header, using a lookup table stored in the :class:`."
"HeaderRegistry`.  All of this is managed transparently for the typical "
"application program, but interfaces are provided for modifying the default "
"behavior for use by more complex applications."
msgstr ""
"Lors de l'utilisation de l'un des objets de définition de politique dérivés "
"de :data:`~email.policy.EmailPolicy`, tous les en-têtes sont produits par :"
"class:`.HeaderRegistry` et ont :class:`.BaseHeader` comme dernière classe "
"mère. Chaque classe d'en-tête a une classe mère supplémentaire qui est "
"déterminée par le type de l'en-tête. Par exemple, de nombreux en-têtes ont "
"la classe :class:`.UnstructuredHeader` comme autre classe mère. La deuxième "
"classe spécialisée pour un en-tête est déterminée par le nom de l'en-tête, "
"en utilisant un tableau de recherche stocké dans :class:`.HeaderRegistry`. "
"Tout cela est géré de manière transparente pour le programme d'application "
"typique, mais des interfaces sont fournies pour modifier le comportement par "
"défaut pour une utilisation par des applications plus complexes."

#: library/email.headerregistry.rst:36
msgid ""
"The sections below first document the header base classes and their "
"attributes, followed by the API for modifying the behavior of :class:`."
"HeaderRegistry`, and finally the support classes used to represent the data "
"parsed from structured headers."
msgstr ""
"Les sections ci-dessous documentent d'abord les classes mères d'en-tête et "
"leurs attributs, suivies de l'API pour modifier le comportement de :class:`."
"HeaderRegistry`, et enfin les classes de gestion utilisées pour représenter "
"les données analysées à partir d'en-têtes structurés."

#: library/email.headerregistry.rst:44
msgid ""
"*name* and *value* are passed to ``BaseHeader`` from the :attr:`~email."
"policy.EmailPolicy.header_factory` call.  The string value of any header "
"object is the *value* fully decoded to unicode."
msgstr ""
"*name* et *value* sont passés à ``BaseHeader`` à partir de l'appel :attr:"
"`~email.policy.EmailPolicy.header_factory`. La valeur de chaîne de tout "
"objet d'en-tête est la *value* entièrement décodée en Unicode."

#: library/email.headerregistry.rst:48
msgid "This base class defines the following read-only properties:"
msgstr "Cette classe mère définit les propriétés en lecture seule suivantes :"

#: library/email.headerregistry.rst:53
msgid ""
"The name of the header (the portion of the field before the ':').  This is "
"exactly the value passed in the :attr:`~email.policy.EmailPolicy."
"header_factory` call for *name*; that is, case is preserved."
msgstr ""
"Nom de l'en-tête (la partie du champ avant le ``:``). C'est exactement la "
"valeur passée dans l'appel :attr:`~email.policy.EmailPolicy.header_factory` "
"pour *name* ; c'est-à-dire que la casse est préservée."

#: library/email.headerregistry.rst:61
msgid ""
"A tuple of :exc:`~email.errors.HeaderDefect` instances reporting any RFC "
"compliance problems found during parsing.  The email package tries to be "
"complete about detecting compliance issues.  See the :mod:`~email.errors` "
"module for a discussion of the types of defects that may be reported."
msgstr ""
"*n*-uplet d'instances :exc:`~email.errors.HeaderDefect` signalant tout "
"problème de conformité avec les RFC détecté lors de l'analyse. Le paquet d'e-"
"mails tente d'être complet en ce qui concerne la détection des problèmes de "
"conformité. Voir le module :mod:`~email.errors` pour une discussion sur les "
"types de défauts qui peuvent être signalés."

#: library/email.headerregistry.rst:69
msgid ""
"The maximum number of headers of this type that can have the same ``name``.  "
"A value of ``None`` means unlimited.  The ``BaseHeader`` value for this "
"attribute is ``None``; it is expected that specialized header classes will "
"override this value as needed."
msgstr ""
"Nombre maximum d'en-têtes de ce type pouvant avoir le même ``name``. Une "
"valeur de ``None`` signifie illimité. La valeur ``BaseHeader`` pour cet "
"attribut est ``None`` ; les classes d'en-tête spécialisées sont censées "
"remplacer cette valeur si nécessaire."

#: library/email.headerregistry.rst:74
msgid ""
"``BaseHeader`` also provides the following method, which is called by the "
"email library code and should not in general be called by application "
"programs:"
msgstr ""
"``BaseHeader`` fournit également la méthode suivante, qui est appelée par le "
"code de la bibliothèque de messagerie et ne doit généralement pas être "
"appelée par les programmes d'application :"

#: library/email.headerregistry.rst:80
msgid ""
"Return a string containing :attr:`~email.policy.Policy.linesep` characters "
"as required to correctly fold the header according to *policy*.  A :attr:"
"`~email.policy.Policy.cte_type` of ``8bit`` will be treated as if it were "
"``7bit``, since headers may not contain arbitrary binary data.  If :attr:"
"`~email.policy.EmailPolicy.utf8` is ``False``, non-ASCII data will be :rfc:"
"`2047` encoded."
msgstr ""
"Renvoie une chaîne contenant les caractères :attr:`~email.policy.Policy."
"linesep` nécessaires pour remettre en forme correctement l'en-tête "
"conformément à *policy*. Un :attr:`~email.policy.Policy.cte_type` de "
"``8bit`` est traité comme s'il s'agissait de ``7bit``, car les en-têtes ne "
"peuvent pas contenir de données binaires arbitraires. Si :attr:`~email."
"policy.EmailPolicy.utf8` est ``False``, les données non-ASCII seront "
"encodées selon la :rfc:`2047`."

#: library/email.headerregistry.rst:88
msgid ""
"``BaseHeader`` by itself cannot be used to create a header object.  It "
"defines a protocol that each specialized header cooperates with in order to "
"produce the header object.  Specifically, ``BaseHeader`` requires that the "
"specialized class provide a :func:`classmethod` named ``parse``.  This "
"method is called as follows::"
msgstr ""
"``BaseHeader`` seule ne peut pas être utilisée pour créer un objet d'en-"
"tête. Elle définit un protocole avec lequel chaque en-tête spécialisé "
"coopère afin de produire l'objet d'en-tête. Plus précisément, ``BaseHeader`` "
"nécessite que la classe spécialisée fournisse une :func:`classmethod` nommée "
"``parse``. Cette méthode s'appelle comme suit ::"

#: library/email.headerregistry.rst:94
msgid "parse(string, kwds)"
msgstr ""

#: library/email.headerregistry.rst:96
msgid ""
"``kwds`` is a dictionary containing one pre-initialized key, ``defects``. "
"``defects`` is an empty list.  The parse method should append any detected "
"defects to this list.  On return, the ``kwds`` dictionary *must* contain "
"values for at least the keys ``decoded`` and ``defects``.  ``decoded`` "
"should be the string value for the header (that is, the header value fully "
"decoded to unicode).  The parse method should assume that *string* may "
"contain content-transfer-encoded parts, but should correctly handle all "
"valid unicode characters as well so that it can parse un-encoded header "
"values."
msgstr ""
"``kwds`` est un dictionnaire contenant une clé pré-initialisée : "
"``defects``. ``defects`` est une liste vide. La méthode d'analyse doit "
"ajouter tous les défauts détectés à cette liste. Au retour, le dictionnaire "
"``kwds`` *doit* contenir des valeurs pour au moins les clés ``decoded`` et "
"``defects``. ``decoded`` doit être la valeur de la chaîne pour l'en-tête "
"(c'est-à-dire la valeur de l'en-tête entièrement décodée en Unicode). La "
"méthode d'analyse doit supposer que *string* peut contenir des parties "
"codées par transfert de contenu, mais doit également gérer correctement tous "
"les caractères Unicode valides afin de pouvoir analyser les valeurs d'en-"
"tête non codées."

#: library/email.headerregistry.rst:105
msgid ""
"``BaseHeader``'s ``__new__`` then creates the header instance, and calls its "
"``init`` method.  The specialized class only needs to provide an ``init`` "
"method if it wishes to set additional attributes beyond those provided by "
"``BaseHeader`` itself.  Such an ``init`` method should look like this::"
msgstr ""
"``__new__`` de ``BaseHeader`` crée ensuite l'instance d'en-tête et appelle "
"sa méthode ``init``. La classe spécialisée n'a besoin de fournir une méthode "
"``init`` que si elle souhaite définir des attributs supplémentaires au-delà "
"de ceux fournis par ``BaseHeader`` lui-même. Une telle méthode ``init`` "
"devrait ressembler à ceci ::"

#: library/email.headerregistry.rst:110
msgid ""
"def init(self, /, *args, **kw):\n"
"    self._myattr = kw.pop('myattr')\n"
"    super().init(*args, **kw)"
msgstr ""

#: library/email.headerregistry.rst:114
msgid ""
"That is, anything extra that the specialized class puts in to the ``kwds`` "
"dictionary should be removed and handled, and the remaining contents of "
"``kw`` (and ``args``) passed to the ``BaseHeader`` ``init`` method."
msgstr ""
"Autrement dit, tout ce que la classe spécialisée ajoute au dictionnaire "
"``kwds`` doit être supprimé et géré, et le contenu restant de ``kw`` (et "
"``args``) est passé à la méthode ``init`` de  ``BaseHeader``."

#: library/email.headerregistry.rst:121
msgid ""
"An \"unstructured\" header is the default type of header in :rfc:`5322`. Any "
"header that does not have a specified syntax is treated as unstructured.  "
"The classic example of an unstructured header is the :mailheader:`Subject` "
"header."
msgstr ""
"Un en-tête « non structuré » est le type d'en-tête par défaut dans la :rfc:"
"`5322`. Tout en-tête qui n'a pas de syntaxe spécifiée est traité comme non "
"structuré. L'exemple classique d'en-tête non structuré est l'en-tête :"
"mailheader:`Subject`."

#: library/email.headerregistry.rst:126
msgid ""
"In :rfc:`5322`, an unstructured header is a run of arbitrary text in the "
"ASCII character set.  :rfc:`2047`, however, has an :rfc:`5322` compatible "
"mechanism for encoding non-ASCII text as ASCII characters within a header "
"value.  When a *value* containing encoded words is passed to the "
"constructor, the ``UnstructuredHeader`` parser converts such encoded words "
"into unicode, following the :rfc:`2047` rules for unstructured text.  The "
"parser uses heuristics to attempt to decode certain non-compliant encoded "
"words.  Defects are registered in such cases, as well as defects for issues "
"such as invalid characters within the encoded words or the non-encoded text."
msgstr ""
"Dans la :rfc:`5322`, un en-tête non structuré est une séquence de texte "
"arbitraire dans le jeu de caractères ASCII. :rfc:`2047`, cependant, possède "
"un mécanisme compatible :rfc:`5322` pour encoder du texte non-ASCII en tant "
"que caractères ASCII dans une valeur d'en-tête. Lorsqu'une *value* contenant "
"des mots encodés est passée au constructeur, l'analyseur "
"``UnstructuredHeader`` convertit ces mots encodés en Unicode, en suivant les "
"règles de la :rfc:`2047` pour le texte non structuré. L'analyseur utilise "
"des heuristiques pour tenter de décoder certains mots codés non conformes. "
"Des défauts sont enregistrés dans de tels cas, ainsi que des défauts pour "
"des problèmes tels que des caractères non valides dans les mots codés ou le "
"texte non codé."

#: library/email.headerregistry.rst:136
msgid "This header type provides no additional attributes."
msgstr "Ce type d'en-tête ne fournit aucun attribut supplémentaire."

#: library/email.headerregistry.rst:141
msgid ""
":rfc:`5322` specifies a very specific format for dates within email headers. "
"The ``DateHeader`` parser recognizes that date format, as well as "
"recognizing a number of variant forms that are sometimes found \"in the "
"wild\"."
msgstr ""
"La :rfc:`5322` spécifie un format très spécifique pour les dates dans les en-"
"têtes de courrier électronique. L'analyseur ``DateHeader`` reconnaît ce "
"format de date, ainsi qu'un certain nombre de formes variantes que l'on "
"trouve parfois « dans la nature »."

#: library/email.headerregistry.rst:146 library/email.headerregistry.rst:188
msgid "This header type provides the following additional attributes:"
msgstr "Ce type d'en-tête fournit les attributs supplémentaires suivants :"

#: library/email.headerregistry.rst:150
msgid ""
"If the header value can be recognized as a valid date of one form or "
"another, this attribute will contain a :class:`~datetime.datetime` instance "
"representing that date.  If the timezone of the input date is specified as "
"``-0000`` (indicating it is in UTC but contains no information about the "
"source timezone), then :attr:`.datetime` will be a naive :class:`~datetime."
"datetime`.  If a specific timezone offset is found (including ``+0000``), "
"then :attr:`.datetime` will contain an aware ``datetime`` that uses :class:"
"`datetime.timezone` to record the timezone offset."
msgstr ""
"Si la valeur d'en-tête peut être reconnue comme une date valide d'une forme "
"ou d'une autre, cet attribut contient une instance :class:`~datetime."
"datetime` représentant cette date. Si le fuseau horaire de la date d'entrée "
"est spécifié comme ``-0000`` (indiquant qu'il est en UTC mais ne contient "
"aucune information sur le fuseau horaire source), alors :attr:`.datetime` "
"est une :class:`~datetime.datetime` naïve. Si un décalage de fuseau horaire "
"spécifique est trouvé (y compris ``+0000``), alors :attr:`.datetime` "
"contient un ``datetime`` avisé qui utilise :class:`datetime.timezone` pour "
"enregistrer le décalage lié au fuseau horaire."

#: library/email.headerregistry.rst:160
msgid ""
"The ``decoded`` value of the header is determined by formatting the "
"``datetime`` according to the :rfc:`5322` rules; that is, it is set to::"
msgstr ""
"La valeur ``decoded`` de l'en-tête est déterminée en formatant le "
"``datetime`` selon les règles de la :rfc:`5322` ; c'est-à-dire qu'elle est "
"définie sur ::"

#: library/email.headerregistry.rst:163
msgid "email.utils.format_datetime(self.datetime)"
msgstr ""

#: library/email.headerregistry.rst:165
msgid ""
"When creating a ``DateHeader``, *value* may be :class:`~datetime.datetime` "
"instance.  This means, for example, that the following code is valid and "
"does what one would expect::"
msgstr ""
"Lors de la création d'un ``DateHeader``, *value* peut être une instance de :"
"class:`~datetime.datetime`. Cela signifie, par exemple, que le code suivant "
"est valide et fait ce à quoi on pourrait s'attendre ::"

#: library/email.headerregistry.rst:169
msgid "msg['Date'] = datetime(2011, 7, 15, 21)"
msgstr ""

#: library/email.headerregistry.rst:171
msgid ""
"Because this is a naive ``datetime`` it will be interpreted as a UTC "
"timestamp, and the resulting value will have a timezone of ``-0000``.  Much "
"more useful is to use the :func:`~email.utils.localtime` function from the :"
"mod:`~email.utils` module::"
msgstr ""
"Comme il s'agit d'un ``datetime`` naïf, il est interprété comme un "
"horodatage UTC et la valeur résultante a un fuseau horaire de ``-0000``. Il "
"est beaucoup plus utile d'utiliser la fonction :func:`~email.utils."
"localtime` du module :mod:`~email.utils` ::"

#: library/email.headerregistry.rst:176
msgid "msg['Date'] = utils.localtime()"
msgstr ""

#: library/email.headerregistry.rst:178
msgid ""
"This example sets the date header to the current time and date using the "
"current timezone offset."
msgstr ""
"Cet exemple définit l'en-tête de date sur l'heure et la date actuelles à "
"l'aide du décalage horaire actuel."

#: library/email.headerregistry.rst:184
msgid ""
"Address headers are one of the most complex structured header types. The "
"``AddressHeader`` class provides a generic interface to any address header."
msgstr ""
"Les en-têtes d'adresse sont l'un des types d'en-têtes structurés les plus "
"complexes. La classe ``AddressHeader`` fournit une interface générique à "
"n'importe quel en-tête d'adresse."

#: library/email.headerregistry.rst:193
msgid ""
"A tuple of :class:`.Group` objects encoding the addresses and groups found "
"in the header value.  Addresses that are not part of a group are represented "
"in this list as single-address ``Groups`` whose :attr:`~.Group.display_name` "
"is ``None``."
msgstr ""
"*n*-uplet d'objets :class:`.Group` encodant les adresses et les groupes "
"trouvés dans la valeur d'en-tête. Les adresses qui ne font pas partie d'un "
"groupe sont représentées dans cette liste comme des ``Groups`` à adresse "
"unique dont :attr:`~.Group.display_name` est ``None``."

#: library/email.headerregistry.rst:201
msgid ""
"A tuple of :class:`.Address` objects encoding all of the individual "
"addresses from the header value.  If the header value contains any groups, "
"the individual addresses from the group are included in the list at the "
"point where the group occurs in the value (that is, the list of addresses is "
"\"flattened\" into a one dimensional list)."
msgstr ""
"*n*-uplet d'objets :class:`.Address` encodant toutes les adresses "
"individuelles à partir de la valeur d'en-tête. Si la valeur d'en-tête "
"contient des groupes, les adresses individuelles du groupe sont incluses "
"dans la liste au point où le groupe apparaît dans la valeur (c'est-à-dire "
"que la liste d'adresses est « aplatie » en une liste unidimensionnelle)."

#: library/email.headerregistry.rst:207
msgid ""
"The ``decoded`` value of the header will have all encoded words decoded to "
"unicode.  :class:`~encodings.idna` encoded domain names are also decoded to "
"unicode.  The ``decoded`` value is set by :ref:`joining <meth-str-join>` "
"the :class:`str` value of the elements of the ``groups`` attribute with ``', "
"'``."
msgstr ""
"La valeur ``decoded`` de l'en-tête a tous les mots codés décodés en Unicode. "
"Les noms de domaine encodés en :class:`~encodings.idna` sont également "
"décodés en Unicode. La valeur ``decoded`` est définie en :ref:`joignant "
"<meth-str-join>` la valeur :class:`str` des éléments de l'attribut "
"``groups`` avec ``', '``."

#: library/email.headerregistry.rst:213
msgid ""
"A list of :class:`.Address` and :class:`.Group` objects in any combination "
"may be used to set the value of an address header.  ``Group`` objects whose "
"``display_name`` is ``None`` will be interpreted as single addresses, which "
"allows an address list to be copied with groups intact by using the list "
"obtained from the ``groups`` attribute of the source header."
msgstr ""
"Une liste d'objets :class:`.Address` et :class:`.Group` dans n'importe "
"quelle combinaison peut être utilisée pour définir la valeur d'un en-tête "
"d'adresse. Les objets ``Group`` dont le ``display_name`` est ``None`` sont "
"interprétés comme des adresses uniques, ce qui permet de copier une liste "
"d'adresses avec des groupes intacts en utilisant la liste obtenue à partir "
"de l'attribut ``groups`` de l'en-tête source."

#: library/email.headerregistry.rst:222
msgid ""
"A subclass of :class:`.AddressHeader` that adds one additional attribute:"
msgstr ""
"Sous-classe de :class:`.AddressHeader` qui ajoute un attribut "
"supplémentaire :"

#: library/email.headerregistry.rst:228
msgid ""
"The single address encoded by the header value.  If the header value "
"actually contains more than one address (which would be a violation of the "
"RFC under the default :mod:`~email.policy`), accessing this attribute will "
"result in a :exc:`ValueError`."
msgstr ""
"Adresse unique codée par la valeur d'en-tête. Si la valeur d'en-tête "
"contient en fait plus d'une adresse (ce qui serait une violation de la RFC "
"sous la valeur par défaut :mod:`~email.policy`), l'accès à cet attribut lève "
"une :exc:`ValueError`."

#: library/email.headerregistry.rst:234
msgid ""
"Many of the above classes also have a ``Unique`` variant (for example, "
"``UniqueUnstructuredHeader``).  The only difference is that in the "
"``Unique`` variant, :attr:`~.BaseHeader.max_count` is set to 1."
msgstr ""
"La plupart des classes ci-dessus ont également une variante ``Unique`` (par "
"exemple, ``UniqueUnstructuredHeader``). La seule différence est que dans la "
"variante ``Unique``, :attr:`~.BaseHeader.max_count` est définie sur 1."

#: library/email.headerregistry.rst:241
msgid ""
"There is really only one valid value for the :mailheader:`MIME-Version` "
"header, and that is ``1.0``.  For future proofing, this header class "
"supports other valid version numbers.  If a version number has a valid value "
"per :rfc:`2045`, then the header object will have non-``None`` values for "
"the following attributes:"
msgstr ""
"Il n'y a vraiment qu'une seule valeur valide pour l'en-tête :mailheader:"
"`MIME-Version`, et c'est ``1.0``. Au cas où, cette classe d'en-tête prend en "
"charge d'autres numéros de version valides. Si un numéro de version a une "
"valeur valide selon la :rfc:`2045`, alors l'objet d'en-tête a des valeurs "
"autres que ``None`` pour les attributs suivants :"

#: library/email.headerregistry.rst:249
msgid ""
"The version number as a string, with any whitespace and/or comments removed."
msgstr "Numéro de version sous forme de chaîne, sans espaces ni commentaires."

#: library/email.headerregistry.rst:254
msgid "The major version number as an integer"
msgstr "Numéro de version majeure sous forme d'entier"

#: library/email.headerregistry.rst:258
msgid "The minor version number as an integer"
msgstr "Numéro de version mineure sous forme d'entier"

#: library/email.headerregistry.rst:263
msgid ""
"MIME headers all start with the prefix 'Content-'.  Each specific header has "
"a certain value, described under the class for that header.  Some can also "
"take a list of supplemental parameters, which have a common format. This "
"class serves as a base for all the MIME headers that take parameters."
msgstr ""
"Les en-têtes MIME commencent tous par le préfixe ``'Content-'``. Chaque en-"
"tête spécifique a une certaine valeur, décrite par la classe de cet en-tête. "
"Certains peuvent également prendre une liste de paramètres supplémentaires, "
"qui ont un format commun. Cette classe sert de base à tous les en-têtes MIME "
"qui prennent des paramètres."

#: library/email.headerregistry.rst:270
msgid "A dictionary mapping parameter names to parameter values."
msgstr ""
"Dictionnaire de correspondance entre les noms de paramètres et leurs valeurs."

#: library/email.headerregistry.rst:275
msgid ""
"A :class:`ParameterizedMIMEHeader` class that handles the :mailheader:"
"`Content-Type` header."
msgstr ""
"Classe :class:`ParameterizedMIMEHeader` qui gère l'en-tête :mailheader:"
"`Content-Type`."

#: library/email.headerregistry.rst:280
msgid "The content type string, in the form ``maintype/subtype``."
msgstr "Chaîne de type de contenu, sous la forme ``maintype/subtype``."

#: library/email.headerregistry.rst:289
msgid ""
"A :class:`ParameterizedMIMEHeader` class that handles the :mailheader:"
"`Content-Disposition` header."
msgstr ""
"Classe :class:`ParameterizedMIMEHeader` qui gère l'en-tête :mailheader:"
"`Content-Disposition`."

#: library/email.headerregistry.rst:294
msgid "``inline`` and ``attachment`` are the only valid values in common use."
msgstr ""
"``inline`` et ``attachment`` sont les seules valeurs valides couramment "
"utilisées."

#: library/email.headerregistry.rst:299
msgid "Handles the :mailheader:`Content-Transfer-Encoding` header."
msgstr "Gère l'en-tête :mailheader:`Content-Transfer-Encoding`."

#: library/email.headerregistry.rst:303
msgid ""
"Valid values are ``7bit``, ``8bit``, ``base64``, and ``quoted-printable``.  "
"See :rfc:`2045` for more information."
msgstr ""
"Les valeurs valides sont ``7bit``, ``8bit``, ``base64`` et ``quoted-"
"printable``. Voir la :rfc:`2045` pour plus d'informations."

#: library/email.headerregistry.rst:312
#, fuzzy
msgid ""
"This is the factory used by :class:`~email.policy.EmailPolicy` by default. "
"``HeaderRegistry`` builds the class used to create a header instance "
"dynamically, using *base_class* and a specialized class retrieved from a "
"registry that it holds.  When a given header name does not appear in the "
"registry, the class specified by *default_class* is used as the specialized "
"class.  When *use_default_map* is ``True`` (the default), the standard "
"mapping of header names to classes is copied in to the registry during "
"initialization.  *base_class* is always the last class in the generated "
"class's :class:`~type.__bases__` list."
msgstr ""
"C'est la fabrique utilisée par :class:`~email.policy.EmailPolicy` par "
"défaut. ``HeaderRegistry`` construit la classe utilisée pour créer "
"dynamiquement une instance d'en-tête, en utilisant *base_class* et une "
"classe spécialisée récupérée à partir d'un registre qu'il contient. "
"Lorsqu'un nom d'en-tête donné n'apparaît pas dans le registre, la classe "
"spécifiée par *default_class* est utilisée comme classe spécialisée. Lorsque "
"*use_default_map* est ``True`` (valeur par défaut), la correspondance "
"standard des noms d'en-tête aux classes est copiée dans le registre lors de "
"l'initialisation. *base_class* est toujours la dernière classe dans la liste "
"``__bases__`` de la classe générée."

#: library/email.headerregistry.rst:322
msgid "The default mappings are:"
msgstr "Les correspondances par défaut sont :"

#: library/email.headerregistry.rst:0
msgid "subject"
msgstr "subject"

#: library/email.headerregistry.rst:324
msgid "UniqueUnstructuredHeader"
msgstr "UniqueUnstructuredHeader"

#: library/email.headerregistry.rst:0
msgid "date"
msgstr "date"

#: library/email.headerregistry.rst:325 library/email.headerregistry.rst:327
msgid "UniqueDateHeader"
msgstr "UniqueDateHeader"

#: library/email.headerregistry.rst:0
msgid "resent-date"
msgstr "resent-date"

#: library/email.headerregistry.rst:326
msgid "DateHeader"
msgstr "DateHeader"

#: library/email.headerregistry.rst:0
msgid "orig-date"
msgstr "orig-date"

#: library/email.headerregistry.rst:0
msgid "sender"
msgstr "sender"

#: library/email.headerregistry.rst:328
msgid "UniqueSingleAddressHeader"
msgstr "UniqueSingleAddressHeader"

#: library/email.headerregistry.rst:0
msgid "resent-sender"
msgstr "resent-sender"

#: library/email.headerregistry.rst:329
msgid "SingleAddressHeader"
msgstr "SingleAddressHeader"

#: library/email.headerregistry.rst:0
msgid "to"
msgstr "to"

#: library/email.headerregistry.rst:330 library/email.headerregistry.rst:332
#: library/email.headerregistry.rst:334 library/email.headerregistry.rst:336
#: library/email.headerregistry.rst:338
msgid "UniqueAddressHeader"
msgstr "UniqueAddressHeader"

#: library/email.headerregistry.rst:0
msgid "resent-to"
msgstr "resent-to"

#: library/email.headerregistry.rst:331 library/email.headerregistry.rst:333
#: library/email.headerregistry.rst:335 library/email.headerregistry.rst:337
msgid "AddressHeader"
msgstr "AddressHeader"

#: library/email.headerregistry.rst:0
msgid "cc"
msgstr "cc"

#: library/email.headerregistry.rst:0
msgid "resent-cc"
msgstr "resent-cc"

#: library/email.headerregistry.rst:0
msgid "bcc"
msgstr "bcc"

#: library/email.headerregistry.rst:0
msgid "resent-bcc"
msgstr "resent-bcc"

#: library/email.headerregistry.rst:0
msgid "from"
msgstr "from"

#: library/email.headerregistry.rst:0
msgid "resent-from"
msgstr "resent-from"

#: library/email.headerregistry.rst:0
msgid "reply-to"
msgstr "reply-to"

#: library/email.headerregistry.rst:0
msgid "mime-version"
msgstr "mime-version"

#: library/email.headerregistry.rst:339
msgid "MIMEVersionHeader"
msgstr "MIMEVersionHeader"

#: library/email.headerregistry.rst:0
msgid "content-type"
msgstr "content-type"

#: library/email.headerregistry.rst:340
msgid "ContentTypeHeader"
msgstr "ContentTypeHeader"

#: library/email.headerregistry.rst:0
msgid "content-disposition"
msgstr "content-disposition"

#: library/email.headerregistry.rst:341
msgid "ContentDispositionHeader"
msgstr "ContentDispositionHeader"

#: library/email.headerregistry.rst:0
msgid "content-transfer-encoding"
msgstr "content-transfer-encoding"

#: library/email.headerregistry.rst:342
msgid "ContentTransferEncodingHeader"
msgstr "ContentTransferEncodingHeader"

#: library/email.headerregistry.rst:0
msgid "message-id"
msgstr "message-id"

#: library/email.headerregistry.rst:343
msgid "MessageIDHeader"
msgstr "MessageIDHeader"

#: library/email.headerregistry.rst:345
msgid "``HeaderRegistry`` has the following methods:"
msgstr "``HeaderRegistry`` a les méthodes suivantes :"

#: library/email.headerregistry.rst:350
msgid ""
"*name* is the name of the header to be mapped.  It will be converted to "
"lower case in the registry.  *cls* is the specialized class to be used, "
"along with *base_class*, to create the class used to instantiate headers "
"that match *name*."
msgstr ""
"*name* est le nom de l'en-tête à faire correspondre. Il est converti en "
"minuscules dans le registre. *cls* est la classe spécialisée à utiliser, "
"avec *base_class*, pour créer la classe utilisée pour instancier les en-"
"têtes qui correspondent à *name*."

#: library/email.headerregistry.rst:358
msgid "Construct and return a class to handle creating a *name* header."
msgstr ""
"Construit et renvoie une classe pour gérer la création d'un en-tête *name*."

#: library/email.headerregistry.rst:363
msgid ""
"Retrieves the specialized header associated with *name* from the registry "
"(using *default_class* if *name* does not appear in the registry) and "
"composes it with *base_class* to produce a class, calls the constructed "
"class's constructor, passing it the same argument list, and finally returns "
"the class instance created thereby."
msgstr ""
"Récupère l'en-tête spécialisé associé à *name* du registre (en utilisant "
"*default_class* si *name* n'apparaît pas dans le registre) et le compose "
"avec *base_class* pour produire une classe, appelle le constructeur de la "
"classe construite, en lui passant la même liste d'arguments, et renvoie "
"enfin l'instance de classe ainsi créée."

#: library/email.headerregistry.rst:370
msgid ""
"The following classes are the classes used to represent data parsed from "
"structured headers and can, in general, be used by an application program to "
"construct structured values to assign to specific headers."
msgstr ""
"Les classes suivantes sont les classes utilisées pour représenter les "
"données analysées à partir d'en-têtes structurés et peuvent, en général, "
"être utilisées par un programme d'application pour construire des valeurs "
"structurées à affecter à des en-têtes spécifiques."

#: library/email.headerregistry.rst:377
msgid ""
"The class used to represent an email address.  The general form of an "
"address is::"
msgstr ""
"Classe utilisée pour représenter une adresse e-mail. La forme générale d'une "
"adresse est :"

#: library/email.headerregistry.rst:380
msgid "[display_name] <username@domain>"
msgstr ""

#: library/email.headerregistry.rst:382
msgid "or::"
msgstr "ou ::"

#: library/email.headerregistry.rst:384
msgid "username@domain"
msgstr ""

#: library/email.headerregistry.rst:386
msgid ""
"where each part must conform to specific syntax rules spelled out in :rfc:"
"`5322`."
msgstr ""
"où chaque partie doit se conformer à des règles de syntaxe spécifiques "
"énoncées dans la :rfc:`5322`."

#: library/email.headerregistry.rst:389
msgid ""
"As a convenience *addr_spec* can be specified instead of *username* and "
"*domain*, in which case *username* and *domain* will be parsed from the "
"*addr_spec*.  An *addr_spec* must be a properly RFC quoted string; if it is "
"not ``Address`` will raise an error.  Unicode characters are allowed and "
"will be property encoded when serialized.  However, per the RFCs, unicode is "
"*not* allowed in the username portion of the address."
msgstr ""
"Pour plus de commodité, *addr_spec* peut être spécifié à la place de "
"*username* et *domain*, *username* et *domain* sont alors analysés à partir "
"de *addr_spec*. Une *addr_spec* doit être une chaîne correctement entre "
"guillemets RFC ; si ce n'est pas le cas, ``Address`` lève une erreur. Les "
"caractères Unicode sont autorisés et sont encodés proprement lors de la "
"sérialisation. Cependant, selon les RFC, l’Unicode n'est *pas* autorisé dans "
"la partie nom d'utilisateur de l'adresse."

#: library/email.headerregistry.rst:398
msgid ""
"The display name portion of the address, if any, with all quoting removed.  "
"If the address does not have a display name, this attribute will be an empty "
"string."
msgstr ""
"Partie du nom d'affichage de l'adresse, le cas échéant, avec toutes les "
"citations supprimées. Si l'adresse n'a pas de nom d'affichage, cet attribut "
"est une chaîne vide."

#: library/email.headerregistry.rst:404
msgid "The ``username`` portion of the address, with all quoting removed."
msgstr "Partie ``username`` de l'adresse, sans guillemets."

#: library/email.headerregistry.rst:408
msgid "The ``domain`` portion of the address."
msgstr "Partie ``domain`` de l'adresse."

#: library/email.headerregistry.rst:412
msgid ""
"The ``username@domain`` portion of the address, correctly quoted for use as "
"a bare address (the second form shown above).  This attribute is not mutable."
msgstr ""
"Partie ``username@domain`` de l'adresse, correctement citée pour une "
"utilisation en tant qu'adresse nue (la deuxième forme illustrée ci-dessus). "
"Cet attribut n'est pas modifiable."

#: library/email.headerregistry.rst:418
msgid ""
"The ``str`` value of the object is the address quoted according to :rfc:"
"`5322` rules, but with no Content Transfer Encoding of any non-ASCII "
"characters."
msgstr ""
"La valeur ``str`` de l'objet est l'adresse entre guillemets selon les règles "
"de la :rfc:`5322`, mais sans encodage de contenu pour les caractères non-"
"ASCII."

#: library/email.headerregistry.rst:422
msgid ""
"To support SMTP (:rfc:`5321`), ``Address`` handles one special case: if "
"``username`` and ``domain`` are both the empty string (or ``None``), then "
"the string value of the ``Address`` is ``<>``."
msgstr ""
"Pour prendre en charge SMTP (:rfc:`5321`), ``Address`` gère un cas "
"particulier : si ``username`` et ``domain`` sont tous deux la chaîne vide "
"(ou ``None``), alors la valeur de chaîne de ``Address`` est ``<>``."

#: library/email.headerregistry.rst:429
msgid ""
"The class used to represent an address group.  The general form of an "
"address group is::"
msgstr ""
"Classe utilisée pour représenter un groupe d'adresses. La forme générale "
"d'un groupe d'adresses est :"

#: library/email.headerregistry.rst:432
msgid "display_name: [address-list];"
msgstr ""

#: library/email.headerregistry.rst:434
msgid ""
"As a convenience for processing lists of addresses that consist of a mixture "
"of groups and single addresses, a ``Group`` may also be used to represent "
"single addresses that are not part of a group by setting *display_name* to "
"``None`` and providing a list of the single address as *addresses*."
msgstr ""
"Pour faciliter le traitement des listes d'adresses composées d'un mélange de "
"groupes et d'adresses uniques, un ``Group`` peut également être utilisé pour "
"représenter des adresses uniques qui ne font pas partie d'un groupe en "
"définissant *display_name* sur ``None`` et en fournissant une liste de "
"l'adresse unique sous la forme *adresses*."

#: library/email.headerregistry.rst:441
msgid ""
"The ``display_name`` of the group.  If it is ``None`` and there is exactly "
"one ``Address`` in ``addresses``, then the ``Group`` represents a single "
"address that is not in a group."
msgstr ""
"``display_name`` du groupe. Si c'est ``None`` et qu'il y a exactement une "
"``Adress`` dans ``adresses``, alors le ``Group`` représente une seule "
"adresse qui n'est pas dans un groupe."

#: library/email.headerregistry.rst:447
msgid ""
"A possibly empty tuple of :class:`.Address` objects representing the "
"addresses in the group."
msgstr ""
"*n*-uplet éventuellement vide d'objets :class:`.Address` représentant les "
"adresses du groupe."

#: library/email.headerregistry.rst:452
msgid ""
"The ``str`` value of a ``Group`` is formatted according to :rfc:`5322`, but "
"with no Content Transfer Encoding of any non-ASCII characters.  If "
"``display_name`` is none and there is a single ``Address`` in the "
"``addresses`` list, the ``str`` value will be the same as the ``str`` of "
"that single ``Address``."
msgstr ""
"La valeur ``str`` d'un ``Group`` est formatée selon la :rfc:`5322`, mais "
"sans encodage de contenu pour les caractères non-ASCII. Si ``display_name`` "
"est ``None`` et qu'il y a une seule ``Address`` dans la liste ``addresses``, "
"la valeur ``str`` est la même que la ``str`` de cette seule ``Adress``."

#: library/email.headerregistry.rst:460
msgid "Footnotes"
msgstr "Notes"

#: library/email.headerregistry.rst:461
msgid ""
"Originally added in 3.3 as a :term:`provisional module <provisional package>`"
msgstr ""
"Ajouté à l'origine dans 3.3 en tant que :term:`paquet provisoire "
"<provisional package>`"
