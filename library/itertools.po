# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-01 00:16+0100\n"
"PO-Revision-Date: 2024-10-29 22:04+0100\n"
"Last-Translator: Jean Abou Samra <jean@abou-samra.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/itertools.rst:2
#, fuzzy
msgid ""
":mod:`!itertools` --- Functions creating iterators for efficient looping"
msgstr ""
":mod:`itertools` — Fonctions créant des itérateurs pour boucler efficacement"

#: library/itertools.rst:20
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired "
"by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr ""
"Ce module implémente de nombreuses briques :term:`d'itérateurs <itérateur>` "
"inspirées par des éléments de APL, Haskell et SML. Toutes ont été "
"retravaillées dans un format adapté à Python."

#: library/itertools.rst:24
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr ""
"Ce module standardise un ensemble de base d'outils rapides et efficaces en "
"mémoire qui peuvent être utilisés individuellement ou en les combinant. "
"Ensemble, ils forment une « algèbre d'itérateurs » rendant possible la "
"construction rapide et efficace d'outils spécialisés en Python."

#: library/itertools.rst:29
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces "
"a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`map` and :func:`count` to form ``map(f, count())``."
msgstr ""
"Par exemple, SML fournit un outil de tabulation ``tabulate(f)`` qui produit  "
"une séquence ``f(0), f(1), ...``. Le même résultat peut être obtenu en "
"Python en combinant :func:`map` et :func:`count` pour former ``map(f, "
"count())``."

#: library/itertools.rst:33
msgid ""
"These tools and their built-in counterparts also work well with the high-"
"speed functions in the :mod:`operator` module.  For example, the "
"multiplication operator can be mapped across two vectors to form an "
"efficient dot-product: ``sum(starmap(operator.mul, zip(vec1, vec2, "
"strict=True)))``."
msgstr ""
"Ces outils et leurs équivalents natifs fonctionnent également bien avec les "
"fonctions optimisées du module :mod:`operator`. Par exemple, l'opérateur de "
"multiplication peut être appliqué à deux vecteurs pour créer un produit "
"scalaire efficace : ``sum(map(operator.mul, vecteur1, vecteur2))``."

#: library/itertools.rst:39
msgid "**Infinite iterators:**"
msgstr "**Itérateurs infinis :**"

#: library/itertools.rst:52 library/itertools.rst:73
msgid "Iterator"
msgstr "Itérateur"

#: library/itertools.rst:52 library/itertools.rst:73
msgid "Arguments"
msgstr "Arguments"

#: library/itertools.rst:52 library/itertools.rst:82
msgid "Results"
msgstr "Résultats"

#: library/itertools.rst:52
msgid "Example"
msgstr "Exemple"

#: library/itertools.rst:44
msgid ":func:`count`"
msgstr ":func:`count`"

#: library/itertools.rst:44
msgid "[start[, step]]"
msgstr "``[start[, step]]``"

#: library/itertools.rst:44
msgid "start, start+step, start+2*step, ..."
msgstr "``start, start+step, start+2*step, ...``"

#: library/itertools.rst:44
msgid "``count(10) → 10 11 12 13 14 ...``"
msgstr "``count(10) → 10 11 12 13 14 ...``"

#: library/itertools.rst:45
msgid ":func:`cycle`"
msgstr ":func:`cycle`"

#: library/itertools.rst:45
msgid "p"
msgstr "p"

#: library/itertools.rst:45
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: library/itertools.rst:45
#, fuzzy
msgid "``cycle('ABCD') → A B C D A B C D ...``"
msgstr "``cycle('ABCD') --> A B C D A B C D ...``"

#: library/itertools.rst:46
msgid ":func:`repeat`"
msgstr ":func:`repeat`"

#: library/itertools.rst:46
msgid "elem [,n]"
msgstr "elem [,n]"

#: library/itertools.rst:46
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "*elem*, *elem*, *elem*, ... à l'infini ou jusqu'à n fois"

#: library/itertools.rst:46
#, fuzzy
msgid "``repeat(10, 3) → 10 10 10``"
msgstr "``repeat(10, 3) --> 10 10 10``"

#: library/itertools.rst:49
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**Itérateurs se terminant par la séquence d'entrée la plus courte :**"

#: library/itertools.rst:54
msgid ":func:`accumulate`"
msgstr ":func:`accumulate`"

#: library/itertools.rst:54
msgid "p [,func]"
msgstr "p [,func]"

#: library/itertools.rst:54
msgid "p0, p0+p1, p0+p1+p2, ..."
msgstr "p0, p0+p1, p0+p1+p2, ..."

#: library/itertools.rst:54
#, fuzzy
msgid "``accumulate([1,2,3,4,5]) → 1 3 6 10 15``"
msgstr "``accumulate([1,2,3,4,5]) --> 1 3 6 10 15``"

#: library/itertools.rst:55
#, fuzzy
msgid ":func:`batched`"
msgstr ":func:`tee`"

#: library/itertools.rst:55
msgid "p, n"
msgstr ""

#: library/itertools.rst:55
#, fuzzy
msgid "(p0, p1, ..., p_n-1), ..."
msgstr "p0, p1, ... ``plast``, p0, p1, ..."

#: library/itertools.rst:55
#, fuzzy
msgid "``batched('ABCDEFG', n=3) → ABC DEF G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: library/itertools.rst:56
msgid ":func:`chain`"
msgstr ":func:`chain`"

#: library/itertools.rst:67
msgid "p, q, ..."
msgstr "p, q, ..."

#: library/itertools.rst:57
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

#: library/itertools.rst:56
#, fuzzy
msgid "``chain('ABC', 'DEF') → A B C D E F``"
msgstr "``chain('ABC', 'DEF') --> A B C D E F``"

#: library/itertools.rst:57
msgid ":func:`chain.from_iterable`"
msgstr ":func:`chain.from_iterable`"

#: library/itertools.rst:63
msgid "iterable"
msgstr "itérable"

#: library/itertools.rst:57
#, fuzzy
msgid "``chain.from_iterable(['ABC', 'DEF']) → A B C D E F``"
msgstr "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"

#: library/itertools.rst:58
msgid ":func:`compress`"
msgstr ":func:`compress`"

#: library/itertools.rst:58
msgid "data, selectors"
msgstr "data, selectors"

#: library/itertools.rst:58
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0] if s[0]), (d[1] if s[1]), ..."

#: library/itertools.rst:58
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) → A C E F``"
msgstr "``compress('ABCDEF', [1,0,1,0,1,1]) → A C E F``"

#: library/itertools.rst:59
msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

#: library/itertools.rst:60 library/itertools.rst:65
msgid "predicate, seq"
msgstr "``predicate, seq``"

#: library/itertools.rst:59
#, fuzzy
msgid "seq[n], seq[n+1], starting when predicate fails"
msgstr "``seq[n]``, ``seq[n+1]``, commençant quand *pred* échoue"

#: library/itertools.rst:59
#, fuzzy
msgid "``dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"

#: library/itertools.rst:60
msgid ":func:`filterfalse`"
msgstr ":func:`filterfalse`"

#: library/itertools.rst:60
#, fuzzy
msgid "elements of seq where predicate(elem) fails"
msgstr "éléments de *seq* pour lesquels *pred(elem)* est faux"

#: library/itertools.rst:60
#, fuzzy
msgid "``filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"

#: library/itertools.rst:61
msgid ":func:`groupby`"
msgstr ":func:`groupby`"

#: library/itertools.rst:61
msgid "iterable[, key]"
msgstr "iterable[, key]"

#: library/itertools.rst:61
msgid "sub-iterators grouped by value of key(v)"
msgstr "sous-itérateurs groupés par la valeur de *key(v)*"

#: library/itertools.rst:61
#, fuzzy
msgid "``groupby(['A','B','DEF'], len) → (1, A B) (3, DEF)``"
msgstr "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"

#: library/itertools.rst:62
msgid ":func:`islice`"
msgstr ":func:`islice`"

#: library/itertools.rst:62
msgid "seq, [start,] stop [, step]"
msgstr "seq, [start,] stop [, step]"

#: library/itertools.rst:62
msgid "elements from seq[start:stop:step]"
msgstr "éléments de ``seq[start:stop:step]``"

#: library/itertools.rst:62
#, fuzzy
msgid "``islice('ABCDEFG', 2, None) → C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: library/itertools.rst:63
msgid ":func:`pairwise`"
msgstr ":func:`pairwise`"

#: library/itertools.rst:63
msgid "(p[0], p[1]), (p[1], p[2])"
msgstr "(p[0], p[1]), (p[1], p[2])"

#: library/itertools.rst:63
#, fuzzy
msgid "``pairwise('ABCDEFG') → AB BC CD DE EF FG``"
msgstr "``pairwise('ABCDEFG') --> AB BC CD DE EF FG``"

#: library/itertools.rst:64
msgid ":func:`starmap`"
msgstr ":func:`starmap`"

#: library/itertools.rst:64
msgid "func, seq"
msgstr "func, seq"

#: library/itertools.rst:64
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

#: library/itertools.rst:64
#, fuzzy
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000``"
msgstr "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"

#: library/itertools.rst:65
msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

#: library/itertools.rst:65
#, fuzzy
msgid "seq[0], seq[1], until predicate fails"
msgstr "``seq[0]``, ``seq[1]``, jusqu'à ce que *pred* échoue"

#: library/itertools.rst:65
#, fuzzy
msgid "``takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"

#: library/itertools.rst:66
msgid ":func:`tee`"
msgstr ":func:`tee`"

#: library/itertools.rst:66
msgid "it, n"
msgstr "it, n"

#: library/itertools.rst:66
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "*it1*, *it2*, ... *itn* sépare un itérateur en *n*"

#: library/itertools.rst:67
msgid ":func:`zip_longest`"
msgstr ":func:`zip_longest`"

#: library/itertools.rst:67
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: library/itertools.rst:67
#, fuzzy
msgid "``zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-``"
msgstr "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"

#: library/itertools.rst:70
msgid "**Combinatoric iterators:**"
msgstr "**Itérateurs combinatoires :**"

#: library/itertools.rst:75
msgid ":func:`product`"
msgstr ":func:`product`"

#: library/itertools.rst:75
msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

#: library/itertools.rst:75
msgid "cartesian product, equivalent to a nested for-loop"
msgstr "produit cartésien, équivalent à une boucle *for* imbriquée"

#: library/itertools.rst:76
msgid ":func:`permutations`"
msgstr ":func:`permutations`"

#: library/itertools.rst:76
msgid "p[, r]"
msgstr "p[, r]"

#: library/itertools.rst:76
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr ""
"*n*-uplets de longueur r, tous les ré-arrangements possibles, sans "
"répétition d'éléments"

#: library/itertools.rst:77
msgid ":func:`combinations`"
msgstr ":func:`combinations`"

#: library/itertools.rst:78
msgid "p, r"
msgstr "p, r"

#: library/itertools.rst:77
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr "*n*-uplets de longueur r, ordonnés, sans répétition d'éléments"

#: library/itertools.rst:78
msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

#: library/itertools.rst:78
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr "*n*-uplets de longueur r, ordonnés, avec répétition d'éléments"

#: library/itertools.rst:82
msgid "Examples"
msgstr "Exemples"

#: library/itertools.rst:84
msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

#: library/itertools.rst:84
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

#: library/itertools.rst:85
msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

#: library/itertools.rst:85
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

#: library/itertools.rst:86
msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

#: library/itertools.rst:86
msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

#: library/itertools.rst:87
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

#: library/itertools.rst:87
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

#: library/itertools.rst:94
#, fuzzy
msgid "Itertool Functions"
msgstr "Fonctions d'*itertool*"

#: library/itertools.rst:96
#, fuzzy
msgid ""
"The following functions all construct and return iterators. Some provide "
"streams of infinite length, so they should only be accessed by functions or "
"loops that truncate the stream."
msgstr ""
"Toutes les fonctions du module qui suivent construisent et renvoient des "
"itérateurs. Certaines produisent des flux de longueur infinie ; celles-ci ne "
"doivent donc être contrôlées que par des fonctions ou boucles qui "
"interrompent le flux."

#: library/itertools.rst:103
#, fuzzy
msgid ""
"Make an iterator that returns accumulated sums or accumulated results from "
"other binary functions."
msgstr ""
"Crée un itérateur qui renvoie les sommes cumulées, ou les résultats cumulés "
"d'autres fonctions binaires (spécifiées par l'argument optionnel *func*)."

#: library/itertools.rst:106
msgid ""
"The *function* defaults to addition.  The *function* should accept two "
"arguments, an accumulated total and a value from the *iterable*."
msgstr ""

#: library/itertools.rst:109
#, fuzzy
msgid ""
"If an *initial* value is provided, the accumulation will start with that "
"value and the output will have one more element than the input iterable."
msgstr ""
"De manière générale, le nombre d'éléments produits par la sortie correspond "
"au nombre d'éléments de *'iterable* en entrée. Cependant, si le paramètre "
"nommé *initial* est fourni, l'accumulation conserve comme premier élément la "
"valeur de *initial* et donc la sortie compte un élément de plus que ce qui "
"est produit par l'entrée *iterable*."

#: library/itertools.rst:186 library/itertools.rst:288
#: library/itertools.rst:524 library/itertools.rst:637
#: library/itertools.rst:779
msgid "Roughly equivalent to::"
msgstr "À peu près équivalent à ::"

#: library/itertools.rst:134
#, fuzzy
msgid ""
"To compute a running minimum, set *function* to :func:`min`. For a running "
"maximum, set *function* to :func:`max`. Or for a running product, set "
"*function* to :func:`operator.mul`. To build an `amortization table <https://"
"www.ramseysolutions.com/real-estate/amortization-schedule>`_, accumulate the "
"interest and apply payments:"
msgstr ""
"Il y a de nombreuses utilisations à l'argument *func*. Celui-ci peut être :"
"func:`min` pour calculer un minimum glissant, :func:`max` pour un maximum "
"glissant ou :func:`operator.mul` pour un produit glissant. Des tableaux de "
"remboursements peuvent être construits en ajoutant les intérêts et en "
"soustrayant les paiements :"

#: library/itertools.rst:154
msgid ""
"See :func:`functools.reduce` for a similar function that returns only the "
"final accumulated value."
msgstr ""
"Voir :func:`functools.reduce` pour une fonction similaire qui ne renvoie que "
"la valeur accumulée finale."

#: library/itertools.rst:159
#, fuzzy
msgid "Added the optional *function* parameter."
msgstr "Ajout du paramètre optionnel *func*."

#: library/itertools.rst:162
msgid "Added the optional *initial* parameter."
msgstr "Ajout du paramètre optionnel *initial*."

#: library/itertools.rst:168
msgid ""
"Batch data from the *iterable* into tuples of length *n*. The last batch may "
"be shorter than *n*."
msgstr ""

#: library/itertools.rst:171
msgid ""
"If *strict* is true, will raise a :exc:`ValueError` if the final batch is "
"shorter than *n*."
msgstr ""

#: library/itertools.rst:174
msgid ""
"Loops over the input iterable and accumulates data into tuples up to size "
"*n*.  The input is consumed lazily, just enough to fill a batch. The result "
"is yielded as soon as the batch is full or when the input iterable is "
"exhausted:"
msgstr ""

#: library/itertools.rst:200
msgid "Added the *strict* option."
msgstr ""

#: library/itertools.rst:206
#, fuzzy
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  This combines multiple data sources into a single iterator.  "
"Roughly equivalent to::"
msgstr ""
"Crée un itérateur qui renvoie les éléments du premier itérable jusqu'à son "
"épuisement, puis continue avec l'itérable suivant jusqu'à ce que tous les "
"itérables soient épuisés. Utilisée pour traiter des séquences consécutives "
"comme une seule séquence. À peu près équivalent à ::"

#: library/itertools.rst:219
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Roughly equivalent to::"
msgstr ""
"Constructeur alternatif pour :func:`chain`. Récupère des entrées chaînées "
"depuis un unique itérable passé en argument, qui est évalué de manière "
"paresseuse. À peu près équivalent à ::"

#: library/itertools.rst:230
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr "Renvoie les combinaisons de longueur *r* de *iterable*."

#: library/itertools.rst:232
msgid ""
"The output is a subsequence of :func:`product` keeping only entries that are "
"subsequences of the *iterable*.  The length of the output is given by :func:"
"`math.comb` which computes ``n! / r! / (n - r)!`` when ``0 ≤ r ≤ n`` or zero "
"when ``r > n``."
msgstr ""

#: library/itertools.rst:237
#, fuzzy
msgid ""
"The combination tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. If the input *iterable* is sorted, the output "
"tuples will be produced in sorted order."
msgstr ""
"Les combinaisons sont produites dans l'ordre lexicographique dérivé de "
"l'ordre des éléments de *iterable*. Ainsi, si *iterable* est ordonné, les "
"*n*-uplets de combinaison produits le sont aussi."

#: library/itertools.rst:241
#, fuzzy
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"If the input elements are unique, there will be no repeated values within "
"each combination."
msgstr ""
"Les éléments sont considérés comme uniques en fonction de leur position, et "
"non pas de leur valeur. Ainsi, si les éléments en entrée sont uniques, il "
"n'y aura pas de valeurs répétées dans chaque combinaison."

#: library/itertools.rst:272
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr ""
"Renvoyer les sous-séquences de longueur *r* des éléments de l'itérable "
"*iterable* d'entrée, permettant aux éléments individuels d'être répétés plus "
"d'une fois."

#: library/itertools.rst:275
msgid ""
"The output is a subsequence of :func:`product` that keeps only entries that "
"are subsequences (with possible repeated elements) of the *iterable*.  The "
"number of subsequence returned is ``(n + r - 1)! / r! / (n - 1)!`` when ``n "
"> 0``."
msgstr ""

#: library/itertools.rst:280
#, fuzzy
msgid ""
"The combination tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. if the input *iterable* is sorted, the output "
"tuples will be produced in sorted order."
msgstr ""
"Les combinaisons sont produites dans l'ordre lexicographique dérivé de "
"l'ordre des éléments de *iterable*. Ainsi, si *iterable* est ordonné, les "
"*n*-uplets de combinaison produits le sont aussi."

#: library/itertools.rst:284
#, fuzzy
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"If the input elements are unique, the generated combinations will also be "
"unique."
msgstr ""
"Les éléments sont considérés comme uniques en fonction de leur position, et "
"non pas de leur valeur. Ainsi si les éléments d'entrée sont uniques, les "
"combinaisons générées seront aussi uniques."

#: library/itertools.rst:314
#, fuzzy
msgid ""
"Make an iterator that returns elements from *data* where the corresponding "
"element in *selectors* is true.  Stops when either the *data* or *selectors* "
"iterables have been exhausted.  Roughly equivalent to::"
msgstr ""
"Crée un itérateur qui filtre les éléments de *data*, en ne renvoyant que "
"ceux dont l'élément correspondant dans *selectors* s'évalue à ``True``. "
"S'arrête quand l'itérable *data* ou *selectors* a été épuisé. À peu près "
"équivalent à ::"

#: library/itertools.rst:328
#, fuzzy
msgid ""
"Make an iterator that returns evenly spaced values beginning with *start*. "
"Can be used with :func:`map` to generate consecutive data points or with :"
"func:`zip` to add sequence numbers.  Roughly equivalent to::"
msgstr ""
"Crée un itérateur qui renvoie des valeurs espacées régulièrement, en "
"commençant par le nombre *start*. Souvent utilisé comme un argument de :func:"
"`map` pour générer des points de données consécutifs. Aussi utilisé avec :"
"func:`zip` pour ajouter des nombres de séquence. À peu près équivalent à ::"

#: library/itertools.rst:341
#, fuzzy
msgid ""
"When counting with floating-point numbers, better accuracy can sometimes be "
"achieved by substituting multiplicative code such as: ``(start + step * i "
"for i in count())``."
msgstr ""
"Pour compter avec des nombres à virgule flottante, il est parfois préférable "
"d'utiliser le code : ``(start + step * i for i in count())`` pour obtenir "
"une meilleure précision."

#: library/itertools.rst:345
msgid "Added *step* argument and allowed non-integer arguments."
msgstr ""
"Ajout de l'argument *step* et ajout du support pour les arguments non-"
"entiers."

#: library/itertools.rst:351
#, fuzzy
msgid ""
"Make an iterator returning elements from the *iterable* and saving a copy of "
"each.  When the iterable is exhausted, return elements from the saved copy.  "
"Repeats indefinitely.  Roughly equivalent to::"
msgstr ""
"Crée un itérateur qui renvoie les éléments de l'itérable en en sauvegardant "
"une copie. Quand l'itérable est épuisé, renvoie les éléments depuis la "
"sauvegarde. Répète à l'infini. À peu près équivalent à ::"

#: library/itertools.rst:367
#, fuzzy
msgid ""
"This itertool may require significant auxiliary storage (depending on the "
"length of the iterable)."
msgstr ""
"Note, cette fonction peut avoir besoin d'un stockage auxiliaire important "
"(en fonction de la longueur de l'itérable)."

#: library/itertools.rst:373
#, fuzzy
msgid ""
"Make an iterator that drops elements from the *iterable* while the "
"*predicate* is true and afterwards returns every element.  Roughly "
"equivalent to::"
msgstr ""
"Crée un itérateur qui renvoie les éléments d'un itérable tant que le "
"prédicat est vrai. À peu près équivalent à ::"

#: library/itertools.rst:389
msgid ""
"Note this does not produce *any* output until the predicate first becomes "
"false, so this itertool may have a lengthy start-up time."
msgstr ""

#: library/itertools.rst:395
#, fuzzy
msgid ""
"Make an iterator that filters elements from the *iterable* returning only "
"those for which the *predicate* returns a false value.  If *predicate* is "
"``None``, returns the items that are false.  Roughly equivalent to::"
msgstr ""
"Crée un itérateur qui filtre les éléments de *iterable*, ne renvoyant "
"seulement ceux pour lesquels le prédicat est ``False``. Si *predicate* vaut "
"``None``, renvoie les éléments qui sont faux. À peu près équivalent à ::"

#: library/itertools.rst:413
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element.  "
"If not specified or is ``None``, *key* defaults to an identity function and "
"returns the element unchanged.  Generally, the iterable needs to already be "
"sorted on the same key function."
msgstr ""
"Crée un itérateur qui renvoie les clés et les groupes de l'itérable "
"*iterable*. La clé *key* est une fonction qui génère une clé pour chaque "
"élément. Si *key* n'est pas spécifiée ou est ``None``, elle vaut par défaut "
"une fonction d'identité qui renvoie l'élément sans le modifier. "
"Généralement, l'itérable a besoin d'avoir ses éléments déjà classés selon "
"cette même fonction de clé."

#: library/itertools.rst:419
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix.  "
"It generates a break or new group every time the value of the key function "
"changes (which is why it is usually necessary to have sorted the data using "
"the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ""
"L'opération de  :func:`groupby` est similaire au filtre ``uniq`` dans Unix. "
"Elle génère un nouveau groupe à chaque fois que la valeur de la fonction "
"*key* change (ce pourquoi il est souvent nécessaire d'avoir trié les données "
"selon la même fonction de clé).  Ce comportement est différent de celui de "
"GROUP BY de SQL qui agrège les éléments sans prendre compte de leur ordre "
"d'entrée."

#: library/itertools.rst:425
msgid ""
"The returned group is itself an iterator that shares the underlying iterable "
"with :func:`groupby`.  Because the source is shared, when the :func:"
"`groupby` object is advanced, the previous group is no longer visible.  So, "
"if that data is needed later, it should be stored as a list::"
msgstr ""
"Le groupe renvoyé est lui-même un itérateur qui partage l'itérable sous-"
"jacent avec :func:`groupby`. Puisque que la source est partagée, quand "
"l'objet :func:`groupby` est avancé, le groupe précédent n'est plus visible. "
"Ainsi, si cette donnée doit être utilisée plus tard, elle doit être stockée "
"comme une liste ::"

#: library/itertools.rst:437
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ":func:`groupby` est à peu près équivalente à ::"

#: library/itertools.rst:475
#, fuzzy
msgid ""
"Make an iterator that returns selected elements from the iterable. Works "
"like sequence slicing but does not support negative values for *start*, "
"*stop*, or *step*."
msgstr ""
"Crée un itérateur qui renvoie les éléments d'un itérable tant que le "
"prédicat est vrai. À peu près équivalent à ::"

#: library/itertools.rst:479
#, fuzzy
msgid ""
"If *start* is zero or ``None``, iteration starts at zero.  Otherwise, "
"elements from the iterable are skipped until *start* is reached."
msgstr ""
"Si *start* vaut ``None``, alors l'itération commence à zéro. Si *step* vaut "
"``None``, alors le pas est à 1 par défaut."

#: library/itertools.rst:482
msgid ""
"If *stop* is ``None``, iteration continues until the input is exhausted, if "
"at all.  Otherwise, it stops at the specified position."
msgstr ""

#: library/itertools.rst:485
msgid ""
"If *step* is ``None``, the step defaults to one.  Elements are returned "
"consecutively unless *step* is set higher than one which results in items "
"being skipped."
msgstr ""

#: library/itertools.rst:511
msgid ""
"If the input is an iterator, then fully consuming the *islice* advances the "
"input iterator by ``max(start, stop)`` steps regardless of the *step* value."
msgstr ""

#: library/itertools.rst:518
msgid "Return successive overlapping pairs taken from the input *iterable*."
msgstr "Renvoie des paires successives d'éléments consécutifs de *iterable*."

#: library/itertools.rst:520
msgid ""
"The number of 2-tuples in the output iterator will be one fewer than the "
"number of inputs.  It will be empty if the input iterable has fewer than two "
"values."
msgstr ""
"En toute logique, il y a une paire de moins que d'éléments dans l'itérable. "
"Aucune paire n'est renvoyée si l'itérable a zéro ou une valeur."

#: library/itertools.rst:541
#, fuzzy
msgid ""
"Return successive *r* length `permutations of elements <https://www."
"britannica.com/science/permutation>`_ from the *iterable*."
msgstr ""
"Renvoie les arrangements successifs de longueur *r* des éléments de "
"*iterable*."

#: library/itertools.rst:544
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr ""
"Si *r* n'est pas spécifié ou vaut ``None``, alors *r* a pour valeur la "
"longueur de *iterable* et toutes les permutations de longueur *r* possibles "
"sont générées."

#: library/itertools.rst:548
msgid ""
"The output is a subsequence of :func:`product` where entries with repeated "
"elements have been filtered out.  The length of the output is given by :func:"
"`math.perm` which computes ``n! / (n - r)!`` when ``0 ≤ r ≤ n`` or zero when "
"``r > n``."
msgstr ""

#: library/itertools.rst:553
#, fuzzy
msgid ""
"The permutation tuples are emitted in lexicographic order according to the "
"order of the input *iterable*.  If the input *iterable* is sorted, the "
"output tuples will be produced in sorted order."
msgstr ""
"Les combinaisons sont produites dans l'ordre lexicographique qui provient de "
"l'ordre des éléments de *iterable*. Ainsi, si *iterable* est ordonné, les "
"*n*-uplets de combinaison produits le sont aussi."

#: library/itertools.rst:557
#, fuzzy
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"If the input elements are unique, there will be no repeated values within a "
"permutation."
msgstr ""
"Les éléments sont considérés comme uniques en fonction de leur position, et "
"non pas de leur valeur. Ainsi, si l'élément est unique, il n'y aura pas de "
"valeurs répétées dans chaque permutation."

#: library/itertools.rst:594
msgid ""
"`Cartesian product <https://en.wikipedia.org/wiki/Cartesian_product>`_ of "
"the input iterables."
msgstr ""

#: library/itertools.rst:597
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y in "
"B)``."
msgstr ""
"À peu près équivalent à des boucles *for* imbriquées dans une expression de "
"générateur. Par exemple ``product(A, B)`` renvoie la même chose que ``((x, "
"y) for x in A for y in B)``."

#: library/itertools.rst:600
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing "
"on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr ""
"Les boucles imbriquées tournent comme un compteur kilométrique avec "
"l'élément le plus à droite avançant à chaque itération. Ce motif défini un "
"ordre lexicographique afin que, si les éléments des itérables en l'entrée "
"sont ordonnés, les *n*-uplets produits le sont aussi."

#: library/itertools.rst:605
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""
"Pour générer le produit d'un itérable avec lui-même, spécifiez le nombre de "
"répétitions avec le paramètre nommé optionnel *repeat*. Par exemple, "
"``product(A, repeat=4)`` est équivalent à ``product(A, A, A, A)``."

#: library/itertools.rst:609
msgid ""
"This function is roughly equivalent to the following code, except that the "
"actual implementation does not build up intermediate results in memory::"
msgstr ""
"Cette fonction est à peu près équivalente au code suivant, à la différence "
"près que la vraie implémentation ne crée pas de résultats intermédiaires en "
"mémoire ::"

#: library/itertools.rst:627
msgid ""
"Before :func:`product` runs, it completely consumes the input iterables, "
"keeping pools of values in memory to generate the products.  Accordingly, it "
"is only useful with finite inputs."
msgstr ""
":func:`product` commence par consommer totalement les itérables qui lui sont "
"passés et les conserve en mémoire pour générer les produits. Par conséquent, "
"cette fonction ne sert que sur des itérables finis."

#: library/itertools.rst:634
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified."
msgstr ""
"Crée un itérateur qui renvoie *object* à l'infini. S'exécute indéfiniment "
"sauf si l'argument *times* est spécifié."

#: library/itertools.rst:648
msgid ""
"A common use for *repeat* is to supply a stream of constant values to *map* "
"or *zip*:"
msgstr ""
"Une utilisation courante de *repeat* est de fournir un flux constant de "
"valeurs à *map* ou *zip* :"

#: library/itertools.rst:659
#, fuzzy
msgid ""
"Make an iterator that computes the *function* using arguments obtained from "
"the *iterable*.  Used instead of :func:`map` when argument parameters have "
"already been \"pre-zipped\" into tuples."
msgstr ""
"Crée un itérateur qui exécute la fonction avec les arguments obtenus depuis "
"l'itérable. Utilisée à la place de :func:`map` quand les arguments sont déjà "
"groupés en *n*-uplets depuis un seul itérable — la donnée a déjà été « pré-"
"zippée »."

#: library/itertools.rst:663
msgid ""
"The difference between :func:`map` and :func:`starmap` parallels the "
"distinction between ``function(a,b)`` and ``function(*c)``. Roughly "
"equivalent to::"
msgstr ""

#: library/itertools.rst:675
#, fuzzy
msgid ""
"Make an iterator that returns elements from the *iterable* as long as the "
"*predicate* is true.  Roughly equivalent to::"
msgstr ""
"Crée un itérateur qui renvoie les éléments d'un itérable tant que le "
"prédicat est vrai. À peu près équivalent à ::"

#: library/itertools.rst:685
msgid ""
"Note, the element that first fails the predicate condition is consumed from "
"the input iterator and there is no way to access it. This could be an issue "
"if an application wants to further consume the input iterator after "
"*takewhile* has been run to exhaustion.  To work around this problem, "
"consider using `more-iterools before_and_after() <https://more-itertools."
"readthedocs.io/en/stable/api.html#more_itertools.before_and_after>`_ instead."
msgstr ""

#: library/itertools.rst:696
msgid "Return *n* independent iterators from a single iterable."
msgstr "Renvoie *n* itérateurs indépendants depuis un unique itérable."

#: library/itertools.rst:733
msgid ""
"When the input *iterable* is already a tee iterator object, all members of "
"the return tuple are constructed as if they had been produced by the "
"upstream :func:`tee` call.  This \"flattening step\" allows nested :func:"
"`tee` calls to share the same underlying data chain and to have a single "
"update step rather than a chain of calls."
msgstr ""

#: library/itertools.rst:739
msgid "The flattening property makes tee iterators efficiently peekable:"
msgstr ""

#: library/itertools.rst:759
#, fuzzy
msgid ""
"``tee`` iterators are not threadsafe. A :exc:`RuntimeError` may be raised "
"when simultaneously using iterators returned by the same :func:`tee` call, "
"even if the original *iterable* is threadsafe."
msgstr ""
"Les itérateurs ``tee`` ne sont pas protégés contre les accès parallèles. "
"L'utilisation simultanée de plusieurs itérateurs renvoyés par le même appel "
"à :func:`tee` est susceptible de lever :exc:`RuntimeError`, même si "
"*iterable* fonctionne avec les accès parallèles."

#: library/itertools.rst:763
msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use :"
"func:`list` instead of :func:`tee`."
msgstr ""
"Cet outil peut avoir besoin d'un stockage auxiliaire important (en fonction "
"de la taille des données temporaires nécessaires). En général, si un "
"itérateur utilise la majorité ou toute la donnée avant qu'un autre itérateur "
"ne commence, il est plus rapide d'utiliser :func:`list` à la place de :func:"
"`tee`."

#: library/itertools.rst:771
#, fuzzy
msgid "Make an iterator that aggregates elements from each of the *iterables*."
msgstr ""
"Crée un itérateur qui renvoie les éléments d'un itérable tant que le "
"prédicat est vrai. À peu près équivalent à ::"

#: library/itertools.rst:774
msgid ""
"If the iterables are of uneven length, missing values are filled-in with "
"*fillvalue*.  If not specified, *fillvalue* defaults to ``None``."
msgstr ""

#: library/itertools.rst:777
msgid "Iteration continues until the longest iterable is exhausted."
msgstr ""

#: library/itertools.rst:803
#, fuzzy
msgid ""
"If one of the iterables is potentially infinite, then the :func:"
"`zip_longest` function should be wrapped with something that limits the "
"number of calls (for example :func:`islice` or :func:`takewhile`)."
msgstr ""
"Si un des itérables est potentiellement infini, alors la fonction :func:"
"`zip_longest` doit être encapsulée dans un code qui limite le nombre "
"d'appels (par exemple, :func:`islice` ou :func:`takewhile`). Si *fillvalue* "
"n'est pas spécifié, il vaut ``None`` par défaut."

#: library/itertools.rst:811
msgid "Itertools Recipes"
msgstr "Recettes *itertools*"

#: library/itertools.rst:813
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr ""
"Cette section présente des recettes pour créer une vaste boîte à outils en "
"se servant des *itertools* existants comme des briques."

#: library/itertools.rst:816
msgid ""
"The primary purpose of the itertools recipes is educational.  The recipes "
"show various ways of thinking about individual tools — for example, that "
"``chain.from_iterable`` is related to the concept of flattening.  The "
"recipes also give ideas about ways that the tools can be combined — for "
"example, how ``starmap()`` and ``repeat()`` can work together.  The recipes "
"also show patterns for using itertools with the :mod:`operator` and :mod:"
"`collections` modules as well as with the built-in itertools such as "
"``map()``, ``filter()``, ``reversed()``, and ``enumerate()``."
msgstr ""

#: library/itertools.rst:825
msgid ""
"A secondary purpose of the recipes is to serve as an incubator.  The "
"``accumulate()``, ``compress()``, and ``pairwise()`` itertools started out "
"as recipes.  Currently, the ``sliding_window()``, ``iter_index()``, and "
"``sieve()`` recipes are being tested to see whether they prove their worth."
msgstr ""

#: library/itertools.rst:830
#, fuzzy
msgid ""
"Substantially all of these recipes and many, many others can be installed "
"from the :pypi:`more-itertools` project found on the Python Package Index::"
msgstr ""
"Toutes ces recettes — et encore beaucoup d'autres — sont regroupées dans le "
"`projet more-itertools <https://pypi.org/project/more-itertools/>`_, "
"disponible dans le Python Package Index ::"

#: library/itertools.rst:836
#, fuzzy
msgid ""
"Many of the recipes offer the same high performance as the underlying "
"toolset. Superior memory performance is kept by processing elements one at a "
"time rather than bringing the whole iterable into memory all at once. Code "
"volume is kept small by linking the tools together in a `functional style "
"<https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf>`_.  High "
"speed is retained by preferring \"vectorized\" building blocks over the use "
"of for-loops and :term:`generators <generator>` which incur interpreter "
"overhead."
msgstr ""
"Ces outils dérivés offrent la même bonne performance que les outils sous-"
"jacents. La performance mémoire supérieure est gardée en traitant les "
"éléments un à la fois plutôt que de charger tout l'itérable en mémoire en "
"même temps. Le volume de code reste bas grâce à un chaînage de style "
"fonctionnel qui aide à éliminer les variables temporaires. La grande vitesse "
"est gardée en préférant les briques « vectorisées » plutôt que les boucles "
"*for* et les :term:`générateurs <generator>` qui engendrent un surcoût de "
"traitement."

#: library/itertools.rst:1008
msgid "The following recipes have a more mathematical flavor:"
msgstr ""

#~ msgid "Cartesian product of input iterables."
#~ msgstr "Produit cartésien des itérables d'entrée."

#~ msgid "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"
#~ msgstr "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"

#~ msgid ""
#~ "If *func* is supplied, it should be a function of two arguments. Elements "
#~ "of the input *iterable* may be any type that can be accepted as arguments "
#~ "to *func*. (For example, with the default operation of addition, elements "
#~ "may be any addable type including :class:`~decimal.Decimal` or :class:"
#~ "`~fractions.Fraction`.)"
#~ msgstr ""
#~ "Si *func* est renseigné, il doit être une fonction à deux arguments. Les "
#~ "éléments de *iterable* peuvent être de n'importe quel type acceptable "
#~ "comme arguments de *func*. Par exemple, avec l'opération par défaut "
#~ "d'addition, les éléments peuvent être de n'importe quel type "
#~ "additionnable, :class:`~decimal.Decimal` ou :class:`~fractions.Fraction` "
#~ "inclus."

#~ msgid ""
#~ "The code for :func:`combinations` can be also expressed as a subsequence "
#~ "of :func:`permutations` after filtering entries where the elements are "
#~ "not in sorted order (according to their position in the input pool)::"
#~ msgstr ""
#~ "Un appel à :func:`combinations` peut aussi être vu comme à un appel à :"
#~ "func:`permutations` en excluant les sorties dans lesquelles les éléments "
#~ "ne sont pas ordonnés (avec la même relation d'ordre que pour l'entrée) ::"

#~ msgid ""
#~ "The number of items returned is ``n! / r! / (n-r)!`` when ``0 <= r <= n`` "
#~ "or zero when ``r > n``."
#~ msgstr ""
#~ "Le nombre d'éléments renvoyés est ``n! / r! / (n-r)!`` quand ``0 <= r <= "
#~ "n`` ou zéro quand ``r > n``."

#~ msgid ""
#~ "The code for :func:`combinations_with_replacement` can be also expressed "
#~ "as a subsequence of :func:`product` after filtering entries where the "
#~ "elements are not in sorted order (according to their position in the "
#~ "input pool)::"
#~ msgstr ""
#~ "Un appel à :func:`combinations_with_replacement` peut aussi être vu comme "
#~ "un appel à :func:`product` en excluant les sorties dans lesquelles les "
#~ "éléments ne sont pas dans ordonnés (avec la même relation d'ordre que "
#~ "pour l'entrée) ::"

#~ msgid ""
#~ "The number of items returned is ``(n+r-1)! / r! / (n-1)!`` when ``n > 0``."
#~ msgstr ""
#~ "Le nombre d'éléments renvoyés est ``(n+r-1)! / r! / (n-1)!`` quand ``n > "
#~ "0``."

#~ msgid ""
#~ "Make an iterator that drops elements from the iterable as long as the "
#~ "predicate is true; afterwards, returns every element.  Note, the iterator "
#~ "does not produce *any* output until the predicate first becomes false, so "
#~ "it may have a lengthy start-up time.  Roughly equivalent to::"
#~ msgstr ""
#~ "Crée un itérateur qui saute les éléments de l'itérable tant que le "
#~ "prédicat est vrai ; renvoie ensuite chaque élément. Notez que l'itérateur "
#~ "ne produit *aucune* sortie avant que le prédicat ne devienne faux, il "
#~ "peut donc avoir un temps de démarrage long. À peu près équivalent à ::"

#~ msgid ""
#~ "Make an iterator that returns selected elements from the iterable. If "
#~ "*start* is non-zero, then elements from the iterable are skipped until "
#~ "start is reached. Afterward, elements are returned consecutively unless "
#~ "*step* is set higher than one which results in items being skipped.  If "
#~ "*stop* is ``None``, then iteration continues until the iterator is "
#~ "exhausted, if at all; otherwise, it stops at the specified position."
#~ msgstr ""
#~ "Crée un itérateur qui renvoie les élément sélectionnés de l'itérable. Si "
#~ "*start* est différent de zéro, alors les éléments de l'itérable sont "
#~ "ignorés jusqu'à ce que *start* soit atteint. Ensuite, les éléments sont "
#~ "renvoyés consécutivement sauf si *step* est plus grand que 1, auquel cas "
#~ "certains éléments seront ignorés. Si *stop* est ``None``, alors "
#~ "l'itération continue jusqu'à ce que l'itérateur soit épuisé s'il ne l'est "
#~ "pas déjà ; sinon, il s'arrête à la position spécifiée."

#~ msgid ""
#~ "The code for :func:`permutations` can be also expressed as a subsequence "
#~ "of :func:`product`, filtered to exclude entries with repeated elements "
#~ "(those from the same position in the input pool)::"
#~ msgstr ""
#~ "Un appel à :func:`permutations` peut aussi être vu un appel à :func:"
#~ "`product` en excluant les sorties avec des doublons (avec la même "
#~ "relation d'ordre que pour l'entrée) ::"

#~ msgid ""
#~ "The number of items returned is ``n! / (n-r)!`` when ``0 <= r <= n`` or "
#~ "zero when ``r > n``."
#~ msgstr ""
#~ "Le nombre d'éléments renvoyés est ``n! / (n-r)!`` quand ``0 <= r <= n`` "
#~ "ou zéro quand ``r > n``."

#~ msgid ""
#~ "The following Python code helps explain what *tee* does (although the "
#~ "actual implementation is more complex and uses only a single underlying :"
#~ "abbr:`FIFO (first-in, first-out)` queue)::"
#~ msgstr ""
#~ "Le code Python qui suit aide à expliquer ce que fait *tee*, bien que la "
#~ "vraie implémentation soit plus complexe et n'utilise qu'une file :abbr:"
#~ "`FIFO (premier entré, premier sorti ou *first-in, first-out* en "
#~ "anglais)` ::"

#~ msgid ""
#~ "Once a :func:`tee` has been created, the original *iterable* should not "
#~ "be used anywhere else; otherwise, the *iterable* could get advanced "
#~ "without the tee objects being informed."
#~ msgstr ""
#~ "Une fois qu’un :func:`tee` a été créé, l’original de *iterable* ne doit "
#~ "être utilisé nulle part ailleurs ; sinon *iterable* pourrait être avancé "
#~ "sans que les objets *tee* n’en soient informés."

#~ msgid ""
#~ "Make an iterator that aggregates elements from each of the iterables. If "
#~ "the iterables are of uneven length, missing values are filled-in with "
#~ "*fillvalue*. Iteration continues until the longest iterable is "
#~ "exhausted.  Roughly equivalent to::"
#~ msgstr ""
#~ "Crée un itérateur qui agrège les éléments de chacun des itérables. Si les "
#~ "itérables sont de longueurs différentes, les valeurs manquantes sont "
#~ "remplacées par *fillvalue*. L'itération continue jusqu'à ce que "
#~ "l'itérable le plus long soit épuisé. À peu près équivalent à ::"
