# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-29 16:06+0100\n"
"PO-Revision-Date: 2018-11-26 07:52+0100\n"
"Last-Translator: Julien VITARD <julienvitard@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.8.11\n"

#: ../Doc/library/hashlib.rst:2
msgid ":mod:`hashlib` --- Secure hashes and message digests"
msgstr ":mod:`hashlib` --- Algorithmes de hachage sécurisés et synthèse de messages"

#: ../Doc/library/hashlib.rst:10
msgid "**Source code:** :source:`Lib/hashlib.py`"
msgstr "**Code source :** :source:`Lib/hashlib.py`"

#: ../Doc/library/hashlib.rst:23
msgid ""
"This module implements a common interface to many different secure hash and message "
"digest algorithms.  Included are the FIPS secure hash algorithms SHA1, SHA224, SHA256, "
"SHA384, and SHA512 (defined in FIPS 180-2) as well as RSA's MD5 algorithm (defined in "
"Internet :rfc:`1321`).  The terms \"secure hash\" and \"message digest\" are "
"interchangeable.  Older algorithms were called message digests.  The modern term is "
"secure hash."
msgstr ""
"Ce module implémente une interface commune à différents algorithmes de hachage "
"sécurisés et de synthèse de messages. Sont inclus les algorithmes standards FIPS de "
"hachage SHA1, SHA224, SHA256, SHA384, et SHA512 (définis dans FIPS 180-2) ainsi que "
"l'algorithme MD5 de RSA (défini par la :rfc:`1321`). Les termes \"algorithmes de "
"hachage sécurisé\" et \"algorithme de synthèse de message\" sont interchangeables. Les "
"anciens algorithmes étaient appelés\" algorithmes de synthèse de messages\". Le terme "
"moderne est \"algorithme de hachage sécurisé\"."

#: ../Doc/library/hashlib.rst:32
msgid ""
"If you want the adler32 or crc32 hash functions, they are available in the :mod:`zlib` "
"module."
msgstr ""
"Si vous préférez utiliser les fonctions de hachage adler32 ou crc32, elles sont "
"disponibles dans le module :mod:`zlib`."

#: ../Doc/library/hashlib.rst:37
msgid ""
"Some algorithms have known hash collision weaknesses, refer to the \"See also\" section "
"at the end."
msgstr ""
"Certains algorithmes ont des faiblesses quant à la collision de hashs, se référer à la "
"section \"Voir aussi\" à la fin."

#: ../Doc/library/hashlib.rst:44
msgid "Hash algorithms"
msgstr "Algorithmes de hachage"

#: ../Doc/library/hashlib.rst:46
msgid ""
"There is one constructor method named for each type of :dfn:`hash`.  All return a hash "
"object with the same simple interface. For example: use :func:`sha256` to create a "
"SHA-256 hash object. You can now feed this object with :term:`bytes-like objects <bytes-"
"like object>` (normally :class:`bytes`) using the :meth:`update` method. At any point "
"you can ask it for the :dfn:`digest` of the concatenation of the data fed to it so far "
"using the :meth:`digest` or :meth:`hexdigest` methods."
msgstr ""
"Il y a un constructeur nommé selon chaque type de :dfn:`hash`. Tous retournent un objet "
"haché avec la même interface. Par exemple : utilisez :func:`sha256` pour créer un objet "
"haché de type SHA-256. Vous pouvez maintenant utilisez cet objet :term:`bytes-like "
"objects <bytes-like object>` (normalement des :class:`bytes`) en utilisant la méthode :"
"meth:`update`. À tout moment vous pouvez demander le :dfn:`digest` de la concaténation "
"des données fournies en utilisant les méthodes :meth:`digest` ou :meth:`hexdigest`."

#: ../Doc/library/hashlib.rst:56
msgid ""
"For better multithreading performance, the Python :term:`GIL` is released for data "
"larger than 2047 bytes at object creation or on update."
msgstr ""
"Pour de meilleures performances avec de multiples fils d'exécution, le :term:`GIL` "
"Python est relâché pour des données dont la taille est supérieure à 2047 octets lors de "
"leur création ou leur mise à jour."

#: ../Doc/library/hashlib.rst:61
msgid ""
"Feeding string objects into :meth:`update` is not supported, as hashes work on bytes, "
"not on characters."
msgstr ""
"Fournir des objets chaînes de caractères à la méthode :meth:`update` n'est pas "
"implémenté, comme les fonctions de hachages travaillent sur des *bytes* et pas sur des "
"caractères."

#: ../Doc/library/hashlib.rst:66
msgid ""
"Constructors for hash algorithms that are always present in this module are :func:"
"`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:`sha512`, :func:"
"`blake2b`, and :func:`blake2s`. :func:`md5` is normally available as well, though it "
"may be missing if you are using a rare \"FIPS compliant\" build of Python. Additional "
"algorithms may also be available depending upon the OpenSSL library that Python uses on "
"your platform. On most platforms the :func:`sha3_224`, :func:`sha3_256`, :func:"
"`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256` are also available."
msgstr ""
"Les constructeurs pour les algorithmes de hachage qui sont toujours présents dans ce "
"module sont :func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:"
"`sha512`, :func:`blake2b`, et :func:`blake2s`. :func:`md5` est normalement disponible "
"aussi, mais il peut être manquant si vous utilisez une forme rare de Python \"conforme "
"FIPS\" . Des algorithmes additionnels peuvent aussi être disponibles dépendant de la "
"librairie OpenSSL que Python utilise sur votre plate-forme. Sur la plupart des plates-"
"formes les fonctions :func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, :func:"
"`sha3_512`, :func:`shake_128`, :func:`shake_256` sont aussi disponibles."

#: ../Doc/library/hashlib.rst:76
msgid ""
"SHA3 (Keccak) and SHAKE constructors :func:`sha3_224`, :func:`sha3_256`, :func:"
"`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256`."
msgstr ""
"Les constructeurs SHA3 (Keccak) et SHAKE :func:`sha3_224`, :func:`sha3_256`, :func:"
"`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256`."

#: ../Doc/library/hashlib.rst:80
msgid ":func:`blake2b` and :func:`blake2s` were added."
msgstr "Les fonctions :func:`blake2b` et :func:`blake2s` ont été ajoutées."

#: ../Doc/library/hashlib.rst:83
msgid ""
"For example, to obtain the digest of the byte string ``b'Nobody inspects the spammish "
"repetition'``::"
msgstr ""
"Par exemple, pour obtenir l'empreinte de la chaîne ``b'Nobody inspects the spammish "
"repetition'`` : ::"

#: ../Doc/library/hashlib.rst:97
msgid "More condensed:"
msgstr "En plus condensé : ::"

#: ../Doc/library/hashlib.rst:104
msgid ""
"Is a generic constructor that takes the string *name* of the desired algorithm as its "
"first parameter.  It also exists to allow access to the above listed hashes as well as "
"any other algorithms that your OpenSSL library may offer.  The named constructors are "
"much faster than :func:`new` and should be preferred."
msgstr ""
"Est un constructeur générique qui prend comme premier paramètre le nom de l'algorithme "
"désiré (*name*) . Il existe pour permettre l'accès aux algorithmes listés ci-dessus "
"ainsi qu'aux autres algorithmes que votre librairie OpenSSL peut offrir. Les "
"constructeurs nommés sont beaucoup plus rapides que :func:`new` et doivent être "
"privilégiés."

#: ../Doc/library/hashlib.rst:110
msgid "Using :func:`new` with an algorithm provided by OpenSSL:"
msgstr "En utilisant :func:`new` avec un algorithme fourni par OpenSSL : ::"

#: ../Doc/library/hashlib.rst:117
msgid "Hashlib provides the following constant attributes:"
msgstr "Hashlib fournit les constantes suivantes : ::"

#: ../Doc/library/hashlib.rst:121
msgid ""
"A set containing the names of the hash algorithms guaranteed to be supported by this "
"module on all platforms.  Note that 'md5' is in this list despite some upstream vendors "
"offering an odd \"FIPS compliant\" Python build that excludes it."
msgstr ""
"Un ensemble contenant les noms des algorithmes de hachage garantis d'être implémentés "
"par ce module sur toutes les plate-formes. Notez que \"md5\" est dans cette liste "
"malgré certains éditeurs qui offrent une implémentation Python de la librairie "
"compatible FIPS l'excluant."

#: ../Doc/library/hashlib.rst:130
msgid ""
"A set containing the names of the hash algorithms that are available in the running "
"Python interpreter.  These names will be recognized when passed to :func:`new`.  :attr:"
"`algorithms_guaranteed` will always be a subset.  The same algorithm may appear "
"multiple times in this set under different names (thanks to OpenSSL)."
msgstr ""
"Un ensemble contenant les noms des algorithmes de hachage disponibles dans "
"l'interpréteur Python. Ces noms sont reconnus lorsqu'ils sont passés à la fonction :"
"func:`new`.  :attr:`algorithms_guaranteed` est toujours un sous-ensemble. Le même "
"algorithme peut apparaître plusieurs fois dans cet ensemble sous un nom différent "
"(grâce à OpenSSL)."

#: ../Doc/library/hashlib.rst:138
msgid ""
"The following values are provided as constant attributes of the hash objects returned "
"by the constructors:"
msgstr ""
"Les valeurs suivantes sont fournis en tant qu'attributs constants des objets hachés "
"retournés par les constructeurs : ::"

#: ../Doc/library/hashlib.rst:144
msgid "The size of the resulting hash in bytes."
msgstr "La taille du *hash* résultant en octets"

#: ../Doc/library/hashlib.rst:148
msgid "The internal block size of the hash algorithm in bytes."
msgstr "La taille interne d'un bloc de l'algorithme de hachage en octets."

#: ../Doc/library/hashlib.rst:150
msgid "A hash object has the following attributes:"
msgstr "L'objet haché possède les attributs suivants : ::"

#: ../Doc/library/hashlib.rst:154
msgid ""
"The canonical name of this hash, always lowercase and always suitable as a parameter "
"to :func:`new` to create another hash of this type."
msgstr ""
"Le nom canonique de cet objet haché, toujours en minuscule et toujours transmissible à "
"la fonction :func:`new` pour créer un autre objet haché de ce type."

#: ../Doc/library/hashlib.rst:157
msgid ""
"The name attribute has been present in CPython since its inception, but until Python "
"3.4 was not formally specified, so may not exist on some platforms."
msgstr ""
"L'attribut *name* est présent dans CPython depuis sa création, mais n'était pas "
"spécifié formellement jusqu'à Python 3.4, il peut ne pas exister sur certaines plate-"
"formes."

#: ../Doc/library/hashlib.rst:162
msgid "A hash object has the following methods:"
msgstr "L'objet haché possède les méthodes suivantes : ::"

#: ../Doc/library/hashlib.rst:167
msgid ""
"Update the hash object with the :term:`bytes-like object`. Repeated calls are "
"equivalent to a single call with the concatenation of all the arguments: ``m.update(a); "
"m.update(b)`` is equivalent to ``m.update(a+b)``."
msgstr ""
"Met à jour l'objet haché avec :term:`bytes-like object`. Les appels répétés sont "
"équivalent à la concaténation de tous les arguments : ``m.update(a); m.update(b)`` est "
"équivalent à ``m.update(a+b)``."

#: ../Doc/library/hashlib.rst:172
msgid ""
"The Python GIL is released to allow other threads to run while hash updates on data "
"larger than 2047 bytes is taking place when using hash algorithms supplied by OpenSSL."
msgstr ""
"Le GIL Python est relâché pour permettre aux autres *threads* de tourner pendant que la "
"fonction de hachage met à jour des données plus larges que 2047 octets, lorsque les "
"algorithmes fournis par OpenSSL sont utilisés."

#: ../Doc/library/hashlib.rst:180
msgid ""
"Return the digest of the data passed to the :meth:`update` method so far. This is a "
"bytes object of size :attr:`digest_size` which may contain bytes in the whole range "
"from 0 to 255."
msgstr ""
"Renvoie le *digest* des données passées à la méthode :meth:`update`. C'est un objet de "
"type *bytes* de taille :attr:`digest_size` qui contient des *bytes* dans l'intervalle 0 "
"à 255."

#: ../Doc/library/hashlib.rst:187 ../Doc/library/hashlib.rst:215
msgid ""
"Like :meth:`digest` except the digest is returned as a string object of double length, "
"containing only hexadecimal digits.  This may be used to exchange the value safely in "
"email or other non-binary environments."
msgstr ""
"Comme la méthode :meth:`digest` sauf que le *digest* renvoyé est une chaîne de "
"caractères de longueur double, contenant seulement des chiffres hexadécimaux. Cela peut "
"être utilisé pour échanger sans risque des valeurs dans les *e-mails* ou dans les "
"environnements non binaires."

#: ../Doc/library/hashlib.rst:194
msgid ""
"Return a copy (\"clone\") of the hash object.  This can be used to efficiently compute "
"the digests of data sharing a common initial substring."
msgstr ""
"Renvoie une copie (\"clone\") de l'objet haché. Cela peut être utilisé pour calculer "
"efficacement les *digests* de données partageant des sous-chaînes communes."

#: ../Doc/library/hashlib.rst:199
msgid "SHAKE variable length digests"
msgstr "Synthèse de messages de taille variable SHAKE"

#: ../Doc/library/hashlib.rst:201
msgid ""
"The :func:`shake_128` and :func:`shake_256` algorithms provide variable length digests "
"with length_in_bits//2 up to 128 or 256 bits of security. As such, their digest methods "
"require a length. Maximum length is not limited by the SHAKE algorithm."
msgstr ""
"Les algorithmes :func:`shake_128` et :func:`shake_256` fournissent des messages de "
"longueur variable avec des longueurs_en_bits//2 jusqu'à 128 ou 256 bits de sécurité. "
"Leurs méthodes *digests* requièrent une longueur. Les longueurs maximales ne sont pas "
"limitées par l'algorithme SHAKE."

#: ../Doc/library/hashlib.rst:208
msgid ""
"Return the digest of the data passed to the :meth:`update` method so far. This is a "
"bytes object of size *length* which may contain bytes in the whole range from 0 to 255."
msgstr ""
"Renvoie le *digest* des données passées à la méthode :meth:`update`. C'est un objet de "
"type *bytes* de taille *length*qui contient des *bytes* dans l'intervalle 0 à 255."

#: ../Doc/library/hashlib.rst:221
msgid "Key derivation"
msgstr "Dérivation de clé"

#: ../Doc/library/hashlib.rst:223
msgid ""
"Key derivation and key stretching algorithms are designed for secure password hashing. "
"Naive algorithms such as ``sha1(password)`` are not resistant against brute-force "
"attacks. A good password hashing function must be tunable, slow, and include a `salt "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_."
msgstr ""
"Les algorithmes de dérivation de clés et d'étirement de clés sont conçus pour le "
"hachage sécurisé de mots de passe. Des algorithmes naïfs comme ``sha1(password)`` ne "
"sont pas résistants aux attaques par force brute. Une bonne fonction de hachage doit "
"être paramétrable, lente, et inclure un `sel <https://en.wikipedia.org/wiki/Salt_"
"%28cryptography%29>`_."

#: ../Doc/library/hashlib.rst:231
msgid ""
"The function provides PKCS#5 password-based key derivation function 2. It uses HMAC as "
"pseudorandom function."
msgstr ""
"La fonction fournit une fonction de dérivation PKCS#5 (Public Key Cryptographic "
"Standards #5 v2.0). Elle utilise HMAC comme fonction de pseudo-aléatoire."

#: ../Doc/library/hashlib.rst:234
msgid ""
"The string *hash_name* is the desired name of the hash digest algorithm for HMAC, e.g. "
"'sha1' or 'sha256'. *password* and *salt* are interpreted as buffers of bytes. "
"Applications and libraries should limit *password* to a sensible length (e.g. 1024). "
"*salt* should be about 16 or more bytes from a proper source, e.g. :func:`os.urandom`."
msgstr ""
"La chaîne de caractères *hash_name* est le nom de l'algorithme de hachage désiré pour "
"le HMAC, e.g. 'sha1' ou 'sha256'. *password* et *salt* sont interprétés comme des "
"tampons d'octets. Les applications et bibliothèques doivent limiter *password* à une "
"longueur raisonnable (e.g. 1024). *salt* doit être de 16 octets ou plus provenant d'une "
"source correcte, e.g. :func:`os.urandom`."

#: ../Doc/library/hashlib.rst:240
msgid ""
"The number of *iterations* should be chosen based on the hash algorithm and computing "
"power. As of 2013, at least 100,000 iterations of SHA-256 are suggested."
msgstr ""
"Le nombre d'*iterations* doit être choisi sur la base de l'algorithme de hachage et de "
"la puissance de calcul. En 2013, au moins 100000 itérations de SHA-256 sont "
"recommandées."

#: ../Doc/library/hashlib.rst:244
msgid ""
"*dklen* is the length of the derived key. If *dklen* is ``None`` then the digest size "
"of the hash algorithm *hash_name* is used, e.g. 64 for SHA-512."
msgstr ""
"*dklen* est la longueur de la clé dérivée. Si *dklen* vaut ``None`` alors la taille du "
"message de l'algorithme de hachage *hash_name* est utilisé, e.g. 64 pour SHA-512."

#: ../Doc/library/hashlib.rst:256
msgid ""
"A fast implementation of *pbkdf2_hmac* is available with OpenSSL.  The Python "
"implementation uses an inline version of :mod:`hmac`. It is about three times slower "
"and doesn't release the GIL."
msgstr ""
"Une implémentation rapide de *pbkdf2_hmac* est disponible avec OpenSSL. "
"L'implémentation Python utilise une version anonyme de :mod:`hmac`. Elle est trois fois "
"plus lente et ne libère pas le GIL."

#: ../Doc/library/hashlib.rst:262
msgid ""
"The function provides scrypt password-based key derivation function as defined in :rfc:"
"`7914`."
msgstr ""
"La fonction fournit la fonction de dérivation de clé scrypt comme définie dans :rfc:"
"`7914`."

#: ../Doc/library/hashlib.rst:265
msgid ""
"*password* and *salt* must be :term:`bytes-like objects <bytes-like object>`.  "
"Applications and libraries should limit *password* to a sensible length (e.g. 1024).  "
"*salt* should be about 16 or more bytes from a proper source, e.g. :func:`os.urandom`."
msgstr ""
"*password* et *salt* doivent être des :term:`bytes-like objects <bytes-like object>`. "
"Les applications et bibliothèques doivent limiter *password* à une longueur raisonnable "
"(e.g. 1024). *salt* doit être de 16 octets ou plus provenant d'une source correcte, e."
"g. :func:`os.urandom`."

#: ../Doc/library/hashlib.rst:270
msgid ""
"*n* is the CPU/Memory cost factor, *r* the block size, *p* parallelization factor and "
"*maxmem* limits memory (OpenSSL 1.1.0 defaults to 32 MiB). *dklen* is the length of the "
"derived key."
msgstr ""
"*n* est le facteur de coût CPU/Mémoire, *r* la taille de bloc, *p* le facteur de "
"parallélisation et *maxmem* limite la mémoire (OpenSSL 1.1.0 limite à 32 MB par "
"défaut). *dklen* est la longueur de la clé dérivée."

#: ../Doc/library/hashlib.rst:275
msgid ":ref:`Availability <availability>`: OpenSSL 1.1+."
msgstr ":ref:`Disponibilité <availability>` : OpenSSL 1.1+."

#: ../Doc/library/hashlib.rst:280
msgid "BLAKE2"
msgstr ""

#: ../Doc/library/hashlib.rst:287
msgid ""
"BLAKE2_ is a cryptographic hash function defined in :rfc:`7693` that comes in two "
"flavors:"
msgstr ""
"BLAKE2_ est une fonction de hachage cryptographique définie dans la :rfc:`7693` et "
"disponible en deux versions : ::"

#: ../Doc/library/hashlib.rst:290
msgid ""
"**BLAKE2b**, optimized for 64-bit platforms and produces digests of any size between 1 "
"and 64 bytes,"
msgstr ""
"**BLAKE2b**, optimisée pour les plate-forme 64-bit et produisant des messages de toutes "
"tailles entre 1 et 64 bytes,"

#: ../Doc/library/hashlib.rst:293
msgid ""
"**BLAKE2s**, optimized for 8- to 32-bit platforms and produces digests of any size "
"between 1 and 32 bytes."
msgstr ""
"**BLAKE2b**, optimisée pour les plates-formes de 8 à 32-bit et produisant des messages "
"de toutes tailles entre 1 et 32 bytes."

#: ../Doc/library/hashlib.rst:296
msgid ""
"BLAKE2 supports **keyed mode** (a faster and simpler replacement for HMAC_), **salted "
"hashing**, **personalization**, and **tree hashing**."
msgstr ""
"BLAKE2 supporte diverses fonctionnalités **keyed mode** (un remplacement plus rapide et "
"plus simple pour HMAC_), **salted hashing**, **personalization**, et **tree hashing**."

#: ../Doc/library/hashlib.rst:299
msgid ""
"Hash objects from this module follow the API of standard library's :mod:`hashlib` "
"objects."
msgstr ""
"Les objets hachés de ce module suivent l'API des objets du module :mod:`hashlib` de la "
"librairie standard."

#: ../Doc/library/hashlib.rst:304
msgid "Creating hash objects"
msgstr "Création d'objets hachés"

#: ../Doc/library/hashlib.rst:306
msgid "New hash objects are created by calling constructor functions:"
msgstr "Les nouveaux objets hachés sont créés en appelant les constructeurs : ::"

#: ../Doc/library/hashlib.rst:318
msgid ""
"These functions return the corresponding hash objects for calculating BLAKE2b or "
"BLAKE2s. They optionally take these general parameters:"
msgstr ""
"Ces fonctions produisent l'objet haché correspondant aux calculs de BLAKE2b ou BLAKE2s. "
"Elles prennent ces paramètres optionnels : ::"

#: ../Doc/library/hashlib.rst:321
msgid ""
"*data*: initial chunk of data to hash, which must be :term:`bytes-like object`.  It can "
"be passed only as positional argument."
msgstr ""
"*data*: morceau initial de données à hacher, qui doit être un objet de type :term:"
"`bytes-like object`. Il peut être passé comme argument positionnel."

#: ../Doc/library/hashlib.rst:324
msgid "*digest_size*: size of output digest in bytes."
msgstr "*digest_size*: taille en sortie du message en octets."

#: ../Doc/library/hashlib.rst:326
msgid ""
"*key*: key for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes for BLAKE2s)."
msgstr ""
"*key*: clé pour les code d'authentification de message *keyed hashing* (jusqu'à 64 "
"octets pour BLAKE2b, jusqu'à 32 octets pour BLAKE2s)."

#: ../Doc/library/hashlib.rst:329
msgid ""
"*salt*: salt for randomized hashing (up to 16 bytes for BLAKE2b, up to 8 bytes for "
"BLAKE2s)."
msgstr ""
"*salt*: sel pour le hachage randomisé *randomized hashing* (jusqu'à 16 octets pour "
"BLAKE2b, jusqu'à 8 octets pour BLAKE2s). "

#: ../Doc/library/hashlib.rst:332
msgid ""
"*person*: personalization string (up to 16 bytes for BLAKE2b, up to 8 bytes for "
"BLAKE2s)."
msgstr ""
"*person*: chaîne de personnalisation (jusqu'à 16 octets pour BLAKE2b, jusqu'à 8 octets "
"pour BLAKE2s)."

#: ../Doc/library/hashlib.rst:335
msgid "The following table shows limits for general parameters (in bytes):"
msgstr "Le tableau suivant présente les limites des paramètres généraux (en octets) : ::"

#: ../Doc/library/hashlib.rst:338
msgid "Hash"
msgstr ""

#: ../Doc/library/hashlib.rst:338
msgid "digest_size"
msgstr ""

#: ../Doc/library/hashlib.rst:338
msgid "len(key)"
msgstr ""

#: ../Doc/library/hashlib.rst:338
msgid "len(salt)"
msgstr ""

#: ../Doc/library/hashlib.rst:338
msgid "len(person)"
msgstr ""

#: ../Doc/library/hashlib.rst:340
msgid "BLAKE2b"
msgstr ""

#: ../Doc/library/hashlib.rst:340
msgid "64"
msgstr ""

#: ../Doc/library/hashlib.rst:340
msgid "16"
msgstr ""

#: ../Doc/library/hashlib.rst:341
msgid "BLAKE2s"
msgstr ""

#: ../Doc/library/hashlib.rst:341
msgid "32"
msgstr ""

#: ../Doc/library/hashlib.rst:341
msgid "8"
msgstr "8"

#: ../Doc/library/hashlib.rst:346
msgid ""
"BLAKE2 specification defines constant lengths for salt and personalization parameters, "
"however, for convenience, this implementation accepts byte strings of any size up to "
"the specified length. If the length of the parameter is less than specified, it is "
"padded with zeros, thus, for example, ``b'salt'`` and ``b'salt\\x00'`` is the same "
"value. (This is not the case for *key*.)"
msgstr ""
"Les spécifications de BLAKE2 définissent des longueurs constantes pour les sel et "
"chaînes de personnalisation, toutefois, par commodité, cette implémentation accepte des "
"chaînes *byte* de n'importe quelle taille jusqu'à la longueur spécifiée. Si la longueur "
"du paramètre est moindre par rapport à celle spécifiée, il est complété par des zéros, "
"ainsi, par exemple, ``b'salt'`` et ``b'salt\\x00'`` sont la même valeur (Ce n'est pas "
"le cas pour *key*.)"

#: ../Doc/library/hashlib.rst:353
msgid "These sizes are available as module `constants`_ described below."
msgstr "Ces tailles sont disponibles comme `constants`_ du module et décrites ci-dessous."

#: ../Doc/library/hashlib.rst:355
msgid "Constructor functions also accept the following tree hashing parameters:"
msgstr ""
"Les fonctions constructeur acceptent aussi les paramètres suivants pour le *tree "
"hashing* : ::"

#: ../Doc/library/hashlib.rst:357
msgid "*fanout*: fanout (0 to 255, 0 if unlimited, 1 in sequential mode)."
msgstr "*fanout*: fanout (0 à 255, 0 si illimité, 1 en mode séquentiel)."

#: ../Doc/library/hashlib.rst:359
msgid "*depth*: maximal depth of tree (1 to 255, 255 if unlimited, 1 in sequential mode)."
msgstr ""
"*depth*: profondeur maximale de l'arbre (1 à 255, 255 si illimité, 1 en mode "
"séquentiel)."

#: ../Doc/library/hashlib.rst:362
msgid ""
"*leaf_size*: maximal byte length of leaf (0 to 2**32-1, 0 if unlimited or in sequential "
"mode)."
msgstr ""
"*leaf_size*: taille maximale en byte d'une feuille (0 à 2**32-1, 0 si illimité ou en "
"mode séquentiel)."

#: ../Doc/library/hashlib.rst:365
msgid ""
"*node_offset*: node offset (0 to 2**64-1 for BLAKE2b, 0 to 2**48-1 for BLAKE2s, 0 for "
"the first, leftmost, leaf, or in sequential mode)."
msgstr ""
"*node_offset*: décalage de nœud (0 à 2**64-1 pour BLAKE2b, 0 à 2**48-1 pour BLAKE2s, 0 "
"pour la première feuille la plus à gauche, ou en mode séquentiel)."

#: ../Doc/library/hashlib.rst:368
msgid "*node_depth*: node depth (0 to 255, 0 for leaves, or in sequential mode)."
msgstr ""
"*node_depth*: profondeur de nœuds (0 à 255, 0 pour les feuilles, ou en mode séquentiel)."

#: ../Doc/library/hashlib.rst:370
msgid ""
"*inner_size*: inner digest size (0 to 64 for BLAKE2b, 0 to 32 for BLAKE2s, 0 in "
"sequential mode)."
msgstr ""
"*inner_size*: taille interne du message (0 à 64 pour BLAKE2b, 0 à 32 pour BLAKE2s, 0 en "
"mode séquentiel)."

#: ../Doc/library/hashlib.rst:373
msgid ""
"*last_node*: boolean indicating whether the processed node is the last one (`False` for "
"sequential mode)."
msgstr ""
"*last_node*: booléen indiquant si le nœud traité est le dernier (`False` pour le mode "
"séquentiel)."

#: ../Doc/library/hashlib.rst:379
msgid ""
"See section 2.10 in `BLAKE2 specification <https://blake2.net/blake2_20130129.pdf>`_ "
"for comprehensive review of tree hashing."
msgstr ""
"Voir section 2.10 dans `BLAKE2 specification <https://blake2.net/blake2_20130129.pdf>`_ "
"pour une approche compréhensive du *tree hashing*."

#: ../Doc/library/hashlib.rst:385
msgid "Constants"
msgstr "Constantes"

#: ../Doc/library/hashlib.rst:390
msgid "Salt length (maximum length accepted by constructors)."
msgstr "Longueur du sel (longueur maximale acceptée par les constructeurs)."

#: ../Doc/library/hashlib.rst:396
msgid "Personalization string length (maximum length accepted by constructors)."
msgstr ""
"Longueur de la chaîne de personnalisation (longueur maximale acceptée par les "
"constructeurs)."

#: ../Doc/library/hashlib.rst:402
msgid "Maximum key size."
msgstr "Taille maximale de clé."

#: ../Doc/library/hashlib.rst:408
msgid "Maximum digest size that the hash function can output."
msgstr "Taille maximale du message que peut fournir la fonction de hachage."

#: ../Doc/library/hashlib.rst:412
msgid "Examples"
msgstr "Exemples"

#: ../Doc/library/hashlib.rst:415
msgid "Simple hashing"
msgstr "Hachage simple"

#: ../Doc/library/hashlib.rst:417
msgid ""
"To calculate hash of some data, you should first construct a hash object by calling the "
"appropriate constructor function (:func:`blake2b` or :func:`blake2s`), then update it "
"with the data by calling :meth:`update` on the object, and, finally, get the digest out "
"of the object by calling :meth:`digest` (or :meth:`hexdigest` for hex-encoded string)."
msgstr ""
"Pour calculer les *hash* de certaines données, vous devez d'abord construire un objet "
"haché en appelant la fonction constructeur appropriée (:func:`blake2b` or :func:"
"`blake2s`), ensuite le mettre à jour avec les données en appelant la méthode :meth:"
"`update` sur l'objet, et, pour finir, récupérer l'empreinte du message en appelant la "
"méthode :meth:`digest` (ou :meth:`hexdigest` pour les chaînes hexadécimales)."

#: ../Doc/library/hashlib.rst:430
msgid ""
"As a shortcut, you can pass the first chunk of data to update directly to the "
"constructor as the positional argument:"
msgstr ""
"Pour raccourcir, vous pouvez passer directement au constructeur, comme argument "
"positionnel, le premier morceau du message à mettre à jour : ::"

#: ../Doc/library/hashlib.rst:437
msgid ""
"You can call :meth:`hash.update` as many times as you need to iteratively update the "
"hash:"
msgstr ""
"Vous pouvez appeler la méthode :meth:`hash.update` autant de fois que nécessaire pour "
"mettre à jour le *hash* de manière itérative : ::"

#: ../Doc/library/hashlib.rst:450
msgid "Using different digest sizes"
msgstr "Usage de tailles d'empreintes différentes"

#: ../Doc/library/hashlib.rst:452
msgid ""
"BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to 32 bytes "
"for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without changing the size of "
"output, we can tell BLAKE2b to produce 20-byte digests:"
msgstr ""
"BLAKE2 permet de configurer la taille des empreintes jusqu'à 64 bytes pour BLAKE2b et "
"jusqu'à 32 bytes pour BLAKE2s. Par exemple, pour remplacer SHA-1 par BLAKE2b sans "
"changer la taille de la sortie, nous pouvons dire à BLAKE2b de produire une empreinte "
"de 20 bytes : ::"

#: ../Doc/library/hashlib.rst:466
msgid ""
"Hash objects with different digest sizes have completely different outputs (shorter "
"hashes are *not* prefixes of longer hashes); BLAKE2b and BLAKE2s produce different "
"outputs even if the output length is the same:"
msgstr ""
"Les objets hachés avec différentes tailles d'empreintes ont des sorties complètement "
"différentes (les *hash* plus courts *ne sont pas* des préfixes de *hash* plus longs); "
"BLAKE2b et BLAKE2s produisent des sorties différentes même si les longueurs des sorties "
"sont les mêmes : ::"

#: ../Doc/library/hashlib.rst:482
msgid "Keyed hashing"
msgstr "Code d'authentification de message"

#: ../Doc/library/hashlib.rst:484
#, fuzzy
msgid ""
"Keyed hashing can be used for authentication as a faster and simpler replacement for "
"`Hash-based message authentication code <https://en.wikipedia.org/wiki/Hash-"
"based_message_authentication_code>`_ (HMAC). BLAKE2 can be securely used in prefix-MAC "
"mode thanks to the indifferentiability property inherited from BLAKE."
msgstr ""
"Le code d'authentification de message peut être utilisé pour l'authentification comme "
"un remplacement simple et rapide de `Hash-based message authentication code <https://en."
"wikipedia.org/wiki/Hash-based_message_authentication_code>`_ (HMAC). BLAKE2 peut être "
"utilisé de manière sécurisée dans le mode préfixe MAC grâce à la propriété "
"d'indifférenciabilité héritée de BLAKE"

#: ../Doc/library/hashlib.rst:490
msgid ""
"This example shows how to get a (hex-encoded) 128-bit authentication code for message "
"``b'message data'`` with key ``b'pseudorandom key'``::"
msgstr ""
"Cet exemple montre comment obtenir un code d'authentification de message de 128-bit (en "
"hexadécimal) pour un message ``b'message data'`` avec la clé ``b'pseudorandom "
"key'`` : ::"

#: ../Doc/library/hashlib.rst:500
msgid ""
"As a practical example, a web application can symmetrically sign cookies sent to users "
"and later verify them to make sure they weren't tampered with::"
msgstr ""
"Comme exemple pratique, une application web peut chiffrer symétriquement les *cookies* "
"envoyés aux utilisateurs et les vérifier plus tard pour être certaine qu'ils n'aient "
"pas été altérés : ::"

#: ../Doc/library/hashlib.rst:529
msgid ""
"Even though there's a native keyed hashing mode, BLAKE2 can, of course, be used in HMAC "
"construction with :mod:`hmac` module::"
msgstr ""
"Même s'il possède en natif la création de code d'authentification de message (MAC), "
"BLAKE2 peut, bien sûr, être utilisé pour construire un HMAC en combinaison du module :"
"mod:`hmac` : ::"

#: ../Doc/library/hashlib.rst:540
msgid "Randomized hashing"
msgstr "Hachage randomisé"

#: ../Doc/library/hashlib.rst:542
msgid ""
"By setting *salt* parameter users can introduce randomization to the hash function. "
"Randomized hashing is useful for protecting against collision attacks on the hash "
"function used in digital signatures."
msgstr ""
"En définissant le paramètre *salt* les utilisateurs peuvent introduire de l'aléatoire "
"dans la fonction de hachage. Le hachage randomisé est utile pour se protéger des "
"attaques par collisions sur les fonctions de hachage utilisées dans les signatures "
"numériques."

#: ../Doc/library/hashlib.rst:546
msgid ""
"Randomized hashing is designed for situations where one party, the message preparer, "
"generates all or part of a message to be signed by a second party, the message signer. "
"If the message preparer is able to find cryptographic hash function collisions (i.e., "
"two messages producing the same hash value), then they might prepare meaningful "
"versions of the message that would produce the same hash value and digital signature, "
"but with different results (e.g., transferring $1,000,000 to an account, rather than "
"$10). Cryptographic hash functions have been designed with collision resistance as a "
"major goal, but the current concentration on attacking cryptographic hash functions may "
"result in a given cryptographic hash function providing less collision resistance than "
"expected. Randomized hashing offers the signer additional protection by reducing the "
"likelihood that a preparer can generate two or more messages that ultimately yield the "
"same hash value during the digital signature generation process --- even if it is "
"practical to find collisions for the hash function. However, the use of randomized "
"hashing may reduce the amount of security provided by a digital signature when all "
"portions of the message are prepared by the signer."
msgstr ""
"Le hachage aléatoire est conçu pour les situations où une partie, le préparateur du "
"message, génère tout ou partie d'un message à signer par une seconde partie, le "
"signataire du message. Si le préparateur du message est capable de trouver des "
"collisions sur la fonction cryptographique de hachage (i.e., deux messages produisant "
"la même valeur de hash), alors ils peuvent préparer des versions significatives du "
"message qui produiront les mêmes valeurs de hash et de signature digitale mais avec des "
"résultats différents (e.g. transférer 1000000$ sur un compte plutôt que 10$). Les "
"fonctions cryptographiques de hachage ont été conçues dans le but de résister aux "
"collisions, mais la concentration actuelle d'attaques sur les fonctions de hachage peut "
"avoir pour conséquence qu'une fonction de hachage donnée soit moins résistante "
"qu'attendu. Le hachage aléatoire offre au signataire une protection supplémentaire en "
"réduisant la probabilité que le préparateur puisse générer deux messages ou plus qui "
"renverront la même valeur de hash lors du processus de génération de la signature "
"digitale --- même s'il est pratique de trouver des collisions sur la fonction de "
"hachage. Toutefois, l'utilisation du hachage aléatoire peut réduire le niveau de "
"sécurité fourni par une signature numérique lorsque tous les morceaux du message sont "
"préparés par le signataire."

#: ../Doc/library/hashlib.rst:565
msgid ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" <https://csrc.nist.gov/"
"publications/detail/sp/800-106/final>`_)"
msgstr ""

#: ../Doc/library/hashlib.rst:568
msgid ""
"In BLAKE2 the salt is processed as a one-time input to the hash function during "
"initialization, rather than as an input to each compression function."
msgstr ""
"Dans BLAKE2, le sel est passé une seule fois lors de l'initialisation de la fonction de "
"hachage, plutôt qu'à chaque appel d'une fonction de compression."

#: ../Doc/library/hashlib.rst:573
msgid ""
"*Salted hashing* (or just hashing) with BLAKE2 or any other general-purpose "
"cryptographic hash function, such as SHA-256, is not suitable for hashing passwords.  "
"See `BLAKE2 FAQ <https://blake2.net/#qa>`_ for more information."
msgstr ""
"*Salted hashing* (ou juste hachage) avec BLAKE2 ou toute autre fonction de hachage "
"générique, comme SHA-256, ne convient pas pour le chiffrement des mots de passe.  Voir "
"`BLAKE2 FAQ <https://blake2.net/#qa>`_ pour plus d'informations."

#: ../Doc/library/hashlib.rst:596
msgid "Personalization"
msgstr "Personnalisation"

#: ../Doc/library/hashlib.rst:598
msgid ""
"Sometimes it is useful to force hash function to produce different digests for the same "
"input for different purposes. Quoting the authors of the Skein hash function:"
msgstr ""
"Parfois il est utile de forcer une fonction de hachage à produire différentes "
"empreintes de message d'une même entrée pour différentes utilisations. Pour citer les "
"auteurs de la fonction de hachage Skein  : ::"

#: ../Doc/library/hashlib.rst:602
msgid ""
"We recommend that all application designers seriously consider doing this; we have seen "
"many protocols where a hash that is computed in one part of the protocol can be used in "
"an entirely different part because two hash computations were done on similar or "
"related data, and the attacker can force the application to make the hash inputs the "
"same. Personalizing each hash function used in the protocol summarily stops this type "
"of attack."
msgstr ""
"Nous recommandons que tous les développeurs d'application considèrent sérieusement de "
"faire cela ; nous avons vu de nombreux protocoles où un *hash* était calculé à un "
"endroit du protocole pour être utilisé à un autre endroit car deux calculs de *hash* "
"étaient réalisés sur des données similaires ou liées, et qu'un attaquant peut forcer "
"une application à prendre en entrée le même hash. Personnaliser chaque fonction de "
"hachage utilisée dans le protocole stoppe immédiatement ce genre d'attaque."

#: ../Doc/library/hashlib.rst:609
msgid ""
"(`The Skein Hash Function Family <http://www.skein-hash.info/sites/default/files/"
"skein1.3.pdf>`_, p. 21)"
msgstr ""

#: ../Doc/library/hashlib.rst:613
msgid "BLAKE2 can be personalized by passing bytes to the *person* argument::"
msgstr "BLAKE2 peut être personnalisé en passant des *bytes* à l'argument *person* : ::"

#: ../Doc/library/hashlib.rst:627
#, fuzzy
msgid ""
"Personalization together with the keyed mode can also be used to derive different keys "
"from a single one."
msgstr ""
"L'utilisation de la personnalisation avec le *keyed mode* peut être utilisé pour "
"dériver différentes clés à partir d'une seule."

#: ../Doc/library/hashlib.rst:641
msgid "Tree mode"
msgstr "Mode Arbre"

#: ../Doc/library/hashlib.rst:643
msgid "Here's an example of hashing a minimal tree with two leaf nodes::"
msgstr ""
"L'exemple ci-dessous présente comment hacher un arbre minimal avec deux nœuds "
"terminaux : ::"

#: ../Doc/library/hashlib.rst:649
msgid "This example uses 64-byte internal digests, and returns the 32-byte final digest::"
msgstr ""
"Cet exemple utilise en interne des empreintes de 64 octets, et produit finalement des "
"empreintes 32 octets : ::"

#: ../Doc/library/hashlib.rst:679
msgid "Credits"
msgstr "Crédits"

#: ../Doc/library/hashlib.rst:681
msgid ""
"BLAKE2_ was designed by *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko Wilcox-"
"O'Hearn*, and *Christian Winnerlein* based on SHA-3_ finalist BLAKE_ created by *Jean-"
"Philippe Aumasson*, *Luca Henzen*, *Willi Meier*, and *Raphael C.-W. Phan*."
msgstr ""
"BLAKE2_ a été conçu par *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko Wilcox-"
"O'Hearn*, et *Christian Winnerlein* basé sur SHA-3_ finaliste BLAKE_ créé par *Jean-"
"Philippe Aumasson*, *Luca Henzen*, *Willi Meier*, et *Raphael C.-W. Phan*."

#: ../Doc/library/hashlib.rst:686
msgid "It uses core algorithm from ChaCha_ cipher designed by *Daniel J.  Bernstein*."
msgstr ""
"Il utilise le cœur de l'algorithme de chiffrement de ChaCha_ conçu par *Daniel J.  "
"Bernstein*."

#: ../Doc/library/hashlib.rst:688
msgid ""
"The stdlib implementation is based on pyblake2_ module. It was written by *Dmitry "
"Chestnykh* based on C implementation written by *Samuel Neves*. The documentation was "
"copied from pyblake2_ and written by *Dmitry Chestnykh*."
msgstr ""
"L'implémentation dans la librairie standard est basée sur le module pyblake2_. Il a été "
"écrit par *Dmitry Chestnykh* et basé sur l'implémentation C écrite par *Samuel Neves*. "
"La documentation a été copiée depuis pyblake2_ et écrite par *Dmitry Chestnykh*."

#: ../Doc/library/hashlib.rst:692
msgid "The C code was partly rewritten for Python by *Christian Heimes*."
msgstr "Le code C a été partiellement réécrit pour Python par *Christian Heimes*."

#: ../Doc/library/hashlib.rst:694
msgid ""
"The following public domain dedication applies for both C hash function implementation, "
"extension code, and this documentation:"
msgstr ""
"Le transfert dans le domaine public s'applique pour l'implémentation C de la fonction "
"de hachage, ses extensions et cette documentation : ::"

#: ../Doc/library/hashlib.rst:697
msgid ""
"To the extent possible under law, the author(s) have dedicated all copyright and "
"related and neighboring rights to this software to the public domain worldwide. This "
"software is distributed without any warranty."
msgstr "A la mesure du possible en vertu du droit, le(s) auteur(s)  "

#: ../Doc/library/hashlib.rst:701
msgid ""
"You should have received a copy of the CC0 Public Domain Dedication along with this "
"software. If not, see https://creativecommons.org/publicdomain/zero/1.0/."
msgstr ""
"Vous devriez recevoir avec ce logiciel une copie de la licence *CC0 Public Domain "
"Dedication*. Sinon, voir https://creativecommons.org/publicdomain/zero/1.0/."

#: ../Doc/library/hashlib.rst:705
msgid ""
"The following people have helped with development or contributed their changes to the "
"project and the public domain according to the Creative Commons Public Domain "
"Dedication 1.0 Universal:"
msgstr ""
"Les personnes suivantes ont aidé au développement ou contribué aux modification du "
"projet et au domaine public selon la licence Creative Commons Public Domain Dedication "
"1.0 Universal : ::"

#: ../Doc/library/hashlib.rst:709
msgid "*Alexandr Sokolovskiy*"
msgstr ""

#: ../Doc/library/hashlib.rst:723
msgid "Module :mod:`hmac`"
msgstr ""

#: ../Doc/library/hashlib.rst:723
msgid "A module to generate message authentication codes using hashes."
msgstr "Un module pour générer des codes d'authentification utilisant des *hash*."

#: ../Doc/library/hashlib.rst:726
msgid "Module :mod:`base64`"
msgstr ""

#: ../Doc/library/hashlib.rst:726
msgid "Another way to encode binary hashes for non-binary environments."
msgstr ""
"Un autre moyen d'encoder des *hash* binaires dans des environnements non binaires."

#: ../Doc/library/hashlib.rst:729
msgid "https://blake2.net"
msgstr ""

#: ../Doc/library/hashlib.rst:729
msgid "Official BLAKE2 website."
msgstr "Site officiel de BLAKE2."

#: ../Doc/library/hashlib.rst:732
msgid ""
"https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/documents/"
"fips180-2.pdf"
msgstr ""

#: ../Doc/library/hashlib.rst:732
msgid "The FIPS 180-2 publication on Secure Hash Algorithms."
msgstr "La publication FIPS 180-2 sur les algorithmes de hachage sécurisés"

#: ../Doc/library/hashlib.rst:736
msgid ""
"https://en.wikipedia.org/wiki/Cryptographic_hash_function#Cryptographic_hash_algorithms"
msgstr ""

#: ../Doc/library/hashlib.rst:735
msgid ""
"Wikipedia article with information on which algorithms have known issues and what that "
"means regarding their use."
msgstr ""
"Article Wikipedia contenant les informations relatives aux algorithmes ayant des "
"problèmes et leur interprétation au regard de leur utilisation."

#: ../Doc/library/hashlib.rst:738
msgid "https://www.ietf.org/rfc/rfc2898.txt"
msgstr ""

#: ../Doc/library/hashlib.rst:739
msgid "PKCS #5: Password-Based Cryptography Specification Version 2.0"
msgstr ""
