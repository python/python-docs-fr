# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-01 00:16+0100\n"
"PO-Revision-Date: 2024-11-01 11:09+0100\n"
"Last-Translator: Jules Lasne <jules.lasne@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.1\n"

#: library/hashlib.rst:2
msgid ":mod:`!hashlib` --- Secure hashes and message digests"
msgstr ""
":mod:`hashlib` --- Algorithmes de hachage sécurisés et synthèse de messages"

#: library/hashlib.rst:10
msgid "**Source code:** :source:`Lib/hashlib.py`"
msgstr "**Code source :** :source:`Lib/hashlib.py`"

#: library/hashlib.rst:23
msgid ""
"This module implements a common interface to many different secure hash and "
"message digest algorithms.  Included are the FIPS secure hash algorithms "
"SHA1, SHA224, SHA256, SHA384, SHA512, (defined in `the FIPS 180-4 "
"standard`_), the SHA-3 series (defined in `the FIPS 202 standard`_) as well "
"as RSA's MD5 algorithm (defined in internet :rfc:`1321`).  The terms "
"\"secure hash\" and \"message digest\" are interchangeable.  Older "
"algorithms were called message digests.  The modern term is secure hash."
msgstr ""
"Ce module implémente une interface commune à différents algorithmes de "
"hachage sécurisés et de synthèse de messages. Sont inclus les algorithmes "
"standards FIPS de hachage SHA1, SHA224, SHA256, SHA384, et SHA512 (définis "
"dans FIPS 180-2), la série SHA-3 (définis dans FIPS 202),  ainsi que "
"l'algorithme MD5 de RSA (défini par la :rfc:`1321`). Les termes « "
"algorithmes de hachage sécurisé » et « algorithme de synthèse de message » "
"sont interchangeables. Les anciens algorithmes étaient appelés « algorithmes "
"de synthèse de messages ». Le terme moderne est « algorithme de hachage "
"sécurisé »."

#: library/hashlib.rst:33
msgid ""
"If you want the adler32 or crc32 hash functions, they are available in the :"
"mod:`zlib` module."
msgstr ""
"Si vous préférez utiliser les fonctions de hachage *adler32* ou *crc32*, "
"elles sont disponibles dans le module :mod:`zlib`."

#: library/hashlib.rst:40
msgid "Hash algorithms"
msgstr "Algorithmes de hachage"

#: library/hashlib.rst:42
msgid ""
"There is one constructor method named for each type of :dfn:`hash`.  All "
"return a hash object with the same simple interface. For example: use :func:"
"`sha256` to create a SHA-256 hash object. You can now feed this object with :"
"term:`bytes-like objects <bytes-like object>` (normally :class:`bytes`) "
"using the :meth:`update<hash.update>` method.  At any point you can ask it "
"for the :dfn:`digest` of the concatenation of the data fed to it so far "
"using the :meth:`digest()<hash.digest>` or :meth:`hexdigest()<hash."
"hexdigest>` methods."
msgstr ""
"Il y a un constructeur nommé selon chaque type de calcul d'empreinte (:dfn:"
"`hash`). Tous renvoient un objet haché avec la même interface. Par exemple : "
"utilisez :func:`sha256` pour créer un objet de calcul d'empreinte avec "
"l'algorithme SHA-256. Vous pouvez maintenant utiliser cet objet avec des :"
"term:`objets octets-compatibles <bytes-like object>` (normalement des :class:"
"`bytes`) en utilisant la méthode :meth:`update<hash.update>`. À tout moment "
"vous pouvez demander l'empreinte (aussi appelée le :dfn:`digest` ou le "
"condensat) de la concaténation des données fournies en utilisant les "
"méthodes :meth:`digest()<hash.digest>` ou :meth:`hexdigest()<hash."
"hexdigest>`."

# suit un :
#: library/hashlib.rst:50
msgid ""
"To allow multithreading, the Python :term:`GIL` is released while computing "
"a hash supplied more than 2047 bytes of data at once in its constructor or :"
"meth:`.update<hash.update>` method."
msgstr ""
"pour de meilleures performances avec de multiples fils d'exécution, le :term:"
"`GIL` Python est relâché pour des données dont la taille est supérieure à "
"2047 octets lors de leur création ou leur mise à jour (méthode :meth:`."
"update<hash.update>`.)."

#: library/hashlib.rst:57
msgid ""
"Constructors for hash algorithms that are always present in this module are :"
"func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:"
"`sha512`, :func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, :func:"
"`sha3_512`, :func:`shake_128`, :func:`shake_256`, :func:`blake2b`, and :func:"
"`blake2s`. :func:`md5` is normally available as well, though it may be "
"missing or blocked if you are using a rare \"FIPS compliant\" build of "
"Python. These correspond to :data:`algorithms_guaranteed`."
msgstr ""
"Les constructeurs pour les algorithmes de hachage qui sont toujours présents "
"dans ce module sont :func:`sha1`, :func:`sha224`, :func:`sha256`, :func:"
"`sha384`, :func:`sha512`, :func:`sha3_224`, :func:`sha3_256`, :func:"
"`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256`, :func:"
"`blake2b`, et :func:`blake2s`. :func:`md5` est normalement disponible aussi, "
"mais il peut être manquant ou bloqué si vous utilisez une forme rare de "
"Python « conforme FIPS ». Cette liste correspond au résultat de la fonction :"
"data:`algorithms_guaranteed`."

#: library/hashlib.rst:65
msgid ""
"Additional algorithms may also be available if your Python distribution's :"
"mod:`hashlib` was linked against a build of OpenSSL that provides others. "
"Others *are not guaranteed available* on all installations and will only be "
"accessible by name via :func:`new`.  See :data:`algorithms_available`."
msgstr ""

#: library/hashlib.rst:72
msgid ""
"Some algorithms have known hash collision weaknesses (including MD5 and "
"SHA1). Refer to `Attacks on cryptographic hash algorithms`_ and the `hashlib-"
"seealso`_ section at the end of this document."
msgstr ""
"Certains algorithmes ont des faiblesses connues relatives à la collision "
"(MD5 et SHA1 inclus). Se référer à `Fonction de hachage cryptographique`_ et "
"à la section `Voir aussi`_ à la fin du document."

# suit un :
#: library/hashlib.rst:76
msgid ""
"SHA3 (Keccak) and SHAKE constructors :func:`sha3_224`, :func:`sha3_256`, :"
"func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256` were "
"added. :func:`blake2b` and :func:`blake2s` were added."
msgstr ""
"les constructeurs SHA3 (Keccak) et SHAKE :func:`sha3_224`, :func:"
"`sha3_256`, :func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:"
"`shake_256` ont été ajoutés. :func:`blake2b` et :func:`blake2s` ont été "
"ajoutés."

# suit un :
#: library/hashlib.rst:84
msgid ""
"All hashlib constructors take a keyword-only argument *usedforsecurity* with "
"default value ``True``. A false value allows the use of insecure and blocked "
"hashing algorithms in restricted environments. ``False`` indicates that the "
"hashing algorithm is not used in a security context, e.g. as a non-"
"cryptographic one-way compression function."
msgstr ""
"tous les constructeurs de *hashlib* prennent un argument mot-clé uniquement "
"*usedforsecurity* avec la valeur par défaut ``True``. Une valeur fausse "
"permet l'utilisation d'algorithmes de hachage non sécurisés et bloqués dans "
"des environnements restreints. ``False`` indique que l'algorithme de hachage "
"ne sera pas utilisé dans un contexte de sécurité, par exemple en tant que "
"fonction de compression à sens unique non cryptographique."

#: library/hashlib.rst:91
msgid "Hashlib now uses SHA3 and SHAKE from OpenSSL if it provides it."
msgstr "*Hashlib* utilise désormais SHA3 et SHAKE d'OpenSSL s'il les fournit."

#: library/hashlib.rst:94
msgid ""
"For any of the MD5, SHA1, SHA2, or SHA3 algorithms that the linked OpenSSL "
"does not provide we fall back to a verified implementation from the `HACL\\* "
"project`_."
msgstr ""

#: library/hashlib.rst:100
msgid "Usage"
msgstr "Utilisation"

#: library/hashlib.rst:102
#, fuzzy
msgid ""
"To obtain the digest of the byte string ``b\"Nobody inspects the spammish "
"repetition\"``::"
msgstr ""
"Par exemple, pour obtenir l'empreinte de la chaîne ``b\"Nobody inspects the "
"spammish repetition\"`` ::"

#: library/hashlib.rst:114
msgid "More condensed:"
msgstr "En plus condensé :"

#: library/hashlib.rst:120
msgid "Constructors"
msgstr "Constructeurs"

#: library/hashlib.rst:124
#, fuzzy
msgid ""
"Is a generic constructor that takes the string *name* of the desired "
"algorithm as its first parameter.  It also exists to allow access to the "
"above listed hashes as well as any other algorithms that your OpenSSL "
"library may offer."
msgstr ""
"Constructeur générique qui prend comme premier paramètre le nom de "
"l'algorithme désiré (*name*). Il existe pour permettre l'accès aux "
"algorithmes listés ci-dessus ainsi qu'aux autres algorithmes que votre "
"bibliothèque OpenSSL peut offrir."

#: library/hashlib.rst:129
#, fuzzy
msgid "Using :func:`new` with an algorithm name:"
msgstr "En utilisant :func:`new` avec un algorithme fourni par OpenSSL :"

#: library/hashlib.rst:148
msgid ""
"Named constructors such as these are faster than passing an algorithm name "
"to :func:`new`."
msgstr ""

#: library/hashlib.rst:152
msgid "Attributes"
msgstr ""

#: library/hashlib.rst:154
msgid "Hashlib provides the following constant module attributes:"
msgstr "*Hashlib* fournit les constantes de module suivantes :"

#: library/hashlib.rst:158
msgid ""
"A set containing the names of the hash algorithms guaranteed to be supported "
"by this module on all platforms.  Note that 'md5' is in this list despite "
"some upstream vendors offering an odd \"FIPS compliant\" Python build that "
"excludes it."
msgstr ""
"Ensemble contenant les noms des algorithmes de hachage garantis d'être "
"implémentés par ce module sur toutes les plate-formes. Notez que *md5* est "
"dans cette liste bien que certains éditeurs diffusent une implémentation "
"Python dont la bibliothèque « compatible FIPS » le bloque."

#: library/hashlib.rst:167
msgid ""
"A set containing the names of the hash algorithms that are available in the "
"running Python interpreter.  These names will be recognized when passed to :"
"func:`new`.  :attr:`algorithms_guaranteed` will always be a subset.  The "
"same algorithm may appear multiple times in this set under different names "
"(thanks to OpenSSL)."
msgstr ""
"Ensemble contenant les noms des algorithmes de hachage disponibles dans "
"l'interpréteur Python. Ces noms sont reconnus lorsqu'ils sont passés à la "
"fonction :func:`new`.  :attr:`algorithms_guaranteed` est toujours un sous-"
"ensemble. Le même algorithme peut apparaître plusieurs fois dans cet "
"ensemble sous un nom différent (grâce à OpenSSL)."

#: library/hashlib.rst:176
msgid "Hash Objects"
msgstr "Objets de calcul d'empreinte"

#: library/hashlib.rst:178
msgid ""
"The following values are provided as constant attributes of the hash objects "
"returned by the constructors:"
msgstr ""
"Les valeurs suivantes sont fournies en tant qu'attributs constants des "
"objets de calcul d'empreintes renvoyés par les constructeurs :"

#: library/hashlib.rst:183
msgid "The size of the resulting hash in bytes."
msgstr "La taille du *hash* résultant en octets."

#: library/hashlib.rst:187
msgid "The internal block size of the hash algorithm in bytes."
msgstr "La taille interne d'un bloc de l'algorithme de hachage en octets."

#: library/hashlib.rst:189
msgid "A hash object has the following attributes:"
msgstr "L'objet de hachage possède les attributs suivants :"

#: library/hashlib.rst:193
msgid ""
"The canonical name of this hash, always lowercase and always suitable as a "
"parameter to :func:`new` to create another hash of this type."
msgstr ""
"Le nom canonique de cette fonction de hachage, toujours en minuscule et que "
"vous pouvez toujours transmettre à la fonction :func:`new` pour créer un "
"autre objet de calcul d'empreinte de ce type."

# suit un :
#: library/hashlib.rst:196
msgid ""
"The name attribute has been present in CPython since its inception, but "
"until Python 3.4 was not formally specified, so may not exist on some "
"platforms."
msgstr ""
"l'attribut *name* est présent dans CPython depuis sa création, mais n'était "
"pas spécifié formellement jusqu'à Python 3.4, il peut ne pas exister sur "
"certaines plate-formes."

#: library/hashlib.rst:201
msgid "A hash object has the following methods:"
msgstr "L'objet de calcul d'empreinte possède les méthodes suivantes :"

#: library/hashlib.rst:206
msgid ""
"Update the hash object with the :term:`bytes-like object`. Repeated calls "
"are equivalent to a single call with the concatenation of all the arguments: "
"``m.update(a); m.update(b)`` is equivalent to ``m.update(a+b)``."
msgstr ""
"Met à jour l'objet de hachage avec :term:`bytes-like object`. Les appels "
"répétés sont équivalents à un simple appel avec la concaténation de tous les "
"arguments : ``m.update(a); m.update(b)`` est équivalent à ``m.update(a+b)``."

#: library/hashlib.rst:214
msgid ""
"Return the digest of the data passed to the :meth:`update` method so far. "
"This is a bytes object of size :attr:`digest_size` which may contain bytes "
"in the whole range from 0 to 255."
msgstr ""
"Renvoie l'empreinte (le *hash*) des données passées à la méthode :meth:"
"`update`. C'est un objet de type *bytes* de taille :attr:`digest_size` qui "
"contient des octets dans l'intervalle 0 à 255."

#: library/hashlib.rst:221
msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value safely in email or other non-binary environments."
msgstr ""
"Comme la méthode :meth:`digest` sauf que l'empreinte renvoyée est une chaîne "
"de caractères dont la longueur est double, contenant seulement des chiffres "
"hexadécimaux. Elle peut être utilisée pour échanger sans risque des valeurs "
"dans les *e-mails* ou dans les environnements non binaires."

#: library/hashlib.rst:228
msgid ""
"Return a copy (\"clone\") of the hash object.  This can be used to "
"efficiently compute the digests of data sharing a common initial substring."
msgstr ""
"Renvoie une copie (\"clone\") de l'objet de calcul de hachage. Cela peut "
"être utilisé pour calculer efficacement des empreintes de données qui "
"commencent par la même sous-chaine."

#: library/hashlib.rst:233
msgid "SHAKE variable length digests"
msgstr "Empreintes de messages de taille variable SHAKE"

#: library/hashlib.rst:238
msgid ""
"The :func:`shake_128` and :func:`shake_256` algorithms provide variable "
"length digests with length_in_bits//2 up to 128 or 256 bits of security. As "
"such, their digest methods require a length. Maximum length is not limited "
"by the SHAKE algorithm."
msgstr ""
"Les algorithmes :func:`shake_128` et :func:`shake_256` produisent des "
"empreintes (ou condensats) de longueur variable avec des "
"``longueurs_en_bits // 2`` jusqu'à 128 ou 256 bits. Leurs méthodes de calcul "
"d'empreinte requièrent une longueur. Les longueurs maximales ne sont pas "
"limitées par l'algorithme SHAKE."

#: library/hashlib.rst:245
msgid ""
"Return the digest of the data passed to the :meth:`~hash.update` method so "
"far. This is a bytes object of size *length* which may contain bytes in the "
"whole range from 0 to 255."
msgstr ""
"Renvoie l'empreinte des données passées à la méthode :meth:`~hash.update`. "
"C'est un objet de type *bytes* de taille *length* qui contient des octets "
"dans l'intervalle 0 à 255."

#: library/hashlib.rst:252
msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value in email or other non-binary environments."
msgstr ""
"Comme la méthode :meth:`digest` sauf que l'empreinte renvoyée est une chaîne "
"de caractères dont la longueur est double, contenant seulement des chiffres "
"hexadécimaux. Elle peut être utilisée pour échanger sans risque des valeurs "
"dans les *e-mails* ou dans les environnements non binaires."

#: library/hashlib.rst:256
msgid "Example use:"
msgstr "Exemple :"

#: library/hashlib.rst:263
msgid "File hashing"
msgstr "Calcul d'empreinte (ou hachage) de fichiers"

#: library/hashlib.rst:265
msgid ""
"The hashlib module provides a helper function for efficient hashing of a "
"file or file-like object."
msgstr ""
"Le module *hashlib* fournit une fonction utilitaire pour calculer "
"efficacement l'empreinte (aussi appelée condensat) d'un fichier ou d'un "
"objet fichier-compatible."

#: library/hashlib.rst:270
msgid ""
"Return a digest object that has been updated with contents of file object."
msgstr ""
"Renvoie un objet de calcul d'empreinte qui a été mis à jour avec le contenu "
"de *fileobj*."

#: library/hashlib.rst:272
msgid ""
"*fileobj* must be a file-like object opened for reading in binary mode. It "
"accepts file objects from  builtin :func:`open`, :class:`~io.BytesIO` "
"instances, SocketIO objects from :meth:`socket.socket.makefile`, and "
"similar. The function may bypass Python's I/O and use the file descriptor "
"from :meth:`~io.IOBase.fileno` directly. *fileobj* must be assumed to be in "
"an unknown state after this function returns or raises. It is up to the "
"caller to close *fileobj*."
msgstr ""
"*fileobj* doit être un objet fichier-compatible ouvert en lecture en mode "
"binaire. Sont acceptés les instances d'objets fichiers produites par la "
"fonction native  :func:`open`, :class:`~io.BytesIO`, les objets connecteurs "
"produits par  :meth:`socket.socket.makefile` et similaires. La fonction peut "
"court-circuiter les entrées-sorties de Python et utiliser directement le "
"descripteur de fichier de :meth:`~io.IOBase.fileno`. Vous devez supposer que "
"*fileobj* est dans un état inconnu après le retour de cette fonction ou si "
"elle a levé une exception. C'est à l'appelant de fermer *fileobj*."

#: library/hashlib.rst:280
msgid ""
"*digest* must either be a hash algorithm name as a *str*, a hash "
"constructor, or a callable that returns a hash object."
msgstr ""
"*digest* doit être un nom d'algorithme de hachage fourni en tant que *str*, "
"un constructeur de hachage ou un appelable qui renvoie un objet de hachage."

#: library/hashlib.rst:283
msgid "Example:"
msgstr "Exemple :"

#: library/hashlib.rst:306
msgid "Key derivation"
msgstr "Dérivation de clé"

#: library/hashlib.rst:308
msgid ""
"Key derivation and key stretching algorithms are designed for secure "
"password hashing. Naive algorithms such as ``sha1(password)`` are not "
"resistant against brute-force attacks. A good password hashing function must "
"be tunable, slow, and include a `salt <https://en.wikipedia.org/wiki/"
"Salt_%28cryptography%29>`_."
msgstr ""
"Les algorithmes de dérivation de clés et d'étirement de clés sont conçus "
"pour le hachage sécurisé de mots de passe. Des algorithmes naïfs comme "
"``sha1(password)`` ne sont pas résistants aux attaques par force brute. Une "
"bonne fonction de hachage doit être paramétrable, lente et inclure un "
"`salage <https://fr.wikipedia.org/wiki/Salage_(cryptographie)>`_."

#: library/hashlib.rst:316
msgid ""
"The function provides PKCS#5 password-based key derivation function 2. It "
"uses HMAC as pseudorandom function."
msgstr ""
"La fonction fournit une fonction de dérivation conforme à PKCS#5 (*Public "
"Key Cryptographic Standards #5 v2.0*). Elle utilise HMAC comme fonction de "
"génération d'un pseudo-aléa."

#: library/hashlib.rst:319
msgid ""
"The string *hash_name* is the desired name of the hash digest algorithm for "
"HMAC, e.g. 'sha1' or 'sha256'. *password* and *salt* are interpreted as "
"buffers of bytes. Applications and libraries should limit *password* to a "
"sensible length (e.g. 1024). *salt* should be about 16 or more bytes from a "
"proper source, e.g. :func:`os.urandom`."
msgstr ""
"La chaîne de caractères *hash_name* est le nom de l'algorithme de hachage "
"désiré pour le HMAC, par exemple ``\"sha1\"`` ou ``\"sha256\"``. *password* "
"et *salt* sont interprétés comme des tampons d'octets. Les applications et "
"bibliothèques doivent limiter *password* à une longueur raisonnable (comme "
"``1024``). *salt* doit être de 16 octets ou plus et provenir d'une source "
"correcte, e.g. :func:`os.urandom`."

#: library/hashlib.rst:325
msgid ""
"The number of *iterations* should be chosen based on the hash algorithm and "
"computing power. As of 2022, hundreds of thousands of iterations of SHA-256 "
"are suggested. For rationale as to why and how to choose what is best for "
"your application, read *Appendix A.2.2* of NIST-SP-800-132_. The answers on "
"the `stackexchange pbkdf2 iterations question`_ explain in detail."
msgstr ""
"Le nombre d'*itérations* doit être choisi en fonction de l'algorithme de "
"hachage et de la puissance de calcul. À partir de 2022, des centaines de "
"milliers d'itérations de SHA-256 sont suggérées. Pour savoir pourquoi et "
"comment choisir ce qui convient le mieux à votre application, lisez "
"*l'annexe A.2.2* du NIST-SP-800-132_ (ressource en anglais). Les réponses "
"contenues dans la question sur le site *stackexchange* `nombre d'itérations "
"recommandées lorsqu'on utilise pbkdf2`_ (page en anglais) expliquent tout en "
"détail."

#: library/hashlib.rst:331
msgid ""
"*dklen* is the length of the derived key in bytes. If *dklen* is ``None`` "
"then the digest size of the hash algorithm *hash_name* is used, e.g. 64 for "
"SHA-512."
msgstr ""
"*dklen* est la longueur de la clé dérivée. Si *dklen* vaut ``None`` alors "
"Python utilise la taille du condensat produit par l'algorithme de hachage "
"*hash_name*, par exemple 64 pour SHA-512."

#: library/hashlib.rst:340
msgid "Function only available when Python is compiled with OpenSSL."
msgstr ""

#: library/hashlib.rst:344
msgid ""
"Function now only available when Python is built with OpenSSL. The slow pure "
"Python implementation has been removed."
msgstr ""

#: library/hashlib.rst:350
msgid ""
"The function provides scrypt password-based key derivation function as "
"defined in :rfc:`7914`."
msgstr ""
"La fonction fournit la fonction de dérivation de clé *scrypt* comme définie "
"dans la :rfc:`7914`."

#: library/hashlib.rst:353
msgid ""
"*password* and *salt* must be :term:`bytes-like objects <bytes-like "
"object>`.  Applications and libraries should limit *password* to a sensible "
"length (e.g. 1024).  *salt* should be about 16 or more bytes from a proper "
"source, e.g. :func:`os.urandom`."
msgstr ""
"*password* et *salt* doivent être des :term:`objets octets-compatibles "
"<bytes-like object>`. Les applications et bibliothèques doivent limiter "
"*password* à une longueur raisonnable (par ex. 1024). *salt* doit être de 16 "
"octets ou plus et provenir d'une source correcte, par ex. :func:`os.urandom`."

#: library/hashlib.rst:358
msgid ""
"*n* is the CPU/Memory cost factor, *r* the block size, *p* parallelization "
"factor and *maxmem* limits memory (OpenSSL 1.1.0 defaults to 32 MiB). "
"*dklen* is the length of the derived key in bytes."
msgstr ""
"*n* est le facteur de coût CPU/Mémoire, *r* la taille de bloc, *p* le "
"facteur de parallélisation et *maxmem* limite l'utilisation de la mémoire "
"(OpenSSL 1.1.0 limite à 32 Mio par défaut). *dklen* est la longueur de la "
"clé dérivée en octets."

#: library/hashlib.rst:368
msgid "BLAKE2"
msgstr "BLAKE2"

#: library/hashlib.rst:375
msgid ""
"BLAKE2_ is a cryptographic hash function defined in :rfc:`7693` that comes "
"in two flavors:"
msgstr ""
"BLAKE2_ est une fonction de hachage cryptographique définie dans la :rfc:"
"`7693` et disponible en deux versions :"

#: library/hashlib.rst:378
msgid ""
"**BLAKE2b**, optimized for 64-bit platforms and produces digests of any size "
"between 1 and 64 bytes,"
msgstr ""
"**BLAKE2b**, optimisée pour les plates-formes 64 bits et produisant des "
"condensats de toutes tailles entre 1 et 64 octets,"

#: library/hashlib.rst:381
msgid ""
"**BLAKE2s**, optimized for 8- to 32-bit platforms and produces digests of "
"any size between 1 and 32 bytes."
msgstr ""
"**BLAKE2s**, optimisée pour les plates-formes de 8 à 32 bits et produisant "
"des empreintes de toutes tailles entre 1 et 32 octets."

#: library/hashlib.rst:384
msgid ""
"BLAKE2 supports **keyed mode** (a faster and simpler replacement for HMAC_), "
"**salted hashing**, **personalization**, and **tree hashing**."
msgstr ""
"BLAKE2 gère diverses fonctionnalités comme le **keyed mode** (plus rapide et "
"plus simple que HMAC_), **salted hashing**, **personalization** et le **tree "
"hashing**."

#: library/hashlib.rst:387
msgid ""
"Hash objects from this module follow the API of standard library's :mod:"
"`hashlib` objects."
msgstr ""
"Les objets de calcul d'empreinte de ce module suivent l'API des objets du "
"module :mod:`hashlib` de la bibliothèque standard."

#: library/hashlib.rst:392
msgid "Creating hash objects"
msgstr "Création d'objets de calcul d'empreinte"

#: library/hashlib.rst:394
msgid "New hash objects are created by calling constructor functions:"
msgstr ""
"Les nouveaux objets de calcul d'empreinte sont créés en appelant les "
"constructeurs :"

#: library/hashlib.rst:408
msgid ""
"These functions return the corresponding hash objects for calculating "
"BLAKE2b or BLAKE2s. They optionally take these general parameters:"
msgstr ""
"Ces fonctions produisent l'objet de calcul d'empreinte correspondant aux "
"algorithmes BLAKE2b ou BLAKE2s. Elles prennent ces paramètres optionnels :"

#: library/hashlib.rst:411
msgid ""
"*data*: initial chunk of data to hash, which must be :term:`bytes-like "
"object`.  It can be passed only as positional argument."
msgstr ""
"*data* : morceau initial de données à hacher, qui doit être un :term:`objet "
"octets-compatible <bytes-like object>`. Il ne peut être passé que comme "
"argument positionnel."

#: library/hashlib.rst:414
msgid "*digest_size*: size of output digest in bytes."
msgstr "*digest_size* : taille en octets de l'empreinte produite."

#: library/hashlib.rst:416
msgid ""
"*key*: key for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes for "
"BLAKE2s)."
msgstr ""
"*key* : clé pour les codes d'authentification de message *keyed hashing* "
"(jusqu'à 64 octets pour BLAKE2b, jusqu'à 32 octets pour BLAKE2s)."

#: library/hashlib.rst:419
msgid ""
"*salt*: salt for randomized hashing (up to 16 bytes for BLAKE2b, up to 8 "
"bytes for BLAKE2s)."
msgstr ""
"*salt* : sel pour le hachage randomisé *randomized hashing* (jusqu'à 16 "
"octets pour BLAKE2b, jusqu'à 8 octets pour BLAKE2s)."

#: library/hashlib.rst:422
msgid ""
"*person*: personalization string (up to 16 bytes for BLAKE2b, up to 8 bytes "
"for BLAKE2s)."
msgstr ""
"*person* : chaîne de personnalisation (jusqu'à 16 octets pour BLAKE2b, "
"jusqu'à 8 octets pour BLAKE2s)."

#: library/hashlib.rst:425
msgid "The following table shows limits for general parameters (in bytes):"
msgstr ""
"Le tableau suivant présente les limites des paramètres généraux (en octets) :"

#: library/hashlib.rst:428
msgid "Hash"
msgstr "Hash"

#: library/hashlib.rst:428
msgid "digest_size"
msgstr "digest_size"

#: library/hashlib.rst:428
msgid "len(key)"
msgstr "len(key)"

#: library/hashlib.rst:428
msgid "len(salt)"
msgstr "len(salt)"

#: library/hashlib.rst:428
msgid "len(person)"
msgstr "len(person)"

#: library/hashlib.rst:430
msgid "BLAKE2b"
msgstr "BLAKE2b"

#: library/hashlib.rst:430
msgid "64"
msgstr "64"

#: library/hashlib.rst:430
msgid "16"
msgstr "16"

#: library/hashlib.rst:431
msgid "BLAKE2s"
msgstr "BLAKE2s"

#: library/hashlib.rst:431
msgid "32"
msgstr "32"

#: library/hashlib.rst:431
msgid "8"
msgstr "8"

# suit un :
#: library/hashlib.rst:436
msgid ""
"BLAKE2 specification defines constant lengths for salt and personalization "
"parameters, however, for convenience, this implementation accepts byte "
"strings of any size up to the specified length. If the length of the "
"parameter is less than specified, it is padded with zeros, thus, for "
"example, ``b'salt'`` and ``b'salt\\x00'`` is the same value. (This is not "
"the case for *key*.)"
msgstr ""
"les spécifications de BLAKE2 définissent des longueurs constantes pour les "
"sel et chaînes de personnalisation. Toutefois, par commodité, cette "
"implémentation accepte des chaînes d'octets de n'importe quelle taille "
"jusqu'à la longueur spécifiée. Si la longueur du paramètre est moindre par "
"rapport à celle spécifiée, il est complété par des zéros. Ainsi, par "
"exemple, ``b'salt'`` et ``b'salt\\x00'`` sont la même valeur (ce n'est pas "
"le cas pour *key*)."

#: library/hashlib.rst:443
msgid "These sizes are available as module `constants`_ described below."
msgstr ""
"Ces tailles sont disponibles en tant que `constantes`_ du module et décrites "
"ci-dessous."

#: library/hashlib.rst:445
msgid ""
"Constructor functions also accept the following tree hashing parameters:"
msgstr ""
"Les fonctions constructeurs acceptent aussi les paramètres suivants pour le "
"calcul d'empreintes en mode arbre :"

#: library/hashlib.rst:447
msgid "*fanout*: fanout (0 to 255, 0 if unlimited, 1 in sequential mode)."
msgstr ""
"*fanout* : *étalement* (0 à 255, 0 si illimité, 1 correspond au mode "
"séquentiel)."

#: library/hashlib.rst:449
msgid ""
"*depth*: maximal depth of tree (1 to 255, 255 if unlimited, 1 in sequential "
"mode)."
msgstr ""
"*depth* : profondeur maximale de l'arbre (1 à 255, 255 si illimité, 1 "
"correspond au mode séquentiel)."

#: library/hashlib.rst:452
msgid ""
"*leaf_size*: maximal byte length of leaf (0 to ``2**32-1``, 0 if unlimited "
"or in sequential mode)."
msgstr ""
"*leaf_size* : taille maximale en octets d'une feuille (0 à ``2**32-1``, 0 si "
"illimité ou en mode séquentiel)."

#: library/hashlib.rst:455
msgid ""
"*node_offset*: node offset (0 to ``2**64-1`` for BLAKE2b, 0 to ``2**48-1`` "
"for BLAKE2s, 0 for the first, leftmost, leaf, or in sequential mode)."
msgstr ""
"*node_offset* : décalage du nœud (0 à ``2**64-1`` pour BLAKE2b, 0 à "
"``2**48-1`` pour BLAKE2s, 0 pour la première feuille la plus à gauche, ou en "
"mode séquentiel)."

#: library/hashlib.rst:458
msgid ""
"*node_depth*: node depth (0 to 255, 0 for leaves, or in sequential mode)."
msgstr ""
"*node_depth* : profondeur du nœud (0 à 255, 0 pour les feuilles, ou en mode "
"séquentiel)."

#: library/hashlib.rst:460
msgid ""
"*inner_size*: inner digest size (0 to 64 for BLAKE2b, 0 to 32 for BLAKE2s, 0 "
"in sequential mode)."
msgstr ""
"*inner_size* : taille de l'empreinte interne (0 à 64 pour BLAKE2b, 0 à 32 "
"pour BLAKE2s, 0 en mode séquentiel)."

#: library/hashlib.rst:463
msgid ""
"*last_node*: boolean indicating whether the processed node is the last one "
"(``False`` for sequential mode)."
msgstr ""
"*last_node* : booléen indiquant si le nœud traité est le dernier (``False`` "
"pour le mode séquentiel)."

#: library/hashlib.rst:466
msgid "Explanation of tree mode parameters."
msgstr "Explication des paramètres du mode arbre."

#: library/hashlib.rst:470
msgid ""
"See section 2.10 in `BLAKE2 specification <https://www.blake2.net/"
"blake2_20130129.pdf>`_ for comprehensive review of tree hashing."
msgstr ""
"Voir la section 2.10 dans `BLAKE2 specification <https://blake2.net/"
"blake2_20130129.pdf>`_ pour une approche globale du hachage en mode arbre."

#: library/hashlib.rst:476
msgid "Constants"
msgstr "Constantes"

#: library/hashlib.rst:481
msgid "Salt length (maximum length accepted by constructors)."
msgstr "Longueur du sel (longueur maximale acceptée par les constructeurs)."

#: library/hashlib.rst:487
msgid ""
"Personalization string length (maximum length accepted by constructors)."
msgstr ""
"Longueur de la chaîne de personnalisation (longueur maximale acceptée par "
"les constructeurs)."

#: library/hashlib.rst:493
msgid "Maximum key size."
msgstr "Taille maximale de clé."

#: library/hashlib.rst:499
msgid "Maximum digest size that the hash function can output."
msgstr "Taille maximale du message que peut fournir la fonction de hachage."

#: library/hashlib.rst:503
msgid "Examples"
msgstr "Exemples"

#: library/hashlib.rst:506
msgid "Simple hashing"
msgstr "Hachage simple"

#: library/hashlib.rst:508
msgid ""
"To calculate hash of some data, you should first construct a hash object by "
"calling the appropriate constructor function (:func:`blake2b` or :func:"
"`blake2s`), then update it with the data by calling :meth:`~hash.update` on "
"the object, and, finally, get the digest out of the object by calling :meth:"
"`~hash.digest` (or :meth:`~hash.hexdigest` for hex-encoded string)."
msgstr ""
"Pour calculer l'empreinte (ou *hash*) d'une quantité de données, vous devez "
"d'abord construire un objet de calcul d'empreinte en appelant la fonction "
"constructeur appropriée (:func:`blake2b` or :func:`blake2s`), ensuite le "
"mettre à jour avec les données en appelant la méthode :meth:`~hash.update` "
"sur l'objet, et, pour finir, récupérer l'empreinte du message en appelant la "
"méthode :meth:`~hash.digest` (ou :meth:`~hash.hexdigest` pour les chaînes "
"hexadécimales)."

#: library/hashlib.rst:521
msgid ""
"As a shortcut, you can pass the first chunk of data to update directly to "
"the constructor as the positional argument:"
msgstr ""
"En plus court, vous pouvez passer directement au constructeur, comme "
"argument positionnel, le premier morceau du message pour le mettre "
"directement à jour :"

#: library/hashlib.rst:528
msgid ""
"You can call :meth:`hash.update` as many times as you need to iteratively "
"update the hash:"
msgstr ""
"Vous pouvez appeler la méthode :meth:`hash.update` autant de fois que "
"nécessaire pour mettre à jour l'empreinte de manière itérative :"

#: library/hashlib.rst:542
msgid "Using different digest sizes"
msgstr "Production de tailles d'empreintes différentes"

#: library/hashlib.rst:544
msgid ""
"BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to "
"32 bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without "
"changing the size of output, we can tell BLAKE2b to produce 20-byte digests:"
msgstr ""
"BLAKE2 permet de configurer la taille des empreintes jusqu'à 64 octets pour "
"BLAKE2b et jusqu'à 32 octets pour BLAKE2s. Par exemple, pour remplacer SHA-1 "
"par BLAKE2b sans changer la taille de la sortie, nous pouvons dire à BLAKE2b "
"de produire une empreinte de 20 octets :"

#: library/hashlib.rst:558
msgid ""
"Hash objects with different digest sizes have completely different outputs "
"(shorter hashes are *not* prefixes of longer hashes); BLAKE2b and BLAKE2s "
"produce different outputs even if the output length is the same:"
msgstr ""
"Les objets de calcul d'empreinte initialisés avec des tailles d'empreintes "
"différentes ont des sorties complètement différentes (les condensats courts "
"*ne sont pas* des préfixes de condensats plus longs) ; BLAKE2b et BLAKE2s "
"produisent des sorties différentes même si les longueurs de sortie sont les "
"mêmes :"

#: library/hashlib.rst:574
msgid "Keyed hashing"
msgstr "Hachage avec clé – Code d'authentification de message"

#: library/hashlib.rst:576
msgid ""
"Keyed hashing can be used for authentication as a faster and simpler "
"replacement for `Hash-based message authentication code <https://en."
"wikipedia.org/wiki/HMAC>`_ (HMAC). BLAKE2 can be securely used in prefix-MAC "
"mode thanks to the indifferentiability property inherited from BLAKE."
msgstr ""
"Le hachage avec clé (*keyed hashing* en anglais) est une alternative plus "
"simple et plus rapide à un `code d’authentification de message de hachage à "
"clé <https://fr.wikipedia.org/wiki/Keyed-hash_message_authentication_code>`_ "
"(HMAC). BLAKE2 peut être utilisé de manière sécurisée dans le mode préfixe "
"MAC grâce à la propriété d'indifférentiabilité héritée de BLAKE."

#: library/hashlib.rst:582
msgid ""
"This example shows how to get a (hex-encoded) 128-bit authentication code "
"for message ``b'message data'`` with key ``b'pseudorandom key'``::"
msgstr ""
"Cet exemple montre comment obtenir un code d'authentification de message de "
"128 bits (en hexadécimal) pour un message ``b'message data'`` avec la clé "
"``b'pseudorandom key'`` ::"

#: library/hashlib.rst:592
msgid ""
"As a practical example, a web application can symmetrically sign cookies "
"sent to users and later verify them to make sure they weren't tampered with::"
msgstr ""
"Comme exemple pratique, une application web peut chiffrer symétriquement les "
"*cookies* envoyés aux utilisateurs et les vérifier plus tard pour être "
"certaine qu'ils n'ont pas été altérés ::"

#: library/hashlib.rst:621
msgid ""
"Even though there's a native keyed hashing mode, BLAKE2 can, of course, be "
"used in HMAC construction with :mod:`hmac` module::"
msgstr ""
"Même s'il possède en natif la création de code d'authentification de message "
"(MAC), BLAKE2 peut, bien sûr, être utilisé pour construire un HMAC en "
"combinaison avec le module :mod:`hmac` ::"

#: library/hashlib.rst:632
msgid "Randomized hashing"
msgstr "Hachage randomisé"

#: library/hashlib.rst:634
msgid ""
"By setting *salt* parameter users can introduce randomization to the hash "
"function. Randomized hashing is useful for protecting against collision "
"attacks on the hash function used in digital signatures."
msgstr ""
"En définissant le paramètre *salt* les utilisateurs peuvent introduire de "
"l'aléatoire dans la fonction de hachage. Le hachage randomisé est utile pour "
"se protéger des attaques par collisions sur les fonctions de hachage "
"utilisées dans les signatures numériques."

#: library/hashlib.rst:638
msgid ""
"Randomized hashing is designed for situations where one party, the message "
"preparer, generates all or part of a message to be signed by a second party, "
"the message signer. If the message preparer is able to find cryptographic "
"hash function collisions (i.e., two messages producing the same hash value), "
"then they might prepare meaningful versions of the message that would "
"produce the same hash value and digital signature, but with different "
"results (e.g., transferring $1,000,000 to an account, rather than $10). "
"Cryptographic hash functions have been designed with collision resistance as "
"a major goal, but the current concentration on attacking cryptographic hash "
"functions may result in a given cryptographic hash function providing less "
"collision resistance than expected. Randomized hashing offers the signer "
"additional protection by reducing the likelihood that a preparer can "
"generate two or more messages that ultimately yield the same hash value "
"during the digital signature generation process --- even if it is practical "
"to find collisions for the hash function. However, the use of randomized "
"hashing may reduce the amount of security provided by a digital signature "
"when all portions of the message are prepared by the signer."
msgstr ""
"Le hachage aléatoire est conçu pour les situations où une partie, le "
"préparateur du message, génère tout ou partie d'un message à signer par une "
"seconde partie, le signataire du message. Si le préparateur du message est "
"capable de trouver des collisions sur la fonction cryptographique de hachage "
"(c.-à-d. deux messages produisant la même valeur une fois hachés), alors il "
"peut préparer plusieurs versions du message, ayant un sens, qui produiront "
"les mêmes empreintes et même signature mais avec des résultats différents "
"(par exemple transférer 1 000 000 $ sur un compte plutôt que 10 $). Les "
"fonctions cryptographiques de hachage ont été conçues avec comme but premier "
"de résister aux collisions, mais la concentration actuelle d'attaques sur "
"les fonctions de hachage peut avoir pour conséquence qu'une fonction de "
"hachage donnée soit moins résistante qu'attendu. Le hachage aléatoire offre "
"au signataire une protection supplémentaire en réduisant la probabilité que "
"le préparateur puisse générer deux messages ou plus qui renverront la même "
"empreinte lors du processus de génération de la signature — même s'il existe "
"un moyen pratique de trouver des collisions sur la fonction de hachage. "
"Toutefois, l'utilisation du hachage aléatoire peut réduire le niveau de "
"sécurité fourni par une signature numérique si  tous les morceaux du message "
"sont préparés par le signataire."

#: library/hashlib.rst:657
msgid ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" <https://"
"csrc.nist.gov/pubs/sp/800/106/final>`_)"
msgstr ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" <https://"
"csrc.nist.gov/pubs/sp/800/106/final>`_, article en anglais)"

#: library/hashlib.rst:660
msgid ""
"In BLAKE2 the salt is processed as a one-time input to the hash function "
"during initialization, rather than as an input to each compression function."
msgstr ""
"Dans BLAKE2, le sel est passé une seule fois lors de l'initialisation de la "
"fonction de hachage, plutôt qu'à chaque appel de la fonction de hachage."

#: library/hashlib.rst:665
msgid ""
"*Salted hashing* (or just hashing) with BLAKE2 or any other general-purpose "
"cryptographic hash function, such as SHA-256, is not suitable for hashing "
"passwords.  See `BLAKE2 FAQ <https://www.blake2.net/#qa>`_ for more "
"information."
msgstr ""
"*Salted hashing* (ou un hachage simple) avec BLAKE2 ou toute autre fonction "
"de hachage générique, comme SHA-256, ne convient pas pour obscurcir des mots "
"de passe. Voir `la FAQ BLAKE2 <https://blake2.net/#qa>`_ (page en anglais) "
"pour plus d'informations."

#: library/hashlib.rst:688
msgid "Personalization"
msgstr "Personnalisation"

#: library/hashlib.rst:690
msgid ""
"Sometimes it is useful to force hash function to produce different digests "
"for the same input for different purposes. Quoting the authors of the Skein "
"hash function:"
msgstr ""
"Parfois il est utile de forcer une fonction de hachage à produire "
"différentes empreintes de message d'une même entrée pour différentes "
"utilisations. Pour citer les auteurs de la fonction de hachage Skein :"

#: library/hashlib.rst:694
msgid ""
"We recommend that all application designers seriously consider doing this; "
"we have seen many protocols where a hash that is computed in one part of the "
"protocol can be used in an entirely different part because two hash "
"computations were done on similar or related data, and the attacker can "
"force the application to make the hash inputs the same. Personalizing each "
"hash function used in the protocol summarily stops this type of attack."
msgstr ""
"Nous recommandons que tous les développeurs d'application considèrent "
"sérieusement de faire cela ; nous avons vu de nombreux protocoles où une "
"empreinte était calculée à un endroit du protocole pour être utilisée à un "
"autre endroit car deux calculs d'empreintes étaient réalisés sur des données "
"similaires ou liées, et qu'un attaquant peut forcer une application à "
"prendre en entrée la même empreinte. Personnaliser chaque fonction de "
"hachage utilisée dans le protocole stoppe immédiatement ce genre d'attaque."

#: library/hashlib.rst:701
msgid ""
"(`The Skein Hash Function Family <https://www.schneier.com/wp-content/"
"uploads/2016/02/skein.pdf>`_, p. 21)"
msgstr ""
"(`The Skein Hash Function Family <https://www.schneier.com/wp-content/"
"uploads/2016/02/skein.pdf>`_, p. 21, article en anglais)"

#: library/hashlib.rst:705
msgid "BLAKE2 can be personalized by passing bytes to the *person* argument::"
msgstr ""
"BLAKE2 peut être personnalisé en passant des *bytes* à l'argument *person* ::"

#: library/hashlib.rst:719
msgid ""
"Personalization together with the keyed mode can also be used to derive "
"different keys from a single one."
msgstr ""
"La personnalisation et le *keyed mode* peuvent être utilisés ensemble pour "
"dériver différentes clés à partir d'une seule."

#: library/hashlib.rst:733
msgid "Tree mode"
msgstr "Mode Arbre"

#: library/hashlib.rst:735
msgid "Here's an example of hashing a minimal tree with two leaf nodes::"
msgstr ""
"L'exemple ci-dessous présente comment hacher un arbre minimal avec deux "
"nœuds terminaux ::"

#: library/hashlib.rst:741
msgid ""
"This example uses 64-byte internal digests, and returns the 32-byte final "
"digest::"
msgstr ""
"Cet exemple utilise en interne des empreintes de 64 octets, et produit "
"finalement des empreintes 32 octets ::"

#: library/hashlib.rst:771
msgid "Credits"
msgstr "Crédits"

#: library/hashlib.rst:773
msgid ""
"BLAKE2_ was designed by *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn*, and *Christian Winnerlein* based on SHA-3_ finalist BLAKE_ "
"created by *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier*, and "
"*Raphael C.-W. Phan*."
msgstr ""
"BLAKE2_ a été conçu par *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn*, et *Christian Winnerlein*. Il est basé la version BLAKE_ "
"qui a participé à la finale de la compétition du NIST SHA-3_ créée par *Jean-"
"Philippe Aumasson*, *Luca Henzen*, *Willi Meier*, et *Raphael C.-W. Phan*."

#: library/hashlib.rst:778
msgid ""
"It uses core algorithm from ChaCha_ cipher designed by *Daniel J.  "
"Bernstein*."
msgstr ""
"Il utilise le cœur de l'algorithme de chiffrement de ChaCha_ conçu par "
"*Daniel J.  Bernstein*."

#: library/hashlib.rst:780
msgid ""
"The stdlib implementation is based on pyblake2_ module. It was written by "
"*Dmitry Chestnykh* based on C implementation written by *Samuel Neves*. The "
"documentation was copied from pyblake2_ and written by *Dmitry Chestnykh*."
msgstr ""
"L'implémentation dans la bibliothèque standard est basée sur le module "
"pyblake2_. Elle a été écrite par *Dmitry Chestnykh* et est basée sur "
"l'implémentation C écrite par *Samuel Neves*. La documentation a été copiée "
"depuis pyblake2_ et écrite par *Dmitry Chestnykh*."

#: library/hashlib.rst:784
msgid "The C code was partly rewritten for Python by *Christian Heimes*."
msgstr ""
"Le code C a été partiellement réécrit pour Python par *Christian Heimes*."

#: library/hashlib.rst:786
msgid ""
"The following public domain dedication applies for both C hash function "
"implementation, extension code, and this documentation:"
msgstr ""
"Le transfert dans le domaine public s'applique pour l'implémentation C de la "
"fonction de hachage, ses extensions et cette documentation :"

#: library/hashlib.rst:789
msgid ""
"To the extent possible under law, the author(s) have dedicated all copyright "
"and related and neighboring rights to this software to the public domain "
"worldwide. This software is distributed without any warranty."
msgstr ""
"Tout en restant dans les limites de la loi, le(s) auteur(s) a (ont) donné "
"tous les droits d’auteur et droits connexes et voisins de ce logiciel au "
"domaine public dans le monde entier. Ce logiciel est distribué sans aucune "
"garantie."

#: library/hashlib.rst:793
msgid ""
"You should have received a copy of the CC0 Public Domain Dedication along "
"with this software. If not, see https://creativecommons.org/publicdomain/"
"zero/1.0/."
msgstr ""
"Vous devriez recevoir avec ce logiciel une copie de la licence *CC0 Public "
"Domain Dedication*. Sinon, voir https://creativecommons.org/publicdomain/"
"zero/1.0/."

#: library/hashlib.rst:797
msgid ""
"The following people have helped with development or contributed their "
"changes to the project and the public domain according to the Creative "
"Commons Public Domain Dedication 1.0 Universal:"
msgstr ""
"Les personnes suivantes ont aidé au développement ou contribué aux "
"modifications du projet et au domaine public selon la licence Creative "
"Commons Public Domain Dedication 1.0 Universal :"

#: library/hashlib.rst:801
msgid "*Alexandr Sokolovskiy*"
msgstr "*Alexandr Sokolovskiy*"

#: library/hashlib.rst:821
msgid "Module :mod:`hmac`"
msgstr "Module :mod:`hmac`"

#: library/hashlib.rst:822
msgid "A module to generate message authentication codes using hashes."
msgstr ""
"Un module pour générer des codes d'authentification utilisant des *hash*."

#: library/hashlib.rst:824
msgid "Module :mod:`base64`"
msgstr "Module :mod:`base64`"

#: library/hashlib.rst:825
msgid "Another way to encode binary hashes for non-binary environments."
msgstr ""
"Un autre moyen d'encoder des *hash* binaires dans des environnements non "
"binaires."

#: library/hashlib.rst:827
msgid "https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf"
msgstr "https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf"

#: library/hashlib.rst:828
msgid "The FIPS 180-4 publication on Secure Hash Algorithms."
msgstr "La publication FIPS 180-4 sur les algorithmes de hachage sécurisés."

#: library/hashlib.rst:830
msgid "https://csrc.nist.gov/pubs/fips/202/final"
msgstr "https://csrc.nist.gov/pubs/fips/202/final"

#: library/hashlib.rst:831
msgid "The FIPS 202 publication on the SHA-3 Standard."
msgstr "La publication FIPS 202 sur le standard SHA-3."

#: library/hashlib.rst:833
msgid "https://www.blake2.net/"
msgstr "https://www.blake2.net/"

#: library/hashlib.rst:834
msgid "Official BLAKE2 website."
msgstr "Site officiel de BLAKE2."

#: library/hashlib.rst:836
msgid "https://en.wikipedia.org/wiki/Cryptographic_hash_function"
msgstr "https://en.wikipedia.org/wiki/Cryptographic_hash_function"

#: library/hashlib.rst:837
msgid ""
"Wikipedia article with information on which algorithms have known issues and "
"what that means regarding their use."
msgstr ""
"Article Wikipedia contenant les informations relatives aux algorithmes ayant "
"des problèmes et leur interprétation au regard de leur utilisation."

#: library/hashlib.rst:840
msgid "https://www.ietf.org/rfc/rfc8018.txt"
msgstr "https://www.ietf.org/rfc/rfc8018.txt"

#: library/hashlib.rst:841
msgid "PKCS #5: Password-Based Cryptography Specification Version 2.1"
msgstr "PKCS #5 : Password-Based Cryptography Specification Version 2.1"

#: library/hashlib.rst:843
msgid ""
"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"
msgstr ""
"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"

#: library/hashlib.rst:844
msgid "NIST Recommendation for Password-Based Key Derivation."
msgstr ""
"Recommandations du NIST pour la dérivation de clé à partir de mot de passe "
"(ressource en anglais)."

#~ msgid "OpenSSL"
#~ msgstr "OpenSSL"

# suit un :
#~ msgid ":func:`blake2b` and :func:`blake2s` were added."
#~ msgstr "les fonctions :func:`blake2b` et :func:`blake2s` ont été ajoutées."

# suit un :
#~ msgid ""
#~ "The Python GIL is released to allow other threads to run while hash "
#~ "updates on data larger than 2047 bytes is taking place when using hash "
#~ "algorithms supplied by OpenSSL."
#~ msgstr ""
#~ "le GIL Python est relâché pour permettre aux autres fils d'exécution de "
#~ "tourner pendant que la fonction de hachage met à jour des données plus "
#~ "longues que 2047 octets, lorsque les algorithmes fournis par OpenSSL sont "
#~ "utilisés."

# suit un :
#~ msgid ""
#~ "A fast implementation of *pbkdf2_hmac* is available with OpenSSL.  The "
#~ "Python implementation uses an inline version of :mod:`hmac`. It is about "
#~ "three times slower and doesn't release the GIL."
#~ msgstr ""
#~ "une implémentation rapide de *pbkdf2_hmac* est disponible avec OpenSSL. "
#~ "L'implémentation Python utilise une version *inline* de :mod:`hmac`. Elle "
#~ "est trois fois plus lente et ne libère pas le GIL."

# suit un :
#~ msgid ""
#~ "Slow Python implementation of *pbkdf2_hmac* is deprecated. In the future "
#~ "the function will only be available when Python is compiled with OpenSSL."
#~ msgstr ""
#~ "l'implémentation en Python (lente) de *pbkdf2_hmac* est obsolète. À "
#~ "l'avenir, la fonction ne sera disponible que lorsque Python est compilé "
#~ "avec OpenSSL."

# suit un :
#~ msgid ""
#~ "Feeding string objects into :meth:`update` is not supported, as hashes "
#~ "work on bytes, not on characters."
#~ msgstr ""
#~ "fournir des objets chaînes de caractères à la méthode :meth:`update` "
#~ "n'est pas implémenté, comme les fonctions de hachages travaillent sur des "
#~ "*bytes* et pas sur des caractères."

#~ msgid ""
#~ "https://csrc.nist.gov/csrc/media/publications/fips/180/2/"
#~ "archive/2002-08-01/documents/fips180-2.pdf"
#~ msgstr ""
#~ "https://csrc.nist.gov/csrc/media/publications/fips/180/2/"
#~ "archive/2002-08-01/documents/fips180-2.pdf"

#~ msgid ""
#~ "The number of *iterations* should be chosen based on the hash algorithm "
#~ "and computing power. As of 2013, at least 100,000 iterations of SHA-256 "
#~ "are suggested."
#~ msgstr ""
#~ "Le nombre d'*iterations* doit être choisi sur la base de l'algorithme de "
#~ "hachage et de la puissance de calcul. En 2013, au moins 100000 itérations "
#~ "de SHA-256 sont recommandées."

#~ msgid ":ref:`Availability <availability>`: OpenSSL 1.1+."
#~ msgstr ":ref:`Disponibilité <availability>` : OpenSSL 1.1+."
