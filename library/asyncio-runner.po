# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-01 00:16+0100\n"
"PO-Revision-Date: 2023-06-29 21:12+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/asyncio-runner.rst:6
msgid "Runners"
msgstr "Exécuteurs (*runners*)"

#: library/asyncio-runner.rst:8
msgid "**Source code:** :source:`Lib/asyncio/runners.py`"
msgstr "**Code source :** :source:`Lib/asyncio/runners.py`"

#: library/asyncio-runner.rst:11
msgid ""
"This section outlines high-level asyncio primitives to run asyncio code."
msgstr ""
"Cette section décrit les primitives *asyncio* de haut niveau pour exécuter "
"du code asynchrone."

#: library/asyncio-runner.rst:13
msgid ""
"They are built on top of an :ref:`event loop <asyncio-event-loop>` with the "
"aim to simplify async code usage for common wide-spread scenarios."
msgstr ""
"Elles sont construites au-dessus d'une :ref:`boucle d'événements <asyncio-"
"event-loop>` dans le but de simplifier l'utilisation du code asynchrone pour "
"les scénarios les plus courants."

#: library/asyncio-runner.rst:23
msgid "Running an asyncio Program"
msgstr "Exécution d'un programme asynchrone"

#: library/asyncio-runner.rst:27
msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr "Exécute la :term:`coroutine` *coro* et renvoie le résultat."

#: library/asyncio-runner.rst:29
#, fuzzy
msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio "
"event loop, *finalizing asynchronous generators*, and closing the executor."
msgstr ""
"Cette fonction exécute la coroutine transmise, en s'occupant de gérer la "
"boucle d'événements *asyncio*, de *finaliser les générateurs asynchrones* et "
"de terminer correctement les fils d'exécution."

#: library/asyncio-runner.rst:115
msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""
"Cette fonction ne peut pas être appelée lorsqu'une autre boucle d'événement "
"asynchrone est en cours d'exécution dans le même fil d'exécution."

#: library/asyncio-runner.rst:85
msgid ""
"If *debug* is ``True``, the event loop will be run in debug mode. ``False`` "
"disables debug mode explicitly. ``None`` is used to respect the global :ref:"
"`asyncio-debug-mode` settings."
msgstr ""
"Si *debug* vaut ``True``, la boucle d'événements est exécutée en mode "
"débogage. ``False`` désactive explicitement le mode débogage. ``None`` est "
"utilisée pour respecter les paramètres globaux définis par :ref:`asyncio-"
"debug-mode`."

#: library/asyncio-runner.rst:40
msgid ""
"If *loop_factory* is not ``None``, it is used to create a new event loop; "
"otherwise :func:`asyncio.new_event_loop` is used. The loop is closed at the "
"end. This function should be used as a main entry point for asyncio "
"programs, and should ideally only be called once. It is recommended to use "
"*loop_factory* to configure the event loop instead of policies. Passing :"
"class:`asyncio.EventLoop` allows running asyncio without the policy system."
msgstr ""

#: library/asyncio-runner.rst:48
msgid ""
"The executor is given a timeout duration of 5 minutes to shutdown. If the "
"executor hasn't finished within that duration, a warning is emitted and the "
"executor is closed."
msgstr ""

#: library/asyncio-runner.rst:52
msgid "Example::"
msgstr "Exemple ::"

# suit un :
#: library/asyncio-runner.rst:62
msgid "Updated to use :meth:`loop.shutdown_default_executor`."
msgstr "mise à jour pour utiliser :meth:`loop.shutdown_default_executor`."

#: library/asyncio-runner.rst:67
msgid ""
"*debug* is ``None`` by default to respect the global debug mode settings."
msgstr ""
"*debug* vaut ``None`` par défaut pour respecter les paramètres du mode de "
"débogage global."

#: library/asyncio-runner.rst:71
msgid "Added *loop_factory* parameter."
msgstr ""

#: library/asyncio-runner.rst:75
msgid "Runner context manager"
msgstr "Gestionnaire de contexte de l'exécuteur"

#: library/asyncio-runner.rst:79
msgid ""
"A context manager that simplifies *multiple* async function calls in the "
"same context."
msgstr ""
"Gestionnaire de contexte englobant *plusieurs* appels de fonctions "
"asynchrones dans le même contexte."

#: library/asyncio-runner.rst:82
msgid ""
"Sometimes several top-level async functions should be called in the same :"
"ref:`event loop <asyncio-event-loop>` and :class:`contextvars.Context`."
msgstr ""
"Parfois, plusieurs fonctions asynchrones de niveau supérieur doivent être "
"appelées dans la même :ref:`boucle d'événements <asyncio-event-loop>` et le "
"même :class:`contextvars.Context`."

#: library/asyncio-runner.rst:89
msgid ""
"*loop_factory* could be used for overriding the loop creation. It is the "
"responsibility of the *loop_factory* to set the created loop as the current "
"one. By default :func:`asyncio.new_event_loop` is used and set as current "
"event loop with :func:`asyncio.set_event_loop` if *loop_factory* is ``None``."
msgstr ""
"*loop_factory* peut être utilisée pour remplacer la création de la boucle. "
"*loop_factory* a la responsabilité de définir la boucle créée comme boucle "
"courante. Par défaut :func:`asyncio.new_event_loop` est utilisée et définie "
"comme boucle d'événements actuelle avec :func:`asyncio.set_event_loop` si "
"*loop_factory* vaut ``None``."

#: library/asyncio-runner.rst:94
#, fuzzy
msgid ""
"Basically, :func:`asyncio.run` example can be rewritten with the runner "
"usage::"
msgstr ""
"Fondamentalement, l'exemple :func:`asyncio.run()` peut être réécrit avec "
"l'utilisation de l'exécuteur suivant ::"

#: library/asyncio-runner.rst:107
msgid "Run a :term:`coroutine <coroutine>` *coro* in the embedded loop."
msgstr ""
"Exécute la :term:`coroutine <coroutine>` *coro* dans la boucle d'événements "
"en cours."

#: library/asyncio-runner.rst:109
msgid "Return the coroutine's result or raise its exception."
msgstr "Renvoie le résultat de la coroutine ou lève les exceptions afférentes."

#: library/asyncio-runner.rst:111
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The runner's default "
"context is used if ``None``."
msgstr ""
"L'argument (uniquement nommé) facultatif *context* permet de spécifier un :"
"class:`contextvars.Context` personnalisé pour la coroutine à exécuter. Le "
"contexte par défaut de l'exécuteur est utilisé si *context* est ``None``."

#: library/asyncio-runner.rst:120
msgid "Close the runner."
msgstr "Termine l'exécuteur."

#: library/asyncio-runner.rst:122
msgid ""
"Finalize asynchronous generators, shutdown default executor, close the event "
"loop and release embedded :class:`contextvars.Context`."
msgstr ""
"Finalise les générateurs asynchrones, arrête l'exécuteur par défaut, ferme "
"la boucle d'événements et libère le :class:`contextvars.Context` en cours."

#: library/asyncio-runner.rst:127
msgid "Return the event loop associated with the runner instance."
msgstr "Renvoie la boucle d'événements associée à l'instance de l'exécuteur."

#: library/asyncio-runner.rst:131
msgid ""
":class:`Runner` uses the lazy initialization strategy, its constructor "
"doesn't initialize underlying low-level structures."
msgstr ""
":class:`Runner` utilise la stratégie d'initialisation paresseuse, son "
"constructeur n'initialise pas les structures de bas niveau sous-jacentes."

#: library/asyncio-runner.rst:134
msgid ""
"Embedded *loop* and *context* are created at the :keyword:`with` body "
"entering or the first call of :meth:`run` or :meth:`get_loop`."
msgstr ""
"La  boucle d'événements *loop* et le *context* intégrés sont créés à "
"l'entrée du corps de :keyword:`with` ou au premier appel de :meth:`run` ou :"
"meth:`get_loop`."

#: library/asyncio-runner.rst:139
msgid "Handling Keyboard Interruption"
msgstr "Gestion de l'interruption par le clavier"

#: library/asyncio-runner.rst:143
msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, :exc:"
"`KeyboardInterrupt` exception is raised in the main thread by default. "
"However this doesn't work with :mod:`asyncio` because it can interrupt "
"asyncio internals and can hang the program from exiting."
msgstr ""
"Lorsque :const:`signal.SIGINT` est déclenché par :kbd:`Ctrl-C`, l'exception :"
"exc:`KeyboardInterrupt` est levée par défaut dans le fils d'exécution "
"principal. Cependant, cela ne fonctionne pas avec :mod:`asyncio` car cela "
"peut interrompre le fonctionnement interne de *asyncio* et empêcher le "
"programme de se terminer."

#: library/asyncio-runner.rst:148
msgid ""
"To mitigate this issue, :mod:`asyncio` handles :const:`signal.SIGINT` as "
"follows:"
msgstr ""
"Pour contrer ce problème, :mod:`asyncio` gère :const:`signal.SIGINT` comme "
"suit :"

#: library/asyncio-runner.rst:150
msgid ""
":meth:`asyncio.Runner.run` installs a custom :const:`signal.SIGINT` handler "
"before any user code is executed and removes it when exiting from the "
"function."
msgstr ""
":meth:`asyncio.Runner.run` installe un gestionnaire :const:`signal.SIGINT` "
"personnalisé avant l'exécution de tout code utilisateur et le supprime à la "
"sortie de la fonction."

#: library/asyncio-runner.rst:152
msgid ""
"The :class:`~asyncio.Runner` creates the main task for the passed coroutine "
"for its execution."
msgstr ""
"Le :class:`~asyncio.Runner` crée la tâche principale pour la coroutine "
"transmise pour son exécution."

#: library/asyncio-runner.rst:154
msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, the custom signal "
"handler cancels the main task by calling :meth:`asyncio.Task.cancel` which "
"raises :exc:`asyncio.CancelledError` inside the main task.  This causes the "
"Python stack to unwind, ``try/except`` and ``try/finally`` blocks can be "
"used for resource cleanup.  After the main task is cancelled, :meth:`asyncio."
"Runner.run` raises :exc:`KeyboardInterrupt`."
msgstr ""
"Lorsque :const:`signal.SIGINT` est déclenché par :kbd:`Ctrl-C`, le "
"gestionnaire de signal personnalisé annule la tâche principale en appelant :"
"meth:`asyncio.Task.cancel` qui lève :exc:`asyncio.CancelledError` à "
"l'intérieur de la tâche principale. Cela entraîne la remontée dans la pile "
"Python, les blocs ``try/except`` et ``try/finally`` peuvent être utilisés "
"pour le nettoyage des ressources. Une fois la tâche principale annulée, :"
"meth:`asyncio.Runner.run` lève :exc:`KeyboardInterrupt`."

#: library/asyncio-runner.rst:160
msgid ""
"A user could write a tight loop which cannot be interrupted by :meth:"
"`asyncio.Task.cancel`, in which case the second following :kbd:`Ctrl-C` "
"immediately raises the :exc:`KeyboardInterrupt` without cancelling the main "
"task."
msgstr ""
"Un utilisateur peut écrire une boucle tellement petite qu'elle ne peut pas "
"être interrompue par :meth:`asyncio.Task.cancel` ; dans ce cas la seconde "
"suivante :kbd:`Ctrl-C` lève immédiatement le :exc:`KeyboardInterrupt` sans "
"annuler la tâche principale."

#~ msgid ""
#~ "This function always creates a new event loop and closes it at the end.  "
#~ "It should be used as a main entry point for asyncio programs, and should "
#~ "ideally only be called once."
#~ msgstr ""
#~ "Cette fonction crée toujours une nouvelle boucle d'événements et la ferme "
#~ "à la fin. Elle doit être utilisée comme point d'entrée principal pour les "
#~ "programmes asynchrones et ne doit idéalement être appelée qu'une seule "
#~ "fois."
