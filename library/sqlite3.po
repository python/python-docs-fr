# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-01 00:16+0100\n"
"PO-Revision-Date: 2023-08-21 17:17+0200\n"
"Last-Translator: Julien Palard <julien@palard.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.3.1\n"

#: library/sqlite3.rst:2
#, fuzzy
msgid ":mod:`!sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`sqlite3` — Interface DB-API 2.0 pour bases de données SQLite"

#: library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**Code source :** :source:`Lib/sqlite3/`"

#: library/sqlite3.rst:25
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite est une bibliothèque C qui fournit une base de données légère sur "
"disque ne nécessitant pas de processus serveur et qui utilise une variante "
"(non standard) du langage de requête SQL pour accéder aux données. Certaines "
"applications peuvent utiliser SQLite pour le stockage de données internes. "
"Il est également possible de créer une application prototype utilisant "
"SQLite, puis de modifier le code pour utiliser une base de données plus "
"robuste telle que PostgreSQL ou Oracle."

#: library/sqlite3.rst:32
#, fuzzy
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`, and requires SQLite 3.15.2 or newer."
msgstr ""
"Le module :mod:`!sqlite3` a été écrit par Gerhard Häring.  Il fournit une "
"interface SQL conforme à la spécification DB-API 2.0 décrite par :pep:`249`, "
"et nécessite SQLite 3.7.15 ou une version plus récente."

#: library/sqlite3.rst:36
msgid "This document includes four main sections:"
msgstr "Ce document inclus 4 sections principales :"

#: library/sqlite3.rst:38
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ""
":ref:`tutoriel sqlite3 <sqlite3-tutorial>` explique comment utiliser le "
"module :mod:`!sqlite3`."

#: library/sqlite3.rst:39
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ""
":ref:`référence sqlite3 <sqlite3-reference>` décrit les classes et les "
"fonctions que ce module définit."

#: library/sqlite3.rst:41
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ""
":ref:`guide sqlite3 <sqlite3-howtos>` détaille comment gérer des tâches "
"spécifiques."

#: library/sqlite3.rst:42
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ""
":ref:`explications sqlite3 <sqlite3-explanation>` propose un contexte "
"détaillé du contrôle de transaction."

#: library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: library/sqlite3.rst:48
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""
"Dans la page Web de SQLite, la documentation décrit la syntaxe et les types "
"de données disponibles qui sont pris en charge par cette variante SQL."

#: library/sqlite3.rst:51
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: library/sqlite3.rst:52
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "Tutoriel, référence et exemples pour apprendre la syntaxe SQL."

#: library/sqlite3.rst:54
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` — Spécifications de l'API 2.0 pour la base de données"

#: library/sqlite3.rst:55
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP écrite par Marc-André Lemburg."

#: library/sqlite3.rst:68
msgid "Tutorial"
msgstr "Tutoriel"

#: library/sqlite3.rst:70
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"Dans ce tutoriel, vous allez créer une base de données des films des Monty "
"Python en utilisant les fonctionnalités de base de :mod:`!sqlite3`. Cela "
"nécessite une compréhension élémentaire des concepts des bases de données, "
"notamment les `curseurs`_ et les `transactions`_."

#: library/sqlite3.rst:75
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"Tout d’abord, nous devons créer une nouvelle base de données et ouvrir une "
"connexion à la base de données pour permettre à :mod:`!sqlite3` de "
"travailler avec elle. Appelez :func:`sqlite3.connect` pour créer une "
"connexion à la base de données :file:`tutorial.db` dans le répertoire de "
"travail actuel, en la créant implicitement si elle n’existe pas :"

#: library/sqlite3.rst:86
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to "
"the on-disk database."
msgstr ""
"L’objet :class:`Connection` renvoyé — ``con`` — représente la connexion à la "
"base de données sur disque."

#: library/sqlite3.rst:89
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() <Connection."
"cursor>` to create the :class:`Cursor`:"
msgstr ""
"Afin d’exécuter les instructions SQL et de récupérer les résultats des "
"requêtes SQL, nous devrons utiliser un curseur de base de données. Appelez :"
"meth:`con.cursor() <Connection.cursor>` pour créer la :class:`Cursor` :"

#: library/sqlite3.rst:97
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration "
"-- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling :meth:"
"`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"Maintenant que nous avons une connexion à la base de données et un curseur, "
"nous pouvons créer une table ``movie`` avec des colonnes pour le titre, "
"l’année de sortie et la note de la critique. Pour plus de simplicité, nous "
"pouvons simplement utiliser les noms des colonnes dans la déclaration de la "
"table — grâce à la fonctionnalité de `typage flexible <flexible typing_>`_ "
"de SQLite, spécifier les types de données est facultatif. Exécutez "
"l’instruction ``CREATE TABLE`` en appelant :meth:`cur.execute(…) <Cursor."
"execute>` :"

#: library/sqlite3.rst:113
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) <Cursor."
"execute>`, assign the result to ``res``, and call :meth:`res.fetchone() "
"<Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"Nous pouvons vérifier que la nouvelle table a été créée en interrogeant la "
"table ``sqlite_master`` intégrée à SQLite, qui devrait maintenant contenir "
"une entrée pour la définition de la table ``movie`` (voir `le schéma Table "
"<The Schema Table_>`_ pour plus de détails). Exécutez cette requête en "
"appelant :meth:`cur.execute(…) <Cursor.execute>`, affectez le résultat à "
"``res``, et appelez :meth:`res.fetchone() <Cursor.fetchone>` pour récupérer "
"la ligne résultante :"

#: library/sqlite3.rst:127
#, fuzzy
msgid ""
"We can see that the table has been created, as the query returns a :class:"
"`tuple` containing the table's name. If we query ``sqlite_master`` for a non-"
"existent table ``spam``, :meth:`!res.fetchone` will return ``None``:"
msgstr ""
"Nous pouvons voir que la table a été créée, puisque la requête retourne un :"
"class:`tuple` contenant le nom de la table. Si nous interrogeons "
"``sqlite_master`` pour une table ``spam`` inexistante, :meth:`!res."
"fetchone()`` retournera ``None`` :"

#: library/sqlite3.rst:138
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) <Cursor."
"execute>`:"
msgstr ""
"Maintenant, ajoutez deux lignes de données en tant que littéraux SQL en "
"exécutant une instruction ``INSERT``, une fois encore en appelant :meth:`cur."
"execute(…) <Cursor.execute>` :"

#: library/sqlite3.rst:150
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see :ref:`sqlite3-"
"controlling-transactions` for details). Call :meth:`con.commit() <Connection."
"commit>` on the connection object to commit the transaction:"
msgstr ""
"L’instruction ``INSERT`` ouvre implicitement une transaction, qui doit être "
"validée avant que les modifications ne soient enregistrées dans la base de "
"données (voir :ref:`contrôle des transactions SQL <sqlite3-controlling-"
"transactions>` pour plus de détails). Appelez :meth:`con.commit() "
"<Connection.commit>` sur l’objet de connexion pour valider la transaction :"

#: library/sqlite3.rst:160
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT`` "
"query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() <Cursor."
"fetchall>` to return all resulting rows:"
msgstr ""
"Nous pouvons vérifier que les données ont été insérées correctement en "
"exécutant une requête ``SELECT``. Utilisez la désormais familière :meth:`cur."
"execute(…) <Cursor.execute>` pour affecter le résultat à ``res``, et "
"appelez :meth:`res.fetchall() <Cursor.fetchall>` pour retourner toutes les "
"lignes résultantes :"

#: library/sqlite3.rst:172
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""
"Le résultat est une :class:`liste <list>` de deux :class:`!tuple`\\s, une "
"par ligne, chacun contenant la valeur ``score`` de cette ligne."

#: library/sqlite3.rst:175
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) <Cursor."
"executemany>`:"
msgstr ""
"Maintenant, insérez trois lignes supplémentaires en appelant :meth:`cur."
"executemany(…) <Cursor.executemany>` :"

#: library/sqlite3.rst:188
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>` "
"to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"Remarquez que les marqueurs ``?`` sont utilisés pour lier les ``data`` à la "
"requête. Utilisez toujours les marqueurs au lieu d’:ref:`expressions "
"formatées <tut-formatting>` pour lier les valeurs Python aux instructions "
"SQL, afin d’éviter les `injections SQL`_ (voir :ref:`placeholder SQL "
"<sqlite3-placeholders>` pour plus de détails)."

#: library/sqlite3.rst:194
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr ""
"Nous pouvons vérifier que les nouvelles lignes ont été insérées en exécutant "
"une requête ``SELECT``, cette fois-ci en itérant sur les résultats de la "
"requête :"

#: library/sqlite3.rst:208
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""
"Chaque ligne est un :class:`tuple` de deux éléments ``(année, titre)``, "
"correspondant aux colonnes sélectionnées dans la requête."

#: library/sqlite3.rst:211
msgid ""
"Finally, verify that the database has been written to disk by calling :meth:"
"`con.close() <Connection.close>` to close the existing connection, opening a "
"new one, creating a new cursor, then querying the database:"
msgstr ""
"Enfin, vérifiez que la base de données a été écrite sur le disque en "
"appelant :meth:`con.close() <Connection.close>` pour fermer la connexion "
"existante, en ouvrir une nouvelle, créer un nouveau curseur, puis interroger "
"la base de données :"

#: library/sqlite3.rst:227
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr ""
"Vous avez maintenant créé une base de données SQLite à l’aide du module :mod:"
"`!sqlite3`, inséré des données et récupéré des valeurs de plusieurs façons."

#: library/sqlite3.rst:239
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ":ref:`guide sqlite3 <sqlite3-howtos>` pour une lecture plus poussée :"

#: library/sqlite3.rst:241
msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`placeholders sqlite3 <sqlite3-placeholders>`"

#: library/sqlite3.rst:242
msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`adaptateurs sqlite3 <sqlite3-adapters>`"

#: library/sqlite3.rst:243
msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`convertisseurs sqlite3 <sqlite3-converters>`"

#: library/sqlite3.rst:615
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ""
":ref:`gestionnaire de contexte de connexion sqlite3 <sqlite3-connection-"
"context-manager>`"

#: library/sqlite3.rst:245
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`guide de fabrique de ligne sqlite3 <sqlite3-howto-row-factory>`"

#: library/sqlite3.rst:247
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ""
":ref:`explications sqlite3 <sqlite3-explanation>` pour un contexte détaillé "
"du contrôle de transaction."

#: library/sqlite3.rst:252
msgid "Reference"
msgstr "Références"

#: library/sqlite3.rst:260
msgid "Module functions"
msgstr "Fonctions du module"

#: library/sqlite3.rst:268
msgid "Open a connection to an SQLite database."
msgstr "Ouvrez une connexion à une base de données SQLite."

#: library/sqlite3.rst:0
msgid "Parameters"
msgstr "Paramètres"

#: library/sqlite3.rst:270
msgid ""
"The path to the database file to be opened. You can pass ``\":memory:\"`` to "
"create an `SQLite database existing only in memory <https://sqlite.org/"
"inmemorydb.html>`_, and open a connection to it."
msgstr ""
"Le chemin d’accès au fichier de la base de données à ouvrir. Passez ``\":"
"memory :\"`` pour créer une `base de données SQLite existant uniquement en "
"mémoire <https://sqlite.org/inmemorydb.html>`_, et ouvrir une connexion à "
"celle-ci."

#: library/sqlite3.rst:277
msgid ""
"How many seconds the connection should wait before raising an :exc:"
"`OperationalError` when a table is locked. If another connection opens a "
"transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"Le temps (en secondes) que la connexion doit attendre avant de lever une :"
"exc:`OperationalError`, si la table est verrouillée. Si une autre connexion "
"ouvre une transaction pour modifier la table, celle-ci sera verrouillée "
"jusqu’à ce que cette transaction soit validée. Par défaut, cinq secondes."

#: library/sqlite3.rst:284
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES` to enable this. Column names takes precedence over declared "
"types if both flags are set. Types cannot be detected for generated fields "
"(for example ``max(data)``), even when the *detect_types* parameter is set; :"
"class:`str` will be returned instead. By default (``0``), type detection is "
"disabled."
msgstr ""
"Contrôle si et comment les types de données non :ref:`nativement pris en "
"charge par SQLite <sqlite3-types>` sont recherchés pour être convertis en "
"types Python, en utilisant les convertisseurs enregistrés avec :func:"
"`register_converter`. Définissez-le à n’importe quelle combinaison (en "
"utilisant ``|``, opérateurs bit-à-bit OR) de :const:`PARSE_DECLTYPES` et :"
"const:`PARSE_COLNAMES` pour activer ceci. Les noms de colonnes ont la "
"priorité sur les types déclarés si les deux drapeaux sont activés. Les types "
"ne peuvent pas être détectés pour les champs générés (par exemple "
"``max(data)``), même si le paramètre *detect_types* est activé ; :class:"
"`str` sera retourné à la place. Par défaut (``0``), la détection des types "
"est désactivée."

#: library/sqlite3.rst:298
#, fuzzy
msgid ""
"Control legacy transaction handling behaviour. See :attr:`Connection."
"isolation_level` and :ref:`sqlite3-transaction-control-isolation-level` for "
"more information. Can be ``\"DEFERRED\"`` (default), ``\"EXCLUSIVE\"`` or "
"``\"IMMEDIATE\"``; or ``None`` to disable opening transactions implicitly. "
"Has no effect unless :attr:`Connection.autocommit` is set to :const:"
"`~sqlite3.LEGACY_TRANSACTION_CONTROL` (the default)."
msgstr ""
"L’attribut :attr:`~Connection.isolation_level` de la connexion, contrôlant "
"si et comment les transactions sont ouvertes implicitement. Peut être "
"``\"DEFERRED\"`` (par défaut), ``\"EXCLUSIVE\"`` ou ``\"IMMEDIATE\"`` ; ou "
"``None`` pour désactiver l’ouverture implicite des transactions. Voir :ref:"
"`contrôle des transactions sqlite3 <sqlite3-controlling-transactions>` pour "
"en savoir plus."

#: library/sqlite3.rst:308
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"Si ``True`` (par défaut), :exc:`ProgrammingError` sera levée si la connexion "
"à la base de données est utilisée par un thread autre que celui qui l’a "
"créée. Si ``False``, la connexion peut être utilisée par plusieurs threads ; "
"les opérations d’écriture devront peut-être être sérialisées par "
"l’utilisateur pour éviter la corruption des données. Voir :attr:`sécurité "
"des threads <threadsafety>` pour plus d’informations."

#: library/sqlite3.rst:317
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""
"Une sous-classe personnalisée de :class:`Connection` pour créer la "
"connexion, si ce n’est pas la classe par défaut :class:`Connection`."

#: library/sqlite3.rst:321
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ""
"Le nombre d’instructions que :mod:`!sqlite3` doit mettre en cache en interne "
"pour cette connexion, afin d’éviter les surcharges d’analyse. Par défaut, "
"128 instructions."

#: library/sqlite3.rst:326
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"Si elle a pour valeur ``True``, la base de données est interprétée comme un :"
"abbr:`URI (Uniform Resource Identifier)` avec un chemin d’accès au fichier "
"et une chaîne de requête facultative. La partie schéma *doit* être ``\"file:"
"\"``, et le chemin peut être relatif ou absolu. La chaîne d’interrogation "
"permet de passer des paramètres à SQLite, ce qui permet d’activer diverses :"
"ref:`astuces d’URI sqlite3 <sqlite3-uri-tricks>`."

#: library/sqlite3.rst:335
msgid ""
"Control :pep:`249` transaction handling behaviour. See :attr:`Connection."
"autocommit` and :ref:`sqlite3-transaction-control-autocommit` for more "
"information. *autocommit* currently defaults to :const:`~sqlite3."
"LEGACY_TRANSACTION_CONTROL`. The default will change to ``False`` in a "
"future Python release."
msgstr ""

#: library/sqlite3.rst:0
msgid "Return type"
msgstr "Type renvoyé"

#: library/sqlite3.rst:346
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""

#: library/sqlite3.rst:347
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""

#: library/sqlite3.rst:349
msgid "Added the *uri* parameter."
msgstr ""

#: library/sqlite3.rst:352
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr ""
"*database* peut maintenant aussi être un :term:`objet de type chemin <path-"
"like object>`, et pas seulement une chaîne de caractères."

#: library/sqlite3.rst:355
msgid "Added the ``sqlite3.connect/handle`` auditing event."
msgstr ""

#: library/sqlite3.rst:358
msgid "Added the *autocommit* parameter."
msgstr ""

#: library/sqlite3.rst:361
msgid ""
"Positional use of the parameters *timeout*, *detect_types*, "
"*isolation_level*, *check_same_thread*, *factory*, *cached_statements*, and "
"*uri* is deprecated. They will become keyword-only parameters in Python 3.15."
msgstr ""

#: library/sqlite3.rst:369
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is "
"performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"Renvoie ``True`` si la déclaration de la chaîne semble contenir une ou "
"plusieurs déclarations SQL complètes. Aucune vérification syntaxique ou "
"analyse syntaxique d’aucune sorte n’est effectuée, si ce n’est la "
"vérification qu’il n’y a pas de chaîne littérale non fermée et que "
"l’instruction se termine par un point-virgule."

#: library/sqlite3.rst:375
msgid "For example:"
msgstr "Exemple :"

#: library/sqlite3.rst:384
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"Cette fonction peut être utile pendant la saisie en ligne de commande pour "
"déterminer si le texte saisi semble former une instruction SQL complète, ou "
"si une saisie supplémentaire est nécessaire avant d’appeler :meth:`~Cursor."
"execute`."

#: library/sqlite3.rst:388
msgid ""
"See :func:`!runsource` in :source:`Lib/sqlite3/__main__.py` for real-world "
"use."
msgstr ""

#: library/sqlite3.rst:393
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on :data:`sys.stderr`. Use ``False`` to disable the feature again."
msgstr ""
"Activer ou désactiver les traces des fonctions de rappel. Par défaut, vous "
"n’obtiendrez pas de traces de pile d’appels dans les fonctions définies par "
"l’utilisateur, les agrégats, les convertisseurs, les fonctions de rappel des "
"mécanismes d’autorisation, etc. Si vous voulez les déboguer, vous pouvez "
"appeler cette fonction avec *flag* à ``True``. Ensuite, vous obtiendrez les "
"traces des fonctions de rappel sur :data:`sys.stderr`. Utilisez ``False`` "
"pour désactiver à nouveau cette fonctionnalité."

#: library/sqlite3.rst:402
msgid ""
"Errors in user-defined function callbacks are logged as unraisable "
"exceptions. Use an :func:`unraisable hook handler <sys.unraisablehook>` for "
"introspection of the failed callback."
msgstr ""

#: library/sqlite3.rst:408
msgid ""
"Register an *adapter* :term:`callable` to adapt the Python type *type* into "
"an SQLite type. The adapter is called with a Python object of type *type* as "
"its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""
"Enregistre un *adaptateur* :term:`callable` pour adapter le type Python "
"*type* en un type SQLite. L'adaptateur est appelé avec un objet Python de "
"type *type* comme seul argument, et doit retourner une valeur d'un :ref:"
"`type que SQLite comprend nativement <sqlite3-types>`."

#: library/sqlite3.rst:416
msgid ""
"Register the *converter* :term:`callable` to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked "
"for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""
"Enregistrer le *convertisseur* :term:`callable` pour convertir les objets "
"SQLite de type *typename* en un objet Python d'un type spécifique. Le "
"convertisseur est invoqué pour toutes les valeurs SQLite de type "
"*typename* ; on lui passe un objet :class:`bytes` et il doit retourner un "
"objet du type Python désiré. Consultez le paramètre *detect_types* de :func:"
"`connect` pour plus d'informations sur le fonctionnement de la détection de "
"type."

#: library/sqlite3.rst:424
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr ""
"Remarque : *typename* et le nom du type dans votre requête sont comparés "
"sans tenir compte de la casse."

#: library/sqlite3.rst:431
msgid "Module constants"
msgstr "Fonctions et constantes du module"

#: library/sqlite3.rst:435
msgid ""
"Set :attr:`~Connection.autocommit` to this constant to select old style (pre-"
"Python 3.12) transaction control behaviour. See :ref:`sqlite3-transaction-"
"control-isolation-level` for more information."
msgstr ""

#: library/sqlite3.rst:441
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The type name must be wrapped "
"in square brackets (``[]``)."
msgstr ""

#: library/sqlite3.rst:451
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr ""

#: library/sqlite3.rst:456
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""

#: library/sqlite3.rst:472
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr ""

#: library/sqlite3.rst:479
msgid ""
"Flags that should be returned by the *authorizer_callback* :term:`callable` "
"passed to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""

#: library/sqlite3.rst:482
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr ""

#: library/sqlite3.rst:483
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr ""

#: library/sqlite3.rst:484
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr ""

#: library/sqlite3.rst:488
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr ""

#: library/sqlite3.rst:493
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""

#: library/sqlite3.rst:499
msgid "The ``named`` DB-API parameter style is also supported."
msgstr ""

#: library/sqlite3.rst:503
#, fuzzy
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr ""
"Le numéro de version de la bibliothèque d'exécution SQLite, sous forme de "
"chaîne."

#: library/sqlite3.rst:507
#, fuzzy
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of :class:"
"`integers <int>`."
msgstr ""
"Le numéro de version de la bibliothèque d'exécution SQLite, sous forme "
"d'entier."

#: library/sqlite3.rst:512
msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based on "
"the default `threading mode <https://sqlite.org/threadsafe.html>`_ the "
"underlying SQLite library is compiled with. The SQLite threading modes are:"
msgstr ""

#: library/sqlite3.rst:517
msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr ""

#: library/sqlite3.rst:519
msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used simultaneously "
"in two or more threads."
msgstr ""

#: library/sqlite3.rst:522
msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple "
"threads with no restriction."
msgstr ""

#: library/sqlite3.rst:525
msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety levels "
"are as follows:"
msgstr ""

#: library/sqlite3.rst:529
msgid "SQLite threading mode"
msgstr ""

#: library/sqlite3.rst:529
msgid ":pep:`threadsafety <0249#threadsafety>`"
msgstr ""

#: library/sqlite3.rst:529
msgid "`SQLITE_THREADSAFE`_"
msgstr ""

#: library/sqlite3.rst:529
msgid "DB-API 2.0 meaning"
msgstr ""

#: library/sqlite3.rst:532
msgid "single-thread"
msgstr ""

#: library/sqlite3.rst:532
msgid "0"
msgstr "0"

#: library/sqlite3.rst:532
msgid "Threads may not share the module"
msgstr ""

#: library/sqlite3.rst:535
#, fuzzy
msgid "multi-thread"
msgstr "Fils d'exécution"

#: library/sqlite3.rst:538
msgid "1"
msgstr "1"

#: library/sqlite3.rst:535
msgid "2"
msgstr "2"

#: library/sqlite3.rst:535
msgid "Threads may share the module, but not connections"
msgstr ""

#: library/sqlite3.rst:538
msgid "serialized"
msgstr ""

#: library/sqlite3.rst:538
msgid "3"
msgstr "3"

#: library/sqlite3.rst:538
msgid "Threads may share the module, connections and cursors"
msgstr ""

#: library/sqlite3.rst:544
msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr ""

#: library/sqlite3.rst:549
#, fuzzy
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr ""
"Le numéro de version de ce module, sous forme de chaîne. Ce n'est pas la "
"version de la bibliothèque SQLite."

#: library/sqlite3.rst:562
msgid ""
"This constant used to reflect the version number of the ``pysqlite`` "
"package, a third-party library which used to upstream changes to :mod:`!"
"sqlite3`. Today, it carries no meaning or practical value."
msgstr ""

#: library/sqlite3.rst:559
#, fuzzy
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr ""
"Le numéro de version de ce module, sous forme d'un *n*-uplet d'entiers. Ce "
"n'est pas la version de la bibliothèque SQLite."

#: library/sqlite3.rst:586
msgid ""
"These constants are used for the :meth:`Connection.setconfig` and :meth:"
"`~Connection.getconfig` methods."
msgstr ""

#: library/sqlite3.rst:589
msgid ""
"The availability of these constants varies depending on the version of "
"SQLite Python was compiled with."
msgstr ""

#: library/sqlite3.rst:596
msgid "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"
msgstr ""

#: library/sqlite3.rst:597
msgid "SQLite docs: Database Connection Configuration Options"
msgstr ""

#: library/sqlite3.rst:603
#, fuzzy
msgid "Connection objects"
msgstr "Objets de connexions"

#: library/sqlite3.rst:607
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating :"
"class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""

#: library/sqlite3.rst:614
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ""

#: library/sqlite3.rst:620
msgid ""
"A :exc:`ResourceWarning` is emitted if :meth:`close` is not called before a :"
"class:`!Connection` object is deleted."
msgstr ""

#: library/sqlite3.rst:623
msgid "An SQLite database connection has the following attributes and methods:"
msgstr ""

#: library/sqlite3.rst:627
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a :term:"
"`callable` returning an instance of :class:`Cursor` or its subclasses."
msgstr ""

#: library/sqlite3.rst:634
msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr ""

#: library/sqlite3.rst:637
msgid "The name of the table where the blob is located."
msgstr ""

#: library/sqlite3.rst:640
msgid "The name of the column where the blob is located."
msgstr ""

#: library/sqlite3.rst:643
msgid "The name of the row where the blob is located."
msgstr ""

#: library/sqlite3.rst:646
msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr ""

#: library/sqlite3.rst:651
msgid ""
"The name of the database where the blob is located. Defaults to ``\"main\"``."
msgstr ""

#: library/sqlite3.rst:0
msgid "Raises"
msgstr ""

#: library/sqlite3.rst:655
msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr ""

#: library/sqlite3.rst:662
msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the SQL "
"function ``zeroblob`` to create a blob with a fixed size."
msgstr ""

#: library/sqlite3.rst:669
msgid ""
"Commit any pending transaction to the database. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If :"
"attr:`!autocommit` is ``False``, a new transaction is implicitly opened if a "
"pending transaction was committed by this method."
msgstr ""

#: library/sqlite3.rst:677
msgid ""
"Roll back to the start of any pending transaction. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If :"
"attr:`!autocommit` is ``False``, a new transaction is implicitly opened if a "
"pending transaction was rolled back by this method."
msgstr ""

#: library/sqlite3.rst:685
msgid ""
"Close the database connection. If :attr:`autocommit` is ``False``, any "
"pending transaction is implicitly rolled back. If :attr:`!autocommit` is "
"``True`` or :data:`LEGACY_TRANSACTION_CONTROL`, no implicit transaction "
"control is executed. Make sure to :meth:`commit` before closing to avoid "
"losing pending changes."
msgstr ""

#: library/sqlite3.rst:695
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""

#: library/sqlite3.rst:701
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""

#: library/sqlite3.rst:707
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""

#: library/sqlite3.rst:713
msgid "Create or remove a user-defined SQL function."
msgstr ""

#: library/sqlite3.rst:715
msgid "The name of the SQL function."
msgstr ""

#: library/sqlite3.rst:718
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr ""

#: library/sqlite3.rst:722
msgid ""
"A :term:`callable` that is called when the SQL function is invoked. The "
"callable must return :ref:`a type natively supported by SQLite <sqlite3-"
"types>`. Set to ``None`` to remove an existing SQL function."
msgstr ""

#: library/sqlite3.rst:729
msgid ""
"If ``True``, the created SQL function is marked as `deterministic <https://"
"sqlite.org/deterministic.html>`_, which allows SQLite to perform additional "
"optimizations."
msgstr ""

#: library/sqlite3.rst:734
msgid "Added the *deterministic* parameter."
msgstr ""

#: library/sqlite3.rst:781 library/sqlite3.rst:1128 library/sqlite3.rst:1593
msgid "Example:"
msgstr "Exemple :"

#: library/sqlite3.rst:753
msgid ""
"Passing *name*, *narg*, and *func* as keyword arguments is deprecated. These "
"parameters will become positional-only in Python 3.15."
msgstr ""

#: library/sqlite3.rst:759
msgid "Create or remove a user-defined SQL aggregate function."
msgstr ""

#: library/sqlite3.rst:761
msgid "The name of the SQL aggregate function."
msgstr ""

#: library/sqlite3.rst:764
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it "
"may take any number of arguments."
msgstr ""

#: library/sqlite3.rst:768
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate "
"as   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""

#: library/sqlite3.rst:769
msgid "A class must implement the following methods:"
msgstr ""

#: library/sqlite3.rst:771
msgid "``step()``: Add a row to the aggregate."
msgstr ""

#: library/sqlite3.rst:833
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""

#: library/sqlite3.rst:775
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled "
"by *n_arg*."
msgstr ""

#: library/sqlite3.rst:778
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""

#: library/sqlite3.rst:812
msgid ""
"Passing *name*, *n_arg*, and *aggregate_class* as keyword arguments is "
"deprecated. These parameters will become positional-only in Python 3.15."
msgstr ""

#: library/sqlite3.rst:818
msgid "Create or remove a user-defined aggregate window function."
msgstr ""

#: library/sqlite3.rst:820
msgid "The name of the SQL aggregate window function to create or remove."
msgstr ""

#: library/sqlite3.rst:823
msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr ""

#: library/sqlite3.rst:827
msgid ""
"A class that must implement the following methods:  * ``step()``: Add a row "
"to the current window. * ``value()``: Return the current value of the "
"aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a type "
"natively supported by SQLite <sqlite3-types>`.  The number of arguments that "
"the ``step()`` and ``value()`` methods must accept is controlled by "
"*num_params*.  Set to ``None`` to remove an existing SQL aggregate window "
"function."
msgstr ""

#: library/sqlite3.rst:828
msgid "A class that must implement the following methods:"
msgstr ""

#: library/sqlite3.rst:830
msgid "``step()``: Add a row to the current window."
msgstr ""

#: library/sqlite3.rst:831
msgid "``value()``: Return the current value of the aggregate."
msgstr ""

#: library/sqlite3.rst:832
msgid "``inverse()``: Remove a row from the current window."
msgstr ""

#: library/sqlite3.rst:836
msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr ""

#: library/sqlite3.rst:839
msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr ""

#: library/sqlite3.rst:841
msgid ""
"If used with a version of SQLite older than 3.25.0, which does not support "
"aggregate window functions."
msgstr ""

#: library/sqlite3.rst:905
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""

#: library/sqlite3.rst:909
msgid "``1`` if the first is ordered higher than the second"
msgstr ""

#: library/sqlite3.rst:910
msgid "``-1`` if the first is ordered lower than the second"
msgstr ""

#: library/sqlite3.rst:911
msgid "``0`` if they are ordered equal"
msgstr ""

#: library/sqlite3.rst:913
msgid "The following example shows a reverse sorting collation:"
msgstr ""

#: library/sqlite3.rst:941
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr ""

#: library/sqlite3.rst:943
msgid ""
"The collation name can contain any Unicode character.  Earlier, only ASCII "
"characters were allowed."
msgstr ""

#: library/sqlite3.rst:950
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an :exc:"
"`OperationalError`."
msgstr ""

#: library/sqlite3.rst:957
msgid ""
"Register :term:`callable` *authorizer_callback* to be invoked for each "
"attempt to access a column of a table in the database. The callback should "
"return one of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:"
"`SQLITE_IGNORE` to signal how access to the column should be handled by the "
"underlying SQLite library."
msgstr ""

#: library/sqlite3.rst:964
msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""

#: library/sqlite3.rst:971
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`!sqlite3` "
"module."
msgstr ""

#: library/sqlite3.rst:975
msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr ""

#: library/sqlite3.rst:977
msgid "Added support for disabling the authorizer using ``None``."
msgstr ""

#: library/sqlite3.rst:980
msgid ""
"Passing *authorizer_callback* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""

#: library/sqlite3.rst:987
msgid ""
"Register :term:`callable` *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""

#: library/sqlite3.rst:992
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr ""

#: library/sqlite3.rst:995
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise a :exc:`DatabaseError` "
"exception."
msgstr ""

#: library/sqlite3.rst:999
msgid ""
"Passing *progress_handler* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""

#: library/sqlite3.rst:1006
msgid ""
"Register :term:`callable` *trace_callback* to be invoked for each SQL "
"statement that is actually executed by the SQLite backend."
msgstr ""

#: library/sqlite3.rst:1009
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the :mod:`!sqlite3` module and the "
"execution of triggers defined in the current database."
msgstr ""

#: library/sqlite3.rst:1017
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr ""

#: library/sqlite3.rst:1020
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""

#: library/sqlite3.rst:1027
msgid ""
"Passing *trace_callback* as a keyword argument is deprecated. The parameter "
"will become positional-only in Python 3.15."
msgstr ""

#: library/sqlite3.rst:1034
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""

#: library/sqlite3.rst:1043
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to :"
"program:`configure`."
msgstr ""

#: library/sqlite3.rst:1050
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension`` "
"with arguments ``connection``, ``enabled``."
msgstr ""

#: library/sqlite3.rst:1054
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr ""

#: library/sqlite3.rst:1086
msgid ""
"Load an SQLite extension from a shared library. Enable extension loading "
"with :meth:`enable_load_extension` before calling this method."
msgstr ""

#: library/sqlite3.rst:1090
msgid "The path to the SQLite extension."
msgstr ""

#: library/sqlite3.rst:1094
msgid ""
"Entry point name. If ``None`` (the default), SQLite will come up with an "
"entry point name of its own; see the SQLite docs `Loading an Extension`_ for "
"details."
msgstr ""

#: library/sqlite3.rst:1103
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""

#: library/sqlite3.rst:1107
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr ""

#: library/sqlite3.rst:1110
msgid "Added the *entrypoint* parameter."
msgstr ""

#: library/sqlite3.rst:1117
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the ``."
"dump`` command in the :program:`sqlite3` shell."
msgstr ""

#: library/sqlite3.rst:1121
msgid ""
"An optional ``LIKE`` pattern for database objects to dump, e.g. "
"``prefix_%``. If ``None`` (the default), all database objects will be "
"included."
msgstr ""

#: library/sqlite3.rst:1215
#, fuzzy
msgid ":ref:`sqlite3-howto-encoding`"
msgstr ":ref:`guide de fabrique de ligne sqlite3 <sqlite3-howto-row-factory>`"

#: library/sqlite3.rst:1143
msgid "Added the *filter* parameter."
msgstr "Ajout du paramètre *filter*."

#: library/sqlite3.rst:1148
msgid "Create a backup of an SQLite database."
msgstr ""

#: library/sqlite3.rst:1150
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr ""

#: library/sqlite3.rst:1153
msgid "The database connection to save the backup to."
msgstr ""

#: library/sqlite3.rst:1156
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr ""

#: library/sqlite3.rst:1162
msgid ""
"If set to a :term:`callable`, it is invoked with three integer arguments for "
"every backup iteration: the *status* of the last iteration, the *remaining* "
"number of pages still to be copied, and the *total* number of pages. "
"Defaults to ``None``."
msgstr ""

#: library/sqlite3.rst:1171
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a "
"custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""

#: library/sqlite3.rst:1178
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr ""

#: library/sqlite3.rst:1182
msgid "Example 1, copy an existing database into another:"
msgstr ""

#: library/sqlite3.rst:1201
msgid "Example 2, copy an existing database into a transient copy:"
msgstr ""

#: library/sqlite3.rst:1219
msgid "Get a connection runtime limit."
msgstr ""

#: library/sqlite3.rst:1221
msgid "The `SQLite limit category`_ to be queried."
msgstr ""

#: library/sqlite3.rst:1263
msgid "If *category* is not recognised by the underlying SQLite library."
msgstr ""

#: library/sqlite3.rst:1229
msgid ""
"Example, query the maximum length of an SQL statement for :class:"
"`Connection` ``con`` (the default is 1000000000):"
msgstr ""

#: library/sqlite3.rst:1249
msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its hard "
"upper bound are silently truncated to the hard upper bound. Regardless of "
"whether or not the limit was changed, the prior value of the limit is "
"returned."
msgstr ""

#: library/sqlite3.rst:1254
msgid "The `SQLite limit category`_ to be set."
msgstr ""

#: library/sqlite3.rst:1257
msgid ""
"The value of the new limit. If negative, the current limit is unchanged."
msgstr ""

#: library/sqlite3.rst:1266
msgid ""
"Example, limit the number of attached databases to 1 for :class:`Connection` "
"``con`` (the default limit is 10):"
msgstr ""

#: library/sqlite3.rst:1287
msgid "Query a boolean connection configuration option."
msgstr ""

#: library/sqlite3.rst:1300
msgid "A :ref:`SQLITE_DBCONFIG code <sqlite3-dbconfig-constants>`."
msgstr ""

#: library/sqlite3.rst:1298
msgid "Set a boolean connection configuration option."
msgstr ""

#: library/sqlite3.rst:1303
msgid ""
"``True`` if the configuration option should be enabled (default); ``False`` "
"if it should be disabled."
msgstr ""

#: library/sqlite3.rst:1311
msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-disk "
"database file, the serialization is just a copy of the disk file.  For an in-"
"memory database or a \"temp\" database, the serialization is the same "
"sequence of bytes which would be written to disk if that database were "
"backed up to disk."
msgstr ""

#: library/sqlite3.rst:1317
msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr ""

#: library/sqlite3.rst:1325
msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr ""

#: library/sqlite3.rst:1333
msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a :class:"
"`Connection`. This method causes the database connection to disconnect from "
"database *name*, and reopen *name* as an in-memory database based on the "
"serialization contained in *data*."
msgstr ""

#: library/sqlite3.rst:1339
msgid "A serialized database."
msgstr ""

#: library/sqlite3.rst:1342
msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr ""

#: library/sqlite3.rst:1346
msgid ""
"If the database connection is currently involved in a read transaction or a "
"backup operation."
msgstr ""

#: library/sqlite3.rst:1350
msgid "If *data* does not contain a valid SQLite database."
msgstr ""

#: library/sqlite3.rst:1353
msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr ""

#: library/sqlite3.rst:1358
msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr ""

#: library/sqlite3.rst:1365
msgid ""
"This attribute controls :pep:`249`-compliant transaction behaviour. :attr:`!"
"autocommit` has three allowed values:"
msgstr ""

#: library/sqlite3.rst:1368
msgid ""
"``False``: Select :pep:`249`-compliant transaction behaviour, implying that :"
"mod:`!sqlite3` ensures a transaction is always open. Use :meth:`commit` and :"
"meth:`rollback` to close transactions."
msgstr ""

#: library/sqlite3.rst:1372
msgid "This is the recommended value of :attr:`!autocommit`."
msgstr ""

#: library/sqlite3.rst:1374
msgid ""
"``True``: Use SQLite's `autocommit mode`_. :meth:`commit` and :meth:"
"`rollback` have no effect in this mode."
msgstr ""

#: library/sqlite3.rst:1377
msgid ""
":data:`LEGACY_TRANSACTION_CONTROL`: Pre-Python 3.12 (non-:pep:`249`-"
"compliant) transaction control. See :attr:`isolation_level` for more details."
msgstr ""

#: library/sqlite3.rst:1381
msgid "This is currently the default value of :attr:`!autocommit`."
msgstr ""

#: library/sqlite3.rst:1383
msgid ""
"Changing :attr:`!autocommit` to ``False`` will open a new transaction, and "
"changing it to ``True`` will commit any pending transaction."
msgstr ""

#: library/sqlite3.rst:1386
msgid "See :ref:`sqlite3-transaction-control-autocommit` for more details."
msgstr ""

#: library/sqlite3.rst:1390
msgid ""
"The :attr:`isolation_level` attribute has no effect unless :attr:"
"`autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`."
msgstr ""

#: library/sqlite3.rst:1397
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr ""

#: library/sqlite3.rst:1400
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr ""

#: library/sqlite3.rst:1407
msgid ""
"Controls the :ref:`legacy transaction handling mode <sqlite3-transaction-"
"control-isolation-level>` of :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``, "
"``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, :ref:`implicit transaction management "
"<sqlite3-transaction-control-isolation-level>` is performed."
msgstr ""

#: library/sqlite3.rst:1415
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the "
"default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""

#: library/sqlite3.rst:1420
msgid ""
"Using :attr:`autocommit` to control transaction handling is recommended over "
"using :attr:`!isolation_level`. :attr:`!isolation_level` has no effect "
"unless :attr:`autocommit` is set to :data:`LEGACY_TRANSACTION_CONTROL` (the "
"default)."
msgstr ""

#: library/sqlite3.rst:1427
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the :attr:"
"`!row_factory` of existing cursors belonging to this connection, only new "
"ones. Is ``None`` by default, meaning each row is returned as a :class:"
"`tuple`."
msgstr ""

#: library/sqlite3.rst:1720 library/sqlite3.rst:1743
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr ""

#: library/sqlite3.rst:1438
msgid ""
"A :term:`callable` that accepts a :class:`bytes` parameter and returns a "
"text representation of it. The callable is invoked for SQLite values with "
"the ``TEXT`` data type. By default, this attribute is set to :class:`str`."
msgstr ""

#: library/sqlite3.rst:1443
#, fuzzy
msgid "See :ref:`sqlite3-howto-encoding` for more details."
msgstr ":ref:`guide sqlite3 <sqlite3-howtos>` pour une lecture plus poussée :"

#: library/sqlite3.rst:1447
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""

#: library/sqlite3.rst:1454
#, fuzzy
msgid "Cursor objects"
msgstr "Objets de connexions"

#: library/sqlite3.rst:1456
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute "
"SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the :ref:"
"`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""

#: library/sqlite3.rst:1463
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you :meth:"
"`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the cursor "
"to fetch the resulting rows:"
msgstr ""

#: library/sqlite3.rst:1488
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr ""

#: library/sqlite3.rst:1495
msgid ""
"Execute a single SQL statement, optionally binding Python values using :ref:"
"`placeholders <sqlite3-placeholders>`."
msgstr ""

#: library/sqlite3.rst:1499
msgid "A single SQL statement."
msgstr ""

#: library/sqlite3.rst:1502
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used. "
"See :ref:`sqlite3-placeholders`."
msgstr ""

#: library/sqlite3.rst:1509
msgid "If *sql* contains more than one SQL statement."
msgstr ""

#: library/sqlite3.rst:1512
msgid ""
"If :attr:`~Connection.autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`, :"
"attr:`~Connection.isolation_level` is not ``None``, *sql* is an ``INSERT``, "
"``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is no open "
"transaction, a transaction is implicitly opened before executing *sql*."
msgstr ""

#: library/sqlite3.rst:1521
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders <sqlite3-"
"placeholders>` are used and *parameters* is a sequence instead of a :class:"
"`dict`. Starting with Python 3.14, :exc:`ProgrammingError` will be raised "
"instead."
msgstr ""

#: library/sqlite3.rst:1527
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr ""

#: library/sqlite3.rst:1531
msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` :abbr:`DML (Data Manipulation Language)` SQL "
"statement *sql*."
msgstr ""

#: library/sqlite3.rst:1535
msgid "Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr ""

#: library/sqlite3.rst:1537
msgid "A single SQL DML statement."
msgstr ""

#: library/sqlite3.rst:1540
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr ""

#: library/sqlite3.rst:1546
msgid ""
"If *sql* contains more than one SQL statement, or is not a DML statement."
msgstr ""

#: library/sqlite3.rst:1567
msgid ""
"Any resulting rows are discarded, including DML statements with `RETURNING "
"clauses`_."
msgstr ""

#: library/sqlite3.rst:1574
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders <sqlite3-"
"placeholders>` are used and the items in *parameters* are sequences instead "
"of :class:`dict`\\s. Starting with Python 3.14, :exc:`ProgrammingError` will "
"be raised instead."
msgstr ""

#: library/sqlite3.rst:1583
msgid ""
"Execute the SQL statements in *sql_script*. If the :attr:`~Connection."
"autocommit` is :data:`LEGACY_TRANSACTION_CONTROL` and there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""

#: library/sqlite3.rst:1591
msgid "*sql_script* must be a :class:`string <str>`."
msgstr ""

#: library/sqlite3.rst:1608
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result "
"set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""

#: library/sqlite3.rst:1616
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr ""

#: library/sqlite3.rst:1619
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""

#: library/sqlite3.rst:1625
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""

#: library/sqlite3.rst:1632
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""

#: library/sqlite3.rst:1639
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr ""

#: library/sqlite3.rst:1641
msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr ""

#: library/sqlite3.rst:1650
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr ""

#: library/sqlite3.rst:1654
msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr ""

#: library/sqlite3.rst:1659
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling :meth:"
"`con.cursor() <Connection.cursor>` will have a :attr:`connection` attribute "
"that refers to *con*:"
msgstr ""

#: library/sqlite3.rst:1674
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""

#: library/sqlite3.rst:1678
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""

#: library/sqlite3.rst:1682
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""

#: library/sqlite3.rst:1690
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr ""

#: library/sqlite3.rst:1692
msgid "Added support for the ``REPLACE`` statement."
msgstr ""

#: library/sqlite3.rst:1697
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods, after the statement has run to completion. This means that any "
"resulting rows must be fetched in order for :attr:`!rowcount` to be updated."
msgstr ""

#: library/sqlite3.rst:1708
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""

#: library/sqlite3.rst:1715
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the :class:`!"
"Cursor` was created. Assigning to this attribute does not affect :attr:"
"`Connection.row_factory` of the parent connection."
msgstr ""

#: library/sqlite3.rst:1731
#, fuzzy
msgid "Row objects"
msgstr "Objets de connexions"

#: library/sqlite3.rst:1735
msgid ""
"A :class:`!Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It supports iteration, "
"equality testing, :func:`len`, and :term:`mapping` access by column name and "
"index."
msgstr ""

#: library/sqlite3.rst:1740
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr ""

#: library/sqlite3.rst:1747
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in :attr:"
"`Cursor.description`."
msgstr ""

#: library/sqlite3.rst:1751
msgid "Added support of slicing."
msgstr ""

#: library/sqlite3.rst:1758
#, fuzzy
msgid "Blob objects"
msgstr "Objets de connexions"

#: library/sqlite3.rst:1764
msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call :func:"
"`len(blob) <len>` to get the size (number of bytes) of the blob. Use indices "
"and :term:`slices <slice>` for direct access to the blob data."
msgstr ""

#: library/sqlite3.rst:1769
msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the blob "
"handle is closed after use."
msgstr ""

#: library/sqlite3.rst:1800
msgid "Close the blob."
msgstr ""

#: library/sqlite3.rst:1802
msgid ""
"The blob will be unusable from this point onward.  An :class:`~sqlite3."
"Error` (or subclass) exception will be raised if any further operation is "
"attempted with the blob."
msgstr ""

#: library/sqlite3.rst:1808
msgid ""
"Read *length* bytes of data from the blob at the current offset position. If "
"the end of the blob is reached, the data up to :abbr:`EOF (End of File)` "
"will be returned.  When *length* is not specified, or is negative, :meth:"
"`~Blob.read` will read until the end of the blob."
msgstr ""

#: library/sqlite3.rst:1816
msgid ""
"Write *data* to the blob at the current offset.  This function cannot change "
"the blob length.  Writing beyond the end of the blob will raise :exc:"
"`ValueError`."
msgstr ""

#: library/sqlite3.rst:1822
msgid "Return the current access position of the blob."
msgstr ""

#: library/sqlite3.rst:1826
msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :const:`os.SEEK_SET` (absolute blob positioning). Other "
"values for *origin* are :const:`os.SEEK_CUR` (seek relative to the current "
"position) and :const:`os.SEEK_END` (seek relative to the blob’s end)."
msgstr ""

#: library/sqlite3.rst:1834
msgid "PrepareProtocol objects"
msgstr ""

#: library/sqlite3.rst:1838
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves <sqlite3-"
"conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""

#: library/sqlite3.rst:1846
msgid "Exceptions"
msgstr "Exceptions"

#: library/sqlite3.rst:1848
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr ""

#: library/sqlite3.rst:1852
msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but "
"may be raised by applications using :mod:`!sqlite3`, for example if a user-"
"defined function truncates data while inserting. ``Warning`` is a subclass "
"of :exc:`Exception`."
msgstr ""

#: library/sqlite3.rst:1859
msgid ""
"The base class of the other exceptions in this module. Use this to catch all "
"errors with one single :keyword:`except` statement. ``Error`` is a subclass "
"of :exc:`Exception`."
msgstr ""

#: library/sqlite3.rst:1863
msgid ""
"If the exception originated from within the SQLite library, the following "
"two attributes are added to the exception:"
msgstr ""

#: library/sqlite3.rst:1868
msgid ""
"The numeric error code from the `SQLite API <https://sqlite.org/rescode."
"html>`_"
msgstr ""

#: library/sqlite3.rst:1875
msgid ""
"The symbolic name of the numeric error code from the `SQLite API <https://"
"sqlite.org/rescode.html>`_"
msgstr ""

#: library/sqlite3.rst:1882
msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other words, "
"if this exception is raised, it probably indicates a bug in the :mod:`!"
"sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""

#: library/sqlite3.rst:1889
msgid ""
"Exception raised for errors that are related to the database. This serves as "
"the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""

#: library/sqlite3.rst:1896
msgid ""
"Exception raised for errors caused by problems with the processed data, like "
"numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""

#: library/sqlite3.rst:1902
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""

#: library/sqlite3.rst:1910
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr ""

#: library/sqlite3.rst:1915
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""

#: library/sqlite3.rst:1922
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate on a "
"closed :class:`Connection`. ``ProgrammingError`` is a subclass of :exc:"
"`DatabaseError`."
msgstr ""

#: library/sqlite3.rst:1929
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""

#: library/sqlite3.rst:1939
msgid "SQLite and Python types"
msgstr ""

#: library/sqlite3.rst:1941
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""

#: library/sqlite3.rst:1944
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr ""

#: library/sqlite3.rst:1964
msgid "Python type"
msgstr "Type Python"

#: library/sqlite3.rst:1964
msgid "SQLite type"
msgstr "SQLite type"

#: library/sqlite3.rst:1966
msgid "``None``"
msgstr "``None``"

#: library/sqlite3.rst:1966
msgid "``NULL``"
msgstr "``NULL``"

#: library/sqlite3.rst:1968
msgid ":class:`int`"
msgstr ":class:`int`"

#: library/sqlite3.rst:1968
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: library/sqlite3.rst:1970
msgid ":class:`float`"
msgstr ":class:`float`"

#: library/sqlite3.rst:1970
msgid "``REAL``"
msgstr "``REAL``"

#: library/sqlite3.rst:1955
msgid ":class:`str`"
msgstr ":class:`str`"

#: library/sqlite3.rst:1972
msgid "``TEXT``"
msgstr "``TEXT``"

#: library/sqlite3.rst:1975
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: library/sqlite3.rst:1975
msgid "``BLOB``"
msgstr "``BLOB``"

#: library/sqlite3.rst:1961
msgid "This is how SQLite types are converted to Python types by default:"
msgstr ""

#: library/sqlite3.rst:1972
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr ""

#: library/sqlite3.rst:1978
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters <sqlite3-"
"converters>`."
msgstr ""

#: library/sqlite3.rst:1988
msgid "Default adapters and converters (deprecated)"
msgstr ""

#: library/sqlite3.rst:1992
msgid ""
"The default adapters and converters are deprecated as of Python 3.12. "
"Instead, use the :ref:`sqlite3-adapter-converter-recipes` and tailor them to "
"your needs."
msgstr ""

#: library/sqlite3.rst:1996
msgid "The deprecated default adapters and converters consist of:"
msgstr ""

#: library/sqlite3.rst:1998
msgid ""
"An adapter for :class:`datetime.date` objects to :class:`strings <str>` in "
"`ISO 8601`_ format."
msgstr ""

#: library/sqlite3.rst:2000
msgid ""
"An adapter for :class:`datetime.datetime` objects to strings in ISO 8601 "
"format."
msgstr ""

#: library/sqlite3.rst:2002
msgid ""
"A converter for :ref:`declared <sqlite3-converters>` \"date\" types to :"
"class:`datetime.date` objects."
msgstr ""

#: library/sqlite3.rst:2004
msgid ""
"A converter for declared \"timestamp\" types to :class:`datetime.datetime` "
"objects. Fractional parts will be truncated to 6 digits (microsecond "
"precision)."
msgstr ""

#: library/sqlite3.rst:2010
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""

#: library/sqlite3.rst:2023
msgid "Command-line interface"
msgstr ""

#: library/sqlite3.rst:2025
msgid ""
"The :mod:`!sqlite3` module can be invoked as a script, using the "
"interpreter's :option:`-m` switch, in order to provide a simple SQLite "
"shell. The argument signature is as follows::"
msgstr ""

#: library/sqlite3.rst:2032
msgid "Type ``.quit`` or CTRL-D to exit the shell."
msgstr ""

#: library/sqlite3.rst:2038
msgid "Print CLI help."
msgstr ""

#: library/sqlite3.rst:2042
msgid "Print underlying SQLite library version."
msgstr ""

#: library/sqlite3.rst:2050
msgid "How-to guides"
msgstr ""

#: library/sqlite3.rst:2055
msgid "How to use placeholders to bind values in SQL queries"
msgstr ""

#: library/sqlite3.rst:2057
#, fuzzy
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"Habituellement, vos opérations SQL utilisent les valeurs de variables "
"Python. Vous ne devez pas assembler votre requête à l'aide des opérations "
"sur les chaînes de caractères de Python, car cela n'est pas sûr. Cela rend "
"votre programme vulnérable à une attaque par injection SQL (voir https://"
"xkcd.com/327/ pour un exemple amusant de ce qui peut mal tourner) ::"

#: library/sqlite3.rst:2070
#, fuzzy
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"À la place, utilisez la capacité DB-API de substitution des paramètres. "
"Placez un ``?`` comme indicateur partout où vous voulez utiliser une valeur, "
"puis fournissez un *n*-uplet de valeurs comme second argument de la méthode :"
"meth:`~Cursor.execute`. D'autres modules de base de données peuvent utiliser "
"un espace réservé différent, tel que ``%s`` ou ``:1``. Par exemple ::"

#: library/sqlite3.rst:2075
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* must be an instance of a :class:`dict` (or a subclass), "
"which must contain keys for all named parameters; any extra items are "
"ignored. Here's an example of both styles:"
msgstr ""

#: library/sqlite3.rst:2113
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ""

#: library/sqlite3.rst:2120
msgid "How to adapt custom Python types to SQLite values"
msgstr ""

#: library/sqlite3.rst:2122
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""

#: library/sqlite3.rst:2126
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""

#: library/sqlite3.rst:2138
msgid "How to write adaptable objects"
msgstr ""

#: library/sqlite3.rst:2140
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""

#: library/sqlite3.rst:2172
msgid "How to register adapter callables"
msgstr ""

#: library/sqlite3.rst:2174
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""

#: library/sqlite3.rst:2205
msgid "How to convert SQLite values to custom Python types"
msgstr ""

#: library/sqlite3.rst:2207
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types, "
"we use *converters*."
msgstr ""

#: library/sqlite3.rst:2212
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr ""

#: library/sqlite3.rst:2215
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr ""

#: library/sqlite3.rst:2220
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter "
"the underlying SQLite data type."
msgstr ""

#: library/sqlite3.rst:2229
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""

#: library/sqlite3.rst:2233
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr ""

#: library/sqlite3.rst:2234
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr ""

#: library/sqlite3.rst:2235
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""

#: library/sqlite3.rst:2239
msgid "The following example illustrates the implicit and explicit approaches:"
msgstr ""

#: library/sqlite3.rst:2292
msgid "Adapter and converter recipes"
msgstr ""

#: library/sqlite3.rst:2294
msgid "This section shows recipes for common adapters and converters."
msgstr ""

#: library/sqlite3.rst:2356
msgid "How to use connection shortcut methods"
msgstr ""

#: library/sqlite3.rst:2358
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and :"
"meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the "
"(often superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""

#: library/sqlite3.rst:2399
msgid "How to use the connection context manager"
msgstr ""

#: library/sqlite3.rst:2401
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back. If :attr:`~Connection.autocommit` "
"is ``False``, a new transaction is implicitly opened after committing or "
"rolling back."
msgstr ""

#: library/sqlite3.rst:2412
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, or if :attr:`~Connection.autocommit` is ``True``, the context "
"manager does nothing."
msgstr ""

#: library/sqlite3.rst:2417
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection. If you need a closing context manager, consider using :meth:"
"`contextlib.closing`."
msgstr ""

#: library/sqlite3.rst:2451
msgid "How to work with SQLite URIs"
msgstr ""

#: library/sqlite3.rst:2453
msgid "Some useful URI tricks include:"
msgstr ""

#: library/sqlite3.rst:2455
msgid "Open a database in read-only mode:"
msgstr ""

#: library/sqlite3.rst:2464
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""

#: library/sqlite3.rst:2474
msgid "Create a shared named in-memory database:"
msgstr ""

#: library/sqlite3.rst:2490
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr ""

#: library/sqlite3.rst:2499
msgid "How to create and use row factories"
msgstr ""

#: library/sqlite3.rst:2501
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a :"
"class:`!tuple` does not suit your needs, you can use the :class:`sqlite3."
"Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""

#: library/sqlite3.rst:2506
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the :class:"
"`Cursor` and the :class:`Connection`, it is recommended to set :class:"
"`Connection.row_factory`, so all cursors created from the connection will "
"use the same row factory."
msgstr ""

#: library/sqlite3.rst:2511
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns, "
"with minimal memory overhead and performance impact over a :class:`!tuple`. "
"To use :class:`!Row` as a row factory, assign it to the :attr:`!row_factory` "
"attribute:"
msgstr ""

#: library/sqlite3.rst:2521
msgid "Queries now return :class:`!Row` objects:"
msgstr ""

#: library/sqlite3.rst:2539
msgid ""
"The ``FROM`` clause can be omitted in the ``SELECT`` statement, as in the "
"above example. In such cases, SQLite returns a single row with columns "
"defined by expressions, e.g. literals, with the given aliases ``expr AS "
"alias``."
msgstr ""

#: library/sqlite3.rst:2544
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as "
"a :class:`dict`, with column names mapped to values:"
msgstr ""

#: library/sqlite3.rst:2553
msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr ""

#: library/sqlite3.rst:2564
msgid "The following row factory returns a :term:`named tuple`:"
msgstr ""

#: library/sqlite3.rst:2575
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ""

#: library/sqlite3.rst:2591
msgid ""
"With some adjustments, the above recipe can be adapted to use a :class:"
"`~dataclasses.dataclass`, or any other custom class, instead of a :class:"
"`~collections.namedtuple`."
msgstr ""

#: library/sqlite3.rst:2599
msgid "How to handle non-UTF-8 text encodings"
msgstr ""

#: library/sqlite3.rst:2601
msgid ""
"By default, :mod:`!sqlite3` uses :class:`str` to adapt SQLite values with "
"the ``TEXT`` data type. This works well for UTF-8 encoded text, but it might "
"fail for other encodings and invalid UTF-8. You can use a custom :attr:"
"`~Connection.text_factory` to handle such cases."
msgstr ""

#: library/sqlite3.rst:2607
msgid ""
"Because of SQLite's `flexible typing`_, it is not uncommon to encounter "
"table columns with the ``TEXT`` data type containing non-UTF-8 encodings, or "
"even arbitrary data. To demonstrate, let's assume we have a database with "
"ISO-8859-2 (Latin-2) encoded text, for example a table of Czech-English "
"dictionary entries. Assuming we now have a :class:`Connection` instance :py:"
"data:`!con` connected to this database, we can decode the Latin-2 encoded "
"text using this :attr:`~Connection.text_factory`:"
msgstr ""

#: library/sqlite3.rst:2620
msgid ""
"For invalid UTF-8 or arbitrary data in stored in ``TEXT`` table columns, you "
"can use the following technique, borrowed from the :ref:`unicode-howto`:"
msgstr ""

#: library/sqlite3.rst:2629
msgid ""
"The :mod:`!sqlite3` module API does not support strings containing "
"surrogates."
msgstr ""

#: library/sqlite3.rst:2634
msgid ":ref:`unicode-howto`"
msgstr ""

#: library/sqlite3.rst:2640
#, fuzzy
msgid "Explanation"
msgstr "Exceptions"

#: library/sqlite3.rst:2646
msgid "Transaction control"
msgstr ""

#: library/sqlite3.rst:2648
msgid ""
":mod:`!sqlite3` offers multiple methods of controlling whether, when and how "
"database transactions are opened and closed. :ref:`sqlite3-transaction-"
"control-autocommit` is recommended, while :ref:`sqlite3-transaction-control-"
"isolation-level` retains the pre-Python 3.12 behaviour."
msgstr ""

#: library/sqlite3.rst:2657
msgid "Transaction control via the ``autocommit`` attribute"
msgstr ""

#: library/sqlite3.rst:2659
msgid ""
"The recommended way of controlling transaction behaviour is through the :"
"attr:`Connection.autocommit` attribute, which should preferably be set using "
"the *autocommit* parameter of :func:`connect`."
msgstr ""

#: library/sqlite3.rst:2664
msgid ""
"It is suggested to set *autocommit* to ``False``, which implies :pep:`249`-"
"compliant transaction control. This means:"
msgstr ""

#: library/sqlite3.rst:2668
msgid ""
":mod:`!sqlite3` ensures that a transaction is always open, so :func:"
"`connect`, :meth:`Connection.commit`, and :meth:`Connection.rollback` will "
"implicitly open a new transaction (immediately after closing the pending "
"one, for the latter two). :mod:`!sqlite3` uses ``BEGIN DEFERRED`` statements "
"when opening transactions."
msgstr ""

#: library/sqlite3.rst:2673
msgid "Transactions should be committed explicitly using :meth:`!commit`."
msgstr ""

#: library/sqlite3.rst:2674
msgid "Transactions should be rolled back explicitly using :meth:`!rollback`."
msgstr ""

#: library/sqlite3.rst:2675
msgid ""
"An implicit rollback is performed if the database is :meth:`~Connection."
"close`-ed with pending changes."
msgstr ""

#: library/sqlite3.rst:2678
msgid ""
"Set *autocommit* to ``True`` to enable SQLite's `autocommit mode`_. In this "
"mode, :meth:`Connection.commit` and :meth:`Connection.rollback` have no "
"effect. Note that SQLite's autocommit mode is distinct from the :pep:`249`-"
"compliant :attr:`Connection.autocommit` attribute; use :attr:`Connection."
"in_transaction` to query the low-level SQLite autocommit mode."
msgstr ""

#: library/sqlite3.rst:2686
msgid ""
"Set *autocommit* to :data:`LEGACY_TRANSACTION_CONTROL` to leave transaction "
"control behaviour to the :attr:`Connection.isolation_level` attribute. See :"
"ref:`sqlite3-transaction-control-isolation-level` for more information."
msgstr ""

#: library/sqlite3.rst:2695
msgid "Transaction control via the ``isolation_level`` attribute"
msgstr ""

#: library/sqlite3.rst:2699
msgid ""
"The recommended way of controlling transactions is via the :attr:"
"`~Connection.autocommit` attribute. See :ref:`sqlite3-transaction-control-"
"autocommit`."
msgstr ""

#: library/sqlite3.rst:2703
msgid ""
"If :attr:`Connection.autocommit` is set to :data:"
"`LEGACY_TRANSACTION_CONTROL` (the default), transaction behaviour is "
"controlled using the :attr:`Connection.isolation_level` attribute. "
"Otherwise, :attr:`!isolation_level` has no effect."
msgstr ""

#: library/sqlite3.rst:2709
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before :meth:`~Cursor."
"execute` and :meth:`~Cursor.executemany` executes ``INSERT``, ``UPDATE``, "
"``DELETE``, or ``REPLACE`` statements; for other statements, no implicit "
"transaction handling is performed. Use the :meth:`~Connection.commit` and :"
"meth:`~Connection.rollback` methods to respectively commit and roll back "
"pending transactions. You can choose the underlying `SQLite transaction "
"behaviour`_ — that is, whether and what type of ``BEGIN`` statements :mod:`!"
"sqlite3` implicitly executes – via the :attr:`~Connection.isolation_level` "
"attribute."
msgstr ""

#: library/sqlite3.rst:2722
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the :attr:`~Connection."
"in_transaction` attribute."
msgstr ""

#: library/sqlite3.rst:2730
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""

#: library/sqlite3.rst:2734
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""

#: library/sqlite3.rst:2738
msgid ""
"The recommended way of controlling transactions is now via the :attr:"
"`~Connection.autocommit` attribute."
msgstr ""

#~ msgid ": (colon)"
#~ msgstr ": (deux-points)"

#~ msgid ""
#~ "Register an :func:`unraisable hook handler <sys.unraisablehook>` for an "
#~ "improved debug experience:"
#~ msgstr ""
#~ "Enregistrez un :func:`gestionnaire de point d’entrée *non levable* <sys."
#~ "unraisablehook>` (*unraisable* en anglais) pour une expérience de "
#~ "débogage améliorée :"

#, fuzzy
#~ msgid ""
#~ "To use the module, start by creating a :class:`Connection` object that "
#~ "represents the database.  Here the data will be stored in the :file:"
#~ "`example.db` file::"
#~ msgstr ""
#~ "Pour utiliser le module, vous devez d’abord créer une :class:`Connection` "
#~ "qui représente la base de données. Dans cet exemple, les données sont "
#~ "stockées dans le fichier :file:`example.db` ::"

#, fuzzy
#~ msgid ""
#~ "The special path name ``:memory:`` can be provided to create a temporary "
#~ "database in RAM."
#~ msgstr ""
#~ "Vous pouvez également fournir le nom spécial ``:memory:`` pour créer une "
#~ "base de données dans la mémoire vive."

#, fuzzy
#~ msgid ""
#~ "Once a :class:`Connection` has been established, create a :class:`Cursor` "
#~ "object and call its :meth:`~Cursor.execute` method to perform SQL "
#~ "commands::"
#~ msgstr ""
#~ "Une fois que vous avez une instance de :class:`Connection`, vous pouvez "
#~ "créer un objet :class:`Cursor` et appeler sa méthode :meth:`~Cursor."
#~ "execute` pour exécuter les commandes SQL ::"

#, fuzzy
#~ msgid ""
#~ "To retrieve data after executing a SELECT statement, either treat the "
#~ "cursor as an :term:`iterator`, call the cursor's :meth:`~Cursor.fetchone` "
#~ "method to retrieve a single matching row, or call :meth:`~Cursor."
#~ "fetchall` to get a list of the matching rows."
#~ msgstr ""
#~ "Pour récupérer des données après avoir exécuté une instruction *SELECT*, "
#~ "vous pouvez considérer le curseur comme un :term:`itérateur <iterator>`, "
#~ "appeler la méthode du curseur :meth:`~Cursor.fetchone` pour récupérer une "
#~ "seule ligne correspondante ou appeler :meth:`~Cursor.fetchall` pour "
#~ "obtenir une liste des lignes correspondantes."

#~ msgid "This example uses the iterator form::"
#~ msgstr "Cet exemple utilise la forme itérateur ::"

#~ msgid ""
#~ "This constant is meant to be used with the *detect_types* parameter of "
#~ "the :func:`connect` function."
#~ msgstr ""
#~ "Cette constante est destinée à être utilisée avec le paramètre "
#~ "*detect_types* de la fonction :func:`connect`."

#~ msgid ""
#~ "Setting it makes the :mod:`sqlite3` module parse the declared type for "
#~ "each column it returns.  It will parse out the first word of the declared "
#~ "type, i. e.  for \"integer primary key\", it will parse out \"integer\", "
#~ "or for \"number(10)\" it will parse out \"number\". Then for that column, "
#~ "it will look into the converters dictionary and use the converter "
#~ "function registered for that type there."
#~ msgstr ""
#~ "Si elle est définie, le module :mod:`sqlite3` analyse le type de donnée "
#~ "déclarée pour chaque colonne. Il déduit le type du premier mot de la "
#~ "déclaration, par exemple de *integer primary key* il gardera *integer*, "
#~ "ou de *number(10)* il gardera *number*. Ensuite, pour cette colonne, il "
#~ "utilisera une fonction de conversion du dictionnaire des convertisseurs."

#, fuzzy
#~ msgid ""
#~ "Setting this makes the SQLite interface parse the column name for each "
#~ "column it returns.  It will look for a string formed [mytype] in there, "
#~ "and then decide that 'mytype' is the type of the column. It will try to "
#~ "find an entry of 'mytype' in the converters dictionary and then use the "
#~ "converter function found there to return the value. The column name found "
#~ "in :attr:`Cursor.description` does not include the type, i. e. if you use "
#~ "something like ``'as \"Expiration date [datetime]\"'`` in your SQL, then "
#~ "we will parse out everything until the first ``'['`` for the column name "
#~ "and strip the preceding space: the column name would simply be "
#~ "\"Expiration date\"."
#~ msgstr ""
#~ "Permet à l’interface SQLite d'analyser le nom pour chaque colonne. Il y "
#~ "cherchera une chaîne comme ``[mytype]`` indiquant que la colonne est de "
#~ "type ``mytype``. Il essaiera de trouver une entrée *mytype* dans le "
#~ "dictionnaire, puis utilisera la fonction de conversion qui s'y trouve "
#~ "pour renvoyer la valeur. Le nom de colonne donnée à :attr:`Cursor."
#~ "description` n'est alors que le premier mot du nom de la colonne, par "
#~ "exemple si vous utilisez ``'as \\\"x [datetime]\\\"'`` dans votre code "
#~ "SQL, le nom de la colonne sera simplement *x*."

#~ msgid ""
#~ "Opens a connection to the SQLite database file *database*. By default "
#~ "returns a :class:`Connection` object, unless a custom *factory* is given."
#~ msgstr ""
#~ "Ouvre une connexion à la base de données SQLite *database*. Par défaut, "
#~ "cette commande renvoie un objet :class:`Connection`, sauf si *factory* "
#~ "est donné."

#~ msgid "Example::"
#~ msgstr "Exemple ::"

#~ msgid "Introduction"
#~ msgstr "Introduction"

#~ msgid ":const:`None`"
#~ msgstr ":const:`None`"

#~ msgid "Footnotes"
#~ msgstr "Notes"

#~ msgid ""
#~ "The data you've saved is persistent and is available in subsequent "
#~ "sessions::"
#~ msgstr ""
#~ "Les données que vous avez sauvegardées sont persistantes et disponibles "
#~ "dans les sessions suivantes ::"

#~ msgid "https://github.com/ghaering/pysqlite"
#~ msgstr "https://github.com/ghaering/pysqlite"

#~ msgid ""
#~ "The pysqlite web page -- sqlite3 is developed externally under the name "
#~ "\"pysqlite\"."
#~ msgstr ""
#~ "La page web de *pysqlite* — *sqlite3* est développée sur un site tiers "
#~ "sous le nom *pysqlite*."
