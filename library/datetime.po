# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 22:40+0100\n"
"PO-Revision-Date: 2023-10-03 21:51+0200\n"
"Last-Translator: Loc Cosnier <loc.cosnier@pm.me>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 3.3.2\n"

#: library/datetime.rst:2
#, fuzzy
msgid ":mod:`!datetime` --- Basic date and time types"
msgstr ":mod:`datetime` — Types de base pour la date et l'heure"

#: library/datetime.rst:11
msgid "**Source code:** :source:`Lib/datetime.py`"
msgstr "**Code source :** :source:`Lib/datetime.py`"

#: library/datetime.rst:17
#, fuzzy
msgid ""
"The :mod:`!datetime` module supplies classes for manipulating dates and "
"times."
msgstr ""
"Le module :mod:`datetime` fournit des classes permettant de manipuler les "
"dates et les heures."

#: library/datetime.rst:19
msgid ""
"While date and time arithmetic is supported, the focus of the implementation "
"is on efficient attribute extraction for output formatting and manipulation."
msgstr ""
"Bien que les calculs de date et d'heure sont gérés, l'attention lors de "
"l'implémentation s'est essentiellement portée sur l'efficacité de "
"l'extraction des attributs en vue de leur manipulation et formatage pour "
"l'affichage."

#: library/datetime.rst:24
msgid "Skip to :ref:`the format codes <format-codes>`."
msgstr ""

#: library/datetime.rst:28
msgid "Module :mod:`calendar`"
msgstr "Module :mod:`calendar`"

#: library/datetime.rst:29
msgid "General calendar related functions."
msgstr "Fonctions génériques associées au calendrier."

#: library/datetime.rst:31
msgid "Module :mod:`time`"
msgstr "Module :mod:`time`"

#: library/datetime.rst:32
msgid "Time access and conversions."
msgstr "Accès aux données d'horaires et aux conversions associées."

#: library/datetime.rst:34
msgid "Module :mod:`zoneinfo`"
msgstr "Module :mod:`zoneinfo`"

#: library/datetime.rst:35
msgid "Concrete time zones representing the IANA time zone database."
msgstr "Fuseaux horaires concrets représentant la base de données IANA."

#: library/datetime.rst:37
msgid "Package `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"
msgstr "Paquet `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"

#: library/datetime.rst:38
msgid "Third-party library with expanded time zone and parsing support."
msgstr ""
"Bibliothèque tierce avec prise en charge complète du fuseau horaire et de "
"l'analyse de dates sous forme textuelle."

#: library/datetime.rst:40
msgid "Package :pypi:`DateType`"
msgstr ""

#: library/datetime.rst:41
msgid ""
"Third-party library that introduces distinct static types to e.g. allow :"
"term:`static type checkers <static type checker>` to differentiate between "
"naive and aware datetimes."
msgstr ""

#: library/datetime.rst:48
msgid "Aware and Naive Objects"
msgstr "Objets avisés et naïfs"

#: library/datetime.rst:50
#, fuzzy
msgid ""
"Date and time objects may be categorized as \"aware\" or \"naive\" depending "
"on whether or not they include time zone information."
msgstr ""
"Les objets *date* et *time* peuvent être classés comme « avisés » ou "
"« naïfs » selon qu'ils contiennent ou non des informations sur le fuseau "
"horaire."

#: library/datetime.rst:53
msgid ""
"With sufficient knowledge of applicable algorithmic and political time "
"adjustments, such as time zone and daylight saving time information, an "
"**aware** object can locate itself relative to other aware objects. An aware "
"object represents a specific moment in time that is not open to "
"interpretation. [#]_"
msgstr ""
"Un objet **avisé** possède suffisamment de connaissance des règles à "
"appliquer et des politiques d'ajustement de l'heure comme les informations "
"sur les fuseaux horaires et l'heure d'été pour se situer de façon relative "
"par rapport à d'autres objets avisés. Un objet avisé est utilisé pour "
"représenter un instant précis qui n'est pas ouvert à l'interprétation [#]_."

#: library/datetime.rst:59
#, fuzzy
msgid ""
"A **naive** object does not contain enough information to unambiguously "
"locate itself relative to other date/time objects. Whether a naive object "
"represents Coordinated Universal Time (UTC), local time, or time in some "
"other time zone is purely up to the program, just like it is up to the "
"program whether a particular number represents metres, miles, or mass. Naive "
"objects are easy to understand and to work with, at the cost of ignoring "
"some aspects of reality."
msgstr ""
"Un objet **naïf** ne comporte pas assez d'informations pour se situer sans "
"ambiguïté par rapport à d'autres objets *date/time*. Le fait qu'un objet "
"naïf représente un Temps universel coordonné (UTC), une heure locale ou une "
"heure dans un autre fuseau horaire dépend complètement du programme, tout "
"comme un nombre peut représenter une longueur, un poids ou une distance pour "
"le programme. Les objets naïfs sont simples à comprendre et il est aisé de "
"travailler avec, au prix de négliger certains aspects de la réalité."

#: library/datetime.rst:66
msgid ""
"For applications requiring aware objects, :class:`.datetime` and :class:`."
"time` objects have an optional time zone information attribute, :attr:`!"
"tzinfo`, that can be set to an instance of a subclass of the abstract :class:"
"`tzinfo` class. These :class:`tzinfo` objects capture information about the "
"offset from UTC time, the time zone name, and whether daylight saving time "
"is in effect."
msgstr ""
"Pour les applications nécessitant des objets avisés, les objets :class:`."
"datetime` et :class:`.time` ont un attribut facultatif renseignant le fuseau "
"horaire, :attr:`!tzinfo`, qui peut être une instance d'une sous-classe de la "
"classe abstraite :class:`tzinfo`. Ces objets :class:`tzinfo` regroupent des "
"informations sur le décalage par rapport à l'heure UTC, le nom du fuseau "
"horaire, et si l'heure d'été est en vigueur."

#: library/datetime.rst:72
#, fuzzy
msgid ""
"Only one concrete :class:`tzinfo` class, the :class:`timezone` class, is "
"supplied by the :mod:`!datetime` module. The :class:`!timezone` class can "
"represent simple time zones with fixed offsets from UTC, such as UTC itself "
"or North American EST and EDT time zones. Supporting time zones at deeper "
"levels of detail is up to the application. The rules for time adjustment "
"across the world are more political than rational, change frequently, and "
"there is no standard suitable for every application aside from UTC."
msgstr ""
"Notez qu'une seule classe concrète :class:`tzinfo`, la classe :class:"
"`timezone`, est proposée par le module :mod:`datetime`. La classe :class:"
"`timezone` représente des fuseaux horaires simples avec un décalage fixe par "
"rapport à UTC, comme UTC lui-même ou les fuseaux EST et EDT d'Amérique du "
"Nord. Gérer des fuseaux horaires d'un niveau de détails plus avancé est à la "
"charge de l'application. Les règles d'ajustement du temps à travers le monde "
"sont plus politiques que rationnelles, changent fréquemment, et il n'y a pas "
"de standard qui vaille pour toute application, en dehors d'UTC."

#: library/datetime.rst:81
msgid "Constants"
msgstr "Constantes"

#: library/datetime.rst:83
#, fuzzy
msgid "The :mod:`!datetime` module exports the following constants:"
msgstr "Le module :mod:`datetime` exporte les constantes suivantes :"

#: library/datetime.rst:87
#, fuzzy
msgid ""
"The smallest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MINYEAR` is 1."
msgstr ""
"Le numéro d'année le plus petit autorisé dans un objet :class:`date` ou :"
"class:`datetime`. :const:`MINYEAR` vaut ``1``."

#: library/datetime.rst:93
#, fuzzy
msgid ""
"The largest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MAXYEAR` is 9999."
msgstr ""
"Le numéro d'année le plus grand autorisé dans un objet :class:`date` ou :"
"class:`datetime`. :const:`MAXYEAR` vaut ``9999``."

#: library/datetime.rst:98
#, fuzzy
msgid "Alias for the UTC time zone singleton :attr:`datetime.timezone.utc`."
msgstr ""
"Alias du singleton de fuseau horaire UTC :attr:`datetime.timezone.utc`."

#: library/datetime.rst:103
msgid "Available Types"
msgstr "Types disponibles"

#: library/datetime.rst:108
msgid ""
"An idealized naive date, assuming the current Gregorian calendar always was, "
"and always will be, in effect. Attributes: :attr:`year`, :attr:`month`, and :"
"attr:`day`."
msgstr ""
"Une date naïve idéalisée, en supposant que le calendrier Grégorien actuel a "
"toujours existé et qu'il existera toujours. Attributs : :attr:`year`, :attr:"
"`month` et :attr:`day`."

#: library/datetime.rst:116
msgid ""
"An idealized time, independent of any particular day, assuming that every "
"day has exactly 24\\*60\\*60 seconds.  (There is no notion of \"leap "
"seconds\" here.) Attributes: :attr:`hour`, :attr:`minute`, :attr:`second`, :"
"attr:`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"Un temps idéalisé, indépendant d'une date particulière, en supposant qu'une "
"journée est composée d'exactement 24\\*60\\*60 secondes (il n'y a pas ici de "
"notion de « seconde intercalaire »). Attributs : :attr:`hour`, :attr:"
"`minute`, :attr:`second`, :attr:`microsecond` et :attr:`tzinfo`."

#: library/datetime.rst:125
msgid ""
"A combination of a date and a time. Attributes: :attr:`year`, :attr:"
"`month`, :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:"
"`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"Une combinaison d'une date et d'une heure. Attributs : :attr:`year`, :attr:"
"`month`, :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:"
"`microsecond`, et :attr:`tzinfo`."

#: library/datetime.rst:133
#, fuzzy
msgid ""
"A duration expressing the difference between two :class:`.datetime` or :"
"class:`date` instances to microsecond resolution."
msgstr ""
"Une durée qui exprime la différence entre deux instances de :class:`date`, :"
"class:`time` ou :class:`datetime` en microsecondes."

#: library/datetime.rst:140
msgid ""
"An abstract base class for time zone information objects. These are used by "
"the :class:`.datetime` and :class:`.time` classes to provide a customizable "
"notion of time adjustment (for example, to account for time zone and/or "
"daylight saving time)."
msgstr ""
"Une classe mère abstraite pour les objets portants des informations sur les "
"fuseaux horaires. Ceux-ci sont utilisés par les classes :class:`.datetime` "
"et :class:`.time` pour donner une notion personnalisable d'ajustement "
"d'horaire (par exemple la prise en compte d'un fuseau horaire et/ou de "
"l'heure d'été)."

#: library/datetime.rst:148
msgid ""
"A class that implements the :class:`tzinfo` abstract base class as a fixed "
"offset from the UTC."
msgstr ""
"Une classe qui implémente la classe mère abstraite :class:`tzinfo` en tant "
"que décalage fixe par rapport au temps UTC."

#: library/datetime.rst:171
msgid "Objects of these types are immutable."
msgstr "Les objets issus de ces types sont immuables."

#: library/datetime.rst:155
msgid "Subclass relationships::"
msgstr "Relations entre les sous-classes ::"

#: library/datetime.rst:157
msgid ""
"object\n"
"    timedelta\n"
"    tzinfo\n"
"        timezone\n"
"    time\n"
"    date\n"
"        datetime"
msgstr ""

#: library/datetime.rst:166
msgid "Common Properties"
msgstr "Propriétés communes"

#: library/datetime.rst:168
msgid ""
"The :class:`date`, :class:`.datetime`, :class:`.time`, and :class:`timezone` "
"types share these common features:"
msgstr ""
"Les types :class:`date`, :class:`.datetime`, :class:`.time`, et :class:"
"`timezone` partagent les caractéristiques suivantes :"

#: library/datetime.rst:172
msgid ""
"Objects of these types are :term:`hashable`, meaning that they can be used "
"as dictionary keys."
msgstr ""
"Les objets de ces types sont :term:`hachable`, ce qui signifie qu'ils "
"peuvent être utilisés comme clés de dictionnaire."

#: library/datetime.rst:174
msgid ""
"Objects of these types support efficient pickling via the :mod:`pickle` "
"module."
msgstr ""
"Les objets de ces types peuvent être sérialisés efficacement par le module :"
"mod:`pickle`."

#: library/datetime.rst:177
msgid "Determining if an Object is Aware or Naive"
msgstr "Catégorisation d'un objet en « avisé » ou « naïf »"

#: library/datetime.rst:179
msgid "Objects of the :class:`date` type are always naive."
msgstr "Les objets de type :class:`date` sont toujours naïfs."

#: library/datetime.rst:181
msgid ""
"An object of type :class:`.time` or :class:`.datetime` may be aware or naive."
msgstr ""
"Un objet du type :class:`.time` ou :class:`.datetime` peut être avisé ou "
"naïf."

#: library/datetime.rst:183
#, fuzzy
msgid ""
"A :class:`.datetime` object ``d`` is aware if both of the following hold:"
msgstr ""
"Un objet :class:`.datetime` *d* est avisé si les deux conditions suivantes "
"vérifient :"

#: library/datetime.rst:185
msgid "``d.tzinfo`` is not ``None``"
msgstr "``d.tzinfo`` ne vaut pas ``None``"

#: library/datetime.rst:186
msgid "``d.tzinfo.utcoffset(d)`` does not return ``None``"
msgstr "``d.tzinfo.utcoffset(d)`` ne renvoie pas ``None``"

#: library/datetime.rst:188
#, fuzzy
msgid "Otherwise, ``d`` is naive."
msgstr "Autrement, *d* est naïf."

#: library/datetime.rst:190
#, fuzzy
msgid "A :class:`.time` object ``t`` is aware if both of the following hold:"
msgstr ""
"Un objet :class:`.time` *t* est avisé si les deux conditions suivantes "
"vérifient :"

#: library/datetime.rst:192
msgid "``t.tzinfo`` is not ``None``"
msgstr "``t.tzinfo`` ne vaut pas ``None``"

#: library/datetime.rst:193
msgid "``t.tzinfo.utcoffset(None)`` does not return ``None``."
msgstr "``t.tzinfo.utcoffset(None)`` ne renvoie pas ``None``."

#: library/datetime.rst:195
#, fuzzy
msgid "Otherwise, ``t`` is naive."
msgstr "Autrement, *t* est naïf."

#: library/datetime.rst:197
msgid ""
"The distinction between aware and naive doesn't apply to :class:`timedelta` "
"objects."
msgstr ""
"La distinction entre avisé et naïf ne s'applique pas aux objets de type :"
"class:`timedelta`."

#: library/datetime.rst:203
msgid ":class:`timedelta` Objects"
msgstr "Objets :class:`timedelta`"

#: library/datetime.rst:205
#, fuzzy
msgid ""
"A :class:`timedelta` object represents a duration, the difference between "
"two :class:`.datetime` or :class:`date` instances."
msgstr ""
"Un objet :class:`timedelta` représente une durée, c'est-à-dire la différence "
"entre deux dates ou heures."

#: library/datetime.rst:210
#, fuzzy
msgid ""
"All arguments are optional and default to 0. Arguments may be integers or "
"floats, and may be positive or negative."
msgstr ""
"Tous les arguments sont optionnels et ont ``0`` comme valeur par défaut. Les "
"arguments peuvent être des entiers ou des flottants et ils peuvent être "
"positifs ou négatifs."

#: library/datetime.rst:213
msgid ""
"Only *days*, *seconds* and *microseconds* are stored internally. Arguments "
"are converted to those units:"
msgstr ""
"Seuls les *jours*, les *secondes* et les *microsecondes* sont stockés en "
"interne. Les arguments sont convertis dans ces unités :"

#: library/datetime.rst:216
msgid "A millisecond is converted to 1000 microseconds."
msgstr "Une milliseconde est convertie en 1000 microsecondes."

#: library/datetime.rst:217
msgid "A minute is converted to 60 seconds."
msgstr "Une minute est convertie en 60 secondes."

#: library/datetime.rst:218
msgid "An hour is converted to 3600 seconds."
msgstr "Une heure est convertie en 3600 secondes."

#: library/datetime.rst:219
msgid "A week is converted to 7 days."
msgstr "Une semaine est convertie en 7 jours."

#: library/datetime.rst:221
msgid ""
"and days, seconds and microseconds are then normalized so that the "
"representation is unique, with"
msgstr ""
"et ensuite les jours, secondes et microsecondes sont normalisés pour que la "
"représentation soit unique avec"

#: library/datetime.rst:224
msgid "``0 <= microseconds < 1000000``"
msgstr "``0 <= microseconds < 1000000``"

#: library/datetime.rst:225
msgid "``0 <= seconds < 3600*24`` (the number of seconds in one day)"
msgstr "``0 <= secondes < 3600*24`` (le nombre de secondes dans une journée)"

#: library/datetime.rst:226
msgid "``-999999999 <= days <= 999999999``"
msgstr "``-999999999 <= days <= 999999999``"

#: library/datetime.rst:228
msgid ""
"The following example illustrates how any arguments besides *days*, "
"*seconds* and *microseconds* are \"merged\" and normalized into those three "
"resulting attributes::"
msgstr ""
"L'exemple suivant illustre comment tous les arguments autres que *days*, "
"*seconds* et *microseconds* sont « fusionnés » et normalisés dans ces trois "
"attributs résultants ::"

#: library/datetime.rst:232
msgid ""
">>> from datetime import timedelta\n"
">>> delta = timedelta(\n"
"...     days=50,\n"
"...     seconds=27,\n"
"...     microseconds=10,\n"
"...     milliseconds=29000,\n"
"...     minutes=5,\n"
"...     hours=8,\n"
"...     weeks=2\n"
"... )\n"
">>> # Only days, seconds, and microseconds remain\n"
">>> delta\n"
"datetime.timedelta(days=64, seconds=29156, microseconds=10)"
msgstr ""

#: library/datetime.rst:246
msgid ""
"If any argument is a float and there are fractional microseconds, the "
"fractional microseconds left over from all arguments are combined and their "
"sum is rounded to the nearest microsecond using round-half-to-even "
"tiebreaker. If no argument is a float, the conversion and normalization "
"processes are exact (no information is lost)."
msgstr ""
"Si l'un des arguments est un flottant et qu'il y a des microsecondes "
"décimales, les microsecondes décimales laissées par les arguments sont "
"combinées et leur somme est arrondie à la microseconde la plus proche en "
"arrondissant les demis vers le nombre pair. Si aucun argument n'est "
"flottant, les processus de conversion et de normalisation seront exacts (pas "
"d'informations perdues)."

#: library/datetime.rst:253
msgid ""
"If the normalized value of days lies outside the indicated range, :exc:"
"`OverflowError` is raised."
msgstr ""
"Si la valeur normalisée des jours déborde de l'intervalle indiqué, une :exc:"
"`OverflowError` est levée."

#: library/datetime.rst:256
msgid ""
"Note that normalization of negative values may be surprising at first. For "
"example::"
msgstr ""
"Notez que la normalisation de valeurs négatives peut être surprenante au "
"premier abord. Par exemple ::"

#: library/datetime.rst:259
msgid ""
">>> from datetime import timedelta\n"
">>> d = timedelta(microseconds=-1)\n"
">>> (d.days, d.seconds, d.microseconds)\n"
"(-1, 86399, 999999)"
msgstr ""

#: library/datetime.rst:566 library/datetime.rst:1764 library/datetime.rst:2369
msgid "Class attributes:"
msgstr "Attributs de la classe :"

#: library/datetime.rst:269
msgid "The most negative :class:`timedelta` object, ``timedelta(-999999999)``."
msgstr "L'objet :class:`timedelta` le plus négatif, ``timedelta(-999999999)``."

#: library/datetime.rst:274
msgid ""
"The most positive :class:`timedelta` object, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."
msgstr ""
"L'objet :class:`timedelta` le plus positif, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."

#: library/datetime.rst:280
msgid ""
"The smallest possible difference between non-equal :class:`timedelta` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"La plus petite différence entre des objets :class:`timedelta` non égaux, "
"``timedelta(microseconds=1)``."

#: library/datetime.rst:283
#, fuzzy
msgid ""
"Note that, because of normalization, ``timedelta.max`` is greater than ``-"
"timedelta.min``. ``-timedelta.max`` is not representable as a :class:"
"`timedelta` object."
msgstr ""
"Il est à noter, du fait de la normalisation, que ``timedelta.max`` > ``-"
"timedelta.min``. ``-timedelta.max`` n'est pas représentable sous la forme "
"d'un objet :class:`timedelta`."

#: library/datetime.rst:584 library/datetime.rst:1784
msgid "Instance attributes (read-only):"
msgstr "Attributs de l'instance (en lecture seule) :"

#: library/datetime.rst:291
#, fuzzy
msgid "Between -999,999,999 and 999,999,999 inclusive."
msgstr "Entre ``-999999999`` et ``999999999`` inclus"

#: library/datetime.rst:296
#, fuzzy
msgid "Between 0 and 86,399 inclusive."
msgstr "Entre 0 et 86399 inclus"

#: library/datetime.rst:300
msgid ""
"It is a somewhat common bug for code to unintentionally use this attribute "
"when it is actually intended to get a :meth:`~timedelta.total_seconds` value "
"instead:"
msgstr ""

#: library/datetime.rst:304
msgid ""
">>> from datetime import timedelta\n"
">>> duration = timedelta(seconds=11235813)\n"
">>> duration.days, duration.seconds\n"
"(130, 3813)\n"
">>> duration.total_seconds()\n"
"11235813.0"
msgstr ""

#: library/datetime.rst:315
#, fuzzy
msgid "Between 0 and 999,999 inclusive."
msgstr "Entre 0 et 999999 inclus"

#: library/datetime.rst:601 library/datetime.rst:1199
msgid "Supported operations:"
msgstr "Opérations gérées :"

#: library/datetime.rst:604 library/datetime.rst:1202
msgid "Operation"
msgstr "Opération"

#: library/datetime.rst:604 library/datetime.rst:1202
msgid "Result"
msgstr "Résultat"

#: library/datetime.rst:325
msgid "``t1 = t2 + t3``"
msgstr "``t1 = t2 + t3``"

#: library/datetime.rst:325
#, fuzzy
msgid ""
"Sum of ``t2`` and ``t3``. Afterwards ``t1 - t2 == t3`` and ``t1 - t3 == t2`` "
"are true. (1)"
msgstr ""
"Somme de *t2* et *t3*. Ensuite ``t1 - t2 == t3`` et ``t1 - t3 == t2`` sont "
"des expressions vraies. (1)"

#: library/datetime.rst:329
msgid "``t1 = t2 - t3``"
msgstr "``t1 = t2 - t3``"

#: library/datetime.rst:329
#, fuzzy
msgid ""
"Difference of ``t2``  and ``t3``. Afterwards ``t1 == t2 - t3`` and ``t2 == "
"t1 + t3`` are true. (1)(6)"
msgstr ""
"Différence entre *t2* et *t3*. Ensuite ``t1 == t2 - t3`` et ``t2 == t1 + "
"t3`` sont des expressions vraies. (1)(6)"

#: library/datetime.rst:333
msgid "``t1 = t2 * i or t1 = i * t2``"
msgstr "``t1 = t2 * i or t1 = i * t2``"

#: library/datetime.rst:333
#, fuzzy
msgid ""
"Delta multiplied by an integer. Afterwards ``t1 // i == t2`` is true, "
"provided ``i != 0``."
msgstr ""
"Delta multiplié par un entier. Ensuite ``t1 // i == t2`` est vrai, en "
"admettant que ``i != 0``."

#: library/datetime.rst:337
#, fuzzy
msgid "In general, ``t1  * i == t1 * (i-1) + t1`` is true. (1)"
msgstr "De manière générale, ``t1 \\ i == t1 \\ (i-1) + t1`` est vrai. (1)"

#: library/datetime.rst:340
msgid "``t1 = t2 * f or t1 = f * t2``"
msgstr "``t1 = t2 * f or t1 = f * t2``"

#: library/datetime.rst:340
msgid ""
"Delta multiplied by a float. The result is rounded to the nearest multiple "
"of timedelta.resolution using round-half-to-even."
msgstr ""
"Delta multiplié par un flottant. Le résultat est arrondi au multiple le plus "
"proche de ``timedelta.resolution`` en utilisant la règle de l'arrondi au "
"pair le plus proche."

#: library/datetime.rst:344
msgid "``f = t2 / t3``"
msgstr "``f = t2 / t3``"

#: library/datetime.rst:344
#, fuzzy
msgid ""
"Division (3) of overall duration ``t2`` by interval unit ``t3``. Returns a :"
"class:`float` object."
msgstr ""
"Division (3) de la durée totale *t2* par l'unité d'intervalle *t3*. Renvoie "
"un objet :class:`float`."

#: library/datetime.rst:348
msgid "``t1 = t2 / f or t1 = t2 / i``"
msgstr "``t1 = t2 / f or t1 = t2 / i``"

#: library/datetime.rst:348
msgid ""
"Delta divided by a float or an int. The result is rounded to the nearest "
"multiple of timedelta.resolution using round-half-to-even."
msgstr ""
"Delta divisé par un flottant ou un entier. Le résultat est arrondi au "
"multiple le plus proche de ``timedelta.resolution`` en utilisant la règle de "
"l'arrondi au pair le plus proche."

#: library/datetime.rst:352
msgid "``t1 = t2 // i`` or ``t1 = t2 // t3``"
msgstr "``t1 = t2 // i`` or ``t1 = t2 // t3``"

#: library/datetime.rst:352
msgid ""
"The floor is computed and the remainder (if any) is thrown away. In the "
"second case, an integer is returned. (3)"
msgstr ""
"Le quotient est calculé et le reste (s'il y en a un) est ignoré. Dans le "
"second cas, un entier est renvoyé. (3)"

#: library/datetime.rst:356
msgid "``t1 = t2 % t3``"
msgstr "``t1 = t2 % t3``"

#: library/datetime.rst:356
msgid "The remainder is computed as a :class:`timedelta` object. (3)"
msgstr "Le reste est calculé comme un objet de type :class:`timedelta`. (3)"

#: library/datetime.rst:359
msgid "``q, r = divmod(t1, t2)``"
msgstr "``q, r = divmod(t1, t2)``"

#: library/datetime.rst:359
#, fuzzy
msgid ""
"Computes the quotient and the remainder: ``q = t1 // t2`` (3) and ``r = t1 % "
"t2``. ``q`` is an integer and ``r`` is a :class:`timedelta` object."
msgstr ""
"Calcule le quotient et le reste : ``q = t1 // t2`` (3) et ``r = t1 % t2``. q "
"est un entier et r est un objet :class:`timedelta`."

#: library/datetime.rst:364
msgid "``+t1``"
msgstr "``+t1``"

#: library/datetime.rst:364
msgid "Returns a :class:`timedelta` object with the same value. (2)"
msgstr "Renvoie un objet :class:`timedelta` avec la même valeur. (2)"

#: library/datetime.rst:367
msgid "``-t1``"
msgstr "``-t1``"

#: library/datetime.rst:367
#, fuzzy
msgid ""
"Equivalent to ``timedelta(-t1.days, -t1.seconds, -t1.microseconds)``, and to "
"``t1 * -1``. (1)(4)"
msgstr ""
"équivalent à :class:`timedelta`\\ (*-t1.days*, *-t1.seconds*, *-t1."
"microseconds*), et à ``t1 * -1``. (1)(4)"

#: library/datetime.rst:371
msgid "``abs(t)``"
msgstr "``abs(t)``"

#: library/datetime.rst:371
#, fuzzy
msgid ""
"Equivalent to ``+t`` when ``t.days >= 0``, and to ``-t`` when ``t.days < "
"0``. (2)"
msgstr ""
"équivalent à ``+t`` quand ``t.days >= 0``, et à ``-t`` quand ``t.days < 0``. "
"(2)"

#: library/datetime.rst:374
msgid "``str(t)``"
msgstr "``str(t)``"

#: library/datetime.rst:374
msgid ""
"Returns a string in the form ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, where D is "
"negative for negative ``t``. (5)"
msgstr ""
"Renvoie une chaîne de la forme ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, où D est "
"négatif pour ``t`` négatif. (5)"

#: library/datetime.rst:378
msgid "``repr(t)``"
msgstr "``repr(t)``"

#: library/datetime.rst:378
msgid ""
"Returns a string representation of the :class:`timedelta` object as a "
"constructor call with canonical attribute values."
msgstr ""
"Renvoie une chaîne de la forme objet :class:`timedelta` comme un appel "
"construit avec des valeurs d'attributs canoniques."

#: library/datetime.rst:623 library/datetime.rst:2600
msgid "Notes:"
msgstr "Notes :"

#: library/datetime.rst:387
msgid "This is exact but may overflow."
msgstr "Ceci est exact, mais peut provoquer un débordement."

#: library/datetime.rst:390
msgid "This is exact and cannot overflow."
msgstr "Ceci est exact, et ne peut pas provoquer un débordement."

#: library/datetime.rst:393
#, fuzzy
msgid "Division by zero raises :exc:`ZeroDivisionError`."
msgstr "Une division par 0 lève une :exc:`ZeroDivisionError`."

#: library/datetime.rst:396
#, fuzzy
msgid "``-timedelta.max`` is not representable as a :class:`timedelta` object."
msgstr ""
"*-timedelta.max* n'est pas représentable avec un objet :class:`timedelta`."

#: library/datetime.rst:399
msgid ""
"String representations of :class:`timedelta` objects are normalized "
"similarly to their internal representation. This leads to somewhat unusual "
"results for negative timedeltas. For example::"
msgstr ""
"La représentation en chaîne des objets :class:`timedelta` est normalisée "
"similairement à leur représentation interne. Cela amène à des résultats "
"inhabituels pour des *timedeltas* négatifs. Par exemple ::"

#: library/datetime.rst:403
msgid ""
">>> timedelta(hours=-5)\n"
"datetime.timedelta(days=-1, seconds=68400)\n"
">>> print(_)\n"
"-1 day, 19:00:00"
msgstr ""

#: library/datetime.rst:409
msgid ""
"The expression ``t2 - t3`` will always be equal to the expression ``t2 + (-"
"t3)`` except when t3 is equal to ``timedelta.max``; in that case the former "
"will produce a result while the latter will overflow."
msgstr ""
"L'expression ``t2 - t3`` est toujours égale à l'expression ``t2 + (-t3)`` "
"sauf si ``t3`` vaut ``timedelta.max`` ; dans ce cas, la première expression "
"produit une valeur alors que la seconde produit un débordement."

#: library/datetime.rst:413
msgid ""
"In addition to the operations listed above, :class:`timedelta` objects "
"support certain additions and subtractions with :class:`date` and :class:`."
"datetime` objects (see below)."
msgstr ""
"En plus des opérations listées ci-dessus, les objets :class:`timedelta` "
"implémentent certaines additions et soustractions avec des objets :class:"
"`date` et :class:`datetime` (voir ci-dessous)."

#: library/datetime.rst:417
msgid ""
"Floor division and true division of a :class:`timedelta` object by another :"
"class:`timedelta` object are now supported, as are remainder operations and "
"the :func:`divmod` function. True division and multiplication of a :class:"
"`timedelta` object by a :class:`float` object are now supported."
msgstr ""
"La division entière et la vraie division d'un objet :class:`timedelta` par "
"un autre :class:`timedelta` sont maintenant gérées, comme le sont les "
"opérations de reste euclidien et la fonction :func:`divmod`. La vraie "
"division et la multiplication d'un objet :class:`timedelta` par un :class:"
"`float` sont maintenant implémentées."

#: library/datetime.rst:423
#, fuzzy
msgid ":class:`timedelta` objects support equality and order comparisons."
msgstr ""
"Les comparaisons des objets :class:`timedelta` sont gérées, avec quelques "
"réserves."

#: library/datetime.rst:425
msgid ""
"In Boolean contexts, a :class:`timedelta` object is considered to be true if "
"and only if it isn't equal to ``timedelta(0)``."
msgstr ""
"Dans les contextes booléens, un objet :class:`timedelta` est considéré comme "
"vrai si et seulement s'il n'est pas égal à ``timedelta(0)``."

#: library/datetime.rst:665 library/datetime.rst:1891
msgid "Instance methods:"
msgstr "Méthodes de l'instance :"

#: library/datetime.rst:432
msgid ""
"Return the total number of seconds contained in the duration. Equivalent to "
"``td / timedelta(seconds=1)``. For interval units other than seconds, use "
"the division form directly (e.g. ``td / timedelta(microseconds=1)``)."
msgstr ""
"Renvoie le nombre total de secondes contenues dans la durée. Équivalent à "
"``td / timedelta(seconds=1)``. Pour un intervalle dont l'unité n'est pas la "
"seconde, utilisez directement la division (par exemple, ``td / "
"timedelta(microseconds=1)``)."

#: library/datetime.rst:436
msgid ""
"Note that for very large time intervals (greater than 270 years on most "
"platforms) this method will lose microsecond accuracy."
msgstr ""
"Notez que pour des intervalles de temps très larges (supérieurs à 270 ans "
"sur la plupart des plateformes), cette méthode perdra la précision des "
"microsecondes."

#: library/datetime.rst:442
msgid "Examples of usage: :class:`timedelta`"
msgstr "Exemples d'utilisation de la classe :class:`timedelta` :"

#: library/datetime.rst:444
msgid "An additional example of normalization::"
msgstr "Un exemple supplémentaire de normalisation ::"

#: library/datetime.rst:446
msgid ""
">>> # Components of another_year add up to exactly 365 days\n"
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> another_year = timedelta(weeks=40, days=84, hours=23,\n"
"...                          minutes=50, seconds=600)\n"
">>> year == another_year\n"
"True\n"
">>> year.total_seconds()\n"
"31536000.0"
msgstr ""

#: library/datetime.rst:456
msgid "Examples of :class:`timedelta` arithmetic::"
msgstr "Exemples d'arithmétique avec la classe :class:`timedelta` ::"

#: library/datetime.rst:458
msgid ""
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> ten_years = 10 * year\n"
">>> ten_years\n"
"datetime.timedelta(days=3650)\n"
">>> ten_years.days // 365\n"
"10\n"
">>> nine_years = ten_years - year\n"
">>> nine_years\n"
"datetime.timedelta(days=3285)\n"
">>> three_years = nine_years // 3\n"
">>> three_years, three_years.days // 365\n"
"(datetime.timedelta(days=1095), 3)"
msgstr ""

#: library/datetime.rst:475
msgid ":class:`date` Objects"
msgstr "Objets :class:`date`"

#: library/datetime.rst:477
msgid ""
"A :class:`date` object represents a date (year, month and day) in an "
"idealized calendar, the current Gregorian calendar indefinitely extended in "
"both directions."
msgstr ""
"Un objet :class:`date` représente une date (année, mois et jour) dans un "
"calendrier idéal, le calendrier grégorien actuel étant indéfiniment étendu "
"dans les deux sens."

#: library/datetime.rst:481
msgid ""
"January 1 of year 1 is called day number 1, January 2 of year 1 is called "
"day number 2, and so on. [#]_"
msgstr ""
"Le 1 :sup:`er` janvier de l'année 1 est appelé jour numéro 1, le 2 janvier "
"de l'année 1 est appelé jour numéro 2, et ainsi de suite. [#]_"

#: library/datetime.rst:486
msgid ""
"All arguments are required. Arguments must be integers, in the following "
"ranges:"
msgstr ""
"Tous les arguments sont requis. Les arguments peuvent être des entiers, dans "
"les intervalles suivants :"

#: library/datetime.rst:489
msgid "``MINYEAR <= year <= MAXYEAR``"
msgstr "``MINYEAR <= year <= MAXYEAR``"

#: library/datetime.rst:490
msgid "``1 <= month <= 12``"
msgstr "``1 <= month <= 12``"

#: library/datetime.rst:491
msgid "``1 <= day <= number of days in the given month and year``"
msgstr "``1 <= day <= nombre de jours dans le mois et l'année donnés``"

#: library/datetime.rst:883
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised."
msgstr ""
"Si un argument est donné en dehors de ces intervalles, une :exc:`ValueError` "
"est levée."

#: library/datetime.rst:888
msgid "Other constructors, all class methods:"
msgstr "Autres constructeurs, méthodes de classe :"

#: library/datetime.rst:500
msgid "Return the current local date."
msgstr "Renvoie la date locale courante."

#: library/datetime.rst:502
msgid "This is equivalent to ``date.fromtimestamp(time.time())``."
msgstr "Cela est équivalent à ``date.fromtimestamp(time.time())``."

#: library/datetime.rst:506
msgid ""
"Return the local date corresponding to the POSIX timestamp, such as is "
"returned by :func:`time.time`."
msgstr ""
"Renvoie la date locale correspondant à l'horodatage POSIX, telle que "
"renvoyée par :func:`time.time`."

#: library/datetime.rst:509
msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range of "
"values supported by the platform C :c:func:`localtime` function, and :exc:"
"`OSError` on :c:func:`localtime` failure. It's common for this to be "
"restricted to years from 1970 through 2038. Note that on non-POSIX systems "
"that include leap seconds in their notion of a timestamp, leap seconds are "
"ignored by :meth:`fromtimestamp`."
msgstr ""
"Elle peut lever une :exc:`OverflowError`, si l'horodatage est en dehors des "
"bornes gérées par la fonction C :c:func:`localtime` de la plateforme, et une "
"exception :exc:`OSError` en cas d'échec de :c:func:`localtime`. Il est "
"commun d'être restreint aux années entre 1970 et 2038. Notez que sur les "
"systèmes non *POSIX* qui incluent les secondes intercalaires dans leur "
"notion d'horodatage, ces secondes sont ignorées par :meth:`fromtimestamp`."

#: library/datetime.rst:516
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"function. Raise :exc:`OSError` instead of :exc:`ValueError` on :c:func:"
"`localtime` failure."
msgstr ""
"Lève une :exc:`OverflowError` plutôt qu'une :exc:`ValueError` si "
"l'horodatage (*timestamp* en anglais) est en dehors des bornes gérées par la "
"fonction C :c:func:`localtime` de la plateforme. Lève une :exc:`OSError` "
"plutôt qu'une :exc:`ValueError` en cas d'échec de :c:func:`localtime`."

#: library/datetime.rst:525
msgid ""
"Return the date corresponding to the proleptic Gregorian ordinal, where "
"January 1 of year 1 has ordinal 1."
msgstr ""
"Renvoie la date correspondant à l'ordinal grégorien proleptique, où le 1er "
"janvier de l'an 1 a l'ordinal 1."

#: library/datetime.rst:528
#, fuzzy
msgid ""
":exc:`ValueError` is raised unless ``1 <= ordinal <= date.max.toordinal()``. "
"For any date ``d``, ``date.fromordinal(d.toordinal()) == d``."
msgstr ""
":exc:`ValueError` est levée à moins que ``1 <= ordinal <= date.max."
"toordinal()``. Pour toute date *d*, ``date.fromordinal(d.toordinal()) == d``."

#: library/datetime.rst:535
#, fuzzy
msgid ""
"Return a :class:`date` corresponding to a *date_string* given in any valid "
"ISO 8601 format, with the following exceptions:"
msgstr ""
"Renvoie une classe :class:`.datetime` correspondant à *date_string* dans un "
"format ISO 8601 valide, avec les exceptions suivantes :"

#: library/datetime.rst:1048
#, fuzzy
msgid ""
"Reduced precision dates are not currently supported (``YYYY-MM``, ``YYYY``)."
msgstr "Les dates ordinales ne sont actuellement pas gérées."

#: library/datetime.rst:1050
msgid ""
"Extended date representations are not currently supported (``±YYYYYY-MM-"
"DD``)."
msgstr ""

#: library/datetime.rst:1052
#, fuzzy
msgid "Ordinal dates are not currently supported (``YYYY-OOO``)."
msgstr "Les dates ordinales ne sont actuellement pas gérées."

#: library/datetime.rst:1054 library/datetime.rst:1520
msgid "Examples::"
msgstr "Exemples ::"

#: library/datetime.rst:546
msgid ""
">>> from datetime import date\n"
">>> date.fromisoformat('2019-12-04')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('20191204')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('2021-W01-1')\n"
"datetime.date(2021, 1, 4)"
msgstr ""

#: library/datetime.rst:555
msgid "Previously, this method only supported the format ``YYYY-MM-DD``."
msgstr ""
"Auparavant, cette méthode prenait en charge seulement le format ``YYYY-MM-"
"DD``."

#: library/datetime.rst:560
msgid ""
"Return a :class:`date` corresponding to the ISO calendar date specified by "
"year, week and day. This is the inverse of the function :meth:`date."
"isocalendar`."
msgstr ""
"Renvoie une :class:`date` correspondant à la date du calendrier ISO définie "
"par l'année, la semaine et le jour. C'est la réciproque de la fonction :meth:"
"`date.isocalendar`."

#: library/datetime.rst:570
msgid "The earliest representable date, ``date(MINYEAR, 1, 1)``."
msgstr "La plus vieille date représentable, ``date(MINYEAR, 1, 1)``."

#: library/datetime.rst:575
msgid "The latest representable date, ``date(MAXYEAR, 12, 31)``."
msgstr "La dernière date représentable, ``date(MAXYEAR, 12, 31)``."

#: library/datetime.rst:580
msgid ""
"The smallest possible difference between non-equal date objects, "
"``timedelta(days=1)``."
msgstr ""
"La plus petite différence possible entre deux objets dates non-égaux, "
"``timedelta(days=1)``."

#: library/datetime.rst:1150
msgid "Between :const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr "Entre :const:`MINYEAR` et :const:`MAXYEAR` inclus."

#: library/datetime.rst:1155
msgid "Between 1 and 12 inclusive."
msgstr "Entre 1 et 12 inclus."

#: library/datetime.rst:1160
msgid "Between 1 and the number of days in the given month of the given year."
msgstr "Entre 1 et le nombre de jours du mois donné de l'année donnée."

#: library/datetime.rst:606
msgid "``date2 = date1 + timedelta``"
msgstr "``date2 = date1 + timedelta``"

#: library/datetime.rst:606
#, fuzzy
msgid "``date2`` will be ``timedelta.days`` days after ``date1``. (1)"
msgstr ""
"``date2`` est décalée de ``timedelta.days`` jours par rapport à ``date1``. "
"(1)"

#: library/datetime.rst:609
msgid "``date2 = date1 - timedelta``"
msgstr "``date2 = date1 - timedelta``"

#: library/datetime.rst:609
#, fuzzy
msgid "Computes ``date2`` such that ``date2 + timedelta == date1``. (2)"
msgstr "Calcule ``date2`` de façon à avoir ``date2 + timedelta == date1``. (2)"

#: library/datetime.rst:612
msgid "``timedelta = date1 - date2``"
msgstr "``timedelta = date1 - date2``"

#: library/datetime.rst:1208
msgid "\\(3)"
msgstr "\\(3)"

#: library/datetime.rst:0
#, fuzzy
msgid "``date1 == date2``"
msgstr "``date1 < date2``"

#: library/datetime.rst:0
#, fuzzy
msgid "``date1 != date2``"
msgstr "``date1 < date2``"

#: library/datetime.rst:1210
msgid "Equality comparison. (4)"
msgstr ""

#: library/datetime.rst:0
msgid "``date1 < date2``"
msgstr "``date1 < date2``"

#: library/datetime.rst:0
#, fuzzy
msgid "``date1 > date2``"
msgstr "``date1 < date2``"

#: library/datetime.rst:0
#, fuzzy
msgid "``date1 <= date2``"
msgstr "``date1 < date2``"

#: library/datetime.rst:0
#, fuzzy
msgid "``date1 >= date2``"
msgstr "``date1 < date2``"

#: library/datetime.rst:1213
msgid "Order comparison. (5)"
msgstr ""

#: library/datetime.rst:626
msgid ""
"*date2* is moved forward in time if ``timedelta.days > 0``, or backward if "
"``timedelta.days < 0``. Afterward ``date2 - date1 == timedelta.days``. "
"``timedelta.seconds`` and ``timedelta.microseconds`` are ignored. :exc:"
"`OverflowError` is raised if ``date2.year`` would be smaller than :const:"
"`MINYEAR` or larger than :const:`MAXYEAR`."
msgstr ""
"``date2`` est déplacée en avant dans le temps si ``timedelta.days > 0``, ou "
"en arrière si ``timedelta.days < 0``. Après quoi ``date2 - date1 == "
"timedelta.days``. ``timedelta.seconds`` et ``timedelta.microseconds`` sont "
"ignorés. Une :exc:`OverflowError` est levée si ``date2.year`` devait être "
"inférieure à :const:`MINYEAR` ou supérieure à :const:`MAXYEAR`."

#: library/datetime.rst:633
msgid "``timedelta.seconds`` and ``timedelta.microseconds`` are ignored."
msgstr "``timedelta.seconds`` et ``timedelta.microseconds`` sont ignorés."

#: library/datetime.rst:636
#, fuzzy
msgid ""
"This is exact, and cannot overflow. ``timedelta.seconds`` and ``timedelta."
"microseconds`` are 0, and ``date2 + timedelta == date1`` after."
msgstr ""
"Cela est exact, et ne peut pas provoquer de débordement. ``timedelta."
"seconds`` et ``timedelta.microseconds`` valent ``0``, et ``date2 + timedelta "
"== date1`` après cela."

#: library/datetime.rst:640
#, fuzzy
msgid ":class:`date` objects are equal if they represent the same date."
msgstr "Renvoie un objet :class:`date` avec les mêmes année, mois et jour."

#: library/datetime.rst:642
msgid ""
":class:`!date` objects that are not also :class:`.datetime` instances are "
"never equal to :class:`!datetime` objects, even if they represent the same "
"date."
msgstr ""

#: library/datetime.rst:647
#, fuzzy
msgid ""
"*date1* is considered less than *date2* when *date1* precedes *date2* in "
"time. In other words, ``date1 < date2`` if and only if ``date1.toordinal() < "
"date2.toordinal()``."
msgstr ""
"``date1`` est considérée comme inférieure à ``date2`` quand ``date1`` "
"précède ``date2`` dans le temps. (4)"

#: library/datetime.rst:651
#, fuzzy
msgid ""
"Order comparison between a :class:`!date` object that is not also a :class:`."
"datetime` instance and a :class:`!datetime` object raises :exc:`TypeError`."
msgstr ""
"Les comparaisons d'égalité entre des instances :class:`.datetime` naïves et "
"avisées ne lèvent pas d'exception :exc:`TypeError`."

#: library/datetime.rst:1281
msgid ""
"Comparison between :class:`.datetime` object and an instance of the :class:"
"`date` subclass that is not a :class:`!datetime` subclass no longer converts "
"the latter to :class:`!date`, ignoring the time part and the time zone. The "
"default behavior can be changed by overriding the special comparison methods "
"in subclasses."
msgstr ""

#: library/datetime.rst:663
msgid ""
"In Boolean contexts, all :class:`date` objects are considered to be true."
msgstr ""
"Dans des contextes booléens, tous les objets :class:`date` sont considérés "
"comme vrai."

#: library/datetime.rst:669
msgid ""
"Return a date with the same value, except for those parameters given new "
"values by whichever keyword arguments are specified."
msgstr ""
"Renvoie une date avec la même valeur, à l'exception des paramètres nommés "
"pour lesquels une nouvelle valeur est donnée en argument."

#: library/datetime.rst:1937
msgid "Example::"
msgstr "Exemple ::"

#: library/datetime.rst:674
msgid ""
">>> from datetime import date\n"
">>> d = date(2002, 12, 31)\n"
">>> d.replace(day=26)\n"
"datetime.date(2002, 12, 26)"
msgstr ""

#: library/datetime.rst:679
msgid ""
":class:`date` objects are also supported by generic function :func:`copy."
"replace`."
msgstr ""

#: library/datetime.rst:1405
msgid ""
"Return a :class:`time.struct_time` such as returned by :func:`time."
"localtime`."
msgstr ""
"Renvoie une :class:`time.struct_time` telle que renvoyée par :func:`time."
"localtime`."

#: library/datetime.rst:687
msgid "The hours, minutes and seconds are 0, and the DST flag is -1."
msgstr ""
"Les heures, minutes et secondes sont égales à 0 et le drapeau DST vaut -1."

#: library/datetime.rst:1407
msgid "``d.timetuple()`` is equivalent to::"
msgstr "``d.timetuple()`` est équivalent à ::"

#: library/datetime.rst:691
msgid ""
"time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))"
msgstr ""

#: library/datetime.rst:693
#, fuzzy
msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st."
msgstr ""
"où ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` est le "
"numéro du jour dans l'année courante commençant par ``1`` pour le 1\\ :sup:"
"`er` janvier."

#: library/datetime.rst:699
#, fuzzy
msgid ""
"Return the proleptic Gregorian ordinal of the date, where January 1 of year "
"1 has ordinal 1. For any :class:`date` object ``d``, ``date.fromordinal(d."
"toordinal()) == d``."
msgstr ""
"Renvoie l'ordinal grégorien proleptique de la date, où le 1er janvier de "
"l'an 1 a l'ordinal 1. Pour tout objet :class:`date` *d*, ``date."
"fromordinal(d.toordinal()) == d``."

#: library/datetime.rst:706
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6. "
"For example, ``date(2002, 12, 4).weekday() == 2``, a Wednesday. See also :"
"meth:`isoweekday`."
msgstr ""
"Renvoie le jour de la semaine sous forme de nombre, où lundi vaut 0 et "
"dimanche vaut 6. Par exemple, ``date(2002, 12, 4).weekday() == 2``, un "
"mercredi. Voir aussi :meth:`isoweekday`."

#: library/datetime.rst:713
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7. "
"For example, ``date(2002, 12, 4).isoweekday() == 3``, a Wednesday. See also :"
"meth:`weekday`, :meth:`isocalendar`."
msgstr ""
"Renvoie le jour de la semaine sous forme de nombre, où lundi vaut 1 et "
"dimanche vaut 7. Par exemple, ``date(2002, 12, 4).isoweekday() == 3``, un "
"mercredi. Voir aussi :meth:`weekday`, :meth:`isocalendar`."

#: library/datetime.rst:720
msgid ""
"Return a :term:`named tuple` object with three components: ``year``, "
"``week`` and ``weekday``."
msgstr ""
"Renvoie un objet :term:`named tuple` avec trois composants : ``year``, "
"``week`` et ``weekday``."

#: library/datetime.rst:723
msgid ""
"The ISO calendar is a widely used variant of the Gregorian calendar. [#]_"
msgstr ""
"Le calendrier ISO est une variante largement utilisée du calendrier "
"grégorien. [#]_"

#: library/datetime.rst:725
msgid ""
"The ISO year consists of 52 or 53 full weeks, and where a week starts on a "
"Monday and ends on a Sunday. The first week of an ISO year is the first "
"(Gregorian) calendar week of a year containing a Thursday. This is called "
"week number 1, and the ISO year of that Thursday is the same as its "
"Gregorian year."
msgstr ""
"Une année ISO est composée de 52 ou 53 semaines pleines, où chaque semaine "
"débute un lundi et se termine un dimanche. La première semaine d'une année "
"ISO est la première semaine calendaire (grégorienne) de l'année comportant "
"un jeudi. Elle est appelée la semaine numéro 1, et l'année ISO de ce jeudi "
"est la même que son année Grégorienne."

#: library/datetime.rst:730
msgid ""
"For example, 2004 begins on a Thursday, so the first week of ISO year 2004 "
"begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004::"
msgstr ""
"Par exemple, l'année 2004 débute un jeudi, donc la première semaine de "
"l'année ISO 2004 débute le lundi 29 décembre 2003 et se termine le dimanche "
"4 janvier 2004 ::"

#: library/datetime.rst:733
msgid ""
">>> from datetime import date\n"
">>> date(2003, 12, 29).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n"
">>> date(2004, 1, 4).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=7)"
msgstr ""

#: library/datetime.rst:739
msgid "Result changed from a tuple to a :term:`named tuple`."
msgstr "Le résultat a changé d'un *n*-uplet à un :term:`named tuple`."

#: library/datetime.rst:744
msgid ""
"Return a string representing the date in ISO 8601 format, ``YYYY-MM-DD``::"
msgstr ""
"Renvoie une chaîne représentant la date au format ISO 8601, ``YYYY-MM-DD`` ::"

#: library/datetime.rst:746
msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).isoformat()\n"
"'2002-12-04'"
msgstr ""

#: library/datetime.rst:752
#, fuzzy
msgid "For a date ``d``, ``str(d)`` is equivalent to ``d.isoformat()``."
msgstr "Pour une date *d*, ``str(d)`` est équivalent à ``d.isoformat()``."

#: library/datetime.rst:757
msgid "Return a string representing the date::"
msgstr "Renvoie une chaîne représentant la date ::"

#: library/datetime.rst:759
msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).ctime()\n"
"'Wed Dec  4 00:00:00 2002'"
msgstr ""

#: library/datetime.rst:1591
msgid "``d.ctime()`` is equivalent to::"
msgstr "``d.ctime()`` est équivalent à ::"

#: library/datetime.rst:1593
msgid "time.ctime(time.mktime(d.timetuple()))"
msgstr ""

#: library/datetime.rst:767
msgid ""
"on platforms where the native C :c:func:`ctime` function (which :func:`time."
"ctime` invokes, but which :meth:`date.ctime` does not invoke) conforms to "
"the C standard."
msgstr ""
"sur les plateformes où la fonction C native :c:func:`ctime` (que :func:`time."
"ctime` invoque, mais pas :meth:`date.ctime`) est conforme au standard C."

#: library/datetime.rst:774
msgid ""
"Return a string representing the date, controlled by an explicit format "
"string. Format codes referring to hours, minutes or seconds will see 0 "
"values. See also :ref:`strftime-strptime-behavior` and :meth:`date."
"isoformat`."
msgstr ""
"Renvoie une chaîne représentant la date, contrôlée par une chaîne de "
"formatage explicite. Les codes de formatage se référant aux heures, minutes "
"ou secondes auront pour valeur 0. Voir :ref:`strftime-strptime-behavior` et :"
"meth:`date.isoformat`."

#: library/datetime.rst:781
msgid ""
"Same as :meth:`.date.strftime`. This makes it possible to specify a format "
"string for a :class:`.date` object in :ref:`formatted string literals <f-"
"strings>` and when using :meth:`str.format`. See also :ref:`strftime-"
"strptime-behavior` and :meth:`date.isoformat`."
msgstr ""
"Identique à :meth:`.date.strftime`. Cela permet de spécifier une chaîne de "
"formatage pour un objet :class:`.date` dans une :ref:`chaîne de formatage "
"littérale <f-strings>` et à l'utilisation de :meth:`str.format`. Voir :ref:"
"`strftime-strptime-behavior` et :meth:`date.isoformat`."

#: library/datetime.rst:787
msgid "Examples of Usage: :class:`date`"
msgstr "Exemple d'utilisation de la classe :class:`date` :"

#: library/datetime.rst:789
msgid "Example of counting days to an event::"
msgstr "Exemple de décompte des jours avant un évènement ::"

#: library/datetime.rst:791
msgid ""
">>> import time\n"
">>> from datetime import date\n"
">>> today = date.today()\n"
">>> today\n"
"datetime.date(2007, 12, 5)\n"
">>> today == date.fromtimestamp(time.time())\n"
"True\n"
">>> my_birthday = date(today.year, 6, 24)\n"
">>> if my_birthday < today:\n"
"...     my_birthday = my_birthday.replace(year=today.year + 1)\n"
"...\n"
">>> my_birthday\n"
"datetime.date(2008, 6, 24)\n"
">>> time_to_birthday = abs(my_birthday - today)\n"
">>> time_to_birthday.days\n"
"202"
msgstr ""

#: library/datetime.rst:808
msgid "More examples of working with :class:`date`:"
msgstr "Plus d'exemples avec la classe :class:`date` :"

#: library/datetime.rst:810
msgid ""
">>> from datetime import date\n"
">>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
"\n"
">>> # Methods related to formatting string output\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"'Monday 11. March 2002'\n"
">>> d.ctime()\n"
"'Mon Mar 11 00:00:00 2002'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, \"day\", \"month\")\n"
"'The day is 11, the month is March.'\n"
"\n"
">>> # Methods for to extracting 'components' under different calendars\n"
">>> t = d.timetuple()\n"
">>> for i in t:     \n"
"...     print(i)\n"
"2002                # year\n"
"3                   # month\n"
"11                  # day\n"
"0\n"
"0\n"
"0\n"
"0                   # weekday (0 = Monday)\n"
"70                  # 70th day in the year\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> for i in ic:    \n"
"...     print(i)\n"
"2002                # ISO year\n"
"11                  # ISO week number\n"
"1                   # ISO day number ( 1 = Monday )\n"
"\n"
">>> # A date object is immutable; all operations produce a new object\n"
">>> d.replace(year=2005)\n"
"datetime.date(2005, 3, 11)"
msgstr ""

#: library/datetime.rst:857
msgid ":class:`.datetime` Objects"
msgstr "Objets :class:`.datetime`"

#: library/datetime.rst:859
msgid ""
"A :class:`.datetime` object is a single object containing all the "
"information from a :class:`date` object and a :class:`.time` object."
msgstr ""
"Un objet :class:`.datetime` est un seul et même objet contenant toute "
"l'information d'un objet :class:`date` et d'un objet :class:`time`."

#: library/datetime.rst:862
msgid ""
"Like a :class:`date` object, :class:`.datetime` assumes the current "
"Gregorian calendar extended in both directions; like a :class:`.time` "
"object, :class:`.datetime` assumes there are exactly 3600\\*24 seconds in "
"every day."
msgstr ""
"Comme un objet :class:`date`, un objet :class:`.datetime` utilise le "
"calendrier Grégorien actuel étendu vers le passé et le futur ; comme un "
"objet :class:`.time`, un objet :class:`.datetime` suppose qu'il y a "
"exactement 3600\\*24 secondes chaque jour."

#: library/datetime.rst:866
msgid "Constructor:"
msgstr "Constructeur :"

#: library/datetime.rst:870
msgid ""
"The *year*, *month* and *day* arguments are required. *tzinfo* may be "
"``None``, or an instance of a :class:`tzinfo` subclass. The remaining "
"arguments must be integers in the following ranges:"
msgstr ""
"Les arguments *year*, *month* et *day* sont requis. *tzinfo* peut être "
"``None`` ou une instance d'une sous-classe de :class:`tzinfo`. Les arguments "
"restant doivent être des nombres, dans les intervalles suivants :"

#: library/datetime.rst:874
msgid "``MINYEAR <= year <= MAXYEAR``,"
msgstr "``MINYEAR <= year <= MAXYEAR``,"

#: library/datetime.rst:875
msgid "``1 <= month <= 12``,"
msgstr "``1 <= month <= 12``,"

#: library/datetime.rst:876
msgid "``1 <= day <= number of days in the given month and year``,"
msgstr "``1 <= day <= nombre de jours dans le mois donné de l'année donnée``,"

#: library/datetime.rst:1755
msgid "``0 <= hour < 24``,"
msgstr "``0 <= hour < 24``,"

#: library/datetime.rst:1756
msgid "``0 <= minute < 60``,"
msgstr "``0 <= minute < 60``,"

#: library/datetime.rst:1757
msgid "``0 <= second < 60``,"
msgstr "``0 <= second < 60``,"

#: library/datetime.rst:1758
msgid "``0 <= microsecond < 1000000``,"
msgstr "``0 <= microsecond < 1000000``,"

#: library/datetime.rst:1759
msgid "``fold in [0, 1]``."
msgstr "``fold in [0, 1]``."

#: library/datetime.rst:1326 library/datetime.rst:1904
#, fuzzy
msgid "Added the *fold* parameter."
msgstr "Ajout de l'argument ``fold``."

#: library/datetime.rst:892
#, fuzzy
msgid "Return the current local date and time, with :attr:`.tzinfo` ``None``."
msgstr "Renvoie la date locale actuelle, avec :attr:`.tzinfo` ``None``."

#: library/datetime.rst:894
msgid "Equivalent to::"
msgstr "Équivalent à ::"

#: library/datetime.rst:896
#, fuzzy
msgid "datetime.fromtimestamp(time.time())"
msgstr "Cela est équivalent à ``date.fromtimestamp(time.time())``."

#: library/datetime.rst:898
msgid "See also :meth:`now`, :meth:`fromtimestamp`."
msgstr "Voir aussi :meth:`now`, :meth:`fromtimestamp`."

#: library/datetime.rst:900
msgid ""
"This method is functionally equivalent to :meth:`now`, but without a ``tz`` "
"parameter."
msgstr ""
"Cette méthode est fonctionnellement équivalente à :meth:`now`, mais sans le "
"paramètre ``tz``."

#: library/datetime.rst:905
msgid "Return the current local date and time."
msgstr "Renvoie la date et l'heure locale actuelle."

#: library/datetime.rst:907
msgid ""
"If optional argument *tz* is ``None`` or not specified, this is like :meth:"
"`today`, but, if possible, supplies more precision than can be gotten from "
"going through a :func:`time.time` timestamp (for example, this may be "
"possible on platforms supplying the C :c:func:`gettimeofday` function)."
msgstr ""
"Si l'argument optionnel *tz* est ``None`` ou n'est pas spécifié, la méthode "
"est similaire à :meth:`today`, mais, si possible, apporte plus de précisions "
"que ce qui peut être trouvé à travers un horodatage :func:`time.time` (par "
"exemple, cela peut être possible sur des plateformes fournissant la fonction "
"C :c:func:`gettimeofday`)."

#: library/datetime.rst:913
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the current date and time are converted to *tz*’s time zone."
msgstr ""
"Si *tz* n'est pas ``None``, il doit être une instance d'une sous-classe :"
"class:`tzinfo`, et la date et l'heure courantes sont converties vers le "
"fuseau horaire *tz*."

#: library/datetime.rst:916
msgid "This function is preferred over :meth:`today` and :meth:`utcnow`."
msgstr "Cette fonction est préférée à :meth:`today` et :meth:`utcnow`."

#: library/datetime.rst:920
msgid ""
"Subsequent calls to :meth:`!datetime.now` may return the same instant "
"depending on the precision of the underlying clock."
msgstr ""

#: library/datetime.rst:925
msgid "Return the current UTC date and time, with :attr:`.tzinfo` ``None``."
msgstr ""
"Renvoie la date et l'heure UTC actuelle, avec :attr:`.tzinfo` ``None``."

#: library/datetime.rst:927
msgid ""
"This is like :meth:`now`, but returns the current UTC date and time, as a "
"naive :class:`.datetime` object. An aware current UTC datetime can be "
"obtained by calling ``datetime.now(timezone.utc)``. See also :meth:`now`."
msgstr ""
"C'est semblable à :meth:`now`, mais renvoie la date et l'heure UTC "
"courantes, comme un objet :class:`.datetime` naïf. Un ``datetime`` UTC "
"courant avisé peut être obtenu en appelant ``datetime.now(timezone.utc)``. "
"Voir aussi :meth:`now`."

#: library/datetime.rst:933
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC. As such, the recommended way to create an object representing the "
"current time in UTC is by calling ``datetime.now(timezone.utc)``."
msgstr ""
"Parce que les objets naïfs ``datetime`` sont traités par de nombreuses "
"méthodes ``datetime`` comme des heures locales, il est préférable d'utiliser "
"les dates connues pour représenter les heures en UTC. En tant que tel, le "
"moyen recommandé pour créer un objet représentant l'heure actuelle en UTC "
"est d'appeler ``datetime.now(timezone.utc)``."

#: library/datetime.rst:940
msgid "Use :meth:`datetime.now` with :attr:`UTC` instead."
msgstr ""

#: library/datetime.rst:945
msgid ""
"Return the local date and time corresponding to the POSIX timestamp, such as "
"is returned by :func:`time.time`. If optional argument *tz* is ``None`` or "
"not specified, the timestamp is converted to the platform's local date and "
"time, and the returned :class:`.datetime` object is naive."
msgstr ""
"Renvoie la date et l'heure locales correspondant à l'horodatage (*timestamp* "
"en anglais) *POSIX*, comme renvoyé par :func:`time.time`. Si l'argument "
"optionnel *tz* est ``None`` ou n'est pas spécifié, l'horodatage est converti "
"vers la date et l'heure locales de la plateforme, et l'objet :class:`."
"datetime` renvoyé est naïf."

#: library/datetime.rst:950
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the timestamp is converted to *tz*’s time zone."
msgstr ""
"Si *tz* n'est pas ``None``, il doit être une instance d'une sous-classe :"
"class:`tzinfo`, et l'horodatage (*timestamp* en anglais) est converti vers "
"le fuseau horaire *tz*."

#: library/datetime.rst:953
msgid ""
":meth:`fromtimestamp` may raise :exc:`OverflowError`, if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"or :c:func:`gmtime` functions, and :exc:`OSError` on :c:func:`localtime` or :"
"c:func:`gmtime` failure. It's common for this to be restricted to years in "
"1970 through 2038. Note that on non-POSIX systems that include leap seconds "
"in their notion of a timestamp, leap seconds are ignored by :meth:"
"`fromtimestamp`, and then it's possible to have two timestamps differing by "
"a second that yield identical :class:`.datetime` objects. This method is "
"preferred over :meth:`utcfromtimestamp`."
msgstr ""
":meth:`fromtimestamp` peut lever une :exc:`OverflowError`, si l'horodatage "
"est en dehors de l'intervalle de valeurs gérées par les fonctions C :c:func:"
"`localtime` ou :c:func:`gmtime` de la plateforme, et une :exc:`OSError` en "
"cas d'échec de :c:func:`localtime` ou :c:func:`gmtime`. Il est courant "
"d'être restreint aux années de 1970 à 2038. Notez que sur les systèmes non "
"*POSIX* qui incluent les secondes intercalaires dans leur notion "
"d'horodatage, les secondes intercalaires sont ignorées par :meth:"
"`fromtimestamp`, et il est alors possible d'avoir deux horodatages différant "
"d'une seconde produisant un objet :class:`.datetime` identique. Cette "
"méthode est préférée à :meth:`utcfromtimestamp`."

#: library/datetime.rst:964
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"or :c:func:`gmtime` functions. Raise :exc:`OSError` instead of :exc:"
"`ValueError` on :c:func:`localtime` or :c:func:`gmtime` failure."
msgstr ""
"Lève une :exc:`OverflowError` plutôt qu'une :exc:`ValueError` si "
"l'horodatage est en dehors de l'intervalle de valeurs gérées par les "
"fonctions C :c:func:`localtime` ou :c:func:`gmtime` de la plateforme. Lève "
"une :exc:`OSError` plutôt qu'une :exc:`ValueError` en cas d'échec de :c:func:"
"`localtime` ou :c:func:`gmtime`."

#: library/datetime.rst:971
msgid ":meth:`fromtimestamp` may return instances with :attr:`.fold` set to 1."
msgstr ""
":meth:`fromtimestamp` peut renvoyer des instances avec l'attribut :attr:`."
"fold` à 1."

#: library/datetime.rst:976
msgid ""
"Return the UTC :class:`.datetime` corresponding to the POSIX timestamp, "
"with :attr:`.tzinfo` ``None``.  (The resulting object is naive.)"
msgstr ""
"Renvoie la classe UTC :class:`.datetime` correspondant à l'horodatage POSIX, "
"avec :attr:`.tzinfo` ``None`` (l'objet résultant est naïf)."

#: library/datetime.rst:979
msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range of "
"values supported by the platform C :c:func:`gmtime` function, and :exc:"
"`OSError` on :c:func:`gmtime` failure. It's common for this to be restricted "
"to years in 1970 through 2038."
msgstr ""
"Cela peut lever une :exc:`OverflowError`, si l'horodatage est en dehors de "
"l'intervalle de valeurs gérées par la fonction C :c:func:`gmtime` de la "
"plateforme, et une :exc:`OSError` en cas d'échec de :c:func:`gmtime`. Il est "
"courant d'être restreint aux années de 1970 à 2038."

#: library/datetime.rst:984
msgid "To get an aware :class:`.datetime` object, call :meth:`fromtimestamp`::"
msgstr ""
"Pour obtenir un objet :class:`.datetime` avisé, appelez :meth:"
"`fromtimestamp` ::"

#: library/datetime.rst:986
msgid "datetime.fromtimestamp(timestamp, timezone.utc)"
msgstr ""

#: library/datetime.rst:988
msgid ""
"On the POSIX compliant platforms, it is equivalent to the following "
"expression::"
msgstr ""
"Sur les plateformes respectant *POSIX*, cela est équivalent à l'expression "
"suivante ::"

#: library/datetime.rst:991
msgid ""
"datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)"
msgstr ""

#: library/datetime.rst:993
msgid ""
"except the latter formula always supports the full years range: between :"
"const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr ""
"excepté que la dernière formule gère l'intervalle complet des années entre :"
"const:`MINYEAR` et :const:`MAXYEAR` incluses."

#: library/datetime.rst:998
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC. As such, the recommended way to create an object representing a "
"specific timestamp in UTC is by calling ``datetime.fromtimestamp(timestamp, "
"tz=timezone.utc)``."
msgstr ""
"Parce que les objets naïfs ``datetime`` sont traités par de nombreuses "
"méthodes ``datetime`` comme des heures locales, il est préférable d'utiliser "
"les dates connues pour représenter les heures en UTC. En tant que tel, le "
"moyen recommandé pour créer un objet représentant un horodatage spécifique "
"en UTC est d'appeler ``datetime.fromtimestamp(timestamp, tz=timezone.utc)``."

#: library/datetime.rst:1004
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`gmtime` "
"function. Raise :exc:`OSError` instead of :exc:`ValueError` on :c:func:"
"`gmtime` failure."
msgstr ""
"Lève une :exc:`OverflowError` plutôt qu'une :exc:`ValueError` si "
"l'horodatage est en dehors de l'intervalle de valeurs gérées par la fonction "
"C :c:func:`gmtime` de la plateforme. Lève une :exc:`OSError` plutôt qu'une :"
"exc:`ValueError` en cas d'échec de :c:func:`gmtime`."

#: library/datetime.rst:1012
msgid "Use :meth:`datetime.fromtimestamp` with :attr:`UTC` instead."
msgstr ""

#: library/datetime.rst:1017
msgid ""
"Return the :class:`.datetime` corresponding to the proleptic Gregorian "
"ordinal, where January 1 of year 1 has ordinal 1. :exc:`ValueError` is "
"raised unless ``1 <= ordinal <= datetime.max.toordinal()``. The hour, "
"minute, second and microsecond of the result are all 0, and :attr:`.tzinfo` "
"is ``None``."
msgstr ""
"Renvoie le :class:`.datetime` correspondant à l'ordinal du calendrier "
"grégorien proleptique, où le 1er janvier de l'an 1 a l'ordinal 1. Une :exc:"
"`ValueError` est levée à moins que ``1 <= ordinal <= datetime.max."
"toordinal()``. Les heures, minutes, secondes et microsecondes du résultat "
"valent toutes 0, et :attr:`.tzinfo` est ``None``."

#: library/datetime.rst:1025
#, fuzzy
msgid ""
"Return a new :class:`.datetime` object whose date components are equal to "
"the given :class:`date` object's, and whose time components are equal to the "
"given :class:`.time` object's. If the *tzinfo* argument is provided, its "
"value is used to set the :attr:`.tzinfo` attribute of the result, otherwise "
"the :attr:`~.time.tzinfo` attribute of the *time* argument is used.  If the "
"*date* argument is a :class:`.datetime` object, its time components and :"
"attr:`.tzinfo` attributes are ignored."
msgstr ""
"Renvoie un nouvel objet :class:`.datetime` dont les composants de date sont "
"égaux à ceux de l'objet :class:`date` donné, et dont les composants de temps "
"sont égaux à ceux de l'objet :class:`time` donné. Si l'argument *tzinfo* est "
"fourni, sa valeur est utilisée pour initialiser l'attribut :attr:`.tzinfo` "
"du résultat, autrement l'attribut :attr:`~.time.tzinfo` de l'argument *time* "
"est utilisé."

#: library/datetime.rst:1033
#, fuzzy
msgid ""
"For any :class:`.datetime` object ``d``, ``d == datetime.combine(d.date(), d."
"time(), d.tzinfo)``."
msgstr ""
"Pour tout objet :class:`.datetime` *d*`, ``d == datetime.combine(d.date(), d."
"time(), d.tzinfo)``. Si *date* est un objet :class:`.datetime`, ses "
"composants de temps et attributs :attr:`.tzinfo` sont ignorés."

#: library/datetime.rst:1036
msgid "Added the *tzinfo* argument."
msgstr "Ajout de l'argument *tzinfo*."

#: library/datetime.rst:1042
msgid ""
"Return a :class:`.datetime` corresponding to a *date_string* in any valid "
"ISO 8601 format, with the following exceptions:"
msgstr ""
"Renvoie une classe :class:`.datetime` correspondant à *date_string* dans un "
"format ISO 8601 valide, avec les exceptions suivantes :"

#: library/datetime.rst:1855
msgid "Time zone offsets may have fractional seconds."
msgstr ""
"Les décalages de fuseaux horaires peuvent comporter des fractions de "
"secondes."

#: library/datetime.rst:1046
msgid "The ``T`` separator may be replaced by any single unicode character."
msgstr ""
"Le séparateur ``T`` peut être remplacé par n'importe quel caractère Unicode."

#: library/datetime.rst:1860
msgid "Fractional hours and minutes are not supported."
msgstr "Les fractions d'heures et de minutes ne sont pas gérées."

#: library/datetime.rst:1056
msgid ""
">>> from datetime import datetime\n"
">>> datetime.fromisoformat('2011-11-04')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('20111104')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23Z')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('20111104T000523')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-W01-2T00:05:23.283')\n"
"datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone."
"utc)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')   \n"
"datetime.datetime(2011, 11, 4, 0, 5, 23,\n"
"    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))"
msgstr ""

#: library/datetime.rst:1078
#, fuzzy
msgid ""
"Previously, this method only supported formats that could be emitted by :"
"meth:`date.isoformat` or :meth:`datetime.isoformat`."
msgstr ""
"Auparavant, cette méthode prenait en charge seulement les formats émis par :"
"meth:`date.isoformat()` et :meth:`datetime.isoformat()`."

#: library/datetime.rst:1085
msgid ""
"Return a :class:`.datetime` corresponding to the ISO calendar date specified "
"by year, week and day. The non-date components of the datetime are populated "
"with their normal default values. This is the inverse of the function :meth:"
"`datetime.isocalendar`."
msgstr ""
"Renvoie une classe :class:`.datetime` correspondant à la date du calendrier "
"ISO spécifiée par année, semaine et jour. Les composantes ne relevant pas de "
"la date de *datetime* sont renseignées avec leurs valeurs par défaut "
"normales. C'est la réciproque de la fonction :meth:`datetime.isocalendar`."

#: library/datetime.rst:1094
msgid ""
"Return a :class:`.datetime` corresponding to *date_string*, parsed according "
"to *format*."
msgstr ""
"Renvoie une classe :class:`.datetime` correspondant à *date_string*, "
"analysée selon *format*."

#: library/datetime.rst:1097
#, fuzzy
msgid ""
"If *format* does not contain microseconds or time zone information, this is "
"equivalent to::"
msgstr ""
"Si *format* ne contient pas de microsecondes ou d'informations sur le fuseau "
"horaire, cela équivaut à ::"

#: library/datetime.rst:2580
#, fuzzy
msgid "datetime(*(time.strptime(date_string, format)[0:6]))"
msgstr "``strptime(date_string, format)``"

#: library/datetime.rst:1101
msgid ""
":exc:`ValueError` is raised if the date_string and format can't be parsed "
"by :func:`time.strptime` or if it returns a value which isn't a time tuple.  "
"See also :ref:`strftime-strptime-behavior` and :meth:`datetime."
"fromisoformat`."
msgstr ""
"Une :exc:`ValueError` est levée si *date_string* et *format* ne peuvent être "
"analysés par :func:`time.strptime` ou si elle renvoie une valeur qui n'est "
"pas un *n*-uplet de temps.  Voir :ref:`strftime-strptime-behavior` et :meth:"
"`datetime.fromisoformat`."

#: library/datetime.rst:1108
msgid ""
"If *format* specifies a day of month without a year a :exc:"
"`DeprecationWarning` is now emitted.  This is to avoid a quadrennial leap "
"year bug in code seeking to parse only a month and day as the default year "
"used in absence of one in the format is not a leap year. Such *format* "
"values may raise an error as of Python 3.15.  The workaround is to always "
"include a year in your *format*.  If parsing *date_string* values that do "
"not have a year, explicitly add a year that is a leap year before parsing:"
msgstr ""

#: library/datetime.rst:1117
msgid ""
">>> from datetime import datetime\n"
">>> date_string = \"02/29\"\n"
">>> when = datetime.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # "
"Avoids leap year bug.\n"
">>> when.strftime(\"%B %d\")  \n"
"'February 29'"
msgstr ""

#: library/datetime.rst:1130
msgid ""
"The earliest representable :class:`.datetime`, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."
msgstr ""
"Le plus ancien :class:`.datetime` représentable, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."

#: library/datetime.rst:1136
msgid ""
"The latest representable :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, 23, "
"59, 59, 999999, tzinfo=None)``."
msgstr ""
"Le dernier :class:`.datetime` représentable, ``datetime(MAXYEAR, 12, 31, 23, "
"59, 59, 999999, tzinfo=None)``."

#: library/datetime.rst:1142
msgid ""
"The smallest possible difference between non-equal :class:`.datetime` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"La plus petite différence possible entre deux objets :class:`.datetime` non-"
"égaux, ``timedelta(microseconds=1)``."

#: library/datetime.rst:1788
msgid "In ``range(24)``."
msgstr "Dans ``range(24)``."

#: library/datetime.rst:1175 library/datetime.rst:1798
msgid "In ``range(60)``."
msgstr "Dans ``range(60)``."

#: library/datetime.rst:1803
msgid "In ``range(1000000)``."
msgstr "Dans ``range(1000000)``."

#: library/datetime.rst:1185
msgid ""
"The object passed as the *tzinfo* argument to the :class:`.datetime` "
"constructor, or ``None`` if none was passed."
msgstr ""
"L'objet passé en tant que paramètre *tzinfo* du constructeur de la classe :"
"class:`.datetime` ou ``None`` si aucun n'a été donné."

#: library/datetime.rst:1814
#, fuzzy
msgid ""
"In ``[0, 1]``. Used to disambiguate wall times during a repeated interval. "
"(A repeated interval occurs when clocks are rolled back at the end of "
"daylight saving time or when the UTC offset for the current zone is "
"decreased for political reasons.) The values 0 and 1 represent, "
"respectively, the earlier and later of the two moments with the same wall "
"time representation."
msgstr ""
"Dans ``[0, 1]``. Utilisé pour désambiguïser les heures dans un intervalle "
"répété. (Un intervalle répété apparaît quand l'horloge est retardée à la fin "
"de l'heure d'été ou quand le décalage horaire UTC du fuseau courant est "
"décrémenté pour des raisons politiques.) La valeur 0 (1) représente le plus "
"ancien (récent) des deux moments représentés par la même heure."

#: library/datetime.rst:1204
msgid "``datetime2 = datetime1 + timedelta``"
msgstr "``datetime2 = datetime1 + timedelta``"

#: library/datetime.rst:2427 library/datetime.rst:2444
#: library/datetime.rst:2509 library/datetime.rst:2518
msgid "\\(1)"
msgstr "\\(1)"

#: library/datetime.rst:1206
msgid "``datetime2 = datetime1 - timedelta``"
msgstr "``datetime2 = datetime1 - timedelta``"

#: library/datetime.rst:2460
msgid "\\(2)"
msgstr "\\(2)"

#: library/datetime.rst:1208
msgid "``timedelta = datetime1 - datetime2``"
msgstr "``timedelta = datetime1 - datetime2``"

#: library/datetime.rst:0
#, fuzzy
msgid "``datetime1 == datetime2``"
msgstr "``datetime1 < datetime2``"

#: library/datetime.rst:0
#, fuzzy
msgid "``datetime1 != datetime2``"
msgstr "``datetime1 < datetime2``"

#: library/datetime.rst:0
msgid "``datetime1 < datetime2``"
msgstr "``datetime1 < datetime2``"

#: library/datetime.rst:0
#, fuzzy
msgid "``datetime1 > datetime2``"
msgstr "``datetime1 < datetime2``"

#: library/datetime.rst:0
#, fuzzy
msgid "``datetime1 <= datetime2``"
msgstr "``datetime1 < datetime2``"

#: library/datetime.rst:0
#, fuzzy
msgid "``datetime1 >= datetime2``"
msgstr "``datetime1 < datetime2``"

#: library/datetime.rst:1220
#, fuzzy
msgid ""
"``datetime2`` is a duration of ``timedelta`` removed from ``datetime1``, "
"moving forward in time if ``timedelta.days > 0``, or backward if ``timedelta."
"days < 0``. The result has the same :attr:`~.datetime.tzinfo` attribute as "
"the input datetime, and ``datetime2 - datetime1 == timedelta`` after. :exc:"
"`OverflowError` is raised if ``datetime2.year`` would be smaller than :const:"
"`MINYEAR` or larger than :const:`MAXYEAR`. Note that no time zone "
"adjustments are done even if the input is an aware object."
msgstr ""
"*datetime2* est décalé d'une durée *timedelta* par rapport à *datetime1*, en "
"avant dans le temps si ``timedelta.days > 0``, ou en arrière si ``timedelta."
"days < 0``.  Le résultat a le même attribut :attr:`~.datetime.tzinfo` que le "
"*datetime* d'entrée, et *datetime2 - datetime1 == timedelta* après "
"l'opération. Une :exc:`OverflowError` est levée si *datetime2.year* devait "
"être inférieure à :const:`MINYEAR` ou supérieure à :const:`MAXYEAR`. Notez "
"qu'aucun ajustement de fuseau horaire n'est réalisé même si l'entrée est "
"avisée."

#: library/datetime.rst:1229
#, fuzzy
msgid ""
"Computes the ``datetime2`` such that ``datetime2 + timedelta == datetime1``. "
"As for addition, the result has the same :attr:`~.datetime.tzinfo` attribute "
"as the input datetime, and no time zone adjustments are done even if the "
"input is aware."
msgstr ""
"Calcule *datetime2* tel que ``datetime2 + timedelta == datetime1``. Comme "
"pour l'addition, le résultat a le même attribut :attr:`~.datetime.tzinfo` "
"que le *datetime* d'entrée, et aucun ajustement de fuseau horaire n'est "
"réalisé même si l'entrée est avisée."

#: library/datetime.rst:1234
msgid ""
"Subtraction of a :class:`.datetime` from a :class:`.datetime` is defined "
"only if both operands are naive, or if both are aware. If one is aware and "
"the other is naive, :exc:`TypeError` is raised."
msgstr ""
"La soustraction d'un :class:`.datetime` à un autre :class:`.datetime` n'est "
"définie que si les deux opérandes sont naïfs, ou s'ils sont les deux "
"avisés.  Si l'un est avisé et que l'autre est naïf, une :exc:`TypeError` est "
"levée."

#: library/datetime.rst:1238
#, fuzzy
msgid ""
"If both are naive, or both are aware and have the same :attr:`~.datetime."
"tzinfo` attribute, the :attr:`~.datetime.tzinfo` attributes are ignored, and "
"the result is a :class:`timedelta` object ``t`` such that ``datetime2 + t == "
"datetime1``. No time zone adjustments are done in this case."
msgstr ""
"Si les deux sont naïfs, ou que les deux sont avisés et ont le même attribut :"
"attr:`~.datetime.tzinfo`, les attributs :attr:`~.datetime.tzinfo` sont "
"ignorés, et le résultat est un objet :class:`timedelta` *t* tel que "
"``datetime2 + t == datetime1``.  Aucun ajustement de fuseau horaire n'a lieu "
"dans ce cas."

#: library/datetime.rst:1243
#, fuzzy
msgid ""
"If both are aware and have different :attr:`~.datetime.tzinfo` attributes, "
"``a-b`` acts as if ``a`` and ``b`` were first converted to naive UTC "
"datetimes. The result is ``(a.replace(tzinfo=None) - a.utcoffset()) - (b."
"replace(tzinfo=None) - b.utcoffset())`` except that the implementation never "
"overflows."
msgstr ""
"Si les deux sont avisés mais ont des attributs :attr:`~.datetime.tzinfo` "
"différents, ``a-b`` agit comme si *a* et *b* étaient premièrement convertis "
"vers des *datetimes* UTC naïfs.  Le résultat est ``(a.replace(tzinfo=None) - "
"a.utcoffset()) - (b.replace(tzinfo=None) - b.utcoffset())`` à l'exception "
"que l'implémentation ne produit jamais de débordement."

#: library/datetime.rst:1249
msgid ""
":class:`.datetime` objects are equal if they represent the same date and "
"time, taking into account the time zone."
msgstr ""

#: library/datetime.rst:1252
#, fuzzy
msgid "Naive and aware :class:`!datetime` objects are never equal."
msgstr ""
"Pour obtenir un objet :class:`.datetime` avisé, appelez :meth:"
"`fromtimestamp` ::"

#: library/datetime.rst:1254
#, fuzzy
msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` attribute, "
"the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are ignored and "
"the base datetimes are compared. If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparison acts as "
"comparands were first converted to UTC datetimes except that the "
"implementation never overflows. :class:`!datetime` instances in a repeated "
"interval are never equal to :class:`!datetime` instances in other time zone."
msgstr ""
"Si les deux opérandes sont avisés, et ont le même attribut :attr:`~.datetime."
"tzinfo`, l'attribut commun :attr:`~.datetime.tzinfo` est ignoré et les "
"*datetimes* de base sont comparés.  Si les deux opérandes sont avisés et ont "
"des attributs :attr:`~.datetime.tzinfo` différents, les opérandes sont "
"premièrement ajustés en soustrayant leurs décalages UTC (obtenus depuis "
"``self.utcoffset()``)."

#: library/datetime.rst:1264
#, fuzzy
msgid ""
"*datetime1* is considered less than *datetime2* when *datetime1* precedes "
"*datetime2* in time, taking into account the time zone."
msgstr ""
"*datetime1* est considéré inférieur à *datetime2* quand il le précède dans "
"le temps."

#: library/datetime.rst:1267
#, fuzzy
msgid ""
"Order comparison between naive and aware :class:`.datetime` objects raises :"
"exc:`TypeError`."
msgstr ""
"Les comparaisons d'égalité entre des instances :class:`.datetime` naïves et "
"avisées ne lèvent pas d'exception :exc:`TypeError`."

#: library/datetime.rst:1270
#, fuzzy
msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` attribute, "
"the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are ignored and "
"the base datetimes are compared. If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparison acts as "
"comparands were first converted to UTC datetimes except that the "
"implementation never overflows."
msgstr ""
"Si les deux opérandes sont avisés, et ont le même attribut :attr:`~.datetime."
"tzinfo`, l'attribut commun :attr:`~.datetime.tzinfo` est ignoré et les "
"*datetimes* de base sont comparés.  Si les deux opérandes sont avisés et ont "
"des attributs :attr:`~.datetime.tzinfo` différents, les opérandes sont "
"premièrement ajustés en soustrayant leurs décalages UTC (obtenus depuis "
"``self.utcoffset()``)."

#: library/datetime.rst:1277
msgid ""
"Equality comparisons between aware and naive :class:`.datetime` instances "
"don't raise :exc:`TypeError`."
msgstr ""
"Les comparaisons d'égalité entre des instances :class:`.datetime` naïves et "
"avisées ne lèvent pas d'exception :exc:`TypeError`."

#: library/datetime.rst:1293
msgid "Return :class:`date` object with same year, month and day."
msgstr "Renvoie un objet :class:`date` avec les mêmes année, mois et jour."

#: library/datetime.rst:1298
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond and "
"fold. :attr:`.tzinfo` is ``None``. See also method :meth:`timetz`."
msgstr ""
"Renvoie un objet :class:`.time` avec les mêmes heures, minutes, secondes, "
"microsecondes et *fold*. :attr:`.tzinfo` est ``None``.  Voir aussi la "
"méthode :meth:`timetz`."

#: library/datetime.rst:1310
msgid "The fold value is copied to the returned :class:`.time` object."
msgstr "La valeur *fold* est copiée vers l'objet :class:`.time` renvoyé."

#: library/datetime.rst:1307
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond, "
"fold, and tzinfo attributes. See also method :meth:`time`."
msgstr ""
"Renvoie un objet :class:`.time` avec les mêmes attributs heure, minute, "
"seconde, microseconde, *fold* et *tzinfo*.  Voir aussi la méthode :meth:"
"`time`."

#: library/datetime.rst:1318
msgid ""
"Return a datetime with the same attributes, except for those attributes "
"given new values by whichever keyword arguments are specified. Note that "
"``tzinfo=None`` can be specified to create a naive datetime from an aware "
"datetime with no conversion of date and time data."
msgstr ""
"Renvoie un *datetime* avec les mêmes attributs, exceptés ceux dont de "
"nouvelles valeurs sont données par les arguments nommés correspondant.  "
"Notez que ``tzinfo=None`` peut être spécifié pour créer un *datetime* naïf "
"depuis un *datetime* avisé sans conversion de la date ou de l'heure."

#: library/datetime.rst:1323
msgid ""
":class:`.datetime` objects are also supported by generic function :func:"
"`copy.replace`."
msgstr ""

#: library/datetime.rst:1332
msgid ""
"Return a :class:`.datetime` object with new :attr:`.tzinfo` attribute *tz*, "
"adjusting the date and time data so the result is the same UTC time as "
"*self*, but in *tz*'s local time."
msgstr ""
"Renvoie un objet :class:`.datetime` avec un nouvel attribut :attr:`.tzinfo` "
"valant *tz*, ajustant la date et l'heure pour que le résultat soit le même "
"temps UTC que *self*, mais dans le temps local au fuseau *tz*."

#: library/datetime.rst:1336
#, fuzzy
msgid ""
"If provided, *tz* must be an instance of a :class:`tzinfo` subclass, and "
"its :meth:`utcoffset` and :meth:`dst` methods must not return ``None``. If "
"*self* is naive, it is presumed to represent time in the system time zone."
msgstr ""
"S'il est fourni, *tz* doit être une instance d'une sous-classe de :class:"
"`tzinfo`, et ses méthodes :meth:`utcoffset` et :meth:`dst` ne doivent pas "
"renvoyer ``None``.  Si *self* est naïf, Python considère que le temps est "
"exprimé dans le fuseau horaire du système."

#: library/datetime.rst:1340
#, fuzzy
msgid ""
"If called without arguments (or with ``tz=None``) the system local time zone "
"is assumed for the target time zone. The ``.tzinfo`` attribute of the "
"converted datetime instance will be set to an instance of :class:`timezone` "
"with the zone name and offset obtained from the OS."
msgstr ""
"Si appelé sans arguments (ou si ``tz=None``) le fuseau horaire local du "
"système est utilisé comme fuseau horaire cible.  L'attribut ``.tzinfo`` de "
"l'instance *datetime* convertie aura pour valeur une instance de :class:"
"`timezone` avec le nom de fuseau et le décalage obtenus depuis l'OS."

#: library/datetime.rst:1345
#, fuzzy
msgid ""
"If ``self.tzinfo`` is *tz*, ``self.astimezone(tz)`` is equal to *self*:  no "
"adjustment of date or time data is performed. Else the result is local time "
"in the time zone *tz*, representing the same UTC time as *self*:  after "
"``astz = dt.astimezone(tz)``, ``astz - astz.utcoffset()`` will have the same "
"date and time data as ``dt - dt.utcoffset()``."
msgstr ""
"Si ``self.tzinfo`` est *tz*, ``self.astimezone(tz)`` est égal à *self* : "
"aucun ajustement de date ou d'heure n'est réalisé. Sinon le résultat est le "
"temps local dans le fuseau *tz* représentant le même temps UTC que *self* : "
"après ``astz = dt.astimezone(tz)``, ``astz - astz.utcoffset()`` aura les "
"mêmes données de date et d'heure que ``dt - dt.utcoffset()``."

#: library/datetime.rst:1351
#, fuzzy
msgid ""
"If you merely want to attach a :class:`timezone` object *tz* to a datetime "
"*dt* without adjustment of date and time data, use ``dt."
"replace(tzinfo=tz)``. If you merely want to remove the :class:`!timezone` "
"object from an aware datetime *dt* without conversion of date and time data, "
"use ``dt.replace(tzinfo=None)``."
msgstr ""
"Si vous voulez seulement associer un fuseau horaire *tz* à un *datetime* "
"*dt* sans ajustement des données de date et d'heure, utilisez ``dt."
"replace(tzinfo=tz)``.  Si vous voulez seulement supprimer le fuseau horaire "
"d'un *datetime* *dt* avisé sans conversion des données de date et d'heure, "
"utilisez ``dt.replace(tzinfo=None)``."

#: library/datetime.rst:1356
msgid ""
"Note that the default :meth:`tzinfo.fromutc` method can be overridden in a :"
"class:`tzinfo` subclass to affect the result returned by :meth:`astimezone`. "
"Ignoring error cases, :meth:`astimezone` acts like::"
msgstr ""
"Notez que la méthode par défaut :meth:`tzinfo.fromutc` peut être redéfinie "
"dans une sous-classe :class:`tzinfo` pour affecter le résultat renvoyé par :"
"meth:`astimezone`. En ignorant les cas d'erreurs, :meth:`astimezone` se "
"comporte comme ::"

#: library/datetime.rst:1360
msgid ""
"def astimezone(self, tz):\n"
"    if self.tzinfo is tz:\n"
"        return self\n"
"    # Convert self to UTC, and attach the new timezone object.\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # Convert from UTC to tz's local time.\n"
"    return tz.fromutc(utc)"
msgstr ""

#: library/datetime.rst:1368
msgid "*tz* now can be omitted."
msgstr "*tz* peut maintenant être omis."

#: library/datetime.rst:1371
msgid ""
"The :meth:`astimezone` method can now be called on naive instances that are "
"presumed to represent system local time."
msgstr ""
"La méthode :meth:`astimezone` peut maintenant être appelée sur des instances "
"naïves qui sont supposées représenter un temps local au système."

#: library/datetime.rst:1378
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"utcoffset(self)``, and raises an exception if the latter doesn't return "
"``None`` or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Si :attr:`.tzinfo` est ``None``, renvoie ``None``, sinon renvoie ``self."
"tzinfo.utcoffset(self)``, et lève une exception si l'expression précédente "
"ne renvoie pas ``None`` ou un objet :class:`timedelta` d'une magnitude "
"inférieure à un jour."

#: library/datetime.rst:1977 library/datetime.rst:2329
#: library/datetime.rst:2653
msgid "The UTC offset is not restricted to a whole number of minutes."
msgstr "Le décalage UTC peut aussi être autre chose qu'un ensemble de minutes."

#: library/datetime.rst:1388
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"dst(self)``, and raises an exception if the latter doesn't return ``None`` "
"or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Si :attr:`.tzinfo` est ``None``, renvoie ``None``, sinon renvoie ``self."
"tzinfo.dst(self)``, et lève une exception si l'expression précédente ne "
"renvoie pas ``None`` ou un objet :class:`timedelta` d'une magnitude "
"inférieure à un jour."

#: library/datetime.rst:1987 library/datetime.rst:2138
msgid "The DST offset is not restricted to a whole number of minutes."
msgstr "Le décalage DST n'est pas restreint à des minutes entières."

#: library/datetime.rst:1398
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"tzname(self)``, raises an exception if the latter doesn't return ``None`` or "
"a string object,"
msgstr ""
"Si :attr:`.tzinfo` est ``None``, renvoie ``None``, sinon renvoie ``self."
"tzinfo.tzname(self)``, lève une exception si l'expression précédente ne "
"renvoie pas ``None`` ou une chaîne de caractères,"

#: library/datetime.rst:1409
msgid ""
"time.struct_time((d.year, d.month, d.day,\n"
"                  d.hour, d.minute, d.second,\n"
"                  d.weekday(), yday, dst))"
msgstr ""

#: library/datetime.rst:1413
#, fuzzy
msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st. The :"
"attr:`~time.struct_time.tm_isdst` flag of the result is set according to "
"the :meth:`dst` method: :attr:`.tzinfo` is ``None`` or :meth:`dst` returns "
"``None``, :attr:`!tm_isdst` is set to ``-1``; else if :meth:`dst` returns a "
"non-zero value, :attr:`!tm_isdst` is set to 1; else :attr:`!tm_isdst` is set "
"to 0."
msgstr ""
"où ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` est le "
"numéro de jour dans l'année courante commençant avec ``1`` pour le 1\\ :sup:"
"`er` janvier. L'option :attr:`tm_isdist` du résultat est attribuée selon la "
"méthode :meth:`dst` : si :attr:`.tzinfo` est ``None`` ou  :meth:`dst` "
"renvoie ``None``, :attr:`tm_isdst` est mise à ``-1`` ; sinon, si :meth:`dst` "
"renvoie une valeur non nulle, :attr:`tm_isdst` est mise à ``1`` ; sinon :"
"attr:`tm_isdst` est mise à ``0``."

#: library/datetime.rst:1424
#, fuzzy
msgid ""
"If :class:`.datetime` instance ``d`` is naive, this is the same as ``d."
"timetuple()`` except that :attr:`~.time.struct_time.tm_isdst` is forced to 0 "
"regardless of what ``d.dst()`` returns. DST is never in effect for a UTC "
"time."
msgstr ""
"Si l'instance de :class:`.datetime` *d* est naïve, cela est équivalent à ``d."
"timetuple()``, excepté que :attr:`tm_isdst` est forcé à 0 sans tenir compte "
"de ce que renvoie ``d.dst()``.  L'heure d'été n'est jamais effective pour un "
"temps UTC."

#: library/datetime.rst:1428
#, fuzzy
msgid ""
"If ``d`` is aware, ``d`` is normalized to UTC time, by subtracting ``d."
"utcoffset()``, and a :class:`time.struct_time` for the normalized time is "
"returned. :attr:`!tm_isdst` is forced to 0. Note that an :exc:"
"`OverflowError` may be raised if ``d.year`` was ``MINYEAR`` or ``MAXYEAR`` "
"and UTC adjustment spills over a year boundary."
msgstr ""
"Si *d* est avisé, il est normalisé vers un temps UTC, en lui soustrayant ``d."
"utcoffset()``, et un :class:`time.struct_time` est renvoyé pour le temps "
"normalisé.  :attr:`tm_isdst` est forcé à 0. Notez qu'une :exc:"
"`OverflowError` peut être levée si *d.year* vaut ``MINYEAR`` ou ``MAXYEAR`` "
"et que l'ajustement UTC fait déborder la limite de l'année."

#: library/datetime.rst:1437
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC; as a result, using :meth:`datetime.utctimetuple` may give misleading "
"results. If you have a naive ``datetime`` representing UTC, use ``datetime."
"replace(tzinfo=timezone.utc)`` to make it aware, at which point you can use :"
"meth:`.datetime.timetuple`."
msgstr ""
"Comme les objets ``datetime`` naïfs sont traités par de nombreuses méthodes "
"``datetime`` comme des heures locales, il est préférable d'utiliser les "
"``datetime`` avisés pour représenter les heures en UTC ; par conséquent, "
"l'utilisation de :meth:`datetime.utcfromtimetuple` peut donner des résultats "
"trompeurs. Si vous disposez d'une ``datetime`` naïve représentant l'heure "
"UTC, utilisez ``datetime.replace(tzinfo=timezone.utc)`` pour la rendre "
"avisée, puis vous pouvez utiliser :meth:`.datetime.timetuple`."

#: library/datetime.rst:1446
msgid ""
"Return the proleptic Gregorian ordinal of the date. The same as ``self."
"date().toordinal()``."
msgstr ""
"Renvoie l'ordinal du calendrier grégorien proleptique de cette date.  "
"Identique à ``self.date().toordinal()``."

#: library/datetime.rst:1451
msgid ""
"Return POSIX timestamp corresponding to the :class:`.datetime` instance. The "
"return value is a :class:`float` similar to that returned by :func:`time."
"time`."
msgstr ""
"Renvoie l'horodatage *POSIX* correspondant à l'instance :class:`.datetime`.  "
"La valeur renvoyée est un :class:`float` similaire à ceux renvoyés par :func:"
"`time.time`."

#: library/datetime.rst:1455
#, fuzzy
msgid ""
"Naive :class:`.datetime` instances are assumed to represent local time and "
"this method relies on the platform C :c:func:`mktime` function to perform "
"the conversion. Since :class:`.datetime` supports wider range of values "
"than :c:func:`mktime` on many platforms, this method may raise :exc:"
"`OverflowError` or :exc:`OSError` for times far in the past or far in the "
"future."
msgstr ""
"Les instances naïves de :class:`.datetime` sont supposées représenter un "
"temps local et cette méthode se base sur la fonction C :c:func:`mktime` de "
"la plateforme pour opérer la conversion.  Comme :class:`.datetime` gère un "
"intervalle de valeurs plus large que :c:func:`mktime` sur beaucoup de "
"plateformes, cette méthode peut lever une :exc:`OverflowError` pour les "
"temps trop éloignés dans le passé ou le futur."

#: library/datetime.rst:1462
msgid ""
"For aware :class:`.datetime` instances, the return value is computed as::"
msgstr ""
"Pour les instances :class:`.datetime` avisées, la valeur renvoyée est "
"calculée comme suit ::"

#: library/datetime.rst:1465
msgid "(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()"
msgstr ""

#: library/datetime.rst:1469
msgid ""
"The :meth:`timestamp` method uses the :attr:`.fold` attribute to "
"disambiguate the times during a repeated interval."
msgstr ""
"La méthode :meth:`timestamp` utilise l'attribut :attr:`.fold` pour "
"désambiguïser le temps dans un intervalle répété."

#: library/datetime.rst:1475
#, fuzzy
msgid ""
"There is no method to obtain the POSIX timestamp directly from a naive :"
"class:`.datetime` instance representing UTC time. If your application uses "
"this convention and your system time zone is not set to UTC, you can obtain "
"the POSIX timestamp by supplying ``tzinfo=timezone.utc``::"
msgstr ""
"Il n'y a pas de méthode pour obtenir l'horodatage (*timestamp* en anglais) "
"*POSIX* directement depuis une instance :class:`.datetime` naïve "
"représentant un temps UTC.  Si votre application utilise cette convention et "
"que le fuseau horaire de votre système n'est pas réglé sur UTC, vous pouvez "
"obtenir l'horodatage *POSIX* en fournissant ``tzinfo=timezone.utc`` ::"

#: library/datetime.rst:1481
msgid "timestamp = dt.replace(tzinfo=timezone.utc).timestamp()"
msgstr ""

#: library/datetime.rst:1483
msgid "or by calculating the timestamp directly::"
msgstr "ou en calculant l'horodatage (*timestamp* en anglais) directement ::"

#: library/datetime.rst:1485
msgid "timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)"
msgstr ""

#: library/datetime.rst:1489
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6. "
"The same as ``self.date().weekday()``. See also :meth:`isoweekday`."
msgstr ""
"Renvoie le jour de la semaine sous forme de nombre, où lundi vaut 0 et "
"dimanche vaut 6. Identique à ``self.date().weekday()``. Voir aussi :meth:"
"`isoweekday`."

#: library/datetime.rst:1495
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7. "
"The same as ``self.date().isoweekday()``. See also :meth:`weekday`, :meth:"
"`isocalendar`."
msgstr ""
"Renvoie le jour de la semaine sous forme de nombre, où lundi vaut 1 et "
"dimanche vaut 7. Identique à ``self.date().isoweekday()``. Voir aussi :meth:"
"`weekday`, :meth:`isocalendar`."

#: library/datetime.rst:1502
msgid ""
"Return a :term:`named tuple` with three components: ``year``, ``week`` and "
"``weekday``. The same as ``self.date().isocalendar()``."
msgstr ""
"Renvoie un :term:`n-uplet nommé<named tuple>` de 3 éléments : ``year``, "
"``week`` et ``weekday``. Identique à ``self.date().isocalendar()``."

#: library/datetime.rst:1508
msgid "Return a string representing the date and time in ISO 8601 format:"
msgstr ""
"Renvoie une chaîne représentant la date et l'heure au format ISO 8601 :"

#: library/datetime.rst:1510
msgid "``YYYY-MM-DDTHH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``YYYY-MM-DDTHH:MM:SS.ffffff``, si :attr:`microsecond` ne vaut pas 0"

#: library/datetime.rst:1511
msgid "``YYYY-MM-DDTHH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``YYYY-MM-DDTHH:MM:SS``, si :attr:`microsecond` vaut 0"

#: library/datetime.rst:1513
msgid ""
"If :meth:`utcoffset` does not return ``None``, a string is appended, giving "
"the UTC offset:"
msgstr ""
"Si :meth:`utcoffset` ne renvoie pas ``None``, une chaîne est ajoutée, "
"donnant le décalage UTC :"

#: library/datetime.rst:1516
msgid ""
"``YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` "
"is not 0"
msgstr ""
"``YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, si :attr:`microsecond` "
"ne vaut pas 0"

#: library/datetime.rst:1518
msgid ""
"``YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``,  if :attr:`microsecond` is 0"
msgstr ""
"``YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``,  si :attr:`microsecond` vaut 0"

#: library/datetime.rst:1522
msgid ""
">>> from datetime import datetime, timezone\n"
">>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n"
"'2019-05-18T15:17:08.132263'\n"
">>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n"
"'2019-05-18T15:17:00+00:00'"
msgstr ""

#: library/datetime.rst:1528
msgid ""
"The optional argument *sep* (default ``'T'``) is a one-character separator, "
"placed between the date and time portions of the result. For example::"
msgstr ""
"L'argument optionnel *sep* (par défaut ``'T'``) est un séparateur d'un "
"caractère, placé entre les portions du résultat correspondant à la date et à "
"l'heure. Par exemple ::"

#: library/datetime.rst:1531
msgid ""
">>> from datetime import tzinfo, timedelta, datetime\n"
">>> class TZ(tzinfo):\n"
"...     \"\"\"A time zone with an arbitrary, constant -06:39 offset.\"\"\"\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=-6, minutes=-39)\n"
"...\n"
">>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')\n"
"'2002-12-25 00:00:00-06:39'\n"
">>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()\n"
"'2009-11-27T00:00:00.000100-06:39'"
msgstr ""

#: library/datetime.rst:1917
msgid ""
"The optional argument *timespec* specifies the number of additional "
"components of the time to include (the default is ``'auto'``). It can be one "
"of the following:"
msgstr ""
"L'argument optionnel *timespec* spécifie le nombre de composants "
"additionnels de temps à inclure (par défaut ``'auto'``). Il peut valoir "
"l'une des valeurs suivantes :"

#: library/datetime.rst:1921
msgid ""
"``'auto'``: Same as ``'seconds'`` if :attr:`microsecond` is 0, same as "
"``'microseconds'`` otherwise."
msgstr ""
"``'auto'`` : Identique à ``'seconds'`` si :attr:`microsecond` vaut 0, à "
"``'microseconds'`` sinon."

#: library/datetime.rst:1923
msgid "``'hours'``: Include the :attr:`hour` in the two-digit ``HH`` format."
msgstr "``'hours'`` : Inclut :attr:`hour` au format à deux chiffres ``HH``."

#: library/datetime.rst:1924
msgid ""
"``'minutes'``: Include :attr:`hour` and :attr:`minute` in ``HH:MM`` format."
msgstr ""
"``'minutes'`` : Inclut :attr:`hour` et :attr:`minute` au format ``HH:MM``."

#: library/datetime.rst:1925
msgid ""
"``'seconds'``: Include :attr:`hour`, :attr:`minute`, and :attr:`second` in "
"``HH:MM:SS`` format."
msgstr ""
"``'seconds'`` : Inclut :attr:`hour`, :attr:`minute` et :attr:`second` au "
"format ``HH:MM:SS``."

#: library/datetime.rst:1927
msgid ""
"``'milliseconds'``: Include full time, but truncate fractional second part "
"to milliseconds. ``HH:MM:SS.sss`` format."
msgstr ""
"``'milliseconds'`` : Inclut le temps complet, mais tronque la partie "
"fractionnaire des millisecondes, au format ``HH:MM:SS.sss``."

#: library/datetime.rst:1929
msgid "``'microseconds'``: Include full time in ``HH:MM:SS.ffffff`` format."
msgstr ""
"``'microseconds'`` : Inclut le temps complet, au format ``HH:MM:SS.ffffff``."

#: library/datetime.rst:1933
msgid "Excluded time components are truncated, not rounded."
msgstr "Les composants de temps exclus sont tronqués et non arrondis."

#: library/datetime.rst:1560
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument::"
msgstr ""
"Une :exc:`ValueError` est levée en cas d'argument *timespec* invalide ::"

#: library/datetime.rst:1563
msgid ""
">>> from datetime import datetime\n"
">>> datetime.now().isoformat(timespec='minutes')   \n"
"'2002-12-25T00:00'\n"
">>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'2015-01-01T12:30:59.000000'"
msgstr ""

#: library/datetime.rst:1948
#, fuzzy
msgid "Added the *timespec* parameter."
msgstr "Ajout de l'argument *timespec*."

#: library/datetime.rst:1576
#, fuzzy
msgid ""
"For a :class:`.datetime` instance ``d``, ``str(d)`` is equivalent to ``d."
"isoformat(' ')``."
msgstr ""
"Pour une instance *d* de :class:`.datetime`, ``str(d)`` est équivalent à ``d."
"isoformat(' ')``."

#: library/datetime.rst:1582
msgid "Return a string representing the date and time::"
msgstr "Renvoie une chaîne représentant la date et l'heure ::"

#: library/datetime.rst:1584
msgid ""
">>> from datetime import datetime\n"
">>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n"
"'Wed Dec  4 20:30:40 2002'"
msgstr ""

#: library/datetime.rst:1588
msgid ""
"The output string will *not* include time zone information, regardless of "
"whether the input is aware or naive."
msgstr ""
"La chaîne de caractères en sortie n'inclura *pas* d'informations sur le "
"fuseau horaire, que l'entrée soit avisée ou naïve."

#: library/datetime.rst:1595
msgid ""
"on platforms where the native C :c:func:`ctime` function (which :func:`time."
"ctime` invokes, but which :meth:`datetime.ctime` does not invoke) conforms "
"to the C standard."
msgstr ""
"sur les plateformes où la fonction C native :c:func:`ctime` (que :func:`time."
"ctime` invoque, mais pas :meth:`datetime.ctime`) est conforme au standard C."

#: library/datetime.rst:1602
msgid ""
"Return a string representing the date and time, controlled by an explicit "
"format string. See also :ref:`strftime-strptime-behavior` and :meth:"
"`datetime.isoformat`."
msgstr ""
"Renvoie une chaîne représentant la date et l'heure, contrôlée par une chaîne "
"de format explicite.  Voir :ref:`strftime-strptime-behavior` et :meth:"
"`datetime.isoformat`."

#: library/datetime.rst:1609
msgid ""
"Same as :meth:`.datetime.strftime`. This makes it possible to specify a "
"format string for a :class:`.datetime` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`. See also :ref:"
"`strftime-strptime-behavior` and :meth:`datetime.isoformat`."
msgstr ""
"Identique à :meth:`.datetime.strftime`.  Cela permet de spécifier une chaîne "
"de format pour un objet :class:`.datetime` dans une :ref:`chaîne de "
"formatage littérale <f-strings>` et en utilisant :meth:`str.format`.  Voir :"
"ref:`strftime-strptime-behavior` et :meth:`datetime.isoformat`."

#: library/datetime.rst:1616
msgid "Examples of Usage: :class:`.datetime`"
msgstr "Exemple d'utilisation de la classe :class:`.datetime` :"

#: library/datetime.rst:1618
#, fuzzy
msgid "Examples of working with :class:`.datetime` objects:"
msgstr "Exemples d'utilisation de l'objet :class:`.time` ::"

#: library/datetime.rst:1620
msgid ""
">>> from datetime import datetime, date, time, timezone\n"
"\n"
">>> # Using datetime.combine()\n"
">>> d = date(2005, 7, 14)\n"
">>> t = time(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
"\n"
">>> # Using datetime.now()\n"
">>> datetime.now()   \n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1\n"
">>> datetime.now(timezone.utc)   \n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone."
"utc)\n"
"\n"
">>> # Using datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
"\n"
">>> # Using datetime.timetuple() to get tuple of all attributes\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:   \n"
"...     print(it)\n"
"...\n"
"2006    # year\n"
"11      # month\n"
"21      # day\n"
"16      # hour\n"
"30      # minute\n"
"0       # second\n"
"1       # weekday (0 = Monday)\n"
"325     # number of days since 1st January\n"
"-1      # dst - method tzinfo.dst() returned None\n"
"\n"
">>> # Date in ISO format\n"
">>> ic = dt.isocalendar()\n"
">>> for it in ic:   \n"
"...     print(it)\n"
"...\n"
"2006    # ISO year\n"
"47      # ISO week\n"
"2       # ISO weekday\n"
"\n"
">>> # Formatting a datetime\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tuesday, 21. November 2006 04:30PM'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'."
"format(dt, \"day\", \"month\", \"time\")\n"
"'The day is 21, the month is November, the time is 04:30PM.'"
msgstr ""

#: library/datetime.rst:1671
msgid ""
"The example below defines a :class:`tzinfo` subclass capturing time zone "
"information for Kabul, Afghanistan, which used +4 UTC until 1945 and then "
"+4:30 UTC thereafter::"
msgstr ""
"L'exemple ci-dessous définit une sous-classe :class:`tzinfo` qui regroupe "
"des informations sur les fuseaux horaires pour Kaboul, en Afghanistan, qui a "
"utilisé +4 UTC jusqu'en 1945, puis +4:30 UTC par la suite ::"

#: library/datetime.rst:1675
msgid ""
"from datetime import timedelta, datetime, tzinfo, timezone\n"
"\n"
"class KabulTz(tzinfo):\n"
"    # Kabul used +4 until 1945, when they moved to +4:30\n"
"    UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if dt.year < 1945:\n"
"            return timedelta(hours=4)\n"
"        elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, "
"30):\n"
"            # An ambiguous (\"imaginary\") half-hour range representing\n"
"            # a 'fold' in time due to the shift from +4 to +4:30.\n"
"            # If dt falls in the imaginary range, use fold to decide how\n"
"            # to resolve. See PEP495.\n"
"            return timedelta(hours=4, minutes=(30 if dt.fold else 0))\n"
"        else:\n"
"            return timedelta(hours=4, minutes=30)\n"
"\n"
"    def fromutc(self, dt):\n"
"        # Follow same validations as in datetime.tzinfo\n"
"        if not isinstance(dt, datetime):\n"
"            raise TypeError(\"fromutc() requires a datetime argument\")\n"
"        if dt.tzinfo is not self:\n"
"            raise ValueError(\"dt.tzinfo is not self\")\n"
"\n"
"        # A custom implementation is required for fromutc as\n"
"        # the input to this function is a datetime with utc values\n"
"        # but with a tzinfo set to self.\n"
"        # See datetime.astimezone or fromtimestamp.\n"
"        if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:\n"
"            return dt + timedelta(hours=4, minutes=30)\n"
"        else:\n"
"            return dt + timedelta(hours=4)\n"
"\n"
"    def dst(self, dt):\n"
"        # Kabul does not observe daylight saving time.\n"
"        return timedelta(0)\n"
"\n"
"    def tzname(self, dt):\n"
"        if dt >= self.UTC_MOVE_DATE:\n"
"            return \"+04:30\"\n"
"        return \"+04\""
msgstr ""

#: library/datetime.rst:1718
msgid "Usage of ``KabulTz`` from above::"
msgstr "Utilisation de ``KabulTz`` cité plus haut ::"

#: library/datetime.rst:1720
msgid ""
">>> tz1 = KabulTz()\n"
"\n"
">>> # Datetime before the change\n"
">>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)\n"
">>> print(dt1.utcoffset())\n"
"4:00:00\n"
"\n"
">>> # Datetime after the change\n"
">>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)\n"
">>> print(dt2.utcoffset())\n"
"4:30:00\n"
"\n"
">>> # Convert datetime to another time zone\n"
">>> dt3 = dt2.astimezone(timezone.utc)\n"
">>> dt3\n"
"datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)\n"
">>> dt2\n"
"datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())\n"
">>> dt2 == dt3\n"
"True"
msgstr ""

#: library/datetime.rst:1744
msgid ":class:`.time` Objects"
msgstr "Objets :class:`.time`"

#: library/datetime.rst:1746
#, fuzzy
msgid ""
"A :class:`.time` object represents a (local) time of day, independent of any "
"particular day, and subject to adjustment via a :class:`tzinfo` object."
msgstr ""
"Un objet :class:`time` représente une heure (locale) du jour, indépendante "
"de tout jour particulier, et sujette à des ajustements par un objet :class:"
"`tzinfo`."

#: library/datetime.rst:1751
msgid ""
"All arguments are optional. *tzinfo* may be ``None``, or an instance of a :"
"class:`tzinfo` subclass. The remaining arguments must be integers in the "
"following ranges:"
msgstr ""
"Tous les arguments sont optionnels. *tzinfo* peut être ``None`` ou une "
"instance d'une sous-classe :class:`tzinfo`.  Les autres arguments doivent "
"être des nombres entiers, dans les intervalles suivants :"

#: library/datetime.rst:1761
#, fuzzy
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised. "
"All default to 0 except *tzinfo*, which defaults to ``None``."
msgstr ""
"Si un argument est fourni en dehors de ces bornes, une :exc:`ValueError` est "
"levée.  Ils valent tous ``0`` par défaut, à l'exception de *tzinfo* qui "
"vaut :const:`None`."

#: library/datetime.rst:1769
msgid "The earliest representable :class:`.time`, ``time(0, 0, 0, 0)``."
msgstr ""
"Le plus petit objet :class:`.time` représentable, ``time(0, 0, 0, 0)``."

#: library/datetime.rst:1774
msgid "The latest representable :class:`.time`, ``time(23, 59, 59, 999999)``."
msgstr ""
"Le plus grand objet :class:`.time` représentable, ``time(23, 59, 59, "
"999999)``."

#: library/datetime.rst:1779
msgid ""
"The smallest possible difference between non-equal :class:`.time` objects, "
"``timedelta(microseconds=1)``, although note that arithmetic on :class:`."
"time` objects is not supported."
msgstr ""
"La plus petite différence possible entre deux objets :class:`.time` non-"
"égaux, ``timedelta(microseconds=1)``, notez cependant que les objets :class:"
"`.time` n'implémentent pas d'opérations arithmétiques."

#: library/datetime.rst:1808
msgid ""
"The object passed as the tzinfo argument to the :class:`.time` constructor, "
"or ``None`` if none was passed."
msgstr ""
"L'objet passé comme argument *tzinfo* au constructeur de :class:`.time`, ou "
"``None`` si aucune valeur n'a été passée."

#: library/datetime.rst:1822
msgid ""
":class:`.time` objects support equality and order comparisons, where ``a`` "
"is considered less than ``b`` when ``a`` precedes ``b`` in time."
msgstr ""

#: library/datetime.rst:1825
msgid ""
"Naive and aware :class:`!time` objects are never equal. Order comparison "
"between naive and aware :class:`!time` objects raises :exc:`TypeError`."
msgstr ""

#: library/datetime.rst:1829
#, fuzzy
msgid ""
"If both comparands are aware, and have the same :attr:`~.time.tzinfo` "
"attribute, the :attr:`!tzinfo` and :attr:`!fold` attributes are ignored and "
"the base times are compared. If both comparands are aware and have "
"different :attr:`!tzinfo` attributes, the comparands are first adjusted by "
"subtracting their UTC offsets (obtained from ``self.utcoffset()``)."
msgstr ""
"Si les deux opérandes sont avisés, et ont le même attribut :attr:`~.datetime."
"tzinfo`, l'attribut commun :attr:`~.datetime.tzinfo` est ignoré et les "
"*datetimes* de base sont comparés.  Si les deux opérandes sont avisés et ont "
"des attributs :attr:`~.datetime.tzinfo` différents, les opérandes sont "
"premièrement ajustés en soustrayant leurs décalages UTC (obtenus depuis "
"``self.utcoffset()``)."

#: library/datetime.rst:1835
#, fuzzy
msgid ""
"Equality comparisons between aware and naive :class:`.time` instances don't "
"raise :exc:`TypeError`."
msgstr ""
"Les comparaisons d'égalité entre des instances :class:`.datetime` naïves et "
"avisées ne lèvent pas d'exception :exc:`TypeError`."

#: library/datetime.rst:1839
msgid ""
"In Boolean contexts, a :class:`.time` object is always considered to be true."
msgstr ""
"Dans un contexte booléen, un objet :class:`.time` est toujours considéré "
"comme vrai."

#: library/datetime.rst:1841
msgid ""
"Before Python 3.5, a :class:`.time` object was considered to be false if it "
"represented midnight in UTC. This behavior was considered obscure and error-"
"prone and has been removed in Python 3.5. See :issue:`13936` for full "
"details."
msgstr ""
"Avant Python 3.5, un objet :class:`.time` était considéré comme faux s'il "
"représentait minuit en UTC.  Ce comportement était considéré comme obscur et "
"propice aux erreurs, il a été supprimé en Python 3.5.  Voir :issue:`13936` "
"pour les détails complets."

#: library/datetime.rst:1848
msgid "Other constructor:"
msgstr "Autre constructeur :"

#: library/datetime.rst:1852
msgid ""
"Return a :class:`.time` corresponding to a *time_string* in any valid ISO "
"8601 format, with the following exceptions:"
msgstr ""
"Renvoie une :class:`.time` correspondant à *time_string* dans un format ISO "
"8601 valide, avec les exceptions suivantes :"

#: library/datetime.rst:1856
msgid ""
"The leading ``T``, normally required in cases where there may be ambiguity "
"between a date and a time, is not required."
msgstr ""
"Le ``T`` initial, normalement requis dans les cas où il peut y avoir une "
"ambiguïté entre une date et une heure, n'est pas nécessaire."

#: library/datetime.rst:1858
msgid ""
"Fractional seconds may have any number of digits (anything beyond 6 will be "
"truncated)."
msgstr ""
"Les fractions de secondes peuvent avoir un nombre quelconque de décimales "
"(tout ce qui dépasse 6 décimales sera tronqué)."

#: library/datetime.rst:1862
#, fuzzy
msgid "Examples:"
msgstr "Exemples ::"

#: library/datetime.rst:1864
msgid ""
">>> from datetime import time\n"
">>> time.fromisoformat('04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T042301')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('04:23:01.000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01,000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01+04:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime."
"timedelta(seconds=14400)))\n"
">>> time.fromisoformat('04:23:01Z')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)\n"
">>> time.fromisoformat('04:23:01+00:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)"
msgstr ""

#: library/datetime.rst:1886
#, fuzzy
msgid ""
"Previously, this method only supported formats that could be emitted by :"
"meth:`time.isoformat`."
msgstr ""
"Auparavant, cette méthode ne prenait en charge que les formats émis par :"
"meth:`time.isoformat()`."

#: library/datetime.rst:1896
msgid ""
"Return a :class:`.time` with the same value, except for those attributes "
"given new values by whichever keyword arguments are specified. Note that "
"``tzinfo=None`` can be specified to create a naive :class:`.time` from an "
"aware :class:`.time`, without conversion of the time data."
msgstr ""
"Renvoie un objet :class:`.time` avec la même valeur, à l'exception des "
"attributs dont les nouvelles valeurs sont spécifiées par les arguments "
"nommés.  Notez que ``tzinfo=None`` peut être spécifié pour créer une "
"instance :class:`.time` naïve à partir d'une instance :class:`.time` avisée, "
"sans conversion des données de temps."

#: library/datetime.rst:1901
msgid ""
":class:`.time` objects are also supported by generic function :func:`copy."
"replace`."
msgstr ""

#: library/datetime.rst:1910
msgid "Return a string representing the time in ISO 8601 format, one of:"
msgstr "Renvoie une chaîne représentant la date au format ISO 8601 :"

#: library/datetime.rst:1912
msgid "``HH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``HH:MM:SS.ffffff``, si :attr:`microsecond` ne vaut pas 0"

#: library/datetime.rst:1913
msgid "``HH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``HH:MM:SS``, si :attr:`microsecond` vaut 0"

#: library/datetime.rst:1914
msgid ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :meth:`utcoffset` does not "
"return ``None``"
msgstr ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, si :meth:`utcoffset` ne renvoie pas "
"``None``"

#: library/datetime.rst:1915
msgid ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` is 0 and :meth:"
"`utcoffset` does not return ``None``"
msgstr ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``, si :attr:`microsecond` vaut 0 et :meth:"
"`utcoffset` ne renvoie pas ``None``"

#: library/datetime.rst:1935
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument."
msgstr ""
"Une :exc:`ValueError` sera levée en cas d'argument *timespec* invalide."

#: library/datetime.rst:1939
msgid ""
">>> from datetime import time\n"
">>> time(hour=12, minute=34, second=56, microsecond=123456)."
"isoformat(timespec='minutes')\n"
"'12:34'\n"
">>> dt = time(hour=12, minute=34, second=56, microsecond=0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'12:34:56.000000'\n"
">>> dt.isoformat(timespec='auto')\n"
"'12:34:56'"
msgstr ""

#: library/datetime.rst:1954
#, fuzzy
msgid "For a time ``t``, ``str(t)`` is equivalent to ``t.isoformat()``."
msgstr "Pour un temps *t*, ``str(t)`` est équivalent à ``t.isoformat()``."

#: library/datetime.rst:1959
msgid ""
"Return a string representing the time, controlled by an explicit format "
"string.  See also :ref:`strftime-strptime-behavior` and :meth:`time."
"isoformat`."
msgstr ""
"Renvoie une chaîne représentant l'heure, contrôlée par une chaîne de "
"formatage explicite.  Voir :ref:`strftime-strptime-behavior` et :meth:`time."
"isoformat`."

#: library/datetime.rst:1965
msgid ""
"Same as :meth:`.time.strftime`. This makes it possible to specify a format "
"string for a :class:`.time` object in :ref:`formatted string literals <f-"
"strings>` and when using :meth:`str.format`. See also :ref:`strftime-"
"strptime-behavior` and :meth:`time.isoformat`."
msgstr ""
"Identique à :meth:`.time.strftime`. Cela permet de spécifier une chaîne de "
"formatage pour un objet :class:`.time` dans une :ref:`chaîne de formatage "
"littérale <f-strings>` et à l'utilisation de :meth:`str.format`. Voir :ref:"
"`strftime-strptime-behavior` et :meth:`time.isoformat`."

#: library/datetime.rst:1973
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"utcoffset(None)``, and raises an exception if the latter doesn't return "
"``None`` or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Si :attr:`.tzinfo` est ``None``, renvoie ``None``, sinon renvoie ``self."
"tzinfo.utcoffset(None)``, et lève une exception si l'expression précédente "
"ne renvoie pas ``None`` ou un objet :class:`timedelta` d'une magnitude "
"inférieure à un jour."

#: library/datetime.rst:1983
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"dst(None)``, and raises an exception if the latter doesn't return ``None``, "
"or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Si :attr:`.tzinfo` est ``None``, renvoie ``None``, sinon renvoie ``self."
"tzinfo.dst(None)``, et lève une exception si l'expression précédente ne "
"renvoie pas ``None`` ou un objet :class:`timedelta` d'une magnitude "
"inférieure à un jour."

#: library/datetime.rst:1992
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"tzname(None)``, or raises an exception if the latter doesn't return ``None`` "
"or a string object."
msgstr ""
"Si :attr:`.tzinfo` est ``None``, renvoie ``None``, sinon renvoie ``self."
"tzinfo.tzname(None)``, et lève une exception si l'expression précédente ne "
"renvoie pas ``None`` ou une chaîne de caractères."

#: library/datetime.rst:1997
msgid "Examples of Usage: :class:`.time`"
msgstr "Exemples d'utilisation de :class:`.time`"

#: library/datetime.rst:1999
msgid "Examples of working with a :class:`.time` object::"
msgstr "Exemples d'utilisation de l'objet :class:`.time` ::"

#: library/datetime.rst:2001
msgid ""
">>> from datetime import time, tzinfo, timedelta\n"
">>> class TZ1(tzinfo):\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=1)\n"
"...     def dst(self, dt):\n"
"...         return timedelta(0)\n"
"...     def tzname(self,dt):\n"
"...         return \"+01:00\"\n"
"...     def  __repr__(self):\n"
"...         return f\"{self.__class__.__name__}()\"\n"
"...\n"
">>> t = time(12, 10, 30, tzinfo=TZ1())\n"
">>> t\n"
"datetime.time(12, 10, 30, tzinfo=TZ1())\n"
">>> t.isoformat()\n"
"'12:10:30+01:00'\n"
">>> t.dst()\n"
"datetime.timedelta(0)\n"
">>> t.tzname()\n"
"'+01:00'\n"
">>> t.strftime(\"%H:%M:%S %Z\")\n"
"'12:10:30 +01:00'\n"
">>> 'The {} is {:%H:%M}.'.format(\"time\", t)\n"
"'The time is 12:10.'"
msgstr ""

#: library/datetime.rst:2030
msgid ":class:`tzinfo` Objects"
msgstr "Objets :class:`tzinfo`"

#: library/datetime.rst:2034
msgid ""
"This is an abstract base class, meaning that this class should not be "
"instantiated directly.  Define a subclass of :class:`tzinfo` to capture "
"information about a particular time zone."
msgstr ""
"Il s'agit d'une classe mère abstraite, ce qui signifie que cette classe ne "
"doit pas être instanciée directement.  Définissez une sous-classe de :class:"
"`tzinfo` pour capturer des informations sur un fuseau horaire particulier."

#: library/datetime.rst:2038
msgid ""
"An instance of (a concrete subclass of) :class:`tzinfo` can be passed to the "
"constructors for :class:`.datetime` and :class:`.time` objects. The latter "
"objects view their attributes as being in local time, and the :class:"
"`tzinfo` object supports methods revealing offset of local time from UTC, "
"the name of the time zone, and DST offset, all relative to a date or time "
"object passed to them."
msgstr ""
"Une instance (d'une sous-classe concrète) de :class:`tzinfo` peut être "
"passée aux constructeurs des objets :class:`.datetime` et :class:`.time`. "
"Les objets en question voient leurs attributs comme étant en temps local, et "
"l'objet :class:`.tzinfo` contient des méthodes pour obtenir le décalage du "
"temps local par rapport à UTC, le nom du fuseau horaire, le décalage d'heure "
"d'été, tous relatifs à un objet de date ou d'heure qui leur est passé."

#: library/datetime.rst:2044
#, fuzzy
msgid ""
"You need to derive a concrete subclass, and (at least) supply "
"implementations of the standard :class:`tzinfo` methods needed by the :class:"
"`.datetime` methods you use. The :mod:`!datetime` module provides :class:"
"`timezone`, a simple concrete subclass of :class:`tzinfo` which can "
"represent time zones with fixed offset from UTC such as UTC itself or North "
"American EST and EDT."
msgstr ""
"Vous devez en dériver une sous-classe concrète et (au minimum) fournir des "
"implémentations aux méthodes standard :class:`tzinfo` requises par les "
"méthodes de :class:`.datetime` que vous utilisez.  Le module :mod:`datetime` "
"fournit une simple sous-classe concrète de :class:`tzinfo`, :class:"
"`timezone`, qui peut représenter des fuseaux horaires avec des décalages "
"fixes par rapport à UTC, tels qu'UTC lui-même ou les fuseaux nord-américains "
"EST et EDT."

#: library/datetime.rst:2051
#, fuzzy
msgid ""
"Special requirement for pickling:  A :class:`tzinfo` subclass must have an :"
"meth:`~object.__init__` method that can be called with no arguments, "
"otherwise it can be pickled but possibly not unpickled again. This is a "
"technical requirement that may be relaxed in the future."
msgstr ""
"Prérequis spécifique à la sérialisation : Une sous-classe :class:`tzinfo` "
"doit avoir une méthode :meth:`__init__` qui peut être appelée sans "
"arguments, sans quoi un objet sérialisé ne pourrait pas toujours être "
"désérialisé.  C'est un prérequis technique qui pourrait être assoupli dans "
"le futur."

#: library/datetime.rst:2057
#, fuzzy
msgid ""
"A concrete subclass of :class:`tzinfo` may need to implement the following "
"methods. Exactly which methods are needed depends on the uses made of aware :"
"mod:`!datetime` objects. If in doubt, simply implement all of them."
msgstr ""
"Une sous-classe concrète de :class:`tzinfo` peut devoir implémenter les "
"méthodes suivantes.  Les méthodes réellement nécessaires dépendent de "
"l'utilisation qui est faite des objets :mod:`datetime` avisés.  Dans le "
"doute, implémentez-les toutes."

#: library/datetime.rst:2064
msgid ""
"Return offset of local time from UTC, as a :class:`timedelta` object that is "
"positive east of UTC. If local time is west of UTC, this should be negative."
msgstr ""
"Renvoie le décalage de l'heure locale par rapport à UTC, sous la forme d'un "
"objet :class:`timedelta` qui est positif à l'est de UTC. Si l'heure locale "
"est à l'ouest de UTC, il doit être négatif."

#: library/datetime.rst:2067
msgid ""
"This represents the *total* offset from UTC; for example, if a :class:"
"`tzinfo` object represents both time zone and DST adjustments, :meth:"
"`utcoffset` should return their sum. If the UTC offset isn't known, return "
"``None``. Else the value returned must be a :class:`timedelta` object "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)`` (the "
"magnitude of the offset must be less than one day). Most implementations of :"
"meth:`utcoffset` will probably look like one of these two::"
msgstr ""
"Cela représente le décalage *total* par rapport à UTC ; par exemple, si un "
"objet :class:`tzinfo` représente à la fois un fuseau horaire et son "
"ajustement à l'heure d'été, :meth:`utcoffset` devrait renvoyer leur somme.  "
"Si le décalage UTC n'est pas connu, elle renvoie ``None``.  Sinon, la valeur "
"renvoyée doit être un objet :class:`timedelta` compris strictement entre ``-"
"timedelta(hours=24)`` et ``timedelta(hours=24)`` (l'amplitude du décalage "
"doit être inférieure à un jour).  La plupart des implémentations de :meth:"
"`utcoffset` ressembleront probablement à l'une des deux suivantes ::"

#: library/datetime.rst:2075
msgid ""
"return CONSTANT                 # fixed-offset class\n"
"return CONSTANT + self.dst(dt)  # daylight-aware class"
msgstr ""

#: library/datetime.rst:2078
msgid ""
"If :meth:`utcoffset` does not return ``None``, :meth:`dst` should not return "
"``None`` either."
msgstr ""
"Si :meth:`utcoffset` ne renvoie pas ``None``, :meth:`dst` ne doit pas non "
"plus renvoyer ``None``."

#: library/datetime.rst:2081
msgid ""
"The default implementation of :meth:`utcoffset` raises :exc:"
"`NotImplementedError`."
msgstr ""
"L'implémentation par défaut de :meth:`utcoffset` lève une :exc:"
"`NotImplementedError`."

#: library/datetime.rst:2090
msgid ""
"Return the daylight saving time (DST) adjustment, as a :class:`timedelta` "
"object or ``None`` if DST information isn't known."
msgstr ""
"Renvoie le réglage de l'heure d'été (DST), sous la forme d'un objet :class:"
"`timedelta` ou ``None`` si l'information DST n'est pas connue."

#: library/datetime.rst:2094
#, fuzzy
msgid ""
"Return ``timedelta(0)`` if DST is not in effect. If DST is in effect, return "
"the offset as a :class:`timedelta` object (see :meth:`utcoffset` for "
"details). Note that DST offset, if applicable, has already been added to the "
"UTC offset returned by :meth:`utcoffset`, so there's no need to consult :"
"meth:`dst` unless you're interested in obtaining DST info separately. For "
"example, :meth:`datetime.timetuple` calls its :attr:`~.datetime.tzinfo` "
"attribute's :meth:`dst` method to determine how the :attr:`~time.struct_time."
"tm_isdst` flag should be set, and :meth:`tzinfo.fromutc` calls :meth:`dst` "
"to account for DST changes when crossing time zones."
msgstr ""
"Renvoie ``timedelta(0)`` si l'heure d'été n'est pas effective. Si elle est "
"effective, renvoie un décalage sous forme d'un objet :class:`timedelta` "
"(voir :meth:`utcoffset` pour les détails). Notez que ce décalage, si "
"applicable, est déjà compris dans le décalage UTC renvoyé par :meth:"
"`utcoffset`, il n'est donc pas nécessaire de faire appel à :meth:`dst` à "
"moins que vous ne souhaitiez obtenir les informations séparément.  Par "
"exemple, :meth:`datetime.timetuple` appelle la méthode :meth:`dst` de son "
"attribut :attr:`~.datetime.tzinfo` pour déterminer si l'option :attr:"
"`tm_isdst` doit être activée, et :meth:`tzinfo.fromutc` fait appel à :meth:"
"`dst` pour tenir compte des heures d'été quand elle traverse des fuseaux "
"horaires."

#: library/datetime.rst:2104
msgid ""
"An instance *tz* of a :class:`tzinfo` subclass that models both standard and "
"daylight times must be consistent in this sense:"
msgstr ""
"Une instance *tz* d'une sous-classe :class:`tzinfo` convenant à la fois pour "
"une heure standard et une heure d'été doit être cohérente :"

#: library/datetime.rst:2107
msgid "``tz.utcoffset(dt) - tz.dst(dt)``"
msgstr "``tz.utcoffset(dt) - tz.dst(dt)``"

#: library/datetime.rst:2109
#, fuzzy
msgid ""
"must return the same result for every :class:`.datetime` *dt* with ``dt."
"tzinfo == tz``. For sane :class:`tzinfo` subclasses, this expression yields "
"the time zone's \"standard offset\", which should not depend on the date or "
"the time, but only on geographic location. The implementation of :meth:"
"`datetime.astimezone` relies on this, but cannot detect violations; it's the "
"programmer's responsibility to ensure it. If a :class:`tzinfo` subclass "
"cannot guarantee this, it may be able to override the default implementation "
"of :meth:`tzinfo.fromutc` to work correctly with :meth:`~.datetime."
"astimezone` regardless."
msgstr ""
"doit renvoyer le même résultat pour tout objet :class:`.datetime` *dt* avec "
"``dt.tzinfo == tz``  Pour les sous-classes saines de :class:`tzinfo`, cette "
"expression calcule le « décalage standard » du fuseau horaire, qui ne doit "
"pas dépendre de la date ou de l'heure, mais seulement de la position "
"géographique.  L'implémentation de :meth:`datetime.astimezone` se base là-"
"dessus, mais ne peut pas détecter les violations ; il est de la "
"responsabilité du programmeur de l'assurer.  Si une sous-classe :class:"
"`tzinfo` ne le garantit pas, il doit être possible de redéfinir "
"l'implémentation par défaut de :meth:`tzinfo.fromutc` pour tout de même "
"fonctionner correctement avec :meth:`astimezone`."

#: library/datetime.rst:2118
msgid ""
"Most implementations of :meth:`dst` will probably look like one of these "
"two::"
msgstr ""
"La plupart des implémentations de :meth:`dst` ressembleront probablement à "
"l'une des deux suivantes ::"

#: library/datetime.rst:2120
msgid ""
"def dst(self, dt):\n"
"    # a fixed-offset class:  doesn't account for DST\n"
"    return timedelta(0)"
msgstr ""

#: library/datetime.rst:2124
msgid "or::"
msgstr "ou ::"

#: library/datetime.rst:2126
msgid ""
"def dst(self, dt):\n"
"    # Code to set dston and dstoff to the time zone's DST\n"
"    # transition times based on the input dt.year, and expressed\n"
"    # in standard local time.\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        return timedelta(hours=1)\n"
"    else:\n"
"        return timedelta(0)"
msgstr ""

#: library/datetime.rst:2136
msgid ""
"The default implementation of :meth:`dst` raises :exc:`NotImplementedError`."
msgstr ""
"L'implémentation par défaut de :meth:`dst` lève une :exc:"
"`NotImplementedError`."

#: library/datetime.rst:2144
#, fuzzy
msgid ""
"Return the time zone name corresponding to the :class:`.datetime` object "
"*dt*, as a string. Nothing about string names is defined by the :mod:`!"
"datetime` module, and there's no requirement that it mean anything in "
"particular. For example, ``\"GMT\"``, ``\"UTC\"``, ``\"-500\"``, "
"``\"-5:00\"``, ``\"EDT\"``, ``\"US/Eastern\"``, ``\"America/New York\"`` are "
"all valid replies. Return ``None`` if a string name isn't known. Note that "
"this is a method rather than a fixed string primarily because some :class:"
"`tzinfo` subclasses will wish to return different names depending on the "
"specific value of *dt* passed, especially if the :class:`tzinfo` class is "
"accounting for daylight time."
msgstr ""
"Renvoie le nom du fuseau horaire correspondant à l'objet :class:`.datetime` "
"*dt*, sous forme d'une chaîne. Rien n'est défini sur les noms par le module :"
"mod:`datetime`, et il n'est pas nécessaire que ces noms signifient quelque "
"chose en particulier.  Par exemple, « *GMT* », « *UTC* », « *-500* », "
"« *-5:00* », « *EDT* », « *US/Eastern* » et « *America/New York* » sont "
"toutes des valeurs de retour valides.  Renvoie ``None`` si un nom est "
"inconnu.  Notez qu'il s'agit d'une méthode et non d'une chaîne fixée en "
"amont, parce que les sous-classes de :class:`tzinfo` peuvent souhaiter "
"renvoyer des noms différents en fonction de valeurs de *dt* spécifiques, en "
"particulier si la classe :class:`tzinfo` tient compte de l'heure d'été."

#: library/datetime.rst:2154
msgid ""
"The default implementation of :meth:`tzname` raises :exc:"
"`NotImplementedError`."
msgstr ""
"L'implémentation par défaut de :meth:`tzname` lève une :exc:"
"`NotImplementedError`."

#: library/datetime.rst:2157
msgid ""
"These methods are called by a :class:`.datetime` or :class:`.time` object, "
"in response to their methods of the same names. A :class:`.datetime` object "
"passes itself as the argument, and a :class:`.time` object passes ``None`` "
"as the argument. A :class:`tzinfo` subclass's methods should therefore be "
"prepared to accept a *dt* argument of ``None``, or of class :class:`."
"datetime`."
msgstr ""
"Ces méthodes sont appelées par les objets :class:`.datetime` et :class:`."
"time`, en réponse à leurs méthodes de mêmes noms.  Un objet :class:`."
"datetime` se passe lui-même en tant qu'argument, et un objet :class:`.time` "
"passe ``None``.  Les méthodes des sous-classes :class:`tzinfo` doivent alors "
"être prêtes à recevoir un argument ``None`` pour *dt*, ou une instance de :"
"class:`.datetime`."

#: library/datetime.rst:2163
msgid ""
"When ``None`` is passed, it's up to the class designer to decide the best "
"response. For example, returning ``None`` is appropriate if the class wishes "
"to say that time objects don't participate in the :class:`tzinfo` protocols. "
"It may be more useful for ``utcoffset(None)`` to return the standard UTC "
"offset, as there is no other convention for discovering the standard offset."
msgstr ""
"Quand ``None`` est passé, il est de la responsabilité du *designer* de la "
"classe de choisir la meilleure réponse.  Par exemple, renvoyer ``None`` est "
"approprié si la classe souhaite signaler que les objets de temps ne "
"participent pas au protocole :class:`tzinfo`. Il peut être plus utile pour "
"``utcoffset(None)`` de renvoyer le décalage UTC standard, comme il n'existe "
"aucune autre convention pour obtenir ce décalage."

#: library/datetime.rst:2169
#, fuzzy
msgid ""
"When a :class:`.datetime` object is passed in response to a :class:`."
"datetime` method, ``dt.tzinfo`` is the same object as *self*. :class:"
"`tzinfo` methods can rely on this, unless user code calls :class:`tzinfo` "
"methods directly. The intent is that the :class:`tzinfo` methods interpret "
"*dt* as being in local time, and not need worry about objects in other time "
"zones."
msgstr ""
"Quand un objet :class:`.datetime` est passé en réponse à une méthode de :"
"class:`.datetime`, ``dt.tzinfo`` est le même objet que *self*.  Les méthodes "
"de :class:`tzinfo` peuvent se baser là-dessus, à moins que le code "
"utilisateur appelle directement des méthodes de :class:`tzinfo`. L'intention "
"est que les méthodes de :class:`tzinfo` interprètent *dt* comme étant le "
"temps local, et n'aient pas à se soucier des objets dans d'autres fuseaux "
"horaires."

#: library/datetime.rst:2175
msgid ""
"There is one more :class:`tzinfo` method that a subclass may wish to "
"override:"
msgstr ""
"Il y a une dernière méthode de :class:`tzinfo` que les sous-classes peuvent "
"vouloir redéfinir :"

#: library/datetime.rst:2180
#, fuzzy
msgid ""
"This is called from the default :meth:`datetime.astimezone` implementation. "
"When called from that, ``dt.tzinfo`` is *self*, and *dt*'s date and time "
"data are to be viewed as expressing a UTC time. The purpose of :meth:"
"`fromutc` is to adjust the date and time data, returning an equivalent "
"datetime in *self*'s local time."
msgstr ""
"Elle est appelée par l'implémentation par défaut de :class:`datetime."
"astimezone()`. Lors d'un appel depuis cette méthode, ``dt.tzinfo`` vaut "
"*self* et les données de date et d'heure de *dt* sont vues comme exprimant "
"un horodatage UTC. Le rôle de :meth:`fromutc` est d'ajuster les données de "
"date et d'heure, renvoyant un objet *datetime* équivalent à *self*, dans le "
"temps local."

#: library/datetime.rst:2186
#, fuzzy
msgid ""
"Most :class:`tzinfo` subclasses should be able to inherit the default :meth:"
"`fromutc` implementation without problems. It's strong enough to handle "
"fixed-offset time zones, and time zones accounting for both standard and "
"daylight time, and the latter even if the DST transition times differ in "
"different years. An example of a time zone the default :meth:`fromutc` "
"implementation may not handle correctly in all cases is one where the "
"standard offset (from UTC) depends on the specific date and time passed, "
"which can happen for political reasons. The default implementations of :meth:"
"`~.datetime.astimezone` and :meth:`fromutc` may not produce the result you "
"want if the result is one of the hours straddling the moment the standard "
"offset changes."
msgstr ""
"La plupart des sous-classes :class:`tzinfo` doivent être en mesure d'hériter "
"sans problème de l'implémentation par défaut de :meth:`fromutc`. Elle est "
"suffisamment robuste pour gérer les fuseaux horaires à décalage fixe, et les "
"fuseaux représentant à la fois des heures standards et d'été, et ce même si "
"le décalage de l'heure d'été est différent suivant les années. Un exemple de "
"fuseau horaire qui ne serait pas géré correctement dans tous les cas par "
"l'implémentation par défaut de :meth:`fromutc` en est un où le décalage "
"standard (par rapport à UTC) dépend de valeurs spécifiques de date et "
"d'heure passées, ce qui peut arriver pour des raisons politiques. Les "
"implémentations par défaut de :meth:`astimezone` et :meth:`fromutc` peuvent "
"ne pas produire les résultats attendus si le résultat est l'une des heures "
"affectées par le changement d'heure."

#: library/datetime.rst:2197
msgid ""
"Skipping code for error cases, the default :meth:`fromutc` implementation "
"acts like::"
msgstr ""
"En omettant le code des cas d'erreurs, l'implémentation par défaut de :meth:"
"`fromutc` se comporte comme suit ::"

#: library/datetime.rst:2200
msgid ""
"def fromutc(self, dt):\n"
"    # raise ValueError error if dt.tzinfo is not self\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # raise ValueError if dtoff is None or dtdst is None\n"
"    delta = dtoff - dtdst  # this is self's standard offset\n"
"    if delta:\n"
"        dt += delta   # convert to standard local time\n"
"        dtdst = dt.dst()\n"
"        # raise ValueError if dtdst is None\n"
"    if dtdst:\n"
"        return dt + dtdst\n"
"    else:\n"
"        return dt"
msgstr ""

#: library/datetime.rst:2215
msgid ""
"In the following :download:`tzinfo_examples.py <../includes/tzinfo_examples."
"py>` file there are some examples of :class:`tzinfo` classes:"
msgstr ""
"Dans le fichier :download:`tzinfo_examples.py <../includes/tzinfo_examples."
"py>` il y a des exemples de :class:`tzinfo` classes :"

#: library/datetime.rst:2219
msgid ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"SECOND = timedelta(seconds=1)\n"
"\n"
"# A class capturing the platform's idea of local time.\n"
"# (May result in wrong values on historical times in\n"
"#  timezones where UTC offset and/or the DST rules had\n"
"#  changed in the past.)\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND\n"
"        args = _time.localtime(stamp)[:6]\n"
"        dst_diff = DSTDIFF // SECOND\n"
"        # Detect fold\n"
"        fold = (args == _time.localtime(stamp - dst_diff))\n"
"        return datetime(*args, microsecond=dt.microsecond,\n"
"                        tzinfo=self, fold=fold)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, 0)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# A complete implementation of current DST rules for major US time zones.\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# US DST Rules\n"
"#\n"
"# This is a simplified (i.e., wrong for a few cases) set of rules for US\n"
"# DST start and end times. For a complete and up-to-date set of DST rules\n"
"# and timezone definitions, visit the Olson Database (or try pytz):\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# https://sourceforge.net/projects/pytz/ (might not be up-to-date)\n"
"#\n"
"# In the US, since 2007, DST starts at 2am (standard time) on the second\n"
"# Sunday in March, which is the first Sunday on or after Mar 8.\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# and ends at 2am (DST time) on the first Sunday of Nov.\n"
"DSTEND_2007 = datetime(1, 11, 1, 2)\n"
"# From 1987 to 2006, DST used to start at 2am (standard time) on the first\n"
"# Sunday in April and to end at 2am (DST time) on the last\n"
"# Sunday of October, which is the first Sunday on or after Oct 25.\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 2)\n"
"# From 1967 to 1986, DST used to start at 2am (standard time) on the last\n"
"# Sunday in April (the one on or after April 24) and to end at 2am (DST "
"time)\n"
"# on the last Sunday of October, which is the first Sunday\n"
"# on or after Oct 25.\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"def us_dst_range(year):\n"
"    # Find start and end times for US DST. For years before 1967, return\n"
"    # start = end for no DST.\n"
"    if 2006 < year:\n"
"        dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"    elif 1986 < year < 2007:\n"
"        dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"    elif 1966 < year < 1987:\n"
"        dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"    else:\n"
"        return (datetime(year, 1, 1), ) * 2\n"
"\n"
"    start = first_sunday_on_or_after(dststart.replace(year=year))\n"
"    end = first_sunday_on_or_after(dstend.replace(year=year))\n"
"    return start, end\n"
"\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # An exception may be sensible here, in one or both cases.\n"
"            # It depends on how you want to treat them.  The default\n"
"            # fromutc() implementation (called by the default astimezone()\n"
"            # implementation) passes a datetime with dt.tzinfo is self.\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        # Can't compare naive to aware objects, so strip the timezone from\n"
"        # dt first.\n"
"        dt = dt.replace(tzinfo=None)\n"
"        if start + HOUR <= dt < end - HOUR:\n"
"            # DST is in effect.\n"
"            return HOUR\n"
"        if end - HOUR <= dt < end:\n"
"            # Fold (an ambiguous hour): use dt.fold to disambiguate.\n"
"            return ZERO if dt.fold else HOUR\n"
"        if start <= dt < start + HOUR:\n"
"            # Gap (a non-existent hour): reverse the fold rule.\n"
"            return HOUR if dt.fold else ZERO\n"
"        # DST is off.\n"
"        return ZERO\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        start = start.replace(tzinfo=self)\n"
"        end = end.replace(tzinfo=self)\n"
"        std_time = dt + self.stdoffset\n"
"        dst_time = std_time + HOUR\n"
"        if end <= dst_time < end + HOUR:\n"
"            # Repeated hour\n"
"            return std_time.replace(fold=1)\n"
"        if std_time < start or dst_time >= end:\n"
"            # Standard time\n"
"            return std_time\n"
"        if start <= std_time < end - HOUR:\n"
"            # Daylight saving time\n"
"            return dst_time\n"
"\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"
msgstr ""

#: library/datetime.rst:2221
msgid ""
"Note that there are unavoidable subtleties twice per year in a :class:"
"`tzinfo` subclass accounting for both standard and daylight time, at the DST "
"transition points. For concreteness, consider US Eastern (UTC -0500), where "
"EDT begins the minute after 1:59 (EST) on the second Sunday in March, and "
"ends the minute after 1:59 (EDT) on the first Sunday in November::"
msgstr ""
"Notez que, deux fois par an, on rencontre des subtilités inévitables dans "
"les sous-classes de :class:`tzinfo` représentant à la fois des heures "
"standard et d'été, au passage de l'une à l'autre. Concrètement, considérez "
"le fuseau de l'est des États-Unis (UTC -0500), où EDT (heure d'été) débute à "
"la minute qui suit 1:59 (EST) le second dimanche de mars, et se termine à la "
"minute qui suit 1:59 (EDT) le premier dimanche de novembre ::"

#: library/datetime.rst:2227
msgid ""
"  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM\n"
"  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM\n"
"  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM\n"
"\n"
"start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM\n"
"\n"
"  end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM"
msgstr ""

#: library/datetime.rst:2235
msgid ""
"When DST starts (the \"start\" line), the local wall clock leaps from 1:59 "
"to 3:00. A wall time of the form 2:MM doesn't really make sense on that day, "
"so ``astimezone(Eastern)`` won't deliver a result with ``hour == 2`` on the "
"day DST begins. For example, at the Spring forward transition of 2016, we "
"get::"
msgstr ""
"Quand l'heure d'été débute (la ligne « *start* »), l'horloge locale passe de "
"1:59 à 3:00. Une heure de la forme 2:MM n'a pas vraiment de sens ce jour là, "
"donc  ``astimezone(Eastern)`` ne fournira pas de résultat avec ``hour == 2`` "
"pour le jour où débute l'heure d'été. Par exemple, lors du changement "
"d'heure du printemps 2016, nous obtenons ::"

#: library/datetime.rst:2240
msgid ""
">>> from datetime import datetime, timezone\n"
">>> from tzinfo_examples import HOUR, Eastern\n"
">>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname())\n"
"...\n"
"05:00:00 UTC = 00:00:00 EST\n"
"06:00:00 UTC = 01:00:00 EST\n"
"07:00:00 UTC = 03:00:00 EDT\n"
"08:00:00 UTC = 04:00:00 EDT"
msgstr ""

#: library/datetime.rst:2254
#, fuzzy
msgid ""
"When DST ends (the \"end\" line), there's a potentially worse problem: "
"there's an hour that can't be spelled unambiguously in local wall time: the "
"last hour of daylight time. In Eastern, that's times of the form 5:MM UTC on "
"the day daylight time ends. The local wall clock leaps from 1:59 (daylight "
"time) back to 1:00 (standard time) again. Local times of the form 1:MM are "
"ambiguous. :meth:`~.datetime.astimezone` mimics the local clock's behavior "
"by mapping two adjacent UTC hours into the same local hour then. In the "
"Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when "
"converted to Eastern, but earlier times have the :attr:`~.datetime.fold` "
"attribute set to 0 and the later times have it set to 1. For example, at the "
"Fall back transition of 2016, we get::"
msgstr ""
"Quand l'heure d'été se termine (la ligne « *end* »), il y a potentiellement "
"un problème pire que cela : il y a une heure qui ne peut pas être exprimée "
"sans ambiguïté en temps local : la dernière heure de l'heure d'été. Dans "
"l'est des États-Unis, l'heure d'été se termine sur les heures de la forme 5:"
"MM UTC. L'horloge locale passe de 1:59 (heure d'été) à 1:00 (heure d'hiver) "
"à nouveau. Les heures locales de la forme 1:MM sont ambiguës. :meth:"
"`astimezone` imite le comportement des horloges locales en associant deux "
"heures UTC adjacentes à la même heure locale.  Dans notre exemple, les "
"horodatages UTC de la forme 5:MM et 6:MM sont tous deux associés à 1:MM "
"quand ils sont convertis vers ce fuseau, mais les horodatages les plus "
"anciens ont l'attribut :attr:`~datetime.fold` à 0 et les plus récents l'ont "
"à 1. Par exemple, lors du changement d'heure de l'automne 2016, nous "
"obtenons ::"

#: library/datetime.rst:2265
msgid ""
">>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)\n"
"...\n"
"04:00:00 UTC = 00:00:00 EDT 0\n"
"05:00:00 UTC = 01:00:00 EDT 0\n"
"06:00:00 UTC = 01:00:00 EST 1\n"
"07:00:00 UTC = 02:00:00 EST 0"
msgstr ""

#: library/datetime.rst:2276
#, fuzzy
msgid ""
"Note that the :class:`.datetime` instances that differ only by the value of "
"the :attr:`~.datetime.fold` attribute are considered equal in comparisons."
msgstr ""
"Notez que deux instances :class:`datetime` qui ne diffèrent que par la "
"valeur de leur attribut :attr:`~datetime.fold` sont considérées égales dans "
"les comparaisons."

#: library/datetime.rst:2279
#, fuzzy
msgid ""
"Applications that can't bear wall-time ambiguities should explicitly check "
"the value of the :attr:`~.datetime.fold` attribute or avoid using hybrid :"
"class:`tzinfo` subclasses; there are no ambiguities when using :class:"
"`timezone`, or any other fixed-offset :class:`tzinfo` subclass (such as a "
"class representing only EST (fixed offset -5 hours), or only EDT (fixed "
"offset -4 hours))."
msgstr ""
"Les applications qui ne peuvent pas gérer ces ambiguïtés doivent vérifier "
"explicitement la valeur de l'attribut :attr:`~datetime.fold` ou éviter "
"d'utiliser des sous-classes :class:`tzinfo` hybrides ; il n'y a aucune "
"ambiguïté lors de l'utilisation de la classe :class:`timezone`, ou toute "
"autre sous-classe de :class:`tzinfo` à décalage fixe (comme une classe "
"représentant uniquement le fuseau EST (de décalage fixe *-5h*) ou uniquement "
"EDT (*-4h*))."

#: library/datetime.rst:2287
msgid ":mod:`zoneinfo`"
msgstr ":mod:`zoneinfo`"

#: library/datetime.rst:2288
#, fuzzy
msgid ""
"The :mod:`!datetime` module has a basic :class:`timezone` class (for "
"handling arbitrary fixed offsets from UTC) and its :attr:`timezone.utc` "
"attribute (a UTC :class:`!timezone` instance)."
msgstr ""
"Le module :mod:`datetime` contient une classe élémentaire :class:`timezone` "
"pour gérer des décalages fixes par rapport à UTC et :attr:`timezone.utc` "
"comme instance du fuseau horaire UTC."

#: library/datetime.rst:2292
#, fuzzy
msgid ""
"``zoneinfo`` brings the *IANA time zone database* (also known as the Olson "
"database) to Python, and its usage is recommended."
msgstr ""
"``zoneinfo`` apporte à Python la *base de données de fuseaux horaires IANA* "
"(aussi appelée base de données Olson), et son utilisation est recommandée."

#: library/datetime.rst:2295
#, fuzzy
msgid "`IANA time zone database <https://www.iana.org/time-zones>`_"
msgstr ""
"`Base de données des fuseaux horaires de l'IANA <https://www.iana.org/time-"
"zones>`_"

#: library/datetime.rst:2296
msgid ""
"The Time Zone Database (often called tz, tzdata or zoneinfo) contains code "
"and data that represent the history of local time for many representative "
"locations around the globe. It is updated periodically to reflect changes "
"made by political bodies to time zone boundaries, UTC offsets, and daylight-"
"saving rules."
msgstr ""
"La *Time Zone Database* (souvent appelée *tz*, *tzdata* ou *zoneinfo*) "
"contient les codes et les données représentant l'historique du temps local "
"pour un grand nombre d'emplacements représentatifs autour du globe. Elle est "
"mise à jour périodiquement, pour refléter les changements opérés par des "
"politiques sur les bornes du fuseau, les décalages UTC, et les règles de "
"passage à l'heure d'été."

#: library/datetime.rst:2306
msgid ":class:`timezone` Objects"
msgstr "Objets :class:`timezone`"

#: library/datetime.rst:2308
#, fuzzy
msgid ""
"The :class:`timezone` class is a subclass of :class:`tzinfo`, each instance "
"of which represents a time zone defined by a fixed offset from UTC."
msgstr ""
"La classe :class:`timezone` est une sous-classe de :class:`tzinfo`, dont "
"chaque instance représente un fuseau horaire défini par un décalage fixe par "
"rapport à UTC."

#: library/datetime.rst:2312
#, fuzzy
msgid ""
"Objects of this class cannot be used to represent time zone information in "
"the locations where different offsets are used in different days of the year "
"or where historical changes have been made to civil time."
msgstr ""
"Les objets de cette classe ne peuvent pas être utilisés pour représenter les "
"informations de fuseaux horaires dans des emplacements où plusieurs "
"décalages sont utilisés au cours de l'année ni où le déroulement du temps "
"civil a fait l'objet d'ajustements."

#: library/datetime.rst:2319
msgid ""
"The *offset* argument must be specified as a :class:`timedelta` object "
"representing the difference between the local time and UTC. It must be "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)``, "
"otherwise :exc:`ValueError` is raised."
msgstr ""
"L'argument *offset* doit être spécifié comme un objet :class:`timedelta` "
"représentant la différence entre le temps local et UTC. Il doit être "
"strictement compris entre ``-timedelta(hours=24)`` et "
"``timedelta(hours=24)``, autrement une :exc:`ValueError` est levée."

#: library/datetime.rst:2324
msgid ""
"The *name* argument is optional. If specified it must be a string that will "
"be used as the value returned by the :meth:`datetime.tzname` method."
msgstr ""
"L'argument *name* est optionnel. S'il est spécifié, il doit être une chaîne "
"qui sera utilisée comme valeur de retour de la méthode :meth:`datetime."
"tzname`."

#: library/datetime.rst:2346
msgid ""
"Return the fixed value specified when the :class:`timezone` instance is "
"constructed."
msgstr ""
"Renvoie la valeur fixe spécifiée lorsque l'instance :class:`timezone` est "
"construite."

#: library/datetime.rst:2338
msgid ""
"The *dt* argument is ignored. The return value is a :class:`timedelta` "
"instance equal to the difference between the local time and UTC."
msgstr ""
"L'argument *dt* est ignoré. La valeur de retour est une instance :class:"
"`timedelta` égale à la différence entre le temps local et UTC."

#: library/datetime.rst:2349
msgid ""
"If *name* is not provided in the constructor, the name returned by "
"``tzname(dt)`` is generated from the value of the ``offset`` as follows. If "
"*offset* is ``timedelta(0)``, the name is \"UTC\", otherwise it is a string "
"in the format ``UTC±HH:MM``, where ± is the sign of ``offset``, HH and MM "
"are two digits of ``offset.hours`` and ``offset.minutes`` respectively."
msgstr ""
"Si *name* n'est pas fourni au constructeur, le nom renvoyé par "
"``tzname(dt)`` est généré comme suit à partir de la valeur de ``offset``.  "
"Si *offset* vaut ``timedelta(0)``, le nom sera « UTC », autrement le nom "
"sera une chaîne de la forme ``UTC±HH:MM``, où ± est le signe d'``offset``, "
"et HH et MM sont respectivement les représentations à deux chiffres de "
"``offset.hours`` et ``offset.minutes``."

#: library/datetime.rst:2355
msgid ""
"Name generated from ``offset=timedelta(0)`` is now plain ``'UTC'``, not "
"``'UTC+00:00'``."
msgstr ""
"Le nom généré à partir de ``offset=timedelta(0)`` est maintenant ``'UTC'`` "
"plutôt que ``'UTC+00:00'``."

#: library/datetime.rst:2362
msgid "Always returns ``None``."
msgstr "Renvoie toujours ``None``."

#: library/datetime.rst:2366
msgid ""
"Return ``dt + offset``. The *dt* argument must be an aware :class:`."
"datetime` instance, with ``tzinfo`` set to ``self``."
msgstr ""
"Renvoie ``dt + offset``. L'argument *dt* doit être une instance avisée de :"
"class:`.datetime`, avec ``tzinfo`` valant ``self``."

#: library/datetime.rst:2373
#, fuzzy
msgid "The UTC time zone, ``timezone(timedelta(0))``."
msgstr "Le fuseau horaire UTC, ``timezone(timedelta(0))``."

#: library/datetime.rst:2382
#, fuzzy
msgid ":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Behavior"
msgstr "Comportement de :meth:`strftime` et :meth:`strptime`"

#: library/datetime.rst:2384
msgid ""
":class:`date`, :class:`.datetime`, and :class:`.time` objects all support a "
"``strftime(format)`` method, to create a string representing the time under "
"the control of an explicit format string."
msgstr ""
"Les objets :class:`date`, :class:`.datetime` et :class:`.time` comportent "
"tous une méthode ``strftime(format)``, pour créer une représentation du "
"temps sous forme d'une chaîne, contrôlée par une chaîne de formatage "
"explicite."

#: library/datetime.rst:2388
msgid ""
"Conversely, the :meth:`datetime.strptime` class method creates a :class:`."
"datetime` object from a string representing a date and time and a "
"corresponding format string."
msgstr ""
"Inversement, la méthode de classe :meth:`datetime.strptime` crée un objet :"
"class:`.datetime` à partir d'une chaîne représentant une date et une heure, "
"et une chaîne de format correspondante."

#: library/datetime.rst:2392
#, fuzzy
msgid ""
"The table below provides a high-level comparison of :meth:`~.datetime."
"strftime` versus :meth:`~.datetime.strptime`:"
msgstr ""
"Le tableau ci-dessous fournit une comparaison de haut niveau entre :meth:"
"`strftime` et :meth:`strptime` :"

#: library/datetime.rst:2396
msgid "``strftime``"
msgstr "``strftime``"

#: library/datetime.rst:2396
msgid "``strptime``"
msgstr "``strptime``"

#: library/datetime.rst:2398
msgid "Usage"
msgstr "Utilisation"

#: library/datetime.rst:2398
msgid "Convert object to a string according to a given format"
msgstr "Convertit un objet en une chaîne selon un format donné"

#: library/datetime.rst:2398
msgid ""
"Parse a string into a :class:`.datetime` object given a corresponding format"
msgstr ""
"Analyse une chaîne dans un objet :class:`.datetime` en fonction du format de "
"correspondance donné"

#: library/datetime.rst:2400
msgid "Type of method"
msgstr "Type de méthode"

#: library/datetime.rst:2400
msgid "Instance method"
msgstr "Méthode d'instance"

#: library/datetime.rst:2400
msgid "Class method"
msgstr "Méthode de classe"

#: library/datetime.rst:2402
msgid "Method of"
msgstr "Méthode de"

#: library/datetime.rst:2402
msgid ":class:`date`; :class:`.datetime`; :class:`.time`"
msgstr ":class:`date` ; :class:`.datetime` ; :class:`.time`"

#: library/datetime.rst:2402
msgid ":class:`.datetime`"
msgstr ":class:`.datetime`"

#: library/datetime.rst:2404
msgid "Signature"
msgstr "Signature"

#: library/datetime.rst:2404
msgid "``strftime(format)``"
msgstr "``strftime(format)``"

#: library/datetime.rst:2404
msgid "``strptime(date_string, format)``"
msgstr "``strptime(date_string, format)``"

#: library/datetime.rst:2411
#, fuzzy
msgid ""
":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Format Codes"
msgstr "Codes de formatage de :meth:`strftime` et :meth:`strptime`"

#: library/datetime.rst:2413
msgid ""
"These methods accept format codes that can be used to parse and format "
"dates::"
msgstr ""
"Ces méthodes acceptent des codes de formatage qui peuvent être utilisés pour "
"analyser et formater les dates ::"

#: library/datetime.rst:2415
msgid ""
">>> datetime.strptime('31/01/22 23:59:59.999999',\n"
"...                   '%d/%m/%y %H:%M:%S.%f')\n"
"datetime.datetime(2022, 1, 31, 23, 59, 59, 999999)\n"
">>> _.strftime('%a %d %b %Y, %I:%M%p')\n"
"'Mon 31 Jan 2022, 11:59PM'"
msgstr ""

#: library/datetime.rst:2421
msgid ""
"The following is a list of all the format codes that the 1989 C standard "
"requires, and these work on all platforms with a standard C implementation."
msgstr ""
"Voici la liste de tous les codes de formatage requis par le C standard 1989, "
"et ils fonctionnent sur toutes les plateformes possédant une implémentation "
"de C standard."

#: library/datetime.rst:2528
msgid "Directive"
msgstr "Directive"

#: library/datetime.rst:2528
msgid "Meaning"
msgstr "Signification"

#: library/datetime.rst:2528
msgid "Example"
msgstr "Exemple"

#: library/datetime.rst:2528
msgid "Notes"
msgstr "Notes"

#: library/datetime.rst:2427
msgid "``%a``"
msgstr "``%a``"

#: library/datetime.rst:2427
msgid "Weekday as locale's abbreviated name."
msgstr "Jour de la semaine abrégé dans la langue locale."

#: library/datetime.rst:0
msgid "Sun, Mon, ..., Sat (en_US);"
msgstr "Sun, Mon, ..., Sat (en_US);"

#: library/datetime.rst:0
msgid "So, Mo, ..., Sa (de_DE)"
msgstr "Lu, Ma, ..., Di (*fr_FR*)"

#: library/datetime.rst:2432
msgid "``%A``"
msgstr "``%A``"

#: library/datetime.rst:2432
msgid "Weekday as locale's full name."
msgstr "Jour de la semaine complet dans la langue locale."

#: library/datetime.rst:0
msgid "Sunday, Monday, ..., Saturday (en_US);"
msgstr "*Sunday*, *Monday*, ..., *Saturday* (*en_US*);"

#: library/datetime.rst:0
msgid "Sonntag, Montag, ..., Samstag (de_DE)"
msgstr "Lundi, Mardi, ..., Dimanche (*fr_FR*)"

#: library/datetime.rst:2437
msgid "``%w``"
msgstr "``%w``"

#: library/datetime.rst:2437
msgid "Weekday as a decimal number, where 0 is Sunday and 6 is Saturday."
msgstr ""
"Jour de la semaine en chiffre, avec 0 pour le dimanche et 6 pour le samedi."

#: library/datetime.rst:2437
msgid "0, 1, ..., 6"
msgstr "0, 1, ..., 6"

#: library/datetime.rst:2441
msgid "``%d``"
msgstr "``%d``"

#: library/datetime.rst:2441
msgid "Day of the month as a zero-padded decimal number."
msgstr "Jour du mois sur deux chiffres."

#: library/datetime.rst:2441
msgid "01, 02, ..., 31"
msgstr "01, 02, ..., 31"

#: library/datetime.rst:2454 library/datetime.rst:2463
#: library/datetime.rst:2472 library/datetime.rst:2490
msgid "\\(9)"
msgstr "\\(9)"

#: library/datetime.rst:2444
msgid "``%b``"
msgstr "``%b``"

#: library/datetime.rst:2444
msgid "Month as locale's abbreviated name."
msgstr "Nom du mois abrégé dans la langue locale."

#: library/datetime.rst:0
msgid "Jan, Feb, ..., Dec (en_US);"
msgstr "Jan, Feb, ..., Dec (*en_US*);"

#: library/datetime.rst:0
msgid "Jan, Feb, ..., Dez (de_DE)"
msgstr "janv., févr., ..., déc. (*fr_FR*)"

#: library/datetime.rst:2449
msgid "``%B``"
msgstr "``%B``"

#: library/datetime.rst:2449
msgid "Month as locale's full name."
msgstr "Nom complet du mois dans la langue locale."

#: library/datetime.rst:0
msgid "January, February, ..., December (en_US);"
msgstr "*January*, *February*, ..., *December* (*en_US*);"

#: library/datetime.rst:0
msgid "Januar, Februar, ..., Dezember (de_DE)"
msgstr "janvier, février, ..., décembre (*fr_FR*)"

#: library/datetime.rst:2454
msgid "``%m``"
msgstr "``%m``"

#: library/datetime.rst:2454
msgid "Month as a zero-padded decimal number."
msgstr "Numéro du mois sur deux chiffres."

#: library/datetime.rst:2466
msgid "01, 02, ..., 12"
msgstr "01, 02, ..., 12"

#: library/datetime.rst:2457
msgid "``%y``"
msgstr "``%y``"

#: library/datetime.rst:2457
msgid "Year without century as a zero-padded decimal number."
msgstr "Année sur deux chiffres (sans le siècle)."

#: library/datetime.rst:2457
msgid "00, 01, ..., 99"
msgstr "00, 01, ..., 99"

#: library/datetime.rst:2460
msgid "``%Y``"
msgstr "``%Y``"

#: library/datetime.rst:2460
msgid "Year with century as a decimal number."
msgstr "Année complète sur quatre chiffres."

#: library/datetime.rst:2530
msgid "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"
msgstr "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"

#: library/datetime.rst:2463
msgid "``%H``"
msgstr "``%H``"

#: library/datetime.rst:2463
msgid "Hour (24-hour clock) as a zero-padded decimal number."
msgstr "Heure à deux chiffres de 00 à 23."

#: library/datetime.rst:2463
msgid "00, 01, ..., 23"
msgstr "00, 01, ..., 23"

#: library/datetime.rst:2466
msgid "``%I``"
msgstr "``%I``"

#: library/datetime.rst:2466
msgid "Hour (12-hour clock) as a zero-padded decimal number."
msgstr "Heure à deux chiffres pour les horloges 12h (01 à 12)."

#: library/datetime.rst:2469
msgid "``%p``"
msgstr "``%p``"

#: library/datetime.rst:2469
msgid "Locale's equivalent of either AM or PM."
msgstr "Équivalent local à AM/PM."

#: library/datetime.rst:0
msgid "AM, PM (en_US);"
msgstr "AM, PM (en_US);"

#: library/datetime.rst:0
msgid "am, pm (de_DE)"
msgstr "am, pm (de_DE)"

#: library/datetime.rst:2469
msgid "\\(1), \\(3)"
msgstr "\\(1), \\(3)"

#: library/datetime.rst:2472
msgid "``%M``"
msgstr "``%M``"

#: library/datetime.rst:2472
msgid "Minute as a zero-padded decimal number."
msgstr "Minutes sur deux chiffres."

#: library/datetime.rst:2475
msgid "00, 01, ..., 59"
msgstr "00, 01, ..., 59"

#: library/datetime.rst:2475
msgid "``%S``"
msgstr "``%S``"

#: library/datetime.rst:2475
msgid "Second as a zero-padded decimal number."
msgstr "Secondes sur deux chiffres."

#: library/datetime.rst:2475
msgid "\\(4), \\(9)"
msgstr "\\(4), \\(9)"

#: library/datetime.rst:2478
msgid "``%f``"
msgstr "``%f``"

#: library/datetime.rst:2478
msgid "Microsecond as a decimal number, zero-padded to 6 digits."
msgstr "Microsecondes sur 6 chiffres."

#: library/datetime.rst:2478
msgid "000000, 000001, ..., 999999"
msgstr "000000, 000001, ..., 999999"

#: library/datetime.rst:2478
msgid "\\(5)"
msgstr "\\(5)"

#: library/datetime.rst:2641
msgid "``%z``"
msgstr "``%z``"

#: library/datetime.rst:2482
msgid ""
"UTC offset in the form ``±HHMM[SS[.ffffff]]`` (empty string if the object is "
"naive)."
msgstr ""
"Décalage horaire UTC sous la forme ``±HHMM[SS[.ffffff]]`` (chaîne vide si "
"l'instance est naïve)."

#: library/datetime.rst:2482
msgid "(empty), +0000, -0400, +1030, +063415, -030712.345216"
msgstr "(vide), +0000, -0400, +1030, +063415, -030712.345216"

#: library/datetime.rst:2487 library/datetime.rst:2544
msgid "\\(6)"
msgstr "\\(6)"

#: library/datetime.rst:2667
msgid "``%Z``"
msgstr "``%Z``"

#: library/datetime.rst:2487
msgid "Time zone name (empty string if the object is naive)."
msgstr "Nom du fuseau horaire (chaîne vide si l'instance est naïve)."

#: library/datetime.rst:2487
msgid "(empty), UTC, GMT"
msgstr "(vide), UTC, GMT"

#: library/datetime.rst:2490
msgid "``%j``"
msgstr "``%j``"

#: library/datetime.rst:2490
msgid "Day of the year as a zero-padded decimal number."
msgstr "Numéro du jour dans l'année sur trois chiffres."

#: library/datetime.rst:2490
msgid "001, 002, ..., 366"
msgstr "001, 002, ..., 366"

#: library/datetime.rst:2493
msgid "``%U``"
msgstr "``%U``"

#: library/datetime.rst:2493
msgid ""
"Week number of the year (Sunday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Sunday are "
"considered to be in week 0."
msgstr ""
"Numéro de la semaine à deux chiffres (où dimanche est considéré comme le "
"premier jour de la semaine). Tous les jours de l'année précédent le premier "
"dimanche sont considérés comme appartenant à la semaine 0."

#: library/datetime.rst:2501
msgid "00, 01, ..., 53"
msgstr "00, 01, ..., 53"

#: library/datetime.rst:2501
msgid "\\(7), \\(9)"
msgstr "\\(7), \\(9)"

#: library/datetime.rst:2501
msgid "``%W``"
msgstr "``%W``"

#: library/datetime.rst:2501
msgid ""
"Week number of the year (Monday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Monday are "
"considered to be in week 0."
msgstr ""
"Numéro de la semaine à deux chiffres (où lundi est considéré comme le "
"premier jour de la semaine). Tous les jours de l'année précédent le premier "
"lundi sont considérés comme appartenant à la semaine 0."

#: library/datetime.rst:2509
msgid "``%c``"
msgstr "``%c``"

#: library/datetime.rst:2509
msgid "Locale's appropriate date and time representation."
msgstr "Représentation locale de la date et de l'heure."

#: library/datetime.rst:0
msgid "Tue Aug 16 21:30:00 1988 (en_US);"
msgstr "Tue Aug 16 21:30:00 1988 (*en_US*);"

#: library/datetime.rst:0
msgid "Di 16 Aug 21:30:00 1988 (de_DE)"
msgstr "mar. 16 août 1988 21:30:00 (*fr_FR*)"

#: library/datetime.rst:2514
msgid "``%x``"
msgstr "``%x``"

#: library/datetime.rst:2514
msgid "Locale's appropriate date representation."
msgstr "Représentation locale de la date."

#: library/datetime.rst:0
msgid "08/16/88 (None);"
msgstr "08/16/88 (None);"

#: library/datetime.rst:0
msgid "08/16/1988 (en_US);"
msgstr "08/16/1988 (*en_US*);"

#: library/datetime.rst:0
msgid "16.08.1988 (de_DE)"
msgstr "16/08/1988 (*fr_FR*)"

#: library/datetime.rst:2518
msgid "``%X``"
msgstr "``%X``"

#: library/datetime.rst:2518
msgid "Locale's appropriate time representation."
msgstr "Représentation locale de l'heure."

#: library/datetime.rst:0
msgid "21:30:00 (en_US);"
msgstr "21:30:00 (*en_US*) ;"

#: library/datetime.rst:0
msgid "21:30:00 (de_DE)"
msgstr "21:30:00 (*fr_FR*)"

#: library/datetime.rst:2521
msgid "``%%``"
msgstr "``%%``"

#: library/datetime.rst:2521
msgid "A literal ``'%'`` character."
msgstr "Un caractère ``'%'`` littéral."

#: library/datetime.rst:2521
msgid "%"
msgstr "%"

#: library/datetime.rst:2524
msgid ""
"Several additional directives not required by the C89 standard are included "
"for convenience. These parameters all correspond to ISO 8601 date values."
msgstr ""
"Plusieurs directives supplémentaires non requises par la norme C89 sont "
"incluses pour des raisons de commodité. Ces paramètres correspondent tous "
"aux valeurs de date de la norme ISO 8601."

#: library/datetime.rst:2530
msgid "``%G``"
msgstr "``%G``"

#: library/datetime.rst:2530
msgid ""
"ISO 8601 year with century representing the year that contains the greater "
"part of the ISO week (``%V``)."
msgstr ""
"Année complète ISO 8601 représentant l'année contenant la plus grande partie "
"de la semaine ISO (``%V``)."

#: library/datetime.rst:2530
msgid "\\(8)"
msgstr "\\(8)"

#: library/datetime.rst:2535
msgid "``%u``"
msgstr "``%u``"

#: library/datetime.rst:2535
msgid "ISO 8601 weekday as a decimal number where 1 is Monday."
msgstr "Jour de la semaine ISO 8601 où 1 correspond au lundi."

#: library/datetime.rst:2535
msgid "1, 2, ..., 7"
msgstr "1, 2, ..., 7"

#: library/datetime.rst:2538
msgid "``%V``"
msgstr "``%V``"

#: library/datetime.rst:2538
msgid ""
"ISO 8601 week as a decimal number with Monday as the first day of the week. "
"Week 01 is the week containing Jan 4."
msgstr ""
"Numéro de la semaine ISO 8601, avec lundi étant le premier jour de la "
"semaine. La semaine 01 est la semaine contenant le 4 janvier."

#: library/datetime.rst:2538
msgid "01, 02, ..., 53"
msgstr "01, 02, ..., 53"

#: library/datetime.rst:2538
msgid "\\(8), \\(9)"
msgstr "\\(8), \\(9)"

#: library/datetime.rst:2663
msgid "``%:z``"
msgstr ""

#: library/datetime.rst:2544
#, fuzzy
msgid ""
"UTC offset in the form ``±HH:MM[:SS[.ffffff]]`` (empty string if the object "
"is naive)."
msgstr ""
"Décalage horaire UTC sous la forme ``±HHMM[SS[.ffffff]]`` (chaîne vide si "
"l'instance est naïve)."

#: library/datetime.rst:2544
#, fuzzy
msgid "(empty), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216"
msgstr "(vide), +0000, -0400, +1030, +063415, -030712.345216"

#: library/datetime.rst:2550
#, fuzzy
msgid ""
"These may not be available on all platforms when used with the :meth:`~."
"datetime.strftime` method. The ISO 8601 year and ISO 8601 week directives "
"are not interchangeable with the year and week number directives above. "
"Calling :meth:`~.datetime.strptime` with incomplete or ambiguous ISO 8601 "
"directives will raise a :exc:`ValueError`."
msgstr ""
"Elles peuvent ne pas être disponibles sur toutes les plateformes quand elles "
"sont utilisées avec la méthode :meth:`strftime`. Les directives ISO 8601 "
"d'année et de semaine ne sont pas interchangeables avec les directives "
"d'année et de semaine précédentes. Appeler :meth:`strptime` avec des "
"directives ISO 8601 incomplètes ou ambiguës lèvera une :exc:`ValueError`."

#: library/datetime.rst:2555
#, fuzzy
msgid ""
"The full set of format codes supported varies across platforms, because "
"Python calls the platform C library's :c:func:`strftime` function, and "
"platform variations are common. To see the full set of format codes "
"supported on your platform, consult the :manpage:`strftime(3)` "
"documentation. There are also differences between platforms in handling of "
"unsupported format specifiers."
msgstr ""
"L'ensemble complet des codes de formatage implémentés varie selon les "
"plateformes, parce que Python appelle la fonction :func:`strftime` de la "
"bibliothèque C de la plateforme, et les variations sont courantes. Pour voir "
"un ensemble complet des codes de formatage implémentés par votre plateforme, "
"consultez la documentation de :manpage:`strftime(3)`. Il existe également "
"des différences entre les plateformes dans la gestion de format non pris en "
"charge."

#: library/datetime.rst:2561
msgid "``%G``, ``%u`` and ``%V`` were added."
msgstr "``%G``, ``%u`` et ``%V`` ont été ajoutés."

#: library/datetime.rst:2564
msgid "``%:z`` was added."
msgstr ""

#: library/datetime.rst:2568
msgid "Technical Detail"
msgstr "Détail technique"

#: library/datetime.rst:2570
#, fuzzy
msgid ""
"Broadly speaking, ``d.strftime(fmt)`` acts like the :mod:`time` module's "
"``time.strftime(fmt, d.timetuple())`` although not all objects support a :"
"meth:`~date.timetuple` method."
msgstr ""
"Grossièrement, ``d.strftime(fmt)`` se comporte comme la fonction ``time."
"strftime(fmt, d.timetuple())`` du module :mod:`time`, bien que tous les "
"objets ne comportent pas de méthode :meth:`timetuple`."

#: library/datetime.rst:2574
#, fuzzy
msgid ""
"For the :meth:`.datetime.strptime` class method, the default value is "
"``1900-01-01T00:00:00.000``: any components not specified in the format "
"string will be pulled from the default value. [#]_"
msgstr ""
"Pour la méthode :meth:`datetime.strptime`, la valeur par défaut est "
"``1900-01-01T00:00:00.000`` : tous les composants non spécifiés dans la "
"chaîne de formatage seront retirés de la valeur par défaut. [#]_"

#: library/datetime.rst:2578
msgid "Using ``datetime.strptime(date_string, format)`` is equivalent to::"
msgstr ""
"L'utilisation de ``datetime.strptime(date_string, format)`` équivaut à ::"

#: library/datetime.rst:2582
#, fuzzy
msgid ""
"except when the format includes sub-second components or time zone offset "
"information, which are supported in ``datetime.strptime`` but are discarded "
"by ``time.strptime``."
msgstr ""
"sauf lorsque le format inclut des composantes de sous-secondes ou des "
"informations de décalage de fuseau horaire, qui sont prises en charge dans "
"``datetime.strptime`` mais pas par ``time.strptime``."

#: library/datetime.rst:2586
#, fuzzy
msgid ""
"For :class:`.time` objects, the format codes for year, month, and day should "
"not be used, as :class:`!time` objects have no such values. If they're used "
"anyway, 1900 is substituted for the year, and 1 for the month and day."
msgstr ""
"Pour les objets :class:`.time`, les codes de formatage pour l'année, le mois "
"et le jour ne devraient pas être utilisés, puisque les objets :class:`time` "
"ne possèdent pas de telles valeurs. S'ils sont tout de même utilisés, "
"``1900`` est utilisé pour l'année, et ``1`` pour le mois et le jour."

#: library/datetime.rst:2590
#, fuzzy
msgid ""
"For :class:`date` objects, the format codes for hours, minutes, seconds, and "
"microseconds should not be used, as :class:`date` objects have no such "
"values. If they're used anyway, 0 is substituted for them."
msgstr ""
"Pour les objets :class:`date`, les codes de formatage pour les heures, "
"minutes, secondes et microsecondes ne devraient pas être utilisés, puisque "
"les objets :class:`date` ne possèdent pas de telles valeurs. S'ils sont tout "
"de même utilisés, la valeur ``0`` est utilisée."

#: library/datetime.rst:2594
msgid ""
"For the same reason, handling of format strings containing Unicode code "
"points that can't be represented in the charset of the current locale is "
"also platform-dependent. On some platforms such code points are preserved "
"intact in the output, while on others ``strftime`` may raise :exc:"
"`UnicodeError` or return an empty string instead."
msgstr ""
"Pour la même raison, la gestion des chaînes contenant des caractères (ou "
"points) Unicode qui ne peuvent pas être représentés dans la *locale* "
"actuelle dépend aussi de la plateforme. Sur certaines plateformes, ces "
"caractères sont conservés tels quels dans la sortie, alors que sur d'autres "
"plateformes ``strftime`` lève une :exc:`UnicodeError` ou renvoie une chaîne "
"vide."

#: library/datetime.rst:2603
msgid ""
"Because the format depends on the current locale, care should be taken when "
"making assumptions about the output value. Field orderings will vary (for "
"example, \"month/day/year\" versus \"day/month/year\"), and the output may "
"contain non-ASCII characters."
msgstr ""
"Comme le format dépend de la locale courante, les assomptions sur la valeur "
"de retour doivent être prises soigneusement. L'ordre des champs variera (par "
"exemple, « mois/jour/année » au lieu de « année/mois/jour »), et le résultat "
"peut contenir des caractères non-ASCII."

#: library/datetime.rst:2609
#, fuzzy
msgid ""
"The :meth:`~.datetime.strptime` method can parse years in the full [1, 9999] "
"range, but years < 1000 must be zero-filled to 4-digit width."
msgstr ""
"La méthode :meth:`strptime` peut analyser toutes les années de l'intervalle "
"[1, 9999], mais toutes les années < 1000 doivent être représentées sur "
"quatre chiffres."

#: library/datetime.rst:2612
#, fuzzy
msgid ""
"In previous versions, :meth:`~.datetime.strftime` method was restricted to "
"years >= 1900."
msgstr ""
"Dans les versions précédentes, la méthode :meth:`strftime` était limitée aux "
"années >= 1900."

#: library/datetime.rst:2616
#, fuzzy
msgid ""
"In version 3.2, :meth:`~.datetime.strftime` method was restricted to years "
">= 1000."
msgstr ""
"En version 3.2, la méthode :meth:`strftime` était limitée aux années >= 1000."

#: library/datetime.rst:2621
#, fuzzy
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%p`` directive "
"only affects the output hour field if the ``%I`` directive is used to parse "
"the hour."
msgstr ""
"Quand utilisée avec la méthode :meth:`strptime`, la directive ``%p`` "
"n'affecte l'heure extraite que si la directive ``%I`` est utilisée pour "
"analyser l'heure."

#: library/datetime.rst:2625
#, fuzzy
msgid ""
"Unlike the :mod:`time` module, the :mod:`!datetime` module does not support "
"leap seconds."
msgstr ""
"À l'inverse du module :mod:`time`, le module :mod:`datetime` ne gère pas les "
"secondes intercalaires."

#: library/datetime.rst:2629
#, fuzzy
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%f`` directive "
"accepts from one to six digits and zero pads on the right. ``%f`` is an "
"extension to the set of format characters in the C standard (but implemented "
"separately in datetime objects, and therefore always available)."
msgstr ""
"Quand elle est utilisée avec la méthode :meth:`strptime`, la directive "
"``%f`` accepte un nombre de 1 à 6 chiffres, où des zéros seront ajoutés à "
"droite. ``%f`` est une extension de l'ensemble des caractères de formatage "
"du standard C (mais implémentée séparément dans les objets *datetime*, la "
"rendant ainsi toujours disponible)."

#: library/datetime.rst:2636
#, fuzzy
msgid ""
"For a naive object, the ``%z``, ``%:z`` and ``%Z`` format codes are replaced "
"by empty strings."
msgstr ""
"Pour les objets naïfs, les codes de formatage ``%z`` et ``%Z`` sont "
"remplacés par des chaînes vides."

#: library/datetime.rst:2639
msgid "For an aware object:"
msgstr "Pour un objet avisé :"

#: library/datetime.rst:2642
#, fuzzy
msgid ""
":meth:`~.datetime.utcoffset` is transformed into a string of the form "
"``±HHMM[SS[.ffffff]]``, where ``HH`` is a 2-digit string giving the number "
"of UTC offset hours, ``MM`` is a 2-digit string giving the number of UTC "
"offset minutes, ``SS`` is a 2-digit string giving the number of UTC offset "
"seconds and ``ffffff`` is a 6-digit string giving the number of UTC offset "
"microseconds. The ``ffffff`` part is omitted when the offset is a whole "
"number of seconds and both the ``ffffff`` and the ``SS`` part is omitted "
"when the offset is a whole number of minutes. For example, if :meth:`~."
"datetime.utcoffset` returns ``timedelta(hours=-3, minutes=-30)``, ``%z`` is "
"replaced with the string ``'-0330'``."
msgstr ""
"Le résultat de :meth:`utcoffset` est transformé en une chaîne sous la forme "
"``±HHMM[SS[.ffffff]]``, où ``HH`` est une chaîne de deux chiffres donnant le "
"nombre d'heures du décalage UTC, ``MM`` une chaîne de deux chiffres donnant "
"le nombre de minutes du décalage UTC, ``SS`` une chaîne de deux chiffres "
"donnant le nombre de secondes du décalage UTC et ``ffffff`` une chaîne de "
"six chiffres donnant le nombre en microsecondes du décalage UTC. La partie "
"``ffffff`` est omise lorsque le décalage est un nombre entier de secondes et "
"les parties ``ffffff`` et ``SS`` sont omises lorsque le décalage est un "
"nombre entier de minutes. Par exemple, si :meth:`utcoffset` renvoie "
"``timedelta(hours=-3, minutes=-30)``, ``%z`` est remplacé par la chaîne "
"``'-0330'``."

#: library/datetime.rst:2656
#, fuzzy
msgid ""
"When the ``%z`` directive is provided to the  :meth:`~.datetime.strptime` "
"method, the UTC offsets can have a colon as a separator between hours, "
"minutes and seconds. For example, ``'+01:00:00'`` will be parsed as an "
"offset of one hour. In addition, providing ``'Z'`` is identical to "
"``'+00:00'``."
msgstr ""
"Quand la directive ``%z`` est soumise à la méthode :meth:`strptime`, le "
"décalage UTC peut avoir une colonne comme séparateur entre les heures, "
"minutes et secondes. Par exemple, ``'+01:00:00'``, est analysé comme un "
"décalage d'une heure. Par ailleurs, ``'Z'`` est identique à ``'+00:00'``."

#: library/datetime.rst:2664
msgid ""
"Behaves exactly as ``%z``, but has a colon separator added between hours, "
"minutes and seconds."
msgstr ""

#: library/datetime.rst:2668
#, fuzzy
msgid ""
"In :meth:`~.datetime.strftime`, ``%Z`` is replaced by an empty string if :"
"meth:`~.datetime.tzname` returns ``None``; otherwise ``%Z`` is replaced by "
"the returned value, which must be a string."
msgstr ""
"Si :meth:`tzname` renvoie ``None``, ``%Z`` est remplacé par une chaîne vide "
"dans :meth:`strftime`. Autrement ``%Z`` est remplacé par la valeur renvoyée, "
"qui doit être une chaîne."

#: library/datetime.rst:2672
#, fuzzy
msgid ":meth:`~.datetime.strptime` only accepts certain values for ``%Z``:"
msgstr ":meth:`strptime` accepte seulement certaines valeurs pour ``%Z`` :"

#: library/datetime.rst:2674
msgid "any value in ``time.tzname`` for your machine's locale"
msgstr "toute valeur dans ``time.tzname`` pour votre machine locale"

#: library/datetime.rst:2675
msgid "the hard-coded values ``UTC`` and ``GMT``"
msgstr "les valeurs ``UTC`` et ``GMT`` codés en dur"

#: library/datetime.rst:2677
msgid ""
"So someone living in Japan may have ``JST``, ``UTC``, and ``GMT`` as valid "
"values, but probably not ``EST``. It will raise ``ValueError`` for invalid "
"values."
msgstr ""
"Ainsi, quelqu'un qui vit au Japon peut avoir comme valeurs valides ``JST``, "
"``UTC`` et ``GMT``, mais probablement pas ``EST``. Les valeurs invalides "
"lèvent ``ValueError``."

#: library/datetime.rst:2681
#, fuzzy
msgid ""
"When the ``%z`` directive is provided to the :meth:`~.datetime.strptime` "
"method, an aware :class:`.datetime` object will be produced. The ``tzinfo`` "
"of the result will be set to a :class:`timezone` instance."
msgstr ""
"Quand la directive ``%z`` est fournie à la méthode :meth:`strptime`, un "
"objet :class:`.datetime` avisé est construit. L'attribut ``tzinfo`` du "
"résultat aura pour valeur une instance de :class:`timezone`."

#: library/datetime.rst:2687
#, fuzzy
msgid ""
"When used with the :meth:`~.datetime.strptime` method, ``%U`` and ``%W`` are "
"only used in calculations when the day of the week and the calendar year "
"(``%Y``) are specified."
msgstr ""
"Quand ces directives sont utilisées avec la méthode :meth:`strptime`, ``%U`` "
"et ``%W`` ne sont utilisées dans les calculs que si le jour de la semaine et "
"l'année calendaire (``%Y``) sont spécifiés."

#: library/datetime.rst:2692
#, fuzzy
msgid ""
"Similar to ``%U`` and ``%W``, ``%V`` is only used in calculations when the "
"day of the week and the ISO year (``%G``) are specified in a :meth:`~."
"datetime.strptime` format string. Also note that ``%G`` and ``%Y`` are not "
"interchangeable."
msgstr ""
"De façon similaire à ``%U`` et ``%W``, ``%v`` n'est utilisé dans les calculs "
"que lorsque le jour de la semaine et l'année ISO (``%G``) sont spécifiés "
"dans la chaîne de formatage :meth:`strptime`. Notez aussi que ``%G`` et "
"``%Y`` ne sont pas interchangeables."

#: library/datetime.rst:2698
#, fuzzy
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the leading zero is "
"optional for  formats ``%d``, ``%m``, ``%H``, ``%I``, ``%M``, ``%S``, "
"``%j``, ``%U``, ``%W``, and ``%V``. Format ``%y`` does require a leading "
"zero."
msgstr ""
"Quand cette directive est utilisée avec la méthode :meth:`strptime`, le zéro "
"d'entête est optionnel pour les formats ``%d``, ``%m``, ``%H``, ``%I``, "
"``%M``, ``%S``, ``%j``, ``%U``, ``%W`` et ``%V``. Le format ``%y`` requiert "
"un zéro en entête."

#: library/datetime.rst:2703
msgid ""
"When parsing a month and day using :meth:`~.datetime.strptime`, always "
"include a year in the format.  If the value you need to parse lacks a year, "
"append an explicit dummy leap year.  Otherwise your code will raise an "
"exception when it encounters leap day because the default year used by the "
"parser is not a leap year.  Users run into this bug every four years..."
msgstr ""

#: library/datetime.rst:2709
msgid ""
">>> month_day = \"02/29\"\n"
">>> datetime.strptime(f\"{month_day};1984\", \"%m/%d;%Y\")  # No leap year "
"bug.\n"
"datetime.datetime(1984, 2, 29, 0, 0)"
msgstr ""

#: library/datetime.rst:2715
msgid ""
":meth:`~.datetime.strptime` calls using a format string containing a day of "
"month without a year now emit a :exc:`DeprecationWarning`. In 3.15 or later "
"we may change this into an error or change the default year to a leap year. "
"See :gh:`70647`."
msgstr ""

#: library/datetime.rst:2722
msgid "Footnotes"
msgstr "Notes"

#: library/datetime.rst:2723
msgid "If, that is, we ignore the effects of Relativity"
msgstr "Si on ignore les effets de la Relativité"

#: library/datetime.rst:2725
msgid ""
"This matches the definition of the \"proleptic Gregorian\" calendar in "
"Dershowitz and Reingold's book *Calendrical Calculations*, where it's the "
"base calendar for all computations. See the book for algorithms for "
"converting between proleptic Gregorian ordinals and many other calendar "
"systems."
msgstr ""
"Cela correspond à la définition du calendrier « grégorien proleptique » dans "
"le livre *Calendrical Calculations* de Dershowitz et Reingold, où il est la "
"base de tous les calculs. Référez-vous au livre pour les algorithmes de "
"conversion entre calendriers grégorien proleptique et les autres systèmes."

#: library/datetime.rst:2731
msgid ""
"See R. H. van Gent's `guide to the mathematics of the ISO 8601 calendar "
"<https://web.archive.org/web/20220531051136/https://webspace.science.uu.nl/"
"~gent0113/calendar/isocalendar.htm>`_ for a good explanation."
msgstr ""
"Voir R. H. van Gent `guide des mathématiques du calendrier ISO 8601 <https://"
"web.archive.org/web/20220531051136/https://webspace.science.uu.nl/~gent0113/"
"calendar/isocalendar.htm>`_ pour une bonne explication."

#: library/datetime.rst:2735
#, fuzzy
msgid ""
"Passing ``datetime.strptime('Feb 29', '%b %d')`` will fail since 1900 is not "
"a leap year."
msgstr ""
"Passer ``datetime.strptime(‘Feb 29’, ‘%b %d’)`` ne marchera pas car ``1900`` "
"n’est pas une année bissextile."

#: library/datetime.rst:2376
msgid "% (percent)"
msgstr "% (pourcentage)"

#: library/datetime.rst:2376
msgid "datetime format"
msgstr "Format de date et d'heure"

#~ msgid "Attribute"
#~ msgstr "Attribut"

#~ msgid "Value"
#~ msgstr "Valeur"

#~ msgid "``days``"
#~ msgstr "``days``"

#~ msgid "``seconds``"
#~ msgstr "``seconds``"

#~ msgid "``microseconds``"
#~ msgstr "``microseconds``"

#~ msgid ""
#~ "The comparisons ``==`` or ``!=`` *always* return a :class:`bool`, no "
#~ "matter the type of the compared object::"
#~ msgstr ""
#~ "Les comparaisons ``==`` ou ``!=`` renvoient *toujours* un :class:`bool`, "
#~ "quel que soit le type de l'objet comparé ::"

#~ msgid ""
#~ "For all other comparisons (such as ``<`` and ``>``), when a :class:"
#~ "`timedelta` object is compared to an object of a different type, :exc:"
#~ "`TypeError` is raised::"
#~ msgstr ""
#~ "Pour toutes les autres comparaisons (telles que ``<`` et ``>``), "
#~ "lorsqu'un objet :class:`timedelta` est comparé à un objet d'un type "
#~ "différent, une :exc:`TypeError` est levée ::"

#~ msgid ""
#~ "Return a :class:`date` corresponding to a *date_string* given in any "
#~ "valid ISO 8601 format, except ordinal dates (e.g. ``YYYY-DDD``)::"
#~ msgstr ""
#~ "Renvoie une :class:`date` correspondant à *date_string* dans un format "
#~ "ISO 8601 valide, à part les dates ordinales (ex: ``YYYY-DDD``) ::"

#~ msgid ""
#~ "In other words, ``date1 < date2`` if and only if ``date1.toordinal() < "
#~ "date2.toordinal()``. Date comparison raises :exc:`TypeError` if the other "
#~ "comparand isn't also a :class:`date` object. However, ``NotImplemented`` "
#~ "is returned instead if the other comparand has a :meth:`timetuple` "
#~ "attribute. This hook gives other kinds of date objects a chance at "
#~ "implementing mixed-type comparison. If not, when a :class:`date` object "
#~ "is compared to an object of a different type, :exc:`TypeError` is raised "
#~ "unless the comparison is ``==`` or ``!=``. The latter cases return :const:"
#~ "`False` or :const:`True`, respectively."
#~ msgstr ""
#~ "En d'autres termes, ``date1 < date2`` si et seulement si ``date1."
#~ "toordinal() < date2.toordinal()``. La comparaison de dates lève une :exc:"
#~ "`TypeError` si l'autre opérande n'est pas un objet :class:`date`. "
#~ "Cependant, ``NotImplemented`` est renvoyé à la place si l'autre opérande "
#~ "a un attribut :meth:`timetuple`. Cela permet à d'autres types d'objets "
#~ "dates d'avoir une chance d'implémenter une comparaison entre types "
#~ "différents. Sinon, quand un objet :class:`date` est comparé à un objet "
#~ "d'un type différent, une :exc:`TypeError` est levée à moins que la "
#~ "comparaison soit ``==`` ou ``!=``. Ces derniers cas renvoient "
#~ "respectivement :const:`False` et :const:`True`."

#~ msgid "Compares :class:`.datetime` to :class:`.datetime`. (4)"
#~ msgstr "Compare :class:`.datetime` à :class:`.datetime`. (4)"

#~ msgid ""
#~ "If one comparand is naive and the other is aware, :exc:`TypeError` is "
#~ "raised if an order comparison is attempted. For equality comparisons, "
#~ "naive instances are never equal to aware instances."
#~ msgstr ""
#~ "Si un opérande est naïf et l'autre avisé, une :exc:`TypeError` est levée "
#~ "si une comparaison d'ordre est attendue.  Pour les comparaisons "
#~ "d'égalité, les instances naïves ne sont jamais égales aux instances "
#~ "avisées."

#~ msgid ""
#~ "In order to stop comparison from falling back to the default scheme of "
#~ "comparing object addresses, datetime comparison normally raises :exc:"
#~ "`TypeError` if the other comparand isn't also a :class:`.datetime` "
#~ "object. However, ``NotImplemented`` is returned instead if the other "
#~ "comparand has a :meth:`timetuple` attribute. This hook gives other kinds "
#~ "of date objects a chance at implementing mixed-type comparison. If not, "
#~ "when a :class:`.datetime` object is compared to an object of a different "
#~ "type, :exc:`TypeError` is raised unless the comparison is ``==`` or ``!"
#~ "=``. The latter cases return :const:`False` or :const:`True`, "
#~ "respectively."
#~ msgstr ""
#~ "Afin d'empêcher la comparaison de retomber sur le schéma par défaut de "
#~ "comparaison des adresses des objets, la comparaison *datetime* lève "
#~ "normalement une exception :exc:`TypeError` si l'autre opérande n'est pas "
#~ "aussi un objet :class:`.datetime`.  Cependant, ``NotImplemented`` est "
#~ "renvoyé à la place si l'autre opérande a un attribut :meth:`timetuple`.  "
#~ "Cela permet à d'autres types d'objets dates d'implémenter la comparaison "
#~ "entre types mixtes.  Sinon, quand un objet :class:`.datetime` est comparé "
#~ "à un objet d'un type différent, une exception :exc:`TypeError` est levée "
#~ "à moins que la comparaison soit ``==`` ou ``!=``.  Ces derniers cas "
#~ "renvoient respectivement :const:`False` et :const:`True`."

#~ msgid "Examples of working with :class:`~datetime.datetime` objects:"
#~ msgstr "Exemples d'utilisation des objets :class:`~datetime.datetime` :"

#~ msgid ""
#~ ":class:`.time` objects support comparison of :class:`.time` to :class:`."
#~ "time`, where *a* is considered less than *b* when *a* precedes *b* in "
#~ "time. If one comparand is naive and the other is aware, :exc:`TypeError` "
#~ "is raised if an order comparison is attempted. For equality comparisons, "
#~ "naive instances are never equal to aware instances."
#~ msgstr ""
#~ "Les objets :class:`.time` gèrent la comparaison d'un :class:`.time` avec "
#~ "un autre :class:`.time`, où *a* est considéré inférieur à *b* s'il le "
#~ "précède dans le temps.  Si un opérande est naïf et l'autre avisé, et "
#~ "qu'une relation d'ordre est attendue, une :exc:`TypeError` est levée. "
#~ "Pour les égalités, les instances naïves ne sont jamais égales aux "
#~ "instances avisées."

#~ msgid ""
#~ "If both comparands are aware, and have the same :attr:`~time.tzinfo` "
#~ "attribute, the common :attr:`~time.tzinfo` attribute is ignored and the "
#~ "base times are compared. If both comparands are aware and have different :"
#~ "attr:`~time.tzinfo` attributes, the comparands are first adjusted by "
#~ "subtracting their UTC offsets (obtained from ``self.utcoffset()``). In "
#~ "order to stop mixed-type comparisons from falling back to the default "
#~ "comparison by object address, when a :class:`.time` object is compared to "
#~ "an object of a different type, :exc:`TypeError` is raised unless the "
#~ "comparison is ``==`` or ``!=``. The latter cases return :const:`False` "
#~ "or :const:`True`, respectively."
#~ msgstr ""
#~ "Si les deux opérandes sont avisés, et ont le même attribut :attr:`~time."
#~ "tzinfo`, l'attribut commun :attr:`~time.tzinfo` est ignoré et les temps "
#~ "de base sont comparés.  Si les deux opérandes sont avisés et ont des "
#~ "attributs :attr:`~time.tzinfo` différents, ils sont d'abord ajustés en "
#~ "leur soustrayant leurs décalages UTC (obtenus à l'aide de ``self."
#~ "utcoffset()``). Afin d'empêcher les comparaisons de types mixtes de "
#~ "retomber sur la comparaison par défaut par l'adresse de l'objet, quand un "
#~ "objet :class:`.time` est comparé à un objet de type différent, une :exc:"
#~ "`TypeError` est levée à moins que la comparaison soit ``==`` ou ``!=``.  "
#~ "Ces derniers cas renvoient respectivement :const:`False` et :const:`True`."

#~ msgid ""
#~ "Equality comparisons between aware and naive :class:`~datetime.time` "
#~ "instances don't raise :exc:`TypeError`."
#~ msgstr ""
#~ "Les comparaisons d'égalité entre instances de :class:`~datetime.time` "
#~ "naïves et avisées ne lèvent pas de :exc:`TypeError`."

#~ msgid "This is equivalent to::"
#~ msgstr "C’est équivalent à ::"

#~ msgid "This is the inverse of :meth:`date.fromisoformat`."
#~ msgstr "C'est la réciproque de :meth:`date.fromisoformat`."

#~ msgid "Specifically, this function supports strings in the format:"
#~ msgstr ""
#~ "Plus précisément, cette fonction prend en charge les chaînes de "
#~ "caractères dans le format :"

#~ msgid ""
#~ "This does *not* support parsing arbitrary ISO 8601 strings - it is only "
#~ "intended as the inverse operation of :meth:`datetime.isoformat`. A more "
#~ "full-featured ISO 8601 parser, ``dateutil.parser.isoparse`` is available "
#~ "in the third-party package `dateutil <https://dateutil.readthedocs.io/en/"
#~ "stable/parser.html#dateutil.parser.isoparse>`__."
#~ msgstr ""
#~ "Ceci ne prend pas en charge l'analyse arbitraire des chaînes de "
#~ "caractères ISO 8601 - il est uniquement destiné à l'opération réciproque "
#~ "de :meth:`datetime.isoformat`. Un analyseur ISO 8601 plus complet, "
#~ "``dateutil.parser.isoparse`` est disponible dans le paquet tiers "
#~ "`dateutil <https://dateutil.readthedocs.io/en/stable/parser.html#dateutil."
#~ "parser.isoparse>`__."

#, fuzzy
#~ msgid ""
#~ "Return a :class:`.time` corresponding to a *time_string* in one of the "
#~ "formats emitted by :meth:`time.isoformat`. Specifically, this function "
#~ "supports strings in the format:"
#~ msgstr ""
#~ "Renvoie une :class:`date` correspondant à *date_string* dans le format "
#~ "émis par :meth:`date.isoformat`. Spécifiquement, cette fonction gère des "
#~ "chaînes dans le(s) format(s) ``YYYY-MM-DD`` :"

#, fuzzy
#~ msgid ""
#~ "This does *not* support parsing arbitrary ISO 8601 strings. It is only "
#~ "intended as the inverse operation of :meth:`time.isoformat`."
#~ msgstr ""
#~ "Ceci ne gère pas l'analyse arbitraire de chaînes ISO 8601, ceci est "
#~ "seulement destiné à l'opération inverse de :meth:`time.isoformat`."

#~ msgid ""
#~ "Week number of the year (Monday as the first day of the week) as a "
#~ "decimal number. All days in a new year preceding the first Monday are "
#~ "considered to be in week 0."
#~ msgstr ""
#~ "Numéro de la semaine à deux chiffres (où lundi est considéré comme le "
#~ "premier jour de la semaine). Tous les jours de l'année précédent le "
#~ "premier lundi sont considérés comme appartenant à la semaine 0."

#~ msgid "`dateutil.tz <https://dateutil.readthedocs.io/en/stable/tz.html>`_"
#~ msgstr "`dateutil.tz <https://dateutil.readthedocs.io/en/stable/tz.html>`_"

#~ msgid "Return a 3-tuple, (ISO year, ISO week number, ISO weekday)."
#~ msgstr ""
#~ "Renvoie un *n*-uplet de 3 éléments, (année ISO, numéro de semaine ISO, "
#~ "jour de la semaine ISO)."
