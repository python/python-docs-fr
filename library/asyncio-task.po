# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-18 15:46+0200\n"
"PO-Revision-Date: 2020-09-22 17:11+0200\n"
"Last-Translator: Philippe GALVAN <git.philippe.galvan@outlook.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.1\n"

#: library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Coroutines et tâches"

#: library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"Cette section donne un aperçu des API de haut-niveau du module *asyncio* "
"pour utiliser les coroutines et les tâches."

#: library/asyncio-task.rst:121
msgid "Coroutines"
msgstr "Coroutines"

#: library/asyncio-task.rst:21
#, fuzzy
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
"Les :term:`coroutines <coroutine>` déclarées avec la syntaxe *async/await* "
"sont la manière privilégiée d’écrire des applications *asyncio*. Par "
"exemple, l’extrait de code suivant (requiert Python 3.7+) affiche « hello », "
"attend 1 seconde et affiche ensuite « world » ::"

#: library/asyncio-task.rst:37
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr "Appeler une coroutine ne la planifie pas pour exécution ::"

#: library/asyncio-task.rst:43
msgid "To actually run a coroutine, asyncio provides three main mechanisms:"
msgstr ""
"Pour réellement exécuter une coroutine, *asyncio* fournit trois mécanismes "
"principaux :"

#: library/asyncio-task.rst:45
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"La fonction :func:`asyncio.run` pour exécuter la fonction « main() », le "
"point d'entrée de haut-niveau (voir l'exemple ci-dessus)."

#: library/asyncio-task.rst:48
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Attendre une coroutine. Le morceau de code suivant attend une seconde, "
"affiche « hello », attend 2 secondes *supplémentaires*, puis affiche enfin "
"« world » ::"

#: library/asyncio-task.rst:69
msgid "Expected output::"
msgstr "Sortie attendue ::"

#: library/asyncio-task.rst:76
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"La fonction :func:`asyncio.create_task` pour exécuter de manière concurrente "
"des coroutines en tant que :class:`tâches <Task>` *asyncio*."

#: library/asyncio-task.rst:79
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Modifions l'exemple ci-dessus et lançons deux coroutines ``say_after`` *de "
"manière concurrente* ::"

#: library/asyncio-task.rst:98
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"La sortie attendue montre à présent que ce code s'exécute une seconde plus "
"rapidement que le précédent ::"

#: library/asyncio-task.rst:110
msgid "Awaitables"
msgstr "*Attendables*"

#: library/asyncio-task.rst:112
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Un objet est dit *attendable* (*awaitable* en anglais, c.-à-d. qui peut être "
"attendu) s'il peut être utilisé dans une expression :keyword:`await`. "
"Beaucoup d'API d'*asyncio* sont conçues pour accepter des *attendables*."

#: library/asyncio-task.rst:116
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Il existe trois types principaux d'*attendables* : les **coroutines**, les "
"**tâches** et les **futurs**."

#: library/asyncio-task.rst:122
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Les coroutines sont des *awaitables* et peuvent donc être attendues par "
"d'autres coroutines ::"

#: library/asyncio-task.rst:143
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"Dans cette documentation, le terme « coroutine » est utilisé pour désigner "
"deux concepts voisins :"

#: library/asyncio-task.rst:146
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "une *fonction coroutine* : une fonction :keyword:`async def` ;"

#: library/asyncio-task.rst:148
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr "un *objet coroutine* : un objet renvoyé par une *fonction coroutine*."

#: library/asyncio-task.rst:151
msgid ""
"asyncio also supports legacy :ref:`generator-based "
"<asyncio_generator_based_coro>` coroutines."
msgstr ""
"*asyncio* implémente également les coroutines :ref:`basées sur des "
"générateurs <asyncio_generator_based_coro>` ; celles-ci sont obsolètes."

#: library/asyncio-task.rst:156
msgid "Tasks"
msgstr "Tâches"

#: library/asyncio-task.rst:157
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr ""
"Les *tâches* servent à planifier des coroutines de façon à ce qu'elles "
"s'exécutent de manière concurrente."

#: library/asyncio-task.rst:159
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"Lorsqu'une coroutine est encapsulée dans une *tâche* à l'aide de fonctions "
"comme :func:`asyncio.create_task`, la coroutine est automatiquement "
"planifiée pour s'exécuter prochainement ::"

#: library/asyncio-task.rst:181
msgid "Futures"
msgstr "Futurs"

#: library/asyncio-task.rst:182
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
"Un :class:`Future` est un objet *awaitable* spécial de **bas-niveau**, qui "
"représente le **résultat final** d'une opération asynchrone."

#: library/asyncio-task.rst:185
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Quand un objet *Future* est *attendu*, cela signifie que la coroutine "
"attendra que ce futur soit résolu à un autre endroit."

#: library/asyncio-task.rst:188
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Les objets *Future* d'*asyncio* sont nécessaires pour permettre l'exécution "
"de code basé sur les fonctions de rappel avec la syntaxe *async* / *await*."

#: library/asyncio-task.rst:191
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Il est normalement **inutile** de créer des objets *Future* dans la couche "
"applicative du code."

#: library/asyncio-task.rst:194
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Les objets *Future*, parfois exposés par des bibliothèques et quelques API "
"d'*asyncio*, peuvent être attendus ::"

#: library/asyncio-task.rst:206
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
":meth:`loop.run_in_executor` est l'exemple typique d'une fonction bas-niveau "
"renvoyant un objet *Future*."

#: library/asyncio-task.rst:211
msgid "Running an asyncio Program"
msgstr "Exécution d'un programme *asyncio*"

#: library/asyncio-task.rst:215
msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr "Exécute la :term:`coroutine` *coro* et renvoie le résultat."

#: library/asyncio-task.rst:217
#, fuzzy
msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio "
"event loop, *finalizing asynchronous generators*, and closing the threadpool."
msgstr ""
"Cette fonction exécute la coroutine passée en argument. Elle gère la boucle "
"d'événements *asyncio* et *finalise les générateurs asynchrones*."

#: library/asyncio-task.rst:221
msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""
"Cette fonction ne peut pas être appelée si une autre boucle d'événement "
"*asyncio* s'exécute dans le même fil d'exécution."

#: library/asyncio-task.rst:224
msgid "If *debug* is ``True``, the event loop will be run in debug mode."
msgstr ""
"Si *debug* vaut ``True``, la boucle d'événement s'exécute en mode de "
"débogage."

#: library/asyncio-task.rst:226
msgid ""
"This function always creates a new event loop and closes it at the end.  It "
"should be used as a main entry point for asyncio programs, and should "
"ideally only be called once."
msgstr ""
"Cette fonction crée toujours une nouvelle boucle d'événement et la clôt à la "
"fin. Elle doit être utilisée comme point d'entrée principal des programmes "
"*asyncio* et ne doit être idéalement appelée qu'une seule fois."

#: library/asyncio-task.rst:374 library/asyncio-task.rst:652
msgid "Example::"
msgstr "Exemple ::"

#: library/asyncio-task.rst:240
msgid "Updated to use :meth:`loop.shutdown_default_executor`."
msgstr ""

#: library/asyncio-task.rst:244
msgid ""
"The source code for ``asyncio.run()`` can be found in :source:`Lib/asyncio/"
"runners.py`."
msgstr ""
"Le code source pour ``asyncio.run()`` est disponible dans :source:`Lib/"
"asyncio/runners.py`."

#: library/asyncio-task.rst:248
msgid "Creating Tasks"
msgstr "Création de tâches"

#: library/asyncio-task.rst:252
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Encapsule la :ref:`coroutine <coroutine>` *coro* dans une tâche et la "
"planifie pour exécution. Renvoie l'objet :class:`Task`."

#: library/asyncio-task.rst:255
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""
"Si *name* n’est pas ``None``, il est défini comme le nom de la tâche en "
"utilisant :meth:`Task.set_name`."

#: library/asyncio-task.rst:258
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"La tâche est exécutée dans la boucle renvoyée par :func:"
"`get_running_loop` ; :exc:`RuntimeError` est levée s'il n'y a pas de boucle "
"en cours d'exécution dans le fil actuel."

#: library/asyncio-task.rst:264
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""

#: library/asyncio-task.rst:841
#, fuzzy
msgid "Added the *name* parameter."
msgstr "ajout du paramètre ``name``."

#: library/asyncio-task.rst:291
msgid "Sleeping"
msgstr "Attente"

#: library/asyncio-task.rst:295
msgid "Block for *delay* seconds."
msgstr "Attend pendant *delay* secondes."

#: library/asyncio-task.rst:297
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Si *result* est spécifié, il est renvoyé à l'appelant quand la coroutine se "
"termine."

#: library/asyncio-task.rst:300
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` suspend systématiquement la tâche courante, ce qui permet aux "
"autres tâches de s'exécuter."

#: library/asyncio-task.rst:303
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""

#: library/asyncio-task.rst:312
msgid ""
"The ``loop`` parameter.  This function has been implicitly getting the "
"current running loop since 3.7.  See :ref:`What's New in 3.10's Removed "
"section <whatsnew310-removed>` for more information."
msgstr ""

#: library/asyncio-task.rst:315
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Exemple d'une coroutine affichant la date toutes les secondes pendant 5 "
"secondes ::"

#: library/asyncio-task.rst:369 library/asyncio-task.rst:477
#: library/asyncio-task.rst:541 library/asyncio-task.rst:635
#: library/asyncio-task.rst:658
#, fuzzy
msgid "Removed the *loop* parameter."
msgstr "Le paramètre *loop*."

#: library/asyncio-task.rst:338
msgid "Running Tasks Concurrently"
msgstr "Exécution de tâches de manière concurrente"

#: library/asyncio-task.rst:342
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Exécute les objets :ref:`awaitable <asyncio-awaitables>` de la séquence "
"*aws*, *de manière concurrente*."

#: library/asyncio-task.rst:345
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Si un *attendable* de *aws* est une coroutine, celui-ci est automatiquement "
"planifié comme une tâche *Task*."

#: library/asyncio-task.rst:348
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Si tous les *awaitables* s'achèvent avec succès, le résultat est la liste "
"des valeurs renvoyées. L'ordre de cette liste correspond à l'ordre des "
"*awaitables* dans *aws*."

#: library/asyncio-task.rst:352
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Si *return_exceptions* vaut ``False`` (valeur par défaut), la première "
"exception levée est immédiatement propagée vers la tâche en attente dans le "
"``gather()``. Les autres *attendables* dans la séquence *aws* **ne sont pas "
"annulés** et poursuivent leur exécution."

#: library/asyncio-task.rst:357
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Si *return_exceptions* vaut ``True``, les exceptions sont traitées de la "
"même manière que les exécutions normales, et incluses dans la liste des "
"résultats."

#: library/asyncio-task.rst:360
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Si ``gather()`` est *annulé*, tous les *awaitables* en cours (ceux qui n'ont "
"pas encore fini de s'exécuter) sont également *annulés*."

#: library/asyncio-task.rst:363
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Si n'importe quel *Task* ou *Future* de la séquence *aws* est *annulé*, il "
"est traité comme s'il avait levé :exc:`CancelledError` — l'appel à "
"``gather()`` n'est alors **pas** annulé. Ceci permet d'empêcher que "
"l'annulation d'une tâche ou d'un futur entraîne l'annulation des autres "
"tâches ou futurs."

#: library/asyncio-task.rst:412
msgid ""
"If *return_exceptions* is False, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""

#: library/asyncio-task.rst:419
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Si *gather* est lui-même annulé, l'annulation est propagée indépendamment de "
"*return_exceptions*."

#: library/asyncio-task.rst:426
msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr ""

#: library/asyncio-task.rst:433
msgid "Shielding From Cancellation"
msgstr "Protection contre l'annulation"

#: library/asyncio-task.rst:437
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Empêche qu'un objet :ref:`awaitable <asyncio-awaitables>` puisse être :meth:"
"`annulé <Task.cancel>`."

#: library/asyncio-task.rst:493
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr ""
"Si *aw* est une coroutine, elle est planifiée automatiquement comme une "
"tâche."

#: library/asyncio-task.rst:442
msgid "The statement::"
msgstr "L'instruction ::"

#: library/asyncio-task.rst:447
msgid "is equivalent to::"
msgstr "est équivalente à ::"

#: library/asyncio-task.rst:451
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*à la différence près* que, si la coroutine qui la contient est annulée, la "
"tâche s'exécutant dans ``something()`` n'est pas annulée. Du point de vue de "
"``something()``, il n'y a pas eu d'annulation. Cependant, son appelant est "
"bien annulé, donc l'expression *await* lève bien une :exc:`CancelledError`."

#: library/asyncio-task.rst:457
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Si ``something()`` est annulée d'une autre façon (c.-à-d. depuis elle-même) "
"ceci annule également ``shield()``."

#: library/asyncio-task.rst:460
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Pour ignorer complètement l'annulation (déconseillé), la fonction "
"``shield()`` peut être combinée à une clause *try* / *except*, comme dans le "
"code ci-dessous ::"

#: library/asyncio-task.rst:472
msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""

#: library/asyncio-task.rst:480
msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr ""

#: library/asyncio-task.rst:486
msgid "Timeouts"
msgstr "Délais d'attente"

#: library/asyncio-task.rst:490
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Attend la fin de l':ref:`awaitable <asyncio-awaitables>` *aw* avec délai "
"d'attente."

#: library/asyncio-task.rst:495
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* peut-être soit ``None``, soit le nombre de secondes (entier ou "
"décimal) d'attente. Si *timeout* vaut ``None``, la fonction s'interrompt "
"jusqu'à ce que le futur s'achève."

#: library/asyncio-task.rst:499
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`asyncio."
"TimeoutError`."
msgstr ""
"Si le délai d'attente maximal est dépassé, la tâche est annulée et "
"l'exception :exc:`asyncio.TimeoutError` est levée."

#: library/asyncio-task.rst:502
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Pour empêcher :meth:`l'annulation <Task.cancel>` de la tâche, il est "
"nécessaire de l'encapsuler dans une fonction :func:`shield`."

#: library/asyncio-task.rst:505
#, fuzzy
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"Cette fonction attend que le futur soit réellement annulé, donc le temps "
"d'attente total peut être supérieur à *timeout*."

#: library/asyncio-task.rst:509
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Si l'attente est annulée, le futur *aw* est également annulé."

#: library/asyncio-task.rst:536
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`asyncio.TimeoutError` immediately."
msgstr ""
"Si le dépassement du délai d'attente maximal provoque l'annulation de *aw*, "
"``wait_for`` attend que *aw* soit annulée. Auparavant, l'exception :exc:"
"`asyncio.TimeoutError` était immédiatement levée."

#: library/asyncio-task.rst:546
msgid "Waiting Primitives"
msgstr "Primitives d'attente"

#: library/asyncio-task.rst:550
#, fuzzy
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently and block until the condition specified by *return_when*."
msgstr ""
"Exécute les objets :ref:`awaitables <asyncio-awaitables>` de l'ensemble "
"*aws* de manière concurrente, et s'interrompt jusqu'à ce que la condition "
"décrite dans *return_when* soit vraie."

#: library/asyncio-task.rst:554
msgid "The *aws* iterable must not be empty."
msgstr ""

#: library/asyncio-task.rst:556
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Renvoie deux ensembles de *Tasks* / *Futures* : ``(done, pending)``."

#: library/asyncio-task.rst:558
msgid "Usage::"
msgstr "Utilisation ::"

#: library/asyncio-task.rst:562
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (entier ou décimal), si précisé, peut-être utilisé pour contrôler "
"le nombre maximal de secondes d'attente avant de se terminer."

#: library/asyncio-task.rst:565
msgid ""
"Note that this function does not raise :exc:`asyncio.TimeoutError`. Futures "
"or Tasks that aren't done when the timeout occurs are simply returned in the "
"second set."
msgstr ""
"Cette fonction ne lève pas :exc:`asyncio.TimeoutError`. Les futurs et les "
"tâches qui ne sont pas finis quand le délai d'attente maximal est dépassé "
"sont tout simplement renvoyés dans le second ensemble."

#: library/asyncio-task.rst:569
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* indique quand la fonction doit se terminer. Il peut prendre "
"les valeurs suivantes :"

#: library/asyncio-task.rst:575
msgid "Constant"
msgstr "Constante"

#: library/asyncio-task.rst:575
msgid "Description"
msgstr "Description"

#: library/asyncio-task.rst:577
msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

#: library/asyncio-task.rst:577
msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"La fonction se termine lorsque n'importe quel futur se termine ou est annulé."

#: library/asyncio-task.rst:580
msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

#: library/asyncio-task.rst:580
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"La fonction se termine lorsque n'importe quel futur se termine en levant une "
"exception. Si aucun *futur* ne lève d'exception, équivaut à :const:"
"`ALL_COMPLETED`."

#: library/asyncio-task.rst:586
msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

#: library/asyncio-task.rst:586
msgid "The function will return when all futures finish or are cancelled."
msgstr ""
"La fonction se termine lorsque les *futurs* sont tous finis ou annulés."

#: library/asyncio-task.rst:590
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"À la différence de :func:`~asyncio.wait_for`, ``wait()`` n'annule pas les "
"futurs quand le délai d'attente est dépassé."

#: library/asyncio-task.rst:595
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task.  Passing coroutines objects to ``wait()`` directly is deprecated as it "
"leads to :ref:`confusing behavior <asyncio_example_wait_coroutine>`."
msgstr ""
"Si un *awaitable* de *aws* est une coroutine, celle-ci est automatiquement "
"planifiée comme une tâche. Passer directement des objets coroutines à "
"``wait()`` est obsolète, car ceci conduisait :ref:`à un comportement portant "
"à confusion <asyncio_example_wait_coroutine>`."

#: library/asyncio-task.rst:606
msgid ""
"``wait()`` schedules coroutines as Tasks automatically and later returns "
"those implicitly created Task objects in ``(done, pending)`` sets.  "
"Therefore the following code won't work as expected::"
msgstr ""
"``wait()`` planifie automatiquement les coroutines comme des tâches et "
"renvoie les objets *Task* ainsi créés dans les ensembles ``(done, "
"pending)``. Le code suivant ne fonctionne donc pas comme voulu ::"

#: library/asyncio-task.rst:619
msgid "Here is how the above snippet can be fixed::"
msgstr "Voici comment corriger le morceau de code ci-dessus ::"

#: library/asyncio-task.rst:632
msgid "Passing coroutine objects to ``wait()`` directly is deprecated."
msgstr "Passer directement des objets coroutines à ``wait()`` est obsolète."

#: library/asyncio-task.rst:641
#, fuzzy
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently.  Return an iterator of coroutines. Each coroutine returned can "
"be awaited to get the earliest next result from the iterable of the "
"remaining awaitables."
msgstr ""
"Exécute les objets :ref:`awaitables <asyncio-awaitables>` de l'ensemble "
"*aws* de manière concurrente. Renvoie un itérateur sur des objets :class:"
"`Future`. Chaque objet *futur* renvoyé représente le résultat le plus récent "
"de l'ensemble des *awaitables* restants."

#: library/asyncio-task.rst:646
msgid ""
"Raises :exc:`asyncio.TimeoutError` if the timeout occurs before all Futures "
"are done."
msgstr ""
"Lève une exception :exc:`asyncio.TimeoutError` si le délai d'attente est "
"dépassé avant que tous les futurs ne soient achevés."

#: library/asyncio-task.rst:661
msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr ""

#: library/asyncio-task.rst:667
msgid "Running in Threads"
msgstr ""

#: library/asyncio-task.rst:671
msgid "Asynchronously run function *func* in a separate thread."
msgstr ""

#: library/asyncio-task.rst:673
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""

#: library/asyncio-task.rst:678
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr ""

#: library/asyncio-task.rst:680
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were ran in the main thread. For example::"
msgstr ""

#: library/asyncio-task.rst:710
msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""

#: library/asyncio-task.rst:717
msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""

#: library/asyncio-task.rst:726
msgid "Scheduling From Other Threads"
msgstr "Planification depuis d'autres fils d'exécution"

#: library/asyncio-task.rst:730
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr ""
"Enregistre une coroutine dans la boucle d'exécution actuelle. Cette "
"opération est compatible avec les programmes à multiples fils d'exécution "
"(*thread-safe*)."

#: library/asyncio-task.rst:732
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Renvoie un :class:`concurrent.futures.Future` pour attendre le résultat d'un "
"autre fil d'exécution du système d'exploitation."

#: library/asyncio-task.rst:735
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Cette fonction est faite pour être appelée par un fil d'exécution distinct "
"de celui dans laquelle la boucle d'événement s'exécute. Exemple ::"

#: library/asyncio-task.rst:747
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Si une exception est levée dans une coroutine, le futur renvoyé en sera "
"averti. Elle peut également être utilisée pour annuler la tâche de la boucle "
"d'événement ::"

#: library/asyncio-task.rst:761
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Voir la section :ref:`exécution concurrente et multi-fils d'exécution "
"<asyncio-multithreading>` de la documentation."

#: library/asyncio-task.rst:764
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"À la différence des autres fonctions d'*asyncio*, cette fonction requiert "
"que *loop* soit passé de manière explicite."

#: library/asyncio-task.rst:771
msgid "Introspection"
msgstr "Introspection"

#: library/asyncio-task.rst:776
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Renvoie l'instance de la :class:`Task` en cours d'exécution, ou ``None`` "
"s'il n'y a pas de tâche en cours."

#: library/asyncio-task.rst:779
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Si *loop* vaut ``None``, :func:`get_running_loop` est appelée pour récupérer "
"la boucle en cours d'exécution."

#: library/asyncio-task.rst:787
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Renvoie l'ensemble des :class:`Task` non terminés en cours d'exécution dans "
"la boucle."

#: library/asyncio-task.rst:790
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Si *loop* vaut ``None``, :func:`get_running_loop` est appelée pour récupérer "
"la boucle en cours d'exécution."

#: library/asyncio-task.rst:797
msgid "Task Object"
msgstr "Objets *Task*"

#: library/asyncio-task.rst:801
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Objet compatible avec :class:`Future <Future>` qui exécute une :ref:"
"`coroutine <coroutine>` Python. Cet objet n'est pas utilisable dans des "
"programmes à fils d'exécution multiples."

#: library/asyncio-task.rst:804
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Les tâches servent à exécuter des coroutines dans des boucles d'événements. "
"Si une coroutine attend un futur, la tâche interrompt son exécution et "
"attend la fin de ce *futur*. Quand celui-ci est terminé, l'exécution de la "
"coroutine encapsulée reprend."

#: library/asyncio-task.rst:810
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Les boucles d'événement fonctionnent de manière *coopérative* : une boucle "
"d'événement exécute une tâche à la fois. Quand une tâche attend la fin d'un "
"futur, la boucle d'événement exécute d'autres tâches, des fonctions de "
"rappel, ou effectue des opérations d'entrées-sorties."

#: library/asyncio-task.rst:815
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"La fonction de haut niveau :func:`asyncio.create_task` et les fonctions de "
"bas-niveau :meth:`loop.create_task` ou :func:`ensure_future` permettent de "
"créer des tâches. Il est déconseillé d'instancier manuellement des objets "
"*Task*."

#: library/asyncio-task.rst:820
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"La méthode :meth:`cancel` d'une tâche en cours d'exécution permet d'annuler "
"celle-ci. L'appel de cette méthode force la tâche à lever l'exception :exc:"
"`CancelledError` dans la coroutine encapsulée. Si la coroutine attendait un "
"*futur* au moment de l'annulation, celui-ci est annulé."

#: library/asyncio-task.rst:825
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
"La méthode :meth:`cancelled` permet de vérifier si la tâche a été annulée. "
"Elle renvoie ``True`` si la coroutine encapsulée n'a pas ignoré l'exception :"
"exc:`CancelledError` et a bien été annulée."

#: library/asyncio-task.rst:830
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` hérite de :class:`Future`, de toute son API, à "
"l'exception de :meth:`Future.set_result` et de :meth:`Future.set_exception`."

#: library/asyncio-task.rst:834
msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr ""
"*Task* implémente le module :mod:`contextvars`. Lors de sa création, une "
"tâche effectue une copie du contexte actuel et exécutera ses coroutines dans "
"cette copie."

#: library/asyncio-task.rst:838
msgid "Added support for the :mod:`contextvars` module."
msgstr "Ajout du support du module :mod:`contextvars`."

#: library/asyncio-task.rst:844
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""

#: library/asyncio-task.rst:850
msgid "Request the Task to be cancelled."
msgstr "Demande l'annulation d'une tâche."

#: library/asyncio-task.rst:852
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Provisionne la levée de l'exception :exc:`CancelledError` dans la coroutine "
"encapsulée. L'exception sera levée au prochain cycle de la boucle "
"d'exécution."

#: library/asyncio-task.rst:855
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged."
msgstr ""
"La coroutine peut alors faire le ménage ou même ignorer la requête en "
"supprimant l'exception à l'aide d'un bloc :keyword:`try` … … ``except "
"CancelledError`` … :keyword:`finally`. Par conséquent, contrairement à :meth:"
"`Future.cancel`, :meth:`Task.cancel` ne garantit pas que la tâche sera "
"annulée, bien qu'ignorer totalement une annulation ne soit ni une pratique "
"courante, ni encouragé."

#: library/asyncio-task.rst:863
#, fuzzy
msgid "Added the *msg* parameter."
msgstr "ajout du paramètre ``name``."

#: library/asyncio-task.rst:868
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"L'exemple ci-dessous illustre comment une coroutine peut intercepter une "
"requête d'annulation ::"

#: library/asyncio-task.rst:907
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Renvoie ``True`` si la tâche est *annulée*."

#: library/asyncio-task.rst:909
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"La tâche est *annulée* quand l'annulation a été demandée avec :meth:`cancel` "
"et la coroutine encapsulée a propagé l'exception :exc:`CancelledError` qui a "
"été levée en son sein."

#: library/asyncio-task.rst:915
msgid "Return ``True`` if the Task is *done*."
msgstr "Renvoie ``True`` si la tâche est *achevée*."

#: library/asyncio-task.rst:917
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Une tâche est dite *achevée* quand la coroutine encapsulée a soit renvoyé "
"une valeur, soit levé une exception, ou que la tâche a été annulée."

#: library/asyncio-task.rst:922
msgid "Return the result of the Task."
msgstr "Renvoie le résultat de la tâche."

#: library/asyncio-task.rst:924
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Si la tâche est *achevée*, le résultat de la coroutine encapsulée est "
"renvoyé (sinon, dans le cas où la coroutine a levé une exception, cette "
"exception est de nouveau levée)."

#: library/asyncio-task.rst:942
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Si la tâche a été *annulée*, cette méthode lève une exception :exc:"
"`CancelledError`."

#: library/asyncio-task.rst:931
msgid ""
"If the Task's result isn't yet available, this method raises a :exc:"
"`InvalidStateError` exception."
msgstr ""
"Si le résultat de la tâche n'est pas encore disponible, cette méthode lève "
"une exception :exc:`InvalidStateError`."

#: library/asyncio-task.rst:936
msgid "Return the exception of the Task."
msgstr "Renvoie l'exception de la tâche."

#: library/asyncio-task.rst:938
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Si la coroutine encapsulée lève une exception, cette exception est renvoyée. "
"Si la coroutine s'est exécutée normalement, cette méthode renvoie ``None``."

#: library/asyncio-task.rst:945
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Si la tâche n'est pas encore *achevée*, cette méthode lève une exception :"
"exc:`InvalidStateError`."

#: library/asyncio-task.rst:950
msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Ajoute une fonction de rappel qui sera exécutée quand la tâche sera "
"*achevée*."

#: library/asyncio-task.rst:961
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Cette méthode ne doit être utilisée que dans du code basé sur les fonctions "
"de rappel de bas-niveau."

#: library/asyncio-task.rst:954
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Se référer à la documentation de :meth:`Future.add_done_callback` pour plus "
"de détails."

#: library/asyncio-task.rst:959
msgid "Remove *callback* from the callbacks list."
msgstr "Retire *callback* de la liste de fonctions de rappel."

#: library/asyncio-task.rst:963
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Se référer à la documentation de :meth:`Future.remove_done_callback` pour "
"plus de détails."

#: library/asyncio-task.rst:968
msgid "Return the list of stack frames for this Task."
msgstr "Renvoie une liste représentant la pile d'appels de la tâche."

#: library/asyncio-task.rst:970
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Si la coroutine encapsulée n'est pas terminée, cette fonction renvoie la "
"pile d'appels à partir de l'endroit où celle-ci est interrompue. Si la "
"coroutine s'est terminée normalement ou a été annulée, cette fonction "
"renvoie une liste vide. Si la coroutine a été terminée par une exception, "
"ceci renvoie la pile d'erreurs."

#: library/asyncio-task.rst:976
msgid "The frames are always ordered from oldest to newest."
msgstr "La pile est toujours affichée de l'appelant à l'appelé."

#: library/asyncio-task.rst:978
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Une seule ligne est renvoyée si la coroutine est suspendue."

#: library/asyncio-task.rst:980
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"L'argument facultatif *limit* définit le nombre maximal d'appels à "
"renvoyer ; par défaut, tous sont renvoyés. L'ordre de la liste diffère selon "
"la nature de celle-ci : les appels les plus récents d'une pile d'appels sont "
"renvoyés, si la pile est une pile d'erreurs, ce sont les appels les plus "
"anciens qui le sont (dans un souci de cohérence avec le module *traceback*)."

#: library/asyncio-task.rst:989
msgid "Print the stack or traceback for this Task."
msgstr "Affiche la pile d'appels ou d'erreurs de la tâche."

#: library/asyncio-task.rst:991
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Le format de sortie des appels produits par :meth:`get_stack` est similaire "
"à celui du module *traceback*."

#: library/asyncio-task.rst:994
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "Le paramètre *limit* est directement passé à :meth:`get_stack`."

#: library/asyncio-task.rst:996
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stderr`."
msgstr ""
"Le paramètre *file* est un flux d'entrées-sorties sur lequel le résultat est "
"écrit ; par défaut, :data:`sys.stderr`."

#: library/asyncio-task.rst:1001
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Renvoie l’objet *coroutine* encapsulé par la :class:`Task`."

#: library/asyncio-task.rst:1007
msgid "Return the name of the Task."
msgstr "Renvoie le nom de la tâche."

#: library/asyncio-task.rst:1009
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Si aucun nom n’a été explicitement assigné à la tâche, l’implémentation par "
"défaut d’une *Task* *asyncio* génère un nom par défaut durant "
"l’instanciation."

#: library/asyncio-task.rst:1017
msgid "Set the name of the Task."
msgstr "Définit le nom de la tâche."

#: library/asyncio-task.rst:1019
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"L’argument *value* peut être n’importe quel objet qui sera ensuite converti "
"en chaine de caractères."

#: library/asyncio-task.rst:1022
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"Dans l’implémentation par défaut de *Task*, le nom sera visible dans le "
"résultat de :func:`repr` d’un objet *Task*."

#: library/asyncio-task.rst:1031
msgid "Generator-based Coroutines"
msgstr "Coroutines basées sur des générateurs"

#: library/asyncio-task.rst:1035
#, fuzzy
msgid ""
"Support for generator-based coroutines is **deprecated** and is removed in "
"Python 3.11."
msgstr ""
"Les coroutines basées sur des générateurs sont **obsolètes** et il est prévu "
"de les supprimer en Python 3.10."

#: library/asyncio-task.rst:1038
msgid ""
"Generator-based coroutines predate async/await syntax.  They are Python "
"generators that use ``yield from`` expressions to await on Futures and other "
"coroutines."
msgstr ""
"Les coroutines basées sur des générateurs sont antérieures à la syntaxe "
"*async* / *await*. Il existe des générateurs *Python* qui utilisent les "
"expressions ``yield from`` pour attendre des *futurs* et autres coroutines."

#: library/asyncio-task.rst:1042
msgid ""
"Generator-based coroutines should be decorated with :func:`@asyncio."
"coroutine <asyncio.coroutine>`, although this is not enforced."
msgstr ""
"Les coroutines basées sur des générateurs doivent être décorées avec :func:"
"`@asyncio.coroutine <asyncio.coroutine>`, même si ce n'est pas vérifié par "
"l'interpréteur."

#: library/asyncio-task.rst:1049
msgid "Decorator to mark generator-based coroutines."
msgstr "Décorateur pour coroutines basées sur des générateurs."

#: library/asyncio-task.rst:1051
msgid ""
"This decorator enables legacy generator-based coroutines to be compatible "
"with async/await code::"
msgstr ""
"Ce décorateur rend compatibles les coroutines basées sur des générateurs "
"avec le code *async* / *await* ::"

#: library/asyncio-task.rst:1061
msgid "This decorator should not be used for :keyword:`async def` coroutines."
msgstr ""
"Ce décorateur ne doit pas être utilisé avec des coroutines :keyword:`async "
"def`."

# pas de majuscule car suit un deux-points
#: library/asyncio-task.rst:1066
msgid "Use :keyword:`async def` instead."
msgstr "utilisez :keyword:`async def` à la place."

#: library/asyncio-task.rst:1070
msgid "Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`."
msgstr "Renvoie ``True`` si *obj* est un :ref:`objet coroutine <coroutine>`."

#: library/asyncio-task.rst:1072
msgid ""
"This method is different from :func:`inspect.iscoroutine` because it returns "
"``True`` for generator-based coroutines."
msgstr ""
"Cette méthode est différente de :func:`inspect.iscoroutine` car elle renvoie "
"``True`` pour des coroutines basées sur des générateurs."

#: library/asyncio-task.rst:1077
msgid "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
msgstr ""
"Renvoie ``True`` si *func* est une :ref:`fonction coroutine <coroutine>`."

#: library/asyncio-task.rst:1080
msgid ""
"This method is different from :func:`inspect.iscoroutinefunction` because it "
"returns ``True`` for generator-based coroutine functions decorated with :"
"func:`@coroutine <coroutine>`."
msgstr ""
"Cette méthode est différente de :func:`inspect.iscoroutinefunction` car elle "
"renvoie ``True`` pour des coroutines basées sur des générateurs, décorées "
"avec :func:`@coroutine <coroutine>`."

#~ msgid ""
#~ "This function has been **added in Python 3.7**.  Prior to Python 3.7, the "
#~ "low-level :func:`asyncio.ensure_future` function can be used instead::"
#~ msgstr ""
#~ "Cette fonction a été **ajoutée dans Python 3.7**. Pour les versions "
#~ "antérieures à la 3.7, la fonction de bas-niveau :func:`asyncio."
#~ "ensure_future` peut-être utilisée ::"
