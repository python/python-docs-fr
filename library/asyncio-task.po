# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-15 22:33+0100\n"
"PO-Revision-Date: 2020-09-22 17:11+0200\n"
"Last-Translator: Philippe GALVAN <git.philippe.galvan@outlook.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.1\n"

#: library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Coroutines et tâches"

#: library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"Cette section donne un aperçu des API de haut-niveau du module *asyncio* "
"pour utiliser les coroutines et les tâches."

#: library/asyncio-task.rst:148
msgid "Coroutines"
msgstr "Coroutines"

#: library/asyncio-task.rst:21
msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr ""

#: library/asyncio-task.rst:25
#, fuzzy
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
"Les :term:`coroutines <coroutine>` déclarées avec la syntaxe *async/await* "
"sont la manière privilégiée d’écrire des applications *asyncio*. Par "
"exemple, l’extrait de code suivant (requiert Python 3.7+) affiche « hello », "
"attend 1 seconde et affiche ensuite « world » ::"

#: library/asyncio-task.rst:41
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr "Appeler une coroutine ne la planifie pas pour exécution ::"

#: library/asyncio-task.rst:47
#, fuzzy
msgid "To actually run a coroutine, asyncio provides the following mechanisms:"
msgstr ""
"Pour réellement exécuter une coroutine, *asyncio* fournit trois mécanismes "
"principaux :"

#: library/asyncio-task.rst:49
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"La fonction :func:`asyncio.run` pour exécuter la fonction « main() », le "
"point d'entrée de haut-niveau (voir l'exemple ci-dessus)."

#: library/asyncio-task.rst:52
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Attendre une coroutine. Le morceau de code suivant attend une seconde, "
"affiche « hello », attend 2 secondes *supplémentaires*, puis affiche enfin "
"« world » ::"

#: library/asyncio-task.rst:73
msgid "Expected output::"
msgstr "Sortie attendue ::"

#: library/asyncio-task.rst:80
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"La fonction :func:`asyncio.create_task` pour exécuter de manière concurrente "
"des coroutines en tant que :class:`tâches <Task>` *asyncio*."

#: library/asyncio-task.rst:83
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Modifions l'exemple ci-dessus et lançons deux coroutines ``say_after`` *de "
"manière concurrente* ::"

#: library/asyncio-task.rst:102
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"La sortie attendue montre à présent que ce code s'exécute une seconde plus "
"rapidement que le précédent ::"

#: library/asyncio-task.rst:110
msgid ""
"The :class:`asyncio.TaskGroup` class provides a more modern alternative to :"
"func:`create_task`. Using this API, the last example becomes::"
msgstr ""

#: library/asyncio-task.rst:128
msgid "The timing and output should be the same as for the previous version."
msgstr ""

#: library/asyncio-task.rst:130
msgid ":class:`asyncio.TaskGroup`."
msgstr ""

#: library/asyncio-task.rst:137
msgid "Awaitables"
msgstr "*Attendables*"

#: library/asyncio-task.rst:139
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Un objet est dit *attendable* (*awaitable* en anglais, c.-à-d. qui peut être "
"attendu) s'il peut être utilisé dans une expression :keyword:`await`. "
"Beaucoup d'API d'*asyncio* sont conçues pour accepter des *attendables*."

#: library/asyncio-task.rst:143
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Il existe trois types principaux d'*attendables* : les **coroutines**, les "
"**tâches** et les **futurs**."

#: library/asyncio-task.rst:149
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Les coroutines sont des *awaitables* et peuvent donc être attendues par "
"d'autres coroutines ::"

#: library/asyncio-task.rst:170
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"Dans cette documentation, le terme « coroutine » est utilisé pour désigner "
"deux concepts voisins :"

#: library/asyncio-task.rst:173
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "une *fonction coroutine* : une fonction :keyword:`async def` ;"

#: library/asyncio-task.rst:175
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr "un *objet coroutine* : un objet renvoyé par une *fonction coroutine*."

#: library/asyncio-task.rst:180
msgid "Tasks"
msgstr "Tâches"

#: library/asyncio-task.rst:181
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr ""
"Les *tâches* servent à planifier des coroutines de façon à ce qu'elles "
"s'exécutent de manière concurrente."

#: library/asyncio-task.rst:183
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"Lorsqu'une coroutine est encapsulée dans une *tâche* à l'aide de fonctions "
"comme :func:`asyncio.create_task`, la coroutine est automatiquement "
"planifiée pour s'exécuter prochainement ::"

#: library/asyncio-task.rst:205
msgid "Futures"
msgstr "Futurs"

#: library/asyncio-task.rst:206
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
"Un :class:`Future` est un objet *awaitable* spécial de **bas-niveau**, qui "
"représente le **résultat final** d'une opération asynchrone."

#: library/asyncio-task.rst:209
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Quand un objet *Future* est *attendu*, cela signifie que la coroutine "
"attendra que ce futur soit résolu à un autre endroit."

#: library/asyncio-task.rst:212
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Les objets *Future* d'*asyncio* sont nécessaires pour permettre l'exécution "
"de code basé sur les fonctions de rappel avec la syntaxe *async* / *await*."

#: library/asyncio-task.rst:215
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Il est normalement **inutile** de créer des objets *Future* dans la couche "
"applicative du code."

#: library/asyncio-task.rst:218
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Les objets *Future*, parfois exposés par des bibliothèques et quelques API "
"d'*asyncio*, peuvent être attendus ::"

#: library/asyncio-task.rst:230
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
":meth:`loop.run_in_executor` est l'exemple typique d'une fonction bas-niveau "
"renvoyant un objet *Future*."

#: library/asyncio-task.rst:235
msgid "Creating Tasks"
msgstr "Création de tâches"

#: library/asyncio-task.rst:237
msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr ""

#: library/asyncio-task.rst:243
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Encapsule la :ref:`coroutine <coroutine>` *coro* dans une tâche et la "
"planifie pour exécution. Renvoie l'objet :class:`Task`."

#: library/asyncio-task.rst:246
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""
"Si *name* n’est pas ``None``, il est défini comme le nom de la tâche en "
"utilisant :meth:`Task.set_name`."

#: library/asyncio-task.rst:249
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""

#: library/asyncio-task.rst:253
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"La tâche est exécutée dans la boucle renvoyée par :func:"
"`get_running_loop` ; :exc:`RuntimeError` est levée s'il n'y a pas de boucle "
"en cours d'exécution dans le fil actuel."

#: library/asyncio-task.rst:259
msgid ""
":meth:`asyncio.TaskGroup.create_task` is a newer alternative that allows for "
"convenient waiting for a group of related tasks."
msgstr ""

#: library/asyncio-task.rst:264
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""

#: library/asyncio-task.rst:1009
#, fuzzy
msgid "Added the *name* parameter."
msgstr "ajout du paramètre ``name``."

#: library/asyncio-task.rst:289
#, fuzzy
msgid "Added the *context* parameter."
msgstr "ajout du paramètre ``name``."

#: library/asyncio-task.rst:294
msgid "Task Cancellation"
msgstr ""

#: library/asyncio-task.rst:296
msgid ""
"Tasks can easily and safely be cancelled. When a task is cancelled, :exc:"
"`asyncio.CancelledError` will be raised in the task at the next opportunity."
msgstr ""

#: library/asyncio-task.rst:300
msgid ""
"It is recommended that coroutines use ``try/finally`` blocks to robustly "
"perform clean-up logic. In case :exc:`asyncio.CancelledError` is explicitly "
"caught, it should generally be propagated when clean-up is complete. Most "
"code can safely ignore :exc:`asyncio.CancelledError`."
msgstr ""

#: library/asyncio-task.rst:305
msgid ""
"The asyncio components that enable structured concurrency, like :class:"
"`asyncio.TaskGroup` and :func:`asyncio.timeout`, are implemented using "
"cancellation internally and might misbehave if a coroutine swallows :exc:"
"`asyncio.CancelledError`. Similarly, user code should not call :meth:"
"`uncancel <asyncio.Task.uncancel>`."
msgstr ""

#: library/asyncio-task.rst:314
#, fuzzy
msgid "Task Groups"
msgstr "Tâches"

#: library/asyncio-task.rst:316
msgid ""
"Task groups combine a task creation API with a convenient and reliable way "
"to wait for all tasks in the group to finish."
msgstr ""

#: library/asyncio-task.rst:321
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` holding a "
"group of tasks. Tasks can be added to the group using :meth:`create_task`. "
"All tasks are awaited when the context manager exits."
msgstr ""

#: library/asyncio-task.rst:330
msgid ""
"Create a task in this task group. The signature matches that of :func:"
"`asyncio.create_task`."
msgstr ""

#: library/asyncio-task.rst:463 library/asyncio-task.rst:655
#: library/asyncio-task.rst:724 library/asyncio-task.rst:820
msgid "Example::"
msgstr "Exemple ::"

#: library/asyncio-task.rst:341
msgid ""
"The ``async with`` statement will wait for all tasks in the group to finish. "
"While waiting, new tasks may still be added to the group (for example, by "
"passing ``tg`` into one of the coroutines and calling ``tg.create_task()`` "
"in that coroutine). Once the last task has finished and the ``async with`` "
"block is exited, no new tasks may be added to the group."
msgstr ""

#: library/asyncio-task.rst:348
msgid ""
"The first time any of the tasks belonging to the group fails with an "
"exception other than :exc:`asyncio.CancelledError`, the remaining tasks in "
"the group are cancelled. No further tasks can then be added to the group. At "
"this point, if the body of the ``async with`` statement is still active (i."
"e., :meth:`~object.__aexit__` hasn't been called yet), the task directly "
"containing the ``async with`` statement is also cancelled. The resulting :"
"exc:`asyncio.CancelledError` will interrupt an ``await``, but it will not "
"bubble out of the containing ``async with`` statement."
msgstr ""

#: library/asyncio-task.rst:358
msgid ""
"Once all tasks have finished, if any tasks have failed with an exception "
"other than :exc:`asyncio.CancelledError`, those exceptions are combined in "
"an :exc:`ExceptionGroup` or :exc:`BaseExceptionGroup` (as appropriate; see "
"their documentation) which is then raised."
msgstr ""

#: library/asyncio-task.rst:365
msgid ""
"Two base exceptions are treated specially: If any task fails with :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit`, the task group still cancels the "
"remaining tasks and waits for them, but then the initial :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit` is re-raised instead of :exc:"
"`ExceptionGroup` or :exc:`BaseExceptionGroup`."
msgstr ""

#: library/asyncio-task.rst:371
msgid ""
"If the body of the ``async with`` statement exits with an exception (so :"
"meth:`~object.__aexit__` is called with an exception set), this is treated "
"the same as if one of the tasks failed: the remaining tasks are cancelled "
"and then waited for, and non-cancellation exceptions are grouped into an "
"exception group and raised. The exception passed into :meth:`~object."
"__aexit__`, unless it is :exc:`asyncio.CancelledError`, is also included in "
"the exception group. The same special case is made for :exc:"
"`KeyboardInterrupt` and :exc:`SystemExit` as in the previous paragraph."
msgstr ""

#: library/asyncio-task.rst:385
msgid "Sleeping"
msgstr "Attente"

#: library/asyncio-task.rst:389
msgid "Block for *delay* seconds."
msgstr "Attend pendant *delay* secondes."

#: library/asyncio-task.rst:391
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Si *result* est spécifié, il est renvoyé à l'appelant quand la coroutine se "
"termine."

#: library/asyncio-task.rst:394
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` suspend systématiquement la tâche courante, ce qui permet aux "
"autres tâches de s'exécuter."

#: library/asyncio-task.rst:397
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""

#: library/asyncio-task.rst:403
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Exemple d'une coroutine affichant la date toutes les secondes pendant 5 "
"secondes ::"

#: library/asyncio-task.rst:512 library/asyncio-task.rst:719
#: library/asyncio-task.rst:801 library/asyncio-task.rst:826
#, fuzzy
msgid "Removed the *loop* parameter."
msgstr "Le paramètre *loop*."

#: library/asyncio-task.rst:426
msgid "Running Tasks Concurrently"
msgstr "Exécution de tâches de manière concurrente"

#: library/asyncio-task.rst:430
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Exécute les objets :ref:`awaitable <asyncio-awaitables>` de la séquence "
"*aws*, *de manière concurrente*."

#: library/asyncio-task.rst:433
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Si un *attendable* de *aws* est une coroutine, celui-ci est automatiquement "
"planifié comme une tâche *Task*."

#: library/asyncio-task.rst:436
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Si tous les *awaitables* s'achèvent avec succès, le résultat est la liste "
"des valeurs renvoyées. L'ordre de cette liste correspond à l'ordre des "
"*awaitables* dans *aws*."

#: library/asyncio-task.rst:440
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Si *return_exceptions* vaut ``False`` (valeur par défaut), la première "
"exception levée est immédiatement propagée vers la tâche en attente dans le "
"``gather()``. Les autres *attendables* dans la séquence *aws* **ne sont pas "
"annulés** et poursuivent leur exécution."

#: library/asyncio-task.rst:445
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Si *return_exceptions* vaut ``True``, les exceptions sont traitées de la "
"même manière que les exécutions normales, et incluses dans la liste des "
"résultats."

#: library/asyncio-task.rst:448
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Si ``gather()`` est *annulé*, tous les *awaitables* en cours (ceux qui n'ont "
"pas encore fini de s'exécuter) sont également *annulés*."

#: library/asyncio-task.rst:451
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Si n'importe quel *Task* ou *Future* de la séquence *aws* est *annulé*, il "
"est traité comme s'il avait levé :exc:`CancelledError` — l'appel à "
"``gather()`` n'est alors **pas** annulé. Ceci permet d'empêcher que "
"l'annulation d'une tâche ou d'un futur entraîne l'annulation des autres "
"tâches ou futurs."

#: library/asyncio-task.rst:458
msgid ""
"A more modern way to create and run tasks concurrently and wait for their "
"completion is :class:`asyncio.TaskGroup`."
msgstr ""

#: library/asyncio-task.rst:501
msgid ""
"If *return_exceptions* is False, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""

#: library/asyncio-task.rst:508
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Si *gather* est lui-même annulé, l'annulation est propagée indépendamment de "
"*return_exceptions*."

#: library/asyncio-task.rst:515
msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr ""

#: library/asyncio-task.rst:522
msgid "Shielding From Cancellation"
msgstr "Protection contre l'annulation"

#: library/asyncio-task.rst:526
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Empêche qu'un objet :ref:`awaitable <asyncio-awaitables>` puisse être :meth:"
"`annulé <Task.cancel>`."

#: library/asyncio-task.rst:701
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr ""
"Si *aw* est une coroutine, elle est planifiée automatiquement comme une "
"tâche."

#: library/asyncio-task.rst:531
msgid "The statement::"
msgstr "L'instruction ::"

#: library/asyncio-task.rst:536
msgid "is equivalent to::"
msgstr "est équivalente à ::"

#: library/asyncio-task.rst:540
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*à la différence près* que, si la coroutine qui la contient est annulée, la "
"tâche s'exécutant dans ``something()`` n'est pas annulée. Du point de vue de "
"``something()``, il n'y a pas eu d'annulation. Cependant, son appelant est "
"bien annulé, donc l'expression *await* lève bien une :exc:`CancelledError`."

#: library/asyncio-task.rst:546
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Si ``something()`` est annulée d'une autre façon (c.-à-d. depuis elle-même) "
"ceci annule également ``shield()``."

#: library/asyncio-task.rst:549
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Pour ignorer complètement l'annulation (déconseillé), la fonction "
"``shield()`` peut être combinée à une clause *try* / *except*, comme dans le "
"code ci-dessous ::"

#: library/asyncio-task.rst:561
msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""

#: library/asyncio-task.rst:569
msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr ""

#: library/asyncio-task.rst:575
msgid "Timeouts"
msgstr "Délais d'attente"

#: library/asyncio-task.rst:579
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` that can be "
"used to limit the amount of time spent waiting on something."
msgstr ""

#: library/asyncio-task.rst:583
#, fuzzy
msgid ""
"*delay* can either be ``None``, or a float/int number of seconds to wait. If "
"*delay* is ``None``, no time limit will be applied; this can be useful if "
"the delay is unknown when the context manager is created."
msgstr ""
"*timeout* peut-être soit ``None``, soit le nombre de secondes (entier ou "
"décimal) d'attente. Si *timeout* vaut ``None``, la fonction s'interrompt "
"jusqu'à ce que le futur s'achève."

#: library/asyncio-task.rst:588
msgid ""
"In either case, the context manager can be rescheduled after creation using :"
"meth:`Timeout.reschedule`."
msgstr ""

#: library/asyncio-task.rst:597
msgid ""
"If ``long_running_task`` takes more than 10 seconds to complete, the context "
"manager will cancel the current task and handle the resulting :exc:`asyncio."
"CancelledError` internally, transforming it into an :exc:`asyncio."
"TimeoutError` which can be caught and handled."
msgstr ""

#: library/asyncio-task.rst:604
msgid ""
"The :func:`asyncio.timeout` context manager is what transforms the :exc:"
"`asyncio.CancelledError` into an :exc:`asyncio.TimeoutError`, which means "
"the :exc:`asyncio.TimeoutError` can only be caught *outside* of the context "
"manager."
msgstr ""

#: library/asyncio-task.rst:609
msgid "Example of catching :exc:`asyncio.TimeoutError`::"
msgstr ""

#: library/asyncio-task.rst:620
msgid ""
"The context manager produced by :func:`asyncio.timeout` can be rescheduled "
"to a different deadline and inspected."
msgstr ""

#: library/asyncio-task.rst:625
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` that limits "
"time spent inside of it."
msgstr ""

#: library/asyncio-task.rst:632
#, fuzzy
msgid ""
"Return the current deadline, or ``None`` if the current deadline is not set."
msgstr ""
"Renvoie l'instance de la :class:`Task` en cours d'exécution, ou ``None`` "
"s'il n'y a pas de tâche en cours."

#: library/asyncio-task.rst:635
msgid ""
"The deadline is a float, consistent with the time returned by :meth:`loop."
"time`."
msgstr ""

#: library/asyncio-task.rst:640
msgid "Change the time the timeout will trigger."
msgstr ""

#: library/asyncio-task.rst:642
msgid ""
"If *when* is ``None``, any current deadline will be removed, and the context "
"manager will wait indefinitely."
msgstr ""

#: library/asyncio-task.rst:645
msgid "If *when* is a float, it is set as the new deadline."
msgstr ""

#: library/asyncio-task.rst:647
msgid ""
"if *when* is in the past, the timeout will trigger on the next iteration of "
"the event loop."
msgstr ""

#: library/asyncio-task.rst:652
msgid "Return whether the context manager has exceeded its deadline (expired)."
msgstr ""

#: library/asyncio-task.rst:672
msgid "Timeout context managers can be safely nested."
msgstr ""

#: library/asyncio-task.rst:678
msgid ""
"Similar to :func:`asyncio.timeout`, except *when* is the absolute time to "
"stop waiting, or ``None``."
msgstr ""

#: library/asyncio-task.rst:698
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Attend la fin de l':ref:`awaitable <asyncio-awaitables>` *aw* avec délai "
"d'attente."

#: library/asyncio-task.rst:703
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* peut-être soit ``None``, soit le nombre de secondes (entier ou "
"décimal) d'attente. Si *timeout* vaut ``None``, la fonction s'interrompt "
"jusqu'à ce que le futur s'achève."

#: library/asyncio-task.rst:707
#, fuzzy
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`TimeoutError`."
msgstr ""
"Si le délai d'attente maximal est dépassé, la tâche est annulée et "
"l'exception :exc:`asyncio.TimeoutError` est levée."

#: library/asyncio-task.rst:710
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Pour empêcher :meth:`l'annulation <Task.cancel>` de la tâche, il est "
"nécessaire de l'encapsuler dans une fonction :func:`shield`."

#: library/asyncio-task.rst:713
#, fuzzy
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"Cette fonction attend que le futur soit réellement annulé, donc le temps "
"d'attente total peut être supérieur à *timeout*."

#: library/asyncio-task.rst:717
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Si l'attente est annulée, le futur *aw* est également annulé."

#: library/asyncio-task.rst:744
#, fuzzy
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`TimeoutError` immediately."
msgstr ""
"Si le dépassement du délai d'attente maximal provoque l'annulation de *aw*, "
"``wait_for`` attend que *aw* soit annulée. Auparavant, l'exception :exc:"
"`asyncio.TimeoutError` était immédiatement levée."

#: library/asyncio-task.rst:754
msgid "Waiting Primitives"
msgstr "Primitives d'attente"

#: library/asyncio-task.rst:758
#, fuzzy
msgid ""
"Run :class:`~asyncio.Future` and :class:`~asyncio.Task` instances in the "
"*aws* iterable concurrently and block until the condition specified by "
"*return_when*."
msgstr ""
"Exécute les objets :ref:`awaitables <asyncio-awaitables>` de l'ensemble "
"*aws* de manière concurrente, et s'interrompt jusqu'à ce que la condition "
"décrite dans *return_when* soit vraie."

#: library/asyncio-task.rst:762
msgid "The *aws* iterable must not be empty."
msgstr ""

#: library/asyncio-task.rst:764
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Renvoie deux ensembles de *Tasks* / *Futures* : ``(done, pending)``."

#: library/asyncio-task.rst:766
msgid "Usage::"
msgstr "Utilisation ::"

#: library/asyncio-task.rst:770
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (entier ou décimal), si précisé, peut-être utilisé pour contrôler "
"le nombre maximal de secondes d'attente avant de se terminer."

#: library/asyncio-task.rst:773
#, fuzzy
msgid ""
"Note that this function does not raise :exc:`TimeoutError`. Futures or Tasks "
"that aren't done when the timeout occurs are simply returned in the second "
"set."
msgstr ""
"Cette fonction ne lève pas :exc:`asyncio.TimeoutError`. Les futurs et les "
"tâches qui ne sont pas finis quand le délai d'attente maximal est dépassé "
"sont tout simplement renvoyés dans le second ensemble."

#: library/asyncio-task.rst:777
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* indique quand la fonction doit se terminer. Il peut prendre "
"les valeurs suivantes :"

#: library/asyncio-task.rst:783
msgid "Constant"
msgstr "Constante"

#: library/asyncio-task.rst:783
msgid "Description"
msgstr "Description"

#: library/asyncio-task.rst:785
msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

#: library/asyncio-task.rst:785
msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"La fonction se termine lorsque n'importe quel futur se termine ou est annulé."

#: library/asyncio-task.rst:788
msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

#: library/asyncio-task.rst:788
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"La fonction se termine lorsque n'importe quel futur se termine en levant une "
"exception. Si aucun *futur* ne lève d'exception, équivaut à :const:"
"`ALL_COMPLETED`."

#: library/asyncio-task.rst:794
msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

#: library/asyncio-task.rst:794
msgid "The function will return when all futures finish or are cancelled."
msgstr ""
"La fonction se termine lorsque les *futurs* sont tous finis ou annulés."

#: library/asyncio-task.rst:798
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"À la différence de :func:`~asyncio.wait_for`, ``wait()`` n'annule pas les "
"futurs quand le délai d'attente est dépassé."

#: library/asyncio-task.rst:804
#, fuzzy
msgid "Passing coroutine objects to ``wait()`` directly is forbidden."
msgstr "Passer directement des objets coroutines à ``wait()`` est obsolète."

#: library/asyncio-task.rst:809
#, fuzzy
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently.  Return an iterator of coroutines. Each coroutine returned can "
"be awaited to get the earliest next result from the iterable of the "
"remaining awaitables."
msgstr ""
"Exécute les objets :ref:`awaitables <asyncio-awaitables>` de l'ensemble "
"*aws* de manière concurrente. Renvoie un itérateur sur des objets :class:"
"`Future`. Chaque objet *futur* renvoyé représente le résultat le plus récent "
"de l'ensemble des *awaitables* restants."

#: library/asyncio-task.rst:814
#, fuzzy
msgid ""
"Raises :exc:`TimeoutError` if the timeout occurs before all Futures are done."
msgstr ""
"Lève une exception :exc:`asyncio.TimeoutError` si le délai d'attente est "
"dépassé avant que tous les futurs ne soient achevés."

#: library/asyncio-task.rst:829
msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr ""

#: library/asyncio-task.rst:835
msgid "Running in Threads"
msgstr ""

#: library/asyncio-task.rst:839
msgid "Asynchronously run function *func* in a separate thread."
msgstr ""

#: library/asyncio-task.rst:841
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""

#: library/asyncio-task.rst:846
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr ""

#: library/asyncio-task.rst:848
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were run in the main thread. For example::"
msgstr ""

#: library/asyncio-task.rst:878
msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""

#: library/asyncio-task.rst:885
msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""

#: library/asyncio-task.rst:894
msgid "Scheduling From Other Threads"
msgstr "Planification depuis d'autres fils d'exécution"

#: library/asyncio-task.rst:898
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr ""
"Enregistre une coroutine dans la boucle d'exécution actuelle. Cette "
"opération est compatible avec les programmes à multiples fils d'exécution "
"(*thread-safe*)."

#: library/asyncio-task.rst:900
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Renvoie un :class:`concurrent.futures.Future` pour attendre le résultat d'un "
"autre fil d'exécution du système d'exploitation."

#: library/asyncio-task.rst:903
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Cette fonction est faite pour être appelée par un fil d'exécution distinct "
"de celui dans laquelle la boucle d'événement s'exécute. Exemple ::"

#: library/asyncio-task.rst:915
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Si une exception est levée dans une coroutine, le futur renvoyé en sera "
"averti. Elle peut également être utilisée pour annuler la tâche de la boucle "
"d'événement ::"

#: library/asyncio-task.rst:929
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Voir la section :ref:`exécution concurrente et multi-fils d'exécution "
"<asyncio-multithreading>` de la documentation."

#: library/asyncio-task.rst:932
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"À la différence des autres fonctions d'*asyncio*, cette fonction requiert "
"que *loop* soit passé de manière explicite."

#: library/asyncio-task.rst:939
msgid "Introspection"
msgstr "Introspection"

#: library/asyncio-task.rst:944
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Renvoie l'instance de la :class:`Task` en cours d'exécution, ou ``None`` "
"s'il n'y a pas de tâche en cours."

#: library/asyncio-task.rst:947
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Si *loop* vaut ``None``, :func:`get_running_loop` est appelée pour récupérer "
"la boucle en cours d'exécution."

#: library/asyncio-task.rst:955
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Renvoie l'ensemble des :class:`Task` non terminés en cours d'exécution dans "
"la boucle."

#: library/asyncio-task.rst:958
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Si *loop* vaut ``None``, :func:`get_running_loop` est appelée pour récupérer "
"la boucle en cours d'exécution."

#: library/asyncio-task.rst:965
msgid "Task Object"
msgstr "Objets *Task*"

#: library/asyncio-task.rst:969
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Objet compatible avec :class:`Future <Future>` qui exécute une :ref:"
"`coroutine <coroutine>` Python. Cet objet n'est pas utilisable dans des "
"programmes à fils d'exécution multiples."

#: library/asyncio-task.rst:972
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Les tâches servent à exécuter des coroutines dans des boucles d'événements. "
"Si une coroutine attend un futur, la tâche interrompt son exécution et "
"attend la fin de ce *futur*. Quand celui-ci est terminé, l'exécution de la "
"coroutine encapsulée reprend."

#: library/asyncio-task.rst:978
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Les boucles d'événement fonctionnent de manière *coopérative* : une boucle "
"d'événement exécute une tâche à la fois. Quand une tâche attend la fin d'un "
"futur, la boucle d'événement exécute d'autres tâches, des fonctions de "
"rappel, ou effectue des opérations d'entrées-sorties."

#: library/asyncio-task.rst:983
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"La fonction de haut niveau :func:`asyncio.create_task` et les fonctions de "
"bas-niveau :meth:`loop.create_task` ou :func:`ensure_future` permettent de "
"créer des tâches. Il est déconseillé d'instancier manuellement des objets "
"*Task*."

#: library/asyncio-task.rst:988
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"La méthode :meth:`cancel` d'une tâche en cours d'exécution permet d'annuler "
"celle-ci. L'appel de cette méthode force la tâche à lever l'exception :exc:"
"`CancelledError` dans la coroutine encapsulée. Si la coroutine attendait un "
"*futur* au moment de l'annulation, celui-ci est annulé."

#: library/asyncio-task.rst:993
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
"La méthode :meth:`cancelled` permet de vérifier si la tâche a été annulée. "
"Elle renvoie ``True`` si la coroutine encapsulée n'a pas ignoré l'exception :"
"exc:`CancelledError` et a bien été annulée."

#: library/asyncio-task.rst:998
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` hérite de :class:`Future`, de toute son API, à "
"l'exception de :meth:`Future.set_result` et de :meth:`Future.set_exception`."

#: library/asyncio-task.rst:1002
msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr ""
"*Task* implémente le module :mod:`contextvars`. Lors de sa création, une "
"tâche effectue une copie du contexte actuel et exécutera ses coroutines dans "
"cette copie."

#: library/asyncio-task.rst:1006
msgid "Added support for the :mod:`contextvars` module."
msgstr "Ajout du support du module :mod:`contextvars`."

#: library/asyncio-task.rst:1012
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""

#: library/asyncio-task.rst:1018
msgid "Return ``True`` if the Task is *done*."
msgstr "Renvoie ``True`` si la tâche est *achevée*."

#: library/asyncio-task.rst:1020
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Une tâche est dite *achevée* quand la coroutine encapsulée a soit renvoyé "
"une valeur, soit levé une exception, ou que la tâche a été annulée."

#: library/asyncio-task.rst:1025
msgid "Return the result of the Task."
msgstr "Renvoie le résultat de la tâche."

#: library/asyncio-task.rst:1027
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Si la tâche est *achevée*, le résultat de la coroutine encapsulée est "
"renvoyé (sinon, dans le cas où la coroutine a levé une exception, cette "
"exception est de nouveau levée)."

#: library/asyncio-task.rst:1045
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Si la tâche a été *annulée*, cette méthode lève une exception :exc:"
"`CancelledError`."

#: library/asyncio-task.rst:1034
msgid ""
"If the Task's result isn't yet available, this method raises a :exc:"
"`InvalidStateError` exception."
msgstr ""
"Si le résultat de la tâche n'est pas encore disponible, cette méthode lève "
"une exception :exc:`InvalidStateError`."

#: library/asyncio-task.rst:1039
msgid "Return the exception of the Task."
msgstr "Renvoie l'exception de la tâche."

#: library/asyncio-task.rst:1041
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Si la coroutine encapsulée lève une exception, cette exception est renvoyée. "
"Si la coroutine s'est exécutée normalement, cette méthode renvoie ``None``."

#: library/asyncio-task.rst:1048
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Si la tâche n'est pas encore *achevée*, cette méthode lève une exception :"
"exc:`InvalidStateError`."

#: library/asyncio-task.rst:1053
msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Ajoute une fonction de rappel qui sera exécutée quand la tâche sera "
"*achevée*."

#: library/asyncio-task.rst:1064
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Cette méthode ne doit être utilisée que dans du code basé sur les fonctions "
"de rappel de bas-niveau."

#: library/asyncio-task.rst:1057
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Se référer à la documentation de :meth:`Future.add_done_callback` pour plus "
"de détails."

#: library/asyncio-task.rst:1062
msgid "Remove *callback* from the callbacks list."
msgstr "Retire *callback* de la liste de fonctions de rappel."

#: library/asyncio-task.rst:1066
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Se référer à la documentation de :meth:`Future.remove_done_callback` pour "
"plus de détails."

#: library/asyncio-task.rst:1071
msgid "Return the list of stack frames for this Task."
msgstr "Renvoie une liste représentant la pile d'appels de la tâche."

#: library/asyncio-task.rst:1073
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Si la coroutine encapsulée n'est pas terminée, cette fonction renvoie la "
"pile d'appels à partir de l'endroit où celle-ci est interrompue. Si la "
"coroutine s'est terminée normalement ou a été annulée, cette fonction "
"renvoie une liste vide. Si la coroutine a été terminée par une exception, "
"ceci renvoie la pile d'erreurs."

#: library/asyncio-task.rst:1079
msgid "The frames are always ordered from oldest to newest."
msgstr "La pile est toujours affichée de l'appelant à l'appelé."

#: library/asyncio-task.rst:1081
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Une seule ligne est renvoyée si la coroutine est suspendue."

#: library/asyncio-task.rst:1083
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"L'argument facultatif *limit* définit le nombre maximal d'appels à "
"renvoyer ; par défaut, tous sont renvoyés. L'ordre de la liste diffère selon "
"la nature de celle-ci : les appels les plus récents d'une pile d'appels sont "
"renvoyés, si la pile est une pile d'erreurs, ce sont les appels les plus "
"anciens qui le sont (dans un souci de cohérence avec le module *traceback*)."

#: library/asyncio-task.rst:1092
msgid "Print the stack or traceback for this Task."
msgstr "Affiche la pile d'appels ou d'erreurs de la tâche."

#: library/asyncio-task.rst:1094
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Le format de sortie des appels produits par :meth:`get_stack` est similaire "
"à celui du module *traceback*."

#: library/asyncio-task.rst:1097
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "Le paramètre *limit* est directement passé à :meth:`get_stack`."

#: library/asyncio-task.rst:1099
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stderr`."
msgstr ""
"Le paramètre *file* est un flux d'entrées-sorties sur lequel le résultat est "
"écrit ; par défaut, :data:`sys.stderr`."

#: library/asyncio-task.rst:1104
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Renvoie l’objet *coroutine* encapsulé par la :class:`Task`."

#: library/asyncio-task.rst:1110
msgid "Return the name of the Task."
msgstr "Renvoie le nom de la tâche."

#: library/asyncio-task.rst:1112
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Si aucun nom n’a été explicitement assigné à la tâche, l’implémentation par "
"défaut d’une *Task* *asyncio* génère un nom par défaut durant "
"l’instanciation."

#: library/asyncio-task.rst:1120
msgid "Set the name of the Task."
msgstr "Définit le nom de la tâche."

#: library/asyncio-task.rst:1122
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"L’argument *value* peut être n’importe quel objet qui sera ensuite converti "
"en chaine de caractères."

#: library/asyncio-task.rst:1125
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"Dans l’implémentation par défaut de *Task*, le nom sera visible dans le "
"résultat de :func:`repr` d’un objet *Task*."

#: library/asyncio-task.rst:1132
msgid "Request the Task to be cancelled."
msgstr "Demande l'annulation d'une tâche."

#: library/asyncio-task.rst:1134
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Provisionne la levée de l'exception :exc:`CancelledError` dans la coroutine "
"encapsulée. L'exception sera levée au prochain cycle de la boucle "
"d'exécution."

#: library/asyncio-task.rst:1137
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged."
msgstr ""
"La coroutine peut alors faire le ménage ou même ignorer la requête en "
"supprimant l'exception à l'aide d'un bloc :keyword:`try` … … ``except "
"CancelledError`` … :keyword:`finally`. Par conséquent, contrairement à :meth:"
"`Future.cancel`, :meth:`Task.cancel` ne garantit pas que la tâche sera "
"annulée, bien qu'ignorer totalement une annulation ne soit ni une pratique "
"courante, ni encouragé."

#: library/asyncio-task.rst:1145
#, fuzzy
msgid "Added the *msg* parameter."
msgstr "ajout du paramètre ``name``."

#: library/asyncio-task.rst:1148
msgid "The ``msg`` parameter is propagated from cancelled task to its awaiter."
msgstr ""

#: library/asyncio-task.rst:1153
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"L'exemple ci-dessous illustre comment une coroutine peut intercepter une "
"requête d'annulation ::"

#: library/asyncio-task.rst:1192
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Renvoie ``True`` si la tâche est *annulée*."

#: library/asyncio-task.rst:1194
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"La tâche est *annulée* quand l'annulation a été demandée avec :meth:`cancel` "
"et la coroutine encapsulée a propagé l'exception :exc:`CancelledError` qui a "
"été levée en son sein."

#: library/asyncio-task.rst:1200
#, fuzzy
msgid "Decrement the count of cancellation requests to this Task."
msgstr "Renvoie une liste représentant la pile d'appels de la tâche."

#: library/asyncio-task.rst:1202
msgid "Returns the remaining number of cancellation requests."
msgstr ""

#: library/asyncio-task.rst:1204
msgid ""
"Note that once execution of a cancelled task completed, further calls to :"
"meth:`uncancel` are ineffective."
msgstr ""

#: library/asyncio-task.rst:1209
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  In particular, if a Task gets successfully uncancelled, this "
"allows for elements of structured concurrency like :ref:`taskgroups` and :"
"func:`asyncio.timeout` to continue running, isolating cancellation to the "
"respective structured block. For example::"
msgstr ""

#: library/asyncio-task.rst:1227
msgid ""
"While the block with ``make_request()`` and ``make_another_request()`` might "
"get cancelled due to the timeout, ``unrelated_code()`` should continue "
"running even in case of the timeout.  This is implemented with :meth:"
"`uncancel`.  :class:`TaskGroup` context managers use :func:`uncancel` in a "
"similar fashion."
msgstr ""

#: library/asyncio-task.rst:1235
msgid ""
"Return the number of pending cancellation requests to this Task, i.e., the "
"number of calls to :meth:`cancel` less the number of :meth:`uncancel` calls."
msgstr ""

#: library/asyncio-task.rst:1239
msgid ""
"Note that if this number is greater than zero but the Task is still "
"executing, :meth:`cancelled` will still return ``False``. This is because "
"this number can be lowered by calling :meth:`uncancel`, which can lead to "
"the task not being cancelled after all if the cancellation requests go down "
"to zero."
msgstr ""

#: library/asyncio-task.rst:1245
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  See :meth:`uncancel` for more details."
msgstr ""

#~ msgid "Running an asyncio Program"
#~ msgstr "Exécution d'un programme *asyncio*"

#~ msgid "Execute the :term:`coroutine` *coro* and return the result."
#~ msgstr "Exécute la :term:`coroutine` *coro* et renvoie le résultat."

#, fuzzy
#~ msgid ""
#~ "This function runs the passed coroutine, taking care of managing the "
#~ "asyncio event loop, *finalizing asynchronous generators*, and closing the "
#~ "threadpool."
#~ msgstr ""
#~ "Cette fonction exécute la coroutine passée en argument. Elle gère la "
#~ "boucle d'événements *asyncio* et *finalise les générateurs asynchrones*."

#~ msgid ""
#~ "This function cannot be called when another asyncio event loop is running "
#~ "in the same thread."
#~ msgstr ""
#~ "Cette fonction ne peut pas être appelée si une autre boucle d'événement "
#~ "*asyncio* s'exécute dans le même fil d'exécution."

#~ msgid "If *debug* is ``True``, the event loop will be run in debug mode."
#~ msgstr ""
#~ "Si *debug* vaut ``True``, la boucle d'événement s'exécute en mode de "
#~ "débogage."

#~ msgid ""
#~ "This function always creates a new event loop and closes it at the end.  "
#~ "It should be used as a main entry point for asyncio programs, and should "
#~ "ideally only be called once."
#~ msgstr ""
#~ "Cette fonction crée toujours une nouvelle boucle d'événement et la clôt à "
#~ "la fin. Elle doit être utilisée comme point d'entrée principal des "
#~ "programmes *asyncio* et ne doit être idéalement appelée qu'une seule fois."

#~ msgid ""
#~ "The source code for ``asyncio.run()`` can be found in :source:`Lib/"
#~ "asyncio/runners.py`."
#~ msgstr ""
#~ "Le code source pour ``asyncio.run()`` est disponible dans :source:`Lib/"
#~ "asyncio/runners.py`."

#~ msgid ""
#~ "This function has been **added in Python 3.7**.  Prior to Python 3.7, the "
#~ "low-level :func:`asyncio.ensure_future` function can be used instead::"
#~ msgstr ""
#~ "Cette fonction a été **ajoutée dans Python 3.7**. Pour les versions "
#~ "antérieures à la 3.7, la fonction de bas-niveau :func:`asyncio."
#~ "ensure_future` peut-être utilisée ::"

#~ msgid ""
#~ "asyncio also supports legacy :ref:`generator-based "
#~ "<asyncio_generator_based_coro>` coroutines."
#~ msgstr ""
#~ "*asyncio* implémente également les coroutines :ref:`basées sur des "
#~ "générateurs <asyncio_generator_based_coro>` ; celles-ci sont obsolètes."

#~ msgid ""
#~ "If any awaitable in *aws* is a coroutine, it is automatically scheduled "
#~ "as a Task.  Passing coroutines objects to ``wait()`` directly is "
#~ "deprecated as it leads to :ref:`confusing behavior "
#~ "<asyncio_example_wait_coroutine>`."
#~ msgstr ""
#~ "Si un *awaitable* de *aws* est une coroutine, celle-ci est "
#~ "automatiquement planifiée comme une tâche. Passer directement des objets "
#~ "coroutines à ``wait()`` est obsolète, car ceci conduisait :ref:`à un "
#~ "comportement portant à confusion <asyncio_example_wait_coroutine>`."

#~ msgid ""
#~ "``wait()`` schedules coroutines as Tasks automatically and later returns "
#~ "those implicitly created Task objects in ``(done, pending)`` sets.  "
#~ "Therefore the following code won't work as expected::"
#~ msgstr ""
#~ "``wait()`` planifie automatiquement les coroutines comme des tâches et "
#~ "renvoie les objets *Task* ainsi créés dans les ensembles ``(done, "
#~ "pending)``. Le code suivant ne fonctionne donc pas comme voulu ::"

#~ msgid "Here is how the above snippet can be fixed::"
#~ msgstr "Voici comment corriger le morceau de code ci-dessus ::"

#~ msgid "Generator-based Coroutines"
#~ msgstr "Coroutines basées sur des générateurs"

#~ msgid ""
#~ "Support for generator-based coroutines is **deprecated** and is scheduled "
#~ "for removal in Python 3.10."
#~ msgstr ""
#~ "Les coroutines basées sur des générateurs sont **obsolètes** et il est "
#~ "prévu de les supprimer en Python 3.10."

#~ msgid ""
#~ "Generator-based coroutines predate async/await syntax.  They are Python "
#~ "generators that use ``yield from`` expressions to await on Futures and "
#~ "other coroutines."
#~ msgstr ""
#~ "Les coroutines basées sur des générateurs sont antérieures à la syntaxe "
#~ "*async* / *await*. Il existe des générateurs *Python* qui utilisent les "
#~ "expressions ``yield from`` pour attendre des *futurs* et autres "
#~ "coroutines."

#~ msgid ""
#~ "Generator-based coroutines should be decorated with :func:`@asyncio."
#~ "coroutine <asyncio.coroutine>`, although this is not enforced."
#~ msgstr ""
#~ "Les coroutines basées sur des générateurs doivent être décorées avec :"
#~ "func:`@asyncio.coroutine <asyncio.coroutine>`, même si ce n'est pas "
#~ "vérifié par l'interpréteur."

#~ msgid "Decorator to mark generator-based coroutines."
#~ msgstr "Décorateur pour coroutines basées sur des générateurs."

#~ msgid ""
#~ "This decorator enables legacy generator-based coroutines to be compatible "
#~ "with async/await code::"
#~ msgstr ""
#~ "Ce décorateur rend compatibles les coroutines basées sur des générateurs "
#~ "avec le code *async* / *await* ::"

#~ msgid ""
#~ "This decorator should not be used for :keyword:`async def` coroutines."
#~ msgstr ""
#~ "Ce décorateur ne doit pas être utilisé avec des coroutines :keyword:"
#~ "`async def`."

# pas de majuscule car suit un deux-points
#~ msgid "Use :keyword:`async def` instead."
#~ msgstr "utilisez :keyword:`async def` à la place."

#~ msgid "Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`."
#~ msgstr ""
#~ "Renvoie ``True`` si *obj* est un :ref:`objet coroutine <coroutine>`."

#~ msgid ""
#~ "This method is different from :func:`inspect.iscoroutine` because it "
#~ "returns ``True`` for generator-based coroutines."
#~ msgstr ""
#~ "Cette méthode est différente de :func:`inspect.iscoroutine` car elle "
#~ "renvoie ``True`` pour des coroutines basées sur des générateurs."

#~ msgid ""
#~ "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
#~ msgstr ""
#~ "Renvoie ``True`` si *func* est une :ref:`fonction coroutine <coroutine>`."

#~ msgid ""
#~ "This method is different from :func:`inspect.iscoroutinefunction` because "
#~ "it returns ``True`` for generator-based coroutine functions decorated "
#~ "with :func:`@coroutine <coroutine>`."
#~ msgstr ""
#~ "Cette méthode est différente de :func:`inspect.iscoroutinefunction` car "
#~ "elle renvoie ``True`` pour des coroutines basées sur des générateurs, "
#~ "décorées avec :func:`@coroutine <coroutine>`."
