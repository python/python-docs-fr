# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-11-15 18:54+0100\n"
"PO-Revision-Date: 2020-04-27 22:47+0200\n"
"Last-Translator: Jules Lasne <jules.lasne@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.3\n"

#: ../Doc/library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Coroutines et tâches"

#: ../Doc/library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"Cette section donne un aperçu des API de haut-niveau du module *asyncio* "
"pour utiliser les coroutines et les tâches."

#: ../Doc/library/asyncio-task.rst:19 ../Doc/library/asyncio-task.rst:121
msgid "Coroutines"
msgstr "Coroutines"

#: ../Doc/library/asyncio-task.rst:21
#, fuzzy
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code (requires Python 3.7+) prints \"hello\", waits 1 second, and "
"then prints \"world\"::"
msgstr ""
"Il est recommandé d'utiliser la syntaxe *async* / *await* pour développer "
"des  programmes *asyncio*.  Par exemple, le morceau de code suivant "
"(nécessitant Python 3.7 ou supérieur) affiche *hello*, attend une seconde et "
"affiche ensuite *world* ::"

#: ../Doc/library/asyncio-task.rst:37
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr "Appeler une coroutine ne la planifie pas pour exécution ::"

#: ../Doc/library/asyncio-task.rst:43
msgid "To actually run a coroutine, asyncio provides three main mechanisms:"
msgstr ""
"Pour réellement exécuter une coroutine, *asyncio* fournit trois mécanismes "
"principaux :"

#: ../Doc/library/asyncio-task.rst:45
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"La fonction :func:`asyncio.run` pour exécuter la fonction « main() », le "
"point d'entrée de haut-niveau (voir l'exemple ci-dessus)."

#: ../Doc/library/asyncio-task.rst:48
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Attendre une coroutine. Le morceau de code suivant attend une seconde, "
"affiche « hello », attend 2 secondes *supplémentaires*, puis affiche enfin "
"*world* ::"

#: ../Doc/library/asyncio-task.rst:69
msgid "Expected output::"
msgstr "Sortie attendue ::"

#: ../Doc/library/asyncio-task.rst:76
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"La fonction :func:`asyncio.create_task` pour exécuter de manière concurrente "
"des coroutines en tant que :class:`tâches <Task>` *asyncio*."

#: ../Doc/library/asyncio-task.rst:79
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Modifions l'exemple ci-dessus et lançons deux coroutines ``say_after`` *de "
"manière concurrente* ::"

#: ../Doc/library/asyncio-task.rst:98
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"La sortie attendue montre à présent que ce code s'exécute une seconde plus "
"rapidement que le précédent ::"

#: ../Doc/library/asyncio-task.rst:110
msgid "Awaitables"
msgstr "Awaitables"

#: ../Doc/library/asyncio-task.rst:112
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Un objet est dit *awaitable* (qui peut être attendu) s'il peut être utilisé "
"dans une expression :keyword:`await`.  Beaucoup d'API d'*asyncio* sont "
"conçues pour accepter des *awaitables*."

#: ../Doc/library/asyncio-task.rst:116
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Il existe trois types principaux d'*awaitables* : les **coroutines**, les "
"**tâches** et les **futurs**."

#: ../Doc/library/asyncio-task.rst:122
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Les coroutines sont des *awaitables* et peuvent donc être attendues par "
"d'autres coroutines ::"

#: ../Doc/library/asyncio-task.rst:143
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"Dans cette documentation, le terme « coroutine » est utilisé pour désigner "
"deux concepts voisins :"

#: ../Doc/library/asyncio-task.rst:146
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "une *fonction coroutine* : une fonction :keyword:`async def`;"

#: ../Doc/library/asyncio-task.rst:148
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr "un *objet coroutine* : un objet renvoyé par une *fonction coroutine*."

#: ../Doc/library/asyncio-task.rst:151
msgid ""
"asyncio also supports legacy :ref:`generator-based "
"<asyncio_generator_based_coro>` coroutines."
msgstr ""
"*asyncio* implémente également les coroutines :ref:`basées sur des "
"générateurs <asyncio_generator_based_coro>` ; celles-ci sont obsolètes."

#: ../Doc/library/asyncio-task.rst:156
msgid "Tasks"
msgstr "Tâches"

#: ../Doc/library/asyncio-task.rst:157
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr ""
"Les *tâches* servent à planifier des coroutines de façon à ce qu'elles "
"s'exécutent de manière concurrente."

#: ../Doc/library/asyncio-task.rst:159
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"Lorsqu'une coroutine est encapsulée dans une *tâche* à l'aide de fonctions "
"comme :func:`asyncio.create_task`, la coroutine est automatiquement "
"planifiée pour s'exécuter prochainement ::"

#: ../Doc/library/asyncio-task.rst:181
msgid "Futures"
msgstr "Futurs"

#: ../Doc/library/asyncio-task.rst:182
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
"Un :class:`Future` est un objet *awaitable* spécial de **bas-niveau**, qui "
"représente le **résultat final** d'une opération asynchrone."

#: ../Doc/library/asyncio-task.rst:185
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Quand un objet *Future* est *attendu*, cela signifie que la coroutine "
"attendra que ce futur soit résolu à un autre endroit."

#: ../Doc/library/asyncio-task.rst:188
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Les objets *Future* d'*asyncio* sont nécessaires pour permettre l'exécution "
"de code basé sur les fonctions de rappel avec la syntaxe *async* / *await*."

#: ../Doc/library/asyncio-task.rst:191
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Il est normalement **inutile** de créer des objets *Future* dans la couche "
"applicative du code."

#: ../Doc/library/asyncio-task.rst:194
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Les objets *Future*, parfois exposés par des bibliothèques et quelques API "
"d'*asyncio*, peuvent être attendus ::"

#: ../Doc/library/asyncio-task.rst:206
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
":meth:`loop.run_in_executor` est l'exemple typique d'une fonction bas-niveau "
"renvoyant un objet *Future*."

#: ../Doc/library/asyncio-task.rst:211
msgid "Running an asyncio Program"
msgstr "Exécution d'un programme *asyncio*"

#: ../Doc/library/asyncio-task.rst:215
msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr ""

#: ../Doc/library/asyncio-task.rst:217
msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio "
"event loop and *finalizing asynchronous generators*."
msgstr ""
"Cette fonction exécute la coroutine passée en argument. Elle gère la boucle "
"d'événements *asyncio* et *finalise les générateurs asynchrones*."

#: ../Doc/library/asyncio-task.rst:221
msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""
"Cette fonction ne peut pas être appelée si une autre boucle d'événement "
"s'exécute dans le même fil d'exécution."

#: ../Doc/library/asyncio-task.rst:224
msgid "If *debug* is ``True``, the event loop will be run in debug mode."
msgstr ""
"Si *debug* vaut ``True``, la boucle d'événement s'exécute en mode de "
"débogage."

#: ../Doc/library/asyncio-task.rst:226
msgid ""
"This function always creates a new event loop and closes it at the end.  It "
"should be used as a main entry point for asyncio programs, and should "
"ideally only be called once."
msgstr ""
"Cette fonction crée toujours une nouvelle boucle d'événement et la clôt à la "
"fin. Elle doit être utilisée comme point d'entrée principal des programmes "
"*asyncio* et ne doit être idéalement appelée qu'une seule fois."

#: ../Doc/library/asyncio-task.rst:230 ../Doc/library/asyncio-task.rst:354
#: ../Doc/library/asyncio-task.rst:463 ../Doc/library/asyncio-task.rst:593
msgid "Example::"
msgstr "Exemple ::"

#: ../Doc/library/asyncio-task.rst:242
msgid ""
"The source code for ``asyncio.run()`` can be found in :source:`Lib/asyncio/"
"runners.py`."
msgstr ""

#: ../Doc/library/asyncio-task.rst:246
msgid "Creating Tasks"
msgstr "Création de tâches"

#: ../Doc/library/asyncio-task.rst:250
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Encapsule la :ref:`coroutine <coroutine>` *coro* dans une tâche et la "
"planifie pour exécution.  Renvoie l'objet  :class:`Task`."

#: ../Doc/library/asyncio-task.rst:253
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""

#: ../Doc/library/asyncio-task.rst:256
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"La tâche est exécutée dans la boucle renvoyée par :func:"
"`get_running_loop` ; :exc:`RuntimeError` est levée s'il n'y a pas de boucle "
"en cours d'exécution dans le fil actuel."

#: ../Doc/library/asyncio-task.rst:260
msgid ""
"This function has been **added in Python 3.7**.  Prior to Python 3.7, the "
"low-level :func:`asyncio.ensure_future` function can be used instead::"
msgstr ""
"Cette fonction a été **ajoutée dans Python 3.7**. Pour les versions "
"antérieures à la 3.7, la fonction de bas-niveau :func:`asyncio."
"ensure_future` peut-être utilisée ::"

#: ../Doc/library/asyncio-task.rst:277 ../Doc/library/asyncio-task.rst:716
msgid "Added the ``name`` parameter."
msgstr ""

#: ../Doc/library/asyncio-task.rst:282
msgid "Sleeping"
msgstr "Attente"

#: ../Doc/library/asyncio-task.rst:286
msgid "Block for *delay* seconds."
msgstr "Attend pendant *delay* secondes."

#: ../Doc/library/asyncio-task.rst:288
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Si *result* est spécifié, il est renvoyé à l'appelant quand la coroutine se "
"termine."

#: ../Doc/library/asyncio-task.rst:291
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` suspend systématiquement la tâche courante, ce qui permet aux "
"autres tâches de s'exécuter."

#: ../Doc/library/asyncio-task.rst:296 ../Doc/library/asyncio-task.rst:351
#: ../Doc/library/asyncio-task.rst:430 ../Doc/library/asyncio-task.rst:460
#: ../Doc/library/asyncio-task.rst:545 ../Doc/library/asyncio-task.rst:592
#: ../Doc/library/asyncio-task.rst:721
msgid "The *loop* parameter."
msgstr ""

#: ../Doc/library/asyncio-task.rst:299
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Exemple d'une coroutine affichant la date toutes les secondes pendant 5 "
"secondes ::"

#: ../Doc/library/asyncio-task.rst:318
msgid "Running Tasks Concurrently"
msgstr "Exécution de tâches de manière concurrente"

#: ../Doc/library/asyncio-task.rst:322
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Exécute les objets :ref:`awaitable <asyncio-awaitables>` de la séquence "
"*aws*, *de manière concurrente*."

#: ../Doc/library/asyncio-task.rst:325
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Si un *awaitable* de *aws* est une coroutine, celui-ci est automatiquement "
"planifié comme une tâche."

#: ../Doc/library/asyncio-task.rst:328
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Si tous les *awaitables* s'achèvent avec succès, le résultat est la liste "
"des valeurs renvoyées. L'ordre de cette liste correspond à l'ordre des "
"*awaitables* dans *aws*."

#: ../Doc/library/asyncio-task.rst:332
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Si *return_exceptions* vaut ``False`` (valeur par défaut), la première "
"exception levée est immédiatement propagée vers la tâche en attente dans le "
"``gather()``.  Les autres *awaitables* dans la séquence *aws* **ne sont pas "
"annulés** et poursuivent leur exécution."

#: ../Doc/library/asyncio-task.rst:337
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Si *return_exceptions* vaut ``True``, les exceptions sont traitées de la "
"même manière que les exécutions normales, et incluses dans la liste des "
"résultats."

#: ../Doc/library/asyncio-task.rst:340
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Si ``gather()`` est *annulé*, tous les *awaitables* en cours (ceux qui n'ont "
"pas encore fini de s'exécuter) sont également *annulés*."

#: ../Doc/library/asyncio-task.rst:343
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Si n'importe quel *Task* ou *Future* de la séquence *aws* est *annulé*, il "
"est traité comme s'il avait levé :exc:`CancelledError` — l'appel à "
"``gather()`` n'est alors **pas** annulé.  Ceci permet d'empêcher que "
"l'annulation d'une tâche ou d'un futur entraîne l'annulation des autres "
"tâches ou futurs."

#: ../Doc/library/asyncio-task.rst:388
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Si *gather* est lui-même annulé, l'annulation est propagée indépendamment de "
"*return_exceptions*."

#: ../Doc/library/asyncio-task.rst:394
msgid "Shielding From Cancellation"
msgstr "Protection contre l'annulation"

#: ../Doc/library/asyncio-task.rst:398
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Empêche qu'un objet :ref:`awaitable <asyncio-awaitables>` puisse être :meth:"
"`annulé <Task.cancel>`."

#: ../Doc/library/asyncio-task.rst:401 ../Doc/library/asyncio-task.rst:441
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr ""
"Si *aw* est une coroutine, elle est planifiée automatiquement comme une "
"tâche."

#: ../Doc/library/asyncio-task.rst:403
msgid "The statement::"
msgstr "L'instruction ::"

#: ../Doc/library/asyncio-task.rst:407
msgid "is equivalent to::"
msgstr "est équivalente à ::"

#: ../Doc/library/asyncio-task.rst:411
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*à la différence près* que si la coroutine qui la contient est annulée, la "
"tâche s'exécutant dans ``something()`` n'est pas annulée.  Du point de vue "
"de ``something()``, il n'y a pas eu d'annulation. Cependant, son appelant "
"est bien annulé, donc l'expression *await* lève bien une :exc:"
"`CancelledError`."

#: ../Doc/library/asyncio-task.rst:417
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Si ``something()`` est annulée d'une autre façon (c.-à-d. depuis elle-même) "
"ceci annule également ``shield()``."

#: ../Doc/library/asyncio-task.rst:420
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Pour ignorer complètement l'annulation (déconseillé), la fonction "
"``shield()`` peut être combinée à une clause *try* / *except*, comme dans le "
"code ci-dessous ::"

#: ../Doc/library/asyncio-task.rst:434
msgid "Timeouts"
msgstr "Délais d'attente"

#: ../Doc/library/asyncio-task.rst:438
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Attend la fin de l':ref:`awaitable <asyncio-awaitables>` *aw* avec délai "
"d'attente."

#: ../Doc/library/asyncio-task.rst:443
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* peut-être soit ``None``, soit le nombre de secondes (entier ou "
"décimal) d'attente. Si *timeout* vaut ``None``, la fonction s'interrompt "
"jusqu'à ce que le futur s'achève."

#: ../Doc/library/asyncio-task.rst:447
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`asyncio."
"TimeoutError`."
msgstr ""
"Si le délai d'attente maximal est dépassé, la tâche est annulée et "
"l'exception :exc:`asyncio.TimeoutError` est levée."

#: ../Doc/library/asyncio-task.rst:450
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Pour empêcher :meth:`l'annulation <Task.cancel>` de la tâche, il est "
"nécessaire de l'encapsuler dans une fonction :func:`shield`."

#: ../Doc/library/asyncio-task.rst:453
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*."
msgstr ""
"Cette fonction attend que le futur soit réellement annulé, donc le temps "
"d'attente total peut être supérieur à *timeout*."

#: ../Doc/library/asyncio-task.rst:456
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Si l'attente est annulée, le futur *aw* est également annulé."

#: ../Doc/library/asyncio-task.rst:483
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`asyncio.TimeoutError` immediately."
msgstr ""
"Si le dépassement du délai d'attente maximal provoque l'annulation de *aw*, "
"``wait_for`` attend que *aw* soit annulée. Auparavant, l'exception :exc:"
"`asyncio.TimeoutError` était immédiatement levée."

#: ../Doc/library/asyncio-task.rst:490
msgid "Waiting Primitives"
msgstr "Primitives d'attente"

#: ../Doc/library/asyncio-task.rst:495
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* set "
"concurrently and block until the condition specified by *return_when*."
msgstr ""
"Exécute les objets :ref:`awaitables <asyncio-awaitables>` de l'ensemble "
"*aws* de manière concurrente, et s'interrompt jusqu'à ce que la condition "
"décrite dans *return_when* soit vraie."

#: ../Doc/library/asyncio-task.rst:499
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Renvoie deux ensembles de *Tasks* / *Futures* : ``(done, pending)``."

#: ../Doc/library/asyncio-task.rst:501
msgid "Usage::"
msgstr "Utilisation ::"

#: ../Doc/library/asyncio-task.rst:505
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (entier ou décimal), si précisé, peut-être utilisé pour contrôler "
"le nombre maximal de secondes d'attente avant de se terminer."

#: ../Doc/library/asyncio-task.rst:508
msgid ""
"Note that this function does not raise :exc:`asyncio.TimeoutError`. Futures "
"or Tasks that aren't done when the timeout occurs are simply returned in the "
"second set."
msgstr ""
"Cette fonction ne lève pas :exc:`asyncio.TimeoutError`. Les futurs et les "
"tâches qui ne sont pas finis quand le délai d'attente maximal est dépassé "
"sont tout simplement renvoyés dans le second ensemble."

#: ../Doc/library/asyncio-task.rst:512
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* indique quand la fonction doit se terminer. Il peut prendre "
"les valeurs suivantes :"

#: ../Doc/library/asyncio-task.rst:518
msgid "Constant"
msgstr "Constante"

#: ../Doc/library/asyncio-task.rst:518
msgid "Description"
msgstr "Description"

#: ../Doc/library/asyncio-task.rst:520
msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

#: ../Doc/library/asyncio-task.rst:520
msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"La fonction se termine lorsque n'importe quel futur se termine ou est annulé."

#: ../Doc/library/asyncio-task.rst:523
msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

#: ../Doc/library/asyncio-task.rst:523
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"La fonction se termine lorsque n'importe quel futur se termine en levant une "
"exception. Si aucun *futur* ne lève d'exception, équivaut à :const:"
"`ALL_COMPLETED`."

#: ../Doc/library/asyncio-task.rst:529
msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

#: ../Doc/library/asyncio-task.rst:529
msgid "The function will return when all futures finish or are cancelled."
msgstr ""
"La fonction se termine lorsque les *futurs* sont tous finis ou annulés."

#: ../Doc/library/asyncio-task.rst:533
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"À la différence de :func:`~asyncio.wait_for`, ``wait()`` n'annule pas les "
"futurs quand le délai d'attente est dépassé."

#: ../Doc/library/asyncio-task.rst:538
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task.  Passing coroutines objects to ``wait()`` directly is deprecated as it "
"leads to :ref:`confusing behavior <asyncio_example_wait_coroutine>`."
msgstr ""
"Si un *awaitable* de *aws* est une coroutine, celle-ci est automatiquement "
"planifiée comme une tâche. Passer directement des objets coroutines à "
"``wait()`` est obsolète, car ceci conduisait :ref:`à un comportement portant "
"à confusion <asyncio_example_wait_coroutine>`."

#: ../Doc/library/asyncio-task.rst:550
msgid ""
"``wait()`` schedules coroutines as Tasks automatically and later returns "
"those implicitly created Task objects in ``(done, pending)`` sets.  "
"Therefore the following code won't work as expected::"
msgstr ""
"``wait()`` planifie automatiquement les coroutines comme des tâches et "
"renvoie les objets *Task* ainsi créés dans les ensembles ``(done, "
"pending)``.  Le code suivant ne fonctionne donc pas comme voulu ::"

#: ../Doc/library/asyncio-task.rst:563
msgid "Here is how the above snippet can be fixed::"
msgstr "Voici comment corriger le morceau de code ci-dessus ::"

#: ../Doc/library/asyncio-task.rst:576
msgid "Passing coroutine objects to ``wait()`` directly is deprecated."
msgstr "Passer directement des objets coroutines à ``wait()`` est obsolète."

#: ../Doc/library/asyncio-task.rst:582
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* set "
"concurrently.  Return an iterator of :class:`Future` objects. Each Future "
"object returned represents the earliest result from the set of the remaining "
"awaitables."
msgstr ""
"Exécute les objets :ref:`awaitables <asyncio-awaitables>` de l'ensemble "
"*aws* de manière concurrente. Renvoie un itérateur sur des objets :class:"
"`Future`. Chaque objet *futur* renvoyé représente le résultat le plus récent "
"de l'ensemble des *awaitables* restants."

#: ../Doc/library/asyncio-task.rst:587
msgid ""
"Raises :exc:`asyncio.TimeoutError` if the timeout occurs before all Futures "
"are done."
msgstr ""
"Lève une exception :exc:`asyncio.TimeoutError` si le délai d'attente est "
"dépassé avant que tous les futurs ne soient achevés."

#: ../Doc/library/asyncio-task.rst:601
msgid "Scheduling From Other Threads"
msgstr "Planification depuis d'autres fils d'exécution"

#: ../Doc/library/asyncio-task.rst:605
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr ""
"Enregistre une coroutine dans la boucle d'exécution actuelle. Cette "
"opération est compatible avec les programmes à multiples fils d'exécution "
"(*thread-safe*)."

#: ../Doc/library/asyncio-task.rst:607
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Renvoie un :class:`concurrent.futures.Future` pour attendre le résultat d'un "
"autre fil d'exécution du système d'exploitation."

#: ../Doc/library/asyncio-task.rst:610
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Cette fonction est faite pour être appelée par un fil d'exécution distinct "
"de celui dans laquelle la boucle d'événement s'exécute. Exemple ::"

#: ../Doc/library/asyncio-task.rst:622
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Si une exception est levée dans une coroutine, le futur renvoyé en sera "
"averti. Elle peut également être utilisée pour annuler la tâche de la boucle "
"d'événement ::"

#: ../Doc/library/asyncio-task.rst:636
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Voir la section :ref:`exécution concurrente et multi-fils d'exécution "
"<asyncio-multithreading>` de la documentation."

#: ../Doc/library/asyncio-task.rst:639
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"À la différence des autres fonction d'*asyncio*, cette fonction requiert que "
"*loop* soit passé de manière explicite."

#: ../Doc/library/asyncio-task.rst:646
msgid "Introspection"
msgstr "Introspection"

#: ../Doc/library/asyncio-task.rst:651
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Renvoie l'instance de la :class:`Task` en cours d'exécution, ou ``None`` "
"s'il n'y a pas de tâche en cours."

#: ../Doc/library/asyncio-task.rst:654
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Si *loop* vaut ``None``, :func:`get_running_loop` est appelée pour récupérer "
"la boucle en cours d'exécution."

#: ../Doc/library/asyncio-task.rst:662
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Renvoie l'ensemble des :class:`Task` non terminés en cours d'exécution dans "
"la boucle."

#: ../Doc/library/asyncio-task.rst:665
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Si *loop* vaut ``None``, :func:`get_running_loop` est appelée pour récupérer "
"la boucle en cours d'exécution."

#: ../Doc/library/asyncio-task.rst:672
msgid "Task Object"
msgstr "Objets *Task*"

#: ../Doc/library/asyncio-task.rst:676
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Objet compatible avec :class:`Future <Future>` qui exécute une :ref:"
"`coroutine <coroutine>` Python.  Cet objet n'est pas utilisable dans des "
"programmes à fils d'exécution multiples."

#: ../Doc/library/asyncio-task.rst:679
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Les tâches servent à exécuter des coroutines dans des boucles d'événements. "
"Si une coroutine attend un futur, la tâche interrompt son exécution et "
"attend la fin de ce *futur*. Quand celui-ci est terminé, l'exécution de la "
"coroutine encapsulée reprend."

#: ../Doc/library/asyncio-task.rst:685
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Les boucles d'événement fonctionnent de manière *coopérative* : une boucle "
"d'événement exécute une tâche à la fois. Quand une tâche attend la fin d'un "
"futur, la boucle d'événement exécute d'autres tâches, des fonctions de "
"rappel, ou effectue des opérations d'entrées-sorties."

#: ../Doc/library/asyncio-task.rst:690
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"La fonction de haut niveau :func:`asyncio.create_task` et les fonctions de "
"bas-niveau :meth:`loop.create_task` ou :func:`ensure_future` permettent de "
"créer des tâches. Il est déconseillé d'instancier manuellement des objets "
"*Task*."

#: ../Doc/library/asyncio-task.rst:695
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"La méthode :meth:`cancel` d'une tâche en cours d'exécution permet d'annuler "
"celle-ci. L'appel de cette méthode force la tâche à lever l'exception :exc:"
"`CancelledError` dans la coroutine encapsulée. Si la coroutine attendait un "
"*futur* au moment de l'annulation, celui-ci est annulé."

#: ../Doc/library/asyncio-task.rst:700
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
"La méthode :meth:`cancelled` permet de vérifier si la tâche a été annulée. "
"Elle renvoie ``True`` si la coroutine encapsulée n'a pas ignoré l'exception :"
"exc:`CancelledError` et a bien été annulée."

#: ../Doc/library/asyncio-task.rst:705
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` hérite de :class:`Future`, de toute son API, à "
"l'exception de :meth:`Future.set_result` et de :meth:`Future.set_exception`."

#: ../Doc/library/asyncio-task.rst:709
msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr ""
"*Task* implémente le module :mod:`contextvars`. Lors de sa création, une "
"tâche effectue une copie du contexte actuel et exécutera ses coroutines dans "
"cette copie."

#: ../Doc/library/asyncio-task.rst:713
msgid "Added support for the :mod:`contextvars` module."
msgstr "Ajout du support du module :mod:`contextvars`."

#: ../Doc/library/asyncio-task.rst:724
msgid "Request the Task to be cancelled."
msgstr "Demande l'annulation d'une tâche."

#: ../Doc/library/asyncio-task.rst:726
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Provisionne la levée de l'exception :exc:`CancelledError` dans la coroutine "
"encapsulée. L'exception sera levée au prochain cycle de la boucle "
"d'exécution."

#: ../Doc/library/asyncio-task.rst:729
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged."
msgstr ""
"La coroutine peut alors se nettoyer ou même ignorer la requête en supprimant "
"l'exception à l'aide d'un bloc :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally`. Par conséquent, contrairement à :"
"meth:`Future.cancel`, :meth:`Task.cancel` ne garantit pas que la tâche sera "
"annulée, bien qu'ignorer totalement une annulation ne soit ni une pratique "
"courante, ni encouragé."

#: ../Doc/library/asyncio-task.rst:739
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"L'exemple ci-dessous illustre comment une coroutine peut intercepter une "
"requête d'annulation ::"

#: ../Doc/library/asyncio-task.rst:778
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Renvoie ``True`` si la tâche est *annulée*."

#: ../Doc/library/asyncio-task.rst:780
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"La tâche est *annulée* quand l'annulation a été demandée avec :meth:`cancel` "
"et la coroutine encapsulée a propagé l'exception :exc:`CancelledError` qui a "
"été levée en son sein."

#: ../Doc/library/asyncio-task.rst:786
msgid "Return ``True`` if the Task is *done*."
msgstr "Renvoie ``True`` si la tâche est *achevée*."

#: ../Doc/library/asyncio-task.rst:788
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Une tâche est dite *achevée* quand la coroutine encapsulée a soit renvoyé "
"une valeur, soit levé une exception, ou que la tâche a été annulée."

#: ../Doc/library/asyncio-task.rst:793
msgid "Return the result of the Task."
msgstr "Renvoie le résultat de la tâche."

#: ../Doc/library/asyncio-task.rst:795
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Si la tâche est *achevée*, le résultat de la coroutine encapsulée est "
"renvoyé (sinon, dans le cas où la coroutine a levé une exception, cette "
"exception est de nouveau levée)."

#: ../Doc/library/asyncio-task.rst:799 ../Doc/library/asyncio-task.rst:813
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Si la tâche a été *annulée*, cette méthode lève une exception  :exc:"
"`CancelledError`."

#: ../Doc/library/asyncio-task.rst:802
msgid ""
"If the Task's result isn't yet available, this method raises a :exc:"
"`InvalidStateError` exception."
msgstr ""
"Si le résultat de la tâche n'est pas encore disponible, cette méthode lève "
"une exception :exc:`InvalidStateError`."

#: ../Doc/library/asyncio-task.rst:807
msgid "Return the exception of the Task."
msgstr "Renvoie l'exception de la tâche."

#: ../Doc/library/asyncio-task.rst:809
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Si la coroutine encapsulée lève une exception, cette exception est renvoyée. "
"Si la coroutine s'est exécutée normalement, cette méthode renvoie ``None``."

#: ../Doc/library/asyncio-task.rst:816
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Si la tâche n'est pas encore *achevée*, cette méthode lève une exception :"
"exc:`InvalidStateError`."

#: ../Doc/library/asyncio-task.rst:821
msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Ajoute une fonction de rappel qui sera exécutée quand la tâche sera "
"*achevée*."

#: ../Doc/library/asyncio-task.rst:823 ../Doc/library/asyncio-task.rst:832
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Cette méthode ne doit être utilisée que dans du code basé sur les fonctions "
"de rappel de bas-niveau."

#: ../Doc/library/asyncio-task.rst:825
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Se référer à la documentation de :meth:`Future.add_done_callback` pour plus "
"de détails."

#: ../Doc/library/asyncio-task.rst:830
msgid "Remove *callback* from the callbacks list."
msgstr "Retire *callback* de la liste de fonctions de rappel."

#: ../Doc/library/asyncio-task.rst:834
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Se référer à la documentation de :meth:`Future.remove_done_callback` pour "
"plus de détails."

#: ../Doc/library/asyncio-task.rst:839
msgid "Return the list of stack frames for this Task."
msgstr "Renvoie une liste représentant la pile d'appels de la tâche."

#: ../Doc/library/asyncio-task.rst:841
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Si la coroutine encapsulée n'est pas terminée, cette fonction renvoie la "
"pile d'appels à partir de l'endroit où celle-ci est interrompue. Si la "
"coroutine s'est terminée normalement ou a été annulée, cette fonction "
"renvoie une liste vide. Si la coroutine a été terminée par une exception, "
"ceci renvoie la pile d'erreurs."

#: ../Doc/library/asyncio-task.rst:847
msgid "The frames are always ordered from oldest to newest."
msgstr "La pile est toujours affichée de l'appelant à l'appelé."

#: ../Doc/library/asyncio-task.rst:849
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Une seule ligne est renvoyée si la coroutine est suspendue."

#: ../Doc/library/asyncio-task.rst:851
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"L'argument facultatif *limit* définit le nombre maximal d'appels à "
"renvoyer ; par défaut, tous sont renvoyés. L'ordre de la liste diffère selon "
"la nature de celle-ci : les appels les plus récents d'une pile d'appels sont "
"renvoyés, si la pile est une pile d'erreurs, ce sont les appels les plus "
"anciens qui le sont (dans un souci de cohérence avec le module *traceback*)."

#: ../Doc/library/asyncio-task.rst:860
msgid "Print the stack or traceback for this Task."
msgstr "Affiche la pile d'appels ou d'erreurs de la tâche."

#: ../Doc/library/asyncio-task.rst:862
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Le format de sortie des appels produits par :meth:`get_stack` est similaire "
"à celui du module *traceback*. "

#: ../Doc/library/asyncio-task.rst:865
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "Le paramètre *limit* est directement passé à :meth:`get_stack`."

#: ../Doc/library/asyncio-task.rst:867
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stderr`."
msgstr ""
"Le paramètre *file* est un flux d'entrées-sorties sur lequel le résultat est "
"écrit ; par défaut, :data:`sys.stderr`."

#: ../Doc/library/asyncio-task.rst:872
#, fuzzy
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Renvoie l'exception de la tâche."

#: ../Doc/library/asyncio-task.rst:878
#, fuzzy
msgid "Return the name of the Task."
msgstr "Renvoie le résultat de la tâche."

#: ../Doc/library/asyncio-task.rst:880
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""

#: ../Doc/library/asyncio-task.rst:888
#, fuzzy
msgid "Set the name of the Task."
msgstr "Renvoie le résultat de la tâche."

#: ../Doc/library/asyncio-task.rst:890
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""

#: ../Doc/library/asyncio-task.rst:893
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""

#: ../Doc/library/asyncio-task.rst:900
msgid "Return a set of all tasks for an event loop."
msgstr "Renvoie l'ensemble des tâches d'une boucle d'évènements."

#: ../Doc/library/asyncio-task.rst:902
msgid ""
"By default all tasks for the current event loop are returned. If *loop* is "
"``None``, the :func:`get_event_loop` function is used to get the current "
"loop."
msgstr ""
"Par défaut, toutes les tâches de la boucle d'exécution actuelle sont "
"renvoyées. Si *loop* vaut ``None``, la fonction :func:`get_event_loop` est "
"appelée pour récupérer la boucle d'exécution actuelle."

#: ../Doc/library/asyncio-task.rst:908
#, fuzzy
msgid ""
"Do not call this as a task method. Use the :func:`asyncio.all_tasks` "
"function instead."
msgstr ""
"Cette méthode est **obsolète** et sera supprimée en Python 3.9. Utilisez la "
"fonction :func:`asyncio.all_tasks` à la place."

#: ../Doc/library/asyncio-task.rst:913
msgid "Return the currently running task or ``None``."
msgstr "Renvoie la tâche en cours d'exécution ou ``None``."

#: ../Doc/library/asyncio-task.rst:915
msgid ""
"If *loop* is ``None``, the :func:`get_event_loop` function is used to get "
"the current loop."
msgstr ""
"Si *loop* vaut ``None``, la fonction :func:`get_event_loop` est utilisée "
"pour récupérer la boucle d'exécution actuelle."

#: ../Doc/library/asyncio-task.rst:920
#, fuzzy
msgid ""
"Do not call this as a task method.  Use the :func:`asyncio.current_task` "
"function instead."
msgstr ""
"Cette méthode est **obsolète** et sera supprimée en Python 3.9. Utilisez la "
"fonction :func:`asyncio.current_task` à la place."

#: ../Doc/library/asyncio-task.rst:927
msgid "Generator-based Coroutines"
msgstr "Coroutines basées sur des générateurs"

#: ../Doc/library/asyncio-task.rst:931
msgid ""
"Support for generator-based coroutines is **deprecated** and is scheduled "
"for removal in Python 3.10."
msgstr ""
"Les coroutines basées sur des générateurs sont **obsolètes** et il est prévu "
"de les supprimer en Python 3.10."

#: ../Doc/library/asyncio-task.rst:934
msgid ""
"Generator-based coroutines predate async/await syntax.  They are Python "
"generators that use ``yield from`` expressions to await on Futures and other "
"coroutines."
msgstr ""
"Les coroutines basées sur des générateurs sont antérieures à la syntaxe "
"*async* / *await*. Il existe des générateurs Python qui utilisent les "
"expressions ``yield from`` pour attendre des *futurs* et autres coroutines."

#: ../Doc/library/asyncio-task.rst:938
msgid ""
"Generator-based coroutines should be decorated with :func:`@asyncio."
"coroutine <asyncio.coroutine>`, although this is not enforced."
msgstr ""
"Les coroutines basées sur des générateurs doivent être décorées avec :func:"
"`@asyncio.coroutine <asyncio.coroutine>`, même si ce n'est pas vérifié par "
"l'interpréteur."

#: ../Doc/library/asyncio-task.rst:945
msgid "Decorator to mark generator-based coroutines."
msgstr "Décorateur pour coroutines basées sur des générateurs."

#: ../Doc/library/asyncio-task.rst:947
msgid ""
"This decorator enables legacy generator-based coroutines to be compatible "
"with async/await code::"
msgstr ""
"Ce décorateur rend compatibles les coroutines basées sur des générateurs "
"avec le code *async* / *await* ::"

#: ../Doc/library/asyncio-task.rst:957
msgid "This decorator should not be used for :keyword:`async def` coroutines."
msgstr ""
"Ce décorateur ne doit pas être utilisé avec des coroutines :keyword:`async "
"def`."

#: ../Doc/library/asyncio-task.rst:962
msgid "Use :keyword:`async def` instead."
msgstr ""

#: ../Doc/library/asyncio-task.rst:966
msgid "Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`."
msgstr "Renvoie ``True`` si *obj* est un :ref:`objet coroutine <coroutine>`."

#: ../Doc/library/asyncio-task.rst:968
msgid ""
"This method is different from :func:`inspect.iscoroutine` because it returns "
"``True`` for generator-based coroutines."
msgstr ""
"Cette méthode est différente de :func:`inspect.iscoroutine` car elle renvoie "
"``True`` pour des coroutines basées sur des générateurs."

#: ../Doc/library/asyncio-task.rst:973
msgid "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
msgstr ""
"Renvoie ``True`` si *func* est une :ref:`fonction coroutine <coroutine>`."

#: ../Doc/library/asyncio-task.rst:976
msgid ""
"This method is different from :func:`inspect.iscoroutinefunction` because it "
"returns ``True`` for generator-based coroutine functions decorated with :"
"func:`@coroutine <coroutine>`."
msgstr ""
"Cette méthode est différente de :func:`inspect.iscoroutinefunction` car elle "
"renvoie ``True`` pour des coroutines basées sur des générateurs, décorées "
"avec :func:`@coroutine <coroutine>`."

#~ msgid ""
#~ "**Important:** this function has been added to asyncio in Python 3.7 on "
#~ "a :term:`provisional basis <provisional api>`."
#~ msgstr ""
#~ "**Important :** cette fonction a été ajoutée à *asyncio* dans Python 3.7 "
#~ "de :term:`manière provisoire <provisional api>`."

#~ msgid ""
#~ "The *loop* argument is deprecated and scheduled for removal in Python "
#~ "3.10."
#~ msgstr "L'argument *loop* est obsolète et sera supprimé en Python 3.10."

#~ msgid ""
#~ "This decorator is **deprecated** and is scheduled for removal in Python "
#~ "3.10."
#~ msgstr ""
#~ "Ce décorateur est **obsolète** et il est prévu de le supprimer en Python "
#~ "3.10."

#~ msgid "Tasks and coroutines"
#~ msgstr "Tâches et coroutines"

#~ msgid "Things a coroutine can do:"
#~ msgstr "Les choses que les coroutines peuvent faire :"

#~ msgid "Example: Hello World coroutine"
#~ msgstr "Exemple : Coroutine \"Hello World\""

#~ msgid "Example: Chain coroutines"
#~ msgstr "Exemple : Chaîner des coroutines"

#~ msgid "InvalidStateError"
#~ msgstr "InvalidStateError"

#~ msgid "The operation is not allowed in this state."
#~ msgstr "L'opération n'est pas autorisée dans cet état."

#~ msgid "The operation exceeded the given deadline."
#~ msgstr "L'opération a dépassé le délai donné."

#~ msgid "Differences:"
#~ msgstr "Différences :"

#~ msgid "Returns the number of callbacks removed."
#~ msgstr "Donne le nombre de fonctions de rappel supprimées."

#~ msgid "Mark the future done and set its result."
#~ msgstr "Marque le futur comme terminé et définit son résultat."

#~ msgid "Mark the future done and set an exception."
#~ msgstr "Marque le futur comme terminé et définit une exception."

#~ msgid "Example: Future with run_until_complete()"
#~ msgstr "Exemple : Futur avec ``run_until_complete()``"

#~ msgid "Example: Future with run_forever()"
#~ msgstr "Exemple : Futur avec ``run_forever()``"

#~ msgid "Example: Parallel execution of tasks"
#~ msgstr "Exemple : Exécution parallèle de tâches"

#~ msgid "Example executing 3 tasks (A, B, C) in parallel::"
#~ msgstr "Exemple d'exécution de trois tâches (A, B, C) en parallèle ::"

#~ msgid "Output::"
#~ msgstr "Sortie ::"

#~ msgid "The function accepts any :term:`awaitable` object."
#~ msgstr "La fonction accepte n'importe quel objet :term:`awaitable`."

#~ msgid "This function is a :ref:`coroutine <coroutine>`, usage::"
#~ msgstr "Cette fonction est une :ref:`coroutine <coroutine>`, utilisation ::"

#~ msgid "A deprecated alias to :func:`ensure_future`."
#~ msgstr "Un alias obsolète de :func:`ensure_future`."

#~ msgid "The same coroutine implemented using a generator::"
#~ msgstr "La même coroutine implémentée en utilisant un générateur ::"
