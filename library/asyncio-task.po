# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 22:40+0100\n"
"PO-Revision-Date: 2023-06-29 21:14+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Coroutines et tâches"

#: library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"Cette section donne un aperçu des API de haut-niveau du module *asyncio* "
"pour utiliser les coroutines et les tâches."

#: library/asyncio-task.rst:148
msgid "Coroutines"
msgstr "Coroutines"

#: library/asyncio-task.rst:21
msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr "**Code source :** :source:`Lib/asyncio/coroutines.py`"

#: library/asyncio-task.rst:25
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
"Les :term:`coroutines <coroutine>` déclarées avec la syntaxe *async/await* "
"sont la manière privilégiée d’écrire des applications asynchrones. Par "
"exemple, l’extrait de code suivant affiche « hello », attend une seconde et "
"affiche ensuite « world » ::"

#: library/asyncio-task.rst:30
msgid ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('hello')\n"
"...     await asyncio.sleep(1)\n"
"...     print('world')\n"
"\n"
">>> asyncio.run(main())\n"
"hello\n"
"world"
msgstr ""

#: library/asyncio-task.rst:41
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""
"Remarquez que simplement appeler une coroutine ne la planifie pas pour "
"exécution ::"

#: library/asyncio-task.rst:44
msgid ""
">>> main()\n"
"<coroutine object main at 0x1053bb7c8>"
msgstr ""

#: library/asyncio-task.rst:47
msgid "To actually run a coroutine, asyncio provides the following mechanisms:"
msgstr ""
"Pour réellement exécuter une coroutine, *asyncio* fournit les mécanismes "
"suivants :"

#: library/asyncio-task.rst:49
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"La fonction :func:`asyncio.run` pour exécuter la fonction « main() », le "
"point d'entrée de haut-niveau (voir l'exemple ci-dessus)."

#: library/asyncio-task.rst:52
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Attendre une coroutine. Le morceau de code suivant attend une seconde, "
"affiche « hello », attend 2 secondes *supplémentaires*, puis affiche enfin "
"« world » ::"

#: library/asyncio-task.rst:56
msgid ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'hello')\n"
"    await say_after(2, 'world')\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"
msgstr ""

#: library/asyncio-task.rst:73
msgid "Expected output::"
msgstr "Sortie attendue ::"

#: library/asyncio-task.rst:75
msgid ""
"started at 17:13:52\n"
"hello\n"
"world\n"
"finished at 17:13:55"
msgstr ""

#: library/asyncio-task.rst:80
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"La fonction :func:`asyncio.create_task` pour exécuter de manière concurrente "
"des coroutines en tant que :class:`tâches <Task>` *asyncio*."

#: library/asyncio-task.rst:83
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Modifions l'exemple ci-dessus et lançons deux coroutines ``say_after`` *de "
"manière concurrente* ::"

#: library/asyncio-task.rst:86
msgid ""
"async def main():\n"
"    task1 = asyncio.create_task(\n"
"        say_after(1, 'hello'))\n"
"\n"
"    task2 = asyncio.create_task(\n"
"        say_after(2, 'world'))\n"
"\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # Wait until both tasks are completed (should take\n"
"    # around 2 seconds.)\n"
"    await task1\n"
"    await task2\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""

#: library/asyncio-task.rst:102
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"La sortie attendue montre à présent que ce code s'exécute une seconde plus "
"rapidement que le précédent ::"

#: library/asyncio-task.rst:105
msgid ""
"started at 17:14:32\n"
"hello\n"
"world\n"
"finished at 17:14:34"
msgstr ""

#: library/asyncio-task.rst:110
msgid ""
"The :class:`asyncio.TaskGroup` class provides a more modern alternative to :"
"func:`create_task`. Using this API, the last example becomes::"
msgstr ""
"La classe :class:`asyncio.TaskGroup` fournit une alternative plus moderne à :"
"func:`create_task`. En utilisant cette API, le dernier exemple devient ::"

#: library/asyncio-task.rst:114
msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(\n"
"            say_after(1, 'hello'))\n"
"\n"
"        task2 = tg.create_task(\n"
"            say_after(2, 'world'))\n"
"\n"
"        print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # The await is implicit when the context manager exits.\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""

#: library/asyncio-task.rst:128
msgid "The timing and output should be the same as for the previous version."
msgstr ""
"Le temps d'exécution et la sortie doivent être les mêmes que pour la version "
"précédente."

#: library/asyncio-task.rst:130
msgid ":class:`asyncio.TaskGroup`."
msgstr ":class:`asyncio.TaskGroup`."

#: library/asyncio-task.rst:137
msgid "Awaitables"
msgstr "*Attendables*"

#: library/asyncio-task.rst:139
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Un objet est dit *attendable* (*awaitable* en anglais, c.-à-d. qui peut être "
"attendu) s'il peut être utilisé dans une expression :keyword:`await`. "
"Beaucoup d'API d'*asyncio* sont conçues pour accepter des *attendables*."

#: library/asyncio-task.rst:143
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Il existe trois types principaux d'*attendables* : les **coroutines**, les "
"**tâches** et les **futurs**."

#: library/asyncio-task.rst:149
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Les coroutines sont des *awaitables* et peuvent donc être attendues par "
"d'autres coroutines ::"

#: library/asyncio-task.rst:152
msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Nothing happens if we just call \"nested()\".\n"
"    # A coroutine object is created but not awaited,\n"
"    # so it *won't run at all*.\n"
"    nested()  # will raise a \"RuntimeWarning\".\n"
"\n"
"    # Let's do it differently now and await it:\n"
"    print(await nested())  # will print \"42\".\n"
"\n"
"asyncio.run(main())"
msgstr ""

# suit un :
#: library/asyncio-task.rst:170
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"dans cette documentation, le terme « coroutine » est utilisé pour désigner "
"deux concepts voisins :"

#: library/asyncio-task.rst:173
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "une *fonction coroutine* : une fonction :keyword:`async def` ;"

#: library/asyncio-task.rst:175
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr "un *objet coroutine* : un objet renvoyé par une *fonction coroutine*."

#: library/asyncio-task.rst:180
msgid "Tasks"
msgstr "Tâches"

#: library/asyncio-task.rst:181
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr ""
"Les *tâches* servent à planifier des coroutines de façon à ce qu'elles "
"s'exécutent de manière concurrente."

#: library/asyncio-task.rst:183
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"Lorsqu'une coroutine est encapsulée dans une *tâche* à l'aide de fonctions "
"comme :func:`asyncio.create_task`, la coroutine est automatiquement "
"planifiée pour s'exécuter prochainement ::"

#: library/asyncio-task.rst:187
msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Schedule nested() to run soon concurrently\n"
"    # with \"main()\".\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # \"task\" can now be used to cancel \"nested()\", or\n"
"    # can simply be awaited to wait until it is complete:\n"
"    await task\n"
"\n"
"asyncio.run(main())"
msgstr ""

#: library/asyncio-task.rst:205
msgid "Futures"
msgstr "Futurs"

#: library/asyncio-task.rst:206
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
"Un :class:`Future` est un objet *attendable* spécial de **bas-niveau**, qui "
"représente le **résultat final** d'une opération asynchrone."

#: library/asyncio-task.rst:209
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Quand un objet *Future* est *attendu*, cela signifie que la coroutine "
"attendra que ce futur soit résolu à un autre endroit."

#: library/asyncio-task.rst:212
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Les objets *Future* d'*asyncio* sont nécessaires pour permettre l'exécution "
"de code basé sur les fonctions de rappel avec la syntaxe *async* / *await*."

#: library/asyncio-task.rst:215
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Il est normalement **inutile** de créer des objets *Future* dans la couche "
"applicative du code."

#: library/asyncio-task.rst:218
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Les objets *Future*, parfois exposés par des bibliothèques et quelques API "
"d'*asyncio*, peuvent être attendus ::"

#: library/asyncio-task.rst:221
msgid ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # this is also valid:\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"        some_python_coroutine()\n"
"    )"
msgstr ""

#: library/asyncio-task.rst:230
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
":meth:`loop.run_in_executor` est l'exemple typique d'une fonction bas-niveau "
"renvoyant un objet *Future*."

#: library/asyncio-task.rst:235
msgid "Creating Tasks"
msgstr "Création de tâches"

#: library/asyncio-task.rst:237
msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr "**Code source :** :source:`Lib/asyncio/tasks.py`"

#: library/asyncio-task.rst:243
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Encapsule la :ref:`coroutine <coroutine>` *coro* dans une tâche et la "
"planifie pour exécution. Renvoie l'objet :class:`Task`."

#: library/asyncio-task.rst:246
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""
"Si *name* n’est pas ``None``, il est défini comme le nom de la tâche en "
"utilisant :meth:`Task.set_name`."

#: library/asyncio-task.rst:249
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"L'argument (uniquement nommé) facultatif *context* permet de spécifier un :"
"class:`contextvars.Context` personnalisé pour la coroutine à exécuter. La "
"copie de contexte actuelle est créée lorsqu'aucun *context* n'est fourni."

#: library/asyncio-task.rst:253
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"La tâche est exécutée dans la boucle renvoyée par :func:"
"`get_running_loop` ; :exc:`RuntimeError` est levée s'il n'y a pas de boucle "
"en cours d'exécution dans le fil actuel."

#: library/asyncio-task.rst:259
#, fuzzy
msgid ""
":meth:`asyncio.TaskGroup.create_task` is a new alternative leveraging "
"structural concurrency; it allows for waiting for a group of related tasks "
"with strong safety guarantees."
msgstr ""
":meth:`asyncio.TaskGroup.create_task` est une alternative plus récente qui "
"permet d'attendre facilement un groupe de tâches associées."

# suit un :
#: library/asyncio-task.rst:265
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""
"gardez une référence au résultat de cette fonction, pour éviter qu'une tâche "
"ne disparaisse en cours d'exécution. La boucle d'événements ne conserve que "
"les références faibles aux tâches. Une tâche qui n'est pas référencée "
"ailleurs peut être supprimée par le ramasse-miettes à tout moment, même "
"avant qu'elle ne soit terminée. Pour créer des tâches d'arrière-plan fiables "
"de type « lance et oublie », rassemblez-les dans une collection ::"

#: library/asyncio-task.rst:272
msgid ""
"background_tasks = set()\n"
"\n"
"for i in range(10):\n"
"    task = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # Add task to the set. This creates a strong reference.\n"
"    background_tasks.add(task)\n"
"\n"
"    # To prevent keeping references to finished tasks forever,\n"
"    # make each task remove its own reference from the set after\n"
"    # completion:\n"
"    task.add_done_callback(background_tasks.discard)"
msgstr ""

# suit un :
#: library/asyncio-task.rst:1188
msgid "Added the *name* parameter."
msgstr "ajout du paramètre *name*."

# suit un :
#: library/asyncio-task.rst:1195
msgid "Added the *context* parameter."
msgstr "ajout du paramètre *context*."

#: library/asyncio-task.rst:295
msgid "Task Cancellation"
msgstr "Annulation de tâche"

#: library/asyncio-task.rst:297
msgid ""
"Tasks can easily and safely be cancelled. When a task is cancelled, :exc:"
"`asyncio.CancelledError` will be raised in the task at the next opportunity."
msgstr ""
"Les tâches peuvent être annulées facilement et en toute sécurité. Lorsqu'une "
"tâche est annulée, :exc:`asyncio.CancelledError` est levée dans la tâche à "
"la première occasion."

#: library/asyncio-task.rst:301
msgid ""
"It is recommended that coroutines use ``try/finally`` blocks to robustly "
"perform clean-up logic. In case :exc:`asyncio.CancelledError` is explicitly "
"caught, it should generally be propagated when clean-up is complete. :exc:"
"`asyncio.CancelledError` directly subclasses :exc:`BaseException` so most "
"code will not need to be aware of it."
msgstr ""
"Il est recommandé que les coroutines utilisent des blocs ``try/finally`` "
"pour exécuter de manière robuste la logique de nettoyage. Dans le cas où :"
"exc:`asyncio.CancelledError` est explicitement interceptée, elle devrait "
"généralement être propagée lorsque le nettoyage est terminé. :exc:`asyncio."
"CancelledError` sous-classe directement :exc:`BaseException` donc la plupart "
"du code n'a pas besoin d'en être conscient."

#: library/asyncio-task.rst:307
msgid ""
"The asyncio components that enable structured concurrency, like :class:"
"`asyncio.TaskGroup` and :func:`asyncio.timeout`, are implemented using "
"cancellation internally and might misbehave if a coroutine swallows :exc:"
"`asyncio.CancelledError`. Similarly, user code should not generally call :"
"meth:`uncancel <asyncio.Task.uncancel>`. However, in cases when suppressing :"
"exc:`asyncio.CancelledError` is truly desired, it is necessary to also call "
"``uncancel()`` to completely remove the cancellation state."
msgstr ""
"Les composants *asyncio* qui permettent la concurrence structurée, comme :"
"class:`asyncio.TaskGroup` et :func:`asyncio.timeout`, sont implémentés en "
"utilisant l'annulation en interne et peuvent mal se comporter si une "
"coroutine ne propage pas :exc:`asyncio.CancelledError`. De même, le code "
"utilisateur ne doit généralement pas appeler :meth:`uncancel<asyncio.Task."
"uncancel>`. Cependant, dans les cas où la suppression de :exc:`asyncio."
"CancelledError` est vraiment souhaitée, il est également nécessaire "
"d'appeler ``uncancel()`` pour supprimer complètement l'état d'annulation."

#: library/asyncio-task.rst:319
msgid "Task Groups"
msgstr "Groupes de tâches"

#: library/asyncio-task.rst:321
msgid ""
"Task groups combine a task creation API with a convenient and reliable way "
"to wait for all tasks in the group to finish."
msgstr ""
"Les groupes de tâches combinent une API de création de tâches avec un moyen "
"pratique et fiable d'attendre la fin de toutes les tâches du groupe."

#: library/asyncio-task.rst:326
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` holding a "
"group of tasks. Tasks can be added to the group using :meth:`create_task`. "
"All tasks are awaited when the context manager exits."
msgstr ""
":ref:`Gestionnaire de contexte asynchrone <async-context-managers>` "
"responsable d’un groupe de tâches. Des tâches peuvent être ajoutées au "
"groupe en utilisant :meth:`create_task`. Toutes les tâches sont attendues à "
"la sortie du gestionnaire de contexte."

#: library/asyncio-task.rst:335
msgid ""
"Create a task in this task group. The signature matches that of :func:"
"`asyncio.create_task`. If the task group is inactive (e.g. not yet entered, "
"already finished, or in the process of shutting down), we will close the "
"given ``coro``."
msgstr ""

#: library/asyncio-task.rst:343
msgid "Close the given coroutine if the task group is not active."
msgstr ""

#: library/asyncio-task.rst:550 library/asyncio-task.rst:781
#: library/asyncio-task.rst:847
msgid "Example::"
msgstr "Exemple ::"

#: library/asyncio-task.rst:347
msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(some_coro(...))\n"
"        task2 = tg.create_task(another_coro(...))\n"
"    print(f\"Both tasks have completed now: {task1.result()}, {task2."
"result()}\")"
msgstr ""

#: library/asyncio-task.rst:353
msgid ""
"The ``async with`` statement will wait for all tasks in the group to finish. "
"While waiting, new tasks may still be added to the group (for example, by "
"passing ``tg`` into one of the coroutines and calling ``tg.create_task()`` "
"in that coroutine). Once the last task has finished and the ``async with`` "
"block is exited, no new tasks may be added to the group."
msgstr ""
"L'instruction ``async with`` attend la fin de toutes les tâches du groupe. "
"Lors de l'attente, de nouvelles tâches peuvent encore être ajoutées au "
"groupe (par exemple, en passant ``tg`` dans l'une des coroutines et en "
"appelant ``tg.create_task()`` dans cette coroutine). Une fois que la "
"dernière tâche est terminée et que le bloc ``async with`` est quitté, aucune "
"nouvelle tâche ne peut être ajoutée au groupe."

#: library/asyncio-task.rst:360
msgid ""
"The first time any of the tasks belonging to the group fails with an "
"exception other than :exc:`asyncio.CancelledError`, the remaining tasks in "
"the group are cancelled. No further tasks can then be added to the group. At "
"this point, if the body of the ``async with`` statement is still active (i."
"e., :meth:`~object.__aexit__` hasn't been called yet), the task directly "
"containing the ``async with`` statement is also cancelled. The resulting :"
"exc:`asyncio.CancelledError` will interrupt an ``await``, but it will not "
"bubble out of the containing ``async with`` statement."
msgstr ""
"La première fois que l'une des tâches appartenant au groupe échoue avec une "
"exception autre que :exc:`asyncio.CancelledError`, les tâches restantes du "
"groupe sont annulées. Aucune autre tâche ne peut alors être ajoutée au "
"groupe. À ce stade, si le corps de l'instruction ``async with`` est toujours "
"actif (par exemple, :meth:`~object.__aexit__` n'a pas encore été appelé), la "
"tâche contenant directement l'instruction ``async with`` est également "
"annulée. Le résultat :exc:`asyncio.CancelledError` interrompt un ``await``, "
"mais il ne sort pas de l'instruction ``async with`` englobante."

#: library/asyncio-task.rst:370
msgid ""
"Once all tasks have finished, if any tasks have failed with an exception "
"other than :exc:`asyncio.CancelledError`, those exceptions are combined in "
"an :exc:`ExceptionGroup` or :exc:`BaseExceptionGroup` (as appropriate; see "
"their documentation) which is then raised."
msgstr ""
"Une fois toutes les tâches terminées, si des tâches ont échoué avec une "
"exception autre que :exc:`asyncio.CancelledError`, ces exceptions sont "
"combinées dans un :exc:`ExceptionGroup` ou :exc:`BaseExceptionGroup` (selon "
"le cas ; voir leur documentation) qui est ensuite levé."

#: library/asyncio-task.rst:377
msgid ""
"Two base exceptions are treated specially: If any task fails with :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit`, the task group still cancels the "
"remaining tasks and waits for them, but then the initial :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit` is re-raised instead of :exc:"
"`ExceptionGroup` or :exc:`BaseExceptionGroup`."
msgstr ""
"Deux exceptions de base sont traitées spécialement : si une tâche échoue "
"avec :exc:`KeyboardInterrupt` ou :exc:`SystemExit`, le groupe de tâches "
"annule toujours les tâches restantes et les attend, mais alors la :exc:"
"`KeyboardInterrupt` ou la :exc:`SystemExit` initiale est levée à nouveau au "
"lieu de :exc:`ExceptionGroup` ou :exc:`BaseExceptionGroup`."

#: library/asyncio-task.rst:383
msgid ""
"If the body of the ``async with`` statement exits with an exception (so :"
"meth:`~object.__aexit__` is called with an exception set), this is treated "
"the same as if one of the tasks failed: the remaining tasks are cancelled "
"and then waited for, and non-cancellation exceptions are grouped into an "
"exception group and raised. The exception passed into :meth:`~object."
"__aexit__`, unless it is :exc:`asyncio.CancelledError`, is also included in "
"the exception group. The same special case is made for :exc:"
"`KeyboardInterrupt` and :exc:`SystemExit` as in the previous paragraph."
msgstr ""
"Si le corps de l'instruction ``async with`` se termine avec une exception "
"(donc :meth:`~object.__aexit__` est appelé avec un ensemble d'exceptions), "
"cela est traité de la même manière que si l'une des tâches échouait : les "
"tâches restantes sont annulées puis attendues, et les exceptions de non-"
"annulation sont regroupées dans un groupe d'exceptions et levées. "
"L'exception transmise à :meth:`~object.__aexit__`, à moins qu'il ne s'agisse "
"de :exc:`asyncio.CancelledError`, est également incluse dans le groupe "
"d'exceptions. Le même cas spécial concerne :exc:`KeyboardInterrupt` et :exc:"
"`SystemExit` comme dans le paragraphe précédent."

#: library/asyncio-task.rst:395
msgid ""
"Task groups are careful not to mix up the internal cancellation used to "
"\"wake up\" their :meth:`~object.__aexit__` with cancellation requests for "
"the task in which they are running made by other parties. In particular, "
"when one task group is syntactically nested in another, and both experience "
"an exception in one of their child tasks simultaneously, the inner task "
"group will process its exceptions, and then the outer task group will "
"receive another cancellation and process its own exceptions."
msgstr ""

#: library/asyncio-task.rst:403
msgid ""
"In the case where a task group is cancelled externally and also must raise "
"an :exc:`ExceptionGroup`, it will call the parent task's :meth:`~asyncio."
"Task.cancel` method. This ensures that a :exc:`asyncio.CancelledError` will "
"be raised at the next :keyword:`await`, so the cancellation is not lost."
msgstr ""

#: library/asyncio-task.rst:409
msgid ""
"Task groups preserve the cancellation count reported by :meth:`asyncio.Task."
"cancelling`."
msgstr ""

#: library/asyncio-task.rst:414
msgid ""
"Improved handling of simultaneous internal and external cancellations and "
"correct preservation of cancellation counts."
msgstr ""

#: library/asyncio-task.rst:418
msgid "Terminating a Task Group"
msgstr ""

#: library/asyncio-task.rst:420
msgid ""
"While terminating a task group is not natively supported by the standard "
"library, termination can be achieved by adding an exception-raising task to "
"the task group and ignoring the raised exception:"
msgstr ""

#: library/asyncio-task.rst:424
msgid ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Exception raised to terminate a task group.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Used to force termination of a task group.\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Task {task_id}: start')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Task {task_id}: done')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # spawn some tasks\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # sleep for 1 second\n"
"            await asyncio.sleep(1)\n"
"            # add an exception-raising task to force the group to terminate\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"
msgstr ""

#: library/asyncio-task.rst:456
#, fuzzy
msgid "Expected output:"
msgstr "Sortie attendue ::"

#: library/asyncio-task.rst:458
msgid ""
"Task 1: start\n"
"Task 2: start\n"
"Task 1: done"
msgstr ""

#: library/asyncio-task.rst:465
msgid "Sleeping"
msgstr "Attente"

#: library/asyncio-task.rst:469
msgid "Block for *delay* seconds."
msgstr "Attend pendant *delay* secondes."

#: library/asyncio-task.rst:471
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Si *result* est spécifié, il est renvoyé à l'appelant quand la coroutine se "
"termine."

#: library/asyncio-task.rst:474
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` suspend systématiquement la tâche courante, ce qui permet aux "
"autres tâches de s'exécuter."

#: library/asyncio-task.rst:477
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""
"Définir le délai sur 0 fournit un chemin optimisé pour permettre à d'autres "
"tâches de s'exécuter. Cela peut être utilisé par les fonctions de longue "
"durée pour éviter de bloquer la boucle d'événements pendant toute la durée "
"de l'appel de fonction."

#: library/asyncio-task.rst:483
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Exemple d'une coroutine affichant la date toutes les secondes pendant 5 "
"secondes ::"

#: library/asyncio-task.rst:486
msgid ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    while True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"
msgstr ""

# suit un :
#: library/asyncio-task.rst:599 library/asyncio-task.rst:872
#: library/asyncio-task.rst:983
msgid "Removed the *loop* parameter."
msgstr "le paramètre *loop* a été enlevé."

#: library/asyncio-task.rst:504
msgid "Raises :exc:`ValueError` if *delay* is :data:`~math.nan`."
msgstr ""

#: library/asyncio-task.rst:509
msgid "Running Tasks Concurrently"
msgstr "Exécution de tâches de manière concurrente"

#: library/asyncio-task.rst:513
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Exécute les objets :ref:`awaitable <asyncio-awaitables>` de la séquence "
"*aws*, *de manière concurrente*."

#: library/asyncio-task.rst:516
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Si un *attendable* de *aws* est une coroutine, celui-ci est automatiquement "
"planifié comme une tâche *Task*."

#: library/asyncio-task.rst:519
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Si tous les *awaitables* s'achèvent avec succès, le résultat est la liste "
"des valeurs renvoyées. L'ordre de cette liste correspond à l'ordre des "
"*awaitables* dans *aws*."

#: library/asyncio-task.rst:523
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Si *return_exceptions* vaut ``False`` (valeur par défaut), la première "
"exception levée est immédiatement propagée vers la tâche en attente dans le "
"``gather()``. Les autres *attendables* dans la séquence *aws* **ne sont pas "
"annulés** et poursuivent leur exécution."

#: library/asyncio-task.rst:528
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Si *return_exceptions* vaut ``True``, les exceptions sont traitées de la "
"même manière que les exécutions normales, et incluses dans la liste des "
"résultats."

#: library/asyncio-task.rst:531
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Si ``gather()`` est *annulé*, tous les *awaitables* en cours (ceux qui n'ont "
"pas encore fini de s'exécuter) sont également *annulés*."

#: library/asyncio-task.rst:534
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Si n'importe quel *Task* ou *Future* de la séquence *aws* est *annulé*, il "
"est traité comme s'il avait levé :exc:`CancelledError` — l'appel à "
"``gather()`` n'est alors **pas** annulé. Ceci permet d'empêcher que "
"l'annulation d'une tâche ou d'un futur entraîne l'annulation des autres "
"tâches ou futurs."

#: library/asyncio-task.rst:541
msgid ""
"A new alternative to create and run tasks concurrently and wait for their "
"completion is :class:`asyncio.TaskGroup`. *TaskGroup* provides stronger "
"safety guarantees than *gather* for scheduling a nesting of subtasks: if a "
"task (or a subtask, a task scheduled by a task) raises an exception, "
"*TaskGroup* will, while *gather* will not, cancel the remaining scheduled "
"tasks)."
msgstr ""

#: library/asyncio-task.rst:552
msgid ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Task {name}: Compute factorial({number}), currently i={i}..."
"\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Task {name}: factorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # Schedule three calls *concurrently*:\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     Task A: Compute factorial(2), currently i=2...\n"
"#     Task B: Compute factorial(3), currently i=2...\n"
"#     Task C: Compute factorial(4), currently i=2...\n"
"#     Task A: factorial(2) = 2\n"
"#     Task B: Compute factorial(3), currently i=3...\n"
"#     Task C: Compute factorial(4), currently i=3...\n"
"#     Task B: factorial(3) = 6\n"
"#     Task C: Compute factorial(4), currently i=4...\n"
"#     Task C: factorial(4) = 24\n"
"#     [2, 6, 24]"
msgstr ""

#: library/asyncio-task.rst:588
#, fuzzy
msgid ""
"If *return_exceptions* is false, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"Si *return_exceptions* est faux, l'annulation de la fonction *gather* après "
"qu'elle a été marquée comme terminée n'annule pas les *attendables* soumis. "
"Par exemple, *gather* peut être marquée comme terminée après avoir propagé "
"une exception à l'appelant, par conséquent, appeler ``gather.cancel()`` "
"après avoir intercepté une exception (levée par l'un des *attendables*) de "
"la collecte n'annule aucun autre *attendable*."

#: library/asyncio-task.rst:595
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Si *gather* est lui-même annulé, l'annulation est propagée indépendamment de "
"*return_exceptions*."

#: library/asyncio-task.rst:602
msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr ""
"Un avertissement d'obsolescence est émis si aucun argument positionnel n'est "
"fourni ou si tous les arguments positionnels ne sont pas des objets de type "
"Future et qu'il n'y a pas de boucle d'événements en cours d'exécution."

#: library/asyncio-task.rst:611
msgid "Eager Task Factory"
msgstr ""

#: library/asyncio-task.rst:615
msgid "A task factory for eager task execution."
msgstr ""

#: library/asyncio-task.rst:617
msgid ""
"When using this factory (via :meth:`loop.set_task_factory(asyncio."
"eager_task_factory) <loop.set_task_factory>`), coroutines begin execution "
"synchronously during :class:`Task` construction. Tasks are only scheduled on "
"the event loop if they block. This can be a performance improvement as the "
"overhead of loop scheduling is avoided for coroutines that complete "
"synchronously."
msgstr ""

#: library/asyncio-task.rst:623
msgid ""
"A common example where this is beneficial is coroutines which employ caching "
"or memoization to avoid actual I/O when possible."
msgstr ""

#: library/asyncio-task.rst:628
msgid ""
"Immediate execution of the coroutine is a semantic change. If the coroutine "
"returns or raises, the task is never scheduled to the event loop. If the "
"coroutine execution blocks, the task is scheduled to the event loop. This "
"change may introduce behavior changes to existing applications. For example, "
"the application's task execution order is likely to change."
msgstr ""

#: library/asyncio-task.rst:639
msgid ""
"Create an eager task factory, similar to :func:`eager_task_factory`, using "
"the provided *custom_task_constructor* when creating a new task instead of "
"the default :class:`Task`."
msgstr ""

#: library/asyncio-task.rst:643
msgid ""
"*custom_task_constructor* must be a *callable* with the signature matching "
"the signature of :class:`Task.__init__ <Task>`. The callable must return a :"
"class:`asyncio.Task`-compatible object."
msgstr ""

#: library/asyncio-task.rst:647
msgid ""
"This function returns a *callable* intended to be used as a task factory of "
"an event loop via :meth:`loop.set_task_factory(factory) <loop."
"set_task_factory>`)."
msgstr ""

#: library/asyncio-task.rst:654
msgid "Shielding From Cancellation"
msgstr "Protection contre l'annulation"

#: library/asyncio-task.rst:658
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Empêche qu'un objet :ref:`awaitable <asyncio-awaitables>` puisse être :meth:"
"`annulé <Task.cancel>`."

#: library/asyncio-task.rst:827
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr ""
"Si *aw* est une coroutine, elle est planifiée automatiquement comme une "
"tâche."

#: library/asyncio-task.rst:663
msgid "The statement::"
msgstr "L'instruction ::"

#: library/asyncio-task.rst:665
msgid ""
"task = asyncio.create_task(something())\n"
"res = await shield(task)"
msgstr ""

#: library/asyncio-task.rst:668
msgid "is equivalent to::"
msgstr "est équivalente à ::"

#: library/asyncio-task.rst:670
msgid "res = await something()"
msgstr ""

#: library/asyncio-task.rst:672
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*à la différence près* que, si la coroutine qui la contient est annulée, la "
"tâche s'exécutant dans ``something()`` n'est pas annulée. Du point de vue de "
"``something()``, il n'y a pas eu d'annulation. Cependant, son appelant est "
"bien annulé, donc l'expression *await* lève bien une :exc:`CancelledError`."

#: library/asyncio-task.rst:678
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Si ``something()`` est annulée d'une autre façon (c.-à-d. depuis elle-même) "
"ceci annule également ``shield()``."

#: library/asyncio-task.rst:681
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Pour ignorer complètement l'annulation (déconseillé), la fonction "
"``shield()`` peut être combinée à une clause *try* / *except*, comme dans le "
"code ci-dessous ::"

#: library/asyncio-task.rst:685
msgid ""
"task = asyncio.create_task(something())\n"
"try:\n"
"    res = await shield(task)\n"
"except CancelledError:\n"
"    res = None"
msgstr ""

# suit un :
#: library/asyncio-task.rst:693
msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""
"sauvegardez une référence aux tâches passées à cette fonction, pour éviter "
"qu'une tâche ne disparaisse en cours d'exécution. La boucle d'événements ne "
"conserve que les références faibles aux tâches. Une tâche qui n'est pas "
"référencée ailleurs peut faire l'objet d'une suppression par le ramasse-"
"miettes à tout moment, même avant qu'elle ne soit terminée."

# suit un :
#: library/asyncio-task.rst:701
msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr ""
"un avertissement d'obsolescence est émis si *aw* n'est pas un objet de type "
"*future* et qu'il n'y a pas de boucle d'événement en cours d'exécution."

#: library/asyncio-task.rst:707
msgid "Timeouts"
msgstr "Délais d'attente"

#: library/asyncio-task.rst:711
#, fuzzy
msgid ""
"Return an :ref:`asynchronous context manager <async-context-managers>` that "
"can be used to limit the amount of time spent waiting on something."
msgstr ""
":ref:`Gestionnaire de contexte asynchrone <async-context-managers>` qui peut "
"être utilisé pour limiter le temps passé à attendre quelque chose."

#: library/asyncio-task.rst:715
msgid ""
"*delay* can either be ``None``, or a float/int number of seconds to wait. If "
"*delay* is ``None``, no time limit will be applied; this can be useful if "
"the delay is unknown when the context manager is created."
msgstr ""
"*delay* peut-être soit ``None``, soit le nombre de secondes (entier ou "
"décimal) d'attente. Si *delay* vaut ``None``, aucune limite n'est "
"appliquée ; cela peut être utile lorsque le délai d'attente est inconnu au "
"moment de la création du gestionnaire de contexte."

#: library/asyncio-task.rst:720
msgid ""
"In either case, the context manager can be rescheduled after creation using :"
"meth:`Timeout.reschedule`."
msgstr ""
"Dans les deux cas, le gestionnaire de contexte peut être redéfini après sa "
"création en utilisant :meth:`Timeout.reschedule`."

#: library/asyncio-task.rst:725
msgid ""
"async def main():\n"
"    async with asyncio.timeout(10):\n"
"        await long_running_task()"
msgstr ""

#: library/asyncio-task.rst:729
#, fuzzy
msgid ""
"If ``long_running_task`` takes more than 10 seconds to complete, the context "
"manager will cancel the current task and handle the resulting :exc:`asyncio."
"CancelledError` internally, transforming it into a :exc:`TimeoutError` which "
"can be caught and handled."
msgstr ""
"Si ``long_running_task`` prend plus de 10 secondes pour se terminer, le "
"gestionnaire de contexte annule la tâche en cours et traite l'erreur :exc:"
"`asyncio.CancelledError` en interne, la transformant en une :exc:`asyncio."
"TimeoutError` qui peut être interceptée et gérée."

# suit un :
#: library/asyncio-task.rst:736
#, fuzzy
msgid ""
"The :func:`asyncio.timeout` context manager is what transforms the :exc:"
"`asyncio.CancelledError` into a :exc:`TimeoutError`, which means the :exc:"
"`TimeoutError` can only be caught *outside* of the context manager."
msgstr ""
"le gestionnaire de contexte :func:`asyncio.timeout` est ce qui transforme "
"la :exc:`asyncio.CancelledError` en une :exc:`asyncio.TimeoutError`, ce qui "
"signifie que la :exc:`asyncio.TimeoutError` ne peut être interceptée qu' *en "
"dehors* du gestionnaire de contexte."

#: library/asyncio-task.rst:741
#, fuzzy
msgid "Example of catching :exc:`TimeoutError`::"
msgstr "Exemple de capture :exc:`asyncio.TimeoutError` ::"

#: library/asyncio-task.rst:743
msgid ""
"async def main():\n"
"    try:\n"
"        async with asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""

#: library/asyncio-task.rst:752
msgid ""
"The context manager produced by :func:`asyncio.timeout` can be rescheduled "
"to a different deadline and inspected."
msgstr ""
"Le gestionnaire de contexte produit par :func:`asyncio.timeout` peut être "
"reprogrammé à une échéance différente et inspecté."

#: library/asyncio-task.rst:757
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` for "
"cancelling overdue coroutines."
msgstr ""
":ref:`Gestionnaire de contexte asynchrone <async-context-managers>` pour "
"annuler les coroutines en retard."

#: library/asyncio-task.rst:760
msgid ""
"``when`` should be an absolute time at which the context should time out, as "
"measured by the event loop's clock:"
msgstr ""
"``when`` doit être un temps absolu au bout duquel le contexte doit expirer, "
"tel que mesuré par l'horloge de la boucle d'événements :"

#: library/asyncio-task.rst:763
msgid "If ``when`` is ``None``, the timeout will never trigger."
msgstr "Si ``when`` vaut ``None``, le délai maximal ne se déclenche jamais."

#: library/asyncio-task.rst:764
msgid ""
"If ``when < loop.time()``, the timeout will trigger on the next iteration of "
"the event loop."
msgstr ""
"Si ``when < loop.time()``, le délai maximal se déclenche à la prochaine "
"itération de la boucle d'événement."

#: library/asyncio-task.rst:769
msgid ""
"Return the current deadline, or ``None`` if the current deadline is not set."
msgstr ""
"Renvoie la limite de temps d'exécution définie actuellement, ou ``None`` "
"s'il n'y en a pas."

#: library/asyncio-task.rst:774
msgid "Reschedule the timeout."
msgstr "Reprogramme le délai d'attente."

#: library/asyncio-task.rst:778
msgid "Return whether the context manager has exceeded its deadline (expired)."
msgstr ""
"Renvoie si le gestionnaire de contexte a dépassé son délai (c.-à-d. s'il a "
"expiré)."

#: library/asyncio-task.rst:783
msgid ""
"async def main():\n"
"    try:\n"
"        # We do not know the timeout when starting, so we pass ``None``.\n"
"        async with asyncio.timeout(None) as cm:\n"
"            # We know the timeout now, so we reschedule it.\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(new_deadline)\n"
"\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        pass\n"
"\n"
"    if cm.expired():\n"
"        print(\"Looks like we haven't finished on time.\")"
msgstr ""

#: library/asyncio-task.rst:798
msgid "Timeout context managers can be safely nested."
msgstr ""
"Les gestionnaires de contexte de délai maximal peuvent être imbriqués en "
"toute sécurité."

#: library/asyncio-task.rst:804
msgid ""
"Similar to :func:`asyncio.timeout`, except *when* is the absolute time to "
"stop waiting, or ``None``."
msgstr ""
"Semblable à :func:`asyncio.timeout`, sauf que *when* est le temps absolu "
"pour arrêter d'attendre, ou ``None``."

#: library/asyncio-task.rst:809
msgid ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline = loop.time() + 20\n"
"    try:\n"
"        async with asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""

#: library/asyncio-task.rst:824
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Attend la fin de l':ref:`awaitable <asyncio-awaitables>` *aw* avec délai "
"d'attente."

#: library/asyncio-task.rst:829
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* peut-être soit ``None``, soit le nombre de secondes (entier ou "
"décimal) d'attente. Si *timeout* vaut ``None``, la fonction s'interrompt "
"jusqu'à ce que le futur s'achève."

#: library/asyncio-task.rst:833
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`TimeoutError`."
msgstr ""
"Si le délai d'attente maximal est dépassé, la tâche est annulée et "
"l'exception :exc:`TimeoutError` est levée."

#: library/asyncio-task.rst:836
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Pour empêcher :meth:`l'annulation <Task.cancel>` de la tâche, il est "
"nécessaire de l'encapsuler dans une fonction :func:`shield`."

#: library/asyncio-task.rst:839
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"Cette fonction attend que le futur soit réellement annulé, donc le temps "
"d'attente total peut être supérieur à *timeout*. Si une exception se produit "
"lors de l'annulation, elle est propagée."

#: library/asyncio-task.rst:843
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Si l'attente est annulée, le futur *aw* est également annulé."

#: library/asyncio-task.rst:849
msgid ""
"async def eternity():\n"
"    # Sleep for one hour\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # Wait for at most 1 second\n"
"    try:\n"
"        await asyncio.wait_for(eternity(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     timeout!"
msgstr ""

#: library/asyncio-task.rst:867
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`TimeoutError` immediately."
msgstr ""
"Si le dépassement du délai d'attente maximal provoque l'annulation de *aw*, "
"``wait_for`` attend que *aw* soit annulée. Auparavant, l'exception :exc:"
"`TimeoutError` était immédiatement levée."

#: library/asyncio-task.rst:875
#, fuzzy
msgid "Raises :exc:`TimeoutError` instead of :exc:`asyncio.TimeoutError`."
msgstr ""
"Lève une exception :exc:`TimeoutError` si le délai d'attente est dépassé "
"avant que tous les futurs ne soient achevés."

#: library/asyncio-task.rst:880
msgid "Waiting Primitives"
msgstr "Primitives d'attente"

#: library/asyncio-task.rst:884
msgid ""
"Run :class:`~asyncio.Future` and :class:`~asyncio.Task` instances in the "
"*aws* iterable concurrently and block until the condition specified by "
"*return_when*."
msgstr ""
"Exécute les instances :class:`~asyncio.Future` et :class:`~asyncio.Task` de "
"l'itérable *aws* de manière concurrente, et s'interrompt jusqu'à ce que la "
"condition décrite dans *return_when* soit vraie."

#: library/asyncio-task.rst:888
#, fuzzy
msgid "The *aws* iterable must not be empty."
msgstr "L'itérable *aws* ne doit pas être vide."

#: library/asyncio-task.rst:890
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Renvoie deux ensembles de *Tasks* / *Futures* : ``(done, pending)``."

#: library/asyncio-task.rst:892
msgid "Usage::"
msgstr "Utilisation ::"

#: library/asyncio-task.rst:894
msgid "done, pending = await asyncio.wait(aws)"
msgstr ""

#: library/asyncio-task.rst:896
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (entier ou décimal), si précisé, peut-être utilisé pour contrôler "
"le nombre maximal de secondes d'attente avant de se terminer."

#: library/asyncio-task.rst:899
msgid ""
"Note that this function does not raise :exc:`TimeoutError`. Futures or Tasks "
"that aren't done when the timeout occurs are simply returned in the second "
"set."
msgstr ""
"Cette fonction ne lève pas :exc:`TimeoutError`. Les futurs et les tâches qui "
"ne sont pas finis quand le délai d'attente maximal est dépassé sont tout "
"simplement renvoyés dans le second ensemble."

#: library/asyncio-task.rst:903
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* indique quand la fonction doit se terminer. Il peut prendre "
"les valeurs suivantes :"

#: library/asyncio-task.rst:909
msgid "Constant"
msgstr "Constante"

#: library/asyncio-task.rst:910
msgid "Description"
msgstr "Description"

#: library/asyncio-task.rst:913
msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"La fonction se termine lorsque n'importe quel futur se termine ou est annulé."

#: library/asyncio-task.rst:916
#, fuzzy
msgid ""
"The function will return when any future finishes by raising an exception. "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"La fonction se termine lorsque n'importe quel futur se termine en levant une "
"exception. Si aucun *futur* ne lève d'exception, équivaut à :const:"
"`ALL_COMPLETED`."

#: library/asyncio-task.rst:921
msgid "The function will return when all futures finish or are cancelled."
msgstr ""
"La fonction se termine lorsque les *futurs* sont tous finis ou annulés."

#: library/asyncio-task.rst:923
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"À la différence de :func:`~asyncio.wait_for`, ``wait()`` n'annule pas les "
"futurs quand le délai d'attente est dépassé."

#: library/asyncio-task.rst:929
msgid "Passing coroutine objects to ``wait()`` directly is forbidden."
msgstr "Passer directement des objets coroutines à ``wait()`` est interdit."

#: library/asyncio-task.rst:990
msgid "Added support for generators yielding tasks."
msgstr ""

#: library/asyncio-task.rst:938
#, fuzzy
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently. The returned object can be iterated to obtain the results of "
"the awaitables as they finish."
msgstr ""
"Exécute les objets :ref:`attendables <asyncio-awaitables>` de l'itérable "
"*aws* de manière concurrente. Renvoie un itérateur sur des coroutines. "
"Chaque coroutine renvoyée peut être attendue pour obtenir le premier "
"résultat suivant de l'ensemble des *attendables* restants."

#: library/asyncio-task.rst:942
msgid ""
"The object returned by ``as_completed()`` can be iterated as an :term:"
"`asynchronous iterator` or a plain :term:`iterator`. When asynchronous "
"iteration is used, the originally-supplied awaitables are yielded if they "
"are tasks or futures. This makes it easy to correlate previously-scheduled "
"tasks with their results. Example::"
msgstr ""

#: library/asyncio-task.rst:948
msgid ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"async for earliest_connect in as_completed(tasks):\n"
"    # earliest_connect is done. The result can be obtained by\n"
"    # awaiting it or calling earliest_connect.result()\n"
"    reader, writer = await earliest_connect\n"
"\n"
"    if earliest_connect is ipv6_connect:\n"
"        print(\"IPv6 connection established.\")\n"
"    else:\n"
"        print(\"IPv4 connection established.\")"
msgstr ""

#: library/asyncio-task.rst:962
msgid ""
"During asynchronous iteration, implicitly-created tasks will be yielded for "
"supplied awaitables that aren't tasks or futures."
msgstr ""

#: library/asyncio-task.rst:965
msgid ""
"When used as a plain iterator, each iteration yields a new coroutine that "
"returns the result or raises the exception of the next completed awaitable. "
"This pattern is compatible with Python versions older than 3.13::"
msgstr ""

#: library/asyncio-task.rst:969
msgid ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"for next_connect in as_completed(tasks):\n"
"    # next_connect is not one of the original task objects. It must be\n"
"    # awaited to obtain the result value or raise the exception of the\n"
"    # awaitable that finishes next.\n"
"    reader, writer = await next_connect"
msgstr ""

#: library/asyncio-task.rst:979
msgid ""
"A :exc:`TimeoutError` is raised if the timeout occurs before all awaitables "
"are done. This is raised by the ``async for`` loop during asynchronous "
"iteration or by the coroutines yielded during plain iteration."
msgstr ""

#: library/asyncio-task.rst:986
msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr ""
"Un avertissement d'obsolescence est émis si tous les objets en attente dans "
"l'itérable *aws* ne sont pas des objets de type *Future* et qu'il n'y a pas "
"de boucle d'événement en cours d'exécution."

#: library/asyncio-task.rst:993
msgid ""
"The result can now be used as either an :term:`asynchronous iterator` or as "
"a plain :term:`iterator` (previously it was only a plain iterator)."
msgstr ""

#: library/asyncio-task.rst:999
msgid "Running in Threads"
msgstr "Exécution dans des fils d'exécution (*threads*)"

#: library/asyncio-task.rst:1003
msgid "Asynchronously run function *func* in a separate thread."
msgstr ""
"Exécute la fonction *func* de manière asynchrone dans un fil d'exécution "
"séparé."

#: library/asyncio-task.rst:1005
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"Tous les *\\*args* et *\\*\\*kwargs* fournis à cette fonction sont "
"directement passés à *func*. De plus, le :class:`contextvars.Context` actuel "
"est propagé, ce qui permet d'accéder aux variables de contexte du fil de "
"boucle d'événements dans le fil séparé."

#: library/asyncio-task.rst:1010
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr ""
"Renvoie une coroutine qui peut être attendue pour obtenir le résultat "
"éventuel de *func*."

#: library/asyncio-task.rst:1012
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were run in the main thread. For example::"
msgstr ""
"Cette fonction coroutine est principalement destinée à être utilisée pour "
"exécuter des fonctions/méthodes faisant beaucoup d'entrées-sorties et qui "
"bloqueraient autrement la boucle d'événements si elles étaient exécutées "
"dans le fil d'exécution principal. Par exemple ::"

#: library/asyncio-task.rst:1016
msgid ""
"def blocking_io():\n"
"    print(f\"start blocking_io at {time.strftime('%X')}\")\n"
"    # Note that time.sleep() can be replaced with any blocking\n"
"    # IO-bound operation, such as file operations.\n"
"    time.sleep(1)\n"
"    print(f\"blocking_io complete at {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f\"started main at {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f\"finished main at {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"# started main at 19:50:53\n"
"# start blocking_io at 19:50:53\n"
"# blocking_io complete at 19:50:54\n"
"# finished main at 19:50:54"
msgstr ""

#: library/asyncio-task.rst:1042
msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""
"Appeler directement ``blocking_io()`` dans n'importe quelle coroutine "
"bloquerait la boucle d'événements pendant sa durée, ce qui entraînerait une "
"seconde supplémentaire de temps d'exécution. Au lieu de cela, en utilisant "
"``asyncio.to_thread()``, nous pouvons l'exécuter dans un fil d'exécution "
"séparé sans bloquer la boucle d'événements."

# suit un :
#: library/asyncio-task.rst:1049
msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""
"en raison du :term:`GIL`, ``asyncio.to_thread()`` ne peut généralement être "
"utilisée que pour rendre les fonctions faisant beaucoup d'entrées-sorties "
"non bloquantes. Cependant, pour les modules d'extension qui relâchent le GIL "
"ou les implémentations Python alternatives qui n'en ont pas, ``asyncio."
"to_thread()`` peut également être utilisée pour les fonctions qui "
"sollicitent beaucoup le processeur."

#: library/asyncio-task.rst:1058
msgid "Scheduling From Other Threads"
msgstr "Planification depuis d'autres fils d'exécution"

#: library/asyncio-task.rst:1062
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr ""
"Enregistre une coroutine dans la boucle d'exécution actuelle. Cette "
"opération est compatible avec les programmes à multiples fils d'exécution "
"(*thread-safe*)."

#: library/asyncio-task.rst:1064
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Renvoie un :class:`concurrent.futures.Future` pour attendre le résultat d'un "
"autre fil d'exécution du système d'exploitation."

#: library/asyncio-task.rst:1067
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Cette fonction est faite pour être appelée par un fil d'exécution distinct "
"de celui dans laquelle la boucle d'événement s'exécute. Exemple ::"

#: library/asyncio-task.rst:1070
msgid ""
"# Create a coroutine\n"
"coro = asyncio.sleep(1, result=3)\n"
"\n"
"# Submit the coroutine to a given loop\n"
"future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"# Wait for the result with an optional timeout argument\n"
"assert future.result(timeout) == 3"
msgstr ""

#: library/asyncio-task.rst:1079
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Si une exception est levée dans une coroutine, le futur renvoyé en sera "
"averti. Elle peut également être utilisée pour annuler la tâche de la boucle "
"d'événement ::"

#: library/asyncio-task.rst:1083
msgid ""
"try:\n"
"    result = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('The coroutine took too long, cancelling the task...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'The coroutine raised an exception: {exc!r}')\n"
"else:\n"
"    print(f'The coroutine returned: {result!r}')"
msgstr ""

#: library/asyncio-task.rst:1093
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Voir la section :ref:`exécution concurrente et multi-fils d'exécution "
"<asyncio-multithreading>` de la documentation."

#: library/asyncio-task.rst:1096
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"À la différence des autres fonctions d'*asyncio*, cette fonction requiert "
"que *loop* soit passé de manière explicite."

#: library/asyncio-task.rst:1103
msgid "Introspection"
msgstr "Introspection"

#: library/asyncio-task.rst:1108
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Renvoie l'instance de la :class:`Task` en cours d'exécution, ou ``None`` "
"s'il n'y a pas de tâche en cours."

#: library/asyncio-task.rst:1111
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Si *loop* vaut ``None``, :func:`get_running_loop` est appelée pour récupérer "
"la boucle en cours d'exécution."

#: library/asyncio-task.rst:1119
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Renvoie l'ensemble des :class:`Task` non terminés en cours d'exécution dans "
"la boucle."

#: library/asyncio-task.rst:1122
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Si *loop* vaut ``None``, :func:`get_running_loop` est appelée pour récupérer "
"la boucle en cours d'exécution."

#: library/asyncio-task.rst:1130
msgid "Return ``True`` if *obj* is a coroutine object."
msgstr "Renvoie ``True`` si *obj* est un objet coroutine."

#: library/asyncio-task.rst:1136
msgid "Task Object"
msgstr "Objets *Task*"

#: library/asyncio-task.rst:1140
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Objet compatible avec :class:`Future <Future>` qui exécute une :ref:"
"`coroutine <coroutine>` Python. Cet objet n'est pas utilisable dans des "
"programmes à fils d'exécution multiples."

#: library/asyncio-task.rst:1143
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Les tâches servent à exécuter des coroutines dans des boucles d'événements. "
"Si une coroutine attend un futur, la tâche interrompt son exécution et "
"attend la fin de ce *futur*. Quand celui-ci est terminé, l'exécution de la "
"coroutine encapsulée reprend."

#: library/asyncio-task.rst:1149
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Les boucles d'événement fonctionnent de manière *coopérative* : une boucle "
"d'événement exécute une tâche à la fois. Quand une tâche attend la fin d'un "
"futur, la boucle d'événement exécute d'autres tâches, des fonctions de "
"rappel, ou effectue des opérations d'entrées-sorties."

#: library/asyncio-task.rst:1154
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"La fonction de haut niveau :func:`asyncio.create_task` et les fonctions de "
"bas-niveau :meth:`loop.create_task` ou :func:`ensure_future` permettent de "
"créer des tâches. Il est déconseillé d'instancier manuellement des objets "
"*Task*."

#: library/asyncio-task.rst:1159
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"La méthode :meth:`cancel` d'une tâche en cours d'exécution permet d'annuler "
"celle-ci. L'appel de cette méthode force la tâche à lever l'exception :exc:"
"`CancelledError` dans la coroutine encapsulée. Si la coroutine attendait un "
"*futur* au moment de l'annulation, celui-ci est annulé."

#: library/asyncio-task.rst:1164
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
"La méthode :meth:`cancelled` permet de vérifier si la tâche a été annulée. "
"Elle renvoie ``True`` si la coroutine encapsulée n'a pas ignoré l'exception :"
"exc:`CancelledError` et a bien été annulée."

#: library/asyncio-task.rst:1169
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` hérite de :class:`Future`, de toute son API, à "
"l'exception de :meth:`Future.set_result` et de :meth:`Future.set_exception`."

#: library/asyncio-task.rst:1173
#, fuzzy
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. If no *context* is "
"provided, the Task copies the current context and later runs its coroutine "
"in the copied context."
msgstr ""
"L'argument (uniquement nommé) facultatif *context* permet de spécifier un :"
"class:`contextvars.Context` personnalisé pour la coroutine à exécuter. La "
"copie de contexte actuelle est créée lorsqu'aucun *context* n'est fourni."

#: library/asyncio-task.rst:1178
msgid ""
"An optional keyword-only *eager_start* argument allows eagerly starting the "
"execution of the :class:`asyncio.Task` at task creation time. If set to "
"``True`` and the event loop is running, the task will start executing the "
"coroutine immediately, until the first time the coroutine blocks. If the "
"coroutine returns or raises without blocking, the task will be finished "
"eagerly and will skip scheduling to the event loop."
msgstr ""

# suit un :
#: library/asyncio-task.rst:1185
msgid "Added support for the :mod:`contextvars` module."
msgstr "ajout du support du module :mod:`contextvars`."

# suit un :
#: library/asyncio-task.rst:1191
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"un avertissement d'obsolescence est émis si *loop* n'est pas spécifié et "
"qu'il n'y a pas de boucle d'événement en cours d'exécution."

# suit un :
#: library/asyncio-task.rst:1198
#, fuzzy
msgid "Added the *eager_start* parameter."
msgstr "ajout du paramètre *name*."

#: library/asyncio-task.rst:1203
msgid "Return ``True`` if the Task is *done*."
msgstr "Renvoie ``True`` si la tâche est *achevée*."

#: library/asyncio-task.rst:1205
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Une tâche est dite *achevée* quand la coroutine encapsulée a soit renvoyé "
"une valeur, soit levé une exception, ou que la tâche a été annulée."

#: library/asyncio-task.rst:1210
msgid "Return the result of the Task."
msgstr "Renvoie le résultat de la tâche."

#: library/asyncio-task.rst:1212
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Si la tâche est *achevée*, le résultat de la coroutine encapsulée est "
"renvoyé (sinon, dans le cas où la coroutine a levé une exception, cette "
"exception est de nouveau levée)."

#: library/asyncio-task.rst:1230
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Si la tâche a été *annulée*, cette méthode lève une exception :exc:"
"`CancelledError`."

#: library/asyncio-task.rst:1219
#, fuzzy
msgid ""
"If the Task's result isn't yet available, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Si le résultat de la tâche n'est pas encore disponible, cette méthode lève "
"une exception :exc:`InvalidStateError`."

#: library/asyncio-task.rst:1224
msgid "Return the exception of the Task."
msgstr "Renvoie l'exception de la tâche."

#: library/asyncio-task.rst:1226
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Si la coroutine encapsulée lève une exception, cette exception est renvoyée. "
"Si la coroutine s'est exécutée normalement, cette méthode renvoie ``None``."

#: library/asyncio-task.rst:1233
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Si la tâche n'est pas encore *achevée*, cette méthode lève une exception :"
"exc:`InvalidStateError`."

#: library/asyncio-task.rst:1238
msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Ajoute une fonction de rappel qui sera exécutée quand la tâche sera "
"*achevée*."

#: library/asyncio-task.rst:1249
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Cette méthode ne doit être utilisée que dans du code basé sur les fonctions "
"de rappel de bas-niveau."

#: library/asyncio-task.rst:1242
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Se référer à la documentation de :meth:`Future.add_done_callback` pour plus "
"de détails."

#: library/asyncio-task.rst:1247
msgid "Remove *callback* from the callbacks list."
msgstr "Retire *callback* de la liste de fonctions de rappel."

#: library/asyncio-task.rst:1251
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Se référer à la documentation de :meth:`Future.remove_done_callback` pour "
"plus de détails."

#: library/asyncio-task.rst:1256
msgid "Return the list of stack frames for this Task."
msgstr "Renvoie une liste représentant la pile d'appels de la tâche."

#: library/asyncio-task.rst:1258
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Si la coroutine encapsulée n'est pas terminée, cette fonction renvoie la "
"pile d'appels à partir de l'endroit où celle-ci est interrompue. Si la "
"coroutine s'est terminée normalement ou a été annulée, cette fonction "
"renvoie une liste vide. Si la coroutine a été terminée par une exception, "
"ceci renvoie la pile d'erreurs."

#: library/asyncio-task.rst:1264
msgid "The frames are always ordered from oldest to newest."
msgstr "La pile est toujours affichée de l'appelant à l'appelé."

#: library/asyncio-task.rst:1266
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Une seule ligne est renvoyée si la coroutine est suspendue."

#: library/asyncio-task.rst:1268
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"L'argument facultatif *limit* définit le nombre maximal d'appels à "
"renvoyer ; par défaut, tous sont renvoyés. L'ordre de la liste diffère selon "
"la nature de celle-ci : les appels les plus récents d'une pile d'appels sont "
"renvoyés, si la pile est une pile d'erreurs, ce sont les appels les plus "
"anciens qui le sont (dans un souci de cohérence avec le module *traceback*)."

#: library/asyncio-task.rst:1277
msgid "Print the stack or traceback for this Task."
msgstr "Affiche la pile d'appels ou d'erreurs de la tâche."

#: library/asyncio-task.rst:1279
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Le format de sortie des appels produits par :meth:`get_stack` est similaire "
"à celui du module *traceback*."

#: library/asyncio-task.rst:1282
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "Le paramètre *limit* est directement passé à :meth:`get_stack`."

#: library/asyncio-task.rst:1284
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stdout`."
msgstr ""
"Le paramètre *file* est un flux d'entrées-sorties sur lequel le résultat est "
"écrit ; par défaut, :data:`sys.stdout`."

#: library/asyncio-task.rst:1289
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Renvoie l’objet *coroutine* encapsulé par la :class:`Task`."

#: library/asyncio-task.rst:1293
msgid ""
"This will return ``None`` for Tasks which have already completed eagerly. "
"See the :ref:`Eager Task Factory <eager-task-factory>`."
msgstr ""

#: library/asyncio-task.rst:1300
msgid "Newly added eager task execution means result may be ``None``."
msgstr ""

#: library/asyncio-task.rst:1304
msgid ""
"Return the :class:`contextvars.Context` object associated with the task."
msgstr ""

#: library/asyncio-task.rst:1311
msgid "Return the name of the Task."
msgstr "Renvoie le nom de la tâche."

#: library/asyncio-task.rst:1313
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Si aucun nom n’a été explicitement assigné à la tâche, l’implémentation par "
"défaut d’une *Task* *asyncio* génère un nom par défaut durant "
"l’instanciation."

#: library/asyncio-task.rst:1321
msgid "Set the name of the Task."
msgstr "Définit le nom de la tâche."

#: library/asyncio-task.rst:1323
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"L’argument *value* peut être n’importe quel objet qui sera ensuite converti "
"en chaine de caractères."

#: library/asyncio-task.rst:1326
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"Dans l’implémentation par défaut de *Task*, le nom sera visible dans le "
"résultat de :func:`repr` d’un objet *Task*."

#: library/asyncio-task.rst:1333
msgid "Request the Task to be cancelled."
msgstr "Demande l'annulation d'une tâche."

#: library/asyncio-task.rst:1335
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Provisionne la levée de l'exception :exc:`CancelledError` dans la coroutine "
"encapsulée. L'exception sera levée au prochain cycle de la boucle "
"d'exécution."

#: library/asyncio-task.rst:1338
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged.  Should the coroutine nevertheless decide to "
"suppress the cancellation, it needs to call :meth:`Task.uncancel` in "
"addition to catching the exception."
msgstr ""
"La coroutine peut alors faire le ménage ou même ignorer la requête en "
"supprimant l'exception à l'aide d'un bloc :keyword:`try` … … ``except "
"CancelledError`` … :keyword:`finally`. Par conséquent, contrairement à :meth:"
"`Future.cancel`, :meth:`Task.cancel` ne garantit pas que la tâche sera "
"annulée, bien qu'ignorer totalement une annulation ne soit ni une pratique "
"courante, ni encouragé. Si la coroutine décide néanmoins de supprimer "
"l'annulation, elle doit appeler :meth:`Task.uncancel` en plus d'intercepter "
"l'exception."

# suit un :
#: library/asyncio-task.rst:1348
msgid "Added the *msg* parameter."
msgstr "ajout du paramètre *msg*."

# suit un :
#: library/asyncio-task.rst:1351
msgid "The ``msg`` parameter is propagated from cancelled task to its awaiter."
msgstr ""
"le paramètre ``msg`` est propagé de la tâche annulée vers celle qui l'attend."

#: library/asyncio-task.rst:1356
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"L'exemple ci-dessous illustre comment une coroutine peut intercepter une "
"requête d'annulation ::"

#: library/asyncio-task.rst:1359
msgid ""
"async def cancel_me():\n"
"    print('cancel_me(): before sleep')\n"
"\n"
"    try:\n"
"        # Wait for 1 hour\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): cancel sleep')\n"
"        raise\n"
"    finally:\n"
"        print('cancel_me(): after sleep')\n"
"\n"
"async def main():\n"
"    # Create a \"cancel_me\" Task\n"
"    task = asyncio.create_task(cancel_me())\n"
"\n"
"    # Wait for 1 second\n"
"    await asyncio.sleep(1)\n"
"\n"
"    task.cancel()\n"
"    try:\n"
"        await task\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me is cancelled now\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     cancel_me(): before sleep\n"
"#     cancel_me(): cancel sleep\n"
"#     cancel_me(): after sleep\n"
"#     main(): cancel_me is cancelled now"
msgstr ""

#: library/asyncio-task.rst:1395
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Renvoie ``True`` si la tâche est *annulée*."

#: library/asyncio-task.rst:1397
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"La tâche est *annulée* quand l'annulation a été demandée avec :meth:`cancel` "
"et la coroutine encapsulée a propagé l'exception :exc:`CancelledError` qui a "
"été levée en son sein."

#: library/asyncio-task.rst:1403
msgid "Decrement the count of cancellation requests to this Task."
msgstr "Décrémente le nombre de demandes d'annulation pour cette tâche."

#: library/asyncio-task.rst:1405
msgid "Returns the remaining number of cancellation requests."
msgstr "Renvoie le nombre restant de demandes d'annulation."

#: library/asyncio-task.rst:1407
msgid ""
"Note that once execution of a cancelled task completed, further calls to :"
"meth:`uncancel` are ineffective."
msgstr ""
"Notez qu'une fois l'exécution d'une tâche annulée terminée, les appels "
"ultérieurs à :meth:`uncancel` ne font rien."

#: library/asyncio-task.rst:1412
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  In particular, if a Task gets successfully uncancelled, this "
"allows for elements of structured concurrency like :ref:`taskgroups` and :"
"func:`asyncio.timeout` to continue running, isolating cancellation to the "
"respective structured block. For example::"
msgstr ""
"Cette méthode est utilisée par les composants internes d'*asyncio* et elle "
"ne devrait pas être utilisée par le code de l'utilisateur final. En "
"particulier, si une tâche est annulée avec succès, cela permet aux "
"structures permettant le multi-fils tels que :ref:`taskgroups` et :func:"
"`asyncio.timeout` de continuer à s'exécuter, isolant l'annulation au bloc "
"concerné. Par exemple ::"

#: library/asyncio-task.rst:1419
msgid ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async with asyncio.timeout(1):\n"
"            # Structured block affected by the timeout:\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"There was a timeout\")\n"
"    # Outer code not affected by the timeout:\n"
"    await unrelated_code()"
msgstr ""

#: library/asyncio-task.rst:1430
msgid ""
"While the block with ``make_request()`` and ``make_another_request()`` might "
"get cancelled due to the timeout, ``unrelated_code()`` should continue "
"running even in case of the timeout.  This is implemented with :meth:"
"`uncancel`.  :class:`TaskGroup` context managers use :func:`uncancel` in a "
"similar fashion."
msgstr ""
"Alors que le bloc avec ``make_request()`` et ``make_another_request()`` peut "
"être annulé en raison du délai d'attente, ``unrelated_code()`` devrait "
"continuer à s'exécuter même en cas d'atteinte du délai maximal. Ceci est "
"implémenté avec :meth:`uncancel`. Les gestionnaires de contexte :class:"
"`TaskGroup` utilisent :func:`uncancel` de la même manière."

#: library/asyncio-task.rst:1436
#, fuzzy
msgid ""
"If end-user code is, for some reason, suppressing cancellation by catching :"
"exc:`CancelledError`, it needs to call this method to remove the "
"cancellation state."
msgstr ""
"Si, pour une raison quelconque, le code de l'utilisateur final supprime "
"l'annulation en interceptant :exc:`CancelledError`, il doit appeler cette "
"méthode pour supprimer l'état d'annulation."

#: library/asyncio-task.rst:1440
msgid ""
"When this method decrements the cancellation count to zero, the method "
"checks if a previous :meth:`cancel` call had arranged for :exc:"
"`CancelledError` to be thrown into the task. If it hasn't been thrown yet, "
"that arrangement will be rescinded (by resetting the internal "
"``_must_cancel`` flag)."
msgstr ""

#: library/asyncio-task.rst:1446
msgid "Changed to rescind pending cancellation requests upon reaching zero."
msgstr ""

#: library/asyncio-task.rst:1451
msgid ""
"Return the number of pending cancellation requests to this Task, i.e., the "
"number of calls to :meth:`cancel` less the number of :meth:`uncancel` calls."
msgstr ""
"Renvoie le nombre de demandes d'annulation en attente à cette tâche, c'est-à-"
"dire le nombre d'appels à :meth:`cancel` moins le nombre d'appels à :meth:"
"`uncancel`."

#: library/asyncio-task.rst:1455
msgid ""
"Note that if this number is greater than zero but the Task is still "
"executing, :meth:`cancelled` will still return ``False``. This is because "
"this number can be lowered by calling :meth:`uncancel`, which can lead to "
"the task not being cancelled after all if the cancellation requests go down "
"to zero."
msgstr ""
"Notez que si ce nombre est supérieur à zéro mais que la tâche est toujours "
"en cours d'exécution, :meth:`cancelled` renvoie toujours ``False``. En "
"effet, ce nombre peut être réduit en appelant :meth:`uncancel`, ce qui peut "
"empêcher en fin de compte la tâche d'être annulée si les demandes "
"d'annulation tombent à zéro."

#: library/asyncio-task.rst:1461
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  See :meth:`uncancel` for more details."
msgstr ""
"Cette méthode est utilisée par les composants internes d'*asyncio* et ne "
"devrait pas être utilisée par le code de l'utilisateur final. Voir :meth:"
"`uncancel` pour plus de détails."

#~ msgid ""
#~ "Create a task in this task group. The signature matches that of :func:"
#~ "`asyncio.create_task`."
#~ msgstr ""
#~ "Crée une tâche dans ce groupe de tâches. La signature correspond à celle "
#~ "de :func:`asyncio.create_task`."

#~ msgid ""
#~ "Raises :exc:`TimeoutError` if the timeout occurs before all Futures are "
#~ "done."
#~ msgstr ""
#~ "Lève une exception :exc:`TimeoutError` si le délai d'attente est dépassé "
#~ "avant que tous les futurs ne soient achevés."

#~ msgid ""
#~ "A more modern way to create and run tasks concurrently and wait for their "
#~ "completion is :class:`asyncio.TaskGroup`."
#~ msgstr ""
#~ "Une façon plus moderne de créer et d'exécuter des tâches simultanément et "
#~ "d'attendre leur achèvement est :class:`asyncio.TaskGroup`."

#~ msgid ":const:`FIRST_COMPLETED`"
#~ msgstr ":const:`FIRST_COMPLETED`"

#~ msgid ":const:`FIRST_EXCEPTION`"
#~ msgstr ":const:`FIRST_EXCEPTION`"

#~ msgid ":const:`ALL_COMPLETED`"
#~ msgstr ":const:`ALL_COMPLETED`"

#~ msgid ""
#~ "Tasks support the :mod:`contextvars` module.  When a Task is created it "
#~ "copies the current context and later runs its coroutine in the copied "
#~ "context."
#~ msgstr ""
#~ "*Task* implémente le module :mod:`contextvars`. Lors de sa création, une "
#~ "tâche effectue une copie du contexte actuel et exécute ses coroutines "
#~ "dans cette copie."

#~ msgid "Running an asyncio Program"
#~ msgstr "Exécution d'un programme *asyncio*"

#~ msgid "Execute the :term:`coroutine` *coro* and return the result."
#~ msgstr "Exécute la :term:`coroutine` *coro* et renvoie le résultat."

#, fuzzy
#~ msgid ""
#~ "This function runs the passed coroutine, taking care of managing the "
#~ "asyncio event loop, *finalizing asynchronous generators*, and closing the "
#~ "threadpool."
#~ msgstr ""
#~ "Cette fonction exécute la coroutine passée en argument. Elle gère la "
#~ "boucle d'événements *asyncio* et *finalise les générateurs asynchrones*."

#~ msgid ""
#~ "This function cannot be called when another asyncio event loop is running "
#~ "in the same thread."
#~ msgstr ""
#~ "Cette fonction ne peut pas être appelée si une autre boucle d'événement "
#~ "*asyncio* s'exécute dans le même fil d'exécution."

#~ msgid "If *debug* is ``True``, the event loop will be run in debug mode."
#~ msgstr ""
#~ "Si *debug* vaut ``True``, la boucle d'événement s'exécute en mode de "
#~ "débogage."

#~ msgid ""
#~ "This function always creates a new event loop and closes it at the end.  "
#~ "It should be used as a main entry point for asyncio programs, and should "
#~ "ideally only be called once."
#~ msgstr ""
#~ "Cette fonction crée toujours une nouvelle boucle d'événement et la clôt à "
#~ "la fin. Elle doit être utilisée comme point d'entrée principal des "
#~ "programmes *asyncio* et ne doit être idéalement appelée qu'une seule fois."

#~ msgid ""
#~ "The source code for ``asyncio.run()`` can be found in :source:`Lib/"
#~ "asyncio/runners.py`."
#~ msgstr ""
#~ "Le code source pour ``asyncio.run()`` est disponible dans :source:`Lib/"
#~ "asyncio/runners.py`."

#~ msgid ""
#~ "This function has been **added in Python 3.7**.  Prior to Python 3.7, the "
#~ "low-level :func:`asyncio.ensure_future` function can be used instead::"
#~ msgstr ""
#~ "Cette fonction a été **ajoutée dans Python 3.7**. Pour les versions "
#~ "antérieures à la 3.7, la fonction de bas-niveau :func:`asyncio."
#~ "ensure_future` peut-être utilisée ::"

#~ msgid ""
#~ "asyncio also supports legacy :ref:`generator-based "
#~ "<asyncio_generator_based_coro>` coroutines."
#~ msgstr ""
#~ "*asyncio* implémente également les coroutines :ref:`basées sur des "
#~ "générateurs <asyncio_generator_based_coro>` ; celles-ci sont obsolètes."

#~ msgid ""
#~ "If any awaitable in *aws* is a coroutine, it is automatically scheduled "
#~ "as a Task.  Passing coroutines objects to ``wait()`` directly is "
#~ "deprecated as it leads to :ref:`confusing behavior "
#~ "<asyncio_example_wait_coroutine>`."
#~ msgstr ""
#~ "Si un *awaitable* de *aws* est une coroutine, celle-ci est "
#~ "automatiquement planifiée comme une tâche. Passer directement des objets "
#~ "coroutines à ``wait()`` est obsolète, car ceci conduisait :ref:`à un "
#~ "comportement portant à confusion <asyncio_example_wait_coroutine>`."

#~ msgid ""
#~ "``wait()`` schedules coroutines as Tasks automatically and later returns "
#~ "those implicitly created Task objects in ``(done, pending)`` sets.  "
#~ "Therefore the following code won't work as expected::"
#~ msgstr ""
#~ "``wait()`` planifie automatiquement les coroutines comme des tâches et "
#~ "renvoie les objets *Task* ainsi créés dans les ensembles ``(done, "
#~ "pending)``. Le code suivant ne fonctionne donc pas comme voulu ::"

#~ msgid "Here is how the above snippet can be fixed::"
#~ msgstr "Voici comment corriger le morceau de code ci-dessus ::"

#~ msgid "Generator-based Coroutines"
#~ msgstr "Coroutines basées sur des générateurs"

#~ msgid ""
#~ "Support for generator-based coroutines is **deprecated** and is scheduled "
#~ "for removal in Python 3.10."
#~ msgstr ""
#~ "Les coroutines basées sur des générateurs sont **obsolètes** et il est "
#~ "prévu de les supprimer en Python 3.10."

#~ msgid ""
#~ "Generator-based coroutines predate async/await syntax.  They are Python "
#~ "generators that use ``yield from`` expressions to await on Futures and "
#~ "other coroutines."
#~ msgstr ""
#~ "Les coroutines basées sur des générateurs sont antérieures à la syntaxe "
#~ "*async* / *await*. Il existe des générateurs *Python* qui utilisent les "
#~ "expressions ``yield from`` pour attendre des *futurs* et autres "
#~ "coroutines."

#~ msgid ""
#~ "Generator-based coroutines should be decorated with :func:`@asyncio."
#~ "coroutine <asyncio.coroutine>`, although this is not enforced."
#~ msgstr ""
#~ "Les coroutines basées sur des générateurs doivent être décorées avec :"
#~ "func:`@asyncio.coroutine <asyncio.coroutine>`, même si ce n'est pas "
#~ "vérifié par l'interpréteur."

#~ msgid "Decorator to mark generator-based coroutines."
#~ msgstr "Décorateur pour coroutines basées sur des générateurs."

#~ msgid ""
#~ "This decorator enables legacy generator-based coroutines to be compatible "
#~ "with async/await code::"
#~ msgstr ""
#~ "Ce décorateur rend compatibles les coroutines basées sur des générateurs "
#~ "avec le code *async* / *await* ::"

#~ msgid ""
#~ "This decorator should not be used for :keyword:`async def` coroutines."
#~ msgstr ""
#~ "Ce décorateur ne doit pas être utilisé avec des coroutines :keyword:"
#~ "`async def`."

# pas de majuscule car suit un deux-points
#~ msgid "Use :keyword:`async def` instead."
#~ msgstr "utilisez :keyword:`async def` à la place."

#~ msgid ""
#~ "This method is different from :func:`inspect.iscoroutine` because it "
#~ "returns ``True`` for generator-based coroutines."
#~ msgstr ""
#~ "Cette méthode est différente de :func:`inspect.iscoroutine` car elle "
#~ "renvoie ``True`` pour des coroutines basées sur des générateurs."

#~ msgid ""
#~ "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
#~ msgstr ""
#~ "Renvoie ``True`` si *func* est une :ref:`fonction coroutine <coroutine>`."

#~ msgid ""
#~ "This method is different from :func:`inspect.iscoroutinefunction` because "
#~ "it returns ``True`` for generator-based coroutine functions decorated "
#~ "with :func:`@coroutine <coroutine>`."
#~ msgstr ""
#~ "Cette méthode est différente de :func:`inspect.iscoroutinefunction` car "
#~ "elle renvoie ``True`` pour des coroutines basées sur des générateurs, "
#~ "décorées avec :func:`@coroutine <coroutine>`."
