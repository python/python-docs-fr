# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-09-23 16:16+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Jeffd <dev@zest-labs.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: library/graphlib.rst:2
msgid ":mod:`graphlib` --- Functionality to operate with graph-like structures"
msgstr ":mod:`graphlib` --- Fonctionnalités pour travailler avec des "
"structures de type graphe"

#: library/graphlib.rst:8
msgid "**Source code:** :source:`Lib/graphlib.py`"
msgstr "**Code-source:** :source:`Lib/graphlib.py`"

#: library/graphlib.rst:20
msgid "Provides functionality to topologically sort a graph of hashable nodes."
msgstr "Fournit les fonctionnalités pour trier topologiquement un graphe de "
"nœuds hachables."

#: library/graphlib.rst:22
msgid ""
"A topological order is a linear ordering of the vertices in a graph such "
"that for every directed edge u -> v from vertex u to vertex v, vertex u "
"comes before vertex v in the ordering. For instance, the vertices of the "
"graph may represent tasks to be performed, and the edges may represent "
"constraints that one task must be performed before another; in this example, "
"a topological ordering is just a valid sequence for the tasks. A complete "
"topological ordering is possible if and only if the graph has no directed "
"cycles, that is, if it is a directed acyclic graph."
msgstr ""
"L'ordre topologique est un ordre linéaire des sommets d'un graphe afin que "
"pour chaque arête u -> v d'un sommet u à un sommet v, cet ordre "
"va placer le sommet u avant le sommet v. Par exemple, les sommets d'un "
"graphe pourraient représenter des tâches à faire et les arêtes pourraient "
"représenter les contraintes d'une tâche qui doit être réalisée avant une "
"autre. Dans cet exemple, un ordre topologique est simplement une séquence "
"valide pour ces tâches. Cet ordre n'est possible si et seulement si le "
"graphe n'a pas de circuit, c'est à dire si c'est un graphe orienté acyclique."

#: library/graphlib.rst:31
msgid ""
"If the optional *graph* argument is provided it must be a dictionary "
"representing a directed acyclic graph where the keys are nodes and the "
"values are iterables of all predecessors of that node in the graph (the "
"nodes that have edges that point to the value in the key). Additional nodes "
"can be added to the graph using the :meth:`~TopologicalSorter.add` method."
msgstr ""
"Si l'argument optionnel *graph* est fournit, cela doit être un dictionnaire "
"représentant un graphe acyclique avec comme clés les nœuds et comme "
"valeur des itérables de tous les prédécesseurs de ce nœud dans le graphe "
"(les nœuds qui ont des arêtes qui pointent vers la valeur de la clé). "
"L'ajout de nœuds peut être fait en utilisant la méthode "
":meth:`~TopologicalSorter.add`"

#: library/graphlib.rst:37
msgid ""
"In the general case, the steps required to perform the sorting of a given "
"graph are as follows:"
msgstr ""
"De manière générale, les étapes nécessaires pour trier un graphe donné "
"sont les suivantes:"

#: library/graphlib.rst:40
msgid ""
"Create an instance of the :class:`TopologicalSorter` with an optional "
"initial graph."
msgstr "Créer une instance de la classe :class:`TopologicalSorter` avec "
"éventuellement un graphe de base."

#: library/graphlib.rst:42
msgid "Add additional nodes to the graph."
msgstr "Ajouter un autre nœud au graphe."

#: library/graphlib.rst:43
msgid "Call :meth:`~TopologicalSorter.prepare` on the graph."
msgstr "Appeler :meth:`~TopologicalSorter.prepare` sur le graphe."

#: library/graphlib.rst:44
msgid ""
"While :meth:`~TopologicalSorter.is_active` is ``True``, iterate over the "
"nodes returned by :meth:`~TopologicalSorter.get_ready` and process them. "
"Call :meth:`~TopologicalSorter.done` on each node as it finishes processing."
msgstr ""
"Tant que :meth:`~TopologicalSorter.is_active` est à ``True``, on itère sur "
"les nœuds renvoyés par :meth:`~TopologicalSorter.get_ready` pour les "
"traiter. L'appel vers :meth:`~TopologicalSorter.done` sur chaque nœud permet "
"de terminer le traitement."

#: library/graphlib.rst:49
msgid ""
"In case just an immediate sorting of the nodes in the graph is required and "
"no parallelism is involved, the convenience method :meth:`TopologicalSorter."
"static_order` can be used directly:"
msgstr ""
"Dans le cas où un tri des nœuds du graphe est requis et qu'aucun "
"parallélisme n'est impliqué, la méthode :meth:`TopologicalSorter."
"static_order` peut être utilisée directement:"

#: library/graphlib.rst:60
msgid ""
"The class is designed to easily support parallel processing of the nodes as "
"they become ready. For instance::"
msgstr ""
"La classe est conçue afin de supporter facilement le traitement en parallèle "
"des nœuds quand ils deviennent disponibles. Par exemple ::"

#: library/graphlib.rst:87
msgid ""
"Add a new node and its predecessors to the graph. Both the *node* and all "
"elements in *predecessors* must be hashable."
msgstr ""
"Ajoute un nouveau nœud et son prédécesseur dans le graphe. Le *nœud* "
"ainsi que tous les éléments dans *predecessors* doivent être hachables."

#: library/graphlib.rst:90
msgid ""
"If called multiple times with the same node argument, the set of "
"dependencies will be the union of all dependencies passed in."
msgstr ""
"Si il est appelé plusieurs fois avec le même nœud en tant qu'argument,"
"le set de dépendances sera l'union de toute les dépendances qui auront "
"été transmises."

#: library/graphlib.rst:93
msgid ""
"It is possible to add a node with no dependencies (*predecessors* is not "
"provided) or to provide a dependency twice. If a node that has not been "
"provided before is included among *predecessors* it will be automatically "
"added to the graph with no predecessors of its own."
msgstr ""
"Il est possible d'ajouter un nœud sans dépendance (*predecessors* n'est "
"pas fournit) ou de fournir une dépendance deux fois. Si un nœud qui n'a "
"jamais été fournit auparavant est inclus dans *predecessors* il sera "
"automatiquement ajouté au graphe sans prédécesseur lui-même."

#: library/graphlib.rst:98
msgid ""
"Raises :exc:`ValueError` if called after :meth:`~TopologicalSorter.prepare`."
msgstr ""
"Lève une :exc:`ValueError` si c'est appelé après "
":meth:`~TopologicalSorter.prepare`."

#: library/graphlib.rst:102
msgid ""
"Mark the graph as finished and check for cycles in the graph. If any cycle "
"is detected, :exc:`CycleError` will be raised, but :meth:`~TopologicalSorter."
"get_ready` can still be used to obtain as many nodes as possible until "
"cycles block more progress. After a call to this function, the graph cannot "
"be modified, and therefore no more nodes can be added using :meth:"
"`~TopologicalSorter.add`."
msgstr ""
"Indique que le graphe est terminé et vérifie les circuits du graphes. Si un "
"circuit est détecté, une :exc:`CycleError` sera levée mais :meth:"
"`~TopologicalSorter.get_ready` peut encore être utilisée pour obtenir autant "
"de nœud que possible avant que les circuits bloquent la progression."
"Apres un appel de cette fonction, le graphe ne peut pas être modifié, et "
"donc aucun nœud ne pourra être ajouté avec :meth:`~TopologicalSorter.add`."

#: library/graphlib.rst:111
msgid ""
"Returns ``True`` if more progress can be made and ``False`` otherwise. "
"Progress can be made if cycles do not block the resolution and either there "
"are still nodes ready that haven't yet been returned by :meth:"
"`TopologicalSorter.get_ready` or the number of nodes marked :meth:"
"`TopologicalSorter.done` is less than the number that have been returned by "
":meth:`TopologicalSorter.get_ready`."
msgstr ""
"Retourne ``True`` si des une progression peut être faite et ``False`` dans "
"le cas contraire. La progression est possible si des circuits ne bloquent "
"pas la résolution ou qu'il reste des nœuds prêts qui n'ont pas encore été "
"retournés par :meth:`TopologicalSorter.get_ready` ou que le nombre de nœuds "
"marqués :meth:`TopologicalSorter.done` est inférieur au nombre qui a été "
"retourné par :meth:`TopologicalSorter.get_ready`."


#: library/graphlib.rst:118
msgid ""
"The :meth:`~TopologicalSorter.__bool__` method of this class defers to this "
"function, so instead of::"
msgstr ""
"La méthode :meth:`~TopologicalSorter.__bool__` de cette classe renvoie à "
"cette fonction donc au lieu de ::"

#: library/graphlib.rst:124
msgid "it is possible to simply do::"
msgstr "il est plus simple de faire ::"

#: library/graphlib.rst:152
msgid ""
"Raises :exc:`ValueError` if called without calling :meth:`~TopologicalSorter."
"prepare` previously."
msgstr ""
"Lève une :exc:`ValueError` si l'appel de :meth:`~TopologicalSorter.prepare` "
"n'a pas été fait au préalable."

#: library/graphlib.rst:134
msgid ""
"Marks a set of nodes returned by :meth:`TopologicalSorter.get_ready` as "
"processed, unblocking any successor of each node in *nodes* for being "
"returned in the future by a call to :meth:`TopologicalSorter.get_ready`."
msgstr ""
"Marque un ensemble de nœuds retourné par :meth:`TopologicalSorter.get_ready` "
"en tant que traité, débloquant tout successeur de chaque nœud de *nodes* "
"d'être retourné dans le futur lors de l'appel à :meth:`~TopologicalSorter."
"get_ready`."

#: library/graphlib.rst:138
msgid ""
"Raises :exc:`ValueError` if any node in *nodes* has already been marked as "
"processed by a previous call to this method or if a node was not added to "
"the graph by using :meth:`TopologicalSorter.add`, if called without calling :"
"meth:`~TopologicalSorter.prepare` or if node has not yet been returned by :"
"meth:`~TopologicalSorter.get_ready`."
msgstr ""
"Lève une :exc:`ValueError` si n'importe quel nœud dans *nodes* a déjà "
"été marqué comme traité par un précédent appel à cette méthode ou si un "
"nœud n'a pas été ajouté au graphe en utilisant :meth:`TopologicalSorter.add`,"
" si l'appel est fait sans appel à :meth:`~TopologicalSorter.prepare` "
"ou si le nœud n'a pas encore été retourné par :meth:`~TopologicalSorter."
"get_ready`."

#: library/graphlib.rst:146
msgid ""
"Returns a ``tuple`` with all the nodes that are ready. Initially it returns "
"all nodes with no predecessors, and once those are marked as processed by "
"calling :meth:`TopologicalSorter.done`, further calls will return all new "
"nodes that have all their predecessors already processed. Once no more "
"progress can be made, empty tuples are returned."
msgstr ""
"Retourne un ``tuple`` avec tous les nœuds prêts. Retourne d'abord "
"tous les nœuds sans prédécesseurs, et une fois marqués comme traités avec "
"un appel de :meth:`TopologicalSorter.done`, les autres appels retournent "
"tous les nouveaux nœuds qui ont tous leurs prédécesseurs déjà traités. Une "
"fois que la progression n'est plus possible, des tuples vides sont retournés."

#: library/graphlib.rst:157
#, fuzzy
msgid ""
"Returns an iterator object which will iterate over nodes in a topological "
"order. When using this method, :meth:`~TopologicalSorter.prepare` and :meth:"
"`~TopologicalSorter.done` should not be called. This method is equivalent "
"to::"
msgstr ""
"Retourne un itérable contenant les nœuds dans un ordre topologique. "
"L'utilisation de cette méthode permet d'éviter l'appel à "
":meth:`TopologicalSorter.prepare` ou :meth:`TopologicalSorter.done` "
"Cette méthode est équivalente à ::"

#: library/graphlib.rst:169
msgid ""
"The particular order that is returned may depend on the specific order in "
"which the items were inserted in the graph. For example:"
msgstr ""
"L'ordre particulier qui est retourné peut dépendre de l'ordre spécifique "
"dans lequel les éléments ont étés ajoutés dans le graphe. Par exemple:"

#: library/graphlib.rst:186
msgid ""
"This is due to the fact that \"0\" and \"2\" are in the same level in the "
"graph (they would have been returned in the same call to :meth:"
"`~TopologicalSorter.get_ready`) and the order between them is determined by "
"the order of insertion."
msgstr ""
"Ceci est dû au fait que \"0\" et \"2\" sont au même niveau dans le graphe "
"(ils auraient été retournés dans le même appel à :meth:"
"`~TopologicalSorter.get_ready`) et l'ordre entre eux est déterminé par "
"l'ordre lors de l'insertion."

#: library/graphlib.rst:192
msgid "If any cycle is detected, :exc:`CycleError` will be raised."
msgstr "Si un cycle est détecté alors une :exc:`CycleError` sera levée.`"

#: library/graphlib.rst:198
msgid "Exceptions"
msgstr "Exceptions"

#: library/graphlib.rst:199
msgid "The :mod:`graphlib` module defines the following exception classes:"
msgstr "Le module :mod:`graphlib` définit les classes d'exceptions suivantes:"

#: library/graphlib.rst:203
msgid ""
"Subclass of :exc:`ValueError` raised by :meth:`TopologicalSorter.prepare` if "
"cycles exist in the working graph. If multiple cycles exist, only one "
"undefined choice among them will be reported and included in the exception."
msgstr ""
"Un classe enfant de :exc:`ValueError` est levée par "
":meth:`TopologicalSorter.prepare` si un cycle existe dans le graphe courant. "
"Si de multiples cycles existent, seulement une sélection aléatoire de "
"ceux-ci seront indiqués et inclus dans l'exception."

#: library/graphlib.rst:207
msgid ""
"The detected cycle can be accessed via the second element in the :attr:"
"`~CycleError.args` attribute of the exception instance and consists in a "
"list of nodes, such that each node is, in the graph, an immediate "
"predecessor of the next node in the list. In the reported list, the first "
"and the last node will be the same, to make it clear that it is cyclic."
msgstr ""
""
"On peut accéder au cycle détecté via le second élément de l'attribut "
"`~CycleError.args` de l'instance de l'exception. Cet attribut sera une "
"liste de nœuds de telle manière que chaque nœud sera, dans le graphe, un "
"prédécesseur immédiat du nœud suivant de cette liste. Dans la liste "
"renvoyée, le premier et le dernier nœud seront le même afin de bien "
"indiquer que c'est cyclique."
