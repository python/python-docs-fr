# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-09 17:54+0200\n"
"PO-Revision-Date: 2020-02-23 23:00+0100\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Last-Translator: \n"
"X-Generator: Poedit 2.2.3\n"

#: ../Doc/library/codecs.rst:2
msgid ":mod:`codecs` --- Codec registry and base classes"
msgstr ":mod:`codecs` — Registre des codecs et classes de base associées"

#: ../Doc/library/codecs.rst:11
msgid "**Source code:** :source:`Lib/codecs.py`"
msgstr "**Code source :** :source:`Lib/codecs.py`"

#: ../Doc/library/codecs.rst:23
msgid ""
"This module defines base classes for standard Python codecs (encoders and "
"decoders) and provides access to the internal Python codec registry, which "
"manages the codec and error handling lookup process. Most standard codecs "
"are :term:`text encodings <text encoding>`, which encode text to bytes, but "
"there are also codecs provided that encode text to text, and bytes to bytes. "
"Custom codecs may encode and decode between arbitrary types, but some module "
"features are restricted to use specifically with :term:`text encodings <text "
"encoding>`, or with codecs that encode to :class:`bytes`."
msgstr ""
"Ce module définit les classes de base pour les codecs (encodeurs et "
"décodeurs) standards Python et fournit l'interface avec le registre des "
"codecs internes à Python, qui gère le processus de recherche de codecs et de "
"gestion des erreurs. La plupart des codecs sont des :term:`encodeurs de "
"texte <text encoding>`, qui encode du texte vers des séquences d'octets "
"(type *bytes* de Python) mais il existe aussi des codecs qui encodent du "
"texte vers du texte et des *bytes* vers des *bytes*. Les codecs "
"personnalisés peuvent encoder et décoder des types arbitraires, mais "
"l'utilisation de certaines fonctionnalités du module est restreinte aux :"
"term:`encodeurs de texte <text encoding>` ou aux codecs qui encodent vers :"
"class:`bytes`."

#: ../Doc/library/codecs.rst:33
msgid ""
"The module defines the following functions for encoding and decoding with "
"any codec:"
msgstr ""
"Le module définit les fonctions suivantes pour encoder et décoder à l'aide "
"de n'importe quel codec :"

#: ../Doc/library/codecs.rst:38
msgid "Encodes *obj* using the codec registered for *encoding*."
msgstr "Encode *obj* en utilisant le codec enregistré pour *encoding*."

#: ../Doc/library/codecs.rst:40
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that encoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeEncodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"Vous pouvez spécifier *errors* pour définir la façon de gérer les erreurs. "
"Le gestionnaire d'erreurs par défaut est ``'strict'``, ce qui veut dire "
"qu'une erreur lors de l'encodage lève :exc:`ValueError` (ou une sous-classe "
"spécifique du codec, telle que :exc:`UnicodeEncodeError`). Référez-vous aux :"
"ref:`classes de base des codecs <codec-base-classes>` pour plus "
"d'informations sur la gestion des erreurs par les codecs."

#: ../Doc/library/codecs.rst:48
msgid "Decodes *obj* using the codec registered for *encoding*."
msgstr "Décode *obj* en utilisant le codec enregistré pour *encoding*."

#: ../Doc/library/codecs.rst:50
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that decoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeDecodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"Vous pouvez spécifier *errors* pour définir la façon de gérer les erreurs. "
"Le gestionnaire d'erreurs par défaut est ``'strict'``, ce qui veut dire "
"qu'une erreur lors du décodage lève :exc:`ValueError` (ou une sous-classe "
"spécifique du codec, telle que :exc:`UnicodeDecodeError`). Référez-vous aux :"
"ref:`classes de base des codecs <codec-base-classes>` pour plus "
"d'informations sur la gestion des erreurs par les codecs."

#: ../Doc/library/codecs.rst:56
msgid "The full details for each codec can also be looked up directly:"
msgstr ""
"Les détails complets de chaque codec peuvent être examinés directement :"

#: ../Doc/library/codecs.rst:60
msgid ""
"Looks up the codec info in the Python codec registry and returns a :class:"
"`CodecInfo` object as defined below."
msgstr ""
"Recherche les informations relatives au codec dans le registre des codecs de "
"Python et renvoie l'objet :class:`CodecInfo` tel que défini ci-dessous."

#: ../Doc/library/codecs.rst:63
msgid ""
"Encodings are first looked up in the registry's cache. If not found, the "
"list of registered search functions is scanned. If no :class:`CodecInfo` "
"object is found, a :exc:`LookupError` is raised. Otherwise, the :class:"
"`CodecInfo` object is stored in the cache and returned to the caller."
msgstr ""
"Les encodeurs sont recherchés en priorité dans le cache du registre. S'ils "
"n'y sont pas, la liste des fonctions de recherche enregistrées est passée en "
"revue. Si aucun objet :class:`CodecInfo` n'est trouvé, une :exc:"
"`LookupError` est levée. Sinon, l'objet :class:`CodecInfo` est mis en cache "
"et renvoyé vers l'appelant."

#: ../Doc/library/codecs.rst:70
msgid ""
"Codec details when looking up the codec registry. The constructor arguments "
"are stored in attributes of the same name:"
msgstr ""
"Les détails d'un codec trouvé dans le registre des codecs. Les arguments du "
"constructeur sont stockés dans les attributs éponymes :"

#: ../Doc/library/codecs.rst:76
msgid "The name of the encoding."
msgstr "Le nom de l'encodeur."

#: ../Doc/library/codecs.rst:82
msgid ""
"The stateless encoding and decoding functions. These must be functions or "
"methods which have the same interface as the :meth:`~Codec.encode` and :meth:"
"`~Codec.decode` methods of Codec instances (see :ref:`Codec Interface <codec-"
"objects>`). The functions or methods are expected to work in a stateless "
"mode."
msgstr ""
"Les fonctions d'encodage et de décodage. Ces fonctions ou méthodes doivent "
"avoir la même interface que les méthodes :meth:`~Codec.encode` et :meth:"
"`~Codec.decode` des instances de Codec (voir :ref:`Interface des codecs "
"<codec-objects>`). Les fonctions et méthodes sont censées fonctionner sans "
"état interne."

#: ../Doc/library/codecs.rst:92
msgid ""
"Incremental encoder and decoder classes or factory functions. These have to "
"provide the interface defined by the base classes :class:"
"`IncrementalEncoder` and :class:`IncrementalDecoder`, respectively. "
"Incremental codecs can maintain state."
msgstr ""
"Classes d'encodeurs et de décodeurs incrémentaux ou fonctions usines. Elles "
"doivent avoir respectivement les mêmes interfaces que celles définies par "
"les classes de base :class:`IncrementalEncoder` et :class:"
"`IncrementalDecoder`. Les codecs incrémentaux peuvent conserver des états "
"internes."

#: ../Doc/library/codecs.rst:101
msgid ""
"Stream writer and reader classes or factory functions. These have to provide "
"the interface defined by the base classes :class:`StreamWriter` and :class:"
"`StreamReader`, respectively. Stream codecs can maintain state."
msgstr ""
"Classes d'écriture et de lecture de flux ou fonctions usines. Elles doivent "
"avoir les mêmes interfaces que celles définies par les classes de base :"
"class:`StreamWriter` et :class:`StreamReader`, respectivement. Les codecs de "
"flux peuvent conserver un état interne."

#: ../Doc/library/codecs.rst:106
msgid ""
"To simplify access to the various codec components, the module provides "
"these additional functions which use :func:`lookup` for the codec lookup:"
msgstr ""
"Pour simplifier l'accès aux différents composants du codec, le module "
"fournit les fonctions supplémentaires suivantes qui utilisent :func:`lookup` "
"pour la recherche du codec :"

#: ../Doc/library/codecs.rst:111
msgid ""
"Look up the codec for the given encoding and return its encoder function."
msgstr ""
"Recherche le codec pour l'encodage *encoding* et renvoie sa fonction "
"d'encodage."

#: ../Doc/library/codecs.rst:113 ../Doc/library/codecs.rst:120
#: ../Doc/library/codecs.rst:146 ../Doc/library/codecs.rst:154
msgid "Raises a :exc:`LookupError` in case the encoding cannot be found."
msgstr "Lève une :exc:`LookupError` si l'encodage *encoding* n'est pas trouvé."

#: ../Doc/library/codecs.rst:118
msgid ""
"Look up the codec for the given encoding and return its decoder function."
msgstr ""
"Recherche le codec pour l'encodage *encoding* et renvoie sa fonction de "
"décodage."

#: ../Doc/library/codecs.rst:125
msgid ""
"Look up the codec for the given encoding and return its incremental encoder "
"class or factory function."
msgstr ""
"Recherche le codec pour l'encodage *encoding* et renvoie sa classe "
"d'encodage incrémental ou la fonction usine."

#: ../Doc/library/codecs.rst:128
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental encoder."
msgstr ""
"Lève une :exc:`LookupError` si l'encodage *encoding* n'est pas trouvé ou si "
"le codec ne gère pas l'encodage incrémental."

#: ../Doc/library/codecs.rst:134
msgid ""
"Look up the codec for the given encoding and return its incremental decoder "
"class or factory function."
msgstr ""
"Recherche le codec pour l'encodage *encoding* et renvoie sa classe de "
"décodage incrémental ou la fonction usine."

#: ../Doc/library/codecs.rst:137
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental decoder."
msgstr ""
"Lève une :exc:`LookupError` si l'encodage *encoding* n'est pas trouvé ou si "
"le codec ne gère pas le décodage incrémental."

#: ../Doc/library/codecs.rst:143
msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamReader` class or factory function."
msgstr ""
"Recherche le codec pour l'encodage *encoding* et renvoie sa classe :class:"
"`StreamReader` ou la fonction usine."

#: ../Doc/library/codecs.rst:151
msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamWriter` class or factory function."
msgstr ""
"Recherche le codec pour l'encodage *encoding* et renvoie sa classe :class:"
"`StreamWriter` ou la fonction usine."

#: ../Doc/library/codecs.rst:156
msgid ""
"Custom codecs are made available by registering a suitable codec search "
"function:"
msgstr ""
"Les codecs personnalisés sont mis à disposition en enregistrant une fonction "
"de recherche de codecs adaptée :"

#: ../Doc/library/codecs.rst:161
msgid ""
"Register a codec search function. Search functions are expected to take one "
"argument, being the encoding name in all lower case letters, and return a :"
"class:`CodecInfo` object. In case a search function cannot find a given "
"encoding, it should return ``None``."
msgstr ""
"Enregistre une fonction de recherche de codec. Il convient qu'une fonction "
"de recherche prenne un argument, le nom de l'encodage écrit en lettres "
"minuscules, et renvoie un objet :class:`CodecInfo`. Si la fonction de "
"recherche ne trouve pas un encodage donné, il convient qu'elle renvoie `` "
"None``."

# Pas de majuscule en début car suit un deux-points.
#: ../Doc/library/codecs.rst:168
msgid ""
"Search function registration is not currently reversible, which may cause "
"problems in some cases, such as unit testing or module reloading."
msgstr ""
"l'enregistrement d'une fonction de recherche n'est actuellement pas "
"réversible, ce qui peut entraîner des problèmes dans certains cas, par "
"exemple pour les tests unitaires ou le rechargement de module."

#: ../Doc/library/codecs.rst:172
msgid ""
"While the builtin :func:`open` and the associated :mod:`io` module are the "
"recommended approach for working with encoded text files, this module "
"provides additional utility functions and classes that allow the use of a "
"wider range of codecs when working with binary files:"
msgstr ""
"Alors qu'il est recommandé d'utiliser la fonction native :func:`open` et le "
"module associé :mod:`io` pour travailler avec des fichiers texte encodés, le "
"présent module fournit des fonctions et classes utilitaires supplémentaires "
"qui permettent l'utilisation d'une plus large gamme de codecs si vous "
"travaillez avec des fichiers binaires :"

#: ../Doc/library/codecs.rst:179
msgid ""
"Open an encoded file using the given *mode* and return an instance of :class:"
"`StreamReaderWriter`, providing transparent encoding/decoding. The default "
"file mode is ``'r'``, meaning to open the file in read mode."
msgstr ""
"Ouvre un fichier encodé en utilisant le *mode* donné et renvoie une instance "
"de :class:`StreamReaderWriter`, permettant un encodage-décodage transparent. "
"Le mode de fichier par défaut est ``'r'``, ce qui signifie que le fichier "
"est ouvert en lecture."

# Pas de majuscule en début car suit un deux-points.
#: ../Doc/library/codecs.rst:185
msgid ""
"Underlying encoded files are always opened in binary mode. No automatic "
"conversion of ``'\\n'`` is done on reading and writing. The *mode* argument "
"may be any binary mode acceptable to the built-in :func:`open` function; the "
"``'b'`` is automatically added."
msgstr ""
"les fichiers encodés sous-jacents sont toujours ouverts en mode binaire. "
"Aucune conversion automatique de ``'\\n'`` n'est effectuée à la lecture ou à "
"l'écriture. L'argument *mode* peut être n'importe quel mode binaire "
"acceptable pour la fonction native :func:`open` ; le ``'b'`` est "
"automatiquement ajouté."

#: ../Doc/library/codecs.rst:190
msgid ""
"*encoding* specifies the encoding which is to be used for the file. Any "
"encoding that encodes to and decodes from bytes is allowed, and the data "
"types supported by the file methods depend on the codec used."
msgstr ""
"*encoding* spécifie l'encodage à utiliser pour le fichier. Tout encodage qui "
"encode et décode des octets (type *bytes*) est autorisé et les types de "
"données pris en charge par les méthodes relatives aux fichiers dépendent du "
"codec utilisé."

#: ../Doc/library/codecs.rst:194
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'`` which causes a :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"*errors* peut être spécifié pour définir la gestion des erreurs. La valeur "
"par défaut est ``'strict'``, ce qui lève une :exc:`ValueError` en cas "
"d'erreur lors du codage."

#: ../Doc/library/codecs.rst:197
msgid ""
"*buffering* has the same meaning as for the built-in :func:`open` function. "
"It defaults to -1 which means that the default buffer size will be used."
msgstr ""
"*buffering* a la même signification que pour la fonction native :func:"
"`open`. Il vaut `-1` par défaut, ce qui signifie que la taille par défaut du "
"tampon est utilisée."

#: ../Doc/library/codecs.rst:203
msgid ""
"Return a :class:`StreamRecoder` instance, a wrapped version of *file* which "
"provides transparent transcoding. The original file is closed when the "
"wrapped version is closed."
msgstr ""
"Renvoie une instance de :class:`StreamRecoder`, version encapsulée de *file* "
"qui fournit un transcodage transparent. Le fichier original est fermé quand "
"la version encapsulée est fermée."

#: ../Doc/library/codecs.rst:207
msgid ""
"Data written to the wrapped file is decoded according to the given "
"*data_encoding* and then written to the original file as bytes using "
"*file_encoding*. Bytes read from the original file are decoded according to "
"*file_encoding*, and the result is encoded using *data_encoding*."
msgstr ""
"Les données écrites dans un fichier encapsulant sont décodées en fonction du "
"*data_encoding* spécifié puis écrites vers le fichier original en tant que "
"*bytes* en utilisant *file_encoding*. Les octets lus dans le fichier "
"original sont décodés conformément à *file_encoding* et le résultat est "
"encodé en utilisant *data_encoding*."

#: ../Doc/library/codecs.rst:213
msgid "If *file_encoding* is not given, it defaults to *data_encoding*."
msgstr ""
"Si *file_encoding* n'est pas spécifié, la valeur par défaut est "
"*data_encoding*."

#: ../Doc/library/codecs.rst:215
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'``, which causes :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"*errors* peut être spécifié pour définir la gestion des erreurs. La valeur "
"par défaut est ``'strict'``, ce qui lève une :exc:`ValueError` en cas "
"d'erreur lors du codage."

#: ../Doc/library/codecs.rst:222
msgid ""
"Uses an incremental encoder to iteratively encode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"encoder."
msgstr ""
"Utilise un encodeur incrémental pour encoder de manière itérative l'entrée "
"fournie par *iterator*. Cette fonction est un :term:`générateur "
"<generator>`. L'argument *errors* (ainsi que tout autre argument passé par "
"mot-clé) est transmis à l'encodeur incrémental."

#: ../Doc/library/codecs.rst:227
msgid ""
"This function requires that the codec accept text :class:`str` objects to "
"encode. Therefore it does not support bytes-to-bytes encoders such as "
"``base64_codec``."
msgstr ""
"Cette fonction nécessite que le codec accepte les objets texte (classe :"
"class:`str`) en entrée. Par conséquent, il ne prend pas en charge les "
"encodeurs *bytes* vers *bytes* tels que ``base64_codec``."

#: ../Doc/library/codecs.rst:234
msgid ""
"Uses an incremental decoder to iteratively decode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"decoder."
msgstr ""
"Utilise un décodeur incrémental pour décoder de manière itérative l'entrée "
"fournie par *iterator*. Cette fonction est un :term:`générateur`. L'argument "
"*errors* (ainsi que tout autre argument passé par mot-clé) est transmis au "
"décodeur incrémental."

#: ../Doc/library/codecs.rst:239
msgid ""
"This function requires that the codec accept :class:`bytes` objects to "
"decode. Therefore it does not support text-to-text encoders such as "
"``rot_13``, although ``rot_13`` may be used equivalently with :func:"
"`iterencode`."
msgstr ""
"Cette fonction requiert que le codec accepte les objets :class:`bytes` en "
"entrée. Par conséquent, elle ne prend pas en charge les encodeurs de texte "
"vers texte tels que ``rot_13``, bien que ``rot_13`` puisse être utilisé de "
"manière équivalente avec :func:`iterencode`."

#: ../Doc/library/codecs.rst:245
msgid ""
"The module also provides the following constants which are useful for "
"reading and writing to platform dependent files:"
msgstr ""
"Le module fournit également les constantes suivantes qui sont utiles pour "
"lire et écrire les fichiers dépendants de la plateforme :"

#: ../Doc/library/codecs.rst:260
msgid ""
"These constants define various byte sequences, being Unicode byte order "
"marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data "
"streams to indicate the byte order used, and in UTF-8 as a Unicode "
"signature. :const:`BOM_UTF16` is either :const:`BOM_UTF16_BE` or :const:"
"`BOM_UTF16_LE` depending on the platform's native byte order, :const:`BOM` "
"is an alias for :const:`BOM_UTF16`, :const:`BOM_LE` for :const:"
"`BOM_UTF16_LE` and :const:`BOM_BE` for :const:`BOM_UTF16_BE`. The others "
"represent the BOM in UTF-8 and UTF-32 encodings."
msgstr ""
"Ces constantes définissent diverses séquences d'octets, les marques d'ordre "
"d'octets (BOM pour *byte order mark* en anglais) Unicode pour plusieurs "
"encodages. Elles sont utilisées dans les flux de données UTF-16 et UTF-32 "
"pour indiquer l'ordre des octets utilisé, et dans UTF-8 comme signature "
"Unicode. :const:`BOM_UTF16` vaut soit :const:`BOM_UTF16_BE`, soit :const:"
"`BOM_UTF16_LE` selon le boutisme natif de la plateforme, :const:`BOM` est un "
"alias pour :const:`BOM_UTF16`, :const:`BOM_LE` pour :const:`BOM_UTF16_LE` "
"et :const:`BOM_BE` pour :const:`BOM_UTF16_BE`. Les autres sont les marques "
"BOM dans les encodages UTF-8 et UTF-32."

#: ../Doc/library/codecs.rst:274
msgid "Codec Base Classes"
msgstr "Classes de base de codecs"

#: ../Doc/library/codecs.rst:276
msgid ""
"The :mod:`codecs` module defines a set of base classes which define the "
"interfaces for working with codec objects, and can also be used as the basis "
"for custom codec implementations."
msgstr ""
"Le module :mod:`codecs` définit un ensemble de classes de base qui "
"spécifient les interfaces pour travailler avec des objets codecs et qui "
"peuvent également être utilisées comme base pour des implémentations de "
"codecs personnalisés."

#: ../Doc/library/codecs.rst:280
msgid ""
"Each codec has to define four interfaces to make it usable as codec in "
"Python: stateless encoder, stateless decoder, stream reader and stream "
"writer. The stream reader and writers typically reuse the stateless encoder/"
"decoder to implement the file protocols. Codec authors also need to define "
"how the codec will handle encoding and decoding errors."
msgstr ""
"Chaque codec doit définir quatre interfaces pour être utilisable comme codec "
"en Python : codeur sans état, décodeur sans état, lecteur de flux et "
"écrivain de flux. Le lecteur et l'écrivain de flux réutilisent généralement "
"l'encodeur-décodeur sans état pour implémenter les protocoles de fichiers. "
"Les auteurs de codecs doivent également définir comment le codec gère les "
"erreurs d'encodage et de décodage."

#: ../Doc/library/codecs.rst:291
msgid "Error Handlers"
msgstr "Gestionnaires d'erreurs"

#: ../Doc/library/codecs.rst:293
msgid ""
"To simplify and standardize error handling, codecs may implement different "
"error handling schemes by accepting the *errors* string argument. The "
"following string values are defined and implemented by all standard Python "
"codecs:"
msgstr ""
"Pour simplifier et standardiser la gestion des erreurs, les codecs peuvent "
"implémenter différents schémas de gestion des erreurs en acceptant "
"l'argument *errors* de type chaîne. Les chaînes suivantes sont définies et "
"les gestionnaires correspondants implémentés par tous les codecs Python "
"standards :"

#: ../Doc/library/codecs.rst:301 ../Doc/library/codecs.rst:324
#: ../Doc/library/codecs.rst:357
msgid "Value"
msgstr "Valeur"

#: ../Doc/library/codecs.rst:301 ../Doc/library/codecs.rst:324
#: ../Doc/library/codecs.rst:357 ../Doc/library/codecs.rst:1268
#: ../Doc/library/codecs.rst:1335 ../Doc/library/codecs.rst:1390
msgid "Meaning"
msgstr "Signification"

#: ../Doc/library/codecs.rst:303
msgid "``'strict'``"
msgstr "``'strict'``"

#: ../Doc/library/codecs.rst:303
msgid ""
"Raise :exc:`UnicodeError` (or a subclass); this is the default. Implemented "
"in :func:`strict_errors`."
msgstr ""
"Lève :exc:`UnicodeError` (ou une sous-classe) ; c'est la valeur par défaut. "
"Implémenté dans :func:`strict_errors`."

#: ../Doc/library/codecs.rst:307
msgid "``'ignore'``"
msgstr "``'ignore'``"

#: ../Doc/library/codecs.rst:307
msgid ""
"Ignore the malformed data and continue without further notice. Implemented "
"in :func:`ignore_errors`."
msgstr ""
"Ignore les données incorrectement formatées et continue sans rien signaler. "
"Implémenté dans :func:`ignore_errors`."

#: ../Doc/library/codecs.rst:312
msgid ""
"The following error handlers are only applicable to :term:`text encodings "
"<text encoding>`:"
msgstr ""
"Les gestionnaires d'erreurs suivants ne s'appliquent que pour les :term:"
"`encodeurs de texte <text encoding>` :"

#: ../Doc/library/codecs.rst:326
msgid "``'replace'``"
msgstr "``'replace'``"

#: ../Doc/library/codecs.rst:326
msgid ""
"Replace with a suitable replacement marker; Python will use the official ``U"
"+FFFD`` REPLACEMENT CHARACTER for the built-in codecs on decoding, and '?' "
"on encoding. Implemented in :func:`replace_errors`."
msgstr ""
"Remplace avec une marque de substitution adaptée ; Python utilise le "
"caractère de substitution officiel ``U+FFFD`` pour les codecs natifs lors du "
"décodage et `'?'` lors de l'encodage. Implémenté dans :func:`replace_errors`."

#: ../Doc/library/codecs.rst:333
msgid "``'xmlcharrefreplace'``"
msgstr "``'xmlcharrefreplace'``"

#: ../Doc/library/codecs.rst:333
msgid ""
"Replace with the appropriate XML character reference (only for encoding). "
"Implemented in :func:`xmlcharrefreplace_errors`."
msgstr ""
"Remplace avec la référence de caractère XML adaptée (uniquement pour "
"l'encodage). Implémenté dans :func:`xmlcharrefreplace_errors`."

#: ../Doc/library/codecs.rst:337
msgid "``'backslashreplace'``"
msgstr "``'backslashreplace'``"

#: ../Doc/library/codecs.rst:337
msgid ""
"Replace with backslashed escape sequences. Implemented in :func:"
"`backslashreplace_errors`."
msgstr ""
"Remplace avec une séquence échappée par des antislashs. Implémenté dans :"
"func:`backslashreplace_errors`."

#: ../Doc/library/codecs.rst:341
msgid "``'namereplace'``"
msgstr "``'namereplace'``"

#: ../Doc/library/codecs.rst:341
msgid ""
"Replace with ``\\N{...}`` escape sequences (only for encoding). Implemented "
"in :func:`namereplace_errors`."
msgstr ""
"Remplace avec des séquences échappées par ``\\N{...}`` (uniquement pour "
"l'encodage). Implémenté dans :func:`namereplace_errors`."

#: ../Doc/library/codecs.rst:345
msgid "``'surrogateescape'``"
msgstr "``'surrogateescape'``"

#: ../Doc/library/codecs.rst:345
msgid ""
"On decoding, replace byte with individual surrogate code ranging from ``U"
"+DC80`` to ``U+DCFF``. This code will then be turned back into the same byte "
"when the ``'surrogateescape'`` error handler is used when encoding the data. "
"(See :pep:`383` for more.)"
msgstr ""
"Lors du décodage, remplace un octet par un code de substitution individuel "
"allant de ``U+DC80`` à ``U+DCFF``. Ce code est reconverti vers l'octet de "
"départ quand le gestionnaire d'erreurs ``'surrogateescape'`` est utilisé "
"pour l'encodage des données (voir la :pep:`383` pour plus de détails)."

#: ../Doc/library/codecs.rst:354
msgid ""
"In addition, the following error handler is specific to the given codecs:"
msgstr ""
"En plus, le gestionnaire d'erreurs suivant est spécifique aux codecs "
"suivants :"

#: ../Doc/library/codecs.rst:357
msgid "Codecs"
msgstr "Codecs"

#: ../Doc/library/codecs.rst:359
msgid "``'surrogatepass'``"
msgstr "``'surrogatepass'``"

#: ../Doc/library/codecs.rst:359
msgid "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"
msgstr "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"

#: ../Doc/library/codecs.rst:359
msgid ""
"Allow encoding and decoding of surrogate codes. These codecs normally treat "
"the presence of surrogates as an error."
msgstr ""
"Autorise l'encodage et le décodage de codes de substitution. Ces codecs "
"traitent normalement la présence d'un code de substitution comme une erreur."

# pas de majuscule en début de phrase car suit un deux-points.
#: ../Doc/library/codecs.rst:364
msgid "The ``'surrogateescape'`` and ``'surrogatepass'`` error handlers."
msgstr ""
"les gestionnaires d'erreurs ``'surrogateescape'`` et ``'surrogatepass'``."

# pas de majuscule en début de phrase car suit un deux-points.
#: ../Doc/library/codecs.rst:367
msgid ""
"The ``'surrogatepass'`` error handlers now works with utf-16\\* and "
"utf-32\\* codecs."
msgstr ""
"le gestionnaire d'erreurs ``'surrogatepass'`` fonctionne maintenant avec les "
"codecs utf-16\\* et utf-32\\*."

# pas de majuscule en début de phrase car suit un deux-points.
#: ../Doc/library/codecs.rst:370
msgid "The ``'namereplace'`` error handler."
msgstr "le gestionnaire d'erreurs ``'namereplace'``."

# pas de majuscule en début de phrase car suit un deux-points.
#: ../Doc/library/codecs.rst:373
msgid ""
"The ``'backslashreplace'`` error handlers now works with decoding and "
"translating."
msgstr ""
"le gestionnaire d'erreurs ``'backslashreplace'`` fonctionne maintenant pour "
"le décodage et la traduction."

#: ../Doc/library/codecs.rst:377
msgid ""
"The set of allowed values can be extended by registering a new named error "
"handler:"
msgstr ""
"L'ensemble des valeurs autorisées peut être étendu en enregistrant un "
"nouveau gestionnaire d'erreurs nommé :"

#: ../Doc/library/codecs.rst:382
msgid ""
"Register the error handling function *error_handler* under the name *name*. "
"The *error_handler* argument will be called during encoding and decoding in "
"case of an error, when *name* is specified as the errors parameter."
msgstr ""

#: ../Doc/library/codecs.rst:386
msgid ""
"For encoding, *error_handler* will be called with a :exc:"
"`UnicodeEncodeError` instance, which contains information about the location "
"of the error. The error handler must either raise this or a different "
"exception, or return a tuple with a replacement for the unencodable part of "
"the input and a position where encoding should continue. The replacement may "
"be either :class:`str` or :class:`bytes`. If the replacement is bytes, the "
"encoder will simply copy them into the output buffer. If the replacement is "
"a string, the encoder will encode the replacement. Encoding continues on "
"original input at the specified position. Negative position values will be "
"treated as being relative to the end of the input string. If the resulting "
"position is out of bound an :exc:`IndexError` will be raised."
msgstr ""

#: ../Doc/library/codecs.rst:398
msgid ""
"Decoding and translating works similarly, except :exc:`UnicodeDecodeError` "
"or :exc:`UnicodeTranslateError` will be passed to the handler and that the "
"replacement from the error handler will be put into the output directly."
msgstr ""

#: ../Doc/library/codecs.rst:403
msgid ""
"Previously registered error handlers (including the standard error handlers) "
"can be looked up by name:"
msgstr ""

#: ../Doc/library/codecs.rst:408
msgid "Return the error handler previously registered under the name *name*."
msgstr ""

#: ../Doc/library/codecs.rst:410
msgid "Raises a :exc:`LookupError` in case the handler cannot be found."
msgstr ""

#: ../Doc/library/codecs.rst:412
msgid ""
"The following standard error handlers are also made available as module "
"level functions:"
msgstr ""

#: ../Doc/library/codecs.rst:417
msgid ""
"Implements the ``'strict'`` error handling: each encoding or decoding error "
"raises a :exc:`UnicodeError`."
msgstr ""

#: ../Doc/library/codecs.rst:423
msgid ""
"Implements the ``'replace'`` error handling (for :term:`text encodings <text "
"encoding>` only): substitutes ``'?'`` for encoding errors (to be encoded by "
"the codec), and ``'\\ufffd'`` (the Unicode replacement character) for "
"decoding errors."
msgstr ""

#: ../Doc/library/codecs.rst:431
msgid ""
"Implements the ``'ignore'`` error handling: malformed data is ignored and "
"encoding or decoding is continued without further notice."
msgstr ""

#: ../Doc/library/codecs.rst:437
msgid ""
"Implements the ``'xmlcharrefreplace'`` error handling (for encoding with :"
"term:`text encodings <text encoding>` only): the unencodable character is "
"replaced by an appropriate XML character reference."
msgstr ""

#: ../Doc/library/codecs.rst:444
msgid ""
"Implements the ``'backslashreplace'`` error handling (for :term:`text "
"encodings <text encoding>` only): malformed data is replaced by a "
"backslashed escape sequence."
msgstr ""

#: ../Doc/library/codecs.rst:450
msgid ""
"Implements the ``'namereplace'`` error handling (for encoding with :term:"
"`text encodings <text encoding>` only): the unencodable character is "
"replaced by a ``\\N{...}`` escape sequence."
msgstr ""

#: ../Doc/library/codecs.rst:460
msgid "Stateless Encoding and Decoding"
msgstr ""

#: ../Doc/library/codecs.rst:462
msgid ""
"The base :class:`Codec` class defines these methods which also define the "
"function interfaces of the stateless encoder and decoder:"
msgstr ""

#: ../Doc/library/codecs.rst:468
msgid ""
"Encodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, :term:`text encoding` converts a string object to a "
"bytes object using a particular character set encoding (e.g., ``cp1252`` or "
"``iso-8859-1``)."
msgstr ""

#: ../Doc/library/codecs.rst:473 ../Doc/library/codecs.rst:495
msgid ""
"The *errors* argument defines the error handling to apply. It defaults to "
"``'strict'`` handling."
msgstr ""

#: ../Doc/library/codecs.rst:476
msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamWriter` for codecs which have to keep state in order to make encoding "
"efficient."
msgstr ""

#: ../Doc/library/codecs.rst:480
msgid ""
"The encoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""

#: ../Doc/library/codecs.rst:486
msgid ""
"Decodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, for a :term:`text encoding`, decoding converts a "
"bytes object encoded using a particular character set encoding to a string "
"object."
msgstr ""

#: ../Doc/library/codecs.rst:491
msgid ""
"For text encodings and bytes-to-bytes codecs, *input* must be a bytes object "
"or one which provides the read-only buffer interface -- for example, buffer "
"objects and memory mapped files."
msgstr ""

#: ../Doc/library/codecs.rst:498
msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamReader` for codecs which have to keep state in order to make decoding "
"efficient."
msgstr ""

#: ../Doc/library/codecs.rst:502
msgid ""
"The decoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""

#: ../Doc/library/codecs.rst:507
msgid "Incremental Encoding and Decoding"
msgstr ""

#: ../Doc/library/codecs.rst:509
msgid ""
"The :class:`IncrementalEncoder` and :class:`IncrementalDecoder` classes "
"provide the basic interface for incremental encoding and decoding. Encoding/"
"decoding the input isn't done with one call to the stateless encoder/decoder "
"function, but with multiple calls to the :meth:`~IncrementalEncoder.encode`/:"
"meth:`~IncrementalDecoder.decode` method of the incremental encoder/decoder. "
"The incremental encoder/decoder keeps track of the encoding/decoding process "
"during method calls."
msgstr ""

#: ../Doc/library/codecs.rst:517
msgid ""
"The joined output of calls to the :meth:`~IncrementalEncoder.encode`/:meth:"
"`~IncrementalDecoder.decode` method is the same as if all the single inputs "
"were joined into one, and this input was encoded/decoded with the stateless "
"encoder/decoder."
msgstr ""

#: ../Doc/library/codecs.rst:526
msgid "IncrementalEncoder Objects"
msgstr ""

#: ../Doc/library/codecs.rst:528
msgid ""
"The :class:`IncrementalEncoder` class is used for encoding an input in "
"multiple steps. It defines the following methods which every incremental "
"encoder must define in order to be compatible with the Python codec registry."
msgstr ""

#: ../Doc/library/codecs.rst:535
msgid "Constructor for an :class:`IncrementalEncoder` instance."
msgstr ""

#: ../Doc/library/codecs.rst:537
msgid ""
"All incremental encoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr ""

#: ../Doc/library/codecs.rst:541
msgid ""
"The :class:`IncrementalEncoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""

#: ../Doc/library/codecs.rst:545
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalEncoder` object."
msgstr ""

#: ../Doc/library/codecs.rst:553
msgid ""
"Encodes *object* (taking the current state of the encoder into account) and "
"returns the resulting encoded object. If this is the last call to :meth:"
"`encode` *final* must be true (the default is false)."
msgstr ""

#: ../Doc/library/codecs.rst:560
msgid ""
"Reset the encoder to the initial state. The output is discarded: call ``."
"encode(object, final=True)``, passing an empty byte or text string if "
"necessary, to reset the encoder and to get the output."
msgstr ""

#: ../Doc/library/codecs.rst:567
msgid ""
"Return the current state of the encoder which must be an integer. The "
"implementation should make sure that ``0`` is the most common state. (States "
"that are more complicated than integers can be converted into an integer by "
"marshaling/pickling the state and encoding the bytes of the resulting string "
"into an integer.)"
msgstr ""

#: ../Doc/library/codecs.rst:576
msgid ""
"Set the state of the encoder to *state*. *state* must be an encoder state "
"returned by :meth:`getstate`."
msgstr ""

#: ../Doc/library/codecs.rst:583
msgid "IncrementalDecoder Objects"
msgstr ""

#: ../Doc/library/codecs.rst:585
msgid ""
"The :class:`IncrementalDecoder` class is used for decoding an input in "
"multiple steps. It defines the following methods which every incremental "
"decoder must define in order to be compatible with the Python codec registry."
msgstr ""

#: ../Doc/library/codecs.rst:592
msgid "Constructor for an :class:`IncrementalDecoder` instance."
msgstr ""

#: ../Doc/library/codecs.rst:594
msgid ""
"All incremental decoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr ""

#: ../Doc/library/codecs.rst:598
msgid ""
"The :class:`IncrementalDecoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""

#: ../Doc/library/codecs.rst:602
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalDecoder` object."
msgstr ""

#: ../Doc/library/codecs.rst:610
msgid ""
"Decodes *object* (taking the current state of the decoder into account) and "
"returns the resulting decoded object. If this is the last call to :meth:"
"`decode` *final* must be true (the default is false). If *final* is true the "
"decoder must decode the input completely and must flush all buffers. If this "
"isn't possible (e.g. because of incomplete byte sequences at the end of the "
"input) it must initiate error handling just like in the stateless case "
"(which might raise an exception)."
msgstr ""

#: ../Doc/library/codecs.rst:621
msgid "Reset the decoder to the initial state."
msgstr ""

#: ../Doc/library/codecs.rst:626
msgid ""
"Return the current state of the decoder. This must be a tuple with two "
"items, the first must be the buffer containing the still undecoded input. "
"The second must be an integer and can be additional state info. (The "
"implementation should make sure that ``0`` is the most common additional "
"state info.) If this additional state info is ``0`` it must be possible to "
"set the decoder to the state which has no input buffered and ``0`` as the "
"additional state info, so that feeding the previously buffered input to the "
"decoder returns it to the previous state without producing any output. "
"(Additional state info that is more complicated than integers can be "
"converted into an integer by marshaling/pickling the info and encoding the "
"bytes of the resulting string into an integer.)"
msgstr ""

#: ../Doc/library/codecs.rst:641
msgid ""
"Set the state of the decoder to *state*. *state* must be a decoder state "
"returned by :meth:`getstate`."
msgstr ""

#: ../Doc/library/codecs.rst:646
msgid "Stream Encoding and Decoding"
msgstr ""

#: ../Doc/library/codecs.rst:649
msgid ""
"The :class:`StreamWriter` and :class:`StreamReader` classes provide generic "
"working interfaces which can be used to implement new encoding submodules "
"very easily. See :mod:`encodings.utf_8` for an example of how this is done."
msgstr ""

#: ../Doc/library/codecs.rst:657
msgid "StreamWriter Objects"
msgstr ""

#: ../Doc/library/codecs.rst:659
msgid ""
"The :class:`StreamWriter` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream writer must define in order to be "
"compatible with the Python codec registry."
msgstr ""

#: ../Doc/library/codecs.rst:666
msgid "Constructor for a :class:`StreamWriter` instance."
msgstr ""

#: ../Doc/library/codecs.rst:668
msgid ""
"All stream writers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr ""

#: ../Doc/library/codecs.rst:672
msgid ""
"The *stream* argument must be a file-like object open for writing text or "
"binary data, as appropriate for the specific codec."
msgstr ""

#: ../Doc/library/codecs.rst:675
msgid ""
"The :class:`StreamWriter` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""

#: ../Doc/library/codecs.rst:679
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamWriter` "
"object."
msgstr ""

#: ../Doc/library/codecs.rst:685
msgid "Writes the object's contents encoded to the stream."
msgstr ""

#: ../Doc/library/codecs.rst:690
msgid ""
"Writes the concatenated list of strings to the stream (possibly by reusing "
"the :meth:`write` method). The standard bytes-to-bytes codecs do not support "
"this method."
msgstr ""

#: ../Doc/library/codecs.rst:697
msgid "Flushes and resets the codec buffers used for keeping state."
msgstr ""

#: ../Doc/library/codecs.rst:699
msgid ""
"Calling this method should ensure that the data on the output is put into a "
"clean state that allows appending of new fresh data without having to rescan "
"the whole stream to recover state."
msgstr ""

#: ../Doc/library/codecs.rst:704
msgid ""
"In addition to the above methods, the :class:`StreamWriter` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""

#: ../Doc/library/codecs.rst:711
msgid "StreamReader Objects"
msgstr ""

#: ../Doc/library/codecs.rst:713
msgid ""
"The :class:`StreamReader` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream reader must define in order to be "
"compatible with the Python codec registry."
msgstr ""

#: ../Doc/library/codecs.rst:720
msgid "Constructor for a :class:`StreamReader` instance."
msgstr ""

#: ../Doc/library/codecs.rst:722
msgid ""
"All stream readers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr ""

#: ../Doc/library/codecs.rst:726
msgid ""
"The *stream* argument must be a file-like object open for reading text or "
"binary data, as appropriate for the specific codec."
msgstr ""

#: ../Doc/library/codecs.rst:729
msgid ""
"The :class:`StreamReader` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""

#: ../Doc/library/codecs.rst:733
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamReader` "
"object."
msgstr ""

#: ../Doc/library/codecs.rst:737
msgid ""
"The set of allowed values for the *errors* argument can be extended with :"
"func:`register_error`."
msgstr ""

#: ../Doc/library/codecs.rst:743
msgid "Decodes data from the stream and returns the resulting object."
msgstr ""

#: ../Doc/library/codecs.rst:745
msgid ""
"The *chars* argument indicates the number of decoded code points or bytes to "
"return. The :func:`read` method will never return more data than requested, "
"but it might return less, if there is not enough available."
msgstr ""

#: ../Doc/library/codecs.rst:750
msgid ""
"The *size* argument indicates the approximate maximum number of encoded "
"bytes or code points to read for decoding. The decoder can modify this "
"setting as appropriate. The default value -1 indicates to read and decode as "
"much as possible. This parameter is intended to prevent having to decode "
"huge files in one step."
msgstr ""

#: ../Doc/library/codecs.rst:757
msgid ""
"The *firstline* flag indicates that it would be sufficient to only return "
"the first line, if there are decoding errors on later lines."
msgstr ""

#: ../Doc/library/codecs.rst:761
msgid ""
"The method should use a greedy read strategy meaning that it should read as "
"much data as is allowed within the definition of the encoding and the given "
"size, e.g.  if optional encoding endings or state markers are available on "
"the stream, these should be read too."
msgstr ""

#: ../Doc/library/codecs.rst:769
msgid "Read one line from the input stream and return the decoded data."
msgstr ""

#: ../Doc/library/codecs.rst:771
msgid ""
"*size*, if given, is passed as size argument to the stream's :meth:`read` "
"method."
msgstr ""

#: ../Doc/library/codecs.rst:774
msgid ""
"If *keepends* is false line-endings will be stripped from the lines returned."
msgstr ""

#: ../Doc/library/codecs.rst:780
msgid ""
"Read all lines available on the input stream and return them as a list of "
"lines."
msgstr ""

#: ../Doc/library/codecs.rst:783
msgid ""
"Line-endings are implemented using the codec's :meth:`decode` method and are "
"included in the list entries if *keepends* is true."
msgstr ""

#: ../Doc/library/codecs.rst:786
msgid ""
"*sizehint*, if given, is passed as the *size* argument to the stream's :meth:"
"`read` method."
msgstr ""

#: ../Doc/library/codecs.rst:792
msgid "Resets the codec buffers used for keeping state."
msgstr ""

#: ../Doc/library/codecs.rst:794
msgid ""
"Note that no stream repositioning should take place. This method is "
"primarily intended to be able to recover from decoding errors."
msgstr ""

#: ../Doc/library/codecs.rst:798
msgid ""
"In addition to the above methods, the :class:`StreamReader` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""

#: ../Doc/library/codecs.rst:804
msgid "StreamReaderWriter Objects"
msgstr ""

#: ../Doc/library/codecs.rst:806
msgid ""
"The :class:`StreamReaderWriter` is a convenience class that allows wrapping "
"streams which work in both read and write modes."
msgstr ""

#: ../Doc/library/codecs.rst:809 ../Doc/library/codecs.rst:833
msgid ""
"The design is such that one can use the factory functions returned by the :"
"func:`lookup` function to construct the instance."
msgstr ""

#: ../Doc/library/codecs.rst:815
msgid ""
"Creates a :class:`StreamReaderWriter` instance. *stream* must be a file-like "
"object. *Reader* and *Writer* must be factory functions or classes providing "
"the :class:`StreamReader` and :class:`StreamWriter` interface resp. Error "
"handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""

#: ../Doc/library/codecs.rst:820
msgid ""
":class:`StreamReaderWriter` instances define the combined interfaces of :"
"class:`StreamReader` and :class:`StreamWriter` classes. They inherit all "
"other methods and attributes from the underlying stream."
msgstr ""

#: ../Doc/library/codecs.rst:828
msgid "StreamRecoder Objects"
msgstr ""

#: ../Doc/library/codecs.rst:830
msgid ""
"The :class:`StreamRecoder` translates data from one encoding to another, "
"which is sometimes useful when dealing with different encoding environments."
msgstr ""

#: ../Doc/library/codecs.rst:839
msgid ""
"Creates a :class:`StreamRecoder` instance which implements a two-way "
"conversion: *encode* and *decode* work on the frontend — the data visible to "
"code calling :meth:`read` and :meth:`write`, while *Reader* and *Writer* "
"work on the backend — the data in *stream*."
msgstr ""

#: ../Doc/library/codecs.rst:844
msgid ""
"You can use these objects to do transparent transcodings, e.g., from Latin-1 "
"to UTF-8 and back."
msgstr ""

#: ../Doc/library/codecs.rst:847
msgid "The *stream* argument must be a file-like object."
msgstr ""

#: ../Doc/library/codecs.rst:849
msgid ""
"The *encode* and *decode* arguments must adhere to the :class:`Codec` "
"interface. *Reader* and *Writer* must be factory functions or classes "
"providing objects of the :class:`StreamReader` and :class:`StreamWriter` "
"interface respectively."
msgstr ""

#: ../Doc/library/codecs.rst:854
msgid ""
"Error handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""

#: ../Doc/library/codecs.rst:858
msgid ""
":class:`StreamRecoder` instances define the combined interfaces of :class:"
"`StreamReader` and :class:`StreamWriter` classes. They inherit all other "
"methods and attributes from the underlying stream."
msgstr ""

#: ../Doc/library/codecs.rst:866
msgid "Encodings and Unicode"
msgstr ""

#: ../Doc/library/codecs.rst:868
msgid ""
"Strings are stored internally as sequences of code points in range ``0x0``--"
"``0x10FFFF``. (See :pep:`393` for more details about the implementation.) "
"Once a string object is used outside of CPU and memory, endianness and how "
"these arrays are stored as bytes become an issue. As with other codecs, "
"serialising a string into a sequence of bytes is known as *encoding*, and "
"recreating the string from the sequence of bytes is known as *decoding*. "
"There are a variety of different text serialisation codecs, which are "
"collectivity referred to as :term:`text encodings <text encoding>`."
msgstr ""

#: ../Doc/library/codecs.rst:878
msgid ""
"The simplest text encoding (called ``'latin-1'`` or ``'iso-8859-1'``) maps "
"the code points 0--255 to the bytes ``0x0``--``0xff``, which means that a "
"string object that contains code points above ``U+00FF`` can't be encoded "
"with this codec. Doing so will raise a :exc:`UnicodeEncodeError` that looks "
"like the following (although the details of the error message may differ): "
"``UnicodeEncodeError: 'latin-1' codec can't encode character '\\u1234' in "
"position 3: ordinal not in range(256)``."
msgstr ""

#: ../Doc/library/codecs.rst:886
msgid ""
"There's another group of encodings (the so called charmap encodings) that "
"choose a different subset of all Unicode code points and how these code "
"points are mapped to the bytes ``0x0``--``0xff``. To see how this is done "
"simply open e.g. :file:`encodings/cp1252.py` (which is an encoding that is "
"used primarily on Windows). There's a string constant with 256 characters "
"that shows you which character is mapped to which byte value."
msgstr ""

#: ../Doc/library/codecs.rst:893
msgid ""
"All of these encodings can only encode 256 of the 1114112 code points "
"defined in Unicode. A simple and straightforward way that can store each "
"Unicode code point, is to store each code point as four consecutive bytes. "
"There are two possibilities: store the bytes in big endian or in little "
"endian order. These two encodings are called ``UTF-32-BE`` and ``UTF-32-LE`` "
"respectively. Their disadvantage is that if e.g. you use ``UTF-32-BE`` on a "
"little endian machine you will always have to swap bytes on encoding and "
"decoding. ``UTF-32`` avoids this problem: bytes will always be in natural "
"endianness. When these bytes are read by a CPU with a different endianness, "
"then bytes have to be swapped though. To be able to detect the endianness of "
"a ``UTF-16`` or ``UTF-32`` byte sequence, there's the so called BOM (\"Byte "
"Order Mark\"). This is the Unicode character ``U+FEFF``. This character can "
"be prepended to every ``UTF-16`` or ``UTF-32`` byte sequence. The byte "
"swapped version of this character (``0xFFFE``) is an illegal character that "
"may not appear in a Unicode text. So when the first character in an "
"``UTF-16`` or ``UTF-32`` byte sequence appears to be a ``U+FFFE`` the bytes "
"have to be swapped on decoding. Unfortunately the character ``U+FEFF`` had a "
"second purpose as a ``ZERO WIDTH NO-BREAK SPACE``: a character that has no "
"width and doesn't allow a word to be split. It can e.g. be used to give "
"hints to a ligature algorithm. With Unicode 4.0 using ``U+FEFF`` as a ``ZERO "
"WIDTH NO-BREAK SPACE`` has been deprecated (with ``U+2060`` (``WORD "
"JOINER``) assuming this role). Nevertheless Unicode software still must be "
"able to handle ``U+FEFF`` in both roles: as a BOM it's a device to determine "
"the storage layout of the encoded bytes, and vanishes once the byte sequence "
"has been decoded into a string; as a ``ZERO WIDTH NO-BREAK SPACE`` it's a "
"normal character that will be decoded like any other."
msgstr ""

#: ../Doc/library/codecs.rst:919
msgid ""
"There's another encoding that is able to encoding the full range of Unicode "
"characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no "
"issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists "
"of two parts: marker bits (the most significant bits) and payload bits. The "
"marker bits are a sequence of zero to four ``1`` bits followed by a ``0`` "
"bit. Unicode characters are encoded like this (with x being payload bits, "
"which when concatenated give the Unicode character):"
msgstr ""

#: ../Doc/library/codecs.rst:928
msgid "Range"
msgstr "*Range*"

#: ../Doc/library/codecs.rst:928
#, fuzzy
msgid "Encoding"
msgstr "Encodages"

#: ../Doc/library/codecs.rst:930
msgid "``U-00000000`` ... ``U-0000007F``"
msgstr "``U-00000000`` ... ``U-0000007F``"

#: ../Doc/library/codecs.rst:930
msgid "0xxxxxxx"
msgstr "0xxxxxxx"

#: ../Doc/library/codecs.rst:932
msgid "``U-00000080`` ... ``U-000007FF``"
msgstr "``U-00000080`` ... ``U-000007FF``"

#: ../Doc/library/codecs.rst:932
msgid "110xxxxx 10xxxxxx"
msgstr "110xxxxx 10xxxxxx"

#: ../Doc/library/codecs.rst:934
msgid "``U-00000800`` ... ``U-0000FFFF``"
msgstr "``U-00000800`` ... ``U-0000FFFF``"

#: ../Doc/library/codecs.rst:934
msgid "1110xxxx 10xxxxxx 10xxxxxx"
msgstr "1110xxxx 10xxxxxx 10xxxxxx"

#: ../Doc/library/codecs.rst:936
msgid "``U-00010000`` ... ``U-0010FFFF``"
msgstr "``U-00010000`` ... ``U-0010FFFF``"

#: ../Doc/library/codecs.rst:936
msgid "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"
msgstr "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"

#: ../Doc/library/codecs.rst:939
msgid ""
"The least significant bit of the Unicode character is the rightmost x bit."
msgstr ""

#: ../Doc/library/codecs.rst:941
msgid ""
"As UTF-8 is an 8-bit encoding no BOM is required and any ``U+FEFF`` "
"character in the decoded string (even if it's the first character) is "
"treated as a ``ZERO WIDTH NO-BREAK SPACE``."
msgstr ""

#: ../Doc/library/codecs.rst:945
msgid ""
"Without external information it's impossible to reliably determine which "
"encoding was used for encoding a string. Each charmap encoding can decode "
"any random byte sequence. However that's not possible with UTF-8, as UTF-8 "
"byte sequences have a structure that doesn't allow arbitrary byte sequences. "
"To increase the reliability with which a UTF-8 encoding can be detected, "
"Microsoft invented a variant of UTF-8 (that Python 2.5 calls ``\"utf-8-sig"
"\"``) for its Notepad program: Before any of the Unicode characters is "
"written to the file, a UTF-8 encoded BOM (which looks like this as a byte "
"sequence: ``0xef``, ``0xbb``, ``0xbf``) is written. As it's rather "
"improbable that any charmap encoded file starts with these byte values "
"(which would e.g. map to"
msgstr ""

#: ../Doc/library/codecs.rst:0
msgid "LATIN SMALL LETTER I WITH DIAERESIS"
msgstr "LATIN SMALL LETTER I WITH DIAERESIS"

#: ../Doc/library/codecs.rst:0
msgid "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"
msgstr "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"

#: ../Doc/library/codecs.rst:0
msgid "INVERTED QUESTION MARK"
msgstr "INVERTED QUESTION MARK"

#: ../Doc/library/codecs.rst:961
msgid ""
"in iso-8859-1), this increases the probability that a ``utf-8-sig`` encoding "
"can be correctly guessed from the byte sequence. So here the BOM is not used "
"to be able to determine the byte order used for generating the byte "
"sequence, but as a signature that helps in guessing the encoding. On "
"encoding the utf-8-sig codec will write ``0xef``, ``0xbb``, ``0xbf`` as the "
"first three bytes to the file. On decoding ``utf-8-sig`` will skip those "
"three bytes if they appear as the first three bytes in the file. In UTF-8, "
"the use of the BOM is discouraged and should generally be avoided."
msgstr ""

#: ../Doc/library/codecs.rst:974
msgid "Standard Encodings"
msgstr ""

#: ../Doc/library/codecs.rst:976
msgid ""
"Python comes with a number of codecs built-in, either implemented as C "
"functions or with dictionaries as mapping tables. The following table lists "
"the codecs by name, together with a few common aliases, and the languages "
"for which the encoding is likely used. Neither the list of aliases nor the "
"list of languages is meant to be exhaustive. Notice that spelling "
"alternatives that only differ in case or use a hyphen instead of an "
"underscore are also valid aliases; therefore, e.g. ``'utf-8'`` is a valid "
"alias for the ``'utf_8'`` codec."
msgstr ""

#: ../Doc/library/codecs.rst:986
msgid ""
"Some common encodings can bypass the codecs lookup machinery to improve "
"performance. These optimization opportunities are only recognized by CPython "
"for a limited set of (case insensitive) aliases: utf-8, utf8, latin-1, "
"latin1, iso-8859-1, iso8859-1, mbcs (Windows only), ascii, us-ascii, utf-16, "
"utf16, utf-32, utf32, and the same using underscores instead of dashes. "
"Using alternative aliases for these encodings may result in slower execution."
msgstr ""

#: ../Doc/library/codecs.rst:994
msgid "Optimization opportunity recognized for us-ascii."
msgstr ""

#: ../Doc/library/codecs.rst:997
msgid ""
"Many of the character sets support the same languages. They vary in "
"individual characters (e.g. whether the EURO SIGN is supported or not), and "
"in the assignment of characters to code positions. For the European "
"languages in particular, the following variants typically exist:"
msgstr ""

#: ../Doc/library/codecs.rst:1002
msgid "an ISO 8859 codeset"
msgstr ""

#: ../Doc/library/codecs.rst:1004
msgid ""
"a Microsoft Windows code page, which is typically derived from an 8859 "
"codeset, but replaces control characters with additional graphic characters"
msgstr ""

#: ../Doc/library/codecs.rst:1007
msgid "an IBM EBCDIC code page"
msgstr ""

#: ../Doc/library/codecs.rst:1009
msgid "an IBM PC code page, which is ASCII compatible"
msgstr ""

#: ../Doc/library/codecs.rst:1014 ../Doc/library/codecs.rst:1268
#: ../Doc/library/codecs.rst:1335 ../Doc/library/codecs.rst:1390
msgid "Codec"
msgstr ""

#: ../Doc/library/codecs.rst:1014 ../Doc/library/codecs.rst:1268
#: ../Doc/library/codecs.rst:1335 ../Doc/library/codecs.rst:1390
msgid "Aliases"
msgstr ""

#: ../Doc/library/codecs.rst:1014
msgid "Languages"
msgstr ""

#: ../Doc/library/codecs.rst:1016
msgid "ascii"
msgstr "*ascii*"

#: ../Doc/library/codecs.rst:1016
msgid "646, us-ascii"
msgstr "*646*, *us-ascii*"

#: ../Doc/library/codecs.rst:1016 ../Doc/library/codecs.rst:1022
#: ../Doc/library/codecs.rst:1030
msgid "English"
msgstr "Anglais"

#: ../Doc/library/codecs.rst:1018
msgid "big5"
msgstr "*big5*"

#: ../Doc/library/codecs.rst:1018
msgid "big5-tw, csbig5"
msgstr "*big5-tw*, *csbig5*"

#: ../Doc/library/codecs.rst:1018 ../Doc/library/codecs.rst:1020
#: ../Doc/library/codecs.rst:1078
msgid "Traditional Chinese"
msgstr "Chinois Traditionnel"

#: ../Doc/library/codecs.rst:1020
msgid "big5hkscs"
msgstr "*big5hkscs*"

#: ../Doc/library/codecs.rst:1020
msgid "big5-hkscs, hkscs"
msgstr "*big5-hkscs*, *hkscs*"

#: ../Doc/library/codecs.rst:1022
msgid "cp037"
msgstr "*cp037*"

#: ../Doc/library/codecs.rst:1022
msgid "IBM037, IBM039"
msgstr "*IBM037*, *IBM039*"

#: ../Doc/library/codecs.rst:1024
msgid "cp273"
msgstr "*cp273*"

#: ../Doc/library/codecs.rst:1024
msgid "273, IBM273, csIBM273"
msgstr "*273*, *IBM273*, *csIBM273*"

#: ../Doc/library/codecs.rst:1024
msgid "German"
msgstr "Allemand"

#: ../Doc/library/codecs.rst:1028
msgid "cp424"
msgstr "*cp424*"

#: ../Doc/library/codecs.rst:1028
msgid "EBCDIC-CP-HE, IBM424"
msgstr "*EBCDIC-CP-HE*, *IBM424*"

#: ../Doc/library/codecs.rst:1028 ../Doc/library/codecs.rst:1048
#: ../Doc/library/codecs.rst:1058 ../Doc/library/codecs.rst:1101
#: ../Doc/library/codecs.rst:1164
msgid "Hebrew"
msgstr "Hébreux"

#: ../Doc/library/codecs.rst:1030
msgid "cp437"
msgstr "*cp437*"

#: ../Doc/library/codecs.rst:1030
msgid "437, IBM437"
msgstr "*437*, *IBM437*"

#: ../Doc/library/codecs.rst:1032
msgid "cp500"
msgstr "*cp500*"

#: ../Doc/library/codecs.rst:1032
msgid "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"
msgstr "*EBCDIC-CP-BE*, *EBCDIC-CP-CH*, *IBM500*"

#: ../Doc/library/codecs.rst:1032 ../Doc/library/codecs.rst:1041
#: ../Doc/library/codecs.rst:1052 ../Doc/library/codecs.rst:1088
#: ../Doc/library/codecs.rst:1095 ../Doc/library/codecs.rst:1148
#: ../Doc/library/codecs.rst:1176 ../Doc/library/codecs.rst:1203
msgid "Western Europe"
msgstr "Europe de l'ouest"

#: ../Doc/library/codecs.rst:1035
msgid "cp720"
msgstr "*cp720*"

#: ../Doc/library/codecs.rst:1035 ../Doc/library/codecs.rst:1062
#: ../Doc/library/codecs.rst:1103 ../Doc/library/codecs.rst:1160
msgid "Arabic"
msgstr "Arabe"

#: ../Doc/library/codecs.rst:1037
msgid "cp737"
msgstr "*cp737*"

#: ../Doc/library/codecs.rst:1037 ../Doc/library/codecs.rst:1068
#: ../Doc/library/codecs.rst:1072 ../Doc/library/codecs.rst:1097
#: ../Doc/library/codecs.rst:1162 ../Doc/library/codecs.rst:1197
msgid "Greek"
msgstr "Grec"

#: ../Doc/library/codecs.rst:1039
msgid "cp775"
msgstr "*cp775*"

#: ../Doc/library/codecs.rst:1039
msgid "IBM775"
msgstr "*IBM775*"

#: ../Doc/library/codecs.rst:1039 ../Doc/library/codecs.rst:1105
#: ../Doc/library/codecs.rst:1155 ../Doc/library/codecs.rst:1172
msgid "Baltic languages"
msgstr "Langues Baltiques"

#: ../Doc/library/codecs.rst:1041
msgid "cp850"
msgstr "*cp850*"

#: ../Doc/library/codecs.rst:1041
msgid "850, IBM850"
msgstr "*850*, *IBM850*"

#: ../Doc/library/codecs.rst:1043
msgid "cp852"
msgstr "*cp852*"

#: ../Doc/library/codecs.rst:1043
msgid "852, IBM852"
msgstr "*852*, *IBM852*"

#: ../Doc/library/codecs.rst:1043 ../Doc/library/codecs.rst:1090
#: ../Doc/library/codecs.rst:1151 ../Doc/library/codecs.rst:1201
msgid "Central and Eastern Europe"
msgstr "Europe centrale et Europe de l'Est"

#: ../Doc/library/codecs.rst:1045
msgid "cp855"
msgstr "*cp855*"

#: ../Doc/library/codecs.rst:1045
msgid "855, IBM855"
msgstr "*855*, *IBM855*"

#: ../Doc/library/codecs.rst:1045 ../Doc/library/codecs.rst:1092
#: ../Doc/library/codecs.rst:1157 ../Doc/library/codecs.rst:1194
msgid "Bulgarian, Byelorussian, Macedonian, Russian, Serbian"
msgstr "Bulgare, Biélorusse, Macédonien, Russe, Serbe"

#: ../Doc/library/codecs.rst:1048
msgid "cp856"
msgstr "*cp856*"

#: ../Doc/library/codecs.rst:1050
msgid "cp857"
msgstr "*cp857*"

#: ../Doc/library/codecs.rst:1050
msgid "857, IBM857"
msgstr "*857*, *IBM857*"

#: ../Doc/library/codecs.rst:1050 ../Doc/library/codecs.rst:1082
#: ../Doc/library/codecs.rst:1099 ../Doc/library/codecs.rst:1166
#: ../Doc/library/codecs.rst:1205
msgid "Turkish"
msgstr "Turc"

#: ../Doc/library/codecs.rst:1052
msgid "cp858"
msgstr "*cp858*"

#: ../Doc/library/codecs.rst:1052
msgid "858, IBM858"
msgstr "*858*, *IBM858*"

#: ../Doc/library/codecs.rst:1054
msgid "cp860"
msgstr "*cp860*"

#: ../Doc/library/codecs.rst:1054
msgid "860, IBM860"
msgstr "*860*, *IBM860*"

#: ../Doc/library/codecs.rst:1054
msgid "Portuguese"
msgstr "Portugais"

#: ../Doc/library/codecs.rst:1056
msgid "cp861"
msgstr "*cp861*"

#: ../Doc/library/codecs.rst:1056
msgid "861, CP-IS, IBM861"
msgstr "*861*, *CP-IS*, *IBM861*"

#: ../Doc/library/codecs.rst:1056 ../Doc/library/codecs.rst:1199
msgid "Icelandic"
msgstr "Islandais"

#: ../Doc/library/codecs.rst:1058
msgid "cp862"
msgstr "*cp862*"

#: ../Doc/library/codecs.rst:1058
msgid "862, IBM862"
msgstr "*862*, *IBM862*"

#: ../Doc/library/codecs.rst:1060
msgid "cp863"
msgstr "*cp863*"

#: ../Doc/library/codecs.rst:1060
msgid "863, IBM863"
msgstr "*863*, *IBM863*"

#: ../Doc/library/codecs.rst:1060
msgid "Canadian"
msgstr "Canadien"

#: ../Doc/library/codecs.rst:1062
msgid "cp864"
msgstr "*cp864*"

#: ../Doc/library/codecs.rst:1062
msgid "IBM864"
msgstr "*IBM864*"

#: ../Doc/library/codecs.rst:1064
msgid "cp865"
msgstr "*cp865*"

#: ../Doc/library/codecs.rst:1064
msgid "865, IBM865"
msgstr "*865*, *IBM865*"

#: ../Doc/library/codecs.rst:1064
msgid "Danish, Norwegian"
msgstr ""

#: ../Doc/library/codecs.rst:1066
msgid "cp866"
msgstr "*cp866*"

#: ../Doc/library/codecs.rst:1066
msgid "866, IBM866"
msgstr "*866*, *IBM866*"

#: ../Doc/library/codecs.rst:1066 ../Doc/library/codecs.rst:1182
msgid "Russian"
msgstr "Russe"

#: ../Doc/library/codecs.rst:1068
msgid "cp869"
msgstr "*cp869*"

#: ../Doc/library/codecs.rst:1068
msgid "869, CP-GR, IBM869"
msgstr "*869*, *CP-GR*, *IBM869*"

#: ../Doc/library/codecs.rst:1070
msgid "cp874"
msgstr "*cp874*"

#: ../Doc/library/codecs.rst:1070
msgid "Thai"
msgstr ""

#: ../Doc/library/codecs.rst:1072
msgid "cp875"
msgstr "*cp875*"

#: ../Doc/library/codecs.rst:1074
msgid "cp932"
msgstr "*cp932*"

#: ../Doc/library/codecs.rst:1074
msgid "932, ms932, mskanji, ms-kanji"
msgstr "*932*, *ms932*, *mskanji*, *ms-kanji*"

#: ../Doc/library/codecs.rst:1074 ../Doc/library/codecs.rst:1109
#: ../Doc/library/codecs.rst:1111 ../Doc/library/codecs.rst:1113
#: ../Doc/library/codecs.rst:1130 ../Doc/library/codecs.rst:1133
#: ../Doc/library/codecs.rst:1138 ../Doc/library/codecs.rst:1141
#: ../Doc/library/codecs.rst:1143 ../Doc/library/codecs.rst:1210
#: ../Doc/library/codecs.rst:1213 ../Doc/library/codecs.rst:1216
msgid "Japanese"
msgstr ""

#: ../Doc/library/codecs.rst:1076
msgid "cp949"
msgstr "*cp949*"

#: ../Doc/library/codecs.rst:1076
msgid "949, ms949, uhc"
msgstr "*949*, *ms949*, *uhc*"

#: ../Doc/library/codecs.rst:1076 ../Doc/library/codecs.rst:1115
#: ../Doc/library/codecs.rst:1145 ../Doc/library/codecs.rst:1180
msgid "Korean"
msgstr ""

#: ../Doc/library/codecs.rst:1078
msgid "cp950"
msgstr "*cp950*"

#: ../Doc/library/codecs.rst:1078
msgid "950, ms950"
msgstr "*950*, *ms950*"

#: ../Doc/library/codecs.rst:1080
msgid "cp1006"
msgstr "*cp1006*"

#: ../Doc/library/codecs.rst:1080
msgid "Urdu"
msgstr ""

#: ../Doc/library/codecs.rst:1082
msgid "cp1026"
msgstr "*cp1026*"

#: ../Doc/library/codecs.rst:1082
msgid "ibm1026"
msgstr "*ibm1026*"

#: ../Doc/library/codecs.rst:1084
msgid "cp1125"
msgstr "*cp1125*"

#: ../Doc/library/codecs.rst:1084
msgid "1125, ibm1125, cp866u, ruscii"
msgstr "*1125*, *ibm1125*, *cp866u*, *ruscii*"

#: ../Doc/library/codecs.rst:1084 ../Doc/library/codecs.rst:1188
msgid "Ukrainian"
msgstr ""

#: ../Doc/library/codecs.rst:1088
msgid "cp1140"
msgstr "*cp1140*"

#: ../Doc/library/codecs.rst:1088
msgid "ibm1140"
msgstr "*ibm1140*"

#: ../Doc/library/codecs.rst:1090
msgid "cp1250"
msgstr "*cp1250*"

#: ../Doc/library/codecs.rst:1090
msgid "windows-1250"
msgstr "*windows-1250*"

#: ../Doc/library/codecs.rst:1092
msgid "cp1251"
msgstr "*cp1251*"

#: ../Doc/library/codecs.rst:1092
msgid "windows-1251"
msgstr "*windows-1251*"

#: ../Doc/library/codecs.rst:1095
msgid "cp1252"
msgstr "*cp1252*"

#: ../Doc/library/codecs.rst:1095
msgid "windows-1252"
msgstr "*windows-1252*"

#: ../Doc/library/codecs.rst:1097
msgid "cp1253"
msgstr "*cp1253*"

#: ../Doc/library/codecs.rst:1097
msgid "windows-1253"
msgstr "*windows-1253*"

#: ../Doc/library/codecs.rst:1099
msgid "cp1254"
msgstr "*cp1254*"

#: ../Doc/library/codecs.rst:1099
msgid "windows-1254"
msgstr "*windows-1254*"

#: ../Doc/library/codecs.rst:1101
msgid "cp1255"
msgstr "*cp1255*"

#: ../Doc/library/codecs.rst:1101
msgid "windows-1255"
msgstr "*windows-1255*"

#: ../Doc/library/codecs.rst:1103
msgid "cp1256"
msgstr "*cp1256*"

#: ../Doc/library/codecs.rst:1103
msgid "windows-1256"
msgstr "*windows-1256*"

#: ../Doc/library/codecs.rst:1105
msgid "cp1257"
msgstr "*cp1257*"

#: ../Doc/library/codecs.rst:1105
msgid "windows-1257"
msgstr "*windows-1257*"

#: ../Doc/library/codecs.rst:1107
msgid "cp1258"
msgstr "*cp1258*"

#: ../Doc/library/codecs.rst:1107
msgid "windows-1258"
msgstr "*windows-1258*"

#: ../Doc/library/codecs.rst:1107
msgid "Vietnamese"
msgstr ""

#: ../Doc/library/codecs.rst:1109
msgid "euc_jp"
msgstr "*euc_jp*"

#: ../Doc/library/codecs.rst:1109
msgid "eucjp, ujis, u-jis"
msgstr "*eucjp*, *ujis*, *u-jis*"

#: ../Doc/library/codecs.rst:1111
msgid "euc_jis_2004"
msgstr "*euc_jis_2004*"

#: ../Doc/library/codecs.rst:1111
msgid "jisx0213, eucjis2004"
msgstr "*jisx0213*, *eucjis2004*"

#: ../Doc/library/codecs.rst:1113
msgid "euc_jisx0213"
msgstr "*euc_jisx0213*"

#: ../Doc/library/codecs.rst:1113
msgid "eucjisx0213"
msgstr "*eucjisx0213*"

#: ../Doc/library/codecs.rst:1115
msgid "euc_kr"
msgstr "*euc_kr*"

#: ../Doc/library/codecs.rst:1115
msgid "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"
msgstr ""
"*euckr*, *korean*, *ksc5601*, *ks_c-5601*, *ks_c-5601-1987*, *ksx1001*, "
"*ks_x-1001*"

#: ../Doc/library/codecs.rst:1119
msgid "gb2312"
msgstr "*gb2312*"

#: ../Doc/library/codecs.rst:1119
msgid ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"
msgstr ""
"*chinese*, *csiso58gb231280*, *euc-cn*, *euccn*, *eucgb2312-cn*, "
"*gb2312-1980*, *gb2312-80*, *iso-ir-58*"

#: ../Doc/library/codecs.rst:1119 ../Doc/library/codecs.rst:1128
msgid "Simplified Chinese"
msgstr ""

#: ../Doc/library/codecs.rst:1124
msgid "gbk"
msgstr "*gbk*"

#: ../Doc/library/codecs.rst:1124
msgid "936, cp936, ms936"
msgstr "*936*, *cp936*, *ms936*"

#: ../Doc/library/codecs.rst:1124 ../Doc/library/codecs.rst:1126
msgid "Unified Chinese"
msgstr ""

#: ../Doc/library/codecs.rst:1126
msgid "gb18030"
msgstr "*gb18030*"

#: ../Doc/library/codecs.rst:1126
msgid "gb18030-2000"
msgstr "*gb18030-2000*"

#: ../Doc/library/codecs.rst:1128
msgid "hz"
msgstr "*hz*"

#: ../Doc/library/codecs.rst:1128
msgid "hzgb, hz-gb, hz-gb-2312"
msgstr "*hzgb*, *hz-gb*, *hz-gb-2312*"

#: ../Doc/library/codecs.rst:1130
msgid "iso2022_jp"
msgstr "*iso2022_jp*"

#: ../Doc/library/codecs.rst:1130
msgid "csiso2022jp, iso2022jp, iso-2022-jp"
msgstr "*csiso2022jp*, *iso2022jp*, *iso-2022-jp*"

#: ../Doc/library/codecs.rst:1133
msgid "iso2022_jp_1"
msgstr "*iso2022_jp_1*"

#: ../Doc/library/codecs.rst:1133
msgid "iso2022jp-1, iso-2022-jp-1"
msgstr "*iso2022jp-1*, *iso-2022-jp-1*"

#: ../Doc/library/codecs.rst:1135
msgid "iso2022_jp_2"
msgstr "*iso2022_jp_2*"

#: ../Doc/library/codecs.rst:1135
msgid "iso2022jp-2, iso-2022-jp-2"
msgstr "*iso2022jp-2*, *iso-2022-jp-2*"

#: ../Doc/library/codecs.rst:1135
msgid "Japanese, Korean, Simplified Chinese, Western Europe, Greek"
msgstr ""

#: ../Doc/library/codecs.rst:1138
msgid "iso2022_jp_2004"
msgstr "*iso2022_jp_2004*"

#: ../Doc/library/codecs.rst:1138
msgid "iso2022jp-2004, iso-2022-jp-2004"
msgstr "*iso2022jp-2004*, *iso-2022-jp-2004*"

#: ../Doc/library/codecs.rst:1141
msgid "iso2022_jp_3"
msgstr "*iso2022_jp_3*"

#: ../Doc/library/codecs.rst:1141
msgid "iso2022jp-3, iso-2022-jp-3"
msgstr "*iso2022jp-3*, *iso-2022-jp-3*"

#: ../Doc/library/codecs.rst:1143
msgid "iso2022_jp_ext"
msgstr "*iso2022_jp_ext*"

#: ../Doc/library/codecs.rst:1143
msgid "iso2022jp-ext, iso-2022-jp-ext"
msgstr "*iso2022jp-ext*, *iso-2022-jp-ext*"

#: ../Doc/library/codecs.rst:1145
msgid "iso2022_kr"
msgstr "*iso2022_kr*"

#: ../Doc/library/codecs.rst:1145
msgid "csiso2022kr, iso2022kr, iso-2022-kr"
msgstr "*csiso2022kr*, *iso2022kr*, *iso-2022-kr*"

#: ../Doc/library/codecs.rst:1148
msgid "latin_1"
msgstr "*latin_1*"

#: ../Doc/library/codecs.rst:1148
msgid "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"
msgstr "*iso-8859-1*, *iso8859-1*, *8859*, *cp819*, *latin*, *latin1*, *L1*"

#: ../Doc/library/codecs.rst:1151
msgid "iso8859_2"
msgstr "*iso8859_2*"

#: ../Doc/library/codecs.rst:1151
msgid "iso-8859-2, latin2, L2"
msgstr "*iso-8859-2*, *latin2*, *L2*"

#: ../Doc/library/codecs.rst:1153
msgid "iso8859_3"
msgstr "*iso8859_3*"

#: ../Doc/library/codecs.rst:1153
msgid "iso-8859-3, latin3, L3"
msgstr "*iso-8859-3*, *latin3*, *L3*"

#: ../Doc/library/codecs.rst:1153
msgid "Esperanto, Maltese"
msgstr ""

#: ../Doc/library/codecs.rst:1155
msgid "iso8859_4"
msgstr "*iso8859_4*"

#: ../Doc/library/codecs.rst:1155
msgid "iso-8859-4, latin4, L4"
msgstr "*iso-8859-4*, *latin4*, *L4*"

#: ../Doc/library/codecs.rst:1157
msgid "iso8859_5"
msgstr "*iso8859_5*"

#: ../Doc/library/codecs.rst:1157
msgid "iso-8859-5, cyrillic"
msgstr "*iso-8859-5*, *cyrillic*"

#: ../Doc/library/codecs.rst:1160
msgid "iso8859_6"
msgstr "*iso8859_6*"

#: ../Doc/library/codecs.rst:1160
msgid "iso-8859-6, arabic"
msgstr "*iso-8859-6*, *arabic*"

#: ../Doc/library/codecs.rst:1162
msgid "iso8859_7"
msgstr "*iso8859_7*"

#: ../Doc/library/codecs.rst:1162
msgid "iso-8859-7, greek, greek8"
msgstr "*iso-8859-7*, *greek*, *greek8*"

#: ../Doc/library/codecs.rst:1164
msgid "iso8859_8"
msgstr "*iso8859_8*"

#: ../Doc/library/codecs.rst:1164
msgid "iso-8859-8, hebrew"
msgstr "*iso-8859-8*, *hebrew*"

#: ../Doc/library/codecs.rst:1166
msgid "iso8859_9"
msgstr "*iso8859_9*"

#: ../Doc/library/codecs.rst:1166
msgid "iso-8859-9, latin5, L5"
msgstr "*iso-8859-9*, *latin5*, *L5*"

#: ../Doc/library/codecs.rst:1168
msgid "iso8859_10"
msgstr "*iso8859_10*"

#: ../Doc/library/codecs.rst:1168
msgid "iso-8859-10, latin6, L6"
msgstr "*iso-8859-10*, *latin6*, *L6*"

#: ../Doc/library/codecs.rst:1168
msgid "Nordic languages"
msgstr ""

#: ../Doc/library/codecs.rst:1170
msgid "iso8859_11"
msgstr "*iso8859_11*"

#: ../Doc/library/codecs.rst:1170
msgid "iso-8859-11, thai"
msgstr "*iso-8859-11*, *thai*"

#: ../Doc/library/codecs.rst:1170
msgid "Thai languages"
msgstr ""

#: ../Doc/library/codecs.rst:1172
msgid "iso8859_13"
msgstr "*iso8859_13*"

#: ../Doc/library/codecs.rst:1172
msgid "iso-8859-13, latin7, L7"
msgstr "*iso-8859-13*, *latin7*, *L7*"

#: ../Doc/library/codecs.rst:1174
msgid "iso8859_14"
msgstr "*iso8859_14*"

#: ../Doc/library/codecs.rst:1174
msgid "iso-8859-14, latin8, L8"
msgstr "*iso-8859-14*, *latin8*, *L8*"

#: ../Doc/library/codecs.rst:1174
msgid "Celtic languages"
msgstr ""

#: ../Doc/library/codecs.rst:1176
msgid "iso8859_15"
msgstr "*iso8859_15*"

#: ../Doc/library/codecs.rst:1176
msgid "iso-8859-15, latin9, L9"
msgstr "*iso-8859-15*, *latin9*, *L9*"

#: ../Doc/library/codecs.rst:1178
msgid "iso8859_16"
msgstr "*iso8859_16*"

#: ../Doc/library/codecs.rst:1178
msgid "iso-8859-16, latin10, L10"
msgstr "*iso-8859-16*, *latin10*, *L10*"

#: ../Doc/library/codecs.rst:1178
msgid "South-Eastern Europe"
msgstr ""

#: ../Doc/library/codecs.rst:1180
msgid "johab"
msgstr "*johab*"

#: ../Doc/library/codecs.rst:1180
msgid "cp1361, ms1361"
msgstr "*cp1361*, *ms1361*"

#: ../Doc/library/codecs.rst:1182
msgid "koi8_r"
msgstr "*koi8_r*"

#: ../Doc/library/codecs.rst:1184
msgid "koi8_t"
msgstr "*koi8_t*"

#: ../Doc/library/codecs.rst:1184
msgid "Tajik"
msgstr "*Tajik*"

#: ../Doc/library/codecs.rst:1188
msgid "koi8_u"
msgstr "*koi8_u*"

#: ../Doc/library/codecs.rst:1190
msgid "kz1048"
msgstr "*kz1048*"

#: ../Doc/library/codecs.rst:1190
msgid "kz_1048, strk1048_2002, rk1048"
msgstr "*kz_1048*, *strk1048_2002*, *rk1048*"

#: ../Doc/library/codecs.rst:1190 ../Doc/library/codecs.rst:1207
msgid "Kazakh"
msgstr ""

#: ../Doc/library/codecs.rst:1194
msgid "mac_cyrillic"
msgstr "*mac_cyrillic*"

#: ../Doc/library/codecs.rst:1194
msgid "maccyrillic"
msgstr "*maccyrillic*"

#: ../Doc/library/codecs.rst:1197
msgid "mac_greek"
msgstr "*mac_greek*"

#: ../Doc/library/codecs.rst:1197
msgid "macgreek"
msgstr "*macgreek*"

#: ../Doc/library/codecs.rst:1199
msgid "mac_iceland"
msgstr "*mac_iceland*"

#: ../Doc/library/codecs.rst:1199
msgid "maciceland"
msgstr "*maciceland*"

#: ../Doc/library/codecs.rst:1201
msgid "mac_latin2"
msgstr "*mac_latin2*"

#: ../Doc/library/codecs.rst:1201
msgid "maclatin2, maccentraleurope"
msgstr "*maclatin2*, *maccentraleurope*"

#: ../Doc/library/codecs.rst:1203
msgid "mac_roman"
msgstr "*mac_roman*"

#: ../Doc/library/codecs.rst:1203
msgid "macroman, macintosh"
msgstr "*macroman*, *macintosh*"

#: ../Doc/library/codecs.rst:1205
msgid "mac_turkish"
msgstr "*mac_turkish*"

#: ../Doc/library/codecs.rst:1205
msgid "macturkish"
msgstr "*macturkish*"

#: ../Doc/library/codecs.rst:1207
msgid "ptcp154"
msgstr "*ptcp154*"

#: ../Doc/library/codecs.rst:1207
msgid "csptcp154, pt154, cp154, cyrillic-asian"
msgstr "*csptcp154*, *pt154*, *cp154*, *cyrillic-asian*"

#: ../Doc/library/codecs.rst:1210
msgid "shift_jis"
msgstr "*shift_jis*"

#: ../Doc/library/codecs.rst:1210
msgid "csshiftjis, shiftjis, sjis, s_jis"
msgstr "*csshiftjis*, *shiftjis*, *sjis*, *s_jis*"

#: ../Doc/library/codecs.rst:1213
msgid "shift_jis_2004"
msgstr "*shift_jis_2004*"

#: ../Doc/library/codecs.rst:1213
msgid "shiftjis2004, sjis_2004, sjis2004"
msgstr "*shiftjis2004*, *sjis_2004*, *sjis2004*"

#: ../Doc/library/codecs.rst:1216
msgid "shift_jisx0213"
msgstr "*shift_jisx0213*"

#: ../Doc/library/codecs.rst:1216
msgid "shiftjisx0213, sjisx0213, s_jisx0213"
msgstr "*shiftjisx0213*, *sjisx0213*, *s_jisx0213*"

#: ../Doc/library/codecs.rst:1219
msgid "utf_32"
msgstr "*utf_32*"

#: ../Doc/library/codecs.rst:1219
msgid "U32, utf32"
msgstr "*U32*, *utf32*"

#: ../Doc/library/codecs.rst:1219 ../Doc/library/codecs.rst:1221
#: ../Doc/library/codecs.rst:1223 ../Doc/library/codecs.rst:1225
#: ../Doc/library/codecs.rst:1227 ../Doc/library/codecs.rst:1229
#: ../Doc/library/codecs.rst:1231 ../Doc/library/codecs.rst:1233
#: ../Doc/library/codecs.rst:1235
msgid "all languages"
msgstr ""

#: ../Doc/library/codecs.rst:1221
msgid "utf_32_be"
msgstr "*utf_32_be*"

#: ../Doc/library/codecs.rst:1221
msgid "UTF-32BE"
msgstr "*UTF-32BE*"

#: ../Doc/library/codecs.rst:1223
msgid "utf_32_le"
msgstr "*utf_32_le*"

#: ../Doc/library/codecs.rst:1223
msgid "UTF-32LE"
msgstr "*UTF-32LE*"

#: ../Doc/library/codecs.rst:1225
msgid "utf_16"
msgstr "*utf_16*"

#: ../Doc/library/codecs.rst:1225
msgid "U16, utf16"
msgstr "*U16*, *utf16*"

#: ../Doc/library/codecs.rst:1227
msgid "utf_16_be"
msgstr "*utf_16_be*"

#: ../Doc/library/codecs.rst:1227
msgid "UTF-16BE"
msgstr "*UTF-16BE*"

#: ../Doc/library/codecs.rst:1229
msgid "utf_16_le"
msgstr "*utf_16_le*"

#: ../Doc/library/codecs.rst:1229
msgid "UTF-16LE"
msgstr "*UTF-16LE*"

#: ../Doc/library/codecs.rst:1231
msgid "utf_7"
msgstr "*utf_7*"

#: ../Doc/library/codecs.rst:1231
msgid "U7, unicode-1-1-utf-7"
msgstr "*U7*, *unicode-1-1-utf-7*"

#: ../Doc/library/codecs.rst:1233
msgid "utf_8"
msgstr "*utf_8*"

#: ../Doc/library/codecs.rst:1233
#, fuzzy
msgid "U8, UTF, utf8, cp65001"
msgstr "*U8*, *UTF*, *utf8*"

#: ../Doc/library/codecs.rst:1235
msgid "utf_8_sig"
msgstr "*utf_8_sig*"

#: ../Doc/library/codecs.rst:1238
msgid ""
"The utf-16\\* and utf-32\\* encoders no longer allow surrogate code points "
"(``U+D800``--``U+DFFF``) to be encoded. The utf-32\\* decoders no longer "
"decode byte sequences that correspond to surrogate code points."
msgstr ""

#: ../Doc/library/codecs.rst:1244
msgid "``cp65001`` is now an alias to ``utf_8``."
msgstr ""

#: ../Doc/library/codecs.rst:1249
msgid "Python Specific Encodings"
msgstr ""

#: ../Doc/library/codecs.rst:1251
msgid ""
"A number of predefined codecs are specific to Python, so their codec names "
"have no meaning outside Python. These are listed in the tables below based "
"on the expected input and output types (note that while text encodings are "
"the most common use case for codecs, the underlying codec infrastructure "
"supports arbitrary data transforms rather than just text encodings). For "
"asymmetric codecs, the stated meaning describes the encoding direction."
msgstr ""

#: ../Doc/library/codecs.rst:1259
msgid "Text Encodings"
msgstr ""

#: ../Doc/library/codecs.rst:1261
msgid ""
"The following codecs provide :class:`str` to :class:`bytes` encoding and :"
"term:`bytes-like object` to :class:`str` decoding, similar to the Unicode "
"text encodings."
msgstr ""

#: ../Doc/library/codecs.rst:1270
msgid "idna"
msgstr "idna"

#: ../Doc/library/codecs.rst:1270
msgid ""
"Implement :rfc:`3490`, see also :mod:`encodings.idna`. Only "
"``errors='strict'`` is supported."
msgstr ""

#: ../Doc/library/codecs.rst:1276
msgid "mbcs"
msgstr "mbcs"

#: ../Doc/library/codecs.rst:1276
msgid "ansi, dbcs"
msgstr ""

#: ../Doc/library/codecs.rst:1276
msgid ""
"Windows only: Encode the operand according to the ANSI codepage (CP_ACP)."
msgstr ""

#: ../Doc/library/codecs.rst:1280
msgid "oem"
msgstr ""

#: ../Doc/library/codecs.rst:1280
msgid ""
"Windows only: Encode the operand according to the OEM codepage (CP_OEMCP)."
msgstr ""

#: ../Doc/library/codecs.rst:1286
msgid "palmos"
msgstr "palmos"

#: ../Doc/library/codecs.rst:1286
msgid "Encoding of PalmOS 3.5."
msgstr ""

#: ../Doc/library/codecs.rst:1288
msgid "punycode"
msgstr "punycode"

#: ../Doc/library/codecs.rst:1288
msgid "Implement :rfc:`3492`. Stateful codecs are not supported."
msgstr ""

#: ../Doc/library/codecs.rst:1292
msgid "raw_unicode_escape"
msgstr "raw_unicode_escape"

#: ../Doc/library/codecs.rst:1292
msgid ""
"Latin-1 encoding with ``\\uXXXX`` and ``\\UXXXXXXXX`` for other code points. "
"Existing backslashes are not escaped in any way. It is used in the Python "
"pickle protocol."
msgstr ""

#: ../Doc/library/codecs.rst:1301
msgid "undefined"
msgstr "undefined"

#: ../Doc/library/codecs.rst:1301
msgid ""
"Raise an exception for all conversions, even empty strings. The error "
"handler is ignored."
msgstr ""

#: ../Doc/library/codecs.rst:1306
msgid "unicode_escape"
msgstr "unicode_escape"

#: ../Doc/library/codecs.rst:1306
msgid ""
"Encoding suitable as the contents of a Unicode literal in ASCII-encoded "
"Python source code, except that quotes are not escaped. Decode from Latin-1 "
"source code. Beware that Python source code actually uses UTF-8 by default."
msgstr ""

#: ../Doc/library/codecs.rst:1318
msgid "\"unicode_internal\" codec is removed."
msgstr ""

#: ../Doc/library/codecs.rst:1325
msgid "Binary Transforms"
msgstr ""

#: ../Doc/library/codecs.rst:1327
msgid ""
"The following codecs provide binary transforms: :term:`bytes-like object` "
"to :class:`bytes` mappings. They are not supported by :meth:`bytes.decode` "
"(which only produces :class:`str` output)."
msgstr ""

#: ../Doc/library/codecs.rst:1335
msgid "Encoder / decoder"
msgstr ""

#: ../Doc/library/codecs.rst:1337
msgid "base64_codec [#b64]_"
msgstr "base64_codec [#b64]_"

#: ../Doc/library/codecs.rst:1337
msgid "base64, base_64"
msgstr "base64, base_64"

#: ../Doc/library/codecs.rst:1337
msgid ""
"Convert the operand to multiline MIME base64 (the result always includes a "
"trailing ``'\\n'``)."
msgstr ""

#: ../Doc/library/codecs.rst:1342
msgid ""
"accepts any :term:`bytes-like object` as input for encoding and decoding"
msgstr ""

#: ../Doc/library/codecs.rst:1337
msgid ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"
msgstr ""

#: ../Doc/library/codecs.rst:1348
msgid "bz2_codec"
msgstr "bz2_codec"

#: ../Doc/library/codecs.rst:1348
msgid "bz2"
msgstr "bz2"

#: ../Doc/library/codecs.rst:1348
msgid "Compress the operand using bz2."
msgstr ""

#: ../Doc/library/codecs.rst:1348
msgid ":meth:`bz2.compress` / :meth:`bz2.decompress`"
msgstr ""

#: ../Doc/library/codecs.rst:1351
msgid "hex_codec"
msgstr "hex_codec"

#: ../Doc/library/codecs.rst:1351
msgid "hex"
msgstr "hex"

#: ../Doc/library/codecs.rst:1351
msgid ""
"Convert the operand to hexadecimal representation, with two digits per byte."
msgstr ""

#: ../Doc/library/codecs.rst:1351
msgid ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"
msgstr ""

#: ../Doc/library/codecs.rst:1356
msgid "quopri_codec"
msgstr "quopri_codec"

#: ../Doc/library/codecs.rst:1356
msgid "quopri, quotedprintable, quoted_printable"
msgstr ""

#: ../Doc/library/codecs.rst:1356
msgid "Convert the operand to MIME quoted printable."
msgstr ""

#: ../Doc/library/codecs.rst:1356
msgid ":meth:`quopri.encode` with ``quotetabs=True`` / :meth:`quopri.decode`"
msgstr ""

#: ../Doc/library/codecs.rst:1360
msgid "uu_codec"
msgstr "uu_codec"

#: ../Doc/library/codecs.rst:1360
msgid "uu"
msgstr "uu"

#: ../Doc/library/codecs.rst:1360
msgid "Convert the operand using uuencode."
msgstr ""

#: ../Doc/library/codecs.rst:1360
msgid ":meth:`uu.encode` / :meth:`uu.decode`"
msgstr ""

#: ../Doc/library/codecs.rst:1363
msgid "zlib_codec"
msgstr "zlib_codec"

#: ../Doc/library/codecs.rst:1363
msgid "zip, zlib"
msgstr "zip, zlib"

#: ../Doc/library/codecs.rst:1363
msgid "Compress the operand using gzip."
msgstr ""

#: ../Doc/library/codecs.rst:1363
msgid ":meth:`zlib.compress` / :meth:`zlib.decompress`"
msgstr ":meth:`zlib.compress` / :meth:`zlib.decompress`"

#: ../Doc/library/codecs.rst:1367
msgid ""
"In addition to :term:`bytes-like objects <bytes-like object>`, "
"``'base64_codec'`` also accepts ASCII-only instances of :class:`str` for "
"decoding"
msgstr ""

#: ../Doc/library/codecs.rst:1371
msgid "Restoration of the binary transforms."
msgstr ""

#: ../Doc/library/codecs.rst:1374
msgid "Restoration of the aliases for the binary transforms."
msgstr ""

#: ../Doc/library/codecs.rst:1381
msgid "Text Transforms"
msgstr ""

#: ../Doc/library/codecs.rst:1383
msgid ""
"The following codec provides a text transform: a :class:`str` to :class:"
"`str` mapping. It is not supported by :meth:`str.encode` (which only "
"produces :class:`bytes` output)."
msgstr ""

#: ../Doc/library/codecs.rst:1392
msgid "rot_13"
msgstr "rot_13"

#: ../Doc/library/codecs.rst:1392
msgid "rot13"
msgstr "rot13"

#: ../Doc/library/codecs.rst:1392
msgid "Return the Caesar-cypher encryption of the operand."
msgstr ""

#: ../Doc/library/codecs.rst:1397
msgid "Restoration of the ``rot_13`` text transform."
msgstr ""

#: ../Doc/library/codecs.rst:1400
msgid "Restoration of the ``rot13`` alias."
msgstr ""

#: ../Doc/library/codecs.rst:1405
msgid ""
":mod:`encodings.idna` --- Internationalized Domain Names in Applications"
msgstr ""

#: ../Doc/library/codecs.rst:1411
msgid ""
"This module implements :rfc:`3490` (Internationalized Domain Names in "
"Applications) and :rfc:`3492` (Nameprep: A Stringprep Profile for "
"Internationalized Domain Names (IDN)). It builds upon the ``punycode`` "
"encoding and :mod:`stringprep`."
msgstr ""

#: ../Doc/library/codecs.rst:1416
msgid ""
"These RFCs together define a protocol to support non-ASCII characters in "
"domain names. A domain name containing non-ASCII characters (such as ``www."
"Alliancefrançaise.nu``) is converted into an ASCII-compatible encoding (ACE, "
"such as ``www.xn--alliancefranaise-npb.nu``). The ACE form of the domain "
"name is then used in all places where arbitrary characters are not allowed "
"by the protocol, such as DNS queries, HTTP :mailheader:`Host` fields, and so "
"on. This conversion is carried out in the application; if possible invisible "
"to the user: The application should transparently convert Unicode domain "
"labels to IDNA on the wire, and convert back ACE labels to Unicode before "
"presenting them to the user."
msgstr ""

#: ../Doc/library/codecs.rst:1427
msgid ""
"Python supports this conversion in several ways:  the ``idna`` codec "
"performs conversion between Unicode and ACE, separating an input string into "
"labels based on the separator characters defined in :rfc:`section 3.1 of RFC "
"3490 <3490#section-3.1>` and converting each label to ACE as required, and "
"conversely separating an input byte string into labels based on the ``.`` "
"separator and converting any ACE labels found into unicode. Furthermore, "
"the :mod:`socket` module transparently converts Unicode host names to ACE, "
"so that applications need not be concerned about converting host names "
"themselves when they pass them to the socket module. On top of that, modules "
"that have host names as function parameters, such as :mod:`http.client` and :"
"mod:`ftplib`, accept Unicode host names (:mod:`http.client` then also "
"transparently sends an IDNA hostname in the :mailheader:`Host` field if it "
"sends that field at all)."
msgstr ""

#: ../Doc/library/codecs.rst:1440
msgid ""
"When receiving host names from the wire (such as in reverse name lookup), no "
"automatic conversion to Unicode is performed: applications wishing to "
"present such host names to the user should decode them to Unicode."
msgstr ""

#: ../Doc/library/codecs.rst:1444
msgid ""
"The module :mod:`encodings.idna` also implements the nameprep procedure, "
"which performs certain normalizations on host names, to achieve case-"
"insensitivity of international domain names, and to unify similar "
"characters. The nameprep functions can be used directly if desired."
msgstr ""

#: ../Doc/library/codecs.rst:1452
msgid ""
"Return the nameprepped version of *label*. The implementation currently "
"assumes query strings, so ``AllowUnassigned`` is true."
msgstr ""

#: ../Doc/library/codecs.rst:1458
msgid ""
"Convert a label to ASCII, as specified in :rfc:`3490`. ``UseSTD3ASCIIRules`` "
"is assumed to be false."
msgstr ""

#: ../Doc/library/codecs.rst:1464
msgid "Convert a label to Unicode, as specified in :rfc:`3490`."
msgstr ""

#: ../Doc/library/codecs.rst:1468
msgid ":mod:`encodings.mbcs` --- Windows ANSI codepage"
msgstr ""

#: ../Doc/library/codecs.rst:1473
msgid "This module implements the ANSI codepage (CP_ACP)."
msgstr ""

#: ../Doc/library/codecs.rst:1476
msgid ":ref:`Availability <availability>`: Windows only."
msgstr ":ref:`Disponibilité <availability>` : Windows uniquement."

#: ../Doc/library/codecs.rst:1477
msgid "Support any error handler."
msgstr ""

#: ../Doc/library/codecs.rst:1480
msgid ""
"Before 3.2, the *errors* argument was ignored; ``'replace'`` was always used "
"to encode, and ``'ignore'`` to decode."
msgstr ""

#: ../Doc/library/codecs.rst:1486
msgid ":mod:`encodings.utf_8_sig` --- UTF-8 codec with BOM signature"
msgstr ""

#: ../Doc/library/codecs.rst:1492
msgid ""
"This module implements a variant of the UTF-8 codec. On encoding, a UTF-8 "
"encoded BOM will be prepended to the UTF-8 encoded bytes. For the stateful "
"encoder this is only done once (on the first write to the byte stream). On "
"decoding, an optional UTF-8 encoded BOM at the start of the data will be "
"skipped."
msgstr ""

#~ msgid "West Europe"
#~ msgstr "Europe de l'Ouest"

#~ msgid "Purpose"
#~ msgstr "Objectif"

#~ msgid "cp65001"
#~ msgstr "*cp65001*"

#~ msgid "Windows only: Windows UTF-8 (``CP_UTF8``)"
#~ msgstr "Windows uniquement : Windows UTF-8 (``CP_UTF8``)"
