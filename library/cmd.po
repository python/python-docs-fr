# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2023-07-21 12:43+0200\n"
"Last-Translator: Edith Viau <info@eviau.net>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0.1\n"

#: library/cmd.rst:2
#, fuzzy
msgid ":mod:`!cmd` --- Support for line-oriented command interpreters"
msgstr ":mod:`cmd` — Interpréteurs en ligne de commande."

#: library/cmd.rst:9
msgid "**Source code:** :source:`Lib/cmd.py`"
msgstr "**Code source:** :source:`Lib/cmd.py`"

#: library/cmd.rst:13
msgid ""
"The :class:`Cmd` class provides a simple framework for writing line-oriented "
"command interpreters.  These are often useful for test harnesses, "
"administrative tools, and prototypes that will later be wrapped in a more "
"sophisticated interface."
msgstr ""
"La :class:`Cmd` fournit une base simple permettant d'écrire des "
"interpréteurs en ligne de commande. Ceux-ci sont souvent utiles pour piloter "
"des tests, pour des outils administratifs, et pour des prototypes destinés à "
"être intégrés à une interface plus sophistiquée."

#: library/cmd.rst:20
msgid ""
"A :class:`Cmd` instance or subclass instance is a line-oriented interpreter "
"framework.  There is no good reason to instantiate :class:`Cmd` itself; "
"rather, it's useful as a superclass of an interpreter class you define "
"yourself in order to inherit :class:`Cmd`'s methods and encapsulate action "
"methods."
msgstr ""
"Une instance de :class:`Cmd` ou d'une classe en héritant est un *framework* "
"orienté ligne de commande. Il n'y a pas de bonne raison d'instancier :class:"
"`Cmd` directement. Elle est plutôt utile en tant que classe mère d'une "
"classe-interprète que vous définirez afin d'hériter des méthodes de :class:"
"`Cmd` et d'encapsuler les opérations."

#: library/cmd.rst:25
msgid ""
"The optional argument *completekey* is the :mod:`readline` name of a "
"completion key; it defaults to :kbd:`Tab`. If *completekey* is not :const:"
"`None` and :mod:`readline` is available, command completion is done "
"automatically."
msgstr ""
"L'argument facultatif *completekey* est le nom :mod:`readline` d'une touche "
"de complétion. Si *completekey* ne vaut pas :const:`None` et que :mod:"
"`readline` est disponible, la complétion de commandes est faite "
"automatiquement."

#: library/cmd.rst:29
msgid ""
"The optional arguments *stdin* and *stdout* specify the  input and output "
"file objects that the Cmd instance or subclass  instance will use for input "
"and output. If not specified, they will default to :data:`sys.stdin` and :"
"data:`sys.stdout`."
msgstr ""
"Les arguments facultatifs *stdin* et *stdout* spécifient les objets-fichiers "
"de lecture et d'écriture que l'instance de Cmd ou d'une classe fille "
"utilisera comme entrée et sortie. Si ces arguments ne sont pas spécifiés, "
"ils prendront comme valeur par défaut :data:`sys.stdin` et :data:`sys."
"stdout`."

#: library/cmd.rst:34
msgid ""
"If you want a given *stdin* to be used, make sure to set the instance's :"
"attr:`use_rawinput` attribute to ``False``, otherwise *stdin* will be "
"ignored."
msgstr ""
"Si vous souhaitez qu'un *stdin* donné soit utilisé, assurez-vous que "
"l'attribut :attr:`use_rawinput` de l'instance vaille ``False``, faute de "
"quoi *stdin* sera ignoré."

#: library/cmd.rst:42
msgid "Cmd Objects"
msgstr "Objets Cmd"

#: library/cmd.rst:44
msgid "A :class:`Cmd` instance has the following methods:"
msgstr "Une instance de :class:`Cmd` possède les méthodes suivantes :"

#: library/cmd.rst:49
msgid ""
"Repeatedly issue a prompt, accept input, parse an initial prefix off the "
"received input, and dispatch to action methods, passing them the remainder "
"of the line as argument."
msgstr ""
"Affiche une invite de commande de manière répétée, accepte une entrée, "
"soustrait un préfixe initial de l'entrée reçue et envoie aux méthodes "
"d'opération la partie restante de l'entrée reçue."

#: library/cmd.rst:53
msgid ""
"The optional argument is a banner or intro string to be issued before the "
"first prompt (this overrides the :attr:`intro` class attribute)."
msgstr ""
"L'argument facultatif est une bannière ou chaîne de caractères "
"d'introduction à afficher avant la première invite de commande (il redéfinit "
"l'attribut de classe :attr:`intro`)."

#: library/cmd.rst:56
msgid ""
"If the :mod:`readline` module is loaded, input will automatically inherit :"
"program:`bash`\\ -like history-list editing (e.g. :kbd:`Control-P` scrolls "
"back to the last command, :kbd:`Control-N` forward to the next one, :kbd:"
"`Control-F` moves the cursor to the right non-destructively, :kbd:`Control-"
"B` moves the cursor to the left non-destructively, etc.)."
msgstr ""
"Si le module :mod:`readline` est chargé, l'entrée héritera automatiquement "
"d'une édition d'historique similaire à :program:`bash` (Par exemple, :kbd:"
"`Control-P` reviendra à la dernière commande, :kbd:`Control-N` avancera à la "
"suivante, :kbd:`Control-F` déplace le curseur vers la droite, :kbd:`Control-"
"B` déplace le curseur vers la gauche, etc...)."

#: library/cmd.rst:62
msgid "An end-of-file on input is passed back as the string ``'EOF'``."
msgstr ""
"Une caractère de fin de fichier est transmis via la chaîne de caractères "
"``'EOF'``."

#: library/cmd.rst:68
#, fuzzy
msgid ""
"An interpreter instance will recognize a command name ``foo`` if and only if "
"it has a method :meth:`!do_foo`.  As a special case, a line beginning with "
"the character ``'?'`` is dispatched to the method :meth:`do_help`.  As "
"another special case, a line beginning with the character ``'!'`` is "
"dispatched to the method :meth:`!do_shell` (if such a method is defined)."
msgstr ""
"Une instance d'un interpréteur reconnaîtra un nom de commande ``foo`` si et "
"seulement si celle-ci possède une méthode :meth:`do_foo`. Les lignes "
"commençant par le caractère ``'?'`` sont un cas particulier: elles sont "
"envoyées à la méthode :meth:`do_help`. Les lignes commençant par le "
"caractère ``'!'`` sont également un cas particulier: elles sont envoyées à "
"la méthode :meth:`do_shell` (si une telle méthode est définie)."

#: library/cmd.rst:74
#, fuzzy
msgid ""
"This method will return when the :meth:`postcmd` method returns a true "
"value. The *stop* argument to :meth:`postcmd` is the return value from the "
"command's corresponding :meth:`!do_\\*` method."
msgstr ""
"Cette méthode ne s'arrêtera que lorsque :meth:`postcmd` renverra une valeur "
"vraie. L'argument *stop* de :meth:`postcmd` est la valeur de retour de la "
"méthode :meth:`do_\\*` correspondant à la commande."

#: library/cmd.rst:78
#, fuzzy
msgid ""
"If completion is enabled, completing commands will be done automatically, "
"and completing of commands args is done by calling :meth:`!complete_foo` "
"with arguments *text*, *line*, *begidx*, and *endidx*.  *text* is the string "
"prefix we are attempting to match: all returned matches must begin with it. "
"*line* is the current input line with leading whitespace removed, *begidx* "
"and *endidx* are the beginning and ending indexes of the prefix text, which "
"could be used to provide different completion depending upon which position "
"the argument is in."
msgstr ""
"Si la complétion est activée, la complétion de commandes sera faite "
"automatiquement; et la complétion d'arguments sera faite en appelant :meth:"
"`complete_foo` avec les arguments *text*, *line*, *begidx*, et *endidx*. "
"*text* est le préfixe que nous cherchons à faire coïncider: toutes les "
"valeurs renvoyées doivent commencer par ce préfixe. *line* est la ligne "
"d'entrée actuelle sans les espaces blancs de début. *begidx* et *endidx* "
"sont les index de début et de fin du préfixe, ils pourraient être utilisés "
"pour fournir différentes complétions en fonction de la position de "
"l'argument."

#: library/cmd.rst:89
#, fuzzy
msgid ""
"All subclasses of :class:`Cmd` inherit a predefined :meth:`!do_help`.  This "
"method, called with an argument ``'bar'``, invokes the corresponding method :"
"meth:`!help_bar`, and if that is not present, prints the docstring of :meth:"
"`!do_bar`, if available.  With no argument, :meth:`!do_help` lists all "
"available help topics (that is, all commands with corresponding :meth:`!"
"help_\\*` methods or commands that have docstrings), and also lists any "
"undocumented commands."
msgstr ""
"Toutes les classes filles de :class:`Cmd` héritent d'une méthode :meth:"
"`do_help` prédéfinie. Cette méthode appellera la méthode :meth:`help_bar` "
"lorsqu'elle est appelée avec un argument ``'bar'``. Si celle-ci n'est pas "
"définie, elle affichera la *docstring* de :meth:`do_bar`, (si elle a une "
"*docstring*). Sans argument, :meth:`do_help` listera tous les sujets d'aide "
"(c'est à dire, toutes les commandes avec une méthode :meth:`help_\\\\*` "
"correspondante ou commande ayant une *docstring*, elle lisera aussi les "
"commandes non documentées."

#: library/cmd.rst:100
#, fuzzy
msgid ""
"Interpret the argument as though it had been typed in response to the "
"prompt. This may be overridden, but should not normally need to be; see the :"
"meth:`precmd` and :meth:`postcmd` methods for useful execution hooks.  The "
"return value is a flag indicating whether interpretation of commands by the "
"interpreter should stop.  If there is a :meth:`!do_\\*` method for the "
"command *str*, the return value of that method is returned, otherwise the "
"return value from the :meth:`default` method is returned."
msgstr ""
"Interprète l'argument comme si il avait été entré en réponse à l'invite de "
"commande. Cette méthode peut être surchargée, mais ne devrait normalement "
"pas avoir besoin de l'être; voir les méthodes :meth:`precmd` et :meth:"
"`postcmd` pour altérer l'exécution d'une commande. La valeur de retour est "
"un *flag* indiquant si l'interprétation de commandes par l'interpréteur "
"devrait arrêter. S'il existe une méthode :meth:`do_\\*` pour la commande "
"*str*, la valeur de retour de cette méthode est renvoyée. Dans le cas "
"contraire, la valeur de retour de la méthode :meth:`default` est renvoyée."

#: library/cmd.rst:111
msgid ""
"Method called when an empty line is entered in response to the prompt. If "
"this method is not overridden, it repeats the last nonempty command entered."
msgstr ""
"Méthode appelée quand une ligne vide est entrée en réponse à l'invite de "
"commande. Si cette méthode n'est pas surchargée, elle répète la dernière "
"commande non-vide entrée."

#: library/cmd.rst:117
msgid ""
"Method called on an input line when the command prefix is not recognized. If "
"this method is not overridden, it prints an error message and returns."
msgstr ""
"Méthode appelée lorsque le préfixe de commande d'une ligne entrée n'est pas "
"reconnu. Si cette méthode n'est pas surchargée, elle affiche un message "
"d'erreur et s'arrête."

#: library/cmd.rst:123
#, fuzzy
msgid ""
"Method called to complete an input line when no command-specific :meth:`!"
"complete_\\*` method is available.  By default, it returns an empty list."
msgstr ""
"Méthode appelée pour compléter une ligne entrée quand aucune méthode :meth:"
"`complete_\\*` spécifique à la commande n'est disponible. Par défaut, elle "
"renvoie une liste vide."

#: library/cmd.rst:129
msgid ""
"Method called to display a list of strings as a compact set of columns. Each "
"column is only as wide as necessary. Columns are separated by two spaces for "
"readability."
msgstr ""
"Méthode appelée pour afficher une liste de chaînes de caractères sous la "
"forme d'un ensemble compact de colonnes. Chaque colonne est de largeur "
"minimale. Les colonnes sont séparées par deux espaces pour faciliter la "
"lecture."

#: library/cmd.rst:136
msgid ""
"Hook method executed just before the command line *line* is interpreted, but "
"after the input prompt is generated and issued.  This method is a stub in :"
"class:`Cmd`; it exists to be overridden by subclasses.  The return value is "
"used as the command which will be executed by the :meth:`onecmd` method; "
"the :meth:`precmd` implementation may re-write the command or simply return "
"*line* unchanged."
msgstr ""
"Méthode de rappel exécutée juste avant que la ligne de commande *line* ne "
"soit interprétée, mais après que l'invite de commande ait été généré et "
"affiché. Cette méthode existe afin d'être surchargée par des classes filles "
"de :class:`Cmd`. La valeur de retour est utilisée comme la commande qui sera "
"exécutée par la méthode :meth:`onecmd`. L'implémentation de :meth:`precmd` "
"peut réécrire la commande ou simplement renvoyer *line* sans modification."

#: library/cmd.rst:146
msgid ""
"Hook method executed just after a command dispatch is finished.  This method "
"is a stub in :class:`Cmd`; it exists to be overridden by subclasses.  *line* "
"is the command line which was executed, and *stop* is a flag which indicates "
"whether execution will be terminated after the call to :meth:`postcmd`; this "
"will be the return value of the :meth:`onecmd` method.  The return value of "
"this method will be used as the new value for the internal flag which "
"corresponds to *stop*; returning false will cause interpretation to continue."
msgstr ""
"Méthode de rappel exécutée juste après qu'une commande ait été exécutée. "
"Cette méthode existe afin d'être surchargée par des classes filles de :class:"
"`Cmd`. *line* est la ligne de commande ayant été exécutée et *stop* est un "
"*flag* indiquant si l'exécution sera terminée après un appel à :meth:"
"`postcmd`. *stop* sera la valeur de retour de :meth:`onecmd`. La valeur de "
"retour de cette méthode sera utilisée comme nouvelle valeur pour le *flag* "
"interne correspondant à *stop*. Renvoyer *False* permettra à "
"l'interprétation de continuer."

#: library/cmd.rst:157
msgid ""
"Hook method executed once when :meth:`cmdloop` is called.  This method is a "
"stub in :class:`Cmd`; it exists to be overridden by subclasses."
msgstr ""
"Méthode de rappel exécutée une fois lorsque :meth:`cmdloop` est appelée. "
"Cette méthode existe afin d'être surchargée par des classes filles de :class:"
"`Cmd`."

#: library/cmd.rst:163
msgid ""
"Hook method executed once when :meth:`cmdloop` is about to return. This "
"method is a stub in :class:`Cmd`; it exists to be overridden by subclasses."
msgstr ""
"Méthode de rappel exécutée une fois lorsque :meth:`cmdloop` va s'arrêter. "
"Cette méthode existe afin d'être surchargée par des classes filles de :class:"
"`Cmd`."

#: library/cmd.rst:167
msgid ""
"Instances of :class:`Cmd` subclasses have some public instance variables:"
msgstr ""
"Les instances de classes filles de :class:`Cmd` possèdent des variables "
"d'instance publiques :"

#: library/cmd.rst:171
msgid "The prompt issued to solicit input."
msgstr "L'invite de commande affiché pour solliciter une entrée."

#: library/cmd.rst:176
msgid "The string of characters accepted for the command prefix."
msgstr "La chaîne de caractères acceptée en tant que préfixe de commande."

#: library/cmd.rst:181
msgid "The last nonempty command prefix seen."
msgstr "Le dernier préfixe de commande non-vide vu."

#: library/cmd.rst:186
msgid ""
"A list of queued input lines.  The cmdqueue list is checked in :meth:"
"`cmdloop` when new input is needed; if it is nonempty, its elements will be "
"processed in order, as if entered at the prompt."
msgstr ""
"Une liste de lignes entrées en file. La liste *cmdqueue* est vérifiée dans :"
"meth:`cmdloop` lorsqu'une nouvelle entrée est nécessitée; si elle n'est pas "
"vide, ses éléments seront traités dans l'ordre, comme si ils avaient entrés "
"dans l'invite de commande."

#: library/cmd.rst:193
msgid ""
"A string to issue as an intro or banner.  May be overridden by giving the :"
"meth:`cmdloop` method an argument."
msgstr ""
"Une chaîne de caractères à afficher en introduction ou bannière. Peut être "
"surchargée en passant un argument à la méthode :meth:`cmdloop`."

#: library/cmd.rst:199
msgid ""
"The header to issue if the help output has a section for documented commands."
msgstr ""
"L'en-tête à afficher si la sortie de l'aide possède une section pour les "
"commandes documentées."

#: library/cmd.rst:204
#, fuzzy
msgid ""
"The header to issue if the help output has a section for miscellaneous  help "
"topics (that is, there are :meth:`!help_\\*` methods without corresponding :"
"meth:`!do_\\*` methods)."
msgstr ""
"L'en-tête à afficher si la sortie de l'aide possède une section pour divers "
"sujets (c'est-à-dire qu'il existe des méthodes :meth:`help_\\*` sans "
"méthodes :meth:`do_\\*` correspondantes)."

#: library/cmd.rst:211
#, fuzzy
msgid ""
"The header to issue if the help output has a section for undocumented  "
"commands (that is, there are :meth:`!do_\\*` methods without corresponding :"
"meth:`!help_\\*` methods)."
msgstr ""
"L'en-tête à afficher si la sortie de l'aide possède une section pour les "
"commandes non documentées (c'est-à-dire qu'il existe des méthodes :meth:"
"`dop_\\*` sans méthodes :meth:`help_\\*` correspondantes)."

#: library/cmd.rst:218
msgid ""
"The character used to draw separator lines under the help-message headers.  "
"If empty, no ruler line is drawn.  It defaults to ``'='``."
msgstr ""
"Le caractère utilisé pour afficher des lignes de séparation sous les en-"
"têtes de messages d'aide. Si il est vide, aucune ligne de séparation n'est "
"affichée. Par défaut, ce caractère vaut ``'='``."

#: library/cmd.rst:224
#, fuzzy
msgid ""
"A flag, defaulting to true.  If true, :meth:`cmdloop` uses :func:`input` to "
"display a prompt and read the next command; if false, :data:`sys.stdout."
"write() <sys.stdout>` and :data:`sys.stdin.readline() <sys.stdin>` are used. "
"(This means that by importing :mod:`readline`, on systems that support it, "
"the interpreter will automatically support :program:`Emacs`\\ -like line "
"editing  and command-history keystrokes.)"
msgstr ""
"Un *flag*, valant *True* par défaut. Si ce *flag* est vrai, :meth:`cmdloop` "
"utilise :func:`input` pour afficher une invite de commande et lire la "
"prochaine commande; si il est faux, :meth:`sys.stdout.write` et :meth:`sys."
"stdin.readline` sont utilisées. (Cela signifie qu'en important :mod:"
"`readline` sur les systèmes qui le supportent, l'interpréteur va "
"automatiquement supporter une édition de ligne similaire à :program:`Emacs` "
"ainsi que des touches d'historique de commande)."

#: library/cmd.rst:234
msgid "Cmd Example"
msgstr "Exemple"

#: library/cmd.rst:238
msgid ""
"The :mod:`cmd` module is mainly useful for building custom shells that let a "
"user work with a program interactively."
msgstr ""
"Le module :mod:`cmd` est utile pour produire des invites de commande "
"permettant à l'utilisateur de travailler avec un programme de manière "
"interactive."

#: library/cmd.rst:241
msgid ""
"This section presents a simple example of how to build a shell around a few "
"of the commands in the :mod:`turtle` module."
msgstr ""
"Cette section présente un exemple simple de comment produire une invite de "
"commande autour de quelques commandes du module :mod:`turtle`."

#: library/cmd.rst:244
#, fuzzy
msgid ""
"Basic turtle commands such as :meth:`~turtle.forward` are added to a :class:"
"`Cmd` subclass with method named :meth:`!do_forward`.  The argument is "
"converted to a number and dispatched to the turtle module.  The docstring is "
"used in the help utility provided by the shell."
msgstr ""
"Des commandes *turtle* basiques telles que :meth:`~turtle.forward` sont "
"ajoutées à une classe fille de :class:`Cmd` avec la méthode appelée :meth:"
"`do_forward`. L'argument est converti en nombre et envoyé au module "
"*turtle*. La *docstring* est utilisée dans l'utilitaire d'aide fourni par "
"l'invite de commande."

#: library/cmd.rst:249
#, fuzzy
msgid ""
"The example also includes a basic record and playback facility implemented "
"with the :meth:`~Cmd.precmd` method which is responsible for converting the "
"input to lowercase and writing the commands to a file.  The :meth:`!"
"do_playback` method reads the file and adds the recorded commands to the :"
"attr:`~Cmd.cmdqueue` for immediate playback::"
msgstr ""
"L'exemple inclut également un utilitaire d'enregistrement et de *playback* "
"implémenté avec la méthode :meth:`~Cmd.precmd`, qui est responsable du "
"passage de l'entrée en minuscules ainsi que d'écrire les commandes dans un "
"fichier. La méthode :meth:`do_playback` lit le fichier et ajoute les "
"commandes enregistrées à :attr:`cmdqueue` pour être rejouées immédiatement ::"

#: library/cmd.rst:255
msgid ""
"import cmd, sys\n"
"from turtle import *\n"
"\n"
"class TurtleShell(cmd.Cmd):\n"
"    intro = 'Welcome to the turtle shell.   Type help or ? to list commands."
"\\n'\n"
"    prompt = '(turtle) '\n"
"    file = None\n"
"\n"
"    # ----- basic turtle commands -----\n"
"    def do_forward(self, arg):\n"
"        'Move the turtle forward by the specified distance:  FORWARD 10'\n"
"        forward(*parse(arg))\n"
"    def do_right(self, arg):\n"
"        'Turn turtle right by given number of degrees:  RIGHT 20'\n"
"        right(*parse(arg))\n"
"    def do_left(self, arg):\n"
"        'Turn turtle left by given number of degrees:  LEFT 90'\n"
"        left(*parse(arg))\n"
"    def do_goto(self, arg):\n"
"        'Move turtle to an absolute position with changing orientation.  "
"GOTO 100 200'\n"
"        goto(*parse(arg))\n"
"    def do_home(self, arg):\n"
"        'Return turtle to the home position:  HOME'\n"
"        home()\n"
"    def do_circle(self, arg):\n"
"        'Draw circle with given radius an options extent and steps:  CIRCLE "
"50'\n"
"        circle(*parse(arg))\n"
"    def do_position(self, arg):\n"
"        'Print the current turtle position:  POSITION'\n"
"        print('Current position is %d %d\\n' % position())\n"
"    def do_heading(self, arg):\n"
"        'Print the current turtle heading in degrees:  HEADING'\n"
"        print('Current heading is %d\\n' % (heading(),))\n"
"    def do_color(self, arg):\n"
"        'Set the color:  COLOR BLUE'\n"
"        color(arg.lower())\n"
"    def do_undo(self, arg):\n"
"        'Undo (repeatedly) the last turtle action(s):  UNDO'\n"
"    def do_reset(self, arg):\n"
"        'Clear the screen and return turtle to center:  RESET'\n"
"        reset()\n"
"    def do_bye(self, arg):\n"
"        'Stop recording, close the turtle window, and exit:  BYE'\n"
"        print('Thank you for using Turtle')\n"
"        self.close()\n"
"        bye()\n"
"        return True\n"
"\n"
"    # ----- record and playback -----\n"
"    def do_record(self, arg):\n"
"        'Save future commands to filename:  RECORD rose.cmd'\n"
"        self.file = open(arg, 'w')\n"
"    def do_playback(self, arg):\n"
"        'Playback commands from a file:  PLAYBACK rose.cmd'\n"
"        self.close()\n"
"        with open(arg) as f:\n"
"            self.cmdqueue.extend(f.read().splitlines())\n"
"    def precmd(self, line):\n"
"        line = line.lower()\n"
"        if self.file and 'playback' not in line:\n"
"            print(line, file=self.file)\n"
"        return line\n"
"    def close(self):\n"
"        if self.file:\n"
"            self.file.close()\n"
"            self.file = None\n"
"\n"
"def parse(arg):\n"
"    'Convert a series of zero or more numbers to an argument tuple'\n"
"    return tuple(map(int, arg.split()))\n"
"\n"
"if __name__ == '__main__':\n"
"    TurtleShell().cmdloop()"
msgstr ""

#: library/cmd.rst:330
msgid ""
"Here is a sample session with the turtle shell showing the help functions, "
"using blank lines to repeat commands, and the simple record and playback "
"facility:"
msgstr ""
"Voici une session d'exemple avec l'invite de commande *turtle*. Elle montre "
"les fonctions d'aide, utilise les lignes vides pour répéter des commandes et "
"montre l'utilitaire de *playback* :"

#: library/cmd.rst:333
msgid ""
"Welcome to the turtle shell.   Type help or ? to list commands.\n"
"\n"
"(turtle) ?\n"
"\n"
"Documented commands (type help <topic>):\n"
"========================================\n"
"bye     color    goto     home  playback  record  right\n"
"circle  forward  heading  left  position  reset   undo\n"
"\n"
"(turtle) help forward\n"
"Move the turtle forward by the specified distance:  FORWARD 10\n"
"(turtle) record spiral.cmd\n"
"(turtle) position\n"
"Current position is 0 0\n"
"\n"
"(turtle) heading\n"
"Current heading is 0\n"
"\n"
"(turtle) reset\n"
"(turtle) circle 20\n"
"(turtle) right 30\n"
"(turtle) circle 40\n"
"(turtle) right 30\n"
"(turtle) circle 60\n"
"(turtle) right 30\n"
"(turtle) circle 80\n"
"(turtle) right 30\n"
"(turtle) circle 100\n"
"(turtle) right 30\n"
"(turtle) circle 120\n"
"(turtle) right 30\n"
"(turtle) circle 120\n"
"(turtle) heading\n"
"Current heading is 180\n"
"\n"
"(turtle) forward 100\n"
"(turtle)\n"
"(turtle) right 90\n"
"(turtle) forward 100\n"
"(turtle)\n"
"(turtle) right 90\n"
"(turtle) forward 400\n"
"(turtle) right 90\n"
"(turtle) forward 500\n"
"(turtle) right 90\n"
"(turtle) forward 400\n"
"(turtle) right 90\n"
"(turtle) forward 300\n"
"(turtle) playback spiral.cmd\n"
"Current position is 0 0\n"
"\n"
"Current heading is 0\n"
"\n"
"Current heading is 180\n"
"\n"
"(turtle) bye\n"
"Thank you for using Turtle"
msgstr ""

#: library/cmd.rst:64
msgid "? (question mark)"
msgstr ""

#: library/cmd.rst:64
msgid "in a command interpreter"
msgstr ""

#: library/cmd.rst:64
msgid "! (exclamation)"
msgstr ""
