# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-07-23 14:38+0200\n"
"PO-Revision-Date: 2023-07-05 23:26+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/asyncio-eventloop.rst:8
msgid "Event Loop"
msgstr "Boucle d'évènements"

#: library/asyncio-eventloop.rst:10
msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"
msgstr ""
"**Code source :** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"

#: library/asyncio-eventloop.rst:16
msgid "Preface"
msgstr "Préface"

#: library/asyncio-eventloop.rst:17
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"La boucle d'événements est au cœur de chaque application *asyncio*. Les "
"boucles d'événements exécutent des tâches et des rappels asynchrones, "
"effectuent des opérations d'entrée-sorite réseau et exécutent des sous-"
"processus."

#: library/asyncio-eventloop.rst:21
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"Les développeurs d'applications doivent généralement utiliser les fonctions "
"*asyncio* de haut niveau, telles que :func:`asyncio.run`, et ne doivent que "
"rarement référencer l'objet boucle ou appeler ses méthodes. Cette section "
"est principalement destinée aux auteurs de code, de bibliothèques et de "
"cadriciels de bas niveau, qui ont besoin d'un contrôle plus précis sur le "
"comportement de la boucle d'événements."

#: library/asyncio-eventloop.rst:28
msgid "Obtaining the Event Loop"
msgstr "Obtention d'une boucle d'évènements"

#: library/asyncio-eventloop.rst:29
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr ""
"Les fonctions de bas niveau suivantes peuvent être utilisées pour obtenir, "
"définir ou créer une boucle d'événements :"

#: library/asyncio-eventloop.rst:34
msgid "Return the running event loop in the current OS thread."
msgstr ""
"Renvoie la boucle d'événements en cours d'exécution dans le fil actuel du "
"système d'exploitation."

#: library/asyncio-eventloop.rst:36
msgid "Raise a :exc:`RuntimeError` if there is no running event loop."
msgstr ""
"Lève une :exc:`RuntimeError` s'il n'y a pas de boucle d'événements en cours "
"d'exécution."

#: library/asyncio-eventloop.rst:38
msgid "This function can only be called from a coroutine or a callback."
msgstr ""
"Cette fonction ne peut être appelée qu'à partir d'une coroutine ou d'une "
"fonction de rappel."

#: library/asyncio-eventloop.rst:44
msgid "Get the current event loop."
msgstr "Arrête l'exécution de la boucle d'évènements."

#: library/asyncio-eventloop.rst:46
msgid ""
"When called from a coroutine or a callback (e.g. scheduled with call_soon or "
"similar API), this function will always return the running event loop."
msgstr ""
"Lorsqu'elle est appelée depuis une coroutine ou une fonction de rappel (par "
"exemple planifiée avec *call_soon* ou une API similaire), cette fonction "
"renvoie toujours la boucle d'événement en cours."

#: library/asyncio-eventloop.rst:50
msgid ""
"If there is no running event loop set, the function will return the result "
"of the ``get_event_loop_policy().get_event_loop()`` call."
msgstr ""
"S'il n'y a pas de boucle d'événement en cours d'exécution, la fonction "
"renvoie le résultat de l'appel ``get_event_loop_policy().get_event_loop()``."

#: library/asyncio-eventloop.rst:53
msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function "
"is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"Étant donné que cette fonction a un comportement plutôt complexe (en "
"particulier lorsque des politiques de boucle d'événements personnalisées "
"sont utilisées), l'utilisation de la fonction :func:`get_running_loop` est "
"préférable à :func:`get_event_loop` dans les coroutines et les fonctions de "
"rappel."

#: library/asyncio-eventloop.rst:58
msgid ""
"As noted above, consider using the higher-level :func:`asyncio.run` "
"function, instead of using these lower level functions to manually create "
"and close an event loop."
msgstr ""
"Comme indiqué ci-dessus, envisagez d'utiliser la fonction de haut niveau :"
"func:`asyncio.run`, au lieu d'utiliser ces fonctions de bas niveau pour "
"créer et fermer manuellement une boucle d'événements."

# suit un :
#: library/asyncio-eventloop.rst:63
msgid ""
"In Python versions 3.10.0--3.10.8 and 3.11.0 this function (and other "
"functions which use it implicitly) emitted a :exc:`DeprecationWarning` if "
"there was no running event loop, even if the current loop was set on the "
"policy. In Python versions 3.10.9, 3.11.1 and 3.12 they emit a :exc:"
"`DeprecationWarning` if there is no running event loop and no current loop "
"is set. In some future Python release this will become an error."
msgstr ""
"dans les versions Python 3.10.0–3.10.8 et 3.11.0, cette fonction (et "
"d'autres fonctions qui l'utilisent implicitement) levait un :exc:"
"`DeprecationWarning` s'il n'y avait pas de boucle d'événements en cours "
"d'exécution, même si la boucle actuelle était définie dans la politique. "
"Dans les versions Python 3.10.9, 3.11.1 et 3.12, elles lèvent un :exc:"
"`DeprecationWarning` s'il n'y a pas de boucle d'événements en cours et "
"qu'aucune boucle actuelle n'est définie. Dans une future version de Python, "
"cela deviendra une erreur."

#: library/asyncio-eventloop.rst:74
msgid "Set *loop* as the current event loop for the current OS thread."
msgstr ""
"Définit *loop* comme boucle d'événements actuelle pour le fil d'exécution "
"actuel du système d'exploitation."

#: library/asyncio-eventloop.rst:78
msgid "Create and return a new event loop object."
msgstr "Crée et renvoie un nouvel objet de boucle d'événements."

#: library/asyncio-eventloop.rst:80
msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
"Notez que le comportement des fonctions :func:`get_event_loop`, :func:"
"`set_event_loop` et :func:`new_event_loop` peut être modifié en :ref:"
"`définissant une politique de boucle d'événement personnalisée <asyncio-"
"policies>`."

#: library/asyncio-eventloop.rst:86
msgid "Contents"
msgstr "Sommaire"

#: library/asyncio-eventloop.rst:87
msgid "This documentation page contains the following sections:"
msgstr "Cette page de documentation contient les sections suivantes :"

# suit un :
#: library/asyncio-eventloop.rst:89
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""
"la section `Event Loop Methods`_ est la documentation de référence des API "
"de boucle d'événements ;"

# suit un :
#: library/asyncio-eventloop.rst:92
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and :class:"
"`TimerHandle` instances which are returned from scheduling methods such as :"
"meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"la section `Callback Handles`_ documente les instances :class:`Handle` et :"
"class:`TimerHandle` qui sont renvoyées par les méthodes de planification "
"telles que :meth:`loop.call_soon` et :meth:`loop.call_later` ;"

# suit un :
#: library/asyncio-eventloop.rst:96
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"la section `Server Objects`_ documente les types renvoyés par les méthodes "
"de boucle d'événements comme :meth:`loop.create_server` ;"

# suit un :
#: library/asyncio-eventloop.rst:99
msgid ""
"The `Event Loop Implementations`_ section documents the :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"la section `Event Loop Implementations`_ documente les classes :class:"
"`SelectorEventLoop` et :class:`ProactorEventLoop` ;"

# suit un :
#: library/asyncio-eventloop.rst:102
msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr ""
"la section `Exemples`_ montre comment travailler avec certaines API de "
"boucle d'événements."

#: library/asyncio-eventloop.rst:109
msgid "Event Loop Methods"
msgstr "Méthodes de la boucle d'évènements"

#: library/asyncio-eventloop.rst:111
msgid "Event loops have **low-level** APIs for the following:"
msgstr ""
"Les boucles d'événements ont des API **de bas niveau** pour les éléments "
"suivants :"

#: library/asyncio-eventloop.rst:119
msgid "Running and stopping the loop"
msgstr "Démarrer et arrêter une boucle d'évènements"

#: library/asyncio-eventloop.rst:123
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr ""
"Lance la boucle jusqu'à ce que *future* (une instance de :class:`Future`) "
"soit terminée."

#: library/asyncio-eventloop.rst:126
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"Si l'argument est un objet :ref:`coroutine <coroutine>`, il est "
"implicitement programmé pour s'exécuter en tant que :class:`asyncio.Task`."

#: library/asyncio-eventloop.rst:129
msgid "Return the Future's result or raise its exception."
msgstr "Renvoie le résultat du *Future* ou lève son exception."

#: library/asyncio-eventloop.rst:133
msgid "Run the event loop until :meth:`stop` is called."
msgstr ""
"Exécute la boucle d'événement jusqu'à ce que :meth:`stop` soit appelée."

#: library/asyncio-eventloop.rst:135
msgid ""
"If :meth:`stop` is called before :meth:`run_forever()` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled), "
"and then exit."
msgstr ""
"Si :meth:`stop` est appelée avant que :meth:`run_forever()` ne soit appelée, "
"la boucle interroge le sélecteur d'entrée-sortie une fois avec un délai "
"d'attente de zéro, exécute tous les rappels programmés en réponse aux "
"événements d'entrée-sortie (et ceux qui étaient déjà programmés), puis "
"quitte."

#: library/asyncio-eventloop.rst:140
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
"Si :meth:`stop` est appelée pendant que :meth:`run_forever` est en cours "
"d'exécution, la boucle exécute le lot actuel de rappels puis se termine. "
"Notez que les nouveaux rappels programmés par fonctions de rappel ne "
"s'exécuteront pas dans ce cas ; à la place, ils s'exécuteront la prochaine "
"fois que :meth:`run_forever` ou :meth:`run_until_complete` sera appelée."

#: library/asyncio-eventloop.rst:148
msgid "Stop the event loop."
msgstr "Arrête l'exécution de la boucle d'évènements."

#: library/asyncio-eventloop.rst:152
msgid "Return ``True`` if the event loop is currently running."
msgstr "Renvoie ``True`` si la boucle d'évènements est démarrée."

#: library/asyncio-eventloop.rst:156
msgid "Return ``True`` if the event loop was closed."
msgstr "Renvoie ``True`` si la boucle d'évènements est arrêtée."

#: library/asyncio-eventloop.rst:160
msgid "Close the event loop."
msgstr "Arrête la boucle d'évènements."

#: library/asyncio-eventloop.rst:162
msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr ""
"La boucle ne doit pas être en cours d'exécution lorsque cette fonction est "
"appelée. Tous les rappels en attente seront ignorés."

#: library/asyncio-eventloop.rst:165
msgid ""
"This method clears all queues and shuts down the executor, but does not wait "
"for the executor to finish."
msgstr ""
"Cette méthode efface toutes les files d'attente et arrête l'exécuteur, mais "
"n'attend pas que l'exécuteur se termine."

#: library/asyncio-eventloop.rst:168
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"Cette méthode est idempotente et irréversible. Aucune autre méthode ne doit "
"être appelée après la fermeture de la boucle d'événements."

#: library/asyncio-eventloop.rst:173
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose()` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""
"Planifie la fermeture de tous les objets :term:`générateurs asynchrones "
"<asynchronous generator>` actuellement ouverts avec un appel :meth:`~agen."
"aclose()`. Après avoir appelé cette méthode, la boucle d'événements émet un "
"avertissement si un nouveau générateur asynchrone est itéré. Elle doit être "
"utilisée pour finaliser de manière fiable tous les générateurs asynchrones "
"planifiés."

#: library/asyncio-eventloop.rst:179
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is "
"used."
msgstr ""
"Notez qu'il n'est pas nécessaire d'appeler cette fonction lorsque :func:"
"`asyncio.run` est utilisée."

#: library/asyncio-eventloop.rst:182 library/asyncio-eventloop.rst:1219
#: library/asyncio-eventloop.rst:1610
msgid "Example::"
msgstr "Exemple ::"

#: library/asyncio-eventloop.rst:194
msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`~concurrent.futures.ThreadPoolExecutor`. Once "
"this method has been called, using the default executor with :meth:`loop."
"run_in_executor` will raise a :exc:`RuntimeError`."
msgstr ""
"Planifie la fermeture de l'exécuteur par défaut et attend que tous les fils "
"se rejoignent dans le :class:`~concurrent.futures.ThreadPoolExecutor`. Une "
"fois cette méthode appelée, l'utilisation de l'exécuteur par défaut avec :"
"meth:`loop.run_in_executor` lève une :exc:`RuntimeError`."

# suit un :
#: library/asyncio-eventloop.rst:202
msgid ""
"Do not call this method when using :func:`asyncio.run`, as the latter "
"handles default executor shutdown automatically."
msgstr ""
"n'appelez pas cette méthode lorsque vous utilisez :func:`asyncio.run`, car "
"cette dernière gère automatiquement l'arrêt de l'exécuteur par défaut."

#: library/asyncio-eventloop.rst:209
msgid "Scheduling callbacks"
msgstr "Planification des fonctions de rappel"

#: library/asyncio-eventloop.rst:213
msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr ""
"Définit la :term:`fonction de rappel <callback>` *callback* à appeler avec "
"les arguments *args* à la prochaine itération de la boucle d'événements."

#: library/asyncio-eventloop.rst:216
msgid ""
"Return an instance of :class:`asyncio.Handle`, which can be used later to "
"cancel the callback."
msgstr ""
"Renvoie une instance de :class:`asyncio.Handle`, qui pourra être utilisée "
"ultérieurement pour annuler le rappel."

#: library/asyncio-eventloop.rst:219
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"Les fonctions de rappels sont appelées dans l'ordre dans lequel elles sont "
"enregistrées. Chaque fonction de rappel sera appelée exactement une fois."

#: library/asyncio-eventloop.rst:222
msgid ""
"The optional keyword-only *context* argument specifies a custom :class:"
"`contextvars.Context` for the *callback* to run in. Callbacks use the "
"current context when no *context* is provided."
msgstr ""
"L'argument facultatif nommé uniquement *context* spécifie un :class:"
"`contextvars.Context` personnalisé pour le *callback* à exécuter. Les "
"rappels utilisent le contexte actuel lorsqu'aucun *context* n'est fourni."

#: library/asyncio-eventloop.rst:226
msgid "Unlike :meth:`call_soon_threadsafe`, this method is not thread-safe."
msgstr ""
"Contrairement à :meth:`call_soon_threadsafe`, cette méthode n'est pas "
"compatible avec les programmes à fils d'exécution multiples."

#: library/asyncio-eventloop.rst:230
msgid ""
"A thread-safe variant of :meth:`call_soon`. When scheduling callbacks from "
"another thread, this function *must* be used, since :meth:`call_soon` is not "
"thread-safe."
msgstr ""
"Une variante compatible avec les programmes à fils d'exécution multiples de :"
"meth:`call_soon`. Lors de la planification de rappels à partir d'un autre "
"fil d'exécution, cette fonction *doit* être utilisée, puisque :meth:"
"`call_soon` n'est pas thread-safe."

#: library/asyncio-eventloop.rst:234
msgid ""
"Raises :exc:`RuntimeError` if called on a loop that's been closed. This can "
"happen on a secondary thread when the main application is shutting down."
msgstr ""
"Lève :exc:`RuntimeError` si elle est appelée sur une boucle qui a été "
"fermée. Cela peut se produire sur un fil secondaire lorsque l'application "
"principale se ferme."

#: library/asyncio-eventloop.rst:238
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Voir la section :ref:`exécution concurrente et multi-fils d'exécution "
"<asyncio-multithreading>` de la documentation."

# suit un :
#: library/asyncio-eventloop.rst:241 library/asyncio-eventloop.rst:291
#: library/asyncio-eventloop.rst:311
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"le paramètre nommé uniquement *context* a été ajouté. Voir :pep:`567` pour "
"plus de détails."

# suit un :
#: library/asyncio-eventloop.rst:249
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"la plupart des fonctions d'ordonnancement :mod:`asyncio` n'autorisent pas le "
"passage d'arguments nommés. Pour le faire, utilisez :func:`functools."
"partial` ::"

#: library/asyncio-eventloop.rst:256
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"L'utilisation d'objets partiels est généralement plus pratique que "
"l'utilisation de lambdas, car *asyncio* peut mieux rendre les objets "
"partiels dans les messages de débogage et d'erreur."

#: library/asyncio-eventloop.rst:264
msgid "Scheduling delayed callbacks"
msgstr "Planification des rappels différés"

#: library/asyncio-eventloop.rst:266
msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track time."
msgstr ""
"La boucle d'événements fournit des mécanismes pour programmer les fonctions "
"de rappel à appeler à un moment donné dans le futur. La boucle d'événements "
"utilise des horloges monotones pour suivre le temps."

#: library/asyncio-eventloop.rst:273
msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr ""
"Planifie le rappel *callback* à appeler après *delay* secondes (peut être un "
"entier ou un flottant)."

#: library/asyncio-eventloop.rst:276 library/asyncio-eventloop.rst:308
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to "
"cancel the callback."
msgstr ""
"Une instance de :class:`asyncio.TimerHandle` est renvoyée et peut être "
"utilisée pour annuler le rappel."

#: library/asyncio-eventloop.rst:279
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr ""
"*callback* sera appelé exactement une fois. Si deux rappels sont programmés "
"exactement à la même heure, l'ordre dans lequel ils sont appelés n'est pas "
"défini."

#: library/asyncio-eventloop.rst:283
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use :"
"func:`functools.partial`."
msgstr ""
"L'argument positionnel facultatif *args* sera transmis au rappel lorsqu'il "
"sera appelé. Si vous voulez que le rappel soit appelé avec des arguments "
"nommés, utilisez :func:`functools.partial`."

#: library/asyncio-eventloop.rst:287
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Un argument facultatif *context* nommé uniquement permet de spécifier un :"
"class:`contextvars.Context` personnalisé pour le *callback* à exécuter. Le "
"contexte actuel est utilisé lorsqu'aucun *context* n'est fourni."

# suit un :
#: library/asyncio-eventloop.rst:295
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr ""
"dans Python 3.7 et versions antérieures avec l'implémentation de la boucle "
"d'événements par défaut, le *delay* ne pouvait pas dépasser un jour. Cela a "
"été corrigé dans Python 3.8."

#: library/asyncio-eventloop.rst:302
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"Planifie l'appel de *callback* à l'horodatage absolu donné *when* (un *int* "
"ou un *float*), en utilisant la même référence de temps que :meth:`loop."
"time`."

#: library/asyncio-eventloop.rst:306
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "Le comportement de cette méthode est le même que :meth:`call_later`."

# suit un :
#: library/asyncio-eventloop.rst:315
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"dans Python 3.7 et versions antérieures avec l'implémentation de la boucle "
"d'événements par défaut, la différence entre *when* et l'heure actuelle ne "
"pouvait pas dépasser un jour. Cela a été corrigé dans Python 3.8."

#: library/asyncio-eventloop.rst:322
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr ""
"Renvoie l'heure actuelle, sous la forme d'une valeur :class:`float`, selon "
"l'horloge monotone interne de la boucle d'événements."

# suit un :
#: library/asyncio-eventloop.rst:326
msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr ""
"dans Python 3.7 et les versions antérieures, les délais d'expiration "
"(relatif *delay* ou absolu *when*) ne doivent pas dépasser un jour. Cela a "
"été corrigé dans Python 3.8."

# suit un :
#: library/asyncio-eventloop.rst:332
msgid "The :func:`asyncio.sleep` function."
msgstr "la fonction :func:`asyncio.sleep`."

#: library/asyncio-eventloop.rst:336
msgid "Creating Futures and Tasks"
msgstr "Création de *Futures* et des tâches"

#: library/asyncio-eventloop.rst:340
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr ""
"Crée un objet :class:`asyncio.Future` attaché à la boucle d'événements."

#: library/asyncio-eventloop.rst:342
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr ""
"C'est la méthode préférée pour créer des *Futures* avec *asyncio*. Cela "
"permet aux boucles d'événements tierces de fournir des implémentations "
"alternatives de l'objet *Future* (avec de meilleures performances ou "
"instrumentation)."

#: library/asyncio-eventloop.rst:350
msgid ""
"Schedule the execution of :ref:`coroutine <coroutine>` *coro*. Return a :"
"class:`Task` object."
msgstr ""
"Planifie l'exécution de :ref:`coroutine <coroutine>` *coro*. Renvoie un "
"objet :class:`Task`."

#: library/asyncio-eventloop.rst:353
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of :class:"
"`Task`."
msgstr ""
"Les boucles d'événements tierces peuvent utiliser leur propre sous-classe "
"de :class:`Task` pour l'interopérabilité. Dans ce cas, le type de résultat "
"est une sous-classe de :class:`Task`."

#: library/asyncio-eventloop.rst:357
msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr ""
"Si l'argument *name* est fourni et non ``None``, il est défini comme le nom "
"de la tâche en utilisant :meth:`Task.set_name`."

#: library/asyncio-eventloop.rst:360
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"Argument facultatif *context* nommé uniquement qui permet de spécifier un :"
"class:`contextvars.Context` personnalisé pour la *coro* à exécuter. La copie "
"de contexte actuel est créée lorsqu'aucun *context* n'est fourni."

#: library/asyncio-eventloop.rst:364
msgid "Added the *name* parameter."
msgstr "ajout du paramètre ``name``."

#: library/asyncio-eventloop.rst:367
msgid "Added the *context* parameter."
msgstr "ajout du paramètre ``context``."

#: library/asyncio-eventloop.rst:372
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr ""
"Définit une fabrique de tâches qui sera utilisée par :meth:`loop."
"create_task`."

#: library/asyncio-eventloop.rst:375
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro, "
"context=None)``, where *loop* is a reference to the active event loop, and "
"*coro* is a coroutine object.  The callable must return a :class:`asyncio."
"Future`-compatible object."
msgstr ""
"Si *factory* est ``None``, la fabrique de tâches par défaut sera définie. "
"Sinon, *factory* doit être un *appelable* avec la signature correspondant à "
"``(loop, coro, context=None)``, où *loop* est une référence à la boucle "
"d'événements active et *coro* est un objet coroutine . L'appelable doit "
"renvoyer un objet compatible avec :class:`asyncio.Future`."

#: library/asyncio-eventloop.rst:383
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr ""
"Renvoie une fabrique de tâches ou ``None`` si celle par défaut est utilisée."

#: library/asyncio-eventloop.rst:387
msgid "Opening network connections"
msgstr "Création de connexions"

#: library/asyncio-eventloop.rst:397
msgid ""
"Open a streaming transport connection to a given address specified by *host* "
"and *port*."
msgstr ""
"Ouvre un flux de transport connecté à l'adresse spécifiée par *host* et "
"*port*."

#: library/asyncio-eventloop.rst:400
#, fuzzy
msgid ""
"The socket family can be either :py:const:`~socket.AF_INET` or :py:const:"
"`~socket.AF_INET6` depending on *host* (or the *family* argument, if "
"provided)."
msgstr ""
"La famille de connecteur peut être :py:data:`~socket.AF_INET` ou :py:data:"
"`~socket.AF_INET6` en fonction de *host* (ou l'argument *family*, s'il est "
"fourni)."

#: library/asyncio-eventloop.rst:404
#, fuzzy
msgid "The socket type will be :py:const:`~socket.SOCK_STREAM`."
msgstr "Le type de connecteur sera :py:data:`~socket.SOCK_STREAM`."

#: library/asyncio-eventloop.rst:406 library/asyncio-eventloop.rst:1135
#: library/asyncio-eventloop.rst:1151
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* doit être un appelable renvoyant un protocole gérant le :"
"ref:`protocole asyncio <asyncio-protocol>`."

#: library/asyncio-eventloop.rst:409
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"Cette méthode tente d'établir la connexion en arrière-plan. En cas de "
"succès, elle renvoie une paire ``(transport, protocol)``."

#: library/asyncio-eventloop.rst:412
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "Le synopsis chronologique de l'opération sous-jacente est le suivant :"

#: library/asyncio-eventloop.rst:414
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr ""
"La connexion est établie et un :ref:`transport asyncio <asyncio-transport>` "
"est créé pour cela."

#: library/asyncio-eventloop.rst:417
msgid ""
"*protocol_factory* is called without arguments and is expected to return a :"
"ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* est appelée sans arguments et doit renvoyer une instance "
"de :ref:`protocol asyncio <asyncio-protocol>`."

#: library/asyncio-eventloop.rst:420
msgid ""
"The protocol instance is coupled with the transport by calling its :meth:"
"`~BaseProtocol.connection_made` method."
msgstr ""
"L'instance de protocole est couplée au transport en appelant sa méthode :"
"meth:`~BaseProtocol.connection_made`."

#: library/asyncio-eventloop.rst:423
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "Un *n*-uplet ``(transport, protocol)`` est renvoyé en cas de succès."

#: library/asyncio-eventloop.rst:425
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr ""
"Le transport créé est un flux bidirectionnel dépendant de l'implémentation."

#: library/asyncio-eventloop.rst:428 library/asyncio-eventloop.rst:549
msgid "Other arguments:"
msgstr "Autres arguments :"

#: library/asyncio-eventloop.rst:430
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is :const:"
"`True`, a default context returned from :func:`ssl.create_default_context` "
"is used."
msgstr ""
"*ssl* : s'il est donné et non faux, un transport SSL/TLS est créé (par "
"défaut un transport TCP simple est créé). Si *ssl* est un objet :class:`ssl."
"SSLContext`, ce contexte est utilisé pour créer le transport ; si *ssl* est :"
"const:`True`, un contexte par défaut renvoyé par :func:`ssl."
"create_default_context` est utilisé."

#: library/asyncio-eventloop.rst:436
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`Considérations sur la sécurité SSL/TLS <ssl-security>`"

#: library/asyncio-eventloop.rst:438
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* définit ou remplace le nom d'hôte auquel le certificat du "
"serveur cible sera comparé. Ne doit être passé que si *ssl* n'est pas "
"``None``. Par défaut, la valeur de l'argument *host* est utilisée. Si *host* "
"est vide, il n'y a pas de valeur par défaut et vous devez transmettre une "
"valeur pour *server_hostname*. Si *server_hostname* est une chaîne vide, la "
"correspondance du nom d'hôte est désactivée (ce qui constitue un risque de "
"sécurité sérieux, permettant des attaques potentielles de type « homme du "
"milieu »)."

#: library/asyncio-eventloop.rst:446
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given, "
"these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* sont facultatifs et sont la famille d'adresse, le "
"protocole et les drapeaux à transmettre à *getaddrinfo()* pour la résolution "
"de *host*. S'ils sont fournis, ils doivent tous être des entiers provenant "
"des constantes du module :mod:`socket`."

#: library/asyncio-eventloop.rst:451
msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt "
"Delay\" as defined in :rfc:`8305`. A sensible default value recommended by "
"the RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay*, s'il est fourni, active Happy Eyeballs pour cette "
"connexion. Il doit s'agir d'un nombre à virgule flottante représentant le "
"temps d'attente en secondes pour qu'une tentative de connexion se termine, "
"avant de démarrer la prochaine tentative en parallèle. Il s'agit du « délai "
"de tentative de connexion » tel que défini dans la :rfc:`8305`. Une valeur "
"par défaut raisonnable recommandée par la RFC est ``0.25`` (250 "
"millisecondes)."

#: library/asyncio-eventloop.rst:459
msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family "
"Count\" as defined in :rfc:`8305`. The default is ``0`` if "
"*happy_eyeballs_delay* is not specified, and ``1`` if it is."
msgstr ""
"*interleave* contrôle la réorganisation des adresses lorsqu'un nom d'hôte se "
"résout en plusieurs adresses IP. S'il vaut ``0`` ou n'est pas spécifié, "
"aucune réorganisation n'est effectuée et les adresses sont essayées dans "
"l'ordre renvoyé par :meth:`getaddrinfo`. Si un entier positif est spécifié, "
"les adresses sont entrelacées par famille d'adresses et l'entier donné est "
"interprété comme \"First Address Family Count\" tel que défini dans la :rfc:"
"`8305`. La valeur par défaut est ``0`` si *happy_eyeballs_delay* n'est pas "
"spécifié, et ``1`` si c'est le cas."

#: library/asyncio-eventloop.rst:468
msgid ""
"*sock*, if given, should be an existing, already connected :class:`socket."
"socket` object to be used by the transport. If *sock* is given, none of "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* and *local_addr* should be specified."
msgstr ""
"*sock*, s'il est fourni, doit être un objet :class:`socket.socket` existant "
"et déjà connecté à utiliser par le transport. Si *sock* est donné, aucun des "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* et *local_addr* ne doit être spécifié."

# suit un :
#: library/asyncio-eventloop.rst:476 library/asyncio-eventloop.rst:580
#: library/asyncio-eventloop.rst:804
msgid ""
"The *sock* argument transfers ownership of the socket to the transport "
"created. To close the socket, call the transport's :meth:`~asyncio."
"BaseTransport.close` method."
msgstr ""
"l'argument *sock* transfère la propriété du connecteur au transport créé. "
"Pour fermer le connecteur, appelez la méthode :meth:`~asyncio.BaseTransport."
"close` du transport."

#: library/asyncio-eventloop.rst:480
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using "
"``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr*, s'il est fourni, est un *n*-uplet ``(local_host, local_port)`` "
"utilisé pour lier le connecteur localement. *local_host* et *local_port* "
"sont recherchés en utilisant ``getaddrinfo()``, de la même manière que "
"*host* et *port*."

#: library/asyncio-eventloop.rst:484 library/asyncio-eventloop.rst:898
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* est (pour une connexion TLS) le temps en secondes à "
"attendre que la poignée de main TLS se termine avant d'abandonner la "
"connexion. ``60.0`` secondes si ``None`` (par défaut)."

#: library/asyncio-eventloop.rst:488 library/asyncio-eventloop.rst:721
#: library/asyncio-eventloop.rst:815 library/asyncio-eventloop.rst:902
msgid ""
"*ssl_shutdown_timeout* is the time in seconds to wait for the SSL shutdown "
"to complete before aborting the connection. ``30.0`` seconds if ``None`` "
"(default)."
msgstr ""
"*ssl_shutdown_timeout* est le temps en secondes à attendre que l'arrêt SSL "
"se termine avant d'abandonner la connexion. ``30.0`` secondes si ``None`` "
"(par défaut)."

# suit un :
#: library/asyncio-eventloop.rst:494 library/asyncio-eventloop.rst:733
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr ""
"ajout de la prise en charge de SSL/TLS dans :class:`ProactorEventLoop`."

# suit un :
#: library/asyncio-eventloop.rst:498
#, fuzzy
msgid ""
"The socket option :py:const:`~socket.TCP_NODELAY` is set by default for all "
"TCP connections."
msgstr ""
"l'option socket :py:data:`~socket.TCP_NODELAY` est définie par défaut pour "
"toutes les connexions TCP."

#: library/asyncio-eventloop.rst:503 library/asyncio-eventloop.rst:825
msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "ajout du paramètre *ssl handshake timeout*"

# suit un :
#: library/asyncio-eventloop.rst:507
msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "ajout des paramètres *happy_eyeballs_delay* et *interleave*."

#: library/asyncio-eventloop.rst:509
msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual-stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""
"Algorithme Happy Eyeballs : « succès avec les hôtes à double pile ». Lorsque "
"le chemin et le protocole IPv4 d'un serveur fonctionnent, mais que le chemin "
"et le protocole IPv6 du serveur ne fonctionnent pas, une application cliente "
"à double pile subit un retard de connexion important par rapport à un client "
"IPv4 uniquement. Ceci n'est pas souhaitable car cela entraîne une moins "
"bonne expérience utilisateur pour le client à double pile. Ce document "
"spécifie les exigences pour les algorithmes qui réduisent ce délai visible "
"par l'utilisateur et fournit un algorithme correspondant."

#: library/asyncio-eventloop.rst:518
#, fuzzy
msgid "For more information: https://datatracker.ietf.org/doc/html/rfc6555"
msgstr ""
"Pour plus d'informations, consultez : https://tools.ietf.org/html/rfc6555"

#: library/asyncio-eventloop.rst:522 library/asyncio-eventloop.rst:641
#: library/asyncio-eventloop.rst:747 library/asyncio-eventloop.rst:782
#: library/asyncio-eventloop.rst:829 library/asyncio-eventloop.rst:910
msgid "Added the *ssl_shutdown_timeout* parameter."
msgstr "ajout du paramètre *ssl shutdown timeout*"

# suit un :
#: library/asyncio-eventloop.rst:526
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be "
"used directly in async/await code."
msgstr ""
"la fonction :func:`open_connection` est une API alternative de haut niveau. "
"Elle renvoie une paire de (:class:`StreamReader`, :class:`StreamWriter`) qui "
"peut être utilisée directement dans le code *async/wait*."

#: library/asyncio-eventloop.rst:536
msgid "Create a datagram connection."
msgstr "Création d'une connexion par datagramme"

#: library/asyncio-eventloop.rst:538
#, fuzzy
msgid ""
"The socket family can be either :py:const:`~socket.AF_INET`, :py:const:"
"`~socket.AF_INET6`, or :py:const:`~socket.AF_UNIX`, depending on *host* (or "
"the *family* argument, if provided)."
msgstr ""
"La famille de connecteur peut être :py:data:`~socket.AF_INET`, :py:data:"
"`~socket.AF_INET6` ou :py:data:`~socket.AF_UNIX`, selon *host* (ou "
"l'argument *family*, s'il est fourni)."

#: library/asyncio-eventloop.rst:542
#, fuzzy
msgid "The socket type will be :py:const:`~socket.SOCK_DGRAM`."
msgstr "Le type de connecteur sera :py:data:`~socket.SOCK_DGRAM`."

#: library/asyncio-eventloop.rst:544 library/asyncio-eventloop.rst:664
#: library/asyncio-eventloop.rst:796
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr ""
"*protocol_factory* doit être un appelable gérant le :ref:`protocole asyncio "
"<asyncio-protocol>`."

#: library/asyncio-eventloop.rst:547 library/asyncio-eventloop.rst:623
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "Un *n*-uplet ``(transport, protocol)`` est renvoyé en cas de succès."

#: library/asyncio-eventloop.rst:551
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using :"
"meth:`getaddrinfo`."
msgstr ""
"*local_addr*, s'il est fourni, est un *n*-uplet ``(local_host, local_port)`` "
"utilisé pour lier le connecteur localement. Le *local_host* et le "
"*local_port* sont recherchés en utilisant :meth:`getaddrinfo`."

#: library/asyncio-eventloop.rst:555
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port* "
"are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr*, s'il est fourni, est un *n*-uplet ``(remote_host, "
"remote_port)`` utilisé pour se connecter à une adresse distante. Le "
"*remote_host* et le *remote_port* sont recherchés en utilisant :meth:"
"`getaddrinfo`."

#: library/asyncio-eventloop.rst:559
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* sont facultatifs et représentent la famille "
"d'adresse, le protocole et les drapeaux à transmettre à :meth:`getaddrinfo` "
"pour la résolution *host*. S'ils sont fournis, ils doivent tous être des "
"entiers provenant des constantes du module :mod:`socket`."

#: library/asyncio-eventloop.rst:564
#, fuzzy
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows and some "
"Unixes. If the :py:const:`~socket.SO_REUSEPORT` constant is not defined then "
"this capability is unsupported."
msgstr ""
"*reuse_port* indique au noyau d'autoriser ce point de terminaison à être lié "
"au même port que les autres points de terminaison existants, tant qu'ils "
"définissent tous cet indicateur lors de leur création. Cette option n'est "
"pas prise en charge sous Windows et certains Unix. Si la constante :py:data:"
"`~socket.SO_REUSEPORT` n'est pas définie, cette fonctionnalité n'est pas "
"prise en charge."

#: library/asyncio-eventloop.rst:570
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* indique au noyau d'autoriser ce point de terminaison à "
"envoyer des messages à l'adresse de *broadcast*."

#: library/asyncio-eventloop.rst:573
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be :const:"
"`None`)."
msgstr ""
"*sock* peut éventuellement être spécifié afin d'utiliser un objet :class:"
"`socket.socket` préexistant, déjà connecté, à utiliser par le transport. Si "
"spécifié, *local_addr* et *remote_addr* doivent être omis (doit être :const:"
"`None`)."

#: library/asyncio-eventloop.rst:584
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
"Voir les exemples :ref:`asyncio-udp-echo-client-protocol` et :ref:`asyncio-"
"udp-echo-server-protocol`."

# suit un :
#: library/asyncio-eventloop.rst:587
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"les paramètres *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast* et *sock* ont été ajoutés."

# suit un :
#: library/asyncio-eventloop.rst:591
#, fuzzy
msgid ""
"The *reuse_address* parameter is no longer supported, as using :py:const:"
"`~sockets.SO_REUSEADDR` poses a significant security concern for UDP. "
"Explicitly passing ``reuse_address=True`` will raise an exception."
msgstr ""
"le paramètre *reuse_address* n'est plus pris en charge, car l'utilisation "
"de :py:data:`~sockets.SO_REUSEADDR` pose un problème de sécurité important "
"pour UDP. Passer explicitement ``reuse_address=True`` lève une exception."

#: library/asyncio-eventloop.rst:596
msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"Lorsque plusieurs processus avec des UID différents attribuent des "
"connecteurs à une adresse de connecteur UDP identique avec ``SO_REUSEADDR``, "
"les paquets entrants peuvent être distribués de manière aléatoire entre les "
"connecteurs."

#: library/asyncio-eventloop.rst:600
#, fuzzy
msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :py:const:`~sockets.SO_REUSEPORT` "
"is used instead, which specifically prevents processes with differing UIDs "
"from assigning sockets to the same socket address."
msgstr ""
"Pour les plates-formes prises en charge, *reuse_port* peut être utilisé en "
"remplacement d'une fonctionnalité similaire. Avec *reuse_port*, :py:data:"
"`~sockets.SO_REUSEPORT` est utilisé à la place, ce qui empêche "
"spécifiquement les processus avec des UID différents d'attribuer des "
"connecteurs à la même adresse de connecteur."

# suit un :
#: library/asyncio-eventloop.rst:606
msgid "Added support for Windows."
msgstr "prise en charge sur Windows."

# suit un :
#: library/asyncio-eventloop.rst:609
msgid ""
"The *reuse_address* parameter, disabled since Python 3.9.0, 3.8.1, 3.7.6 and "
"3.6.10, has been entirely removed."
msgstr ""
"le paramètre *reuse_address*, désactivé depuis Python 3.9.0, 3.8.1, 3.7.6 et "
"3.6.10, a été entièrement supprimé."

#: library/asyncio-eventloop.rst:618
msgid "Create a Unix connection."
msgstr "Crée une connexion Unix"

#: library/asyncio-eventloop.rst:620
#, fuzzy
msgid ""
"The socket family will be :py:const:`~socket.AF_UNIX`; socket type will be :"
"py:const:`~socket.SOCK_STREAM`."
msgstr ""
"La famille de connecteur est :py:data:`~socket.AF_UNIX` ; le type de "
"connecteur est :py:data:`~socket.SOCK_STREAM`."

#: library/asyncio-eventloop.rst:625
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, :class:"
"`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* est le nom d'un connecteur de domaine Unix et est obligatoire, sauf "
"si un paramètre *sock* est spécifié. Les connecteurs Unix abstraits, les "
"chemins :class:`str`, :class:`bytes` et :class:`~pathlib.Path` sont pris en "
"charge."

#: library/asyncio-eventloop.rst:630
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""
"Voir la documentation de la méthode :meth:`loop.create_connection` pour plus "
"d'informations sur les arguments de cette méthode."

#: library/asyncio-eventloop.rst:633 library/asyncio-eventloop.rst:773
#: library/asyncio-eventloop.rst:1202
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Disponibilité <availability>` : Unix."

#: library/asyncio-eventloop.rst:635
msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`."
msgstr ""
"ajout du paramètre *ssl_handshake_timeout*. Le paramètre *chemin* peut "
"désormais être un :term:`objet simili-chemin <path-like object>`."

#: library/asyncio-eventloop.rst:645
msgid "Creating network servers"
msgstr "Création de serveurs"

#: library/asyncio-eventloop.rst:657
#, fuzzy
msgid ""
"Create a TCP server (socket type :const:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr ""
"Crée un serveur TCP (type de connecteur :data:`~socket.SOCK_STREAM`) "
"écoutant sur le *port* de l'adresse *hôte*."

#: library/asyncio-eventloop.rst:660
msgid "Returns a :class:`Server` object."
msgstr "Renvoie un objet :class:`Server`."

#: library/asyncio-eventloop.rst:662
msgid "Arguments:"
msgstr "Arguments :"

#: library/asyncio-eventloop.rst:667
msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr ""
"Le paramètre *host* peut être défini sur plusieurs types qui déterminent où "
"le serveur écoute :"

#: library/asyncio-eventloop.rst:670
msgid ""
"If *host* is a string, the TCP server is bound to a single network interface "
"specified by *host*."
msgstr ""
"Si *host* est une chaîne, le serveur TCP est lié à une seule interface "
"réseau spécifiée par *host*."

#: library/asyncio-eventloop.rst:673
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr ""
"Si *host* est une séquence de chaînes, le serveur TCP est lié à toutes les "
"interfaces réseau spécifiées par la séquence."

#: library/asyncio-eventloop.rst:676
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr ""
"Si *host* est une chaîne vide ou ``None``, toutes les interfaces sont prises "
"en compte et une liste de plusieurs connecteurs est renvoyée (probablement "
"une pour IPv4 et une autre pour IPv6)."

#: library/asyncio-eventloop.rst:680
msgid ""
"The *port* parameter can be set to specify which port the server should "
"listen on. If ``0`` or ``None`` (the default), a random unused port will be "
"selected (note that if *host* resolves to multiple network interfaces, a "
"different random port will be selected for each interface)."
msgstr ""
"Le paramètre *port* peut être défini pour spécifier sur quel port le serveur "
"doit écouter. Si ``0`` ou ``None`` (la valeur par défaut), un port inutilisé "
"aléatoire est sélectionné (notez que si *host* se résout en plusieurs "
"interfaces réseau, un port aléatoire différent est sélectionné pour chaque "
"interface)."

#: library/asyncio-eventloop.rst:685
#, fuzzy
msgid ""
"*family* can be set to either :const:`socket.AF_INET` or :const:`~socket."
"AF_INET6` to force the socket to use IPv4 or IPv6. If not set, the *family* "
"will be determined from host name (defaults to :const:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* peut être défini sur :data:`socket.AF_INET` ou sur :data:`~socket."
"AF_INET6` pour forcer le connecteur à utiliser IPv4 ou IPv6. Si elle n'est "
"pas définie, *family* est déterminée à partir du nom d'hôte (par défaut :"
"data:`~socket.AF_UNSPEC`)."

#: library/asyncio-eventloop.rst:690
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* est un masque de bits pour :meth:`getaddrinfo`."

#: library/asyncio-eventloop.rst:692
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"*sock* peut éventuellement être spécifié afin d'utiliser un objet connecteur "
"préexistant. S'il est spécifié, *host* et *port* ne doivent pas être "
"spécifiés."

# suit un :
#: library/asyncio-eventloop.rst:697
msgid ""
"The *sock* argument transfers ownership of the socket to the server created. "
"To close the socket, call the server's :meth:`~asyncio.Server.close` method."
msgstr ""
"l'argument *sock* transfère la propriété du connecteur au serveur créé. Pour "
"fermer le connecteur, appelez la méthode :meth:`~asyncio.Server.close` du "
"serveur."

#: library/asyncio-eventloop.rst:701
msgid ""
"*backlog* is the maximum number of queued connections passed to :meth:"
"`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* est le nombre maximum de connexions en file d'attente passées à :"
"meth:`~socket.socket.listen` (par défaut à 100)."

#: library/asyncio-eventloop.rst:704
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr ""
"*ssl* peut être défini sur une instance :class:`~ssl.SSLContext` pour "
"activer TLS sur les connexions acceptées."

#: library/asyncio-eventloop.rst:707
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* indique au noyau de réutiliser un connecteur local dans "
"l'état ``TIME_WAIT``, sans attendre l'expiration de son délai d'attente "
"naturel. S'il n'est pas spécifié, il est automatiquement défini sur ``True`` "
"sous Unix."

#: library/asyncio-eventloop.rst:712
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* indique au noyau d'autoriser ce point de terminaison à être lié "
"au même port que les autres points de terminaison existants, tant qu'ils "
"définissent tous cet indicateur lors de leur création. Cette option n'est "
"pas prise en charge sous Windows."

#: library/asyncio-eventloop.rst:717
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* est (pour un serveur TLS) le temps en secondes à "
"attendre que la poignée de main TLS se termine avant d'abandonner la "
"connexion. ``60.0`` secondes si ``None`` (par défaut)."

#: library/asyncio-eventloop.rst:725
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever` "
"to make the server to start accepting connections."
msgstr ""
"*start_serving* défini à ``True`` (valeur par défaut) fait que le serveur "
"créé commence immédiatement à accepter les connexions. Lorsqu'il est défini "
"sur ``False``, l'utilisateur doit attendre sur :meth:`Server.start_serving` "
"ou :meth:`Server.serve_forever` pour que le serveur commence à accepter les "
"connexions."

# suit un :
#: library/asyncio-eventloop.rst:737
msgid "The *host* parameter can be a sequence of strings."
msgstr "le paramètre *host* peut être une séquence de chaînes."

# suit un :
#: library/asyncio-eventloop.rst:741
#, fuzzy
msgid ""
"Added *ssl_handshake_timeout* and *start_serving* parameters. The socket "
"option :py:const:`~socket.TCP_NODELAY` is set by default for all TCP "
"connections."
msgstr ""
"ajout des paramètres *ssl_handshake_timeout* et *start_serving*. L'option "
"socket :py:data:`~socket.TCP_NODELAY` est définie par défaut pour toutes les "
"connexions TCP."

# suit un :
#: library/asyncio-eventloop.rst:751
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
"la fonction :func:`start_server` est une API alternative de niveau supérieur "
"qui renvoie une paire de :class:`StreamReader` et :class:`StreamWriter` qui "
"peut être utilisée dans un code *async/wait*."

#: library/asyncio-eventloop.rst:762
#, fuzzy
msgid ""
"Similar to :meth:`loop.create_server` but works with the :py:const:`~socket."
"AF_UNIX` socket family."
msgstr ""
"Similaire à :meth:`loop.create_server` mais fonctionne avec la famille de "
"connecteurs :py:data:`~socket.AF_UNIX`."

#: library/asyncio-eventloop.rst:765
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock* "
"argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`, "
"and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* est le nom d'un connecteur de domaine Unix et est obligatoire, sauf "
"si un argument *sock* est fourni. Les connecteurs Unix abstraits, les "
"chemins :class:`str`, :class:`bytes` et :class:`~pathlib.Path` sont pris en "
"charge."

#: library/asyncio-eventloop.rst:770
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""
"Voir la documentation de la méthode :meth:`loop.create_server` pour plus "
"d'informations sur les arguments de cette méthode."

# suit un :
#: library/asyncio-eventloop.rst:777
msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :class:`~pathlib.Path` object."
msgstr ""
"ajout des paramètres *ssl_handshake_timeout* et *start_serving*. Le "
"paramètre *path* peut maintenant être un objet :class:`~pathlib.Path`."

#: library/asyncio-eventloop.rst:789
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr ""
"Enveloppe une connexion déjà acceptée dans une paire transport/protocole."

#: library/asyncio-eventloop.rst:791
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr ""
"Cette méthode peut être utilisée par les serveurs qui acceptent les "
"connexions en dehors d'*asyncio* mais qui utilisent *asyncio* pour les gérer."

#: library/asyncio-eventloop.rst:794 library/asyncio-eventloop.rst:884
msgid "Parameters:"
msgstr "Paramètres :"

#: library/asyncio-eventloop.rst:799
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* est un objet connecteur préexistant renvoyé par :meth:`socket.accept "
"<socket.socket.accept>`."

#: library/asyncio-eventloop.rst:808
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* peut être défini sur une :class:`~ssl.SSLContext` pour activer SSL sur "
"les connexions acceptées."

#: library/asyncio-eventloop.rst:811
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* est (pour une connexion SSL) le temps en secondes à "
"attendre que la poignée de main SSL se termine avant d'abandonner la "
"connexion. ``60.0`` secondes si ``None`` (par défaut)."

#: library/asyncio-eventloop.rst:819
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "Renvoie une paire ``(transport, protocole)``."

#: library/asyncio-eventloop.rst:833
msgid "Transferring files"
msgstr "Transfert de fichiers"

#: library/asyncio-eventloop.rst:838
msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr ""
"Envoie *file* via *transport*. Renvoie le nombre total d'octets envoyés."

#: library/asyncio-eventloop.rst:841
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""
"La méthode utilise :meth:`os.sendfile` (hautes performances) si elle est "
"disponible."

#: library/asyncio-eventloop.rst:843
msgid "*file* must be a regular file object opened in binary mode."
msgstr "*file* doit être un objet fichier normal ouvert en mode binaire."

#: library/asyncio-eventloop.rst:845 library/asyncio-eventloop.rst:1090
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method "
"raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* indique où commencer la lecture du fichier. Si spécifié, *count* "
"est le nombre total d'octets à transmettre, par opposition à l'envoi du "
"fichier jusqu'à ce que EOF soit atteint. La position du fichier est toujours "
"mise à jour, même lorsque cette méthode génère une erreur. :meth:`file."
"tell() <io.IOBase.tell>` peut être utilisée pour obtenir le nombre d'octets "
"réellement envoyés."

#: library/asyncio-eventloop.rst:852
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or "
"SSL socket on Unix)."
msgstr ""
"*fallback* défini sur ``True`` permet à *asyncio* de lire et d'envoyer "
"manuellement le fichier lorsque la plateforme ne prend pas en charge l'appel "
"système *sendfile* (par exemple, Windows ou connecteur SSL sous Unix)."

#: library/asyncio-eventloop.rst:856
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Lève :exc:`SendfileNotAvailableError` si le système ne prend pas en charge "
"l'appel système *sendfile* et que *fallback* est ``False``."

#: library/asyncio-eventloop.rst:863
msgid "TLS Upgrade"
msgstr "Passage du flux en TLS"

#: library/asyncio-eventloop.rst:870
msgid "Upgrade an existing transport-based connection to TLS."
msgstr "Convertit une connexion existante en connexion TLS."

#: library/asyncio-eventloop.rst:872
msgid ""
"Create a TLS coder/decoder instance and insert it between the *transport* "
"and the *protocol*. The coder/decoder implements both *transport*-facing "
"protocol and *protocol*-facing transport."
msgstr ""
"Crée une instance de codeur-décodeur TLS et l'insère entre le *transport* et "
"le *protocol*. Le codeur-décodeur implémente à la fois le protocole vers le "
"*transport* et le transport vers le *protocol*."

#: library/asyncio-eventloop.rst:876
msgid ""
"Return the created two-interface instance. After *await*, the *protocol* "
"must stop using the original *transport* and communicate with the returned "
"object only because the coder caches *protocol*-side data and sporadically "
"exchanges extra TLS session packets with *transport*."
msgstr ""
"Renvoie l'instance à deux interfaces créée. Après *await*, le *protocol* "
"doit cesser d'utiliser le *transport* d'origine et communiquer avec l'objet "
"renvoyé uniquement parce que le codeur met en cache les données côté "
"*protocol* et échange sporadiquement des paquets de session TLS "
"supplémentaires avec *transport*."

#: library/asyncio-eventloop.rst:881
msgid ""
"In some situations (e.g. when the passed transport is already closing) this "
"may return ``None``."
msgstr ""

#: library/asyncio-eventloop.rst:886
msgid ""
"*transport* and *protocol* instances that methods like :meth:`~loop."
"create_server` and :meth:`~loop.create_connection` return."
msgstr ""
"*transport* et *protocol* que des méthodes comme :meth:`~loop.create_server` "
"et :meth:`~loop.create_connection` renvoient."

#: library/asyncio-eventloop.rst:890
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext* : une instance configurée de :class:`~ssl.SSLContext`."

#: library/asyncio-eventloop.rst:892
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""
"*server_side* passe à ``True`` lorsqu'une connexion côté serveur est mise à "
"jour (comme celle créée par :meth:`~loop.create_server`)."

#: library/asyncio-eventloop.rst:895
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname* : définit ou remplace le nom d'hôte auquel le certificat "
"du serveur cible est comparé."

#: library/asyncio-eventloop.rst:915
msgid "Watching file descriptors"
msgstr "Surveillance de descripteur de fichier"

#: library/asyncio-eventloop.rst:919
msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr ""
"Commence à surveiller la disponibilité en lecture du descripteur de fichier "
"*fd* et appelle *callback* avec les arguments spécifiés une fois que *fd* "
"est disponible en lecture."

#: library/asyncio-eventloop.rst:925
msgid ""
"Stop monitoring the *fd* file descriptor for read availability. Returns "
"``True`` if *fd* was previously being monitored for reads."
msgstr ""
"Arrête de surveiller le descripteur de fichier *fd* pour la disponibilité en "
"lecture. Renvoie ``True`` si *fd* était précédemment surveillé pour les "
"lectures."

#: library/asyncio-eventloop.rst:930
msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr ""
"Commence à surveiller le descripteur de fichier *fd* pour la disponibilité "
"en écriture et appelle *callback* avec les arguments spécifiés une fois que "
"*fd* est disponible en écriture."

#: library/asyncio-eventloop.rst:934 library/asyncio-eventloop.rst:1189
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""
"Utilisez :func:`functools.partial` pour :ref:`passer des arguments nommés "
"<asyncio-pass-keywords>` à *callback*."

#: library/asyncio-eventloop.rst:939
msgid ""
"Stop monitoring the *fd* file descriptor for write availability. Returns "
"``True`` if *fd* was previously being monitored for writes."
msgstr ""
"Arrête de surveiller le descripteur de fichier *fd* pour la disponibilité en "
"écriture. Renvoie ``True`` si *fd* était précédemment surveillé pour les "
"écritures."

#: library/asyncio-eventloop.rst:942
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some "
"limitations of these methods."
msgstr ""
"Voir aussi la section :ref:`Prise en charge de la plate-forme <asyncio-"
"platform-support>` pour certaines limitations de ces méthodes."

#: library/asyncio-eventloop.rst:947
msgid "Working with socket objects directly"
msgstr "Travail direct avec des objets *socket*"

#: library/asyncio-eventloop.rst:949
msgid ""
"In general, protocol implementations that use transport-based APIs such as :"
"meth:`loop.create_connection` and :meth:`loop.create_server` are faster than "
"implementations that work with sockets directly. However, there are some use "
"cases when performance is not critical, and working with :class:`~socket."
"socket` objects directly is more convenient."
msgstr ""
"En général, les implémentations de protocole qui utilisent des API basées "
"sur le transport telles que :meth:`loop.create_connection` et :meth:`loop."
"create_server` sont plus rapides que les implémentations qui fonctionnent "
"directement avec les *sockets*. Cependant, il existe des cas d'utilisation "
"où les performances ne sont pas critiques, et travailler directement avec "
"les objets :class:`~socket.socket` est plus pratique."

#: library/asyncio-eventloop.rst:958
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of :meth:`socket."
"recv() <socket.socket.recv>`."
msgstr ""
"Reçoit jusqu'à *nbytes* de *sock*. Version asynchrone de :meth:`socket."
"recv() <socket.socket.recv>`."

#: library/asyncio-eventloop.rst:961
msgid "Return the received data as a bytes object."
msgstr "Renvoie les données reçues sous la forme d'un objet bytes."

#: library/asyncio-eventloop.rst:963 library/asyncio-eventloop.rst:977
#: library/asyncio-eventloop.rst:988 library/asyncio-eventloop.rst:1000
#: library/asyncio-eventloop.rst:1015 library/asyncio-eventloop.rst:1030
#: library/asyncio-eventloop.rst:1040 library/asyncio-eventloop.rst:1066
#: library/asyncio-eventloop.rst:1104
msgid "*sock* must be a non-blocking socket."
msgstr "Le connecteur *sock* ne doit pas être bloquant."

# suit un :
#: library/asyncio-eventloop.rst:965
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this "
"is an ``async def`` method."
msgstr ""
"même si cette méthode a toujours été documentée en tant que méthode "
"coroutine, les versions antérieures à Python 3.7 renvoyaient un :class:"
"`Future`. Depuis Python 3.7, il s'agit d'une méthode ``async def``."

#: library/asyncio-eventloop.rst:972
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking :"
"meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"Reçoit les données de *sock* dans le tampon *buf*. Basée sur le modèle de la "
"méthode bloquante :meth:`socket.recv_into() <socket.socket.recv_into>`."

#: library/asyncio-eventloop.rst:975
msgid "Return the number of bytes written to the buffer."
msgstr "Renvoie le nombre d'octets écrits dans le tampon."

#: library/asyncio-eventloop.rst:983
msgid ""
"Receive a datagram of up to *bufsize* from *sock*.  Asynchronous version of :"
"meth:`socket.recvfrom() <socket.socket.recvfrom>`."
msgstr ""
"Reçoit un datagramme jusqu'à *bufsize* de *sock*. Version asynchrone de :"
"meth:`socket.recvfrom() <socket.socket.recvfrom>`."

#: library/asyncio-eventloop.rst:986
msgid "Return a tuple of (received data, remote address)."
msgstr "Renvoie un *n*-uplet (données reçues, adresse distante)."

#: library/asyncio-eventloop.rst:994
msgid ""
"Receive a datagram of up to *nbytes* from *sock* into *buf*. Asynchronous "
"version of :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."
msgstr ""
"Reçoit un datagramme jusqu'à *nbytes* de *sock* vers *buf*. Version "
"asynchrone de :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."

#: library/asyncio-eventloop.rst:998
msgid "Return a tuple of (number of bytes received, remote address)."
msgstr "Renvoie un *n*-uplet (nombre d'octets reçus, adresse distante)."

#: library/asyncio-eventloop.rst:1006
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of :meth:`socket."
"sendall() <socket.socket.sendall>`."
msgstr ""
"Envoie les données *data* au connecteur *sock*. Version asynchrone de :meth:"
"`socket.sendall() <socket.socket.sendall>`."

#: library/asyncio-eventloop.rst:1009
msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""
"Cette méthode continue d'envoyer des données au connecteur jusqu'à ce que "
"toutes les *data* aient été envoyées ou qu'une erreur se produise. ``None`` "
"est renvoyé en cas de succès. En cas d'erreur, une exception est levée. De "
"plus, il n'existe aucun moyen de déterminer la quantité de données, le cas "
"échéant, qui a été traitée avec succès par l'extrémité réceptrice de la "
"connexion."

# suit un :
#: library/asyncio-eventloop.rst:1017 library/asyncio-eventloop.rst:1068
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"même si la méthode a toujours été documentée en tant que méthode coroutine, "
"avant Python 3.7, elle renvoyait un :class:`Future`. Depuis Python 3.7, il "
"s'agit d'une méthode ``async def``."

#: library/asyncio-eventloop.rst:1024
msgid ""
"Send a datagram from *sock* to *address*. Asynchronous version of :meth:"
"`socket.sendto() <socket.socket.sendto>`."
msgstr ""
"Envoie un datagramme de *sock* à *address*. Version asynchrone de :meth:"
"`socket.sendto() <socket.socket.sendto>`."

#: library/asyncio-eventloop.rst:1028
msgid "Return the number of bytes sent."
msgstr "Renvoie le nombre d'octets envoyés."

#: library/asyncio-eventloop.rst:1036
msgid "Connect *sock* to a remote socket at *address*."
msgstr "Connecte *sock* à un connecteur distant situé à *address*."

#: library/asyncio-eventloop.rst:1038
msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr ""
"Version asynchrone de :meth:`socket.connect() <socket.socket.connect>`."

#: library/asyncio-eventloop.rst:1042
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling :func:`socket."
"inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to resolve the "
"*address*."
msgstr ""
"``address`` n'a plus besoin d'être résolu. ``sock_connect`` essaie de "
"vérifier si *address* est déjà résolue en appelant :func:`socket.inet_pton`. "
"Sinon, :meth:`loop.getaddrinfo` est utilisé pour résoudre *address*."

#: library/asyncio-eventloop.rst:1051
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection` et :func:`asyncio.open_connection() "
"<open_connection>`."

#: library/asyncio-eventloop.rst:1057
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""
"Accepte une connexion. Basée sur le modèle de la méthode bloquante :meth:"
"`socket.accept() <socket.socket.accept>`."

#: library/asyncio-eventloop.rst:1060
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"Le connecteur doit être lié à une adresse et écouter les connexions. La "
"valeur de retour est une paire ``(conn, adresse)`` où *conn* est un *nouvel* "
"objet socket utilisable pour envoyer et recevoir des données sur la "
"connexion, et *adresse* est l'adresse liée au connecteur de l'autre côté de "
"la connexion."

#: library/asyncio-eventloop.rst:1075
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server` et :func:`start_server`."

#: library/asyncio-eventloop.rst:1080
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr ""
"Envoie le fichier en utilisant :mod:`os.sendfile` (haute performance) si "
"possible. Renvoie le nombre total d'octets envoyés."

#: library/asyncio-eventloop.rst:1083
msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr ""
"Version asynchrone de :meth:`socket.sendfile() <socket.socket.sendfile>`."

#: library/asyncio-eventloop.rst:1085
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."
msgstr ""
"*sock* doit être un :const:`socket.SOCK_STREAM` :class:`~socket.socket` non "
"bloquant."

#: library/asyncio-eventloop.rst:1088
msgid "*file* must be a regular file object open in binary mode."
msgstr "*file* doit être un objet fichier normal ouvert en mode binaire."

#: library/asyncio-eventloop.rst:1097
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""
"*fallback*, lorsqu'il est défini à ``True``, permet à *asyncio* de lire et "
"d'envoyer manuellement le fichier lorsque la plateforme ne prend pas en "
"charge l'appel système *sendfile* (par exemple, Windows ou connecteur SSL "
"sous Unix)."

#: library/asyncio-eventloop.rst:1101
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Lève une :exc:`SendfileNotAvailableError` si le système ne prend pas en "
"charge l'appel système *sendfile* et que *fallback* est ``False``."

#: library/asyncio-eventloop.rst:1110
msgid "DNS"
msgstr "DNS"

#: library/asyncio-eventloop.rst:1115
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr "Version asynchrone de :meth:`socket.getaddrinfo`."

#: library/asyncio-eventloop.rst:1119
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr "Version asynchrone de :meth:`socket.getnameinfo`."

# suit un :
#: library/asyncio-eventloop.rst:1121
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning :"
"class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""
"les méthodes *getaddrinfo* et *getnameinfo* ont toujours été documentées "
"pour renvoyer une coroutine, mais avant Python 3.7, elles renvoyaient en "
"fait des objets :class:`asyncio.Future`. À partir de Python 3.7, les deux "
"méthodes sont des coroutines."

#: library/asyncio-eventloop.rst:1129
msgid "Working with pipes"
msgstr "Travail avec des tubes (*pipes*)"

#: library/asyncio-eventloop.rst:1133
msgid "Register the read end of *pipe* in the event loop."
msgstr ""
"Branche l'extrémité en lecture du tube *pipe* à la boucle d'évènements."

#: library/asyncio-eventloop.rst:1138
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr "*pipe* est un :term:`simili-fichier <file object>`."

#: library/asyncio-eventloop.rst:1140
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the :class:"
"`ReadTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Renvoie la paire ``(transport, protocol)``, où *transport* prend en charge "
"l'interface :class:`ReadTransport` et *protocol* est un objet instancié par "
"*protocol_factory*."

#: library/asyncio-eventloop.rst:1144 library/asyncio-eventloop.rst:1160
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
"Avec la boucle d'événements :class:`SelectorEventLoop`, le *pipe* est mis en "
"mode non bloquant."

#: library/asyncio-eventloop.rst:1149
msgid "Register the write end of *pipe* in the event loop."
msgstr "Branche l'extrémité en écriture de *pipe* à la boucle d'évènements."

#: library/asyncio-eventloop.rst:1154
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe* est un :term:`simili-fichier <file object>`."

#: library/asyncio-eventloop.rst:1156
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports :class:"
"`WriteTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Renvoie la paire ``(transport, protocol)``, où *transport* prend en charge "
"l'interface :class:`WriteTransport` et *protocol* est un objet instancié par "
"*protocol_factory*."

#: library/asyncio-eventloop.rst:1165
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
":class:`SelectorEventLoop` ne prend pas en charge les méthodes ci-dessus "
"sous Windows. Utilisez :class:`ProactorEventLoop` à la place pour Windows."

# suit un :
#: library/asyncio-eventloop.rst:1170
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr ""
"les méthodes :meth:`loop.subprocess_exec` et :meth:`loop.subprocess_shell`."

#: library/asyncio-eventloop.rst:1175
msgid "Unix signals"
msgstr "Signaux Unix"

#: library/asyncio-eventloop.rst:1179
msgid "Set *callback* as the handler for the *signum* signal."
msgstr "Définit *callback* comme gestionnaire du signal *signum*."

#: library/asyncio-eventloop.rst:1181
msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"La fonction de rappel sera appelée par *loop*, avec d'autres rappels en file "
"d'attente et des coroutines exécutables de cette boucle d'événements. "
"Contrairement aux gestionnaires de signaux enregistrés à l'aide de :func:"
"`signal.signal`, un rappel enregistré avec cette fonction est autorisé à "
"interagir avec la boucle d'événements."

#: library/asyncio-eventloop.rst:1186
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"Lève une :exc:`ValueError` si le numéro de signal est invalide ou non "
"attrapable. Lève une :exc:`RuntimeError` s'il y a un problème lors de la "
"configuration du gestionnaire."

#: library/asyncio-eventloop.rst:1192
msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main thread."
msgstr ""
"Comme :func:`signal.signal`, cette fonction doit être invoquée dans le fil "
"d'exécution principal."

#: library/asyncio-eventloop.rst:1197
msgid "Remove the handler for the *sig* signal."
msgstr "Supprime le gestionnaire du signal *sig*."

#: library/asyncio-eventloop.rst:1199
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr ""
"Renvoie ``True`` si le gestionnaire de signal a été supprimé, ou ``False`` "
"si aucun gestionnaire n'a été défini pour le signal donné."

# suit un :
#: library/asyncio-eventloop.rst:1206
msgid "The :mod:`signal` module."
msgstr "le module :mod:`signal`."

#: library/asyncio-eventloop.rst:1210
msgid "Executing code in thread or process pools"
msgstr "Exécution de code dans des pools de threads ou de processus"

#: library/asyncio-eventloop.rst:1214
msgid "Arrange for *func* to be called in the specified executor."
msgstr "Fait en sorte que *func* soit appelée dans l'exécuteur spécifié."

#: library/asyncio-eventloop.rst:1216
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``."
msgstr ""
"L'argument *executor* doit être une instance :class:`concurrent.futures."
"Executor`. L'exécuteur par défaut est utilisé si *executor* vaut ``None``."

#: library/asyncio-eventloop.rst:1261
msgid ""
"Note that the entry point guard (``if __name__ == '__main__'``) is required "
"for option 3 due to the peculiarities of :mod:`multiprocessing`, which is "
"used by :class:`~concurrent.futures.ProcessPoolExecutor`. See :ref:`Safe "
"importing of main module <multiprocessing-safe-main-import>`."
msgstr ""
"Notez que la garde du point d'entrée (``if __name__ == '__main__'``) est "
"requis pour l'option 3 en raison des particularités de :mod:"
"`multiprocessing`, qui est utilisé par :class:`~concurrent.futures."
"ProcessPoolExecutor`. Voir :ref:`Importation sécurisée du module principal "
"<multiprocessing-safe-main-import>`."

#: library/asyncio-eventloop.rst:1266
msgid "This method returns a :class:`asyncio.Future` object."
msgstr "Cette méthode renvoie un objet :class:`asyncio.Future`."

#: library/asyncio-eventloop.rst:1268
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""
"Utilisez :func:`functools.partial` pour :ref:`passer des arguments nommés "
"<asyncio-pass-keywords>` à *func*."

#: library/asyncio-eventloop.rst:1271
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the "
"thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""
":meth:`loop.run_in_executor` ne configure plus le ``max_workers`` de "
"l'exécuteur de pool de threads qu'il crée, laissant à la place à l'exécuteur "
"de pool de threads (:class:`~concurrent.futures.ThreadPoolExecutor`) le soin "
"de définir le défaut."

#: library/asyncio-eventloop.rst:1280
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* must be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"Définit *executor* comme exécuteur par défaut utilisé par :meth:"
"`run_in_executor`. *executor* doit être une instance de :class:`~concurrent."
"futures.ThreadPoolExecutor`."

#: library/asyncio-eventloop.rst:1284
msgid ""
"*executor* must be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"*executor* doit être une instance de :class:`~concurrent.futures."
"ThreadPoolExecutor`."

#: library/asyncio-eventloop.rst:1290
msgid "Error Handling API"
msgstr "API de gestion d'erreur"

#: library/asyncio-eventloop.rst:1292
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr ""
"Permet de personnaliser la façon dont les exceptions sont gérées dans la "
"boucle d'événements."

#: library/asyncio-eventloop.rst:1296
msgid "Set *handler* as the new event loop exception handler."
msgstr ""
"Définit *handler* comme nouveau gestionnaire d'exceptions de boucle "
"d'événements."

#: library/asyncio-eventloop.rst:1298
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop, "
"context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about context)."
msgstr ""
"Si *handler* est ``None``, le gestionnaire d'exceptions par défaut est "
"activé. Sinon, *handler* doit être un appelable avec la signature "
"correspondant à ``(loop, context)``, où ``loop`` est une référence à la "
"boucle d'événements active et ``context`` est un ``dict`` contenant les "
"détails de l'exception (voir la documentation :meth:`call_exception_handler` "
"pour plus de détails sur le contexte)."

#: library/asyncio-eventloop.rst:1308
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr ""
"Renvoie le gestionnaire d'exceptions actuel ou ``None`` si aucun "
"gestionnaire d'exceptions personnalisé n'a été défini."

#: library/asyncio-eventloop.rst:1315
msgid "Default exception handler."
msgstr "Gestionnaire d'exception par défaut."

#: library/asyncio-eventloop.rst:1317
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr ""
"Appelée lorsqu'une exception se produit et qu'aucun gestionnaire d'exception "
"n'est défini. Elle peut être appelée par un gestionnaire d'exceptions "
"personnalisé qui souhaite s'en remettre au comportement du gestionnaire par "
"défaut."

#: library/asyncio-eventloop.rst:1321
msgid ""
"*context* parameter has the same meaning as in :meth:"
"`call_exception_handler`."
msgstr ""
"Le paramètre *context* a la même signification que dans :meth:"
"`call_exception_handler`."

#: library/asyncio-eventloop.rst:1326
msgid "Call the current event loop exception handler."
msgstr ""
"Appelle le gestionnaire d'exception de la boucle d'évènements actuelle."

#: library/asyncio-eventloop.rst:1328
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr ""
"*context* est un objet ``dict`` contenant les clés suivantes (de nouvelles "
"clés pourront être introduites dans les futures versions de Python) :"

#: library/asyncio-eventloop.rst:1331
msgid "'message': Error message;"
msgstr "'message' : message d'erreur ;"

#: library/asyncio-eventloop.rst:1332
msgid "'exception' (optional): Exception object;"
msgstr "'exception' (facultatif) : objet exception ;"

#: library/asyncio-eventloop.rst:1333
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'future' (facultatif) : instance de :class:`asyncio.Future` ;"

#: library/asyncio-eventloop.rst:1334
msgid "'task' (optional): :class:`asyncio.Task` instance;"
msgstr "'task' (facultatif) : instance de :class:`asyncio.Task` ;"

#: library/asyncio-eventloop.rst:1335
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "*'handle'* (facultatif) : instance de :class:`asyncio.Handle` ;"

#: library/asyncio-eventloop.rst:1336
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr ""
"*'protocol'* (facultatif) : instance de :ref:`protocole asyncio <asyncio-"
"protocol>` ;"

#: library/asyncio-eventloop.rst:1337
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""
"'transport' (facultatif) : instance de :ref:`transport asyncio <asyncio-"
"transport>` ;"

#: library/asyncio-eventloop.rst:1338
msgid "'socket' (optional): :class:`socket.socket` instance;"
msgstr "'socket' (facultatif) : instance de :class:`socket.socket` ;"

#: library/asyncio-eventloop.rst:1340
msgid "'asyncgen' (optional): Asynchronous generator that caused"
msgstr "*'asyncgen'* (facultatif) : générateur asynchrone qui a causé"

#: library/asyncio-eventloop.rst:1340
msgid "the exception."
msgstr "l'exception"

# suit un :
#: library/asyncio-eventloop.rst:1344
msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler()` method."
msgstr ""
"cette méthode ne doit pas être surchargée dans les boucles d'événements sous-"
"classées. Pour la gestion personnalisée des exceptions, utilisez la méthode :"
"meth:`set_exception_handler()`."

#: library/asyncio-eventloop.rst:1349
msgid "Enabling debug mode"
msgstr "Activation du mode débogage"

#: library/asyncio-eventloop.rst:1353
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "Obtient le mode de débogage (:class:`bool`) de la boucle d'événements."

#: library/asyncio-eventloop.rst:1355
msgid ""
"The default value is ``True`` if the environment variable :envvar:"
"`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr ""
"La valeur par défaut est ``True`` si la variable d'environnement :envvar:"
"`PYTHONASYNCIODEBUG` est définie sur une chaîne non vide, ``False`` sinon."

#: library/asyncio-eventloop.rst:1361
msgid "Set the debug mode of the event loop."
msgstr "Active le mode débogage pour la boucle d'évènements."

# suit un :
#: library/asyncio-eventloop.rst:1365
msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr ""
"le nouveau :ref:`mode de développement Python <devmode>` peut désormais "
"également être utilisé pour activer le mode de débogage."

# suit un :
#: library/asyncio-eventloop.rst:1370
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr "le :ref:`mode debogage d'asyncio <asyncio-debug-mode>`."

#: library/asyncio-eventloop.rst:1374
msgid "Running Subprocesses"
msgstr "Exécution de sous-processus"

#: library/asyncio-eventloop.rst:1376
msgid ""
"Methods described in this subsections are low-level.  In regular async/await "
"code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"Les méthodes décrites dans ces sous-sections sont de bas niveau. Dans le "
"code *async/await* normal, pensez à utiliser les fonctions de commodité de "
"haut niveau :func:`asyncio.create_subprocess_shell` et :func:`asyncio."
"create_subprocess_exec` à la place."

# suit un :
#: library/asyncio-eventloop.rst:1383
msgid ""
"On Windows, the default event loop :class:`ProactorEventLoop` supports "
"subprocesses, whereas :class:`SelectorEventLoop` does not. See :ref:"
"`Subprocess Support on Windows <asyncio-windows-subprocess>` for details."
msgstr ""
"sous Windows, la boucle d'événements par défaut :class:`ProactorEventLoop` "
"prend en charge les sous-processus, contrairement à :class:"
"`SelectorEventLoop`. Voir :ref:`Prise en charge des sous-processus sous "
"Windows <asyncio-windows-subprocess>` pour plus de détails."

#: library/asyncio-eventloop.rst:1392
msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr ""
"Crée un sous-processus à partir d'un ou plusieurs arguments de chaîne "
"spécifiés par *args*."

#: library/asyncio-eventloop.rst:1395
msgid "*args* must be a list of strings represented by:"
msgstr "*args* doit être une liste de chaînes représentée par :"

#: library/asyncio-eventloop.rst:1397
msgid ":class:`str`;"
msgstr ":class:`str` ;"

#: library/asyncio-eventloop.rst:1398
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""
"ou :class:`bytes`, encodés selon l':ref:`encodage du système de fichiers "
"<filesystem-encoding>`."

#: library/asyncio-eventloop.rst:1401
msgid ""
"The first string specifies the program executable, and the remaining strings "
"specify the arguments.  Together, string arguments form the ``argv`` of the "
"program."
msgstr ""
"La première chaîne spécifie l'exécutable du programme et les chaînes "
"restantes spécifient les arguments. Ensemble, les arguments de chaîne "
"forment le ``argv`` du programme."

#: library/asyncio-eventloop.rst:1405
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""
"C'est similaire à la classe standard de la bibliothèque :class:`subprocess."
"Popen` appelée avec ``shell=False`` et la liste des chaînes passées en "
"premier argument ; cependant, où :class:`~subprocess.Popen` prend un seul "
"argument qui est une liste de chaînes, *subprocess_exec* prend plusieurs "
"arguments de chaînes."

#: library/asyncio-eventloop.rst:1411
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`asyncio.SubprocessProtocol` class."
msgstr ""
"Le *protocol_factory* doit être un appelable renvoyant une sous-classe de la "
"classe :class:`asyncio.SubprocessProtocol`."

#: library/asyncio-eventloop.rst:1414
msgid "Other parameters:"
msgstr "Autres paramètres :"

#: library/asyncio-eventloop.rst:1416
msgid "*stdin* can be any of these:"
msgstr "*stdin* peut être l'un de ces éléments :"

#: library/asyncio-eventloop.rst:1418
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard input stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
"un objet de type fichier représentant un tube à connecter au flux d'entrée "
"standard du sous-processus en utilisant :meth:`~loop.connect_write_pipe`,"

#: library/asyncio-eventloop.rst:1421 library/asyncio-eventloop.rst:1433
#: library/asyncio-eventloop.rst:1445
msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe "
"and connect it,"
msgstr ""
"la constante :const:`subprocess.PIPE` (par défaut) qui va créer un nouveau "
"tube et le connecter,"

#: library/asyncio-eventloop.rst:1423 library/asyncio-eventloop.rst:1435
#: library/asyncio-eventloop.rst:1447
msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr ""
"la valeur ``None`` qui fera que le sous-processus héritera du descripteur de "
"fichier de ce processus,"

#: library/asyncio-eventloop.rst:1425 library/asyncio-eventloop.rst:1437
#: library/asyncio-eventloop.rst:1449
msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special :"
"data:`os.devnull` file will be used"
msgstr ""
"la constante :const:`subprocess.DEVNULL` qui indique que le fichier spécial :"
"data:`os.devnull` sera utilisé."

#: library/asyncio-eventloop.rst:1428
msgid "*stdout* can be any of these:"
msgstr "*stdout* peut être l'un de ces éléments :"

#: library/asyncio-eventloop.rst:1430
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard output stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
"un objet de type fichier représentant un tube à connecter au flux de sortie "
"standard du sous-processus en utilisant :meth:`~loop.connect_write_pipe`,"

#: library/asyncio-eventloop.rst:1440
msgid "*stderr* can be any of these:"
msgstr "*stderr* peut être l'un de ces éléments :"

#: library/asyncio-eventloop.rst:1442
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard error stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
"un objet de type fichier représentant un tube à connecter au flux d'erreurs "
"standard du sous-processus en utilisant :meth:`~loop.connect_write_pipe`,"

#: library/asyncio-eventloop.rst:1451
msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ""
"la constante :const:`subprocess.STDOUT` qui connectera le flux d'erreur "
"standard au flux de sortie standard du processus."

#: library/asyncio-eventloop.rst:1454
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*, "
"*encoding* and *errors*, which should not be specified at all."
msgstr ""
"Tous les autres arguments nommés sont passés à :class:`subprocess.Popen` "
"sans interprétation, à l'exception de *bufsize*, *universal_newlines*, "
"*shell*, *text*, *encoding* et *errors*, qui ne doivent pas être spécifiés "
"du tout."

#: library/asyncio-eventloop.rst:1459
msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr ""
"L'API de sous-processus ``asyncio`` ne prend pas en charge le décodage des "
"flux sous forme de texte. :func:`bytes.decode` peut être utilisée pour "
"convertir les octets renvoyés par le flux en texte."

#: library/asyncio-eventloop.rst:1463
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation "
"on other arguments."
msgstr ""
"Voir le constructeur de la classe :class:`subprocess.Popen` pour la "
"documentation sur les autres arguments."

#: library/asyncio-eventloop.rst:1466
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"Renvoie une paire ``(transport, protocol)``, où *transport* est conforme à "
"la classe de base :class:`asyncio.SubprocessTransport` et *protocol* est un "
"objet instancié par *protocol_factory*."

#: library/asyncio-eventloop.rst:1474
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a :class:"
"`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"Crée un sous-processus à partir de *cmd*, qui peut être une chaîne :class:"
"`str` ou une chaîne :class:`bytes` encodée avec l':ref:`encodage du système "
"de fichiers <filesystem-encoding>`, en utilisant la syntaxe \"shell\" de la "
"plate-forme."

#: library/asyncio-eventloop.rst:1479
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""
"C'est similaire à la classe standard de la bibliothèque :class:`subprocess."
"Popen` appelée avec ``shell=True``."

#: library/asyncio-eventloop.rst:1482
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`SubprocessProtocol` class."
msgstr ""
"Le *protocol_factory* doit être un appelable renvoyant une sous-classe de la "
"classe :class:`SubprocessProtocol`."

#: library/asyncio-eventloop.rst:1485
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""
"Voir :meth:`~loop.subprocess_exec` pour plus de détails sur les arguments "
"restants."

#: library/asyncio-eventloop.rst:1488
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"Renvoie une paire ``(transport, protocol)``, où *transport* est conforme à "
"la classe de base :class:`SubprocessTransport` et *protocol* est un objet "
"instancié par *protocol_factory*."

# suit un :
#: library/asyncio-eventloop.rst:1493
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""
"il est de la responsabilité de l'application de s'assurer que tous les "
"espaces blancs et les caractères spéciaux sont correctement échappés pour "
"éviter les vulnérabilités d'`injection de shell <https://en.wikipedia.org/"
"wiki/Shell_injection#Shell_injection>`_. La fonction :func:`shlex.quote` "
"peut être utilisée pour échapper correctement les espaces blancs et les "
"caractères spéciaux dans les chaînes qui seront utilisées pour construire "
"des commandes shell."

#: library/asyncio-eventloop.rst:1502
msgid "Callback Handles"
msgstr "Fonctions de rappel sur des descripteurs"

#: library/asyncio-eventloop.rst:1506
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, :meth:`loop."
"call_soon_threadsafe`."
msgstr ""
"Objet encapsulant une fonction de rappel renvoyé par :meth:`loop."
"call_soon`, :meth:`loop.call_soon_threadsafe`."

#: library/asyncio-eventloop.rst:1511
msgid ""
"Cancel the callback.  If the callback has already been canceled or executed, "
"this method has no effect."
msgstr ""
"Annule le rappel. Si le rappel a déjà été annulé ou exécuté, cette méthode "
"n'a aucun effet."

#: library/asyncio-eventloop.rst:1516
msgid "Return ``True`` if the callback was cancelled."
msgstr "Renvoie ``True`` si la fonction de rappel a été annulée."

#: library/asyncio-eventloop.rst:1522
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and :meth:"
"`loop.call_at`."
msgstr ""
"Objet encapsulant la fonction de rappel renvoyé par :meth:`loop.call_later` "
"et :meth:`loop.call_at`."

#: library/asyncio-eventloop.rst:1525
msgid "This class is a subclass of :class:`Handle`."
msgstr "Cette classe est une sous-classe de :class:`Handle`."

#: library/asyncio-eventloop.rst:1529
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr ""
"Renvoie une heure de rappel planifiée sous forme de :class:`float` secondes."

#: library/asyncio-eventloop.rst:1531
msgid ""
"The time is an absolute timestamp, using the same time reference as :meth:"
"`loop.time`."
msgstr ""
"L'heure est un horodatage absolu, utilisant la même référence de temps que :"
"meth:`loop.time`."

#: library/asyncio-eventloop.rst:1538
msgid "Server Objects"
msgstr "Objets Serveur"

#: library/asyncio-eventloop.rst:1540
msgid ""
"Server objects are created by :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server`, and :func:`start_unix_server` "
"functions."
msgstr ""
"Les objets serveur sont créés par les fonctions :meth:`loop.create_server`, :"
"meth:`loop.create_unix_server`, :func:`start_server` et :func:"
"`start_unix_server`."

#: library/asyncio-eventloop.rst:1544
#, fuzzy
msgid "Do not instantiate the :class:`Server` class directly."
msgstr "N'instanciez pas la classe directement."

#: library/asyncio-eventloop.rst:1548
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async "
"with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""
"Les objets *Server* sont des gestionnaires de contexte asynchrones. "
"Lorsqu'il est utilisé dans une instruction ``async with``, il est garanti "
"que l'objet Serveur est fermé et n'accepte pas de nouvelle connexion lorsque "
"l'instruction ``async with`` est terminée ::"

# suit un :
#: library/asyncio-eventloop.rst:1561
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr ""
"l'objet serveur est un gestionnaire de contexte asynchrone depuis Python 3.7."

#: library/asyncio-eventloop.rst:1564
msgid ""
"This class was exposed publicly as ``asyncio.Server`` in Python 3.9.11, "
"3.10.3 and 3.11."
msgstr ""

#: library/asyncio-eventloop.rst:1569
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""
"Arrête le serveur : ferme les connecteurs d'écoute et définit l'attribut :"
"attr:`sockets` à ``None``."

#: library/asyncio-eventloop.rst:1572
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr ""
"Les connecteurs qui représentent les connexions client entrantes existantes "
"restent ouvertes."

#: library/asyncio-eventloop.rst:1575
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` coroutine "
"to wait until the server is closed."
msgstr ""
"Le serveur est fermé de manière asynchrone, utilisez la coroutine :meth:"
"`wait_closed` pour attendre que le serveur soit fermé."

#: library/asyncio-eventloop.rst:1580
msgid "Return the event loop associated with the server object."
msgstr "Renvoie la boucle d'événement associée à l'objet serveur."

#: library/asyncio-eventloop.rst:1586
msgid "Start accepting connections."
msgstr "Commence à accepter les connexions."

#: library/asyncio-eventloop.rst:1588
msgid ""
"This method is idempotent, so it can be called when the server is already "
"serving."
msgstr ""
"Cette méthode est idempotente, elle peut donc être appelée lorsque le "
"serveur est déjà en service."

#: library/asyncio-eventloop.rst:1591
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""
"Le paramètre nommé *start_serving* de :meth:`loop.create_server` et :meth:"
"`asyncio.start_server` permet de créer un objet *Server* qui n'accepte pas "
"les connexions initialement. Dans ce cas, ``Server.start_serving()`` ou :"
"meth:`Server.serve_forever` peut être utilisée pour que le serveur commence "
"à accepter les connexions."

#: library/asyncio-eventloop.rst:1602
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""
"Commence à accepter les connexions jusqu'à ce que la coroutine soit annulée. "
"L'annulation de la tâche ``serve_forever`` provoque la fermeture du serveur."

#: library/asyncio-eventloop.rst:1606
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"Cette méthode peut être appelée si le serveur accepte déjà les connexions. "
"Une seule tâche ``serve_forever`` peut exister par objet *Server*."

#: library/asyncio-eventloop.rst:1628
msgid "Return ``True`` if the server is accepting new connections."
msgstr "Renvoie ``True`` si le serveur accepte de nouvelles connexions."

#: library/asyncio-eventloop.rst:1634
msgid "Wait until the :meth:`close` method completes."
msgstr "Attend que la méthode :meth:`close` se termine."

#: library/asyncio-eventloop.rst:1638
#, fuzzy
msgid ""
"List of socket-like objects, ``asyncio.trsock.TransportSocket``, which the "
"server is listening on."
msgstr ""
"Liste les objets :class:`socket.socket` sur lesquels le serveur écoute."

# vulnérabilités
#: library/asyncio-eventloop.rst:1641
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"avant Python 3.7, ``Server.sockets`` renvoyait directement une liste interne "
"de sockets de serveur. En 3.7, une copie de cette liste est renvoyée."

#: library/asyncio-eventloop.rst:1651
msgid "Event Loop Implementations"
msgstr "Implémentations de boucle d'évènements"

#: library/asyncio-eventloop.rst:1653
msgid ""
"asyncio ships with two different event loop implementations: :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"*asyncio* est livré avec deux implémentations de boucles d'événements "
"différentes : :class:`SelectorEventLoop` et :class:`ProactorEventLoop`."

#: library/asyncio-eventloop.rst:1656
msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on Unix "
"and :class:`ProactorEventLoop` on Windows."
msgstr ""
"Par défaut, *asyncio* est configuré pour utiliser :class:`SelectorEventLoop` "
"sous Unix et :class:`ProactorEventLoop` sous Windows."

#: library/asyncio-eventloop.rst:1662
msgid "An event loop based on the :mod:`selectors` module."
msgstr "Boucle d'événements basée sur le module :mod:`selectors`."

#: library/asyncio-eventloop.rst:1664
msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr ""
"Utilise le *sélecteur* le plus efficace disponible pour la plate-forme "
"donnée. Il est également possible de configurer manuellement "
"l'implémentation exacte du sélecteur à utiliser ::"

#: library/asyncio-eventloop.rst:1679
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Disponibilité <availability>` : Unix, Windows."

#: library/asyncio-eventloop.rst:1684
msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr ""
"Boucle d'événements pour Windows qui utilise des \"I/O Completion "
"Ports\" (IOCP)."

#: library/asyncio-eventloop.rst:1686
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Disponibilité <availability>` : Windows."

#: library/asyncio-eventloop.rst:1690
msgid ""
"`MSDN documentation on I/O Completion Ports <https://docs.microsoft.com/en-"
"ca/windows/desktop/FileIO/i-o-completion-ports>`_."
msgstr ""
"`Documentation MSDN sur les ports de saisie semi-automatique d’E/S <https://"
"docs.microsoft.com/fr-fr/windows/desktop/FileIO/i-o-completion-ports>`_."

#: library/asyncio-eventloop.rst:1696
msgid "Abstract base class for asyncio-compliant event loops."
msgstr ""
"Classe mère abstraite pour les boucles d'événements conforme à *asyncio*."

#: library/asyncio-eventloop.rst:1698
msgid ""
"The :ref:`asyncio-event-loop-methods` section lists all methods that an "
"alternative implementation of ``AbstractEventLoop`` should have defined."
msgstr ""
"La section :ref:`asyncio-event-loop-methods` liste toutes les méthodes "
"qu'une implémentation alternative de ``AbstractEventLoop`` doit définir."

#: library/asyncio-eventloop.rst:1704
msgid "Examples"
msgstr "Exemples"

#: library/asyncio-eventloop.rst:1706
msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and :meth:`loop."
"call_soon`.  Modern asyncio applications rarely need to be written this way; "
"consider using the high-level functions like :func:`asyncio.run`."
msgstr ""
"Notez que tous les exemples de cette section montrent **à dessein** comment "
"utiliser les API de boucle d'événement de bas niveau, telles que :meth:`loop."
"run_forever` et :meth:`loop.call_soon`. Les applications *asyncio* modernes "
"ont rarement besoin d'être écrites de cette façon ; pensez à utiliser les "
"fonctions de haut niveau comme :func:`asyncio.run`."

#: library/asyncio-eventloop.rst:1716
msgid "Hello World with call_soon()"
msgstr "\"Hello World\" avec ``call_soon()``"

#: library/asyncio-eventloop.rst:1718
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""
"Un exemple utilisant la méthode :meth:`loop.call_soon` pour programmer un "
"rappel. Le rappel affiche ``\"Hello World\"`` puis arrête la boucle "
"d'événements ::"

# suit un :
#: library/asyncio-eventloop.rst:1742
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr ""
"un exemple similaire de :ref:`Hello World <coroutine>` créé avec une "
"coroutine et la fonction :func:`run`."

#: library/asyncio-eventloop.rst:1749
msgid "Display the current date with call_later()"
msgstr "Affichage de la date actuelle avec ``call_later()``"

#: library/asyncio-eventloop.rst:1751
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr ""
"Un exemple de rappel affichant la date actuelle toutes les secondes. Le "
"rappel utilise la méthode :meth:`loop.call_later` pour se re-planifier après "
"5 secondes, puis arrête la boucle d'événements ::"

# suit un :
#: library/asyncio-eventloop.rst:1779
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a "
"coroutine and the :func:`run` function."
msgstr ""
"un exemple similaire de :ref:`date actuelle <asyncio_example_sleep>` créé "
"avec une coroutine et la fonction :func:`run`."

#: library/asyncio-eventloop.rst:1786
msgid "Watch a file descriptor for read events"
msgstr "Surveillance des événements de lecture pour un descripteur de fichier"

#: library/asyncio-eventloop.rst:1788
msgid ""
"Wait until a file descriptor received some data using the :meth:`loop."
"add_reader` method and then close the event loop::"
msgstr ""
"Attend qu'un descripteur de fichier reçoive des données en utilisant la "
"méthode :meth:`loop.add_reader` puis ferme la boucle d'événements ::"

# suit un :
#: library/asyncio-eventloop.rst:1826
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"un :ref:`exemple <asyncio_example_create_connection>` similaire utilisant "
"les transports, les protocoles et la méthode :meth:`loop.create_connection`,"

# suit un :
#: library/asyncio-eventloop.rst:1830
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""
"un autre :ref:`exemple <asyncio_example_create_connection-streams>` "
"utilisant la fonction et les flux de haut niveau :func:`asyncio."
"open_connection`."

#: library/asyncio-eventloop.rst:1838
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "Gestion des signaux *SIGINT* et *SIGTERM*"

#: library/asyncio-eventloop.rst:1840
msgid "(This ``signals`` example only works on Unix.)"
msgstr "(Cet exemple ne fonctionne que sur Unix.)"

#: library/asyncio-eventloop.rst:1842
msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` using "
"the :meth:`loop.add_signal_handler` method::"
msgstr ""
"Enregistre des gestionnaires pour les signaux :py:data:`SIGINT` et :py:data:"
"`SIGTERM` en utilisant la méthode :meth:`loop.add_signal_handler` ::"
