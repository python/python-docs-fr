# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-01 00:16+0100\n"
"PO-Revision-Date: 2021-10-30 12:59+0200\n"
"Last-Translator: Antoine Wecxsteen\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.3\n"

#: library/multiprocessing.shared_memory.rst:2
#, fuzzy
msgid ""
":mod:`!multiprocessing.shared_memory` --- Shared memory for direct access "
"across processes"
msgstr ""
":mod:`multiprocessing.shared_memory` — Mémoire partagée en accès direct "
"depuis plusieurs processus"

#: library/multiprocessing.shared_memory.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/shared_memory.py`"
msgstr "**Code source :** :source:`Lib/multiprocessing/shared_memory.py`"

#: library/multiprocessing.shared_memory.rst:18
#, fuzzy
msgid ""
"This module provides a class, :class:`SharedMemory`, for the allocation and "
"management of shared memory to be accessed by one or more processes on a "
"multicore or symmetric multiprocessor (SMP) machine.  To assist with the "
"life-cycle management of shared memory especially across distinct processes, "
"a :class:`~multiprocessing.managers.BaseManager` subclass, :class:"
"`~multiprocessing.managers.SharedMemoryManager`, is also provided in the :"
"mod:`multiprocessing.managers` module."
msgstr ""
"Ce module fournit une classe, :class:`SharedMemory`, pour l'allocation et la "
"gestion de mémoire partagée entre un ou plusieurs processus sur une machine "
"à plusieurs cœurs ou à multiprocesseurs (architecture *symmetric "
"multiprocessor* ou SMP). Pour faciliter la gestion du cycle de vie de la "
"mémoire partagée, tout particulièrement entre plusieurs processus, le module "
"``multiprocessing.managers`` fournit aussi la classe :class:"
"`~multiprocessing.managers.SharedMemoryManager`, sous-classe de :class:"
"`BaseManager`."

#: library/multiprocessing.shared_memory.rst:26
#, fuzzy
msgid ""
"In this module, shared memory refers to \"POSIX style\" shared memory blocks "
"(though is not necessarily implemented explicitly as such) and does not "
"refer to \"distributed shared memory\".  This style of shared memory permits "
"distinct processes to potentially read and write to a common (or shared) "
"region of volatile memory.  Processes are conventionally limited to only "
"have access to their own process memory space but shared memory permits the "
"sharing of data between processes, avoiding the need to instead send "
"messages between processes containing that data.  Sharing data directly via "
"memory can provide significant performance benefits compared to sharing data "
"via disk or socket or other communications requiring the serialization/"
"deserialization and copying of data."
msgstr ""
"Dans ce module, il faut entendre « mémoire partagée » au sens de « blocs de "
"mémoire partagée à la mode System V » (même si l'implémentation peut "
"différer), et non au sens de « mémoire distribuée ». Ce type de mémoire "
"partagée permet à plusieurs processus d'écrire dans une zone commune (ou "
"« partagée ») de la mémoire vive. Normalement, les processus n'ont accès "
"qu'à leur propre espace mémoire ; la mémoire partagée permet justement le "
"partage de données entre des processus, ce qui leur évite d'avoir à "
"s'envoyer ces données par message. Échanger des données par mémoire partagée "
"peut amener des gains de performance substantiels par rapport aux échanges "
"via le disque dur, des connecteurs ou d'autres canaux qui nécessitent de "
"sérialiser et de désérialiser les données."

#: library/multiprocessing.shared_memory.rst:41
#, fuzzy
msgid ""
"Create an instance of the :class:`!SharedMemory` class for either creating a "
"new shared memory block or attaching to an existing shared memory block.  "
"Each shared memory block is assigned a unique name. In this way, one process "
"can create a shared memory block with a particular name and a different "
"process can attach to that same shared memory block using that same name."
msgstr ""
"Crée un nouveau bloc de mémoire partagée ou enregistre un bloc déjà "
"existant. Un nom unique doit être donné à chaque bloc de mémoire partagée ; "
"ainsi, un processus peut créer un nouveau bloc de mémoire partagée avec un "
"nom fixé et un autre processus peut enregistrer le même bloc, à partir de "
"son nom."

#: library/multiprocessing.shared_memory.rst:48
#, fuzzy
msgid ""
"As a resource for sharing data across processes, shared memory blocks may "
"outlive the original process that created them.  When one process no longer "
"needs access to a shared memory block that might still be needed by other "
"processes, the :meth:`close` method should be called. When a shared memory "
"block is no longer needed by any process, the :meth:`unlink` method should "
"be called to ensure proper cleanup."
msgstr ""
"Puisque qu'il permet de partager des données entre processus, un bloc de "
"mémoire partagée peut survivre au processus qui l'a créé. Lorsqu'un "
"processus n'a plus besoin d'un bloc — qui peut toujours être en cours "
"d'utilisation par un autre — il doit appeler la méthode :meth:`close()`. "
"Quand tous les processus ont fini d'utiliser ce bloc, il faut appeler la "
"méthode :meth:`unlink()` pour le libérer."

#: library/multiprocessing.shared_memory.rst:0
msgid "Parameters"
msgstr "Paramètres"

#: library/multiprocessing.shared_memory.rst:55
#, fuzzy
msgid ""
"The unique name for the requested shared memory, specified as a string. When "
"creating a new shared memory block, if ``None`` (the default) is supplied "
"for the name, a novel name will be generated."
msgstr ""
"*name* est le nom (une chaîne de caractères) unique de la mémoire partagée à "
"allouer. Lors de la création d'un nouveau bloc mémoire, si ``None`` (valeur "
"par défaut) est passé comme nom, un nouveau nom est généré."

#: library/multiprocessing.shared_memory.rst:61
#, fuzzy
msgid ""
"Control whether a new shared memory block is created (``True``) or an "
"existing shared memory block is attached (``False``)."
msgstr ""
"*create* indique si un nouveau bloc doit être alloué (``True``) ou si on "
"enregistre un bloc déjà existant (``False``)."

#: library/multiprocessing.shared_memory.rst:65
#, fuzzy
msgid ""
"The requested number of bytes when creating a new shared memory block. "
"Because some platforms choose to allocate chunks of memory based upon that "
"platform's memory page size, the exact size of the shared memory block may "
"be larger or equal to the size requested. When attaching to an existing "
"shared memory block, the *size* parameter is ignored."
msgstr ""
"*size* définit le nombre d'octets à allouer. Comme certaines plates-formes "
"choisissent d'allouer les blocs mémoire en multiples de la taille de la page "
"mémoire de la plate-forme, la taille réellement allouée peut être supérieure "
"à la taille demandée. Lors de l'enregistrement d'un bloc déjà existant, le "
"paramètre ``size`` est ignoré."

#: library/multiprocessing.shared_memory.rst:73
msgid ""
"When ``True``, register the shared memory block with a resource tracker "
"process on platforms where the OS does not do this automatically. The "
"resource tracker ensures proper cleanup of the shared memory even if all "
"other processes with access to the memory exit without doing so. Python "
"processes created from a common ancestor using :mod:`multiprocessing` "
"facilities share a single resource tracker process, and the lifetime of "
"shared memory segments is handled automatically among these processes. "
"Python processes created in any other way will receive their own resource "
"tracker when accessing shared memory with *track* enabled. This will cause "
"the shared memory to be deleted by the resource tracker of the first process "
"that terminates. To avoid this issue, users of :mod:`subprocess` or "
"standalone Python processes should set *track* to ``False`` when there is "
"already another process in place that does the bookkeeping. *track* is "
"ignored on Windows, which has its own tracking and automatically deletes "
"shared memory when all handles to it have been closed."
msgstr ""

#: library/multiprocessing.shared_memory.rst:91
msgid "Added the *track* parameter."
msgstr ""

#: library/multiprocessing.shared_memory.rst:96
msgid ""
"Close the file descriptor/handle to the shared memory from this instance.  :"
"meth:`close` should be called once access to the shared memory block from "
"this instance is no longer needed.  Depending on operating system, the "
"underlying memory may or may not be freed even if all handles to it have "
"been closed.  To ensure proper cleanup, use the :meth:`unlink` method."
msgstr ""

#: library/multiprocessing.shared_memory.rst:105
msgid ""
"Delete the underlying shared memory block.  This should be called only once "
"per shared memory block regardless of the number of handles to it, even in "
"other processes. :meth:`unlink` and :meth:`close` can be called in any "
"order, but trying to access data inside a shared memory block after :meth:"
"`unlink` may result in memory access errors, depending on platform."
msgstr ""

#: library/multiprocessing.shared_memory.rst:112
msgid ""
"This method has no effect on Windows, where the only way to delete a shared "
"memory block is to close all handles."
msgstr ""

#: library/multiprocessing.shared_memory.rst:117
msgid "A memoryview of contents of the shared memory block."
msgstr "Une *memoryview* du contenu du bloc de mémoire partagée."

#: library/multiprocessing.shared_memory.rst:121
msgid "Read-only access to the unique name of the shared memory block."
msgstr "Nom unique du bloc de mémoire partagée (lecture seule)."

#: library/multiprocessing.shared_memory.rst:125
msgid "Read-only access to size in bytes of the shared memory block."
msgstr "Taille en octets du bloc de mémoire partagée (lecture seule)."

#: library/multiprocessing.shared_memory.rst:128
msgid ""
"The following example demonstrates low-level use of :class:`SharedMemory` "
"instances::"
msgstr ""
"L'exemple qui suit montre un exemple d'utilisation bas niveau d'instances "
"de :class:`SharedMemory` ::"

#: library/multiprocessing.shared_memory.rst:154
#, fuzzy
msgid ""
"The following example demonstrates a practical use of the :class:"
"`SharedMemory` class with `NumPy arrays <https://numpy.org/>`_, accessing "
"the same :class:`!numpy.ndarray` from two distinct Python shells:"
msgstr ""
"Le code qui suit est un exemple d'utilisation réel de la classe :class:"
"`SharedMemory` avec des `tableaux NumPy <https://www.numpy.org/>`_ qui "
"accèdent au même ``numpy.ndarray`` depuis deux invites Python différentes :"

#: library/multiprocessing.shared_memory.rst:208
#, fuzzy
msgid ""
"A subclass of :class:`multiprocessing.managers.BaseManager` which can be "
"used for the management of shared memory blocks across processes."
msgstr ""
"Une sous-classe de :class:`~multiprocessing.managers.BaseManager` pour gérer "
"des blocs de mémoire partagée entre processus."

#: library/multiprocessing.shared_memory.rst:211
#, fuzzy
msgid ""
"A call to :meth:`~multiprocessing.managers.BaseManager.start` on a :class:`!"
"SharedMemoryManager` instance causes a new process to be started. This new "
"process's sole purpose is to manage the life cycle of all shared memory "
"blocks created through it.  To trigger the release of all shared memory "
"blocks managed by that process, call :meth:`~multiprocessing.managers."
"BaseManager.shutdown` on the instance. This triggers a :meth:"
"`~multiprocessing.shared_memory.SharedMemory.unlink` call on all of the :"
"class:`SharedMemory` objects managed by that process and then stops the "
"process itself.  By creating :class:`!SharedMemory` instances through a :"
"class:`!SharedMemoryManager`, we avoid the need to manually track and "
"trigger the freeing of shared memory resources."
msgstr ""
"Un appel à :meth:`~multiprocessing.managers.BaseManager.start` depuis une "
"instance :class:`SharedMemoryManager` lance un nouveau processus dont le "
"seul but est de gérer le cycle de vie des blocs mémoires qu'il a créés. La "
"méthode :meth:`~multiprocessing.managers.BaseManager.shutdown()` de "
"l'instance déclenche la libération de tous les blocs mémoires gérés par ce "
"processus. Elle appelle :meth:`SharedMemory.unlink()` sur tous les objets :"
"class:`SharedMemory` gérés par ce processus et l'arrête ensuite. Créer des "
"instances de ``SharedMemory`` par l'intermédiaire d'un "
"``SharedMemoryManager`` évite d'avoir à gérer et à libérer manuellement les "
"ressources mémoire partagées."

#: library/multiprocessing.shared_memory.rst:223
msgid ""
"This class provides methods for creating and returning :class:`SharedMemory` "
"instances and for creating a list-like object (:class:`ShareableList`) "
"backed by shared memory."
msgstr ""
"Cette classe fournit des méthodes pour créer et renvoyer des instances de :"
"class:`SharedMemory` et pour créer des objets compatibles liste (:class:"
"`ShareableList`) basés sur la mémoire partagée."

#: library/multiprocessing.shared_memory.rst:227
#, fuzzy
msgid ""
"Refer to :class:`~multiprocessing.managers.BaseManager` for a description of "
"the inherited *address* and *authkey* optional input arguments and how they "
"may be used to connect to an existing :class:`!SharedMemoryManager` service "
"from other processes."
msgstr ""
"Référez-vous à :class:`multiprocessing.managers.BaseManager` pour la "
"description des arguments optionnels hérités *address* et *authkey*, et "
"comment ceux-ci doivent être utilisés pour enregistrer un service de "
"``SharedMemoryManager`` depuis un autre processus."

#: library/multiprocessing.shared_memory.rst:234
#, fuzzy
msgid ""
"Create and return a new :class:`SharedMemory` object with the specified "
"*size* in bytes."
msgstr ""
"Crée et renvoie un nouvel objet :class:`SharedMemory` de taille ``size`` "
"octets."

#: library/multiprocessing.shared_memory.rst:239
#, fuzzy
msgid ""
"Create and return a new :class:`ShareableList` object, initialized by the "
"values from the input *sequence*."
msgstr ""
"Crée et renvoie un nouvel objet :class:`ShareableList`, initialisé à partir "
"des valeurs de la ``sequence`` en entrée."

#: library/multiprocessing.shared_memory.rst:243
#, fuzzy
msgid ""
"The following example demonstrates the basic mechanisms of a :class:"
"`~multiprocessing.managers.SharedMemoryManager`:"
msgstr ""
"L'exemple qui suit illustre les mécanismes de base de :class:"
"`SharedMemoryManager` :"

#: library/multiprocessing.shared_memory.rst:261
#, fuzzy
msgid ""
"The following example depicts a potentially more convenient pattern for "
"using :class:`~multiprocessing.managers.SharedMemoryManager` objects via "
"the :keyword:`with` statement to ensure that all shared memory blocks are "
"released after they are no longer needed:"
msgstr ""
"L'exemple suivant montre comment utiliser un objet :class:"
"`SharedMemoryManager` avec l'instruction :keyword:`with` pour être sûr que "
"tous les blocs mémoire sont libérés quand ils ne sont plus nécessaires. "
"C'est souvent plus pratique que l'exemple précédent :"

#: library/multiprocessing.shared_memory.rst:280
#, fuzzy
msgid ""
"When using a :class:`~multiprocessing.managers.SharedMemoryManager` in a :"
"keyword:`with` statement, the shared memory blocks created using that "
"manager are all released when the :keyword:`!with` statement's code block "
"finishes execution."
msgstr ""
"Lors de l'utilisation d'un :class:`SharedMemoryManager` dans une "
"instruction :keyword:`with`, les blocs de mémoire partagée créés par ce "
"gestionnaire sont tous libérés quand les instructions à l'intérieur du bloc :"
"keyword:`with` ont été exécutées."

#: library/multiprocessing.shared_memory.rst:288
msgid ""
"Provide a mutable list-like object where all values stored within are stored "
"in a shared memory block. This constrains storable values to the following "
"built-in data types:"
msgstr ""

#: library/multiprocessing.shared_memory.rst:292
msgid ":class:`int` (signed 64-bit)"
msgstr ""

#: library/multiprocessing.shared_memory.rst:293
msgid ":class:`float`"
msgstr ":class:`float`"

#: library/multiprocessing.shared_memory.rst:294
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: library/multiprocessing.shared_memory.rst:295
msgid ":class:`str` (less than 10M bytes each when encoded as UTF-8)"
msgstr ""

#: library/multiprocessing.shared_memory.rst:296
msgid ":class:`bytes` (less than 10M bytes each)"
msgstr ""

#: library/multiprocessing.shared_memory.rst:297
msgid "``None``"
msgstr "``None``"

#: library/multiprocessing.shared_memory.rst:299
msgid ""
"It also notably differs from the built-in :class:`list` type in that these "
"lists can not change their overall length (i.e. no :meth:`!append`, :meth:`!"
"insert`, etc.) and do not support the dynamic creation of new :class:`!"
"ShareableList` instances via slicing."
msgstr ""

#: library/multiprocessing.shared_memory.rst:305
#, fuzzy
msgid ""
"*sequence* is used in populating a new :class:`!ShareableList` full of "
"values. Set to ``None`` to instead attach to an already existing :class:`!"
"ShareableList` by its unique shared memory name."
msgstr ""
"*sequence* sert à créer une nouvelle ``ShareableList`` avec des valeurs. "
"Mettez-le à ``None`` pour enregistrer une ``ShareableList`` déjà existante, "
"en renseignant son nom unique."

#: library/multiprocessing.shared_memory.rst:309
#, fuzzy
msgid ""
"*name* is the unique name for the requested shared memory, as described in "
"the definition for :class:`SharedMemory`.  When attaching to an existing :"
"class:`!ShareableList`, specify its shared memory block's unique name while "
"leaving *sequence* set to ``None``."
msgstr ""
"*name* est le nom unique de la mémoire partagée demandée, tel que décrit "
"dans la définition de :class:`SharedMemory`. Pour enregistrer une "
"``ShareableList`` déjà existante, renseignez le nom unique du bloc de "
"mémoire partagée et laissez ``sequence`` à ``None``."

#: library/multiprocessing.shared_memory.rst:316
msgid ""
"A known issue exists for :class:`bytes` and :class:`str` values. If they end "
"with ``\\x00`` nul bytes or characters, those may be *silently stripped* "
"when fetching them by index from the :class:`!ShareableList`. This ``."
"rstrip(b'\\x00')`` behavior is considered a bug and may go away in the "
"future. See :gh:`106939`."
msgstr ""

#: library/multiprocessing.shared_memory.rst:322
msgid ""
"For applications where rstripping of trailing nulls is a problem, work "
"around it by always unconditionally appending an extra non-0 byte to the end "
"of such values when storing and unconditionally removing it when fetching:"
msgstr ""

#: library/multiprocessing.shared_memory.rst:345
#, fuzzy
msgid "Return the number of occurrences of *value*."
msgstr "Renvoie le nombre d’occurrences de ``value``."

#: library/multiprocessing.shared_memory.rst:349
#, fuzzy
msgid ""
"Return first index position of *value*. Raise :exc:`ValueError` if *value* "
"is not present."
msgstr ""
"Renvoie l'indice de la première occurrence de ``value``. Lève une :exc:"
"`ValueError` si ``value`` n'est pas présent."

#: library/multiprocessing.shared_memory.rst:354
msgid ""
"Read-only attribute containing the :mod:`struct` packing format used by all "
"currently stored values."
msgstr ""
"Attribut en lecture seule contenant le format d’agrégation :mod:`struct` "
"utilisé par les valeurs déjà stockées."

#: library/multiprocessing.shared_memory.rst:359
msgid "The :class:`SharedMemory` instance where the values are stored."
msgstr ""
"Instance de :class:`SharedMemory` dans laquelle les valeurs sont stockées."

#: library/multiprocessing.shared_memory.rst:362
msgid ""
"The following example demonstrates basic use of a :class:`ShareableList` "
"instance:"
msgstr ""
"L'exemple qui suit illustre un cas d'usage de base d'une instance de :class:"
"`ShareableList` :"

#: library/multiprocessing.shared_memory.rst:395
msgid ""
"The following example depicts how one, two, or many processes may access the "
"same :class:`ShareableList` by supplying the name of the shared memory block "
"behind it:"
msgstr ""
"L'exemple ci-dessous montre comment un, deux ou un grand nombre de processus "
"peuvent accéder à une :class:`ShareableList` commune à partir du nom du bloc "
"mémoire partagé sous-jacent :"

#: library/multiprocessing.shared_memory.rst:410
#, fuzzy
msgid ""
"The following examples demonstrates that :class:`ShareableList` (and "
"underlying :class:`SharedMemory`) objects can be pickled and unpickled if "
"needed. Note, that it will still be the same shared object. This happens, "
"because the deserialized object has the same unique name and is just "
"attached to an existing object with the same name (if the object is still "
"alive):"
msgstr ""
"L'exemple ci-dessous montre comment une ``ShareableList`` (et le "
"``SharedMemory`` sous-jacent) peut être sérialisée et désérialisée. Gardez "
"bien à l'esprit que c'est toujours le même objet, car l'objet désérialisé a "
"le même nom unique et est tout simplement attaché à un objet déjà existant "
"du même nom (si cet objet est toujours en vie) :"

#, fuzzy
#~ msgid ""
#~ "Close access to the shared memory from this instance.  In order to ensure "
#~ "proper cleanup of resources, all instances should call :meth:`close` once "
#~ "the instance is no longer needed.  Note that calling :meth:`!close` does "
#~ "not cause the shared memory block itself to be destroyed."
#~ msgstr ""
#~ "Empêche les accès ultérieurs à la mémoire partagée depuis cette "
#~ "instance ; toutes les instances doivent appeler ``close()`` pour "
#~ "s'assurer que les ressources sont bien libérées. Notez qu'appeler "
#~ "``close()`` ne libère pas la mémoire elle-même."

#, fuzzy
#~ msgid ""
#~ "Request that the underlying shared memory block be destroyed.  In order "
#~ "to ensure proper cleanup of resources, :meth:`unlink` should be called "
#~ "once (and only once) across all processes which have need for the shared "
#~ "memory block.  After requesting its destruction, a shared memory block "
#~ "may or may not be immediately destroyed and this behavior may differ "
#~ "across platforms.  Attempts to access data inside the shared memory block "
#~ "after :meth:`!unlink` has been called may result in memory access "
#~ "errors.  Note: the last process relinquishing its hold on a shared memory "
#~ "block may call :meth:`!unlink` and :meth:`close` in either order."
#~ msgstr ""
#~ "Initie la libération de la mémoire partagée sous-jacente. Pour être sûr "
#~ "que les ressources sont libérées correctement, ``unlink()`` doit être "
#~ "appelée une (et une seule) fois par tous les processus qui ont utilisé le "
#~ "bloc partagé. Après avoir initié la destruction d'un bloc mémoire, le "
#~ "bloc peut ne pas être détruit immédiatement ; ce comportement dépend de "
#~ "la plate-forme. Accéder aux données d'un bloc de mémoire partagée après "
#~ "l'appel à ``unlink()`` peut provoquer une erreur mémoire. Notez que le "
#~ "dernier processus à libérer le bloc mémoire de mémoire partagée peut "
#~ "appeler ``unlink()`` et :meth:`close()` dans n'importe quel ordre."

#~ msgid ""
#~ "Provides a mutable list-like object where all values stored within are "
#~ "stored in a shared memory block.  This constrains storable values to only "
#~ "the ``int``, ``float``, ``bool``, ``str`` (less than 10M bytes each), "
#~ "``bytes`` (less than 10M bytes each), and ``None`` built-in data types. "
#~ "It also notably differs from the built-in ``list`` type in that these "
#~ "lists can not change their overall length (i.e. no append, insert, etc.) "
#~ "and do not support the dynamic creation of new :class:`ShareableList` "
#~ "instances via slicing."
#~ msgstr ""
#~ "Construit un objet mutable compatible avec le type liste dont toutes les "
#~ "valeurs sont stockées dans un bloc de mémoire partagée. Ceci limite le "
#~ "type des valeurs pouvant être stockées aux types natifs ``int``, "
#~ "``float``, ``bool``, ``str`` (de moins de 10 Mo chacune), ``bytes`` (de "
#~ "moins de 10 Mo chacun) et ``None``. Une autre différence majeure avec une "
#~ "``list`` native réside dans le fait qu'il est impossible de changer la "
#~ "taille (c.-à-d. pas d'ajout en fin de liste, ni d'insertion etc.) et "
#~ "qu'il n'est pas possible de créer de nouvelles instances de :class:"
#~ "`ShareableList` par découpage."
