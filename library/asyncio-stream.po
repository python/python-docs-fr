# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-14 13:19+0200\n"
"PO-Revision-Date: 2023-07-04 23:07+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/asyncio-stream.rst:7
msgid "Streams"
msgstr "Flux (*streams*)"

#: library/asyncio-stream.rst:9
msgid "**Source code:** :source:`Lib/asyncio/streams.py`"
msgstr "**Code source :** :source:`Lib/asyncore.py`"

#: library/asyncio-stream.rst:13
msgid ""
"Streams are high-level async/await-ready primitives to work with network "
"connections.  Streams allow sending and receiving data without using "
"callbacks or low-level protocols and transports."
msgstr ""
"Les flux sont des primitives de haut niveau compatibles avec *async*/*await* "
"pour utiliser les connexions réseau. Les flux permettent d'envoyer et de "
"recevoir des données sans utiliser de fonctions de rappel ou des protocoles "
"de bas niveau."

#: library/asyncio-stream.rst:19
msgid "Here is an example of a TCP echo client written using asyncio streams::"
msgstr ""
"Voici un exemple de client « écho TCP » écrit en utilisant les flux "
"*asyncio* ::"

#: library/asyncio-stream.rst:42
msgid "See also the `Examples`_ section below."
msgstr "Voir également la section `Exemples`_ ci-dessous."

#: library/asyncio-stream.rst:46
msgid "Stream Functions"
msgstr "Fonctions de flux"

#: library/asyncio-stream.rst:47
msgid ""
"The following top-level asyncio functions can be used to create and work "
"with streams:"
msgstr ""
"Les fonctions *asyncio* de haut niveau suivantes peuvent être utilisées pour "
"créer et utiliser des flux :"

#: library/asyncio-stream.rst:58
msgid ""
"Establish a network connection and return a pair of ``(reader, writer)`` "
"objects."
msgstr ""
"Établit une connexion réseau et renvoie une paire d'objets ``(lecteur, "
"écrivain)``."

#: library/asyncio-stream.rst:61
msgid ""
"The returned *reader* and *writer* objects are instances of :class:"
"`StreamReader` and :class:`StreamWriter` classes."
msgstr ""
"Les objets *lecteur* et *écrivain* renvoyés sont des instances des classes :"
"class:`StreamReader` et :class:`StreamWriter`."

#: library/asyncio-stream.rst:109
msgid ""
"*limit* determines the buffer size limit used by the returned :class:"
"`StreamReader` instance.  By default the *limit* is set to 64 KiB."
msgstr ""
"*limit* détermine la limite de taille de tampon utilisée par l'instance :"
"class:`StreamReader` renvoyée. Par défaut, *limit* est fixée à 64 Kio."

#: library/asyncio-stream.rst:68
msgid ""
"The rest of the arguments are passed directly to :meth:`loop."
"create_connection`."
msgstr ""
"Le reste des arguments est passé directement à :meth:`loop."
"create_connection`."

# suit un :
#: library/asyncio-stream.rst:147
msgid ""
"The *sock* argument transfers ownership of the socket to the :class:"
"`StreamWriter` created. To close the socket, call its :meth:`~asyncio."
"StreamWriter.close` method."
msgstr ""
"l'argument *sock* transfère la propriété du connecteur réseau au :class:"
"`StreamWriter` créé. Pour fermer le connecteur, appelez sa méthode :meth:"
"`~asyncio.StreamWriter.close`."

# suit un :
#: library/asyncio-stream.rst:77
msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "ajout du paramètre *ssl_handshake_timeout*."

# suit un :
#: library/asyncio-stream.rst:80
msgid "Added *happy_eyeballs_delay* and *interleave* parameters."
msgstr "ajout des paramètres *happy_eyeballs_delay* et *interleave*."

# suit un :
#: library/asyncio-stream.rst:125 library/asyncio-stream.rst:187
msgid "Removed the *loop* parameter."
msgstr "suppression du paramètre *loop*."

# suit un :
#: library/asyncio-stream.rst:128 library/asyncio-stream.rst:190
msgid "Added the *ssl_shutdown_timeout* parameter."
msgstr "ajout du paramètre *ssl_shutdown_timeout*."

#: library/asyncio-stream.rst:98
msgid "Start a socket server."
msgstr "Démarre un serveur de connexions"

#: library/asyncio-stream.rst:100
msgid ""
"The *client_connected_cb* callback is called whenever a new client "
"connection is established.  It receives a ``(reader, writer)`` pair as two "
"arguments, instances of the :class:`StreamReader` and :class:`StreamWriter` "
"classes."
msgstr ""
"La fonction de rappel *client_connected_cb* est appelée chaque fois qu'une "
"nouvelle connexion client est établie. Elle reçoit une paire d'arguments "
"``(lecteur, écrivain)``, instances des classes :class:`StreamReader` et :"
"class:`StreamWriter`."

#: library/asyncio-stream.rst:105
msgid ""
"*client_connected_cb* can be a plain callable or a :ref:`coroutine function "
"<coroutine>`; if it is a coroutine function, it will be automatically "
"scheduled as a :class:`Task`."
msgstr ""
"*client_connected_cb* peut être un simple appelable ou une fonction :ref:"
"`coroutine <coroutine>` ; s'il s'agit d'une fonction coroutine, elle sera "
"automatiquement planifiée en tant que :class:`Task`."

#: library/asyncio-stream.rst:113
msgid ""
"The rest of the arguments are passed directly to :meth:`loop.create_server`."
msgstr ""
"Le reste des arguments est passé directement à :meth:`loop.create_server`."

# suit un :
#: library/asyncio-stream.rst:177
msgid ""
"The *sock* argument transfers ownership of the socket to the server created. "
"To close the socket, call the server's :meth:`~asyncio.Server.close` method."
msgstr ""
"l'argument *sock* transfère la propriété du connecteur au serveur créé. Pour "
"fermer le connecteur, appelez la méthode :meth:`~asyncio.Server.close` du "
"serveur."

# suit un :
#: library/asyncio-stream.rst:122
msgid "Added the *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "ajout des paramètres *ssl_handshake_timeout* et *start_serving*."

#: library/asyncio-stream.rst:133
msgid "Unix Sockets"
msgstr "Connecteurs Unix (*sockets*)"

#: library/asyncio-stream.rst:138
msgid ""
"Establish a Unix socket connection and return a pair of ``(reader, writer)``."
msgstr ""
"Ouvre un connecteur Unix et renvoie une paire de ``(lecteur, écrivain)``."

#: library/asyncio-stream.rst:141
msgid "Similar to :func:`open_connection` but operates on Unix sockets."
msgstr ""
"Similaire à :func:`open_connection` mais fonctionne sur les connecteurs Unix."

#: library/asyncio-stream.rst:143
msgid "See also the documentation of :meth:`loop.create_unix_connection`."
msgstr "Voir aussi la documentation de :meth:`loop.create_unix_connection`."

#: library/asyncio-stream.rst:181
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Disponibilité <availability>` : Unix."

# suit un :
#: library/asyncio-stream.rst:153
msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`"
msgstr ""
"ajout du paramètre *ssl_handshake_timeout*. Le paramètre *path* peut "
"désormais être un :term:`objet simili-chemin <path-like object>`"

#: library/asyncio-stream.rst:169
msgid "Start a Unix socket server."
msgstr "Démarre un connecteur Unix en mode serveur."

#: library/asyncio-stream.rst:171
msgid "Similar to :func:`start_server` but works with Unix sockets."
msgstr ""
"Similaire à :func:`start_server` mais fonctionne avec les connecteurs Unix."

#: library/asyncio-stream.rst:173
msgid "See also the documentation of :meth:`loop.create_unix_server`."
msgstr "Voir aussi la documentation de :meth:`loop.create_unix_server`."

# suit un :
#: library/asyncio-stream.rst:183
msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :term:`path-like object`."
msgstr ""
"ajout des paramètres *ssl_handshake_timeout* et *start_serving*. Le "
"paramètre *chemin* peut désormais être un :term:`simili-chemin<path-like "
"object>`."

#: library/asyncio-stream.rst:195
msgid "StreamReader"
msgstr "Flux lecteurs (*StreamReader*)"

#: library/asyncio-stream.rst:199
msgid ""
"Represents a reader object that provides APIs to read data from the IO "
"stream. As an :term:`asynchronous iterable`, the object supports the :"
"keyword:`async for` statement."
msgstr ""
"Représente un objet lecteur qui fournit des API pour lire les données du "
"flux d'entrée-sortie. En tant que :term:`itérable asynchrone <asynchronous "
"iterable>`, l'objet prend en charge l'instruction :keyword:`async for`."

#: library/asyncio-stream.rst:203
msgid ""
"It is not recommended to instantiate *StreamReader* objects directly; use :"
"func:`open_connection` and :func:`start_server` instead."
msgstr ""
"Il n'est pas recommandé d'instancier directement les objets *StreamReader* ; "
"utilisez :func:`open_connection` et :func:`start_server` à la place."

#: library/asyncio-stream.rst:209
msgid "Read up to *n* bytes from the stream."
msgstr "Lit jusqu'à *n* octets du flux."

#: library/asyncio-stream.rst:211
msgid ""
"If *n* is not provided or set to ``-1``, read until EOF, then return all "
"read :class:`bytes`. If EOF was received and the internal buffer is empty, "
"return an empty ``bytes`` object."
msgstr ""
"Si *n* n'est pas fourni ou défini à ``-1``, lit jusqu'à *EOF*, puis renvoie "
"tous les :class:`bytes` lus. Si *EOF* a été reçu et que le tampon interne "
"est vide, renvoie un objet ``bytes`` vide."

#: library/asyncio-stream.rst:216
msgid "If *n* is ``0``, return an empty ``bytes`` object immediately."
msgstr "Si *n* vaut ``0``, renvoie immédiatement un objet ``bytes`` vide."

#: library/asyncio-stream.rst:218
msgid ""
"If *n* is positive, return at most *n* available ``bytes`` as soon as at "
"least 1 byte is available in the internal buffer. If EOF is received before "
"any byte is read, return an empty ``bytes`` object."
msgstr ""
"Si *n* est positif, renvoie au plus *n* ``bytes`` disponibles dès qu'au "
"moins 1 octet est disponible dans le tampon interne. Si *EOF* est reçu avant "
"qu'aucun octet ne soit lu, renvoie un objet ``bytes`` vide."

#: library/asyncio-stream.rst:225
msgid ""
"Read one line, where \"line\" is a sequence of bytes ending with ``\\n``."
msgstr ""
"Lit une ligne, où une « ligne » est une séquence d'octets se terminant par ``"
"\\n``."

#: library/asyncio-stream.rst:228
msgid ""
"If EOF is received and ``\\n`` was not found, the method returns partially "
"read data."
msgstr ""
"Si *EOF* est reçu et ``\\n`` n'a pas été trouvé, la méthode renvoie des "
"données partiellement lues."

#: library/asyncio-stream.rst:231
msgid ""
"If EOF is received and the internal buffer is empty, return an empty "
"``bytes`` object."
msgstr ""
"Si *EOF* est reçu et que le tampon interne est vide, renvoie un objet "
"``bytes`` vide."

#: library/asyncio-stream.rst:236
msgid "Read exactly *n* bytes."
msgstr "Lit exactement *n* octets."

#: library/asyncio-stream.rst:238
msgid ""
"Raise an :exc:`IncompleteReadError` if EOF is reached before *n* can be "
"read.  Use the :attr:`IncompleteReadError.partial` attribute to get the "
"partially read data."
msgstr ""
"Lève une :exc:`IncompleteReadError` si *EOF* est atteint avant que *n* "
"octets ne puissent être lus. Utilisez l'attribut :attr:`IncompleteReadError."
"partial` pour obtenir les données partiellement lues."

#: library/asyncio-stream.rst:244
msgid "Read data from the stream until *separator* is found."
msgstr "Lit les données du flux jusqu'à ce que le *separator* soit trouvé."

#: library/asyncio-stream.rst:246
msgid ""
"On success, the data and separator will be removed from the internal buffer "
"(consumed). Returned data will include the separator at the end."
msgstr ""
"En cas de succès, les données et le séparateur sont supprimés du tampon "
"interne (consommés). Les données renvoyées incluent le séparateur à la fin."

#: library/asyncio-stream.rst:250
msgid ""
"If the amount of data read exceeds the configured stream limit, a :exc:"
"`LimitOverrunError` exception is raised, and the data is left in the "
"internal buffer and can be read again."
msgstr ""
"Si la quantité de données lues dépasse la limite de flux configurée, une "
"exception :exc:`LimitOverrunError` est levée et les données sont laissées "
"dans le tampon interne et peuvent être lues à nouveau."

#: library/asyncio-stream.rst:254
msgid ""
"If EOF is reached before the complete separator is found, an :exc:"
"`IncompleteReadError` exception is raised, and the internal buffer is "
"reset.  The :attr:`IncompleteReadError.partial` attribute may contain a "
"portion of the separator."
msgstr ""
"Si *EOF* est atteint avant que le séparateur complet ne soit trouvé, une "
"exception :exc:`IncompleteReadError` est levée  et le tampon interne est "
"réinitialisé. L'attribut :attr:`IncompleteReadError.partial` peut contenir "
"une partie du séparateur."

#: library/asyncio-stream.rst:263
msgid "Return ``True`` if the buffer is empty and :meth:`feed_eof` was called."
msgstr ""
"Renvoie ``True`` si le tampon est vide et que :meth:`feed_eof` a été appelée."

#: library/asyncio-stream.rst:268
msgid "StreamWriter"
msgstr "Flux écrivains (*StreamWriter*)"

#: library/asyncio-stream.rst:272
msgid ""
"Represents a writer object that provides APIs to write data to the IO stream."
msgstr ""
"Représente un objet écrivain qui fournit des API pour écrire des données "
"dans le flux d'entrée-sortie."

#: library/asyncio-stream.rst:275
msgid ""
"It is not recommended to instantiate *StreamWriter* objects directly; use :"
"func:`open_connection` and :func:`start_server` instead."
msgstr ""
"Il n'est pas recommandé d'instancier directement les objets *StreamWriter* ; "
"utilisez :func:`open_connection` et :func:`start_server` à la place."

#: library/asyncio-stream.rst:281
msgid ""
"The method attempts to write the *data* to the underlying socket "
"immediately. If that fails, the data is queued in an internal write buffer "
"until it can be sent."
msgstr ""
"La méthode tente d'écrire immédiatement les *data* dans le connecteur sous-"
"jacent. Si cela échoue, les données sont mises en file d'attente dans un "
"tampon d'écriture interne jusqu'à ce qu'elles puissent être envoyées."

#: library/asyncio-stream.rst:297
msgid "The method should be used along with the ``drain()`` method::"
msgstr "La méthode doit être utilisée avec la méthode ``drain()`` ::"

#: library/asyncio-stream.rst:292
msgid ""
"The method writes a list (or any iterable) of bytes to the underlying socket "
"immediately. If that fails, the data is queued in an internal write buffer "
"until it can be sent."
msgstr ""
"La méthode écrit immédiatement une liste (ou tout itérable) d'octets dans le "
"connecteur sous-jacent. Si cela échoue, les données sont mises en file "
"d'attente dans un tampon d'écriture interne jusqu'à ce qu'elles puissent "
"être envoyées."

#: library/asyncio-stream.rst:304
msgid "The method closes the stream and the underlying socket."
msgstr "La méthode ferme le flux et le connecteur sous-jacent."

#: library/asyncio-stream.rst:306
msgid ""
"The method should be used, though not mandatory, along with the "
"``wait_closed()`` method::"
msgstr ""
"La méthode doit être utilisée, bien que ce ne soit pas obligatoire, avec la "
"méthode ``wait_closed()`` ::"

#: library/asyncio-stream.rst:314
msgid ""
"Return ``True`` if the underlying transport supports the :meth:`write_eof` "
"method, ``False`` otherwise."
msgstr ""
"Renvoie ``True`` si le transport sous-jacent gère la méthode :meth:"
"`write_eof`, ``False`` sinon."

#: library/asyncio-stream.rst:319
msgid ""
"Close the write end of the stream after the buffered write data is flushed."
msgstr ""
"Ferme le flux en écriture après le vidage des données d'écriture en mémoire "
"tampon."

#: library/asyncio-stream.rst:324
msgid "Return the underlying asyncio transport."
msgstr "Renvoie le transport asynchrone sous-jacent."

#: library/asyncio-stream.rst:328
msgid ""
"Access optional transport information; see :meth:`BaseTransport."
"get_extra_info` for details."
msgstr ""
"Donne accès aux informations de transport facultatives ; voir :meth:"
"`BaseTransport.get_extra_info` pour plus de détails."

#: library/asyncio-stream.rst:333
msgid "Wait until it is appropriate to resume writing to the stream. Example::"
msgstr ""
"Attend qu'il soit approprié de reprendre l'écriture dans le flux. Par "
"exemple ::"

#: library/asyncio-stream.rst:339
msgid ""
"This is a flow control method that interacts with the underlying IO write "
"buffer.  When the size of the buffer reaches the high watermark, *drain()* "
"blocks until the size of the buffer is drained down to the low watermark and "
"writing can be resumed.  When there is nothing to wait for, the :meth:"
"`drain` returns immediately."
msgstr ""
"Il s'agit d'une méthode de contrôle de flux qui interagit avec le tampon "
"d'écriture entrée-sortie sous-jacent. Lorsque la taille du tampon atteint la "
"limite haute, *drain()* bloque jusqu'à ce que la taille du tampon soit "
"drainée jusqu'à la limite basse et que l'écriture puisse reprendre. "
"Lorsqu'il n'y a rien à attendre, :meth:`drain` termine immédiatement."

#: library/asyncio-stream.rst:349
msgid "Upgrade an existing stream-based connection to TLS."
msgstr "Bascule la connexion basée sur le flux existant vers TLS."

#: library/asyncio-stream.rst:351
msgid "Parameters:"
msgstr "Paramètres :"

#: library/asyncio-stream.rst:353
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext* : une instance configurée de :class:`~ssl.SSLContext`."

#: library/asyncio-stream.rst:355
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname* : définit ou remplace le nom d'hôte auquel le certificat "
"du serveur cible sera comparé."

#: library/asyncio-stream.rst:358
msgid ""
"*ssl_handshake_timeout* is the time in seconds to wait for the TLS handshake "
"to complete before aborting the connection.  ``60.0`` seconds if ``None`` "
"(default)."
msgstr ""
"*ssl_handshake_timeout* est le temps en secondes à attendre pour que la "
"poignée de main TLS se termine avant d'abandonner la connexion. ``60.0`` "
"secondes si ``None`` (par défaut)."

#: library/asyncio-stream.rst:366
msgid ""
"Return ``True`` if the stream is closed or in the process of being closed."
msgstr "Renvoie ``True`` si le flux est fermé ou en cours de fermeture."

#: library/asyncio-stream.rst:373
msgid "Wait until the stream is closed."
msgstr "Attend que le flux soit fermé."

#: library/asyncio-stream.rst:375
msgid ""
"Should be called after :meth:`close` to wait until the underlying connection "
"is closed, ensuring that all data has been flushed before e.g. exiting the "
"program."
msgstr ""
"Doit être appelée après :meth:`close` pour attendre que la connexion sous-"
"jacente soit fermée, en s'assurant que toutes les données ont été vidées "
"avant, par exemple, de quitter le programme."

#: library/asyncio-stream.rst:383
msgid "Examples"
msgstr "Exemples"

#: library/asyncio-stream.rst:388
msgid "TCP echo client using streams"
msgstr "Client d'écho TCP utilisant des flux"

#: library/asyncio-stream.rst:390
msgid "TCP echo client using the :func:`asyncio.open_connection` function::"
msgstr ""
"Client d'écho TCP utilisant la fonction :func:`asyncio.open_connection` ::"

#: library/asyncio-stream.rst:414
msgid ""
"The :ref:`TCP echo client protocol "
"<asyncio_example_tcp_echo_client_protocol>` example uses the low-level :meth:"
"`loop.create_connection` method."
msgstr ""
"L'exemple :ref:`asyncio_example_tcp_echo_client_protocol` utilise la méthode "
"de bas niveau :meth:`loop.create_connection`."

#: library/asyncio-stream.rst:421
msgid "TCP echo server using streams"
msgstr "Serveur d'écho TCP utilisant des flux"

#: library/asyncio-stream.rst:423
msgid "TCP echo server using the :func:`asyncio.start_server` function::"
msgstr ""
"Serveur d'écho TCP utilisant la fonction :func:`asyncio.start_server` ::"

#: library/asyncio-stream.rst:457
msgid ""
"The :ref:`TCP echo server protocol "
"<asyncio_example_tcp_echo_server_protocol>` example uses the :meth:`loop."
"create_server` method."
msgstr ""
"L'exemple de :ref:`asyncio_example_tcp_echo_server_protocol` utilise la "
"méthode :meth:`loop.create_server`."

#: library/asyncio-stream.rst:462
msgid "Get HTTP headers"
msgstr "Récupération des en-têtes HTTP"

#: library/asyncio-stream.rst:464
msgid ""
"Simple example querying HTTP headers of the URL passed on the command line::"
msgstr ""
"Exemple simple d'interrogation des en-têtes HTTP de l'URL transmise sur la "
"ligne de commande ::"

#: library/asyncio-stream.rst:503
msgid "Usage::"
msgstr "Utilisation ::"

#: library/asyncio-stream.rst:507
msgid "or with HTTPS::"
msgstr "ou avec HTTPS ::"

#: library/asyncio-stream.rst:515
msgid "Register an open socket to wait for data using streams"
msgstr "Ouverture d'un connecteur pour attendre les données à l'aide de flux"

#: library/asyncio-stream.rst:517
msgid ""
"Coroutine waiting until a socket receives data using the :func:"
"`open_connection` function::"
msgstr ""
"Coroutine attendant qu'un connecteur reçoive des données en utilisant la "
"fonction :func:`open_connection` ::"

#: library/asyncio-stream.rst:552
msgid ""
"The :ref:`register an open socket to wait for data using a protocol "
"<asyncio_example_create_connection>` example uses a low-level protocol and "
"the :meth:`loop.create_connection` method."
msgstr ""
"L'exemple :ref:`asyncio_example_create_connection` utilise un protocole de "
"bas niveau et la méthode :meth:`loop.create_connection`."

#: library/asyncio-stream.rst:556
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to watch a file descriptor."
msgstr ""
"L'exemple :ref:`asyncio_example_watch_fd` utilise la méthode de bas niveau :"
"meth:`loop.add_reader` pour surveiller un descripteur de fichier."
