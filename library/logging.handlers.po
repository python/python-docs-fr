# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-24 09:01+0200\n"
"PO-Revision-Date: 2020-12-14 10:12+0100\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Last-Translator: Philippe GALVAN <git.philippe.galvan@outlook.fr>\n"
"X-Generator: Poedit 2.4.2\n"

#: library/logging.handlers.rst:2
msgid ":mod:`logging.handlers` --- Logging handlers"
msgstr ":mod:`logging.handlers` — Gestionnaires de journalisation"

#: library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**Code source :** :source:`Lib/logging/handlers.py`"

#: library/logging.handlers.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Cette page contient uniquement des informations de référence. Pour des "
"tutoriels, veuillez consulter"

#: library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutoriel basique <logging-basic-tutorial>`"

#: library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutoriel avancé <logging-advanced-tutorial>`"

#: library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`livre de recettes sur la journalisation <logging-cookbook>`"

#: library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and :class:"
"`NullHandler`) are actually defined in the :mod:`logging` module itself, but "
"have been documented here along with the other handlers."
msgstr ""
"Les gestionnaires suivants, très utiles, sont fournis dans le paquet. Notez "
"que trois des gestionnaires (:class:`StreamHandler`, :class:`FileHandler` "
"et :class:`NullHandler`) sont en réalité définis dans le module :mod:"
"`logging` lui-même, mais qu’ils sont documentés ici avec les autres "
"gestionnaires."

#: library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "Gestionnaire à flux — *StreamHandler*"

#: library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports :meth:"
"`write` and :meth:`flush` methods)."
msgstr ""
"La classe :class:`StreamHandler`, du paquet :mod:`logging`, envoie les "
"sorties de journalisation dans des flux tels que *sys.stdout*, *sys.stderr* "
"ou n’importe quel objet fichier-compatible (ou, plus précisément, tout objet "
"qui gère les méthodes :meth:`write` et :meth:`flush`)."

#: library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, *sys."
"stderr* will be used."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`StreamHandler`. Si "
"*stream* est spécifié, l’instance l’utilise pour les sorties de "
"journalisation ; autrement elle utilise *sys.stderr*."

#: library/logging.handlers.rst:50
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using :func:`traceback."
"print_exception` and appended to the stream."
msgstr ""
"Si un formateur est spécifié, il est utilisé pour formater l’enregistrement. "
"L’enregistrement est ensuite écrit dans le flux, suivi par :attr:"
"`terminator`. Si une information d’exception est présente, elle est formatée "
"en utilisant :func:`traceback.print_exception` puis ajoutée aux flux."

#: library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the :meth:"
"`close` method is inherited from :class:`~logging.Handler` and so does no "
"output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"Purge le flux en appelant sa méthode :meth:`flush`. Notez que la méthode :"
"meth:`close` est héritée de :class:`~logging.Handler` donc elle n'écrit "
"rien. Par conséquent, un appel explicite à :meth:`flush` peut parfois "
"s'avérer nécessaire."

#: library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr ""
"Définit le flux de l’instance à la valeur spécifiée, si elle est différente. "
"L’ancien flux est purgé avant que le nouveau flux ne soit établi."

#: library/logging.handlers.rst:0
msgid "Parameters"
msgstr "Paramètres"

#: library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "Le flux que le gestionnaire doit utiliser."

#: library/logging.handlers.rst:0
msgid "Returns"
msgstr "Renvoie"

#: library/logging.handlers.rst:69
msgid "the old stream, if the stream was changed, or *None* if it wasn't."
msgstr "l’ancien flux, si le flux a été changé, ou *None* s’il ne l’a pas été."

#: library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr ""
"Chaine de caractères utilisée comme marqueur de fin lors de l’écriture "
"formatée d'un enregistrement dans un flux. La valeur par défaut est "
"``'\\n'``."

#: library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr ""
"Si vous ne voulez pas marquer de fin de ligne, vous pouvez définir "
"l’attribut ``terminator`` du gestionnaire en tant que chaîne de caractères "
"vide."

#: library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr ""
"Dans des versions antérieures, le marqueur de fin était codé en dur sous la "
"forme ``'\\n'``."

#: library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "Gestionnaire à fichier — *FileHandler*"

#: library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
"La classe :class:`FileHandler`, du paquet :mod:`logging`, envoie les sorties "
"de journalisation dans un fichier. Elle hérite des fonctionnalités de sortie "
"de :class:`StreamHandler`."

#: library/logging.handlers.rst:98
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file "
"is opened and used as the stream for logging. If *mode* is not specified, :"
"const:`'a'` is used.  If *encoding* is not ``None``, it is used to open the "
"file with that encoding.  If *delay* is true, then file opening is deferred "
"until the first call to :meth:`emit`. By default, the file grows "
"indefinitely. If *errors* is specified, it's used to determine how encoding "
"errors are handled."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`FileHandler`. Le fichier "
"spécifié est ouvert et utilisé comme flux pour la journalisation. Si *mode* "
"n’est pas spécifié, :const:`'a'` est utilisé. Si *encoding* n’est pas à "
"``None``, il est utilisé pour ouvrir le fichier avec cet encodage. Si "
"*delay* est ``True``, alors l’ouverture du fichier est reportée jusqu’au "
"premier appel de :meth:`emit`. Par défaut, le fichier croit indéfiniment. Si "
"*errors* est spécifié, il est utilisé pour déterminer comment sont gérées "
"les erreurs d’encodage."

#: library/logging.handlers.rst:105 library/logging.handlers.rst:187
#: library/logging.handlers.rst:322 library/logging.handlers.rst:428
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr ""
"L'argument *filename* accepte les objets :class:`~pathlib.Path` aussi bien "
"que les chaînes de caractères."

#: library/logging.handlers.rst:109 library/logging.handlers.rst:191
#: library/logging.handlers.rst:326 library/logging.handlers.rst:432
msgid "The *errors* parameter was added."
msgstr "Le paramètre *errors* a été ajouté."

#: library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "Ferme le fichier."

#: library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "Écrit l’enregistrement dans le fichier."

#: library/logging.handlers.rst:124
msgid "NullHandler"
msgstr "Gestionnaire à puits sans fond — *NullHandler*"

#: library/logging.handlers.rst:128
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
"La classe :class:`NullHandler`, située dans le paquet principal :mod:"
"`logging`, ne produit aucun formatage ni sortie. C’est essentiellement un "
"gestionnaire « fantôme » destiné aux développeurs de bibliothèques."

#: library/logging.handlers.rst:134
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr "Renvoie une nouvelle instance de la classe :class:`NullHandler`."

#: library/logging.handlers.rst:138 library/logging.handlers.rst:142
msgid "This method does nothing."
msgstr "Cette méthode ne fait rien."

#: library/logging.handlers.rst:146
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr ""
"Cette méthode renvoie ``None`` pour le verrou, étant donné qu’il n’y a aucun "
"flux d'entrée-sortie sous-jacent dont l’accès doit être sérialisé."

#: library/logging.handlers.rst:150
msgid ""
"See :ref:`library-config` for more information on how to use :class:"
"`NullHandler`."
msgstr ""
"Voir :ref:`library-config` pour plus d’information sur l'utilisation de :"
"class:`NullHandler`."

#: library/logging.handlers.rst:156
msgid "WatchedFileHandler"
msgstr "Gestionnaire à fichier avec surveillance — *WatchedFileHandler*"

#: library/logging.handlers.rst:160
msgid ""
"The :class:`WatchedFileHandler` class, located in the :mod:`logging."
"handlers` module, is a :class:`FileHandler` which watches the file it is "
"logging to. If the file changes, it is closed and reopened using the file "
"name."
msgstr ""
"La classe :class:`WatchedFileHandler`, située dans le module :mod:`logging."
"handlers`, est un :class:`FileHandler` qui surveille le fichier dans lequel "
"il journalise. Si le fichier change, il est fermé et rouvert en utilisant le "
"nom du fichier."

#: library/logging.handlers.rst:164
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"Un changement du fichier peut arriver à cause de l’utilisation de programmes "
"tels que *newsyslog* ou *logrotate* qui assurent le roulement des fichiers "
"de journalisation. Ce gestionnaire, destiné à une utilisation sous Unix/"
"Linux, surveille le fichier pour voir s’il a changé depuis la dernière "
"écriture (un fichier est réputé avoir changé si son nœud d’index ou le "
"périphérique auquel il est rattaché a changé). Si le fichier a changé, "
"l’ancien flux vers ce fichier est fermé, et le fichier est ouvert pour "
"établir un nouveau flux."

#: library/logging.handlers.rst:171
msgid ""
"This handler is not appropriate for use under Windows, because under Windows "
"open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"Ce gestionnaire n’est pas approprié pour une utilisation sous *Windows*, car "
"sous *Windows* les fichiers de journalisation ouverts ne peuvent être ni "
"déplacés, ni renommés — la journalisation ouvre les fichiers avec des "
"verrous exclusifs — de telle sorte qu’il n’y a pas besoin d’un tel "
"gestionnaire. En outre, *ST_INO* n’est pas géré par *Windows* ; :func:`~os."
"stat` renvoie toujours zéro pour cette valeur."

#: library/logging.handlers.rst:180
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, :const:`'a'` is used.  If *encoding* is not ``None``, it is "
"used to open the file with that encoding.  If *delay* is true, then file "
"opening is deferred until the first call to :meth:`emit`.  By default, the "
"file grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`WatchedFileHandler`. Le "
"fichier spécifié est ouvert et utilisé comme flux pour la journalisation. Si "
"*mode* n’est pas spécifié, :const:`'a'` est utilisé. Si *encoding* n’est pas "
"``None``, il est utilisé pour ouvrir le fichier avec cet encodage. Si "
"*delay* est à *true*, alors l’ouverture du fichier est reportée jusqu’au "
"premier appel à :meth:`emit`. Par défaut, le fichier croit indéfiniment. Si "
"*errors* est spécifié, il est utilisé pour déterminer comment sont gérées "
"les erreurs d’encodage."

#: library/logging.handlers.rst:196
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr ""
"Vérifie si le fichier a changé. Si c’est le cas, le flux existant est purgé "
"et fermé et le fichier est rouvert, généralement avant d'effectuer "
"l’écriture de l'enregistrement dans le fichier."

#: library/logging.handlers.rst:205
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr ""
"Écrit l’enregistrement dans le fichier, mais appelle d’abord :meth:"
"`reopenIfNeeded` pour rouvrir le fichier s’il a changé."

#: library/logging.handlers.rst:211
msgid "BaseRotatingHandler"
msgstr "Base des gestionnaires à roulement *BaseRotatingHandler*"

#: library/logging.handlers.rst:213
msgid ""
"The :class:`BaseRotatingHandler` class, located in the :mod:`logging."
"handlers` module, is the base class for the rotating file handlers, :class:"
"`RotatingFileHandler` and :class:`TimedRotatingFileHandler`. You should not "
"need to instantiate this class, but it has attributes and methods you may "
"need to override."
msgstr ""
"La classe :class:`BaseRotatingHandler`, située dans le module :mod:`logging."
"handlers`, est la classe de base pour les gestionnaires à roulement, :class:"
"`RotatingFileHandler` et :class:`TimedRotatingFileHandler`. Vous ne devez "
"pas initialiser cette classe, mais elle a des attributs et des méthodes que "
"vous devrez peut-être surcharger."

#: library/logging.handlers.rst:221
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr ""
"Les paramètres sont les mêmes que pour :class:`FileHandler`. Les attributs "
"sont :"

#: library/logging.handlers.rst:225
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method "
"delegates to this callable. The parameters passed to the callable are those "
"passed to :meth:`rotation_filename`."
msgstr ""
"Si cet attribut est défini en tant qu’appelable, la méthode :meth:"
"`rotation_filename` se rapporte à cet appelable. Les paramètres passés à "
"l’appelable sont ceux passés à :meth:`rotation_filename`."

#: library/logging.handlers.rst:229
msgid ""
"The namer function is called quite a few times during rollover, so it should "
"be as simple and as fast as possible. It should also return the same output "
"every time for a given input, otherwise the rollover behaviour may not work "
"as expected."
msgstr ""
"La fonction *namer* est appelée pas mal de fois durant le roulement, de "
"telle sorte qu’elle doit être aussi simple et rapide que possible. Elle doit "
"aussi renvoyer toujours la même sortie pour une entrée donnée, autrement le "
"comportement du roulement pourrait être différent de celui attendu."

#: library/logging.handlers.rst:239
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed "
"to :meth:`rotate`."
msgstr ""
"Si cet attribut est défini en tant qu’appelable, cet appelable se substitue "
"à la méthode :meth:`rotate`. Les paramètres passés à l’appelable sont ceux "
"passés à :meth:`rotate`."

#: library/logging.handlers.rst:247
msgid "Modify the filename of a log file when rotating."
msgstr ""
"Modifie le nom du fichier d’un fichier de journalisation lors du roulement."

#: library/logging.handlers.rst:249
msgid "This is provided so that a custom filename can be provided."
msgstr "Cette méthode sert à pouvoir produire un nom de fichier personnalisé."

#: library/logging.handlers.rst:251
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"L’implémentation par défaut appelle l’attribut *namer* du gestionnaire, si "
"c’est un appelable, lui passant le nom par défaut. Si l’attribut n’est pas "
"un appelable (le défaut est ``None``), le nom est renvoyé tel quel."

#: library/logging.handlers.rst:255
msgid "The default name for the log file."
msgstr "Le nom par défaut du fichier de journalisation."

#: library/logging.handlers.rst:262
msgid "When rotating, rotate the current log."
msgstr "Lors du roulement, effectue le roulement du journal courant."

#: library/logging.handlers.rst:264
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute "
"isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"L’implémentation par défaut appelle l’attribut *rotator* du gestionnaire, si "
"c’est un appelable, lui passant les arguments *source* et *dest*. Si "
"l’attribut n’est pas un appelable (le défaut est ``None``), le nom de la "
"source est simplement renommé avec la destination."

#: library/logging.handlers.rst:269
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr ""
"Le nom du fichier source. Il s’agit normalement du nom du fichier, par "
"exemple ``\"test.log\"``."

#: library/logging.handlers.rst:271
msgid ""
"The destination filename. This is normally what the source is rotated to, e."
"g. 'test.log.1'."
msgstr ""
"Le nom du fichier de destination. Il s’agit normalement du nom donné à la "
"source après le roulement, par exemple ``\"test.log.1\"``."

#: library/logging.handlers.rst:276
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and :"
"class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"La raison d’être de ces attributs est de vous épargner la création d’une "
"sous-classe — vous pouvez utiliser les mêmes appels pour des instances de :"
"class:`RotatingFileHandler` et :class:`TimedRotatingFileHandler`. Si le "
"*namer* ou le *rotator* appelable lève une exception, ce sera géré de la "
"même manière que n’importe quelle exception durant un appel :meth:`emit`, "
"c'est-à-dire par la méthode :meth:`handleError` du gestionnaire."

#: library/logging.handlers.rst:283
msgid ""
"If you need to make more significant changes to rotation processing, you can "
"override the methods."
msgstr ""
"Si vous avez besoin de faire d’importantes modifications au processus de "
"roulement, surchargez les méthodes."

#: library/logging.handlers.rst:286
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "Pour un exemple, voir :ref:`cookbook-rotator-namer`."

#: library/logging.handlers.rst:292
msgid "RotatingFileHandler"
msgstr "Gestionnaire à roulement de fichiers — *RotatingFileHandler*"

#: library/logging.handlers.rst:294
msgid ""
"The :class:`RotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files."
msgstr ""
"La classe :class:`RotatingFileHandler`, située dans le module :mod:`logging."
"handlers`, gère le roulement des fichiers de journalisation sur disque."

#: library/logging.handlers.rst:300
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`RotatingFileHandler`. Le "
"fichier spécifié est ouvert et utilisé en tant que flux de sortie pour la "
"journalisation. Si *mode* n’est pas spécifié, ``'a'`` est utilisé. Si "
"*encoding* n’est pas à ``None``, il est utilisé pour ouvrir le fichier avec "
"cet encodage. Si *delay* est à *true*, alors l’ouverture du fichier est "
"reportée au premier appel de :meth:`emit`. Par défaut, le fichier croit "
"indéfiniment. Si *errors* est spécifié, il détermine comment sont gérées les "
"erreurs d’encodage."

#: library/logging.handlers.rst:307
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to :"
"dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never "
"occurs, so you generally want to set *backupCount* to at least 1, and have a "
"non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of :file:`app."
"log`, you would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, "
"up to :file:`app.log.5`. The file being written to is always :file:`app."
"log`.  When this file is filled, it is closed and renamed to :file:`app."
"log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, etc. exist, then "
"they are renamed to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"Utilisez les valeurs *maxBytes* et *backupCount* pour autoriser le roulement "
"du fichier (:dfn:`rollover`) à une taille prédéterminée. Quand la taille "
"limite est sur le point d’être dépassée, le fichier est fermé et un nouveau "
"fichier est discrètement ouvert en tant que sortie. Un roulement se produit "
"dès que le fichier de journalisation actuel atteint presque une taille de "
"*maxBytes* ; si *maxBytes* ou *backupCount* est à 0, le roulement ne se "
"produit jamais, donc en temps normal il convient de définir *backupCount* à "
"au moins 1, et avoir une valeur de *maxBytes* non nulle. Quand *backupCount* "
"est non nul, le système sauvegarde les anciens fichiers de journalisation en "
"leur ajoutant au nom du fichier, les suffixes ``\".1\"``, ``\".2\"`` et "
"ainsi de suite. Par exemple, avec un *backupCount* de 5 et :file:`app.log` "
"comme radical du fichier, vous obtiendrez :file:`app.log`, :file:`app."
"log.1`, :file:`app.log.2`, jusqu’à :file:`app.log.5`. Le fichier dans lequel "
"on écrit est toujours :file:`app.log`. Quand ce fichier est rempli, il est "
"fermé et renommé en :file:`app.log.1`, et si les fichiers :file:`app."
"log.1`, :file:`app.log.2`, etc. existent, alors ils sont renommés "
"respectivement en :file:`app.log.2`, :file:`app.log.3` etc."

#: library/logging.handlers.rst:331 library/logging.handlers.rst:437
msgid "Does a rollover, as described above."
msgstr "Effectue un roulement, comme décrit au-dessus."

#: library/logging.handlers.rst:336
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr ""
"Écrit l'enregistrement dans le fichier, effectuant un roulement au besoin "
"comme décrit précédemment."

#: library/logging.handlers.rst:342
msgid "TimedRotatingFileHandler"
msgstr ""
"Gestionnaire à roulement de fichiers périodique — *TimedRotatingFileHandler*"

#: library/logging.handlers.rst:344
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files at certain timed "
"intervals."
msgstr ""
"La classe :class:`TimedRotatingFileHandler`, située dans le module :mod:"
"`logging.handlers`, gère le roulement des fichiers de journalisation sur le "
"disque à un intervalle de temps spécifié."

#: library/logging.handlers.rst:351
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:"
"`TimedRotatingFileHandler`. Le fichier spécifié est ouvert et utilisé en "
"tant que flux de sortie pour la journalisation. Au moment du roulement, il "
"met également à jour le suffixe du nom du fichier. Le roulement se produit "
"sur la base combinée de *when* et *interval*."

#: library/logging.handlers.rst:356
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr ""
"Utilisez le *when* pour spécifier le type de l’*interval*. La liste des "
"valeurs possibles est ci-dessous. Notez qu’elles sont sensibles à la casse."

#: library/logging.handlers.rst:360
msgid "Value"
msgstr "Valeur"

#: library/logging.handlers.rst:360
msgid "Type of interval"
msgstr "Type d’intervalle"

#: library/logging.handlers.rst:360
msgid "If/how *atTime* is used"
msgstr "Si/comment *atTime* est utilisé"

#: library/logging.handlers.rst:362
msgid "``'S'``"
msgstr "``'S'``"

#: library/logging.handlers.rst:362
msgid "Seconds"
msgstr "Secondes"

#: library/logging.handlers.rst:362 library/logging.handlers.rst:364
#: library/logging.handlers.rst:366 library/logging.handlers.rst:368
msgid "Ignored"
msgstr "Ignoré"

#: library/logging.handlers.rst:364
msgid "``'M'``"
msgstr "``'M'``"

#: library/logging.handlers.rst:364
msgid "Minutes"
msgstr "Minutes"

#: library/logging.handlers.rst:366
msgid "``'H'``"
msgstr "``'H'``"

#: library/logging.handlers.rst:366
msgid "Hours"
msgstr "Heures"

#: library/logging.handlers.rst:368
msgid "``'D'``"
msgstr "``'D'``"

#: library/logging.handlers.rst:368
msgid "Days"
msgstr "Jours"

#: library/logging.handlers.rst:370
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: library/logging.handlers.rst:370
msgid "Weekday (0=Monday)"
msgstr "Jour de la semaine (0=lundi)"

#: library/logging.handlers.rst:370 library/logging.handlers.rst:373
msgid "Used to compute initial rollover time"
msgstr "Utilisé pour calculer le moment du roulement"

#: library/logging.handlers.rst:373
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: library/logging.handlers.rst:373
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr ""
"Roulement du fichier à minuit, si *atTime* n’est pas spécifié, sinon à "
"l’heure *atTime*"

#: library/logging.handlers.rst:378
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for "
"*interval* isn't used."
msgstr ""
"Lors de l’utilisation d’un roulement basé sur les jours de la semaine, "
"définir *W0* pour lundi, *W1* pour mardi, et ainsi de suite jusqu’à *W6* "
"pour dimanche. Dans ce cas, la valeur indiquée pour *interval* n’est pas "
"utilisée."

#: library/logging.handlers.rst:382
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format ``%Y-%m-%d_"
"%H-%M-%S`` or a leading portion thereof, depending on the rollover interval."
msgstr ""
"Le système sauvegarde les anciens fichiers de journalisation en ajoutant une "
"extension au nom du fichier. Les extensions sont basées sur la date et "
"l’heure, en utilisation le format *strftime* ``%Y-%m-%d_%H-%M-%S`` ou le "
"début de celui-ci, selon l’intervalle du roulement."

#: library/logging.handlers.rst:387
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the "
"current time, is used to compute when the next rotation will occur."
msgstr ""
"Lors du premier calcul du roulement suivant (quand le gestionnaire est "
"créé), la dernière date de modification d’un fichier de journalisation "
"existant, ou sinon la date actuelle, est utilisée pour calculer la date du "
"prochain roulement."

#: library/logging.handlers.rst:391
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr ""

#: library/logging.handlers.rst:394
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""

#: library/logging.handlers.rst:399
msgid ""
"If *delay* is true, then file opening is deferred until the first call to :"
"meth:`emit`."
msgstr ""

#: library/logging.handlers.rst:402
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover "
"is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""

#: library/logging.handlers.rst:409
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""

#: library/logging.handlers.rst:412
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once "
"a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""

#: library/logging.handlers.rst:425
msgid "*atTime* parameter was added."
msgstr ""

#: library/logging.handlers.rst:441
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr ""

#: library/logging.handlers.rst:447
msgid "SocketHandler"
msgstr ""

#: library/logging.handlers.rst:449
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""

#: library/logging.handlers.rst:455
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""

#: library/logging.handlers.rst:458
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""

#: library/logging.handlers.rst:464
msgid "Closes the socket."
msgstr ""

#: library/logging.handlers.rst:469
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a :class:"
"`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""

#: library/logging.handlers.rst:479
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr ""

#: library/logging.handlers.rst:486
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket (:const:"
"`socket.SOCK_STREAM`)."
msgstr ""

#: library/logging.handlers.rst:493
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details "
"of this operation are equivalent to::"
msgstr ""

#: library/logging.handlers.rst:501
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them "
"on the receiving end, or alternatively you can disable unpickling of global "
"objects on the receiving end."
msgstr ""

#: library/logging.handlers.rst:510
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for :meth:`~SocketHandler."
"makePickle`."
msgstr ""

#: library/logging.handlers.rst:514
msgid ""
"This function allows for partial sends, which can happen when the network is "
"busy."
msgstr ""

#: library/logging.handlers.rst:520
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""

#: library/logging.handlers.rst:528
msgid "This behaviour is controlled by the following handler attributes:"
msgstr ""

#: library/logging.handlers.rst:530
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr ""

#: library/logging.handlers.rst:531
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr ""

#: library/logging.handlers.rst:532
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr ""

#: library/logging.handlers.rst:534
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""

#: library/logging.handlers.rst:543
msgid "DatagramHandler"
msgstr ""

#: library/logging.handlers.rst:545
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""

#: library/logging.handlers.rst:552
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""

#: library/logging.handlers.rst:555
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""

#: library/logging.handlers.rst:561
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a :class:`~logging."
"LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""

#: library/logging.handlers.rst:570
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""

#: library/logging.handlers.rst:576
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr ""

#: library/logging.handlers.rst:583
msgid "SysLogHandler"
msgstr ""

#: library/logging.handlers.rst:585
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""

#: library/logging.handlers.rst:591
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as "
"a string, for example '/dev/log'. In this case, a Unix domain socket is used "
"to send the message to the syslog. If *facility* is not specified, :const:"
"`LOG_USER` is used. The type of socket opened depends on the *socktype* "
"argument, which defaults to :const:`socket.SOCK_DGRAM` and thus opens a UDP "
"socket. To open a TCP socket (for use with the newer syslog daemons such as "
"rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""

#: library/logging.handlers.rst:603
msgid ""
"Note that if your server is not listening on UDP port 514, :class:"
"`SysLogHandler` may appear not to work. In that case, check what address you "
"should be using for a domain socket - it's system dependent. For example, on "
"Linux it's usually '/dev/log' but on OS/X it's '/var/run/syslog'. You'll "
"need to check your platform and use the appropriate address (you may need to "
"do this check at runtime if your application needs to run on several "
"platforms). On Windows, you pretty much have to use the UDP option."
msgstr ""

#: library/logging.handlers.rst:612
msgid "*socktype* was added."
msgstr ""

#: library/logging.handlers.rst:618
msgid "Closes the socket to the remote host."
msgstr ""

#: library/logging.handlers.rst:623
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr ""

#: library/logging.handlers.rst:626
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""

#: library/logging.handlers.rst:635
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set "
"to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""

#: library/logging.handlers.rst:642
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""

#: library/logging.handlers.rst:653
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr ""

#: library/logging.handlers.rst:657
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""

#: library/logging.handlers.rst:660
msgid "**Priorities**"
msgstr ""

#: library/logging.handlers.rst:663 library/logging.handlers.rst:685
msgid "Name (string)"
msgstr ""

#: library/logging.handlers.rst:663 library/logging.handlers.rst:685
msgid "Symbolic value"
msgstr ""

#: library/logging.handlers.rst:665
msgid "``alert``"
msgstr "``alert``"

#: library/logging.handlers.rst:665
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: library/logging.handlers.rst:667
msgid "``crit`` or ``critical``"
msgstr "``crit`` ou ``critical``"

#: library/logging.handlers.rst:667
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: library/logging.handlers.rst:669
msgid "``debug``"
msgstr "``debug``"

#: library/logging.handlers.rst:669
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: library/logging.handlers.rst:671
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` ou ``panic``"

#: library/logging.handlers.rst:671
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: library/logging.handlers.rst:673
msgid "``err`` or ``error``"
msgstr "``err`` ou ``error``"

#: library/logging.handlers.rst:673
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: library/logging.handlers.rst:675
msgid "``info``"
msgstr "``info``"

#: library/logging.handlers.rst:675
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: library/logging.handlers.rst:677
msgid "``notice``"
msgstr "``notice``"

#: library/logging.handlers.rst:677
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: library/logging.handlers.rst:679
msgid "``warn`` or ``warning``"
msgstr "``warn`` ou ``warning``"

#: library/logging.handlers.rst:679
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: library/logging.handlers.rst:682
msgid "**Facilities**"
msgstr ""

#: library/logging.handlers.rst:687
msgid "``auth``"
msgstr "``auth``"

#: library/logging.handlers.rst:687
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: library/logging.handlers.rst:689
msgid "``authpriv``"
msgstr "``authpriv``"

#: library/logging.handlers.rst:689
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: library/logging.handlers.rst:691
msgid "``cron``"
msgstr "``cron``"

#: library/logging.handlers.rst:691
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: library/logging.handlers.rst:693
msgid "``daemon``"
msgstr "``daemon``"

#: library/logging.handlers.rst:693
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: library/logging.handlers.rst:695
msgid "``ftp``"
msgstr "``ftp``"

#: library/logging.handlers.rst:695
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: library/logging.handlers.rst:697
msgid "``kern``"
msgstr "``kern``"

#: library/logging.handlers.rst:697
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: library/logging.handlers.rst:699
msgid "``lpr``"
msgstr "``lpr``"

#: library/logging.handlers.rst:699
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: library/logging.handlers.rst:701
msgid "``mail``"
msgstr "``mail``"

#: library/logging.handlers.rst:701
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: library/logging.handlers.rst:703
msgid "``news``"
msgstr "``news``"

#: library/logging.handlers.rst:703
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: library/logging.handlers.rst:705
msgid "``syslog``"
msgstr "``syslog``"

#: library/logging.handlers.rst:705
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: library/logging.handlers.rst:707
msgid "``user``"
msgstr "``user``"

#: library/logging.handlers.rst:707
msgid "LOG_USER"
msgstr "LOG_USER"

#: library/logging.handlers.rst:709
msgid "``uucp``"
msgstr "``uucp``"

#: library/logging.handlers.rst:709
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: library/logging.handlers.rst:711
msgid "``local0``"
msgstr "``local0``"

#: library/logging.handlers.rst:711
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: library/logging.handlers.rst:713
msgid "``local1``"
msgstr "``local1``"

#: library/logging.handlers.rst:713
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: library/logging.handlers.rst:715
msgid "``local2``"
msgstr "``local2``"

#: library/logging.handlers.rst:715
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: library/logging.handlers.rst:717
msgid "``local3``"
msgstr "``local3``"

#: library/logging.handlers.rst:717
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: library/logging.handlers.rst:719
msgid "``local4``"
msgstr "``local4``"

#: library/logging.handlers.rst:719
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: library/logging.handlers.rst:721
msgid "``local5``"
msgstr "``local5``"

#: library/logging.handlers.rst:721
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: library/logging.handlers.rst:723
msgid "``local6``"
msgstr "``local6``"

#: library/logging.handlers.rst:723
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: library/logging.handlers.rst:725
msgid "``local7``"
msgstr "``local7``"

#: library/logging.handlers.rst:725
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: library/logging.handlers.rst:730
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is "
"not suitable for your needs. The default algorithm maps ``DEBUG``, ``INFO``, "
"``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog names, and "
"all other level names to 'warning'."
msgstr ""

#: library/logging.handlers.rst:740
msgid "NTEventLogHandler"
msgstr ""

#: library/logging.handlers.rst:742
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's "
"Win32 extensions for Python installed."
msgstr ""

#: library/logging.handlers.rst:750
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname* "
"should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, ``'win32service."
"pyd'`` is used - this is installed with the Win32 extensions and contains "
"some basic placeholder message definitions. Note that use of these "
"placeholders will make your event logs big, as the entire message source is "
"held in the log. If you want slimmer logs, you have to pass in the name of "
"your own .dll or .exe which contains the message definitions you want to use "
"in the event log). The *logtype* is one of ``'Application'``, ``'System'`` "
"or ``'Security'``, and defaults to ``'Application'``."
msgstr ""

#: library/logging.handlers.rst:766
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""

#: library/logging.handlers.rst:775
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr ""

#: library/logging.handlers.rst:781
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr ""

#: library/logging.handlers.rst:787
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :"
"const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""

#: library/logging.handlers.rst:798
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""

#: library/logging.handlers.rst:807
msgid "SMTPHandler"
msgstr ""

#: library/logging.handlers.rst:809
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""

#: library/logging.handlers.rst:815
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""

#: library/logging.handlers.rst:822
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the :meth:`smtplib."
"SMTP.starttls` method.)"
msgstr ""

#: library/logging.handlers.rst:829
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr ""

#: library/logging.handlers.rst:832
msgid "The *timeout* argument was added."
msgstr ""

#: library/logging.handlers.rst:837
msgid "Formats the record and sends it to the specified addressees."
msgstr ""

#: library/logging.handlers.rst:842
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr ""

#: library/logging.handlers.rst:848
msgid "MemoryHandler"
msgstr ""

#: library/logging.handlers.rst:850
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""

#: library/logging.handlers.rst:855
msgid ""
":class:`MemoryHandler` is a subclass of the more general :class:"
"`BufferingHandler`, which is an abstract class. This buffers logging records "
"in memory. Whenever each record is added to the buffer, a check is made by "
"calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it "
"should, then :meth:`flush` is expected to do the flushing."
msgstr ""

#: library/logging.handlers.rst:864
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr ""

#: library/logging.handlers.rst:870
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call :"
"meth:`flush` to process the buffer."
msgstr ""

#: library/logging.handlers.rst:876
msgid ""
"You can override this to implement custom flushing behavior. This version "
"just zaps the buffer to empty."
msgstr ""

#: library/logging.handlers.rst:882
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr ""

#: library/logging.handlers.rst:888
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""

#: library/logging.handlers.rst:897
msgid "The *flushOnClose* parameter was added."
msgstr ""

#: library/logging.handlers.rst:903
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr ""

#: library/logging.handlers.rst:909
msgid ""
"For a :class:`MemoryHandler`, flushing means just sending the buffered "
"records to the target, if there is one. The buffer is also cleared when this "
"happens. Override if you want different behavior."
msgstr ""

#: library/logging.handlers.rst:916
msgid "Sets the target handler for this handler."
msgstr ""

#: library/logging.handlers.rst:921
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr ""

#: library/logging.handlers.rst:927
msgid "HTTPHandler"
msgstr ""

#: library/logging.handlers.rst:929
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a Web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""

#: library/logging.handlers.rst:936
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a :class:`ssl."
"SSLContext` instance to configure the SSL settings used for the HTTPS "
"connection. If *credentials* is specified, it should be a 2-tuple consisting "
"of userid and password, which will be placed in a HTTP 'Authorization' "
"header using Basic authentication. If you specify credentials, you should "
"also specify secure=True so that your userid and password are not passed in "
"cleartext across the wire."
msgstr ""

#: library/logging.handlers.rst:947
#, fuzzy
msgid "The *context* parameter was added."
msgstr "Ajout du paramètre *exit*."

#: library/logging.handlers.rst:952
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns ``record."
"__dict__``. This method can be overridden if e.g. only a subset of :class:"
"`~logging.LogRecord` is to be sent to the web server, or if more specific "
"customization of what's sent to the server is required."
msgstr ""

#: library/logging.handlers.rst:960
msgid ""
"Sends the record to the Web server as a URL-encoded dictionary. The :meth:"
"`mapLogRecord` method is used to convert the record to the dictionary to be "
"sent."
msgstr ""

#: library/logging.handlers.rst:964
msgid ""
"Since preparing a record for sending it to a Web server is not the same as a "
"generic formatting operation, using :meth:`~logging.Handler.setFormatter` to "
"specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a Web server."
msgstr ""

#: library/logging.handlers.rst:977
msgid "QueueHandler"
msgstr ""

#: library/logging.handlers.rst:981
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""

#: library/logging.handlers.rst:985
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in Web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""

#: library/logging.handlers.rst:994
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any queue-"
"like object; it's used as-is by the :meth:`enqueue` method, which needs to "
"know how to send messages to it. The queue is not *required* to have the "
"task tracking API, which means that you can use :class:`~queue.SimpleQueue` "
"instances for *queue*."
msgstr ""

#: library/logging.handlers.rst:1004
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur (e."
"g. because a bounded queue has filled up), the :meth:`~logging.Handler."
"handleError` method is called to handle the error. This can result in the "
"record silently being dropped (if :attr:`logging.raiseExceptions` is "
"``False``) or a message printed to ``sys.stderr`` (if :attr:`logging."
"raiseExceptions` is ``True``)."
msgstr ""

#: library/logging.handlers.rst:1013
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr ""

#: library/logging.handlers.rst:1016
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"and exception information, if present.  It also removes unpickleable items "
"from the record in-place."
msgstr ""

#: library/logging.handlers.rst:1020
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr ""

#: library/logging.handlers.rst:1026
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr ""

#: library/logging.handlers.rst:1035
msgid "QueueListener"
msgstr ""

#: library/logging.handlers.rst:1039
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While :class:"
"`QueueListener` is not itself a handler, it is documented here because it "
"works hand-in-hand with :class:`QueueHandler`."
msgstr ""

#: library/logging.handlers.rst:1047
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in Web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""

#: library/logging.handlers.rst:1056
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know "
"how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use :"
"class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""

#: library/logging.handlers.rst:1064
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""

#: library/logging.handlers.rst:1069
msgid "The ``respect_handler_level`` argument was added."
msgstr ""

#: library/logging.handlers.rst:1074
msgid "Dequeues a record and return it, optionally blocking."
msgstr ""

#: library/logging.handlers.rst:1076
msgid ""
"The base implementation uses ``get()``. You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""

#: library/logging.handlers.rst:1082
msgid "Prepare a record for handling."
msgstr ""

#: library/logging.handlers.rst:1084
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""

#: library/logging.handlers.rst:1090
msgid "Handle a record."
msgstr ""

#: library/logging.handlers.rst:1092
msgid ""
"This just loops through the handlers offering them the record to handle. The "
"actual object passed to the handlers is that which is returned from :meth:"
"`prepare`."
msgstr ""

#: library/logging.handlers.rst:1098
msgid "Starts the listener."
msgstr ""

#: library/logging.handlers.rst:1100
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr ""

#: library/logging.handlers.rst:1105
msgid "Stops the listener."
msgstr ""

#: library/logging.handlers.rst:1107
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that "
"if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr ""

#: library/logging.handlers.rst:1113
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""

#: library/logging.handlers.rst:1124
msgid "Module :mod:`logging`"
msgstr "Module :mod:`logging`"

#: library/logging.handlers.rst:1124
msgid "API reference for the logging module."
msgstr "Référence d'API pour le module de journalisation."

#: library/logging.handlers.rst:1126
msgid "Module :mod:`logging.config`"
msgstr "Module :mod:`logging.config`"

#: library/logging.handlers.rst:1127
msgid "Configuration API for the logging module."
msgstr "API de configuration pour le module de journalisation."
