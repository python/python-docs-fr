# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-18 15:46+0200\n"
"PO-Revision-Date: 2020-12-14 10:12+0100\n"
"Last-Translator: Antoine Wecxsteen\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.3\n"

#: library/logging.handlers.rst:2
msgid ":mod:`logging.handlers` --- Logging handlers"
msgstr ":mod:`logging.handlers` — Gestionnaires de journalisation"

#: library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**Code source :** :source:`Lib/logging/handlers.py`"

#: library/logging.handlers.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Cette page contient uniquement des informations de référence. Pour des "
"tutoriels, veuillez consulter"

#: library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutoriel basique <logging-basic-tutorial>`"

#: library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutoriel avancé <logging-advanced-tutorial>`"

#: library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`livre de recettes sur la journalisation <logging-cookbook>`"

#: library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and :class:"
"`NullHandler`) are actually defined in the :mod:`logging` module itself, but "
"have been documented here along with the other handlers."
msgstr ""
"Les gestionnaires suivants, très utiles, sont fournis dans le paquet. Notez "
"que trois des gestionnaires (:class:`StreamHandler`, :class:`FileHandler` "
"et :class:`NullHandler`) sont en réalité définis dans le module :mod:"
"`logging` lui-même, mais qu’ils sont documentés ici avec les autres "
"gestionnaires."

#: library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "Gestionnaire à flux — *StreamHandler*"

#: library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports :meth:"
"`write` and :meth:`flush` methods)."
msgstr ""
"La classe :class:`StreamHandler`, du paquet :mod:`logging`, envoie les "
"sorties de journalisation dans des flux tels que *sys.stdout*, *sys.stderr* "
"ou n’importe quel objet fichier-compatible (ou, plus précisément, tout objet "
"qui gère les méthodes :meth:`write` et :meth:`flush`)."

#: library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, *sys."
"stderr* will be used."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`StreamHandler`. Si "
"*stream* est spécifié, l’instance l’utilise pour les sorties de "
"journalisation ; autrement elle utilise *sys.stderr*."

#: library/logging.handlers.rst:50
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using :func:`traceback."
"print_exception` and appended to the stream."
msgstr ""
"Si un formateur est spécifié, il est utilisé pour formater l’enregistrement. "
"L’enregistrement est ensuite écrit dans le flux, suivi par :attr:"
"`terminator`. Si une information d’exception est présente, elle est formatée "
"en utilisant :func:`traceback.print_exception` puis ajoutée aux flux."

#: library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the :meth:"
"`close` method is inherited from :class:`~logging.Handler` and so does no "
"output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"Purge le flux en appelant sa méthode :meth:`flush`. Notez que la méthode :"
"meth:`close` est héritée de :class:`~logging.Handler` donc elle n'écrit "
"rien. Par conséquent, un appel explicite à :meth:`flush` peut parfois "
"s'avérer nécessaire."

#: library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr ""
"Définit le flux de l’instance à la valeur spécifiée, si elle est différente. "
"L’ancien flux est purgé avant que le nouveau flux ne soit établi."

#: library/logging.handlers.rst:0
msgid "Parameters"
msgstr "Paramètres"

#: library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "le flux que le gestionnaire doit utiliser."

#: library/logging.handlers.rst:0
msgid "Returns"
msgstr "Renvoie"

#: library/logging.handlers.rst:69
msgid "the old stream, if the stream was changed, or *None* if it wasn't."
msgstr "l’ancien flux, si le flux a été changé, ou *None* s’il ne l’a pas été."

#: library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr ""
"Chaine de caractères utilisée comme marqueur de fin lors de l’écriture "
"formatée d'un enregistrement dans un flux. La valeur par défaut est "
"``'\\n'``."

#: library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr ""
"Si vous ne voulez pas marquer de fin de ligne, il faut définir l’attribut "
"``terminator`` à la chaîne de caractères vide."

#: library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr ""
"Dans des versions antérieures, le marqueur de fin était codé en dur sous la "
"forme ``'\\n'``."

#: library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "Gestionnaire à fichier — *FileHandler*"

#: library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
"La classe :class:`FileHandler`, du paquet :mod:`logging`, envoie les sorties "
"de journalisation dans un fichier. Elle hérite des fonctionnalités de sortie "
"de :class:`StreamHandler`."

#: library/logging.handlers.rst:98
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file "
"is opened and used as the stream for logging. If *mode* is not specified, :"
"const:`'a'` is used.  If *encoding* is not ``None``, it is used to open the "
"file with that encoding.  If *delay* is true, then file opening is deferred "
"until the first call to :meth:`emit`. By default, the file grows "
"indefinitely. If *errors* is specified, it's used to determine how encoding "
"errors are handled."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`FileHandler`. Le fichier "
"spécifié est ouvert et utilisé comme flux pour la journalisation. Si *mode* "
"n’est pas spécifié, :const:`'a'` est utilisé. Si *encoding* n’est pas à "
"``None``, il est utilisé pour ouvrir le fichier avec cet encodage. Si "
"*delay* est ``True``, alors l’ouverture du fichier est reportée jusqu’au "
"premier appel de :meth:`emit`. Par défaut, le fichier croit indéfiniment. Si "
"*errors* est spécifié, il est utilisé pour déterminer comment sont gérées "
"les erreurs d’encodage."

#: library/logging.handlers.rst:105 library/logging.handlers.rst:190
#: library/logging.handlers.rst:338 library/logging.handlers.rst:444
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr ""
"L'argument *filename* accepte les objets :class:`~pathlib.Path` aussi bien "
"que les chaînes de caractères."

#: library/logging.handlers.rst:109 library/logging.handlers.rst:194
#: library/logging.handlers.rst:342 library/logging.handlers.rst:448
msgid "The *errors* parameter was added."
msgstr "ajout du paramètre *errors*."

#: library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "Ferme le fichier."

#: library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "Écrit l’enregistrement dans le fichier."

#: library/logging.handlers.rst:120
msgid ""
"Note that if the file was closed due to logging shutdown at exit and the "
"file mode is 'w', the record will not be emitted (see :issue:`42378`)."
msgstr ""

#: library/logging.handlers.rst:127
msgid "NullHandler"
msgstr "Gestionnaire à puits sans fond — *NullHandler*"

#: library/logging.handlers.rst:131
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
"La classe :class:`NullHandler`, située dans le paquet principal :mod:"
"`logging`, ne produit aucun formatage ni sortie. C’est essentiellement un "
"gestionnaire « fantôme » destiné aux développeurs de bibliothèques."

#: library/logging.handlers.rst:137
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr "Renvoie une nouvelle instance de la classe :class:`NullHandler`."

#: library/logging.handlers.rst:141 library/logging.handlers.rst:145
msgid "This method does nothing."
msgstr "Cette méthode ne fait rien."

#: library/logging.handlers.rst:149
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr ""
"Cette méthode renvoie ``None`` pour le verrou, étant donné qu’il n’y a aucun "
"flux d'entrée-sortie sous-jacent dont l’accès doit être sérialisé."

#: library/logging.handlers.rst:153
msgid ""
"See :ref:`library-config` for more information on how to use :class:"
"`NullHandler`."
msgstr ""
"Voir :ref:`library-config` pour plus d’information sur l'utilisation de :"
"class:`NullHandler`."

#: library/logging.handlers.rst:159
msgid "WatchedFileHandler"
msgstr "Gestionnaire à fichier avec surveillance — *WatchedFileHandler*"

#: library/logging.handlers.rst:163
msgid ""
"The :class:`WatchedFileHandler` class, located in the :mod:`logging."
"handlers` module, is a :class:`FileHandler` which watches the file it is "
"logging to. If the file changes, it is closed and reopened using the file "
"name."
msgstr ""
"La classe :class:`WatchedFileHandler`, du module :mod:`logging.handlers`, "
"est une classe :class:`FileHandler` qui surveille le fichier dans lequel "
"elle écrit. Si le fichier est modifié, il est fermé et rouvert en utilisant "
"le nom du fichier."

#: library/logging.handlers.rst:167
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"Le fichier peut être modifié par des programmes tels que *newsyslog* ou "
"*logrotate* qui assurent le roulement des fichiers de journalisation. Ce "
"gestionnaire, destiné à une utilisation sous Unix-Linux, surveille le "
"fichier pour voir s’il a changé depuis la dernière écriture (un fichier est "
"considéré comme modifié si son nœud d’index ou le périphérique auquel il est "
"rattaché a changé). Si le fichier a changé, l’ancien flux vers ce fichier "
"est fermé, et le fichier est ouvert pour établir un nouveau flux."

#: library/logging.handlers.rst:174
msgid ""
"This handler is not appropriate for use under Windows, because under Windows "
"open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"Ce gestionnaire n’est pas approprié pour une utilisation sous *Windows*, car "
"sous *Windows* les fichiers de journalisation ouverts ne peuvent être ni "
"déplacés, ni renommés — la journalisation ouvre les fichiers avec des "
"verrous exclusifs — de telle sorte qu’il n’y a pas besoin d’un tel "
"gestionnaire. En outre, *ST_INO* n’est pas géré par *Windows* ; :func:`~os."
"stat` renvoie toujours zéro pour cette valeur."

#: library/logging.handlers.rst:183
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, :const:`'a'` is used.  If *encoding* is not ``None``, it is "
"used to open the file with that encoding.  If *delay* is true, then file "
"opening is deferred until the first call to :meth:`emit`.  By default, the "
"file grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`WatchedFileHandler`. Le "
"fichier spécifié est ouvert et utilisé comme flux pour la journalisation. Si "
"*mode* n’est pas spécifié, :const:`'a'` est utilisé. Si *encoding* n’est pas "
"``None``, il est utilisé pour ouvrir le fichier avec cet encodage. Si "
"*delay* est à *true*, alors l’ouverture du fichier est reportée au premier "
"appel à :meth:`emit`. Par défaut, le fichier croit indéfiniment. Si *errors* "
"est spécifié, il est utilisé pour déterminer comment sont gérées les erreurs "
"d’encodage."

#: library/logging.handlers.rst:199
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr ""
"Vérifie si le fichier a changé. Si c’est le cas, le flux existant est purgé "
"et fermé et le fichier est rouvert, généralement avant d'effectuer "
"l’écriture de l'enregistrement dans le fichier."

#: library/logging.handlers.rst:208
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr ""
"Écrit l’enregistrement dans le fichier, mais appelle d’abord :meth:"
"`reopenIfNeeded` pour rouvrir le fichier s’il a changé."

#: library/logging.handlers.rst:214
msgid "BaseRotatingHandler"
msgstr "Base des gestionnaires à roulement — *BaseRotatingHandler*"

#: library/logging.handlers.rst:216
msgid ""
"The :class:`BaseRotatingHandler` class, located in the :mod:`logging."
"handlers` module, is the base class for the rotating file handlers, :class:"
"`RotatingFileHandler` and :class:`TimedRotatingFileHandler`. You should not "
"need to instantiate this class, but it has attributes and methods you may "
"need to override."
msgstr ""
"La classe :class:`BaseRotatingHandler`, du module :mod:`logging.handlers`, "
"est la classe de base pour les gestionnaires à roulement, :class:"
"`RotatingFileHandler` et :class:`TimedRotatingFileHandler`. Il ne faut pas "
"créer des instances de cette classe, mais surcharger ses attributs et "
"méthodes."

#: library/logging.handlers.rst:224
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr ""
"Les paramètres sont les mêmes que pour :class:`FileHandler`. Les attributs "
"sont :"

#: library/logging.handlers.rst:228
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method "
"delegates to this callable. The parameters passed to the callable are those "
"passed to :meth:`rotation_filename`."
msgstr ""
"Si cet attribut est un qu’appelable, la méthode :meth:`rotation_filename` "
"délègue sa logique à cet appelable. Les paramètres passés à l’appelable sont "
"ceux passés à :meth:`rotation_filename`."

#: library/logging.handlers.rst:232
msgid ""
"The namer function is called quite a few times during rollover, so it should "
"be as simple and as fast as possible. It should also return the same output "
"every time for a given input, otherwise the rollover behaviour may not work "
"as expected."
msgstr ""
"la fonction *namer* est appelée de nombreuses fois durant le roulement ; "
"elle doit donc être aussi simple et rapide que possible. Elle doit aussi "
"renvoyer toujours la même sortie pour une entrée donnée, autrement le "
"comportement du roulement pourrait être différent de celui attendu."

#: library/logging.handlers.rst:237
msgid ""
"It's also worth noting that care should be taken when using a namer to "
"preserve certain attributes in the filename which are used during rotation. "
"For example, :class:`RotatingFileHandler` expects to have a set of log files "
"whose names contain successive integers, so that rotation works as expected, "
"and :class:`TimedRotatingFileHandler` deletes old log files (based on the "
"``backupCount`` parameter passed to the handler's initializer) by "
"determining the oldest files to delete. For this to happen, the filenames "
"should be sortable using the date/time portion of the filename, and a namer "
"needs to respect this. (If a namer is wanted that doesn't respect this "
"scheme, it will need to be used in a subclass of :class:"
"`TimedRotatingFileHandler` which overrides the :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete` method to fit in with the "
"custom naming scheme.)"
msgstr ""

#: library/logging.handlers.rst:255
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed "
"to :meth:`rotate`."
msgstr ""
"Si cet attribut est un appelable, il se substitue à la méthode :meth:"
"`rotate`. Les paramètres passés à l’appelable sont ceux passés à :meth:"
"`rotate`."

#: library/logging.handlers.rst:263
msgid "Modify the filename of a log file when rotating."
msgstr ""
"Modifie le nom du fichier d’un fichier de journalisation lors du roulement."

#: library/logging.handlers.rst:265
msgid "This is provided so that a custom filename can be provided."
msgstr "Cette méthode sert à pouvoir produire un nom de fichier personnalisé."

#: library/logging.handlers.rst:267
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"L’implémentation par défaut appelle l’attribut *namer* du gestionnaire, si "
"c’est un appelable, lui passant le nom par défaut. Si l’attribut n’est pas "
"un appelable (le défaut est ``None``), le nom est renvoyé tel quel."

#: library/logging.handlers.rst:271
msgid "The default name for the log file."
msgstr "le nom par défaut du fichier de journalisation."

#: library/logging.handlers.rst:278
msgid "When rotating, rotate the current log."
msgstr "Lors du roulement, effectue le roulement du journal courant."

#: library/logging.handlers.rst:280
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute "
"isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"L’implémentation par défaut appelle l’attribut *rotator* du gestionnaire, si "
"c’est un appelable, lui passant les arguments *source* et *dest*. Si "
"l’attribut n’est pas un appelable (le défaut est ``None``), le nom de la "
"source est simplement renommé avec la destination."

#: library/logging.handlers.rst:285
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr ""
"le nom du fichier source. Il s’agit normalement du nom du fichier, par "
"exemple ``\"test.log\"``."

#: library/logging.handlers.rst:287
msgid ""
"The destination filename. This is normally what the source is rotated to, e."
"g. 'test.log.1'."
msgstr ""
"le nom du fichier de destination. Il s’agit normalement du nom donné à la "
"source après le roulement, par exemple ``\"test.log.1\"``."

#: library/logging.handlers.rst:292
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and :"
"class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"La raison d’être de ces attributs est de vous épargner la création d’une "
"sous-classe — vous pouvez utiliser les mêmes appels pour des instances de :"
"class:`RotatingFileHandler` et :class:`TimedRotatingFileHandler`. Si "
"l'appelable *namer* ou *rotator* lève une exception, elle est gérée de la "
"même manière que n’importe quelle exception levée lors d'un appel à :meth:"
"`emit`, c'est-à-dire par la méthode :meth:`handleError` du gestionnaire."

#: library/logging.handlers.rst:299
msgid ""
"If you need to make more significant changes to rotation processing, you can "
"override the methods."
msgstr ""
"Si vous avez besoin de faire d’importantes modifications au processus de "
"roulement, surchargez les méthodes."

#: library/logging.handlers.rst:302
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "Pour un exemple, voir :ref:`cookbook-rotator-namer`."

#: library/logging.handlers.rst:308
msgid "RotatingFileHandler"
msgstr "Gestionnaire à roulement de fichiers — *RotatingFileHandler*"

#: library/logging.handlers.rst:310
msgid ""
"The :class:`RotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files."
msgstr ""
"La classe :class:`RotatingFileHandler`, du module :mod:`logging.handlers`, "
"gère le roulement des fichiers de journalisation sur disque."

#: library/logging.handlers.rst:316
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`RotatingFileHandler`. Le "
"fichier spécifié est ouvert et utilisé comme flux de sortie pour la "
"journalisation. Si *mode* n’est pas spécifié, ``'a'`` est utilisé. Si "
"*encoding* n’est pas à ``None``, il est utilisé pour ouvrir le fichier avec "
"cet encodage. Si *delay* est à *true*, alors l’ouverture du fichier est "
"reportée au premier appel de :meth:`emit`. Par défaut, le fichier croit "
"indéfiniment. Si *errors* est spécifié, il détermine comment sont gérées les "
"erreurs d’encodage."

#: library/logging.handlers.rst:323
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to :"
"dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never "
"occurs, so you generally want to set *backupCount* to at least 1, and have a "
"non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of :file:`app."
"log`, you would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, "
"up to :file:`app.log.5`. The file being written to is always :file:`app."
"log`.  When this file is filled, it is closed and renamed to :file:`app."
"log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, etc. exist, then "
"they are renamed to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"Utilisez les valeurs *maxBytes* et *backupCount* pour autoriser le roulement "
"du fichier (:dfn:`rollover`) à une taille prédéterminée. Quand la taille "
"limite est sur le point d’être dépassée, le fichier est fermé et un nouveau "
"fichier est automatiquement ouvert pour le remplacer. Un roulement se "
"produit dès que le fichier de journalisation actuel atteint une taille "
"proche de *maxBytes* ; si *maxBytes* ou *backupCount* est à 0, le roulement "
"ne se produit jamais, donc en temps normal il convient de définir "
"*backupCount* à au moins 1, et avoir une valeur de *maxBytes* non nulle. "
"Quand *backupCount* est non nul, le système sauvegarde les anciens fichiers "
"de journalisation en ajoutant à leur nom les suffixes ``\".1\"``, ``\".2\"`` "
"et ainsi de suite. Par exemple, avec un *backupCount* de 5 et :file:`app."
"log` comme radical du fichier, on obtient :file:`app.log`, :file:`app."
"log.1`, :file:`app.log.2`, jusqu’à :file:`app.log.5`. Le fichier dans lequel "
"on écrit est toujours :file:`app.log`. Quand ce fichier est rempli, il est "
"fermé et renommé en :file:`app.log.1`, et si les fichiers :file:`app."
"log.1`, :file:`app.log.2`, etc. existent, alors ils sont renommés en :file:"
"`app.log.2`, :file:`app.log.3` etc. respectivement."

#: library/logging.handlers.rst:347 library/logging.handlers.rst:453
msgid "Does a rollover, as described above."
msgstr "Effectue un roulement, comme décrit ci-dessus."

#: library/logging.handlers.rst:352
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr ""
"Écrit l'enregistrement dans le fichier, effectuant un roulement au besoin "
"comme décrit précédemment."

#: library/logging.handlers.rst:358
msgid "TimedRotatingFileHandler"
msgstr ""
"Gestionnaire à roulement de fichiers périodique — *TimedRotatingFileHandler*"

#: library/logging.handlers.rst:360
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files at certain timed "
"intervals."
msgstr ""
"La classe :class:`TimedRotatingFileHandler` du module :mod:`logging."
"handlers` gère le roulement des fichiers de journalisation sur le disque "
"selon un intervalle de temps spécifié."

#: library/logging.handlers.rst:367
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:"
"`TimedRotatingFileHandler`. Le fichier spécifié est ouvert et utilisé comme "
"flux de sortie pour la journalisation. Au moment du roulement, elle met "
"également à jour le suffixe du nom du fichier. L'intervalle entre les "
"roulements est déterminé par les valeurs de *when* et *interval*."

#: library/logging.handlers.rst:372
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr ""
"Utilisez *when* pour spécifier le type de *interval*. Ses valeurs possibles "
"sont décrites ci-dessous. Notez qu'elles ne sont pas sensibles à la casse."

#: library/logging.handlers.rst:376
msgid "Value"
msgstr "Valeur"

#: library/logging.handlers.rst:376
msgid "Type of interval"
msgstr "Type d’intervalle"

#: library/logging.handlers.rst:376
msgid "If/how *atTime* is used"
msgstr "Rôle de *atTime*"

#: library/logging.handlers.rst:378
msgid "``'S'``"
msgstr "``'S'``"

#: library/logging.handlers.rst:378
msgid "Seconds"
msgstr "Secondes"

#: library/logging.handlers.rst:378 library/logging.handlers.rst:380
#: library/logging.handlers.rst:382 library/logging.handlers.rst:384
msgid "Ignored"
msgstr "Ignoré"

#: library/logging.handlers.rst:380
msgid "``'M'``"
msgstr "``'M'``"

#: library/logging.handlers.rst:380
msgid "Minutes"
msgstr "Minutes"

#: library/logging.handlers.rst:382
msgid "``'H'``"
msgstr "``'H'``"

#: library/logging.handlers.rst:382
msgid "Hours"
msgstr "Heures"

#: library/logging.handlers.rst:384
msgid "``'D'``"
msgstr "``'D'``"

#: library/logging.handlers.rst:384
msgid "Days"
msgstr "Jours"

#: library/logging.handlers.rst:386
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: library/logging.handlers.rst:386
msgid "Weekday (0=Monday)"
msgstr "Jour de la semaine (0 = lundi)"

#: library/logging.handlers.rst:386 library/logging.handlers.rst:389
msgid "Used to compute initial rollover time"
msgstr "Utilisé pour calculer le moment du roulement"

#: library/logging.handlers.rst:389
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: library/logging.handlers.rst:389
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr ""
"Roulement du fichier à minuit, si *atTime* n’est pas spécifié, sinon à "
"l’heure *atTime*"

#: library/logging.handlers.rst:394
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for "
"*interval* isn't used."
msgstr ""
"Pour un roulement selon les jours de la semaine, mettez la valeur *W0* pour "
"lundi, *W1* pour mardi, et ainsi de suite jusqu’à *W6* pour dimanche. Dans "
"ce cas, la valeur indiquée pour *interval* n’est pas utilisée."

#: library/logging.handlers.rst:398
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format ``%Y-%m-"
"%d_%H-%M-%S`` or a leading portion thereof, depending on the rollover "
"interval."
msgstr ""
"Le système sauvegarde les anciens fichiers de journalisation en ajoutant une "
"extension au nom du fichier. Les extensions sont basées sur la date et "
"l’heure, au format *strftime* ``%Y-%m-%d_%H-%M-%S`` ou le début de celui-ci, "
"selon l’intervalle du roulement."

#: library/logging.handlers.rst:403
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the "
"current time, is used to compute when the next rotation will occur."
msgstr ""
"Le premier calcul de la date du prochain roulement (quand le gestionnaire "
"est créé) dépend de la dernière date de modification d’un fichier de "
"journalisation existant, ou à défaut de la date actuelle."

#: library/logging.handlers.rst:407
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr ""
"Si *utc* est vrai, les temps sont UTC, sinon l'heure locale est utilisée."

#: library/logging.handlers.rst:410
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""
"Si *backupCount* est non nul, au plus *backupCount* fichiers sont "
"sauvegardés. Si des fichiers supplémentaires devaient être créés par le jeu "
"du roulement, les plus vieux seraient supprimés. La logique de suppression "
"détermine les fichiers à supprimer selon l'intervalle, donc changer cette "
"valeur peut conduire à ce que certains fichiers anciens restent sur le "
"disque."

#: library/logging.handlers.rst:415
msgid ""
"If *delay* is true, then file opening is deferred until the first call to :"
"meth:`emit`."
msgstr ""
"Si *delay* est à *true*, alors l’ouverture du fichier est reportée au "
"premier appel de :meth:`emit`."

#: library/logging.handlers.rst:418
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover "
"is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""
"Si le roulement doit se produire « à minuit » ou « à un jour fixe de la "
"semaine » et si *atTime* n'est pas ``None``, ce doit être une instance de "
"``datetime.time`` qui définit l'heure de la journée à laquelle le roulement "
"se produit. Dans ce cas, la valeur de *atTime* ne sert qu'à déterminer la "
"date du roulement *initial*, la date des roulements ultérieurs est "
"déterminée par le calcul standard de l'intervalle."

#: library/logging.handlers.rst:425
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""
"Si *errors* est définit, il définit comment traiter les erreurs d'encodage."

#: library/logging.handlers.rst:428
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once "
"a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""
"la date du premier roulement est déterminée lors de l'initialisation du "
"gestionnaire. Ce n'est que lors d'un roulement que la date du roulement "
"suivant n'est déterminée, et un roulement n'a lieu que si des entrées "
"doivent être journalisées. Gardez bien cela à l'esprit pour ne pas avoir de "
"surprises. Par exemple, un gestionnaire avec un intervalle « d'une minute » "
"ne produira pas nécessairement des fichiers avec des dates (dans le nom "
"desdits fichiers) séparées d'une minute. Si une application génère des "
"journaux plus fréquemment que toutes les minutes au cours de son exécution, "
"alors *dans ce cas* vous obtiendrez des fichiers avec des temps séparés "
"d'une minute. Si la même application ne produit une entrée de journal que "
"toutes les cinq minutes, il y aura des sauts dans les dates des fichiers "
"produits qui correspondront aux moments où rien n'a été produit (et donc où "
"aucun roulement n'a eu lieu)."

#: library/logging.handlers.rst:441
msgid "*atTime* parameter was added."
msgstr "ajout du paramètre *atTime*."

#: library/logging.handlers.rst:457
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr ""
"Écrit l'enregistrement dans le fichier, effectuant un roulement au besoin "
"comme décrit précédemment."

#: library/logging.handlers.rst:461
msgid ""
"Returns a list of filenames which should be deleted as part of rollover. "
"These are the absolute paths of the oldest backup log files written by the "
"handler."
msgstr ""

#: library/logging.handlers.rst:467
msgid "SocketHandler"
msgstr "Gestionnaire à connecteur — *SocketHandler*"

#: library/logging.handlers.rst:469
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""

#: library/logging.handlers.rst:475
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""

#: library/logging.handlers.rst:478
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""

#: library/logging.handlers.rst:484
msgid "Closes the socket."
msgstr ""

#: library/logging.handlers.rst:489
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a :class:"
"`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""

#: library/logging.handlers.rst:499
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr ""

#: library/logging.handlers.rst:506
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket (:const:"
"`socket.SOCK_STREAM`)."
msgstr ""

#: library/logging.handlers.rst:513
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details "
"of this operation are equivalent to::"
msgstr ""

#: library/logging.handlers.rst:521
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them "
"on the receiving end, or alternatively you can disable unpickling of global "
"objects on the receiving end."
msgstr ""

#: library/logging.handlers.rst:530
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for :meth:`~SocketHandler."
"makePickle`."
msgstr ""

#: library/logging.handlers.rst:534
msgid ""
"This function allows for partial sends, which can happen when the network is "
"busy."
msgstr ""

#: library/logging.handlers.rst:540
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""

#: library/logging.handlers.rst:548
msgid "This behaviour is controlled by the following handler attributes:"
msgstr ""

#: library/logging.handlers.rst:550
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr ""

#: library/logging.handlers.rst:551
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr ""

#: library/logging.handlers.rst:552
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr ""

#: library/logging.handlers.rst:554
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""

#: library/logging.handlers.rst:563
msgid "DatagramHandler"
msgstr ""

#: library/logging.handlers.rst:565
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""

#: library/logging.handlers.rst:572
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""

#: library/logging.handlers.rst:575
msgid ""
"As UDP is not a streaming protocol, there is no persistent connection "
"between an instance of this handler and *host*. For this reason, when using "
"a network socket, a DNS lookup might have to be made each time an event is "
"logged, which can introduce some latency into the system. If this affects "
"you, you can do a lookup yourself and initialize this handler using the "
"looked-up IP address rather than the hostname."
msgstr ""

#: library/logging.handlers.rst:582
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""

#: library/logging.handlers.rst:588
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a :class:`~logging."
"LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""

#: library/logging.handlers.rst:597
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""

#: library/logging.handlers.rst:603
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr ""

#: library/logging.handlers.rst:610
msgid "SysLogHandler"
msgstr ""

#: library/logging.handlers.rst:612
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""

#: library/logging.handlers.rst:618
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as "
"a string, for example '/dev/log'. In this case, a Unix domain socket is used "
"to send the message to the syslog. If *facility* is not specified, :const:"
"`LOG_USER` is used. The type of socket opened depends on the *socktype* "
"argument, which defaults to :const:`socket.SOCK_DGRAM` and thus opens a UDP "
"socket. To open a TCP socket (for use with the newer syslog daemons such as "
"rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""

#: library/logging.handlers.rst:630
msgid ""
"Note that if your server is not listening on UDP port 514, :class:"
"`SysLogHandler` may appear not to work. In that case, check what address you "
"should be using for a domain socket - it's system dependent. For example, on "
"Linux it's usually '/dev/log' but on OS/X it's '/var/run/syslog'. You'll "
"need to check your platform and use the appropriate address (you may need to "
"do this check at runtime if your application needs to run on several "
"platforms). On Windows, you pretty much have to use the UDP option."
msgstr ""

#: library/logging.handlers.rst:639
msgid ""
"On macOS 12.x (Monterey), Apple has changed the behaviour of their syslog "
"daemon - it no longer listens on a domain socket. Therefore, you cannot "
"expect :class:`SysLogHandler` to work on this system."
msgstr ""

#: library/logging.handlers.rst:643
msgid "See :gh:`91070` for more information."
msgstr ""

#: library/logging.handlers.rst:645
msgid "*socktype* was added."
msgstr ""

#: library/logging.handlers.rst:651
msgid "Closes the socket to the remote host."
msgstr ""

#: library/logging.handlers.rst:656
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr ""

#: library/logging.handlers.rst:659
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""

#: library/logging.handlers.rst:668
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set "
"to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""

#: library/logging.handlers.rst:675
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""

#: library/logging.handlers.rst:686
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr ""

#: library/logging.handlers.rst:690
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""

#: library/logging.handlers.rst:693
msgid "**Priorities**"
msgstr ""

#: library/logging.handlers.rst:696 library/logging.handlers.rst:718
msgid "Name (string)"
msgstr ""

#: library/logging.handlers.rst:696 library/logging.handlers.rst:718
msgid "Symbolic value"
msgstr ""

#: library/logging.handlers.rst:698
msgid "``alert``"
msgstr "``alert``"

#: library/logging.handlers.rst:698
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: library/logging.handlers.rst:700
msgid "``crit`` or ``critical``"
msgstr "``crit`` ou ``critical``"

#: library/logging.handlers.rst:700
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: library/logging.handlers.rst:702
msgid "``debug``"
msgstr "``debug``"

#: library/logging.handlers.rst:702
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: library/logging.handlers.rst:704
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` ou ``panic``"

#: library/logging.handlers.rst:704
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: library/logging.handlers.rst:706
msgid "``err`` or ``error``"
msgstr "``err`` ou ``error``"

#: library/logging.handlers.rst:706
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: library/logging.handlers.rst:708
msgid "``info``"
msgstr "``info``"

#: library/logging.handlers.rst:708
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: library/logging.handlers.rst:710
msgid "``notice``"
msgstr "``notice``"

#: library/logging.handlers.rst:710
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: library/logging.handlers.rst:712
msgid "``warn`` or ``warning``"
msgstr "``warn`` ou ``warning``"

#: library/logging.handlers.rst:712
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: library/logging.handlers.rst:715
msgid "**Facilities**"
msgstr ""

#: library/logging.handlers.rst:720
msgid "``auth``"
msgstr "``auth``"

#: library/logging.handlers.rst:720
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: library/logging.handlers.rst:722
msgid "``authpriv``"
msgstr "``authpriv``"

#: library/logging.handlers.rst:722
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: library/logging.handlers.rst:724
msgid "``cron``"
msgstr "``cron``"

#: library/logging.handlers.rst:724
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: library/logging.handlers.rst:726
msgid "``daemon``"
msgstr "``daemon``"

#: library/logging.handlers.rst:726
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: library/logging.handlers.rst:728
msgid "``ftp``"
msgstr "``ftp``"

#: library/logging.handlers.rst:728
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: library/logging.handlers.rst:730
msgid "``kern``"
msgstr "``kern``"

#: library/logging.handlers.rst:730
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: library/logging.handlers.rst:732
msgid "``lpr``"
msgstr "``lpr``"

#: library/logging.handlers.rst:732
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: library/logging.handlers.rst:734
msgid "``mail``"
msgstr "``mail``"

#: library/logging.handlers.rst:734
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: library/logging.handlers.rst:736
msgid "``news``"
msgstr "``news``"

#: library/logging.handlers.rst:736
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: library/logging.handlers.rst:738
msgid "``syslog``"
msgstr "``syslog``"

#: library/logging.handlers.rst:738
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: library/logging.handlers.rst:740
msgid "``user``"
msgstr "``user``"

#: library/logging.handlers.rst:740
msgid "LOG_USER"
msgstr "LOG_USER"

#: library/logging.handlers.rst:742
msgid "``uucp``"
msgstr "``uucp``"

#: library/logging.handlers.rst:742
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: library/logging.handlers.rst:744
msgid "``local0``"
msgstr "``local0``"

#: library/logging.handlers.rst:744
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: library/logging.handlers.rst:746
msgid "``local1``"
msgstr "``local1``"

#: library/logging.handlers.rst:746
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: library/logging.handlers.rst:748
msgid "``local2``"
msgstr "``local2``"

#: library/logging.handlers.rst:748
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: library/logging.handlers.rst:750
msgid "``local3``"
msgstr "``local3``"

#: library/logging.handlers.rst:750
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: library/logging.handlers.rst:752
msgid "``local4``"
msgstr "``local4``"

#: library/logging.handlers.rst:752
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: library/logging.handlers.rst:754
msgid "``local5``"
msgstr "``local5``"

#: library/logging.handlers.rst:754
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: library/logging.handlers.rst:756
msgid "``local6``"
msgstr "``local6``"

#: library/logging.handlers.rst:756
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: library/logging.handlers.rst:758
msgid "``local7``"
msgstr "``local7``"

#: library/logging.handlers.rst:758
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: library/logging.handlers.rst:763
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is "
"not suitable for your needs. The default algorithm maps ``DEBUG``, ``INFO``, "
"``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog names, and "
"all other level names to 'warning'."
msgstr ""

#: library/logging.handlers.rst:773
msgid "NTEventLogHandler"
msgstr ""

#: library/logging.handlers.rst:775
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's "
"Win32 extensions for Python installed."
msgstr ""

#: library/logging.handlers.rst:783
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname* "
"should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, ``'win32service."
"pyd'`` is used - this is installed with the Win32 extensions and contains "
"some basic placeholder message definitions. Note that use of these "
"placeholders will make your event logs big, as the entire message source is "
"held in the log. If you want slimmer logs, you have to pass in the name of "
"your own .dll or .exe which contains the message definitions you want to use "
"in the event log). The *logtype* is one of ``'Application'``, ``'System'`` "
"or ``'Security'``, and defaults to ``'Application'``."
msgstr ""

#: library/logging.handlers.rst:799
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""

#: library/logging.handlers.rst:808
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr ""

#: library/logging.handlers.rst:814
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr ""

#: library/logging.handlers.rst:820
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :"
"const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""

#: library/logging.handlers.rst:831
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""

#: library/logging.handlers.rst:840
msgid "SMTPHandler"
msgstr ""

#: library/logging.handlers.rst:842
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""

#: library/logging.handlers.rst:848
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""

#: library/logging.handlers.rst:855
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the :meth:`smtplib."
"SMTP.starttls` method.)"
msgstr ""

#: library/logging.handlers.rst:862
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr ""

#: library/logging.handlers.rst:865
msgid "The *timeout* argument was added."
msgstr ""

#: library/logging.handlers.rst:870
msgid "Formats the record and sends it to the specified addressees."
msgstr ""

#: library/logging.handlers.rst:875
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr ""

#: library/logging.handlers.rst:881
msgid "MemoryHandler"
msgstr ""

#: library/logging.handlers.rst:883
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""

#: library/logging.handlers.rst:888
msgid ""
":class:`MemoryHandler` is a subclass of the more general :class:"
"`BufferingHandler`, which is an abstract class. This buffers logging records "
"in memory. Whenever each record is added to the buffer, a check is made by "
"calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it "
"should, then :meth:`flush` is expected to do the flushing."
msgstr ""

#: library/logging.handlers.rst:897
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr ""

#: library/logging.handlers.rst:903
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call :"
"meth:`flush` to process the buffer."
msgstr ""

#: library/logging.handlers.rst:909
msgid ""
"You can override this to implement custom flushing behavior. This version "
"just zaps the buffer to empty."
msgstr ""

#: library/logging.handlers.rst:915
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr ""

#: library/logging.handlers.rst:921
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""

#: library/logging.handlers.rst:930
msgid "The *flushOnClose* parameter was added."
msgstr ""

#: library/logging.handlers.rst:936
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr ""

#: library/logging.handlers.rst:942
msgid ""
"For a :class:`MemoryHandler`, flushing means just sending the buffered "
"records to the target, if there is one. The buffer is also cleared when this "
"happens. Override if you want different behavior."
msgstr ""

#: library/logging.handlers.rst:949
msgid "Sets the target handler for this handler."
msgstr ""

#: library/logging.handlers.rst:954
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr ""

#: library/logging.handlers.rst:960
msgid "HTTPHandler"
msgstr ""

#: library/logging.handlers.rst:962
#, fuzzy
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""
"La classe :class:`TimedRotatingFileHandler`, située dans le module :mod:"
"`logging.handlers`, gère le roulement des fichiers de journalisation sur le "
"disque à un intervalle de temps spécifié."

#: library/logging.handlers.rst:969
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a :class:`ssl."
"SSLContext` instance to configure the SSL settings used for the HTTPS "
"connection. If *credentials* is specified, it should be a 2-tuple consisting "
"of userid and password, which will be placed in a HTTP 'Authorization' "
"header using Basic authentication. If you specify credentials, you should "
"also specify secure=True so that your userid and password are not passed in "
"cleartext across the wire."
msgstr ""

#: library/logging.handlers.rst:980
#, fuzzy
msgid "The *context* parameter was added."
msgstr "Ajout du paramètre *exit*."

#: library/logging.handlers.rst:985
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns ``record."
"__dict__``. This method can be overridden if e.g. only a subset of :class:"
"`~logging.LogRecord` is to be sent to the web server, or if more specific "
"customization of what's sent to the server is required."
msgstr ""

#: library/logging.handlers.rst:993
msgid ""
"Sends the record to the web server as a URL-encoded dictionary. The :meth:"
"`mapLogRecord` method is used to convert the record to the dictionary to be "
"sent."
msgstr ""

#: library/logging.handlers.rst:997
msgid ""
"Since preparing a record for sending it to a web server is not the same as a "
"generic formatting operation, using :meth:`~logging.Handler.setFormatter` to "
"specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a web server."
msgstr ""

#: library/logging.handlers.rst:1010
msgid "QueueHandler"
msgstr ""

#: library/logging.handlers.rst:1014
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""

#: library/logging.handlers.rst:1018
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""

#: library/logging.handlers.rst:1027
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any queue-"
"like object; it's used as-is by the :meth:`enqueue` method, which needs to "
"know how to send messages to it. The queue is not *required* to have the "
"task tracking API, which means that you can use :class:`~queue.SimpleQueue` "
"instances for *queue*."
msgstr ""

#: library/logging.handlers.rst:1034 library/logging.handlers.rst:1123
msgid ""
"If you are using :mod:`multiprocessing`, you should avoid using :class:"
"`~queue.SimpleQueue` and instead use :class:`multiprocessing.Queue`."
msgstr ""

#: library/logging.handlers.rst:1039
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur (e."
"g. because a bounded queue has filled up), the :meth:`~logging.Handler."
"handleError` method is called to handle the error. This can result in the "
"record silently being dropped (if :attr:`logging.raiseExceptions` is "
"``False``) or a message printed to ``sys.stderr`` (if :attr:`logging."
"raiseExceptions` is ``True``)."
msgstr ""

#: library/logging.handlers.rst:1048
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr ""

#: library/logging.handlers.rst:1051
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"exception and stack information, if present.  It also removes unpickleable "
"items from the record in-place. Specifically, it overwrites the record's :"
"attr:`msg` and :attr:`message` attributes with the merged message (obtained "
"by calling the handler's :meth:`format` method), and sets the :attr:`args`, :"
"attr:`exc_info` and :attr:`exc_text` attributes to ``None``."
msgstr ""

#: library/logging.handlers.rst:1059
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr ""

#: library/logging.handlers.rst:1063
msgid ""
"The base implementation formats the message with arguments, sets the "
"``message`` and ``msg`` attributes to the formatted message and sets the "
"``args`` and ``exc_text`` attributes to ``None`` to allow pickling and to "
"prevent further attempts at formatting. This means that a handler on the :"
"class:`QueueListener` side won't have the information to do custom "
"formatting, e.g. of exceptions. You may wish to subclass ``QueueHandler`` "
"and override this method to e.g. avoid setting ``exc_text`` to ``None``. "
"Note that the ``message`` / ``msg`` / ``args`` changes are related to "
"ensuring the record is pickleable, and you might or might not be able to "
"avoid doing that depending on whether your ``args`` are pickleable. (Note "
"that you may have to consider not only your own code but also code in any "
"libraries that you use.)"
msgstr ""

#: library/logging.handlers.rst:1079
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr ""

#: library/logging.handlers.rst:1085
msgid ""
"When created via configuration using :func:`~logging.config.dictConfig`, "
"this attribute will contain a :class:`QueueListener` instance for use with "
"this handler. Otherwise, it will be ``None``."
msgstr ""

#: library/logging.handlers.rst:1094
msgid "QueueListener"
msgstr ""

#: library/logging.handlers.rst:1098
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While :class:"
"`QueueListener` is not itself a handler, it is documented here because it "
"works hand-in-hand with :class:`QueueHandler`."
msgstr ""

#: library/logging.handlers.rst:1106
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""

#: library/logging.handlers.rst:1115
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know "
"how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use :"
"class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""

#: library/logging.handlers.rst:1126
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""

#: library/logging.handlers.rst:1131
msgid "The ``respect_handler_level`` argument was added."
msgstr ""

#: library/logging.handlers.rst:1136
msgid "Dequeues a record and return it, optionally blocking."
msgstr ""

#: library/logging.handlers.rst:1138
msgid ""
"The base implementation uses ``get()``. You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""

#: library/logging.handlers.rst:1144
msgid "Prepare a record for handling."
msgstr ""

#: library/logging.handlers.rst:1146
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""

#: library/logging.handlers.rst:1152
msgid "Handle a record."
msgstr ""

#: library/logging.handlers.rst:1154
msgid ""
"This just loops through the handlers offering them the record to handle. The "
"actual object passed to the handlers is that which is returned from :meth:"
"`prepare`."
msgstr ""

#: library/logging.handlers.rst:1160
msgid "Starts the listener."
msgstr ""

#: library/logging.handlers.rst:1162
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr ""

#: library/logging.handlers.rst:1167
msgid "Stops the listener."
msgstr ""

#: library/logging.handlers.rst:1169
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that "
"if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr ""

#: library/logging.handlers.rst:1175
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""

#: library/logging.handlers.rst:1186
msgid "Module :mod:`logging`"
msgstr "Module :mod:`logging`"

#: library/logging.handlers.rst:1186
msgid "API reference for the logging module."
msgstr "Référence d'API pour le module de journalisation."

#: library/logging.handlers.rst:1188
msgid "Module :mod:`logging.config`"
msgstr "Module :mod:`logging.config`"

#: library/logging.handlers.rst:1189
msgid "Configuration API for the logging module."
msgstr "API de configuration pour le module de journalisation."
