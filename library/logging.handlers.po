# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-31 11:33+0100\n"
"PO-Revision-Date: 2020-12-14 10:12+0100\n"
"Last-Translator: Philippe GALVAN <git.philippe.galvan@outlook.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.2\n"

#: library/logging.handlers.rst:2
msgid ":mod:`logging.handlers` --- Logging handlers"
msgstr ":mod:`logging.handlers` — Gestionnaires de journalisation"

#: library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**Code source :** :source:`Lib/logging/handlers.py`"

#: library/logging.handlers.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Cette page contient uniquement des informations de référence. Pour des "
"tutoriels, veuillez consulter"

#: library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutoriel basique <logging-basic-tutorial>`"

#: library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutoriel avancé <logging-advanced-tutorial>`"

#: library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`livre de recettes sur la journalisation <logging-cookbook>`"

#: library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and :class:"
"`NullHandler`) are actually defined in the :mod:`logging` module itself, but "
"have been documented here along with the other handlers."
msgstr ""
"Les gestionnaires suivants, très utiles, sont fournis dans le paquet. Notez "
"que trois des gestionnaires (:class:`StreamHandler`, :class:`FileHandler` "
"et :class:`NullHandler`) sont en réalité définis dans le module :mod:"
"`logging` lui-même, mais qu’ils sont documentés ici avec les autres "
"gestionnaires."

#: library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "Gestionnaire à flux — *StreamHandler*"

#: library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports :meth:"
"`write` and :meth:`flush` methods)."
msgstr ""
"La classe :class:`StreamHandler`, du paquet :mod:`logging`, envoie les "
"sorties de journalisation dans des flux tels que *sys.stdout*, *sys.stderr* "
"ou n’importe quel objet fichier-compatible (ou, plus précisément, tout objet "
"qui gère les méthodes :meth:`write` et :meth:`flush`)."

#: library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, *sys."
"stderr* will be used."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`StreamHandler`. Si "
"*stream* est spécifié, l’instance l’utilise pour les sorties de "
"journalisation ; autrement elle utilise *sys.stderr*."

#: library/logging.handlers.rst:50
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using :func:`traceback."
"print_exception` and appended to the stream."
msgstr ""
"Si un formateur est spécifié, il est utilisé pour formater l’enregistrement. "
"L’enregistrement est ensuite écrit dans le flux, suivi par :attr:"
"`terminator`. Si une information d’exception est présente, elle est formatée "
"en utilisant :func:`traceback.print_exception` puis ajoutée aux flux."

#: library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the :meth:"
"`close` method is inherited from :class:`~logging.Handler` and so does no "
"output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"Purge le flux en appelant sa méthode :meth:`flush`. Notez que la méthode :"
"meth:`close` est héritée de :class:`~logging.Handler` donc elle n'écrit "
"rien. Par conséquent, un appel explicite à :meth:`flush` peut parfois "
"s'avérer nécessaire."

#: library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr ""
"Définit le flux de l’instance à la valeur spécifiée, si elle est différente. "
"L’ancien flux est purgé avant que le nouveau flux ne soit établi."

#: library/logging.handlers.rst:0
msgid "Parameters"
msgstr "Paramètres"

#: library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "Le flux que le gestionnaire doit utiliser."

#: library/logging.handlers.rst:0
msgid "Returns"
msgstr "Renvoie"

#: library/logging.handlers.rst:69
msgid "the old stream, if the stream was changed, or *None* if it wasn't."
msgstr "l’ancien flux, si le flux a été changé, ou *None* s’il ne l’a pas été."

#: library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr ""
"Chaine de caractères utilisée comme marqueur de fin lors de l’écriture "
"formatée d'un enregistrement dans un flux. La valeur par défaut est "
"``'\\n'``."

#: library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr ""
"Si vous ne voulez pas marquer de fin de ligne, vous pouvez définir "
"l’attribut ``terminator`` du gestionnaire en tant que chaîne de caractères "
"vide."

#: library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr ""
"Dans des versions antérieures, le marqueur de fin était codé en dur sous la "
"forme ``'\\n'``."

#: library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "Gestionnaire à fichier — *FileHandler*"

#: library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
"La classe :class:`FileHandler`, du paquet :mod:`logging`, envoie les sorties "
"de journalisation dans un fichier. Elle hérite des fonctionnalités de sortie "
"de :class:`StreamHandler`."

#: library/logging.handlers.rst:98
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file "
"is opened and used as the stream for logging. If *mode* is not specified, :"
"const:`'a'` is used.  If *encoding* is not ``None``, it is used to open the "
"file with that encoding.  If *delay* is true, then file opening is deferred "
"until the first call to :meth:`emit`. By default, the file grows "
"indefinitely. If *errors* is specified, it's used to determine how encoding "
"errors are handled."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`FileHandler`. Le fichier "
"spécifié est ouvert et utilisé comme flux pour la journalisation. Si *mode* "
"n’est pas spécifié, :const:`'a'` est utilisé. Si *encoding* n’est pas à "
"``None``, il est utilisé pour ouvrir le fichier avec cet encodage. Si "
"*delay* est ``True``, alors l’ouverture du fichier est reportée jusqu’au "
"premier appel de :meth:`emit`. Par défaut, le fichier croit indéfiniment. Si "
"*errors* est spécifié, il est utilisé pour déterminer comment sont gérées "
"les erreurs d’encodage."

#: library/logging.handlers.rst:105 library/logging.handlers.rst:187
#: library/logging.handlers.rst:335 library/logging.handlers.rst:441
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr ""
"L'argument *filename* accepte les objets :class:`~pathlib.Path` aussi bien "
"que les chaînes de caractères."

#: library/logging.handlers.rst:109 library/logging.handlers.rst:191
#: library/logging.handlers.rst:339 library/logging.handlers.rst:445
msgid "The *errors* parameter was added."
msgstr "Le paramètre *errors* a été ajouté."

#: library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "Ferme le fichier."

#: library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "Écrit l’enregistrement dans le fichier."

#: library/logging.handlers.rst:124
msgid "NullHandler"
msgstr "Gestionnaire à puits sans fond — *NullHandler*"

#: library/logging.handlers.rst:128
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
"La classe :class:`NullHandler`, située dans le paquet principal :mod:"
"`logging`, ne produit aucun formatage ni sortie. C’est essentiellement un "
"gestionnaire « fantôme » destiné aux développeurs de bibliothèques."

#: library/logging.handlers.rst:134
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr "Renvoie une nouvelle instance de la classe :class:`NullHandler`."

#: library/logging.handlers.rst:138 library/logging.handlers.rst:142
msgid "This method does nothing."
msgstr "Cette méthode ne fait rien."

#: library/logging.handlers.rst:146
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr ""
"Cette méthode renvoie ``None`` pour le verrou, étant donné qu’il n’y a aucun "
"flux d'entrée-sortie sous-jacent dont l’accès doit être sérialisé."

#: library/logging.handlers.rst:150
msgid ""
"See :ref:`library-config` for more information on how to use :class:"
"`NullHandler`."
msgstr ""
"Voir :ref:`library-config` pour plus d’information sur l'utilisation de :"
"class:`NullHandler`."

#: library/logging.handlers.rst:156
msgid "WatchedFileHandler"
msgstr "Gestionnaire à fichier avec surveillance — *WatchedFileHandler*"

#: library/logging.handlers.rst:160
msgid ""
"The :class:`WatchedFileHandler` class, located in the :mod:`logging."
"handlers` module, is a :class:`FileHandler` which watches the file it is "
"logging to. If the file changes, it is closed and reopened using the file "
"name."
msgstr ""
"La classe :class:`WatchedFileHandler`, située dans le module :mod:`logging."
"handlers`, est un :class:`FileHandler` qui surveille le fichier dans lequel "
"il journalise. Si le fichier change, il est fermé et rouvert en utilisant le "
"nom du fichier."

#: library/logging.handlers.rst:164
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"Un changement du fichier peut arriver à cause de l’utilisation de programmes "
"tels que *newsyslog* ou *logrotate* qui assurent le roulement des fichiers "
"de journalisation. Ce gestionnaire, destiné à une utilisation sous Unix/"
"Linux, surveille le fichier pour voir s’il a changé depuis la dernière "
"écriture (un fichier est réputé avoir changé si son nœud d’index ou le "
"périphérique auquel il est rattaché a changé). Si le fichier a changé, "
"l’ancien flux vers ce fichier est fermé, et le fichier est ouvert pour "
"établir un nouveau flux."

#: library/logging.handlers.rst:171
msgid ""
"This handler is not appropriate for use under Windows, because under Windows "
"open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"Ce gestionnaire n’est pas approprié pour une utilisation sous *Windows*, car "
"sous *Windows* les fichiers de journalisation ouverts ne peuvent être ni "
"déplacés, ni renommés — la journalisation ouvre les fichiers avec des "
"verrous exclusifs — de telle sorte qu’il n’y a pas besoin d’un tel "
"gestionnaire. En outre, *ST_INO* n’est pas géré par *Windows* ; :func:`~os."
"stat` renvoie toujours zéro pour cette valeur."

#: library/logging.handlers.rst:180
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, :const:`'a'` is used.  If *encoding* is not ``None``, it is "
"used to open the file with that encoding.  If *delay* is true, then file "
"opening is deferred until the first call to :meth:`emit`.  By default, the "
"file grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`WatchedFileHandler`. Le "
"fichier spécifié est ouvert et utilisé comme flux pour la journalisation. Si "
"*mode* n’est pas spécifié, :const:`'a'` est utilisé. Si *encoding* n’est pas "
"``None``, il est utilisé pour ouvrir le fichier avec cet encodage. Si "
"*delay* est à *true*, alors l’ouverture du fichier est reportée jusqu’au "
"premier appel à :meth:`emit`. Par défaut, le fichier croit indéfiniment. Si "
"*errors* est spécifié, il est utilisé pour déterminer comment sont gérées "
"les erreurs d’encodage."

#: library/logging.handlers.rst:196
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr ""
"Vérifie si le fichier a changé. Si c’est le cas, le flux existant est purgé "
"et fermé et le fichier est rouvert, généralement avant d'effectuer "
"l’écriture de l'enregistrement dans le fichier."

#: library/logging.handlers.rst:205
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr ""
"Écrit l’enregistrement dans le fichier, mais appelle d’abord :meth:"
"`reopenIfNeeded` pour rouvrir le fichier s’il a changé."

#: library/logging.handlers.rst:211
msgid "BaseRotatingHandler"
msgstr "Base des gestionnaires à roulement *BaseRotatingHandler*"

#: library/logging.handlers.rst:213
msgid ""
"The :class:`BaseRotatingHandler` class, located in the :mod:`logging."
"handlers` module, is the base class for the rotating file handlers, :class:"
"`RotatingFileHandler` and :class:`TimedRotatingFileHandler`. You should not "
"need to instantiate this class, but it has attributes and methods you may "
"need to override."
msgstr ""
"La classe :class:`BaseRotatingHandler`, située dans le module :mod:`logging."
"handlers`, est la classe de base pour les gestionnaires à roulement, :class:"
"`RotatingFileHandler` et :class:`TimedRotatingFileHandler`. Vous ne devez "
"pas initialiser cette classe, mais elle a des attributs et des méthodes que "
"vous devrez peut-être surcharger."

#: library/logging.handlers.rst:221
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr ""
"Les paramètres sont les mêmes que pour :class:`FileHandler`. Les attributs "
"sont :"

#: library/logging.handlers.rst:225
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method "
"delegates to this callable. The parameters passed to the callable are those "
"passed to :meth:`rotation_filename`."
msgstr ""
"Si cet attribut est défini en tant qu’appelable, la méthode :meth:"
"`rotation_filename` se rapporte à cet appelable. Les paramètres passés à "
"l’appelable sont ceux passés à :meth:`rotation_filename`."

#: library/logging.handlers.rst:229
msgid ""
"The namer function is called quite a few times during rollover, so it should "
"be as simple and as fast as possible. It should also return the same output "
"every time for a given input, otherwise the rollover behaviour may not work "
"as expected."
msgstr ""
"La fonction *namer* est appelée pas mal de fois durant le roulement, de "
"telle sorte qu’elle doit être aussi simple et rapide que possible. Elle doit "
"aussi renvoyer toujours la même sortie pour une entrée donnée, autrement le "
"comportement du roulement pourrait être différent de celui attendu."

#: library/logging.handlers.rst:234
msgid ""
"It's also worth noting that care should be taken when using a namer to "
"preserve certain attributes in the filename which are used during rotation. "
"For example, :class:`RotatingFileHandler` expects to have a set of log files "
"whose names contain successive integers, so that rotation works as expected, "
"and :class:`TimedRotatingFileHandler` deletes old log files (based on the "
"``backupCount`` parameter passed to the handler's initializer) by "
"determining the oldest files to delete. For this to happen, the filenames "
"should be sortable using the date/time portion of the filename, and a namer "
"needs to respect this. (If a namer is wanted that doesn't respect this "
"scheme, it will need to be used in a subclass of :class:"
"`TimedRotatingFileHandler` which overrides the :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete` method to fit in with the "
"custom naming scheme.)"
msgstr ""

#: library/logging.handlers.rst:252
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed "
"to :meth:`rotate`."
msgstr ""
"Si cet attribut est défini en tant qu’appelable, cet appelable se substitue "
"à la méthode :meth:`rotate`. Les paramètres passés à l’appelable sont ceux "
"passés à :meth:`rotate`."

#: library/logging.handlers.rst:260
msgid "Modify the filename of a log file when rotating."
msgstr ""
"Modifie le nom du fichier d’un fichier de journalisation lors du roulement."

#: library/logging.handlers.rst:262
msgid "This is provided so that a custom filename can be provided."
msgstr "Cette méthode sert à pouvoir produire un nom de fichier personnalisé."

#: library/logging.handlers.rst:264
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"L’implémentation par défaut appelle l’attribut *namer* du gestionnaire, si "
"c’est un appelable, lui passant le nom par défaut. Si l’attribut n’est pas "
"un appelable (le défaut est ``None``), le nom est renvoyé tel quel."

#: library/logging.handlers.rst:268
msgid "The default name for the log file."
msgstr "Le nom par défaut du fichier de journalisation."

#: library/logging.handlers.rst:275
msgid "When rotating, rotate the current log."
msgstr "Lors du roulement, effectue le roulement du journal courant."

#: library/logging.handlers.rst:277
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute "
"isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"L’implémentation par défaut appelle l’attribut *rotator* du gestionnaire, si "
"c’est un appelable, lui passant les arguments *source* et *dest*. Si "
"l’attribut n’est pas un appelable (le défaut est ``None``), le nom de la "
"source est simplement renommé avec la destination."

#: library/logging.handlers.rst:282
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr ""
"Le nom du fichier source. Il s’agit normalement du nom du fichier, par "
"exemple ``\"test.log\"``."

#: library/logging.handlers.rst:284
msgid ""
"The destination filename. This is normally what the source is rotated to, e."
"g. 'test.log.1'."
msgstr ""
"Le nom du fichier de destination. Il s’agit normalement du nom donné à la "
"source après le roulement, par exemple ``\"test.log.1\"``."

#: library/logging.handlers.rst:289
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and :"
"class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"La raison d’être de ces attributs est de vous épargner la création d’une "
"sous-classe — vous pouvez utiliser les mêmes appels pour des instances de :"
"class:`RotatingFileHandler` et :class:`TimedRotatingFileHandler`. Si le "
"*namer* ou le *rotator* appelable lève une exception, ce sera géré de la "
"même manière que n’importe quelle exception durant un appel :meth:`emit`, "
"c'est-à-dire par la méthode :meth:`handleError` du gestionnaire."

#: library/logging.handlers.rst:296
msgid ""
"If you need to make more significant changes to rotation processing, you can "
"override the methods."
msgstr ""
"Si vous avez besoin de faire d’importantes modifications au processus de "
"roulement, surchargez les méthodes."

#: library/logging.handlers.rst:299
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "Pour un exemple, voir :ref:`cookbook-rotator-namer`."

#: library/logging.handlers.rst:305
msgid "RotatingFileHandler"
msgstr "Gestionnaire à roulement de fichiers — *RotatingFileHandler*"

#: library/logging.handlers.rst:307
msgid ""
"The :class:`RotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files."
msgstr ""
"La classe :class:`RotatingFileHandler`, située dans le module :mod:`logging."
"handlers`, gère le roulement des fichiers de journalisation sur disque."

#: library/logging.handlers.rst:313
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:`RotatingFileHandler`. Le "
"fichier spécifié est ouvert et utilisé en tant que flux de sortie pour la "
"journalisation. Si *mode* n’est pas spécifié, ``'a'`` est utilisé. Si "
"*encoding* n’est pas à ``None``, il est utilisé pour ouvrir le fichier avec "
"cet encodage. Si *delay* est à *true*, alors l’ouverture du fichier est "
"reportée au premier appel de :meth:`emit`. Par défaut, le fichier croit "
"indéfiniment. Si *errors* est spécifié, il détermine comment sont gérées les "
"erreurs d’encodage."

#: library/logging.handlers.rst:320
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to :"
"dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never "
"occurs, so you generally want to set *backupCount* to at least 1, and have a "
"non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of :file:`app."
"log`, you would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, "
"up to :file:`app.log.5`. The file being written to is always :file:`app."
"log`.  When this file is filled, it is closed and renamed to :file:`app."
"log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, etc. exist, then "
"they are renamed to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"Utilisez les valeurs *maxBytes* et *backupCount* pour autoriser le roulement "
"du fichier (:dfn:`rollover`) à une taille prédéterminée. Quand la taille "
"limite est sur le point d’être dépassée, le fichier est fermé et un nouveau "
"fichier est discrètement ouvert en tant que sortie. Un roulement se produit "
"dès que le fichier de journalisation actuel atteint presque une taille de "
"*maxBytes* ; si *maxBytes* ou *backupCount* est à 0, le roulement ne se "
"produit jamais, donc en temps normal il convient de définir *backupCount* à "
"au moins 1, et avoir une valeur de *maxBytes* non nulle. Quand *backupCount* "
"est non nul, le système sauvegarde les anciens fichiers de journalisation en "
"leur ajoutant au nom du fichier, les suffixes ``\".1\"``, ``\".2\"`` et "
"ainsi de suite. Par exemple, avec un *backupCount* de 5 et :file:`app.log` "
"comme radical du fichier, vous obtiendrez :file:`app.log`, :file:`app."
"log.1`, :file:`app.log.2`, jusqu’à :file:`app.log.5`. Le fichier dans lequel "
"on écrit est toujours :file:`app.log`. Quand ce fichier est rempli, il est "
"fermé et renommé en :file:`app.log.1`, et si les fichiers :file:`app."
"log.1`, :file:`app.log.2`, etc. existent, alors ils sont renommés "
"respectivement en :file:`app.log.2`, :file:`app.log.3` etc."

#: library/logging.handlers.rst:344 library/logging.handlers.rst:450
msgid "Does a rollover, as described above."
msgstr "Effectue un roulement, comme décrit au-dessus."

#: library/logging.handlers.rst:349
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr ""
"Écrit l'enregistrement dans le fichier, effectuant un roulement au besoin "
"comme décrit précédemment."

#: library/logging.handlers.rst:355
msgid "TimedRotatingFileHandler"
msgstr ""
"Gestionnaire à roulement de fichiers périodique — *TimedRotatingFileHandler*"

#: library/logging.handlers.rst:357
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files at certain timed "
"intervals."
msgstr ""
"La classe :class:`TimedRotatingFileHandler`, située dans le module :mod:"
"`logging.handlers`, gère le roulement des fichiers de journalisation sur le "
"disque à un intervalle de temps spécifié."

#: library/logging.handlers.rst:364
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
"Renvoie une nouvelle instance de la classe :class:"
"`TimedRotatingFileHandler`. Le fichier spécifié est ouvert et utilisé en "
"tant que flux de sortie pour la journalisation. Au moment du roulement, il "
"met également à jour le suffixe du nom du fichier. Le roulement se produit "
"sur la base combinée de *when* et *interval*."

#: library/logging.handlers.rst:369
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr ""
"Utilisez le *when* pour spécifier le type de l’*interval*. La liste des "
"valeurs possibles est ci-dessous. Notez qu’elles sont sensibles à la casse."

#: library/logging.handlers.rst:373
msgid "Value"
msgstr "Valeur"

#: library/logging.handlers.rst:373
msgid "Type of interval"
msgstr "Type d’intervalle"

#: library/logging.handlers.rst:373
msgid "If/how *atTime* is used"
msgstr "Si/comment *atTime* est utilisé"

#: library/logging.handlers.rst:375
msgid "``'S'``"
msgstr "``'S'``"

#: library/logging.handlers.rst:375
msgid "Seconds"
msgstr "Secondes"

#: library/logging.handlers.rst:375 library/logging.handlers.rst:377
#: library/logging.handlers.rst:379 library/logging.handlers.rst:381
msgid "Ignored"
msgstr "Ignoré"

#: library/logging.handlers.rst:377
msgid "``'M'``"
msgstr "``'M'``"

#: library/logging.handlers.rst:377
msgid "Minutes"
msgstr "Minutes"

#: library/logging.handlers.rst:379
msgid "``'H'``"
msgstr "``'H'``"

#: library/logging.handlers.rst:379
msgid "Hours"
msgstr "Heures"

#: library/logging.handlers.rst:381
msgid "``'D'``"
msgstr "``'D'``"

#: library/logging.handlers.rst:381
msgid "Days"
msgstr "Jours"

#: library/logging.handlers.rst:383
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: library/logging.handlers.rst:383
msgid "Weekday (0=Monday)"
msgstr "Jour de la semaine (0=lundi)"

#: library/logging.handlers.rst:383 library/logging.handlers.rst:386
msgid "Used to compute initial rollover time"
msgstr "Utilisé pour calculer le moment du roulement"

#: library/logging.handlers.rst:386
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: library/logging.handlers.rst:386
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr ""
"Roulement du fichier à minuit, si *atTime* n’est pas spécifié, sinon à "
"l’heure *atTime*"

#: library/logging.handlers.rst:391
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for "
"*interval* isn't used."
msgstr ""
"Lors de l’utilisation d’un roulement basé sur les jours de la semaine, "
"définir *W0* pour lundi, *W1* pour mardi, et ainsi de suite jusqu’à *W6* "
"pour dimanche. Dans ce cas, la valeur indiquée pour *interval* n’est pas "
"utilisée."

#: library/logging.handlers.rst:395
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format ``%Y-%m-%d_"
"%H-%M-%S`` or a leading portion thereof, depending on the rollover interval."
msgstr ""
"Le système sauvegarde les anciens fichiers de journalisation en ajoutant une "
"extension au nom du fichier. Les extensions sont basées sur la date et "
"l’heure, en utilisation le format *strftime* ``%Y-%m-%d_%H-%M-%S`` ou le "
"début de celui-ci, selon l’intervalle du roulement."

#: library/logging.handlers.rst:400
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the "
"current time, is used to compute when the next rotation will occur."
msgstr ""
"Lors du premier calcul du roulement suivant (quand le gestionnaire est "
"créé), la dernière date de modification d’un fichier de journalisation "
"existant, ou sinon la date actuelle, est utilisée pour calculer la date du "
"prochain roulement."

#: library/logging.handlers.rst:404
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr ""

#: library/logging.handlers.rst:407
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""

#: library/logging.handlers.rst:412
msgid ""
"If *delay* is true, then file opening is deferred until the first call to :"
"meth:`emit`."
msgstr ""

#: library/logging.handlers.rst:415
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover "
"is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""

#: library/logging.handlers.rst:422
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""

#: library/logging.handlers.rst:425
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once "
"a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""

#: library/logging.handlers.rst:438
msgid "*atTime* parameter was added."
msgstr ""

#: library/logging.handlers.rst:454
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr ""

#: library/logging.handlers.rst:458
msgid ""
"Returns a list of filenames which should be deleted as part of rollover. "
"These are the absolute paths of the oldest backup log files written by the "
"handler."
msgstr ""

#: library/logging.handlers.rst:464
msgid "SocketHandler"
msgstr ""

#: library/logging.handlers.rst:466
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""

#: library/logging.handlers.rst:472
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""

#: library/logging.handlers.rst:475
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""

#: library/logging.handlers.rst:481
msgid "Closes the socket."
msgstr ""

#: library/logging.handlers.rst:486
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a :class:"
"`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""

#: library/logging.handlers.rst:496
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr ""

#: library/logging.handlers.rst:503
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket (:const:"
"`socket.SOCK_STREAM`)."
msgstr ""

#: library/logging.handlers.rst:510
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details "
"of this operation are equivalent to::"
msgstr ""

#: library/logging.handlers.rst:518
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them "
"on the receiving end, or alternatively you can disable unpickling of global "
"objects on the receiving end."
msgstr ""

#: library/logging.handlers.rst:527
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for :meth:`~SocketHandler."
"makePickle`."
msgstr ""

#: library/logging.handlers.rst:531
msgid ""
"This function allows for partial sends, which can happen when the network is "
"busy."
msgstr ""

#: library/logging.handlers.rst:537
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""

#: library/logging.handlers.rst:545
msgid "This behaviour is controlled by the following handler attributes:"
msgstr ""

#: library/logging.handlers.rst:547
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr ""

#: library/logging.handlers.rst:548
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr ""

#: library/logging.handlers.rst:549
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr ""

#: library/logging.handlers.rst:551
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""

#: library/logging.handlers.rst:560
msgid "DatagramHandler"
msgstr ""

#: library/logging.handlers.rst:562
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""

#: library/logging.handlers.rst:569
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""

#: library/logging.handlers.rst:572
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""

#: library/logging.handlers.rst:578
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a :class:`~logging."
"LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""

#: library/logging.handlers.rst:587
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""

#: library/logging.handlers.rst:593
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr ""

#: library/logging.handlers.rst:600
msgid "SysLogHandler"
msgstr ""

#: library/logging.handlers.rst:602
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""

#: library/logging.handlers.rst:608
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as "
"a string, for example '/dev/log'. In this case, a Unix domain socket is used "
"to send the message to the syslog. If *facility* is not specified, :const:"
"`LOG_USER` is used. The type of socket opened depends on the *socktype* "
"argument, which defaults to :const:`socket.SOCK_DGRAM` and thus opens a UDP "
"socket. To open a TCP socket (for use with the newer syslog daemons such as "
"rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""

#: library/logging.handlers.rst:620
msgid ""
"Note that if your server is not listening on UDP port 514, :class:"
"`SysLogHandler` may appear not to work. In that case, check what address you "
"should be using for a domain socket - it's system dependent. For example, on "
"Linux it's usually '/dev/log' but on OS/X it's '/var/run/syslog'. You'll "
"need to check your platform and use the appropriate address (you may need to "
"do this check at runtime if your application needs to run on several "
"platforms). On Windows, you pretty much have to use the UDP option."
msgstr ""

#: library/logging.handlers.rst:629
msgid "*socktype* was added."
msgstr ""

#: library/logging.handlers.rst:635
msgid "Closes the socket to the remote host."
msgstr ""

#: library/logging.handlers.rst:640
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr ""

#: library/logging.handlers.rst:643
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""

#: library/logging.handlers.rst:652
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set "
"to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""

#: library/logging.handlers.rst:659
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""

#: library/logging.handlers.rst:670
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr ""

#: library/logging.handlers.rst:674
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""

#: library/logging.handlers.rst:677
msgid "**Priorities**"
msgstr ""

#: library/logging.handlers.rst:680 library/logging.handlers.rst:702
msgid "Name (string)"
msgstr ""

#: library/logging.handlers.rst:680 library/logging.handlers.rst:702
msgid "Symbolic value"
msgstr ""

#: library/logging.handlers.rst:682
msgid "``alert``"
msgstr "``alert``"

#: library/logging.handlers.rst:682
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: library/logging.handlers.rst:684
msgid "``crit`` or ``critical``"
msgstr "``crit`` ou ``critical``"

#: library/logging.handlers.rst:684
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: library/logging.handlers.rst:686
msgid "``debug``"
msgstr "``debug``"

#: library/logging.handlers.rst:686
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: library/logging.handlers.rst:688
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` ou ``panic``"

#: library/logging.handlers.rst:688
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: library/logging.handlers.rst:690
msgid "``err`` or ``error``"
msgstr "``err`` ou ``error``"

#: library/logging.handlers.rst:690
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: library/logging.handlers.rst:692
msgid "``info``"
msgstr "``info``"

#: library/logging.handlers.rst:692
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: library/logging.handlers.rst:694
msgid "``notice``"
msgstr "``notice``"

#: library/logging.handlers.rst:694
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: library/logging.handlers.rst:696
msgid "``warn`` or ``warning``"
msgstr "``warn`` ou ``warning``"

#: library/logging.handlers.rst:696
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: library/logging.handlers.rst:699
msgid "**Facilities**"
msgstr ""

#: library/logging.handlers.rst:704
msgid "``auth``"
msgstr "``auth``"

#: library/logging.handlers.rst:704
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: library/logging.handlers.rst:706
msgid "``authpriv``"
msgstr "``authpriv``"

#: library/logging.handlers.rst:706
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: library/logging.handlers.rst:708
msgid "``cron``"
msgstr "``cron``"

#: library/logging.handlers.rst:708
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: library/logging.handlers.rst:710
msgid "``daemon``"
msgstr "``daemon``"

#: library/logging.handlers.rst:710
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: library/logging.handlers.rst:712
msgid "``ftp``"
msgstr "``ftp``"

#: library/logging.handlers.rst:712
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: library/logging.handlers.rst:714
msgid "``kern``"
msgstr "``kern``"

#: library/logging.handlers.rst:714
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: library/logging.handlers.rst:716
msgid "``lpr``"
msgstr "``lpr``"

#: library/logging.handlers.rst:716
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: library/logging.handlers.rst:718
msgid "``mail``"
msgstr "``mail``"

#: library/logging.handlers.rst:718
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: library/logging.handlers.rst:720
msgid "``news``"
msgstr "``news``"

#: library/logging.handlers.rst:720
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: library/logging.handlers.rst:722
msgid "``syslog``"
msgstr "``syslog``"

#: library/logging.handlers.rst:722
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: library/logging.handlers.rst:724
msgid "``user``"
msgstr "``user``"

#: library/logging.handlers.rst:724
msgid "LOG_USER"
msgstr "LOG_USER"

#: library/logging.handlers.rst:726
msgid "``uucp``"
msgstr "``uucp``"

#: library/logging.handlers.rst:726
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: library/logging.handlers.rst:728
msgid "``local0``"
msgstr "``local0``"

#: library/logging.handlers.rst:728
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: library/logging.handlers.rst:730
msgid "``local1``"
msgstr "``local1``"

#: library/logging.handlers.rst:730
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: library/logging.handlers.rst:732
msgid "``local2``"
msgstr "``local2``"

#: library/logging.handlers.rst:732
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: library/logging.handlers.rst:734
msgid "``local3``"
msgstr "``local3``"

#: library/logging.handlers.rst:734
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: library/logging.handlers.rst:736
msgid "``local4``"
msgstr "``local4``"

#: library/logging.handlers.rst:736
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: library/logging.handlers.rst:738
msgid "``local5``"
msgstr "``local5``"

#: library/logging.handlers.rst:738
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: library/logging.handlers.rst:740
msgid "``local6``"
msgstr "``local6``"

#: library/logging.handlers.rst:740
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: library/logging.handlers.rst:742
msgid "``local7``"
msgstr "``local7``"

#: library/logging.handlers.rst:742
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: library/logging.handlers.rst:747
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is "
"not suitable for your needs. The default algorithm maps ``DEBUG``, ``INFO``, "
"``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog names, and "
"all other level names to 'warning'."
msgstr ""

#: library/logging.handlers.rst:757
msgid "NTEventLogHandler"
msgstr ""

#: library/logging.handlers.rst:759
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's "
"Win32 extensions for Python installed."
msgstr ""

#: library/logging.handlers.rst:767
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname* "
"should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, ``'win32service."
"pyd'`` is used - this is installed with the Win32 extensions and contains "
"some basic placeholder message definitions. Note that use of these "
"placeholders will make your event logs big, as the entire message source is "
"held in the log. If you want slimmer logs, you have to pass in the name of "
"your own .dll or .exe which contains the message definitions you want to use "
"in the event log). The *logtype* is one of ``'Application'``, ``'System'`` "
"or ``'Security'``, and defaults to ``'Application'``."
msgstr ""

#: library/logging.handlers.rst:783
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""

#: library/logging.handlers.rst:792
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr ""

#: library/logging.handlers.rst:798
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr ""

#: library/logging.handlers.rst:804
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :"
"const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""

#: library/logging.handlers.rst:815
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""

#: library/logging.handlers.rst:824
msgid "SMTPHandler"
msgstr ""

#: library/logging.handlers.rst:826
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""

#: library/logging.handlers.rst:832
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""

#: library/logging.handlers.rst:839
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the :meth:`smtplib."
"SMTP.starttls` method.)"
msgstr ""

#: library/logging.handlers.rst:846
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr ""

#: library/logging.handlers.rst:849
msgid "The *timeout* argument was added."
msgstr ""

#: library/logging.handlers.rst:854
msgid "Formats the record and sends it to the specified addressees."
msgstr ""

#: library/logging.handlers.rst:859
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr ""

#: library/logging.handlers.rst:865
msgid "MemoryHandler"
msgstr ""

#: library/logging.handlers.rst:867
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""

#: library/logging.handlers.rst:872
msgid ""
":class:`MemoryHandler` is a subclass of the more general :class:"
"`BufferingHandler`, which is an abstract class. This buffers logging records "
"in memory. Whenever each record is added to the buffer, a check is made by "
"calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it "
"should, then :meth:`flush` is expected to do the flushing."
msgstr ""

#: library/logging.handlers.rst:881
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr ""

#: library/logging.handlers.rst:887
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call :"
"meth:`flush` to process the buffer."
msgstr ""

#: library/logging.handlers.rst:893
msgid ""
"You can override this to implement custom flushing behavior. This version "
"just zaps the buffer to empty."
msgstr ""

#: library/logging.handlers.rst:899
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr ""

#: library/logging.handlers.rst:905
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""

#: library/logging.handlers.rst:914
msgid "The *flushOnClose* parameter was added."
msgstr ""

#: library/logging.handlers.rst:920
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr ""

#: library/logging.handlers.rst:926
msgid ""
"For a :class:`MemoryHandler`, flushing means just sending the buffered "
"records to the target, if there is one. The buffer is also cleared when this "
"happens. Override if you want different behavior."
msgstr ""

#: library/logging.handlers.rst:933
msgid "Sets the target handler for this handler."
msgstr ""

#: library/logging.handlers.rst:938
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr ""

#: library/logging.handlers.rst:944
msgid "HTTPHandler"
msgstr ""

#: library/logging.handlers.rst:946
#, fuzzy
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""
"La classe :class:`TimedRotatingFileHandler`, située dans le module :mod:"
"`logging.handlers`, gère le roulement des fichiers de journalisation sur le "
"disque à un intervalle de temps spécifié."

#: library/logging.handlers.rst:953
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a :class:`ssl."
"SSLContext` instance to configure the SSL settings used for the HTTPS "
"connection. If *credentials* is specified, it should be a 2-tuple consisting "
"of userid and password, which will be placed in a HTTP 'Authorization' "
"header using Basic authentication. If you specify credentials, you should "
"also specify secure=True so that your userid and password are not passed in "
"cleartext across the wire."
msgstr ""

#: library/logging.handlers.rst:964
#, fuzzy
msgid "The *context* parameter was added."
msgstr "Ajout du paramètre *exit*."

#: library/logging.handlers.rst:969
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns ``record."
"__dict__``. This method can be overridden if e.g. only a subset of :class:"
"`~logging.LogRecord` is to be sent to the web server, or if more specific "
"customization of what's sent to the server is required."
msgstr ""

#: library/logging.handlers.rst:977
msgid ""
"Sends the record to the web server as a URL-encoded dictionary. The :meth:"
"`mapLogRecord` method is used to convert the record to the dictionary to be "
"sent."
msgstr ""

#: library/logging.handlers.rst:981
msgid ""
"Since preparing a record for sending it to a web server is not the same as a "
"generic formatting operation, using :meth:`~logging.Handler.setFormatter` to "
"specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a web server."
msgstr ""

#: library/logging.handlers.rst:994
msgid "QueueHandler"
msgstr ""

#: library/logging.handlers.rst:998
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""

#: library/logging.handlers.rst:1002
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""

#: library/logging.handlers.rst:1011
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any queue-"
"like object; it's used as-is by the :meth:`enqueue` method, which needs to "
"know how to send messages to it. The queue is not *required* to have the "
"task tracking API, which means that you can use :class:`~queue.SimpleQueue` "
"instances for *queue*."
msgstr ""

#: library/logging.handlers.rst:1021
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur (e."
"g. because a bounded queue has filled up), the :meth:`~logging.Handler."
"handleError` method is called to handle the error. This can result in the "
"record silently being dropped (if :attr:`logging.raiseExceptions` is "
"``False``) or a message printed to ``sys.stderr`` (if :attr:`logging."
"raiseExceptions` is ``True``)."
msgstr ""

#: library/logging.handlers.rst:1030
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr ""

#: library/logging.handlers.rst:1033
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"and exception information, if present.  It also removes unpickleable items "
"from the record in-place."
msgstr ""

#: library/logging.handlers.rst:1037
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr ""

#: library/logging.handlers.rst:1043
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr ""

#: library/logging.handlers.rst:1052
msgid "QueueListener"
msgstr ""

#: library/logging.handlers.rst:1056
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While :class:"
"`QueueListener` is not itself a handler, it is documented here because it "
"works hand-in-hand with :class:`QueueHandler`."
msgstr ""

#: library/logging.handlers.rst:1064
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""

#: library/logging.handlers.rst:1073
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know "
"how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use :"
"class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""

#: library/logging.handlers.rst:1081
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""

#: library/logging.handlers.rst:1086
msgid "The ``respect_handler_level`` argument was added."
msgstr ""

#: library/logging.handlers.rst:1091
msgid "Dequeues a record and return it, optionally blocking."
msgstr ""

#: library/logging.handlers.rst:1093
msgid ""
"The base implementation uses ``get()``. You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""

#: library/logging.handlers.rst:1099
msgid "Prepare a record for handling."
msgstr ""

#: library/logging.handlers.rst:1101
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""

#: library/logging.handlers.rst:1107
msgid "Handle a record."
msgstr ""

#: library/logging.handlers.rst:1109
msgid ""
"This just loops through the handlers offering them the record to handle. The "
"actual object passed to the handlers is that which is returned from :meth:"
"`prepare`."
msgstr ""

#: library/logging.handlers.rst:1115
msgid "Starts the listener."
msgstr ""

#: library/logging.handlers.rst:1117
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr ""

#: library/logging.handlers.rst:1122
msgid "Stops the listener."
msgstr ""

#: library/logging.handlers.rst:1124
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that "
"if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr ""

#: library/logging.handlers.rst:1130
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""

#: library/logging.handlers.rst:1141
msgid "Module :mod:`logging`"
msgstr "Module :mod:`logging`"

#: library/logging.handlers.rst:1141
msgid "API reference for the logging module."
msgstr "Référence d'API pour le module de journalisation."

#: library/logging.handlers.rst:1143
msgid "Module :mod:`logging.config`"
msgstr "Module :mod:`logging.config`"

#: library/logging.handlers.rst:1144
msgid "Configuration API for the logging module."
msgstr "API de configuration pour le module de journalisation."
