# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-01 00:16+0100\n"
"PO-Revision-Date: 2024-01-18 22:43+0100\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: library/email.parser.rst:2
#, fuzzy
msgid ":mod:`!email.parser`: Parsing email messages"
msgstr ":mod:`email.parser` : analyser des e-mails"

#: library/email.parser.rst:7
msgid "**Source code:** :source:`Lib/email/parser.py`"
msgstr "**Code source :** :source:`Lib/email/parser.py`"

#: library/email.parser.rst:11
msgid ""
"Message object structures can be created in one of two ways: they can be "
"created from whole cloth by creating an :class:`~email.message.EmailMessage` "
"object, adding headers using the dictionary interface, and adding payload(s) "
"using :meth:`~email.message.EmailMessage.set_content` and related methods, "
"or they can be created by parsing a serialized representation of the email "
"message."
msgstr ""
"Les instances de messages peuvent être créées de deux façons : elles peuvent "
"être créées de toutes pièces en créant un objet :class:`~email.message."
"message.EmailMessage`, en ajoutant des en-têtes en utilisant l'interface de "
"dictionnaire, et en ajoutant un ou plusieurs corps de message en utilisant :"
"meth:`~email.message.message.EmailMessage.set_content` et les méthodes "
"associées, ou elles peuvent être créées en analysant une représentation "
"sérialisée de l'e-mail."

#: library/email.parser.rst:18
msgid ""
"The :mod:`email` package provides a standard parser that understands most "
"email document structures, including MIME documents.  You can pass the "
"parser a bytes, string or file object, and the parser will return to you the "
"root :class:`~email.message.EmailMessage` instance of the object structure.  "
"For simple, non-MIME messages the payload of this root object will likely be "
"a string containing the text of the message.  For MIME messages, the root "
"object will return ``True`` from its :meth:`~email.message.EmailMessage."
"is_multipart` method, and the subparts can be accessed via the payload "
"manipulation methods, such as :meth:`~email.message.EmailMessage.get_body`, :"
"meth:`~email.message.EmailMessage.iter_parts`, and :meth:`~email.message."
"EmailMessage.walk`."
msgstr ""
"Le paquet :mod:`email` fournit un analyseur standard qui comprend la plupart "
"des structures de documents de courrier électronique, y compris les "
"documents MIME. Vous pouvez passer à l'analyseur un objet *bytes*, chaîne ou "
"fichier, et l'analyseur vous renverra l'instance racine :class:`~email."
"message.EmailMessage` de la structure de l'objet. Pour les messages simples "
"non MIME, la charge utile de cet objet racine sera probablement une chaîne "
"contenant le texte du message. Pour les messages MIME, la méthode :meth:"
"`~email.message.EmailMessage.is_multipart` de l'objet racine renvoie "
"``True``, et les sous-parties sont accessibles via les méthodes de "
"manipulation de la charge utile, telles que :meth:`~ email.message."
"EmailMessage.get_body`, :meth:`~email.message.EmailMessage.iter_parts` et :"
"meth:`~email.message.EmailMessage.walk`."

#: library/email.parser.rst:30
msgid ""
"There are actually two parser interfaces available for use, the :class:"
"`Parser` API and the incremental :class:`FeedParser` API.  The :class:"
"`Parser` API is most useful if you have the entire text of the message in "
"memory, or if the entire message lives in a file on the file system.  :class:"
"`FeedParser` is more appropriate when you are reading the message from a "
"stream which might block waiting for more input (such as reading an email "
"message from a socket).  The :class:`FeedParser` can consume and parse the "
"message incrementally, and only returns the root object when you close the "
"parser."
msgstr ""
"Il existe en fait deux interfaces d'analyseur disponibles, l'API :class:"
"`Parser` et l'API incrémentale :class:`FeedParser`. L'API :class:`Parser` "
"est plus utile si vous avez le texte entier du message en mémoire ou si le "
"message entier réside dans un fichier sur le système de fichiers. :class:"
"`FeedParser` est plus appropriée lorsque vous lisez le message à partir d'un "
"flux qui peut bloquer en attente d'une entrée supplémentaire (comme la "
"lecture d'un message électronique à partir d'un connecteur réseau). :class:"
"`FeedParser` peut consommer et analyser le message de manière incrémentielle "
"et ne renvoie l'objet racine que lorsque vous fermez l'analyseur."

#: library/email.parser.rst:39
#, fuzzy
msgid ""
"Note that the parser can be extended in limited ways, and of course you can "
"implement your own parser completely from scratch.  All of the logic that "
"connects the :mod:`email` package's bundled parser and the :class:`~email."
"message.EmailMessage` class is embodied in the :class:`~email.policy.Policy` "
"class, so a custom parser can create message object trees any way it finds "
"necessary by implementing custom versions of the appropriate :class:`!"
"Policy` methods."
msgstr ""
"Notez que l'analyseur peut être étendu de manière limitée et, bien sûr, vous "
"pouvez implémenter votre propre analyseur complètement à partir de zéro. "
"Toute la logique qui relie l'analyseur intégré au paquet :mod:`email` et la "
"classe :class:`~email.message.EmailMessage` est incarnée dans la classe :mod:"
"`policy`, de sorte qu'un analyseur personnalisé peut créer des arborescences "
"d'objet message comme il le juge nécessaire en implémentant des versions "
"personnalisées des méthodes :mod:`policy` appropriées."

#: library/email.parser.rst:49
msgid "FeedParser API"
msgstr "API *FeedParser*"

#: library/email.parser.rst:51
msgid ""
"The :class:`BytesFeedParser`, imported from the :mod:`email.feedparser` "
"module, provides an API that is conducive to incremental parsing of email "
"messages, such as would be necessary when reading the text of an email "
"message from a source that can block (such as a socket).  The :class:"
"`BytesFeedParser` can of course be used to parse an email message fully "
"contained in a :term:`bytes-like object`, string, or file, but the :class:"
"`BytesParser` API may be more convenient for such use cases.  The semantics "
"and results of the two parser APIs are identical."
msgstr ""
":class:`BytesFeedParser`, importée du module :mod:`email.feedparser`, "
"fournit une API propice à l'analyse incrémentielle des messages "
"électroniques, adaptée à la lecture du texte d'un message électronique à "
"partir d'une source qui peut bloquer (comme un connecteur). :class:"
"`BytesFeedParser` peut bien sûr être utilisée pour analyser un message "
"électronique entièrement contenu dans un :term:`objet octets-compatible "
"<bytes-like object>`, une chaîne ou un fichier, mais l'API :class:"
"`BytesParser` peut être plus pratique dans ces utilisations. La sémantique "
"et les résultats des deux API d'analyseurs sont identiques."

#: library/email.parser.rst:60
msgid ""
"The :class:`BytesFeedParser`'s API is simple; you create an instance, feed "
"it a bunch of bytes until there's no more to feed it, then close the parser "
"to retrieve the root message object.  The :class:`BytesFeedParser` is "
"extremely accurate when parsing standards-compliant messages, and it does a "
"very good job of parsing non-compliant messages, providing information about "
"how a message was deemed broken.  It will populate a message object's :attr:"
"`~email.message.EmailMessage.defects` attribute with a list of any problems "
"it found in a message.  See the :mod:`email.errors` module for the list of "
"defects that it can find."
msgstr ""
"L'API de :class:`BytesFeedParser` est simple ; vous créez une instance, "
"l'alimentez d'une suite d'octets jusqu'à ce qu'il n'y en ait plus pour "
"l'alimenter, puis fermez l'analyseur pour récupérer l'objet message racine. :"
"class:`BytesFeedParser` est extrêmement précise lors de l'analyse des "
"messages conformes aux normes, et elle fait un très bon travail d'analyse "
"des messages non conformes, fournissant des informations sur ce qu'elle "
"considère comme non approprié dans un message. Elle remplit l'attribut :attr:"
"`~email.message.EmailMessage.defects` d'un objet message avec une liste de "
"tous les problèmes trouvés dans un message. Voir le module :mod:`email."
"errors` pour la liste des défauts qu'elle peut trouver."

#: library/email.parser.rst:70
msgid "Here is the API for the :class:`BytesFeedParser`:"
msgstr "Voici l’API de :class:`BytesFeedParser` :"

#: library/email.parser.rst:75
msgid ""
"Create a :class:`BytesFeedParser` instance.  Optional *_factory* is a no-"
"argument callable; if not specified use the :attr:`~email.policy.Policy."
"message_factory` from the *policy*.  Call *_factory* whenever a new message "
"object is needed."
msgstr ""
"Crée une instance :class:`BytesFeedParser`. *_factory* est un appelable "
"facultatif sans argument ; s'il n'est pas spécifié, elle utilise la :attr:"
"`~email.policy.Policy.message_factory` de la *policy*. Elle appelle "
"*_factory* chaque fois qu'un nouvel objet de message est nécessaire."

#: library/email.parser.rst:80
msgid ""
"If *policy* is specified use the rules it specifies to update the "
"representation of the message.  If *policy* is not set, use the :class:"
"`compat32 <email.policy.Compat32>` policy, which maintains backward "
"compatibility with the Python 3.2 version of the email package and provides :"
"class:`~email.message.Message` as the default factory.  All other policies "
"provide :class:`~email.message.EmailMessage` as the default *_factory*. For "
"more information on what else *policy* controls, see the :mod:`~email."
"policy` documentation."
msgstr ""
"Si *policy* est spécifiée, elle utilise les règles spécifiées pour mettre à "
"jour la représentation du message. Si *policy* n'est pas définie, elle "
"utilise la stratégie :class:`compat32 <email.policy.Compat32>`, qui "
"maintient la rétrocompatibilité avec la version Python 3.2 du paquet de "
"messagerie et fournit :class:`~email.message.Message` comme usine par "
"défaut. Toutes les autres stratégies fournissent :class:`~email.message."
"EmailMessage` comme *_factory* par défaut. Pour plus d'informations sur ce "
"que *policy* régit, consultez la documentation :mod:`~email.policy`."

#: library/email.parser.rst:145
msgid ""
"Note: **The policy keyword should always be specified**; The default will "
"change to :data:`email.policy.default` in a future version of Python."
msgstr ""
"Remarque : **Le paramètre nommé « policy » doit toujours être spécifié** ; "
"La valeur par défaut deviendra :data:`email.policy.default` dans une future "
"version de Python."

# suit un :
#: library/email.parser.rst:122
msgid "Added the *policy* keyword."
msgstr "ajout du paramètre nommé *policy*."

#: library/email.parser.rst:95
msgid "*_factory* defaults to the policy ``message_factory``."
msgstr "*_factory* utilise par défaut la politique ``message_factory``."

#: library/email.parser.rst:100
msgid ""
"Feed the parser some more data.  *data* should be a :term:`bytes-like "
"object` containing one or more lines.  The lines can be partial and the "
"parser will stitch such partial lines together properly.  The lines can have "
"any of the three common line endings: carriage return, newline, or carriage "
"return and newline (they can even be mixed)."
msgstr ""
"Alimente l'analyseur avec plus de données. *data* doit être un :term:`objet "
"octets-compatible <bytes-like object>` contenant une ou plusieurs lignes. "
"Les lignes peuvent être partielles et l'analyseur assemble correctement ces "
"lignes partielles. Les lignes peuvent avoir l'une des trois fins de ligne "
"courantes : retour chariot, nouvelle ligne ou retour chariot et nouvelle "
"ligne (elles peuvent même être mélangées)."

#: library/email.parser.rst:109
msgid ""
"Complete the parsing of all previously fed data and return the root message "
"object.  It is undefined what happens if :meth:`~feed` is called after this "
"method has been called."
msgstr ""
"Termine l'analyse de toutes les données précédemment alimentées et renvoie "
"l'objet message racine. Ce qui se passe si :meth:`~feed` est appelée après "
"l'appel de cette méthode n'est pas défini."

#: library/email.parser.rst:116
msgid ""
"Works like :class:`BytesFeedParser` except that the input to the :meth:"
"`~BytesFeedParser.feed` method must be a string.  This is of limited "
"utility, since the only way for such a message to be valid is for it to "
"contain only ASCII text or, if :attr:`~email.policy.Policy.utf8` is "
"``True``, no binary attachments."
msgstr ""
"Fonctionne comme :class:`BytesFeedParser` sauf que l'entrée de la méthode :"
"meth:`~BytesFeedParser.feed` doit être une chaîne. Ceci est d'une utilité "
"limitée, car la seule façon pour qu'un tel message soit valide est qu'il ne "
"contienne que du texte ASCII ou, si :attr:`~email.policy.Policy.utf8` vaut "
"``True``, aucun binaire en pièce jointe."

#: library/email.parser.rst:126
msgid "Parser API"
msgstr "API de *Parser*"

#: library/email.parser.rst:128
msgid ""
"The :class:`BytesParser` class, imported from the :mod:`email.parser` "
"module, provides an API that can be used to parse a message when the "
"complete contents of the message are available in a :term:`bytes-like "
"object` or file.  The :mod:`email.parser` module also provides :class:"
"`Parser` for parsing strings, and header-only parsers, :class:"
"`BytesHeaderParser` and :class:`HeaderParser`, which can be used if you're "
"only interested in the headers of the message.  :class:`BytesHeaderParser` "
"and :class:`HeaderParser` can be much faster in these situations, since they "
"do not attempt to parse the message body, instead setting the payload to the "
"raw body."
msgstr ""
"La classe :class:`BytesParser`, importée du module :mod:`email.parser`, "
"fournit une API qui peut être utilisée pour analyser un message lorsque le "
"contenu complet du message est disponible dans un :term:`objet octets-"
"compatible <bytes-like object>` ou un fichier. Le module :mod:`email.parser` "
"fournit également :class:`Parser` pour l'analyse des chaînes et des "
"analyseurs d'en-tête uniquement, :class:`BytesHeaderParser` et :class:"
"`HeaderParser`, qui peuvent être utilisés si vous ne vous intéressez qu'aux "
"en-têtes du message. :class:`BytesHeaderParser` et :class:`HeaderParser` "
"peuvent être beaucoup plus rapides dans ces situations, car ils n'essaient "
"pas d'analyser le corps du message."

#: library/email.parser.rst:141
msgid ""
"Create a :class:`BytesParser` instance.  The *_class* and *policy* arguments "
"have the same meaning and semantics as the *_factory* and *policy* arguments "
"of :class:`BytesFeedParser`."
msgstr ""
"Crée une instance :class:`BytesParser`. Les arguments *_class* et *policy* "
"ont la même signification et la même sémantique que les arguments *_factory* "
"et *policy* de :class:`BytesFeedParser`."

#: library/email.parser.rst:148
msgid ""
"Removed the *strict* argument that was deprecated in 2.4.  Added the "
"*policy* keyword."
msgstr ""
"suppression de l'argument *strict* qui était obsolète dans 2.4. Ajout du "
"paramètre nommé *policy*."

#: library/email.parser.rst:200 library/email.parser.rst:280
msgid "*_class* defaults to the policy ``message_factory``."
msgstr "*_class* utilise par défaut la politique ``message_factory``."

#: library/email.parser.rst:156
msgid ""
"Read all the data from the binary file-like object *fp*, parse the resulting "
"bytes, and return the message object.  *fp* must support both the :meth:`~io."
"IOBase.readline` and the :meth:`~io.IOBase.read` methods."
msgstr ""
"Lit toutes les données de l'objet de type fichier binaire *fp*, analyse les "
"octets résultants et renvoie l'objet message. *fp* doit prendre en charge "
"les méthodes :meth:`~io.IOBase.readline` et :meth:`~io.IOBase.read`."

#: library/email.parser.rst:161
msgid ""
"The bytes contained in *fp* must be formatted as a block of :rfc:`5322` (or, "
"if :attr:`~email.policy.Policy.utf8` is ``True``, :rfc:`6532`) style headers "
"and header continuation lines, optionally preceded by an envelope header.  "
"The header block is terminated either by the end of the data or by a blank "
"line.  Following the header block is the body of the message (which may "
"contain MIME-encoded subparts, including subparts with a :mailheader:"
"`Content-Transfer-Encoding` of ``8bit``)."
msgstr ""
"Les octets contenus dans *fp* doivent être formatés comme un bloc d'en-têtes "
"de style conforme à la :rfc:`5322` (ou, si :attr:`~email.policy.Policy.utf8` "
"est ``True``, à la :rfc:`6532`), éventuellement précédés d'un en-tête "
"d'enveloppe. Le bloc d'en-têtes se termine soit par la fin des données, soit "
"par une ligne blanche. Après le bloc d'en-têtes se trouve le corps du "
"message (qui peut contenir des sous-parties codées MIME, y compris des sous-"
"parties avec un :mailheader:`Content-Transfer-Encoding` de ``8bit``)."

#: library/email.parser.rst:169
msgid ""
"Optional *headersonly* is a flag specifying whether to stop parsing after "
"reading the headers or not.  The default is ``False``, meaning it parses the "
"entire contents of the file."
msgstr ""
"*headersonly* est un indicateur facultatif spécifiant s'il faut arrêter "
"l'analyse après avoir lu les en-têtes ou non. La valeur par défaut est "
"``False``, ce qui signifie qu'il analyse tout le contenu du fichier."

#: library/email.parser.rst:176
msgid ""
"Similar to the :meth:`parse` method, except it takes a :term:`bytes-like "
"object` instead of a file-like object.  Calling this method on a :term:"
"`bytes-like object` is equivalent to wrapping *bytes* in a :class:`~io."
"BytesIO` instance first and calling :meth:`parse`."
msgstr ""
"Semblable à la méthode :meth:`parse`, sauf qu'elle prend un :term:`objet "
"octets-compatible <bytes-like object>` au lieu d'un objet de type fichier. "
"Appeler cette méthode sur un :term:`objet octets-compatible <bytes-like "
"object>` équivaut à envelopper *bytes* dans une instance :class:`~io."
"BytesIO` d'abord et à appeler :meth:`parse`."

#: library/email.parser.rst:221
msgid "Optional *headersonly* is as with the :meth:`parse` method."
msgstr ""
"L'utilisation de l'option *headersonly* est identique à son utilisation dans "
"la méthode :meth:`parse`."

#: library/email.parser.rst:188
msgid ""
"Exactly like :class:`BytesParser`, except that *headersonly* defaults to "
"``True``."
msgstr ""
"Exactement comme :class:`BytesParser`, sauf que *headersonly* par défaut est "
"``True``."

#: library/email.parser.rst:196
msgid ""
"This class is parallel to :class:`BytesParser`, but handles string input."
msgstr ""
"Cette classe est semblable à :class:`BytesParser`, mais elle accepte une "
"chaîne en entrée."

#: library/email.parser.rst:245 library/email.parser.rst:268
#: library/email.parser.rst:278
msgid "Removed the *strict* argument.  Added the *policy* keyword."
msgstr ""
"suppression de l'argument *strict*. Ajout de l'argument nommé *policy*."

#: library/email.parser.rst:205
msgid ""
"Read all the data from the text-mode file-like object *fp*, parse the "
"resulting text, and return the root message object.  *fp* must support both "
"the :meth:`~io.TextIOBase.readline` and the :meth:`~io.TextIOBase.read` "
"methods on file-like objects."
msgstr ""
"Lit toutes les données de l'objet de type fichier en mode texte *fp*, "
"analyse le texte résultant et renvoie l'objet message racine. *fp* doit "
"prendre en charge les méthodes :meth:`~io.TextIOBase.readline` et :meth:`~io."
"TextIOBase.read` sur les objets de type fichier."

#: library/email.parser.rst:210
msgid ""
"Other than the text mode requirement, this method operates like :meth:"
"`BytesParser.parse`."
msgstr ""
"Outre l'exigence du mode texte, cette méthode fonctionne comme :meth:"
"`BytesParser.parse`."

#: library/email.parser.rst:216
msgid ""
"Similar to the :meth:`parse` method, except it takes a string object instead "
"of a file-like object.  Calling this method on a string is equivalent to "
"wrapping *text* in a :class:`~io.StringIO` instance first and calling :meth:"
"`parse`."
msgstr ""
"Similaire à la méthode :meth:`parse`, sauf qu'elle prend un objet chaîne au "
"lieu d'un objet de type fichier. Appeler cette méthode sur une chaîne "
"équivaut à envelopper *text* dans une instance :class:`~io.StringIO` d'abord "
"et à appeler :meth:`parse`."

#: library/email.parser.rst:226
msgid ""
"Exactly like :class:`Parser`, except that *headersonly* defaults to ``True``."
msgstr ""
"Exactement comme :class:`Parser`, sauf que *headersonly* par défaut est "
"``True``."

#: library/email.parser.rst:230
msgid ""
"Since creating a message object structure from a string or a file object is "
"such a common task, four functions are provided as a convenience.  They are "
"available in the top-level :mod:`email` package namespace."
msgstr ""
"Étant donné que la création d'une structure d'objet message à partir d'une "
"chaîne ou d'un objet fichier est une tâche très courante, quatre fonctions "
"sont fournies par commodité. Elles sont disponibles dans l'espace de noms de "
"paquet de niveau supérieur :mod:`email`."

#: library/email.parser.rst:239
msgid ""
"Return a message object structure from a :term:`bytes-like object`.  This is "
"equivalent to ``BytesParser().parsebytes(s)``.  Optional *_class* and "
"*policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
"Renvoie une structure d'objet message à partir d'un :term:`objet octets-"
"compatible <bytes-like object>`. C'est équivalent à ``BytesParser()."
"parsebytes(s)``. *_class* et *policy* (facultatifs) sont interprétés comme "
"pour le constructeur de classe :class:`~email.parser.BytesParser`."

#: library/email.parser.rst:252
msgid ""
"Return a message object structure tree from an open binary :term:`file "
"object`.  This is equivalent to ``BytesParser().parse(fp)``.  *_class* and "
"*policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
"Renvoie une arborescence d'objets message à partir d'un :term:`objet fichier "
"<file object>` binaire ouvert. C'est équivalent à ``BytesParser()."
"parse(fp)``. *_class* et *policy* sont interprétés comme pour le "
"constructeur de classe :class:`~email.parser.BytesParser`."

#: library/email.parser.rst:264
msgid ""
"Return a message object structure from a string.  This is equivalent to "
"``Parser().parsestr(s)``.  *_class* and *policy* are interpreted as with "
"the :class:`~email.parser.Parser` class constructor."
msgstr ""
"Renvoie une structure d'objet message à partir d'une chaîne. C'est "
"équivalent à ``Parser().parsestr(s)``. *_class* et *policy* sont interprétés "
"comme avec le constructeur de classe :class:`~email.parser.Parser`."

#: library/email.parser.rst:274
msgid ""
"Return a message object structure tree from an open :term:`file object`. "
"This is equivalent to ``Parser().parse(fp)``.  *_class* and *policy* are "
"interpreted as with the :class:`~email.parser.Parser` class constructor."
msgstr ""
"Renvoie une arborescence de structures d'objets messages à partir d'un :term:"
"`objet fichier <file object>` ouvert. C'est équivalent à ``Parser()."
"parse(fp)``. *_class* et *policy* sont interprétés comme avec le "
"constructeur de classe :class:`~email.parser.Parser`."

#: library/email.parser.rst:283
msgid ""
"Here's an example of how you might use :func:`message_from_bytes` at an "
"interactive Python prompt::"
msgstr ""
"Voici un exemple d'utilisation :func:`message_from_bytes` dans une invite "
"Python interactive ::"

#: library/email.parser.rst:291
msgid "Additional notes"
msgstr "Notes complémentaires"

#: library/email.parser.rst:293
msgid "Here are some notes on the parsing semantics:"
msgstr "Voici des remarques sur la sémantique d'analyse :"

#: library/email.parser.rst:295
msgid ""
"Most non-\\ :mimetype:`multipart` type messages are parsed as a single "
"message object with a string payload.  These objects will return ``False`` "
"for :meth:`~email.message.EmailMessage.is_multipart`, and :meth:`~email."
"message.EmailMessage.iter_parts` will yield an empty list."
msgstr ""
"La plupart des messages de type non-\\ :mimetype:`multipart` sont analysés "
"comme un seul objet de message avec une charge utile de type chaîne. Ces "
"objets renvoient ``False`` pour :meth:`~email.message.EmailMessage."
"is_multipart` et :meth:`~email.message.EmailMessage.iter_parts` donne une "
"liste vide."

#: library/email.parser.rst:300
msgid ""
"All :mimetype:`multipart` type messages will be parsed as a container "
"message object with a list of sub-message objects for their payload.  The "
"outer container message will return ``True`` for :meth:`~email.message."
"EmailMessage.is_multipart`, and :meth:`~email.message.EmailMessage."
"iter_parts` will yield a list of subparts."
msgstr ""
"Tous les messages de type :mimetype:`multipart` sont analysés comme un objet "
"de message conteneur avec une liste d'objets de sous-messages pour leur "
"charge utile. Le message du conteneur externe renvoie ``True`` pour :meth:"
"`~email.message.EmailMessage.is_multipart` et :meth:`~email.message."
"EmailMessage.iter_parts` donne une liste de sous-parties."

#: library/email.parser.rst:306
msgid ""
"Most messages with a content type of :mimetype:`message/\\*` (such as :"
"mimetype:`message/delivery-status` and :mimetype:`message/rfc822`) will also "
"be parsed as container object containing a list payload of length 1.  Their :"
"meth:`~email.message.EmailMessage.is_multipart` method will return ``True``. "
"The single element yielded by :meth:`~email.message.EmailMessage.iter_parts` "
"will be a sub-message object."
msgstr ""
"La plupart des messages avec un type de contenu de :mimetype:`message/\\*` "
"(tels que :mimetype:`message/delivery-status` et :mimetype:`message/rfc822`) "
"sont également analysés en tant qu'objet conteneur contenant une charge "
"utile de type « liste de longueur 1 ». Leur méthode :meth:`~email.message."
"EmailMessage.is_multipart` renvoie ``True``. L'élément unique généré par :"
"meth:`~email.message.EmailMessage.iter_parts` est un objet sous-message."

#: library/email.parser.rst:313
msgid ""
"Some non-standards-compliant messages may not be internally consistent about "
"their :mimetype:`multipart`\\ -edness.  Such messages may have a :mailheader:"
"`Content-Type` header of type :mimetype:`multipart`, but their :meth:`~email."
"message.EmailMessage.is_multipart` method may return ``False``. If such "
"messages were parsed with the :class:`~email.parser.FeedParser`, they will "
"have an instance of the :class:`~email.errors."
"MultipartInvariantViolationDefect` class in their *defects* attribute list.  "
"See :mod:`email.errors` for details."
msgstr ""
"Certains messages non conformes aux normes peuvent ne pas être cohérents en "
"interne quant à :mimetype:`multipart`. De tels messages peuvent avoir un en-"
"tête :mailheader:`Content-Type` de type :mimetype:`multipart`, mais leur "
"méthode :meth:`~email.message.EmailMessage.is_multipart` peut renvoyer "
"``False``. Si de tels messages ont été analysés avec la :class:`~email."
"parser.FeedParser`, ils auront une instance de la classe :class:`~email."
"errors.MultipartInvariantViolationDefect` dans leur liste d'attributs "
"*defects*. Voir :mod:`email.errors` pour plus de détails."
