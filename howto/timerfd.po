# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 22:40+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/howto/timerfd.rst:5
msgid "timer file descriptor HOWTO"
msgstr ""

#: ../Doc/howto/timerfd.rst:0
msgid "Release"
msgstr ""

#: ../Doc/howto/timerfd.rst:7
msgid "1.13"
msgstr ""

#: ../Doc/howto/timerfd.rst:9
msgid ""
"This HOWTO discusses Python's support for the linux timer file descriptor."
msgstr ""

#: ../Doc/howto/timerfd.rst:13
msgid "Examples"
msgstr ""

#: ../Doc/howto/timerfd.rst:15
msgid ""
"The following example shows how to use a timer file descriptor to execute a "
"function twice a second:"
msgstr ""

#: ../Doc/howto/timerfd.rst:18
msgid ""
"# Practical scripts should use really use a non-blocking timer,\n"
"# we use a blocking timer here for simplicity.\n"
"import os, time\n"
"\n"
"# Create the timer file descriptor\n"
"fd = os.timerfd_create(time.CLOCK_REALTIME)\n"
"\n"
"# Start the timer in 1 second, with an interval of half a second\n"
"os.timerfd_settime(fd, initial=1, interval=0.5)\n"
"\n"
"try:\n"
"    # Process timer events four times.\n"
"    for _ in range(4):\n"
"        # read() will block until the timer expires\n"
"        _ = os.read(fd, 8)\n"
"        print(\"Timer expired\")\n"
"finally:\n"
"    # Remember to close the timer file descriptor!\n"
"    os.close(fd)"
msgstr ""

#: ../Doc/howto/timerfd.rst:40
msgid ""
"To avoid the precision loss caused by the :class:`float` type, timer file "
"descriptors allow specifying initial expiration and interval in integer "
"nanoseconds with ``_ns`` variants of the functions."
msgstr ""

#: ../Doc/howto/timerfd.rst:44
msgid ""
"This example shows how :func:`~select.epoll` can be used with timer file "
"descriptors to wait until the file descriptor is ready for reading:"
msgstr ""

#: ../Doc/howto/timerfd.rst:47
msgid ""
"import os, time, select, socket, sys\n"
"\n"
"# Create an epoll object\n"
"ep = select.epoll()\n"
"\n"
"# In this example, use loopback address to send \"stop\" command to the "
"server.\n"
"#\n"
"# $ telnet 127.0.0.1 1234\n"
"# Trying 127.0.0.1...\n"
"# Connected to 127.0.0.1.\n"
"# Escape character is '^]'.\n"
"# stop\n"
"# Connection closed by foreign host.\n"
"#\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"sock.bind((\"127.0.0.1\", 1234))\n"
"sock.setblocking(False)\n"
"sock.listen(1)\n"
"ep.register(sock, select.EPOLLIN)\n"
"\n"
"# Create timer file descriptors in non-blocking mode.\n"
"num = 3\n"
"fds = []\n"
"for _ in range(num):\n"
"    fd = os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\n"
"    fds.append(fd)\n"
"    # Register the timer file descriptor for read events\n"
"    ep.register(fd, select.EPOLLIN)\n"
"\n"
"# Start the timer with os.timerfd_settime_ns() in nanoseconds.\n"
"# Timer 1 fires every 0.25 seconds; timer 2 every 0.5 seconds; etc\n"
"for i, fd in enumerate(fds, start=1):\n"
"    one_sec_in_nsec = 10**9\n"
"    i = i * one_sec_in_nsec\n"
"    os.timerfd_settime_ns(fd, initial=i//4, interval=i//4)\n"
"\n"
"timeout = 3\n"
"try:\n"
"    conn = None\n"
"    is_active = True\n"
"    while is_active:\n"
"        # Wait for the timer to expire for 3 seconds.\n"
"        # epoll.poll() returns a list of (fd, event) pairs.\n"
"        # fd is a file descriptor.\n"
"        # sock and conn[=returned value of socket.accept()] are socket "
"objects, not file descriptors.\n"
"        # So use sock.fileno() and conn.fileno() to get the file "
"descriptors.\n"
"        events = ep.poll(timeout)\n"
"\n"
"        # If more than one timer file descriptors are ready for reading at "
"once,\n"
"        # epoll.poll() returns a list of (fd, event) pairs.\n"
"        #\n"
"        # In this example settings,\n"
"        #    1st timer fires every 0.25 seconds in 0.25 seconds. (0.25, 0.5, "
"0.75, 1.0, ...)\n"
"        #    2nd timer every 0.5 seconds in 0.5 seconds. (0.5, 1.0, 1.5, "
"2.0, ...)\n"
"        #    3rd timer every 0.75 seconds in 0.75 seconds. (0.75, 1.5, 2.25, "
"3.0, ...)\n"
"        #\n"
"        #    In 0.25 seconds, only 1st timer fires.\n"
"        #    In 0.5 seconds, 1st timer and 2nd timer fires at once.\n"
"        #    In 0.75 seconds, 1st timer and 3rd timer fires at once.\n"
"        #    In 1.5 seconds, 1st timer, 2nd timer and 3rd timer fires at "
"once.\n"
"        #\n"
"        # If a timer file descriptor is signaled more than once since\n"
"        # the last os.read() call, os.read() returns the number of signaled\n"
"        # as host order of class bytes.\n"
"        print(f\"Signaled events={events}\")\n"
"        for fd, event in events:\n"
"            if event & select.EPOLLIN:\n"
"                if fd == sock.fileno():\n"
"                    # Check if there is a connection request.\n"
"                    print(f\"Accepting connection {fd}\")\n"
"                    conn, addr = sock.accept()\n"
"                    conn.setblocking(False)\n"
"                    print(f\"Accepted connection {conn} from {addr}\")\n"
"                    ep.register(conn, select.EPOLLIN)\n"
"                elif conn and fd == conn.fileno():\n"
"                    # Check if there is data to read.\n"
"                    print(f\"Reading data {fd}\")\n"
"                    data = conn.recv(1024)\n"
"                    if data:\n"
"                        # You should catch UnicodeDecodeError exception for "
"safety.\n"
"                        cmd = data.decode()\n"
"                        if cmd.startswith(\"stop\"):\n"
"                            print(f\"Stopping server\")\n"
"                            is_active = False\n"
"                        else:\n"
"                            print(f\"Unknown command: {cmd}\")\n"
"                    else:\n"
"                        # No more data, close connection\n"
"                        print(f\"Closing connection {fd}\")\n"
"                        ep.unregister(conn)\n"
"                        conn.close()\n"
"                        conn = None\n"
"                elif fd in fds:\n"
"                    print(f\"Reading timer {fd}\")\n"
"                    count = int.from_bytes(os.read(fd, 8), byteorder=sys."
"byteorder)\n"
"                    print(f\"Timer {fds.index(fd) + 1} expired {count} "
"times\")\n"
"                else:\n"
"                    print(f\"Unknown file descriptor {fd}\")\n"
"finally:\n"
"    for fd in fds:\n"
"        ep.unregister(fd)\n"
"        os.close(fd)\n"
"    ep.close()"
msgstr ""

#: ../Doc/howto/timerfd.rst:153
msgid ""
"This example shows how :func:`~select.select` can be used with timer file "
"descriptors to wait until the file descriptor is ready for reading:"
msgstr ""

#: ../Doc/howto/timerfd.rst:156
msgid ""
"import os, time, select, socket, sys\n"
"\n"
"# In this example, use loopback address to send \"stop\" command to the "
"server.\n"
"#\n"
"# $ telnet 127.0.0.1 1234\n"
"# Trying 127.0.0.1...\n"
"# Connected to 127.0.0.1.\n"
"# Escape character is '^]'.\n"
"# stop\n"
"# Connection closed by foreign host.\n"
"#\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"sock.bind((\"127.0.0.1\", 1234))\n"
"sock.setblocking(False)\n"
"sock.listen(1)\n"
"\n"
"# Create timer file descriptors in non-blocking mode.\n"
"num = 3\n"
"fds = [os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\n"
"       for _ in range(num)]\n"
"select_fds = fds + [sock]\n"
"\n"
"# Start the timers with os.timerfd_settime() in seconds.\n"
"# Timer 1 fires every 0.25 seconds; timer 2 every 0.5 seconds; etc\n"
"for i, fd in enumerate(fds, start=1):\n"
"   os.timerfd_settime(fd, initial=i/4, interval=i/4)\n"
"\n"
"timeout = 3\n"
"try:\n"
"    conn = None\n"
"    is_active = True\n"
"    while is_active:\n"
"       # Wait for the timer to expire for 3 seconds.\n"
"       # select.select() returns a list of file descriptors or objects.\n"
"       rfd, wfd, xfd = select.select(select_fds, select_fds, select_fds, "
"timeout)\n"
"       for fd in rfd:\n"
"           if fd == sock:\n"
"               # Check if there is a connection request.\n"
"               print(f\"Accepting connection {fd}\")\n"
"               conn, addr = sock.accept()\n"
"               conn.setblocking(False)\n"
"               print(f\"Accepted connection {conn} from {addr}\")\n"
"               select_fds.append(conn)\n"
"           elif conn and fd == conn:\n"
"               # Check if there is data to read.\n"
"               print(f\"Reading data {fd}\")\n"
"               data = conn.recv(1024)\n"
"               if data:\n"
"                   # You should catch UnicodeDecodeError exception for "
"safety.\n"
"                   cmd = data.decode()\n"
"                   if cmd.startswith(\"stop\"):\n"
"                       print(f\"Stopping server\")\n"
"                       is_active = False\n"
"                   else:\n"
"                       print(f\"Unknown command: {cmd}\")\n"
"               else:\n"
"                   # No more data, close connection\n"
"                   print(f\"Closing connection {fd}\")\n"
"                   select_fds.remove(conn)\n"
"                   conn.close()\n"
"                   conn = None\n"
"           elif fd in fds:\n"
"               print(f\"Reading timer {fd}\")\n"
"               count = int.from_bytes(os.read(fd, 8), byteorder=sys."
"byteorder)\n"
"               print(f\"Timer {fds.index(fd) + 1} expired {count} times\")\n"
"           else:\n"
"               print(f\"Unknown file descriptor {fd}\")\n"
"finally:\n"
"    for fd in fds:\n"
"       os.close(fd)\n"
"    sock.close()\n"
"    sock = None"
msgstr ""
