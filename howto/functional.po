# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/howto/functional.rst:3
msgid "Functional Programming HOWTO"
msgstr "Guide pratique : programmation fonctionnelle"

#: ../Doc/howto/functional.rst:5
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../Doc/howto/functional.rst:6
msgid "0.31"
msgstr ""

#: ../Doc/howto/functional.rst:8
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as :"
"term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"Dans ce document, nous allons faire un tour des fonctionnalités de Python "
"adaptées à la réalisation d'un programme dans un style fonctionnel. Après "
"une introduction à la programmation fonctionnelle, nous aborderons des "
"outils tels que les :term:`iterator`\\s et les :term:`generator`\\s ainsi "
"que les modules :mod:`itertools` et :mod:`functools`."

#: ../Doc/howto/functional.rst:16
msgid "Introduction"
msgstr "Introduction"

#: ../Doc/howto/functional.rst:18
msgid ""
"This section explains the basic concept of functional programming; if you're "
"just interested in learning about Python language features, skip to the next "
"section."
msgstr ""

#: ../Doc/howto/functional.rst:22
msgid ""
"Programming languages support decomposing problems in several different ways:"
msgstr ""
"Les langages de programmation permettent de traiter des problèmes selon "
"différentes approches :"

#: ../Doc/howto/functional.rst:24
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C, "
"Pascal, and even Unix shells are procedural languages."
msgstr ""
"La plupart des langages de programmation suivent une logique "
"**procédurale** : les programmes sont constitués de listes d'instructions "
"qui détaillent les opérations que l'ordinateur doit appliquer aux entrées du "
"programme. C, Pascal ou encore les interpréteurs de commandes Unix sont des "
"langages procéduraux."

#: ../Doc/howto/functional.rst:28
msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're "
"most likely to be familiar with; a SQL query describes the data set you want "
"to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"Les langages **déclaratifs** permettent d'écrire la spécification du "
"problème et laissent l'implémentation du langage trouver une façon efficace "
"de réaliser les calculs nécessaires à sa résolution. SQL est un langage "
"déclaratif que vous êtes susceptible de connaître ; une requête SQL décrit "
"le jeu de données que vous souhaitez récupérer et le moteur SQL choisit de "
"parcourir les tables ou d'utiliser les index, l'ordre de résolution des sous-"
"clauses, etc."

#: ../Doc/howto/functional.rst:35
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't "
"force the use of object-oriented features."
msgstr ""
"Les programmes **orientés objet** manipulent des ensembles d'objets. Ceux-ci "
"possèdent un état interne et des méthodes qui interrogent ou modifient cet "
"état d'une façon ou d'une autre. Smalltalk et Java sont deux langages "
"orientés objet. C++ et Python gèrent la programmation orientée objet mais "
"n'imposent pas l'utilisation de telles fonctionnalités."

#: ../Doc/howto/functional.rst:41
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"La programmation **fonctionnelle** implique de décomposer un problème en un "
"ensemble de fonctions. Dans l'idéal, les fonctions produisent des sorties à "
"partir d'entrées et ne possède pas d'état interne qui soit susceptible de "
"modifier la sortie pour une entrée donnée. Les langages fonctionnels les "
"plus connus sont ceux de la famille ML (Standard ML, OCaml et autres) et "
"Haskell."

#: ../Doc/howto/functional.rst:47
msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages "
"that support several different approaches.  Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the "
"GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""

#: ../Doc/howto/functional.rst:57
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions "
"that have no side effects at all are called **purely functional**.  Avoiding "
"side effects means not using data structures that get updated as a program "
"runs; every function's output must only depend on its input."
msgstr ""
"Dans un programme fonctionnel, l'entrée traverse un ensemble de fonctions. "
"Chaque fonction opère sur son entrée et produit une sortie. Le style "
"fonctionnel préconise de ne pas écrire de fonctions ayant des effets de "
"bord, c'est-à-dire qui modifient un état interne ou réalisent d'autres "
"changements qui ne sont pas visibles dans la valeur de sortie de la "
"fonction. Les fonctions qui ne présentent aucun effet de bord sont dites "
"**purement fonctionnelles**. L'interdiction des effets de bord signifie "
"qu'aucune structure de données n'est mise à jour lors de l'exécution du "
"programme ; chaque sortie d'une fonction ne dépend que de son entrée."

#: ../Doc/howto/functional.rst:65
msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all "
"side effects.  Printing to the screen or writing to a disk file are side "
"effects, for example.  For example, in Python a ``print`` statement or a "
"``time.sleep(1)`` both return no useful value; they're only called for their "
"side effects of sending some text to the screen or pausing execution for a "
"second."
msgstr ""

#: ../Doc/howto/functional.rst:73
msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"Les programmes Python écrits dans un style fonctionnel ne poussent "
"généralement pas le curseur de la pureté à l'extrême en interdisant toute "
"entrée/sortie ou les assignations ; ils exhibent une interface fonctionnelle "
"en apparence mais utilisent des fonctionnalités impures en interne. Par "
"exemple, l'implémentation d'une fonction peut assigner dans des variables "
"locales mais ne modifiera pas de variable globale et n'aura pas d'autre "
"effet de bord."

#: ../Doc/howto/functional.rst:79
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"La programmation fonctionnelle peut être considérée comme l'opposé de la "
"programmation orientée objet. Les objets encapsulent un état interne ainsi "
"qu'une collection de méthodes qui permettent de modifier cet état. Les "
"programmes consistent à appliquer les bons changements à ces états. La "
"programmation fonctionnelle vous impose d'éviter au maximum ces changements "
"d'états en travaillant sur des données qui traversent un flux de fonctions. "
"En Python, vous pouvez combiner ces deux approches en écrivant des fonctions "
"qui prennent en argument et renvoient des instances représentants des objets "
"de votre application (courriers électroniques, transactions, etc.)."

#: ../Doc/howto/functional.rst:88
msgid ""
"Functional design may seem like an odd constraint to work under.  Why should "
"you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr ""
"Programmer sous la contrainte du paradigme fonctionnel peut sembler étrange. "
"Pourquoi vouloir éviter les objets et les effets de bord ? Il existe des "
"avantages théoriques et pratiques au style fonctionnel :"

#: ../Doc/howto/functional.rst:92
msgid "Formal provability."
msgstr "Preuves formelles."

#: ../Doc/howto/functional.rst:93
msgid "Modularity."
msgstr "Modularité."

#: ../Doc/howto/functional.rst:94
msgid "Composability."
msgstr "Composabilité."

#: ../Doc/howto/functional.rst:95
msgid "Ease of debugging and testing."
msgstr "Facilité de débogage et de test."

#: ../Doc/howto/functional.rst:99
msgid "Formal provability"
msgstr "Preuves formelles"

#: ../Doc/howto/functional.rst:101
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr ""
"Un avantage théorique est qu'il plus facile de construire une preuve "
"mathématique de l'exactitude d'un programme fonctionnel."

#: ../Doc/howto/functional.rst:104
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"Les chercheurs ont longtemps souhaité trouver des façons de prouver "
"mathématiquement qu'un programme est correct. Cela ne se borne pas à tester "
"si la sortie d'un programme est correcte sur de nombreuses entrées ou lire "
"le code source et en conclure que le celui-ci semble juste. L'objectif est "
"d'établir une preuve rigoureuse que le programme produit le bon résultat "
"pour toutes les entrées possibles."

#: ../Doc/howto/functional.rst:111
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"La technique utilisée pour prouver l'exactitude d'un programme est d'écrire "
"des **invariants**, c'est-à-dire des propriétés de l'entrée et des variables "
"du programme qui sont toujours vérifiées. Pour chaque ligne de code, il "
"suffit de montrer que si les invariants X et Y sont vrais **avant** "
"l'exécution de cette ligne, les invariants légèrement modifiés X' et Y' sont "
"vérifiés **après** son exécution. Ceci se répète jusqu'à atteindre la fin du "
"programme. À ce stade, les invariants doivent alors correspondre aux "
"propriétés que l'on souhaite que la sortie du programme vérifie."

#: ../Doc/howto/functional.rst:119
msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr ""
"L'aversion du style fonctionnel envers les assignations de variable est "
"apparue car celles-ci sont difficiles à gérer avec cette méthode. Les "
"assignations peuvent rompre des invariants qui étaient vrais auparavant sans "
"pour autant produire de nouveaux invariants qui pourraient être propagés."

#: ../Doc/howto/functional.rst:124
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"Malheureusement, prouver l'exactitude d'un programme est très peu commode et "
"ne concerne que rarement des logiciels en Python. Même des programmes "
"triviaux nécessitent souvent des preuves s'étalant sur plusieurs pages ; la "
"preuve de l'exactitude d'un programme relativement gros serait gigantesque. "
"Peu, voire aucun, des programmes que vous utilisez quotidiennement "
"(l'interpréteur Python, votre analyseur syntaxique XML, votre navigateur "
"web) ne peuvent être prouvés exacts. Même si vous écriviez ou généreriez une "
"preuve, il faudrait encore vérifier celle-ci. Peut-être qu'elle contient une "
"erreur et que vous pensez désormais, à tort, que vous avez prouvé que votre "
"programme est correct."

#: ../Doc/howto/functional.rst:135
msgid "Modularity"
msgstr "Modularité"

#: ../Doc/howto/functional.rst:137
msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"Un intérêt plus pratique de la programmation fonctionnelle est qu'elle "
"impose de décomposer le problème en petits morceaux. Les programmes qui en "
"résultent sont souvent plus modulaires. Il est plus simple de spécifier et "
"d'écrire une petite fonction qui ne fait qu'une seule tâche plutôt qu'une "
"grosse fonction qui réalise une transformation complexe. Les petites "
"fonctions sont plus faciles à lire et à vérifier."

#: ../Doc/howto/functional.rst:145
msgid "Ease of debugging and testing"
msgstr "Facilité de débogage et de test"

#: ../Doc/howto/functional.rst:147
msgid "Testing and debugging a functional-style program is easier."
msgstr "Tester et déboguer un programme fonctionnel est plus facile."

#: ../Doc/howto/functional.rst:149
msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point "
"where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"Déboguer est plus simple car les fonctions sont généralement petites et bien "
"spécifiées. Lorsqu'un programme ne fonctionne pas, chaque fonction constitue "
"une étape intermédiaire au niveau de laquelle vous pouvez vérifier que les "
"valeurs sont justes. Vous pouvez observer les entrées intermédiaires et les "
"sorties afin d'isoler rapidement la fonction qui est à l'origine du bogue."

#: ../Doc/howto/functional.rst:154
msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"Les tests sont plus faciles car chaque fonction est désormais un sujet "
"potentiel pour un test unitaire. Les fonctions ne dépendent pas d'un état "
"particulier du système qui devrait être répliqué avant d'exécuter un test ; "
"à la place vous n'avez qu'à produire une entrée synthétique et vérifier que "
"le résultat correspond à ce que vous attendez."

#: ../Doc/howto/functional.rst:161
msgid "Composability"
msgstr "Composabilité"

#: ../Doc/howto/functional.rst:163
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function "
"that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"En travaillant sur un programme dans le style fonctionnel, vous écrivez un "
"certain nombre de fonctions avec des entrées et des sorties variables. "
"Certaines de ces fonctions sont inévitablement spécifiques à une application "
"en particulier, mais d'autres peuvent s'appliquer à de nombreux cas d'usage. "
"Par exemple, une fonction qui liste l'ensemble des fichiers XML d'un "
"répertoire à partir du chemin de celui-ci ou une fonction qui renvoie le "
"contenu d'un fichier à partir de son nom peuvent être utiles dans de "
"nombreuses situations."

#: ../Doc/howto/functional.rst:170
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration "
"and writing a few functions specialized for the current task."
msgstr ""
"Au fur et à mesure, vous constituez ainsi une bibliothèque personnelle "
"d'utilitaires. Souvent, vous pourrez construire de nouveaux programmes en "
"agençant des fonctions existantes dans une nouvelle configuration et en "
"écrivant quelques fonctions spécifiques à votre objectif en cours."

#: ../Doc/howto/functional.rst:176
msgid "Iterators"
msgstr "Itérateurs"

#: ../Doc/howto/functional.rst:178
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr ""
"Commençons par jeter un œil à une des fonctionnalités les plus importantes "
"pour écrire en style fonctionnel avec Python : les itérateurs."

#: ../Doc/howto/functional.rst:181
msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called ``next()`` that takes no arguments and always returns the next "
"element of the stream.  If there are no more elements in the stream, "
"``next()`` must raise the ``StopIteration`` exception.  Iterators don't have "
"to be finite, though; it's perfectly reasonable to write an iterator that "
"produces an infinite stream of data."
msgstr ""

#: ../Doc/howto/functional.rst:189
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called an **iterable** object if you "
"can get an iterator for it."
msgstr ""

#: ../Doc/howto/functional.rst:196
msgid "You can experiment with the iteration interface manually:"
msgstr "Vous pouvez expérimenter avec l'interface d'itération manuellement :"

#: ../Doc/howto/functional.rst:214
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the ``for`` statement.  In the statement ``for X in Y``, Y "
"must be an iterator or some object for which ``iter()`` can create an "
"iterator. These two statements are equivalent::"
msgstr ""

#: ../Doc/howto/functional.rst:225
msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr ""
"Les itérateurs peuvent être transformés en listes ou en tuples en appelant "
"les constructeurs respectifs :func:`list` et :func:`tuple` :"

#: ../Doc/howto/functional.rst:234
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"Le dépaquetage de séquences fonctionne également sur les itérateurs : si "
"vous savez qu'un itérateur renvoie N éléments, vous pouvez les dépaqueter "
"dans un n-uplet :"

#: ../Doc/howto/functional.rst:243
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The ``"
"\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; ``max()``, "
"``min()`` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""

#: ../Doc/howto/functional.rst:251
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the ``next()`` method.  Functions may "
"therefore consume all of the iterator's output, and if you need to do "
"something different with the same stream, you'll have to create a new "
"iterator."
msgstr ""

#: ../Doc/howto/functional.rst:261
msgid "Data Types That Support Iterators"
msgstr "Types de données itérables"

#: ../Doc/howto/functional.rst:263
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr ""
"Nous avons vu précédemment comment les listes et les *tuples* gèrent les "
"itérateurs. En réalité, n'importe quel type de séquence en Python, par "
"exemple les chaînes de caractères, sont itérables."

#: ../Doc/howto/functional.rst:267
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over "
"the dictionary's keys:"
msgstr ""

#: ../Doc/howto/functional.rst:291
msgid ""
"Note that the order is essentially random, because it's based on the hash "
"ordering of the objects in the dictionary."
msgstr ""

#: ../Doc/howto/functional.rst:294
msgid ""
"Applying ``iter()`` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over keys, values, or key/value pairs, you can explicitly call the "
"``iterkeys()``, ``itervalues()``, or ``iteritems()`` methods to get an "
"appropriate iterator."
msgstr ""

#: ../Doc/howto/functional.rst:299
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ""
"Le constructeur :func:`dict` accepte de prendre un itérateur en argument qui "
"renvoie un flux fini de pairs ``(clé, valeur)`` :"

#: ../Doc/howto/functional.rst:306
msgid ""
"Files also support iteration by calling the ``readline()`` method until "
"there are no more lines in the file.  This means you can read each line of a "
"file like this::"
msgstr ""

#: ../Doc/howto/functional.rst:314
msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr ""
"Les ensembles peuvent être créés à partir d'un itérable et autorisent "
"l'itération sur les éléments de l'ensemble ::"

#: ../Doc/howto/functional.rst:324
msgid "Generator expressions and list comprehensions"
msgstr "Expressions génératrices et compréhension de listes"

#: ../Doc/howto/functional.rst:326
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"Deux opérations courantes réalisables sur la sortie d'un itérateur sont 1) "
"effectuer une opération pour chaque élément, 2) extraire le sous-ensemble "
"des éléments qui vérifient une certaine condition. Par exemple, pour une "
"liste de chaînes de caractères, vous pouvez choisir de retirer tous les "
"caractères blancs à la fin de chaque ligne ou extraire toutes les chaînes "
"contenant une sous-chaîne précise."

#: ../Doc/howto/functional.rst:332
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and "
"\"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can "
"strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"Les compréhensions de listes et les expressions génératrices sont des façons "
"concises d'exprimer de telles opérations, inspirées du langage de "
"programmation fonctionnel Haskell (https://www.haskell.org/).  Vous pouvez "
"retirer tous les caractères blancs initiaux et finaux d'un flux de chaînes "
"de caractères à l'aide du code suivant ::"

#: ../Doc/howto/functional.rst:345
msgid ""
"You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr ""
"Vous pouvez ne sélectionner que certains éléments en ajoutant une condition "
"« ``if`` » ::"

#: ../Doc/howto/functional.rst:350
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an "
"infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"La compréhension de liste renvoie une liste Python ; ``stripped_list`` est "
"une liste contenant les lignes après transformation, pas un itérateur. Les "
"expressions génératrices renvoient un itérateur qui calcule les valeurs au "
"fur et à mesure sans toutes les matérialiser d'un seul coup. Cela signifie "
"que les compréhensions de listes ne sont pas très utiles si vous travaillez "
"sur des itérateurs infinis ou produisant une très grande quantité de "
"données. Les expressions génératrices sont préférables dans ce cas."

#: ../Doc/howto/functional.rst:357
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"Les expressions génératrices sont écrites entre parenthèses (« () ») et les "
"compréhensions de listes entre crochets (« [] »). Les expressions "
"génératrices sont de la forme ::"

#: ../Doc/howto/functional.rst:370
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr ""
"La compréhension de liste équivalente s'écrit de la même manière, utilisez "
"juste des crochets à la place des parenthèses."

#: ../Doc/howto/functional.rst:373
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"Les éléments de la sortie sont les valeurs successives de ``expression``. La "
"clause ``if`` est facultative ; si elle est présente, ``expression`` n'est "
"évaluée et ajoutée au résultat que si ``condition`` est vérifiée."

#: ../Doc/howto/functional.rst:377
msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an "
"iterator that will be immediately passed to a function you can write::"
msgstr ""
"Les expressions génératrices doivent toujours être écrites entre "
"parenthèses, mais les parenthèses qui encadrent un appel de fonction "
"comptent aussi. Si vous souhaitez créer un itérateur qui soit immédiatement "
"passé à une fonction, vous pouvez écrire ::"

#: ../Doc/howto/functional.rst:383
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``, "
"``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"Les clauses ``for ... in`` indiquent les séquences sur lesquelles itérer. "
"Celles-ci peuvent être de longueurs différentes car l'itération est réalisée "
"de gauche à droite et non en parallèle. ``sequence2`` est parcourue "
"entièrement pour chaque élément de ``sequence1``. ``sequence3`` est ensuite "
"parcourue dans son intégralité pour chaque paire d'éléments de ``sequence1`` "
"et ``sequence2``."

#: ../Doc/howto/functional.rst:389
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr ""
"Autrement dit, une compréhension de liste ou une expression génératrice est "
"équivalente au code Python ci-dessous ::"

#: ../Doc/howto/functional.rst:406
msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"Ainsi lorsque plusieurs clauses ``for ... in`` sont présentes mais sans "
"condition ``if``, la longueur totale de la nouvelle séquence est égale au "
"produit des longueurs des séquences itérées. Si vous travaillez sur deux "
"listes de longueur 3, la sortie contiendra 9 éléments :"

#: ../Doc/howto/functional.rst:421
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Afin de ne pas créer une ambiguïté dans la grammaire de Python, "
"``expression`` doit être encadrée par des parenthèses si elle produit un n-"
"uplet. La première compréhension de liste ci-dessous n'est pas valide "
"syntaxiquement, tandis que la seconde l'est ::"

#: ../Doc/howto/functional.rst:432
msgid "Generators"
msgstr "Générateurs"

#: ../Doc/howto/functional.rst:434
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"Les générateurs forment une classe spéciale de fonctions qui simplifie la "
"création d'itérateurs. Les fonctions habituelles calculent une valeur et la "
"renvoie, tandis que les générateurs renvoient un itérateur qui produit un "
"flux de valeurs."

#: ../Doc/howto/functional.rst:438
msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"Vous connaissez sans doute le fonctionnement des appels de fonctions en "
"Python ou en C. Lorsqu'une fonction est appelée, un espace de nommage privé "
"lui est associé pour ses variables locales. Lorsque le programme atteint une "
"instruction ``return``, les variables locales sont détruites et la valeur "
"est renvoyée à l'appelant. Les appels postérieurs à la même fonction créent "
"un nouvel espace de nommage privé et de nouvelles variables locales. "
"Cependant, que se passerait-il si les variables locales n'étaient pas "
"détruites lors de la sortie d'une fonction ? Et s'il était possible de "
"reprendre l'exécution de la fonction là où elle s'était arrêtée ? Les "
"générateurs sont une réponse à ces questions ; vous pouvez considérer qu'il "
"s'agit de fonctions qu'il est possible d'interrompre, puis de relancer sans "
"perdre leur progression."

#: ../Doc/howto/functional.rst:447
msgid "Here's the simplest example of a generator function:"
msgstr "Voici un exemple simple de fonction génératrice :"

#: ../Doc/howto/functional.rst:455
msgid ""
"Any function containing a ``yield`` keyword is a generator function; this is "
"detected by Python's :term:`bytecode` compiler which compiles the function "
"specially as a result."
msgstr ""

#: ../Doc/howto/functional.rst:459
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's ``.next()`` method, the "
"function will resume executing."
msgstr ""

#: ../Doc/howto/functional.rst:467
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "Voici un exemple d'utilisation du générateur ``generate_ints()`` :"

#: ../Doc/howto/functional.rst:484
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""

#: ../Doc/howto/functional.rst:487
msgid ""
"Inside a generator function, the ``return`` statement can only be used "
"without a value, and signals the end of the procession of values; after "
"executing a ``return`` the generator cannot return any further values.  "
"``return`` with a value, such as ``return 5``, is a syntax error inside a "
"generator function.  The end of the generator's results can also be "
"indicated by raising ``StopIteration`` manually, or by just letting the flow "
"of execution fall off the bottom of the function."
msgstr ""

#: ../Doc/howto/functional.rst:495
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the ``next()`` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class can be much messier."
msgstr ""

#: ../Doc/howto/functional.rst:502
msgid ""
"The test suite included with Python's library, ``test_generators.py``, "
"contains a number of more interesting examples.  Here's one generator that "
"implements an in-order traversal of a tree using generators recursively. ::"
msgstr ""

#: ../Doc/howto/functional.rst:517
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the N-"
"Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"Deux autres exemples de ``test_generators.py`` permettent de résoudre le "
"problème des N Reines (placer *N* reines sur un échiquier de dimensions "
"*NxN* de telle sorte qu'aucune reine ne soit en position d'en prendre une "
"autre) et le problème du cavalier (trouver un chemin permettant au cavalier "
"de visiter toutes les cases d'un échiquier *NxN* sans jamais visiter la même "
"case deux fois)."

#: ../Doc/howto/functional.rst:525
msgid "Passing values into a generator"
msgstr "Transmettre des valeurs au générateur"

#: ../Doc/howto/functional.rst:527
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass "
"any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"Avant Python 2.5, les générateurs ne pouvaient que produire des sorties. Une "
"fois le code du générateur exécuté pour créer un itérateur, il était "
"impossible d'introduire de l'information nouvelle dans la fonction mise en "
"pause. Une astuce consistait à obtenir cette fonctionnalité en autorisant le "
"générateur à consulter des variables globales ou en lui passant des objets "
"mutables modifiés hors du générateur, mais ces approches étaient compliquées."

#: ../Doc/howto/functional.rst:534
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. :keyword:"
"`yield` became an expression, returning a value that can be assigned to a "
"variable or otherwise operated on::"
msgstr ""
"À partir de Python 2.5, il existe une méthode simple pour transmettre des "
"valeurs à un générateur. Le mot-clé :keyword:`yield` est devenu une "
"expression qui renvoie une valeur sur laquelle il est possible d'opérer et "
"que vous pouvez assigner à une variable ::"

#: ../Doc/howto/functional.rst:540
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"Comme dans l'exemple ci-dessus, nous vous recommandons de **toujours** "
"encadrer les expressions ``yield`` par des parenthèses lorsque vous utilisez "
"leur valeur de retour. Elles ne sont pas toujours indispensables mais mieux "
"vaut prévenir que guérir : il est plus facile de les ajouter "
"systématiquement que de prendre le risque de les oublier là où elles sont "
"requises."

#: ../Doc/howto/functional.rst:545
msgid ""
"(PEP 342 explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""

#: ../Doc/howto/functional.rst:551
msgid ""
"Values are sent into a generator by calling its ``send(value)`` method.  "
"This method resumes the generator's code and the ``yield`` expression "
"returns the specified value.  If the regular ``next()`` method is called, "
"the ``yield`` returns ``None``."
msgstr ""

#: ../Doc/howto/functional.rst:556
msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr ""
"Voici un exemple de compteur qui s'incrémente de 1 mais dont il est possible "
"de modifier le compte interne."

#: ../Doc/howto/functional.rst:571
msgid "And here's an example of changing the counter:"
msgstr "Et voici comment il est possible de modifier le compteur :"

#: ../Doc/howto/functional.rst:588
msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the ``send()`` method will be the only method used to resume your "
"generator function."
msgstr ""

#: ../Doc/howto/functional.rst:593
msgid ""
"In addition to ``send()``, there are two other new methods on generators:"
msgstr ""

#: ../Doc/howto/functional.rst:595
msgid ""
"``throw(type, value=None, traceback=None)`` is used to raise an exception "
"inside the generator; the exception is raised by the ``yield`` expression "
"where the generator's execution is paused."
msgstr ""

#: ../Doc/howto/functional.rst:599
msgid ""
"``close()`` raises a :exc:`GeneratorExit` exception inside the generator to "
"terminate the iteration.  On receiving this exception, the generator's code "
"must either raise :exc:`GeneratorExit` or :exc:`StopIteration`; catching the "
"exception and doing anything else is illegal and will trigger a :exc:"
"`RuntimeError`.  ``close()`` will also be called by Python's garbage "
"collector when the generator is garbage-collected."
msgstr ""

#: ../Doc/howto/functional.rst:606
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching :exc:"
"`GeneratorExit`."
msgstr ""
"Si vous devez exécuter du code pour faire le ménage lors d'une :exc:"
"`GeneratorExit`, nous vous suggérons d'utiliser une structure ``try: ... "
"finally`` plutôt que d'attraper :exc:`GeneratorExit`."

#: ../Doc/howto/functional.rst:609
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr ""
"Ces changements cumulés transforment les générateurs de producteurs "
"unidirectionnels d'information vers un statut hybride à la fois producteur "
"et consommateur."

#: ../Doc/howto/functional.rst:612
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"Les générateurs sont également devenus des **coroutines**, une forme "
"généralisée de sous-routine. L'exécution des sous-routines démarre à un "
"endroit et se termine à un autre (au début de la fonction et au niveau de "
"l'instruction ``return``), tandis qu'il est possible d'entrer, de sortir ou "
"de reprendre une coroutine à différents endroits (les instructions "
"``yield``)."

#: ../Doc/howto/functional.rst:619
msgid "Built-in functions"
msgstr "Fonctions natives"

#: ../Doc/howto/functional.rst:621
msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr ""
"Voyons un peu plus en détail les fonctions natives souvent utilisées de "
"concert avec les itérateurs."

#: ../Doc/howto/functional.rst:623
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter`, are "
"somewhat obsolete; they duplicate the features of list comprehensions but "
"return actual lists instead of iterators."
msgstr ""

#: ../Doc/howto/functional.rst:627
msgid ""
"``map(f, iterA, iterB, ...)`` returns a list containing ``f(iterA[0], "
"iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."
msgstr ""

#: ../Doc/howto/functional.rst:639
msgid ""
"As shown above, you can achieve the same effect with a list comprehension.  "
"The :func:`itertools.imap` function does the same thing but can handle "
"infinite iterators; it'll be discussed later, in the section on the :mod:"
"`itertools` module."
msgstr ""

#: ../Doc/howto/functional.rst:643
msgid ""
"``filter(predicate, iter)`` returns a list that contains all the sequence "
"elements that meet a certain condition, and is similarly duplicated by list "
"comprehensions.  A **predicate** is a function that returns the truth value "
"of some condition; for use with :func:`filter`, the predicate must take a "
"single value."
msgstr ""

#: ../Doc/howto/functional.rst:655
msgid "This can also be written as a list comprehension:"
msgstr "Cela peut se réécrire sous la forme d'une compréhension de liste :"

#: ../Doc/howto/functional.rst:660
msgid ""
":func:`filter` also has a counterpart in the :mod:`itertools` module, :func:"
"`itertools.ifilter`, that returns an iterator and can therefore handle "
"infinite sequences just as :func:`itertools.imap` can."
msgstr ""

#: ../Doc/howto/functional.rst:664
msgid ""
"``reduce(func, iter, [initial_value])`` doesn't have a counterpart in the :"
"mod:`itertools` module because it cumulatively performs an operation on all "
"the iterable's elements and therefore can't be applied to infinite "
"iterables. ``func`` must be a function that takes two elements and returns a "
"single value. :func:`reduce` takes the first two elements A and B returned "
"by the iterator and calculates ``func(A, B)``.  It then requests the third "
"element, C, calculates ``func(func(A, B), C)``, combines this result with "
"the fourth element returned, and continues until the iterable is exhausted.  "
"If the iterable returns no values at all, a :exc:`TypeError` exception is "
"raised.  If the initial value is supplied, it's used as a starting point and "
"``func(initial_value, A)`` is the first calculation."
msgstr ""

#: ../Doc/howto/functional.rst:688
msgid ""
"If you use :func:`operator.add` with :func:`reduce`, you'll add up all the "
"elements of the iterable.  This case is so common that there's a special "
"built-in called :func:`sum` to compute it:"
msgstr ""

#: ../Doc/howto/functional.rst:699
msgid ""
"For many uses of :func:`reduce`, though, it can be clearer to just write the "
"obvious :keyword:`for` loop::"
msgstr ""

#: ../Doc/howto/functional.rst:711
msgid ""
"``enumerate(iter)`` counts off the elements in the iterable, returning 2-"
"tuples containing the count and each element."
msgstr ""

#: ../Doc/howto/functional.rst:720
msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ""
":func:`enumerate` est souvent utilisée lorsque l'on souhaite boucler sur une "
"liste tout en listant les indices pour lesquels une certaine condition est "
"vérifiée ::"

#: ../Doc/howto/functional.rst:728
msgid ""
"``sorted(iterable, [cmp=None], [key=None], [reverse=False])`` collects all "
"the elements of the iterable into a list, sorts the list, and returns the "
"sorted result.  The ``cmp``, ``key``, and ``reverse`` arguments are passed "
"through to the constructed list's ``.sort()`` method. ::"
msgstr ""

#: ../Doc/howto/functional.rst:743
msgid ""
"(For a more detailed discussion of sorting, see the Sorting mini-HOWTO in "
"the Python wiki at https://wiki.python.org/moin/HowTo/Sorting.)"
msgstr ""

#: ../Doc/howto/functional.rst:746
msgid ""
"The ``any(iter)`` and ``all(iter)`` built-ins look at the truth values of an "
"iterable's contents.  :func:`any` returns ``True`` if any element in the "
"iterable is a true value, and :func:`all` returns ``True`` if all of the "
"elements are true values:"
msgstr ""

#: ../Doc/howto/functional.rst:766
msgid "Small functions and the lambda expression"
msgstr "Expressions lambda et fonctions courtes"

#: ../Doc/howto/functional.rst:768
msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr ""
"Dans un style de programmation fonctionnel, il est courant d'avoir besoin de "
"petites fonctions utilisées comme prédicats ou pour combiner des éléments "
"d'une façon ou d'une autre."

#: ../Doc/howto/functional.rst:771
msgid ""
"If there's a Python built-in or a module function that's suitable, you don't "
"need to define a new function at all::"
msgstr ""
"S'il existe une fonction native Python ou une fonction d'un module qui "
"convient, vous n'avez pas besoin de définir de nouvelle fonction ::"

#: ../Doc/howto/functional.rst:777
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the ``lambda`` statement.  ``lambda`` takes "
"a number of parameters and an expression combining these parameters, and "
"creates a small function that returns the value of the expression::"
msgstr ""

#: ../Doc/howto/functional.rst:788
msgid ""
"An alternative is to just use the ``def`` statement and define a function in "
"the usual way::"
msgstr ""
"Une autre façon de faire est de simplement utiliser l'instruction ``def`` "
"afin de définir une fonction de la manière habituelle ::"

#: ../Doc/howto/functional.rst:800
msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr ""
"La méthode à préférer est une question de style, en général l'auteur évite "
"l'utilisation de ``lambda``."

#: ../Doc/howto/functional.rst:803
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a "
"``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing?"
msgstr ""

#: ../Doc/howto/functional.rst:814
msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr ""
"Vous pouvez sûrement comprendre ce que fait ce code mais cela prend du temps "
"de démêler l'expression pour y voir plus clair. Une clause ``def`` concise "
"améliore la situation ::"

#: ../Doc/howto/functional.rst:823
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr ""
"Toutefois l'idéal aurait été de simplement se contenter d'une boucle "
"``for`` ::"

#: ../Doc/howto/functional.rst:829
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr ""
"ou de la fonction native :func:`sum` et d'une expression génératrice ::"

#: ../Doc/howto/functional.rst:833
msgid "Many uses of :func:`reduce` are clearer when written as ``for`` loops."
msgstr ""

#: ../Doc/howto/functional.rst:835
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses "
"of ``lambda``:"
msgstr ""
"Frederik Lundh a suggéré quelques règles pour le réusinage de code "
"impliquant les expressions ``lambda`` :"

#: ../Doc/howto/functional.rst:838
msgid "Write a lambda function."
msgstr "Écrire une fonction lambda."

#: ../Doc/howto/functional.rst:839
msgid "Write a comment explaining what the heck that lambda does."
msgstr ""
"Écrire un commentaire qui explique ce que fait cette satanée fonction lambda."

#: ../Doc/howto/functional.rst:840
msgid ""
"Study the comment for a while, and think of a name that captures the essence "
"of the comment."
msgstr ""
"Scruter le commentaire pendant quelques temps et réfléchir à un nom qui "
"synthétise son essence."

#: ../Doc/howto/functional.rst:842
msgid "Convert the lambda to a def statement, using that name."
msgstr ""
"Réécrire la fonction lambda en une définition *def* en utilisant ce nom."

#: ../Doc/howto/functional.rst:843
msgid "Remove the comment."
msgstr "Effacer le commentaire."

#: ../Doc/howto/functional.rst:845
msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr ""
"J'aime beaucoup ces règles mais vous êtes libre de ne pas être d'accord et "
"de ne pas préférer ce style sans lambda."

#: ../Doc/howto/functional.rst:850
msgid "The itertools module"
msgstr "Le module *itertools*"

#: ../Doc/howto/functional.rst:852
msgid ""
"The :mod:`itertools` module contains a number of commonly-used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
"Le module :mod:`itertools` contient de nombreux itérateurs très utilisés, "
"ainsi que des fonctions pour combiner différents itérateurs. Cette section "
"présente le contenu du module au travers de quelques exemples."

#: ../Doc/howto/functional.rst:856
msgid "The module's functions fall into a few broad classes:"
msgstr "Les fonctions du module se divisent en quelques grandes catégories :"

#: ../Doc/howto/functional.rst:858
msgid "Functions that create a new iterator based on an existing iterator."
msgstr ""
"Les fonctions qui transforment un itérateur existant en un nouvel itérateur."

#: ../Doc/howto/functional.rst:859
msgid "Functions for treating an iterator's elements as function arguments."
msgstr ""
"Les fonctions qui traitent les éléments d'un itérateur comme les arguments "
"d'une fonction."

#: ../Doc/howto/functional.rst:860
msgid "Functions for selecting portions of an iterator's output."
msgstr ""
"Les fonctions qui permettent de sélectionner des portions de la sortie d'un "
"itérateur."

#: ../Doc/howto/functional.rst:861
msgid "A function for grouping an iterator's output."
msgstr "Une fonction qui permet de grouper la sortie d'un itérateur."

#: ../Doc/howto/functional.rst:864
msgid "Creating new iterators"
msgstr "Créer de nouveaux itérateurs"

#: ../Doc/howto/functional.rst:866
msgid ""
"``itertools.count(n)`` returns an infinite stream of integers, increasing by "
"1 each time.  You can optionally supply the starting number, which defaults "
"to 0::"
msgstr ""

#: ../Doc/howto/functional.rst:874
msgid ""
"``itertools.cycle(iter)`` saves a copy of the contents of a provided "
"iterable and returns a new iterator that returns its elements from first to "
"last.  The new iterator will repeat these elements infinitely. ::"
msgstr ""

#: ../Doc/howto/functional.rst:881
msgid ""
"``itertools.repeat(elem, [n])`` returns the provided element ``n`` times, or "
"returns the element endlessly if ``n`` is not provided. ::"
msgstr ""

#: ../Doc/howto/functional.rst:889
msgid ""
"``itertools.chain(iterA, iterB, ...)`` takes an arbitrary number of "
"iterables as input, and returns all the elements of the first iterator, then "
"all the elements of the second, and so on, until all of the iterables have "
"been exhausted. ::"
msgstr ""

#: ../Doc/howto/functional.rst:896
msgid ""
"``itertools.izip(iterA, iterB, ...)`` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ""

#: ../Doc/howto/functional.rst:902
msgid ""
"It's similar to the built-in :func:`zip` function, but doesn't construct an "
"in-memory list and exhaust all the input iterators before returning; instead "
"tuples are constructed and returned only if they're requested.  (The "
"technical term for this behaviour is `lazy evaluation <http://en.wikipedia."
"org/wiki/Lazy_evaluation>`__.)"
msgstr ""

#: ../Doc/howto/functional.rst:908
msgid ""
"This iterator is intended to be used with iterables that are all of the same "
"length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr ""
"Cet itérateur suppose qu'il opère sur des itérables de même longueur. Si la "
"longueur des itérables diffère, le flux résultant a la même longueur que le "
"plus court des itérables. ::"

#: ../Doc/howto/functional.rst:915
msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr ""
"Toutefois, vous devez éviter de dépendre de ce comportement. En effet un "
"élément d'un des itérables les plus longs peut être retiré puis jeté (car "
"l'autre itérable est trop court). Cela signifie que vous ne pouvez alors "
"plus utiliser cet itérable car vous allez sauter l'élément qui vient d'être "
"jeté."

#: ../Doc/howto/functional.rst:919
msgid ""
"``itertools.islice(iter, [start], stop, [step])`` returns a stream that's a "
"slice of the iterator.  With a single ``stop`` argument, it will return the "
"first ``stop`` elements.  If you supply a starting index, you'll get ``stop-"
"start`` elements, and if you supply a value for ``step``, elements will be "
"skipped accordingly.  Unlike Python's string and list slicing, you can't use "
"negative values for ``start``, ``stop``, or ``step``. ::"
msgstr ""

#: ../Doc/howto/functional.rst:933
msgid ""
"``itertools.tee(iter, [n])`` replicates an iterator; it returns ``n`` "
"independent iterators that will all return the contents of the source "
"iterator. If you don't supply a value for ``n``, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""

#: ../Doc/howto/functional.rst:951
msgid "Calling functions on elements"
msgstr "Appliquer des fonctions au contenu des itérateurs"

#: ../Doc/howto/functional.rst:953
msgid ""
"Two functions are used for calling other functions on the contents of an "
"iterable."
msgstr ""

#: ../Doc/howto/functional.rst:956
msgid ""
"``itertools.imap(f, iterA, iterB, ...)`` returns a stream containing "
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ..."
"``::"
msgstr ""

#: ../Doc/howto/functional.rst:962
msgid ""
"The ``operator`` module contains a set of functions corresponding to "
"Python's operators.  Some examples are ``operator.add(a, b)`` (adds two "
"values), ``operator.ne(a, b)`` (same as ``a!=b``), and ``operator."
"attrgetter('id')`` (returns a callable that fetches the ``\"id\"`` "
"attribute)."
msgstr ""

#: ../Doc/howto/functional.rst:967
msgid ""
"``itertools.starmap(func, iter)`` assumes that the iterable will return a "
"stream of tuples, and calls ``f()`` using these tuples as the arguments::"
msgstr ""

#: ../Doc/howto/functional.rst:978
msgid "Selecting elements"
msgstr "Sélectionner des éléments"

#: ../Doc/howto/functional.rst:980
msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr ""
"Une autre catégorie de fonctions est celle permettant de sélectionner un "
"sous-ensemble des éléments de l'itérateur selon un prédicat donné."

#: ../Doc/howto/functional.rst:983
msgid ""
"``itertools.ifilter(predicate, iter)`` returns all the elements for which "
"the predicate returns true::"
msgstr ""

#: ../Doc/howto/functional.rst:992
msgid ""
"``itertools.ifilterfalse(predicate, iter)`` is the opposite, returning all "
"elements for which the predicate returns false::"
msgstr ""

#: ../Doc/howto/functional.rst:998
msgid ""
"``itertools.takewhile(predicate, iter)`` returns elements for as long as the "
"predicate returns true.  Once the predicate returns false, the iterator will "
"signal the end of its results."
msgstr ""

#: ../Doc/howto/functional.rst:1013
msgid ""
"``itertools.dropwhile(predicate, iter)`` discards elements while the "
"predicate returns true, and then returns the rest of the iterable's results."
msgstr ""

#: ../Doc/howto/functional.rst:1026
msgid "Grouping elements"
msgstr "Grouper les éléments"

#: ../Doc/howto/functional.rst:1028
msgid ""
"The last function I'll discuss, ``itertools.groupby(iter, key_func=None)``, "
"is the most complicated.  ``key_func(elem)`` is a function that can compute "
"a key value for each element returned by the iterable.  If you don't supply "
"a key function, the key is simply each element itself."
msgstr ""

#: ../Doc/howto/functional.rst:1033
msgid ""
"``groupby()`` collects all the consecutive elements from the underlying "
"iterable that have the same key value, and returns a stream of 2-tuples "
"containing a key value and an iterator for the elements with that key."
msgstr ""

#: ../Doc/howto/functional.rst:1061
msgid ""
"``groupby()`` assumes that the underlying iterable's contents will already "
"be sorted based on the key.  Note that the returned iterators also use the "
"underlying iterable, so you have to consume the results of iterator-1 before "
"requesting iterator-2 and its corresponding key."
msgstr ""

#: ../Doc/howto/functional.rst:1068
msgid "The functools module"
msgstr "Le module *functools*"

#: ../Doc/howto/functional.rst:1070
msgid ""
"The :mod:`functools` module in Python 2.5 contains some higher-order "
"functions. A **higher-order function** takes one or more functions as input "
"and returns a new function.  The most useful tool in this module is the :"
"func:`functools.partial` function."
msgstr ""
"Le module :mod:`functools` introduit par Python 2.5 contient diverses "
"fonctions d'ordre supérieur. Une **fonction d'ordre supérieur** prend une ou "
"plusieurs fonctions en entrée et renvoie une fonction. L'outil le plus "
"important de ce module est la fonction :func:`functools.partial`."

#: ../Doc/howto/functional.rst:1075
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create "
"a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"En programmant dans un style fonctionnel, il est courant de vouloir "
"construire des variantes de fonctions existantes dont certains paramètres "
"sont prédéfinis. Par exemple, considérons une fonction Python ``f(a, b, "
"c)``. Si vous voulez une nouvelle fonction ``g(b, c)`` équivalente à ``f(1, "
"b, c)``, c'est-à-dire fixer le premier paramètre de ``f()``. La fonction "
"``g()`` est une appelée « application partielle » de ``f()``."

#: ../Doc/howto/functional.rst:1081
msgid ""
"The constructor for ``partial`` takes the arguments ``(function, arg1, "
"arg2, ... kwarg1=value1, kwarg2=value2)``.  The resulting object is "
"callable, so you can just call it to invoke ``function`` with the filled-in "
"arguments."
msgstr ""

#: ../Doc/howto/functional.rst:1085
msgid "Here's a small but realistic example::"
msgstr "Voici un exemple court mais réaliste ::"

#: ../Doc/howto/functional.rst:1099
msgid "The operator module"
msgstr "Le module *operator*"

#: ../Doc/howto/functional.rst:1101
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
"Le module :mod:`operator` mentionné précédemment contient un ensemble de "
"fonctions reproduisant les opérateurs de Python. Ces fonctions sont souvent "
"utiles en programmation fonctionnelle car elles permettent de ne pas avoir à "
"écrire des fonctions triviales qui ne réalisent qu'une seule opération."

#: ../Doc/howto/functional.rst:1106
msgid "Some of the functions in this module are:"
msgstr "Voici quelques fonctions de ce module :"

#: ../Doc/howto/functional.rst:1108
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``div()``, ``floordiv()``, "
"``abs()``, ..."
msgstr ""

#: ../Doc/howto/functional.rst:1110
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "Les opérations logiques : ``not_()``, ``truth()``."

#: ../Doc/howto/functional.rst:1111
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "Les opérations bit à bit : ``and_()``, ``or_()``, ``invert()``."

#: ../Doc/howto/functional.rst:1112
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr ""
"Les comparaisons : ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, et "
"``ge()``."

#: ../Doc/howto/functional.rst:1113
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "L'identification des objets : ``is_()``, ``is_not()``."

#: ../Doc/howto/functional.rst:1115
msgid "Consult the operator module's documentation for a complete list."
msgstr ""
"Veuillez vous référer à la documentation du module *operator* pour une liste "
"complète."

#: ../Doc/howto/functional.rst:1119
msgid "Revision History and Acknowledgements"
msgstr "Historique des modifications et remerciements"

#: ../Doc/howto/functional.rst:1121
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike "
"Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"L'auteur souhaiterait remercier les personnes suivantes pour leurs "
"suggestions, leurs corrections et leur aide sur les premières versions de "
"cet article : Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim "
"Jewett, Mike Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake "
"Winton."

#: ../Doc/howto/functional.rst:1126
msgid "Version 0.1: posted June 30 2006."
msgstr "Version 0.1 : publiée le 30 juin 2006."

#: ../Doc/howto/functional.rst:1128
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "Version 0.11 : publiée le 1er juillet 2006. Correction orthographique."

#: ../Doc/howto/functional.rst:1130
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr ""
"Version 0.2 : publiée le 10 juillet 2006. Fusion des sections *genexp* et "
"*listcomp*. Correction orthographique."

#: ../Doc/howto/functional.rst:1133
msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr ""
"Version 0.21 : ajout de plusieurs références suggérées sur la liste de "
"diffusion *tutor*."

#: ../Doc/howto/functional.rst:1135
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"Version 0.30 : ajout d'une section sur le module ``functional`` écrite par "
"Collin Winter ; ajout d'une courte section sur le module ``operator`` ; "
"quelques autres modifications."

#: ../Doc/howto/functional.rst:1140
msgid "References"
msgstr "Références"

#: ../Doc/howto/functional.rst:1143
msgid "General"
msgstr "Général"

#: ../Doc/howto/functional.rst:1145
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and "
"Gerald Jay Sussman with Julie Sussman.  Full text at https://mitpress.mit."
"edu/sicp/.  In this classic textbook of computer science, chapters 2 and 3 "
"discuss the use of sequences and streams to organize the data flow inside a "
"program.  The book uses Scheme for its examples, but many of the design "
"approaches described in these chapters are applicable to functional-style "
"Python code."
msgstr ""
"**Structure and Interpretation of Computer Programs** par Harold Abelson et "
"Gerald Jay Sussman avec Julie Sussman. Disponible à l'adresse https://"
"mitpress.mit.edu/sicp/. Ce livre est un classique en informatique. Les "
"chapitres 2 et 3 présentent l'utilisation des séquences et des flux pour "
"organiser le flot de données dans un programme. Les exemples du livre "
"utilisent le langage Scheme mais la plupart des approches décrites dans ces "
"chapitres s'appliquent au style fonctionnel de Python."

#: ../Doc/howto/functional.rst:1153
msgid ""
"http://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""
"http://www.defmacro.org/ramblings/fp.html : une présentation générale à la "
"programmation fonctionnelle avec une longue introduction historique et des "
"exemples en Java."

#: ../Doc/howto/functional.rst:1156
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://fr.wikipedia.org/wiki/Programmation_fonctionnelle : l'entrée "
"Wikipédia qui décrit la programmation fonctionnelle."

#: ../Doc/howto/functional.rst:1159
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr ""
"https://fr.wikipedia.org/wiki/Coroutine : l'entrée pour les coroutines."

#: ../Doc/howto/functional.rst:1161
msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr ""
"https://fr.wikipedia.org/wiki/Curryfication : l'entrée pour le concept de "
"curryfication (création d'applications partielles)."

#: ../Doc/howto/functional.rst:1164
msgid "Python-specific"
msgstr "Spécifique à Python"

#: ../Doc/howto/functional.rst:1166
msgid ""
"http://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in "
"Text Processing\"."
msgstr ""
"http://gnosis.cx/TPiP/ : le premier chapitre du livre de David Mertz :title-"
"reference:`Text Processing in Python` présente l'utilisation de la "
"programmation fonctionnelle pour le traitement de texte dans la section « "
"Utilisation des fonctions d'ordre supérieur pour le traitement de texte »."

#: ../Doc/howto/functional.rst:1171
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see"
msgstr ""

#: ../Doc/howto/functional.rst:1174
msgid ""
"`part 1 <https://www.ibm.com/developerworks/linux/library/l-prog/index."
"html>`__, `part 2 <https://www.ibm.com/developerworks/linux/library/l-prog2/"
"index.html>`__, and `part 3 <https://www.ibm.com/developerworks/linux/"
"library/l-prog3/index.html>`__,"
msgstr ""

#: ../Doc/howto/functional.rst:1180
msgid "Python documentation"
msgstr "Documentation Python"

#: ../Doc/howto/functional.rst:1182
msgid "Documentation for the :mod:`itertools` module."
msgstr "Documentation du module :mod:`itertools`."

#: ../Doc/howto/functional.rst:1184
msgid "Documentation for the :mod:`operator` module."
msgstr "Documentation du module :mod:`operator`."

#: ../Doc/howto/functional.rst:1186
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: *\"Generator Expressions\"*"

#: ../Doc/howto/functional.rst:1188
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: *\"Coroutines via Enhanced Generators\"* décrit les nouvelles "
"fonctionnalités des générateurs en Python 2.5."
