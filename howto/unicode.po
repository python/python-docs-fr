# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-29 00:24+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "Guide Unicode"

#: ../Doc/howto/unicode.rst:0
msgid "Release"
msgstr "Version"

#: ../Doc/howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../Doc/howto/unicode.rst:9
msgid ""
"This HOWTO discusses Python support for Unicode, and explains various "
"problems that people commonly encounter when trying to work with Unicode."
msgstr ""

#: ../Doc/howto/unicode.rst:14
msgid "Introduction to Unicode"
msgstr "Introduction à Unicode"

#: ../Doc/howto/unicode.rst:17
msgid "History of Character Codes"
msgstr "Histoire des codes de caractères"

#: ../Doc/howto/unicode.rst:19
msgid ""
"In 1968, the American Standard Code for Information Interchange, better "
"known by its acronym ASCII, was standardized.  ASCII defined numeric codes "
"for various characters, with the numeric values running from 0 to 127.  For "
"example, the lowercase letter 'a' is assigned 97 as its code value."
msgstr ""
"En 1968, l'*American Standard Code for Information Interchange*, mieux connu "
"sous son acronyme *ASCII*, a été normalisé.  L'ASCII définissait des codes "
"numériques  pour différents caractères, les valeurs numériques s'étendant de "
"0 à 127.  Par exemple, la lettre minuscule « a » est assignée à 97 comme "
"valeur de code."

#: ../Doc/howto/unicode.rst:24
msgid ""
"ASCII was an American-developed standard, so it only defined unaccented "
"characters.  There was an 'e', but no 'é' or 'Í'.  This meant that languages "
"which required accented characters couldn't be faithfully represented in "
"ASCII. (Actually the missing accents matter for English, too, which contains "
"words such as 'naïve' and 'café', and some publications have house styles "
"which require spellings such as 'coöperate'.)"
msgstr ""
"ASCII était une norme développée par les États-Unis, elle ne définissait "
"donc que des caractères non accentués.  Il y avait « e », mais pas « é » ou "
"« Í ».  Cela signifiait que les langues qui nécessitaient des caractères "
"accentués ne pouvaient pas être fidèlement représentées en ASCII. (En fait, "
"les accents manquants importaient pour l'anglais aussi, qui contient des "
"mots tels que « naïve » et « café », et certaines publications ont des "
"styles propres qui exigent des orthographes tels que « *coöperate* ».)"

#: ../Doc/howto/unicode.rst:31
msgid ""
"For a while people just wrote programs that didn't display accents. In the "
"mid-1980s an Apple II BASIC program written by a French speaker might have "
"lines like these:"
msgstr ""
"Pendant un certain temps, les gens ont juste écrit des programmes qui "
"n'affichaient pas d'accents. Au milieu des années 1980, un programme Apple "
"II BASIC écrit par un français pouvait avoir des lignes comme celles-ci : ::"

#: ../Doc/howto/unicode.rst:40
msgid ""
"Those messages should contain accents (terminée, paramètre, enregistrés) and "
"they just look wrong to someone who can read French."
msgstr ""
"Ces messages devraient contenir des accents (terminée, paramètre, "
"enregistrés) et ils ont juste l'air anormaux à quelqu'un lisant le français."

#: ../Doc/howto/unicode.rst:43
msgid ""
"In the 1980s, almost all personal computers were 8-bit, meaning that bytes "
"could hold values ranging from 0 to 255.  ASCII codes only went up to 127, "
"so some machines assigned values between 128 and 255 to accented "
"characters.  Different machines had different codes, however, which led to "
"problems exchanging files. Eventually various commonly used sets of values "
"for the 128--255 range emerged. Some were true standards, defined by the "
"International Organization for Standardization, and some were *de facto* "
"conventions that were invented by one company or another and managed to "
"catch on."
msgstr ""
"Dans les années 1980, presque tous les ordinateurs personnels étaient à 8 "
"bits, ce qui signifie que les octets pouvaient contenir des valeurs allant "
"de 0 à 255.  Les codes ASCII allaient seulement jusqu'à 127, alors certaines "
"machines ont assigné les valeurs entre 128 et 255 à des caractères "
"accentués.  Différentes machines avaient des codes différents, cependant, ce "
"qui a conduit à des problèmes d'échange de fichiers. Finalement, divers "
"ensembles de valeurs couramment utilisés pour la gamme 128--255 ont émergé. "
"Certains étaient de véritables normes, définies par l'Organisation "
"internationale de normalisation, et certaines étaient des conventions *de "
"facto* qui ont été inventées par une entreprise ou une autre et qui ont fini "
"par se répandre."

#: ../Doc/howto/unicode.rst:52
msgid ""
"255 characters aren't very many.  For example, you can't fit both the "
"accented characters used in Western Europe and the Cyrillic alphabet used "
"for Russian into the 128--255 range because there are more than 128 such "
"characters."
msgstr ""
"255 caractères, ça n'est pas beaucoup.  Par exemple, vous ne pouvez pas "
"contenir à la fois les caractères accentués utilisés en Europe occidentale "
"et l'alphabet cyrillique utilisé pour le russe dans la gamme 128--255, car "
"il y a plus de 128 de tous ces caractères."

#: ../Doc/howto/unicode.rst:56
msgid ""
"You could write files using different codes (all your Russian files in a "
"coding system called KOI8, all your French files in a different coding "
"system called Latin1), but what if you wanted to write a French document "
"that quotes some Russian text?  In the 1980s people began to want to solve "
"this problem, and the Unicode standardization effort began."
msgstr ""
"Vous pouviez écrire les fichiers avec des codes différents (tous vos "
"fichiers russes dans un système de codage appelé *KOI8*, tous vos fichiers "
"français dans un système de codage différent appelé *Latin1*), mais que "
"faire si vous souhaitiez écrire un document français citant du texte russe ? "
"Dans les années 80, les gens ont commencé à vouloir résoudre ce problème, et "
"les efforts de standardisation Unicode ont commencé."

#: ../Doc/howto/unicode.rst:62
msgid ""
"Unicode started out using 16-bit characters instead of 8-bit characters.  16 "
"bits means you have 2^16 = 65,536 distinct values available, making it "
"possible to represent many different characters from many different "
"alphabets; an initial goal was to have Unicode contain the alphabets for "
"every single human language. It turns out that even 16 bits isn't enough to "
"meet that goal, and the modern Unicode specification uses a wider range of "
"codes, 0 through 1,114,111 ( ``0x10FFFF`` in base 16)."
msgstr ""
"Unicode a commencé par utiliser des caractères 16 bits au lieu de 8 bits. 16 "
"bits signifie que vous avez 2^16 = 65 536 valeurs distinctes disponibles, ce "
"qui permet de représenter de nombreux caractères différents à partir de "
"nombreux alphabets différents. Un des objectifs initiaux était de faire en "
"sorte que Unicode contienne les alphabets de chaque langue humaine. Il "
"s’avère que même 16 bits ne suffisent pas pour atteindre cet objectif, et la "
"spécification Unicode moderne utilise une gamme de codes plus étendue, "
"allant de 0 à 1 114 111 (``0x10FFFF`` en base 16)."

#: ../Doc/howto/unicode.rst:70
msgid ""
"There's a related ISO standard, ISO 10646.  Unicode and ISO 10646 were "
"originally separate efforts, but the specifications were merged with the 1.1 "
"revision of Unicode."
msgstr ""
"Il existe une norme ISO connexe, ISO 10646. Unicode et ISO 10646 étaient à "
"l’origine des efforts séparés, mais les spécifications ont été fusionnées "
"avec la révision 1.1 d’Unicode."

#: ../Doc/howto/unicode.rst:74
msgid ""
"(This discussion of Unicode's history is highly simplified.  The precise "
"historical details aren't necessary for understanding how to use Unicode "
"effectively, but if you're curious, consult the Unicode consortium site "
"listed in the References or the `Wikipedia entry for Unicode <https://en."
"wikipedia.org/wiki/Unicode#History>`_ for more information.)"
msgstr ""
"(Cette discussion sur l’historique d’Unicode est extrêmement simplifiée. Les "
"détails historiques précis ne sont pas nécessaires pour comprendre comment "
"utiliser efficacement Unicode, mais si vous êtes curieux, consultez le site "
"du consortium Unicode indiqué dans les références ou la `page Wikipédia pour "
"Unicode <https://en.wikipedia.org/wiki/Unicode#History>`_ (page en anglais) "
"pour plus d’informations.)"

#: ../Doc/howto/unicode.rst:83
msgid "Definitions"
msgstr "Définitions"

#: ../Doc/howto/unicode.rst:85
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are 'È' and 'Í'.  Characters "
"are abstractions, and vary depending on the language or context you're "
"talking about.  For example, the symbol for ohms (Ω) is usually drawn much "
"like the capital letter omega (Ω) in the Greek alphabet (they may even be "
"the same in some fonts), but these are two different characters that have "
"different meanings."
msgstr ""

#: ../Doc/howto/unicode.rst:93
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point is an integer value, usually denoted in base 16.  In "
"the standard, a code point is written using the notation ``U+12CA`` to mean "
"the character with value ``0x12ca`` (4,810 decimal).  The Unicode standard "
"contains a lot of tables listing characters and their corresponding code "
"points:"
msgstr ""

#: ../Doc/howto/unicode.rst:107
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+12CA``'.  ``U+12CA`` is a code point, which represents some "
"particular character; in this case, it represents the character 'ETHIOPIC "
"SYLLABLE WI'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""

#: ../Doc/howto/unicode.rst:113
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"Un caractère est représenté sur un écran ou sur papier par un ensemble "
"d’éléments graphiques appelé **glyphe**. Le glyphe d’un A majuscule, par "
"exemple, est deux traits diagonaux et un trait horizontal, bien que les "
"détails exacts dépendent de la police utilisée. La plupart du code Python "
"n’a pas besoin de s’inquiéter des glyphes ; trouver le bon glyphe à afficher "
"est généralement le travail d’une boîte à outils GUI ou du moteur de rendu "
"des polices d’un terminal."

#: ../Doc/howto/unicode.rst:122
msgid "Encodings"
msgstr "Encodages"

#: ../Doc/howto/unicode.rst:124
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence needs to be represented as a set of bytes (meaning, values "
"from 0 through 255) in memory.  The rules for translating a Unicode string "
"into a sequence of bytes are called an **encoding**."
msgstr ""

#: ../Doc/howto/unicode.rst:130
msgid ""
"The first encoding you might think of is an array of 32-bit integers.  In "
"this representation, the string \"Python\" would look like this:"
msgstr ""

#: ../Doc/howto/unicode.rst:139
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr ""
"Cette représentation est simple mais son utilisation pose un certain nombre "
"de problèmes."

#: ../Doc/howto/unicode.rst:142
msgid "It's not portable; different processors order the bytes differently."
msgstr ""
"Elle n’est pas portable ; des processeurs différents ordonnent les octets "
"différemment."

#: ../Doc/howto/unicode.rst:144
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points "
"are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"Elle gâche beaucoup d'espace. Dans la plupart des textes, la majorité des "
"points de code sont inférieurs à 127, ou à 255, donc beaucoup d'espace est "
"occupé par des octets ``0x00``. La chaîne ci-dessus occupe 24 octets, à "
"comparer aux 6 octets nécessaires pour une représentation en ASCII. "
"L'utilisation supplémentaire de RAM n'a pas trop d'importance (les "
"ordinateurs de bureau ont des gigaoctets de RAM et les chaînes ne sont "
"généralement pas si grandes que ça), mais l'accroissement de notre "
"utilisation du disque et de la bande passante réseau par un facteur de 4 est "
"intolérable."

#: ../Doc/howto/unicode.rst:152
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new "
"family of wide string functions would need to be used."
msgstr ""
"Elle n’est pas compatible avec les fonctions C existantes telles que "
"``strlen()``, il faudrait donc utiliser une nouvelle famille de fonctions, "
"celle des chaînes larges (*wide strings*)."

#: ../Doc/howto/unicode.rst:155
msgid ""
"Many Internet standards are defined in terms of textual data, and can't "
"handle content with embedded zero bytes."
msgstr ""
"De nombreuses normes Internet sont définies en termes de données textuelles "
"et ne peuvent pas gérer le contenu incorporant des octets *zéro*."

#: ../Doc/howto/unicode.rst:158
msgid ""
"Generally people don't use this encoding, instead choosing other encodings "
"that are more efficient and convenient.  UTF-8 is probably the most commonly "
"supported encoding; it will be discussed below."
msgstr ""
"Généralement, les gens n’utilisent pas cet encodage, mais optent pour "
"d’autres encodages plus efficaces et pratiques. UTF-8 est probablement "
"l’encodage le plus couramment pris en charge ; celui-ci sera abordé ci-"
"dessous."

#: ../Doc/howto/unicode.rst:162
msgid ""
"Encodings don't have to handle every possible Unicode character, and most "
"encodings don't.  The rules for converting a Unicode string into the ASCII "
"encoding, for example, are simple; for each code point:"
msgstr ""
"Les encodages n'ont pas à gérer tous les caractères Unicode possibles, et "
"les plupart ne le font pas. Les règles pour convertir une chaîne Unicode en "
"codage ASCII, par exemple, sont simples. pour chaque point de code :"

#: ../Doc/howto/unicode.rst:166
msgid ""
"If the code point is < 128, each byte is the same as the value of the code "
"point."
msgstr ""
"Si le point de code est < 128, chaque octet est identique à la valeur du "
"point de code."

#: ../Doc/howto/unicode.rst:169
msgid ""
"If the code point is 128 or greater, the Unicode string can't be represented "
"in this encoding.  (Python raises a :exc:`UnicodeEncodeError` exception in "
"this case.)"
msgstr ""
"Si le point de code est égal à 128 ou plus, la chaîne Unicode ne peut pas "
"être représentée dans ce codage (Python déclenche une exception :exc:"
"`UnicodeEncodeError` dans ce cas)."

#: ../Doc/howto/unicode.rst:173
msgid ""
"Latin-1, also known as ISO-8859-1, is a similar encoding.  Unicode code "
"points 0--255 are identical to the Latin-1 values, so converting to this "
"encoding simply requires converting code points to byte values; if a code "
"point larger than 255 is encountered, the string can't be encoded into "
"Latin-1."
msgstr ""
"Latin-1, également connu sous le nom de ISO-8859-1, est un encodage "
"similaire. Les points de code Unicode 0–255 étant identiques aux valeurs de "
"Latin-1, la conversion en cet encodage nécessite simplement la conversion "
"des points de code en octets de même valeur ; si un point de code supérieur "
"à 255 est rencontré, la chaîne ne peut pas être codée en latin-1."

#: ../Doc/howto/unicode.rst:178
msgid ""
"Encodings don't have to be simple one-to-one mappings like Latin-1.  "
"Consider IBM's EBCDIC, which was used on IBM mainframes.  Letter values "
"weren't in one block: 'a' through 'i' had values from 129 to 137, but 'j' "
"through 'r' were 145 through 153.  If you wanted to use EBCDIC as an "
"encoding, you'd probably use some sort of lookup table to perform the "
"conversion, but this is largely an internal detail."
msgstr ""
"Les encodages ne doivent pas nécessairement être de simples mappages un à "
"un, comme Latin-1. Prenons l’exemple du code EBCDIC d’IBM, utilisé sur les "
"ordinateurs centraux IBM. Les valeurs de lettre ne faisaient pas partie d’un "
"bloc: les lettres « a » à « i » étaient comprises entre 129 et 137, mais les "
"lettres « j » à « r » étaient comprises entre 145 et 153. Si vous vouliez "
"utiliser EBCDIC comme encodage, vous auriez probablement utilisé une sorte "
"de table de correspondance pour effectuer la conversion, mais il s’agit en "
"surtout d’un détail d'implémentation."

#: ../Doc/howto/unicode.rst:185
msgid ""
"UTF-8 is one of the most commonly used encodings.  UTF stands for \"Unicode "
"Transformation Format\", and the '8' means that 8-bit numbers are used in "
"the encoding.  (There are also a UTF-16 and UTF-32 encodings, but they are "
"less frequently used than UTF-8.)  UTF-8 uses the following rules:"
msgstr ""

#: ../Doc/howto/unicode.rst:190
msgid ""
"If the code point is < 128, it's represented by the corresponding byte value."
msgstr ""
"Si le point de code est < 128, il est représenté par la valeur de l'octet "
"correspondant."

#: ../Doc/howto/unicode.rst:191
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr ""
"Si le point de code est ≥ 128, il est transformé en une séquence de deux, "
"trois ou quatre octets, où chaque octet de la séquence est compris entre 128 "
"et 255."

#: ../Doc/howto/unicode.rst:194
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 a plusieurs propriétés intéressantes :"

#: ../Doc/howto/unicode.rst:196
msgid "It can handle any Unicode code point."
msgstr "Il peut gérer n'importe quel point de code Unicode."

#: ../Doc/howto/unicode.rst:197
msgid ""
"A Unicode string is turned into a sequence of bytes containing no embedded "
"zero bytes.  This avoids byte-ordering issues, and means UTF-8 strings can "
"be processed by C functions such as ``strcpy()`` and sent through protocols "
"that can't handle zero bytes."
msgstr ""

#: ../Doc/howto/unicode.rst:201
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "Une chaîne de texte ASCII est également un texte UTF-8 valide."

#: ../Doc/howto/unicode.rst:202
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr ""
"UTF-8 est assez compact. La majorité des caractères couramment utilisés "
"peuvent être représentés avec un ou deux octets."

#: ../Doc/howto/unicode.rst:204
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr ""
"Si des octets sont corrompus ou perdus, il est possible de déterminer le "
"début du prochain point de code encodé en UTF-8 et de se resynchroniser. Il "
"est également improbable que des données 8-bits aléatoires ressemblent à du "
"UTF-8 valide."

#: ../Doc/howto/unicode.rst:211 ../Doc/howto/unicode.rst:485
#: ../Doc/howto/unicode.rst:705
msgid "References"
msgstr "Références"

#: ../Doc/howto/unicode.rst:213
msgid ""
"The `Unicode Consortium site <http://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology <http://www.unicode.org/"
"history/>`_ of the origin and development of Unicode is also available on "
"the site."
msgstr ""
"Le site du `Consortium Unicode <http://www.unicode.org>`_, en anglais, a des "
"diagrammes de caractères, un glossaire et des versions PDF de la "
"spécification Unicode. Préparez-vous à une lecture difficile. Une "
"`chronologie <http://www.unicode.org/history/>`_ de l’origine et du "
"développement de l’Unicode est également disponible sur le site."

#: ../Doc/howto/unicode.rst:218
msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://www.cs.tut.fi/~jkorpela/unicode/guide.html>`_ to reading the "
"Unicode character tables."
msgstr ""

#: ../Doc/howto/unicode.rst:222
msgid ""
"Another `good introductory article <http://www.joelonsoftware.com/articles/"
"Unicode.html>`_ was written by Joel Spolsky. If this introduction didn't "
"make things clear to you, you should try reading this alternate article "
"before continuing."
msgstr ""

#: ../Doc/howto/unicode.rst:227
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"Les pages Wikipédia sont souvent utiles ; voir les pages pour « `Codage des "
"caractères <https://fr.wikipedia.org/wiki/Codage_des_caract%C3%A8res>`_ » et "
"`UTF-8 <https://fr.wikipedia.org/wiki/UTF-8>`_, par exemple."

#: ../Doc/howto/unicode.rst:233
msgid "Python's Unicode Support"
msgstr "Prise en charge Unicode de Python"

#: ../Doc/howto/unicode.rst:235
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr ""
"Maintenant que vous avez appris les rudiments de l'Unicode, nous pouvons "
"regarder les fonctionnalités Unicode de Python."

#: ../Doc/howto/unicode.rst:239
msgid "The String Type"
msgstr "Le type *String*"

#: ../Doc/howto/unicode.rst:241
msgid ""
"Since Python 3.0, the language features a :class:`str` type that contain "
"Unicode characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""

#: ../Doc/howto/unicode.rst:245
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr ""
"L'encodage par défaut pour le code source Python est UTF-8, il est donc "
"facile d'inclure des caractères Unicode dans une chaîne littérale ::"

#: ../Doc/howto/unicode.rst:255
msgid ""
"You can use a different encoding from UTF-8 by putting a specially-formatted "
"comment as the first or second line of the source code::"
msgstr ""

#: ../Doc/howto/unicode.rst:260
msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr ""
"Note : Python 3 sait gérer les caractères Unicode dans les identifiants ::"

#: ../Doc/howto/unicode.rst:266
msgid ""
"If you can't enter a particular character in your editor or want to keep the "
"source code ASCII-only for some reason, you can also use escape sequences in "
"string literals. (Depending on your system, you may see the actual capital-"
"delta glyph instead of a \\u escape.) ::"
msgstr ""
"Si vous ne pouvez pas entrer un caractère particulier dans votre éditeur ou "
"si vous voulez garder le code source uniquement en ASCII pour une raison "
"quelconque, vous pouvez également utiliser des séquences d'échappement dans "
"les littéraux de chaîne (en fonction de votre système, il se peut que vous "
"voyiez le glyphe réel du *delta majuscule* au lieu d'une séquence "
"d'échappement ``\\u...``) ::"

#: ../Doc/howto/unicode.rst:278
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"De plus, une chaîne de caractères peut être créée en utilisant la méthode :"
"func:`~bytes.decode` de la classe :class:`bytes`. Cette méthode prend un "
"argument *encoding*, ``UTF-8`` par exemple, et optionnellement un argument "
"*errors*."

#: ../Doc/howto/unicode.rst:282
msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument "
"are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"L'argument *errors* détermine la réponse lorsque la chaîne en entrée ne peut "
"pas être convertie selon les règles de l'encodage. Les valeurs autorisées "
"pour cet argument sont ``'strict'`` (« strict » : lève une exception :exc:"
"`UnicodeDecodeError`), ``'replace'`` (« remplacer » : utilise ``U+FFFD``, "
"``REPLACEMENT CARACTER``), ``'ignore'`` (« ignorer » : n'inclut pas le "
"caractère dans le résultat Unicode) ou ``'backslashreplace'`` (« remplacer "
"avec antislash » : insère une séquence d’échappement ``\\xNN``). Les "
"exemples suivants illustrent les différences ::"

#: ../Doc/howto/unicode.rst:302
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"3.2 comes with roughly 100 different encodings; see the Python Library "
"Reference at :ref:`standard-encodings` for a list.  Some encodings have "
"multiple names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' "
"are all synonyms for the same encoding."
msgstr ""

#: ../Doc/howto/unicode.rst:308
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` built-"
"in function, which takes integers and returns a Unicode string of length 1 "
"that contains the corresponding code point.  The reverse operation is the "
"built-in :func:`ord` function that takes a one-character Unicode string and "
"returns the code point value::"
msgstr ""
"Des chaînes Unicode à un caractère peuvent également être créées avec la "
"fonction native :func:`chr`, qui prend des entiers et renvoie une chaîne "
"Unicode de longueur 1 qui contient le point de code correspondant. "
"L'opération inverse est la fonction native :func:`ord` qui prend une chaîne "
"Unicode d'un caractère et renvoie la valeur du point de code ::"

#: ../Doc/howto/unicode.rst:320
msgid "Converting to Bytes"
msgstr "Conversion en octets"

#: ../Doc/howto/unicode.rst:322
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
"La méthode inverse de :meth:`bytes.decode` est :meth:`str.encode`, qui "
"renvoie une représentation :class:`bytes` de la chaîne Unicode, codée dans "
"l’encodage *encoding* demandé."

#: ../Doc/howto/unicode.rst:326
msgid ""
"The *errors* parameter is the same as the parameter of the :meth:`~bytes."
"decode` method but supports a few more possible handlers. As well as "
"``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case inserts a "
"question mark instead of the unencodable character), there is also "
"``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"Le paramètre *errors* est le même que le paramètre de la méthode :meth:"
"`~bytes.decode` mais possède quelques gestionnaires supplémentaires. En plus "
"de ``'strict'``, ``'ignore'`` et ``'remplace'`` (qui dans ce cas insère un "
"point d'interrogation au lieu du caractère non codable), il y a aussi "
"``'xmlcharrefreplace'`` (insère une référence XML), ``backslashreplace`` "
"(insère une séquence ``\\uNNNN``) et ``namereplace`` (insère une séquence ``"
"\\N{...}``)."

#: ../Doc/howto/unicode.rst:334
msgid "The following example shows the different results::"
msgstr "L'exemple suivant montre les différents résultats ::"

#: ../Doc/howto/unicode.rst:355
msgid ""
"The low-level routines for registering and accessing the available encodings "
"are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"Les routines de bas niveau pour enregistrer et accéder aux encodages "
"disponibles se trouvent dans le module :mod:`codecs`. L'implémentation de "
"nouveaux encodages nécessite également de comprendre le module :mod:"
"`codecs`. Cependant, les fonctions d'encodage et de décodage renvoyées par "
"ce module sont généralement de bas-niveau pour être facilement utilisées et "
"l'écriture de nouveaux encodages est une tâche très spécialisée, donc le "
"module ne sera pas couvert dans ce guide."

#: ../Doc/howto/unicode.rst:364
msgid "Unicode Literals in Python Source Code"
msgstr "Littéraux Unicode dans le code source Python"

#: ../Doc/howto/unicode.rst:366
msgid ""
"In Python source code, specific Unicode code points can be written using the "
"``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"Dans le code source Python, des points de code Unicode spécifiques peuvent "
"être écrits en utilisant la séquence d'échappement ``\\u``, suivie de quatre "
"chiffres hexadécimaux donnant le point de code. La séquence d'échappement ``"
"\\U`` est similaire, mais attend huit chiffres hexadécimaux, pas quatre ::"

#: ../Doc/howto/unicode.rst:378
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as "
"you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"L'utilisation de séquences d'échappement pour des points de code supérieurs "
"à 127 est acceptable à faible dose, mais devient gênante si vous utilisez "
"beaucoup de caractères accentués, comme c'est le cas dans un programme avec "
"des messages en français ou dans une autre langue utilisant des lettres "
"accentuées. Vous pouvez également assembler des chaînes de caractères à "
"l'aide de la fonction native :func:`chr`, mais c'est encore plus fastidieux."

#: ../Doc/howto/unicode.rst:384
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"Idéalement, vous devriez être capable d'écrire des littéraux dans l'encodage "
"naturel de votre langue. Vous pourriez alors éditer le code source de Python "
"avec votre éditeur favori qui affiche les caractères accentués "
"naturellement, et a les bons caractères utilisés au moment de l'exécution."

#: ../Doc/howto/unicode.rst:389
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by "
"including a special comment as either the first or second line of the source "
"file::"
msgstr ""
"Python considère que le code source est écrit en UTF-8 par défaut, mais vous "
"pouvez utiliser presque n'importe quel encodage si vous déclarez l'encodage "
"utilisé. Cela se fait en incluant un commentaire spécial sur la première ou "
"la deuxième ligne du fichier source ::"

#: ../Doc/howto/unicode.rst:399
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to "
"a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"La syntaxe s'inspire de la notation d'*Emacs* pour spécifier les variables "
"locales à un fichier. *Emacs* supporte de nombreuses variables différentes, "
"mais Python ne gère que *coding*. Les symboles ``-*-`` indiquent à *Emacs* "
"que le commentaire est spécial ; ils n'ont aucune signification pour Python "
"mais sont une convention. Python cherche ``coding: name`` ou ``coding=name`` "
"dans le commentaire."

#: ../Doc/howto/unicode.rst:405
msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8 "
"as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"Si vous n'incluez pas un tel commentaire, l'encodage par défaut est UTF-8 "
"comme déjà mentionné. Voir aussi la :pep:`263` pour plus d'informations."

#: ../Doc/howto/unicode.rst:410
msgid "Unicode Properties"
msgstr "Propriétés Unicode"

#: ../Doc/howto/unicode.rst:412
msgid ""
"The Unicode specification includes a database of information about code "
"points. For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (Unicode has "
"characters representing the Roman numerals and fractions such as one-third "
"and four-fifths).  There are also properties related to the code point's use "
"in bidirectional text and other display-related properties."
msgstr ""

#: ../Doc/howto/unicode.rst:419
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr ""
"Le programme suivant affiche des informations sur plusieurs caractères et "
"affiche la valeur numérique d'un caractère particulier ::"

#: ../Doc/howto/unicode.rst:433
msgid "When run, this prints:"
msgstr "Si vous l'exécutez, cela affiche :"

#: ../Doc/howto/unicode.rst:444
msgid ""
"The category codes are abbreviations describing the nature of the character. "
"These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation <http://www."
"unicode.org/reports/tr44/#General_Category_Values>`_ for a list of category "
"codes."
msgstr ""
"Les codes de catégorie sont des abréviations décrivant la nature du "
"caractère. Celles-ci sont regroupées en catégories telles que « Lettre », "
"« Nombre », « Ponctuation » ou « Symbole », qui sont à leur tour divisées en "
"sous-catégories. Pour prendre par exemple les codes de la sortie ci-dessus, "
"``'Ll'`` signifie « Lettre, minuscules », ``'No'`` signifie « Nombre, "
"autre », ``'Mn'`` est « Marque, non-espaçant », et ``'So'`` est « Symbole, "
"autre ». Voir la section `Valeurs générales des catégories de la "
"documentation de la base de données de caractères Unicode <http://www."
"unicode.org/reports/tr44/#General_Category_Values>`_ (ressource en anglais) "
"pour une liste de codes de catégories."

#: ../Doc/howto/unicode.rst:455
msgid "Unicode Regular Expressions"
msgstr "Expressions régulières Unicode"

#: ../Doc/howto/unicode.rst:457
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as "
"``\\d`` and ``\\w`` have different meanings depending on whether the pattern "
"is supplied as bytes or a string.  For example, ``\\d`` will match the "
"characters ``[0-9]`` in bytes but in strings will match any character that's "
"in the ``'Nd'`` category."
msgstr ""
"Les expressions régulières gérées par le module :mod:`re` peuvent être "
"fournies sous forme de chaîne d'octets ou de texte. Certaines séquences de "
"caractères spéciaux telles que ``\\d`` et ``\\w`` ont des significations "
"différentes selon que le motif est fourni en octets ou en texte. Par "
"exemple, ``\\d`` correspond aux caractères ``[0-9]`` en octets mais dans les "
"chaînes de caractères correspond à tout caractère de la catégorie ``'Nd'``."

#: ../Doc/howto/unicode.rst:464
msgid ""
"The string in this example has the number 57 written in both Thai and Arabic "
"numerals::"
msgstr ""
"Dans cet exemple, la chaîne contient le nombre 57 écrit en chiffres arabes "
"et thaïlandais ::"

#: ../Doc/howto/unicode.rst:474
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If "
"you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will "
"match the substring \"57\" instead."
msgstr ""
"Une fois exécuté, ``\\d+`` correspond aux chiffres thaïlandais et les "
"affiche. Si vous fournissez le drapeau :const:`re.ASCII` à :func:`~re."
"compile`, ``\\d+`` correspond cette fois à la chaîne \"57\"."

#: ../Doc/howto/unicode.rst:478
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"De même, ``\\w`` correspond à une grande variété de caractères Unicode mais "
"seulement ``[a-zA-Z0-9_]`` en octets (ou si :const:`re.ASCII` est fourni) et "
"``\\s`` correspond soit aux caractères blancs Unicode soit aux caractères "
"``[ \\t\\n\\r\\f\\v]``."

#: ../Doc/howto/unicode.rst:489
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr ""
"Quelques bonnes discussions alternatives sur la gestion d'Unicode par Python "
"sont :"

#: ../Doc/howto/unicode.rst:491
msgid ""
"`Processing Text Files in Python 3 <http://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, by Nick Coghlan."
msgstr ""
"`Processing Text Files in Python 3 <http://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, par Nick Coghlan."

#: ../Doc/howto/unicode.rst:492
msgid ""
"`Pragmatic Unicode <http://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""

#: ../Doc/howto/unicode.rst:494
msgid ""
"The :class:`str` type is described in the Python library reference at :ref:"
"`textseq`."
msgstr ""
"Le type :class:`str` est décrit dans la référence de la bibliothèque Python "
"à :ref:`textseq`."

#: ../Doc/howto/unicode.rst:497
msgid "The documentation for the :mod:`unicodedata` module."
msgstr "La documentation du module :mod:`unicodedata`."

#: ../Doc/howto/unicode.rst:499
msgid "The documentation for the :mod:`codecs` module."
msgstr "La documentation du module :mod:`codecs`."

#: ../Doc/howto/unicode.rst:501
msgid ""
"Marc-André Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"Marc-André Lemburg a donné une présentation intitulée `« Python et "
"Unicode » (diapositives PDF) <https://downloads.egenix.com/python/Unicode-"
"EPC2002-Talk.pdf>`_ à *EuroPython* 2002. Les diapositives sont un excellent "
"aperçu de la conception des fonctionnalités Unicode de Python 2 (où le type "
"de chaîne Unicode est appelé ``unicode`` et les littéraux commencent par "
"``u``)."

#: ../Doc/howto/unicode.rst:509
msgid "Reading and Writing Unicode Data"
msgstr "Lecture et écriture de données Unicode"

#: ../Doc/howto/unicode.rst:511
msgid ""
"Once you've written some code that works with Unicode data, the next problem "
"is input/output.  How do you get Unicode strings into your program, and how "
"do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"Une fois que vous avez écrit du code qui fonctionne avec des données "
"Unicode, le problème suivant concerne les entrées/sorties. Comment obtenir "
"des chaînes Unicode dans votre programme et comment convertir les chaînes "
"Unicode dans une forme appropriée pour le stockage ou la transmission ?"

#: ../Doc/howto/unicode.rst:515
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used "
"in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"Il est possible que vous n'ayez rien à faire en fonction de vos sources "
"d'entrée et des destinations de vos données de sortie ; il convient de "
"vérifier si les bibliothèques utilisées dans votre application gèrent "
"l'Unicode nativement. Par exemple, les analyseurs XML renvoient souvent des "
"données Unicode. De nombreuses bases de données relationnelles prennent "
"également en charge les colonnes encodées en Unicode et peuvent renvoyer des "
"valeurs Unicode à partir d'une requête SQL."

#: ../Doc/howto/unicode.rst:521
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"Les données Unicode sont généralement converties en un encodage particulier "
"avant d'être écrites sur le disque ou envoyées sur un connecteur réseau. Il "
"est possible de faire tout le travail vous-même : ouvrir un fichier, lire un "
"élément 8-bits, puis convertir les octets avec ``bytes.decode(encoding)``. "
"Cependant, l'approche manuelle n'est pas recommandée."

#: ../Doc/howto/unicode.rst:526
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can "
"be represented by several bytes.  If you want to read the file in arbitrary-"
"sized chunks (say, 1024 or 4096 bytes), you need to write error-handling "
"code to catch the case where only part of the bytes encoding a single "
"Unicode character are read at the end of a chunk.  One solution would be to "
"read the entire file into memory and then perform the decoding, but that "
"prevents you from working with files that are extremely large; if you need "
"to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for at "
"least a moment you'd need to have both the encoded string and its Unicode "
"version in memory.)"
msgstr ""
"La nature multi-octets des encodages pose problème ; un caractère Unicode "
"peut être représenté par plusieurs octets. Si vous voulez lire le fichier "
"par morceaux de taille arbitraire (disons 1024 ou 4096 octets), vous devez "
"écrire un code de gestion des erreurs pour détecter le cas où une partie "
"seulement des octets codant un seul caractère Unicode est lue à la fin d'un "
"morceau. Une solution serait de lire le fichier entier en mémoire et "
"d'effectuer le décodage, mais cela vous empêche de travailler avec des "
"fichiers extrêmement volumineux ; si vous avez besoin de lire un fichier de "
"2 Gio, vous avez besoin de 2 Gio de RAM (plus que ça, en fait, puisque "
"pendant un moment, vous aurez besoin d'avoir à la fois la chaîne encodée et "
"sa version Unicode en mémoire)."

#: ../Doc/howto/unicode.rst:536
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already "
"been done for you: the built-in :func:`open` function can return a file-like "
"object that assumes the file's contents are in a specified encoding and "
"accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in :"
"meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""
"La solution serait d'utiliser l'interface de décodage de bas-niveau pour "
"intercepter le cas des séquences d'encodage incomplètes. Ce travail "
"d'implémentation a déjà été fait pour vous : la fonction native :func:`open` "
"peut renvoyer un objet de type fichier qui suppose que le contenu du fichier "
"est dans un encodage spécifié et accepte les paramètres Unicode pour des "
"méthodes telles que :meth:`~io.TextIOBase.read` et :meth:`~io.TextIOBase."
"write`. Ceci fonctionne grâce aux paramètres *encoding* et *errors* de :func:"
"`open` qui sont interprétés comme ceux de :meth:`str.encode` et :meth:`bytes."
"decode`."

#: ../Doc/howto/unicode.rst:545
msgid "Reading Unicode from a file is therefore simple::"
msgstr "Lire de l'Unicode à partir d'un fichier est donc simple ::"

#: ../Doc/howto/unicode.rst:551
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr ""
"Il est également possible d'ouvrir des fichiers en mode « mise à jour », "
"permettant à la fois la lecture et l'écriture ::"

#: ../Doc/howto/unicode.rst:559
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"Le caractère Unicode ``U+FEFFF`` est utilisé comme marque pour indiquer le "
"boutisme (c'est-à-dire l'ordre dans lequel les octets sont placés pour "
"indiquer une valeur sur plusieurs octets, *byte-order mark* en anglais ou "
"*BOM*), et est souvent écrit en tête (premier caractère) d'un fichier afin "
"d'aider à l'auto-détection du boutisme du fichier. Certains encodages, comme "
"UTF-16, s'attendent à ce qu'une *BOM* soit présente au début d'un fichier ; "
"lorsqu'un tel encodage est utilisé, la *BOM* sera automatiquement écrite "
"comme premier caractère et sera silencieusement retirée lorsque le fichier "
"sera lu. Il existe des variantes de ces encodages, comme ``utf-16-le`` et "
"``utf-16-be`` pour les encodages petit-boutiste et gros-boutiste, qui "
"spécifient un ordre d'octets donné et ne sautent pas la *BOM*."

#: ../Doc/howto/unicode.rst:568
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  Use "
"the 'utf-8-sig' codec to automatically skip the mark if present for reading "
"such files."
msgstr ""

#: ../Doc/howto/unicode.rst:576
msgid "Unicode filenames"
msgstr "Noms de fichiers Unicode"

#: ../Doc/howto/unicode.rst:578
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  For example, Mac OS X uses UTF-8 while Windows uses a "
"configurable encoding; on Windows, Python uses the name \"mbcs\" to refer to "
"whatever the currently configured encoding is.  On Unix systems, there will "
"only be a filesystem encoding if you've set the ``LANG`` or ``LC_CTYPE`` "
"environment variables; if you haven't, the default encoding is UTF-8."
msgstr ""

#: ../Doc/howto/unicode.rst:587
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
"La fonction :func:`sys.getfilesystemencoding` renvoie l'encodage à utiliser "
"sur votre système actuel, au cas où vous voudriez faire l'encodage "
"manuellement, mais il n'y a pas vraiment de raisons de s'embêter avec ça. "
"Lors de l'ouverture d'un fichier pour la lecture ou l'écriture, vous pouvez "
"généralement simplement fournir la chaîne Unicode comme nom de fichier et "
"elle est automatiquement convertie à l'encodage qui convient ::"

#: ../Doc/howto/unicode.rst:597
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ""
"Les fonctions du module :mod:`os` telles que :func:`os.stat` acceptent "
"également les noms de fichiers Unicode."

#: ../Doc/howto/unicode.rst:600
msgid ""
"The :func:`os.listdir` function returns filenames and raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes "
"containing the encoded versions?  :func:`os.listdir` will do both, depending "
"on whether you provided the directory path as bytes or a Unicode string.  If "
"you pass a Unicode string as the path, filenames will be decoded using the "
"filesystem's encoding and a list of Unicode strings will be returned, while "
"passing a byte path will return the filenames as bytes.  For example, "
"assuming the default filesystem encoding is UTF-8, running the following "
"program::"
msgstr ""

#: ../Doc/howto/unicode.rst:618
msgid "will produce the following output:"
msgstr "produit la sortie suivante :"

#: ../Doc/howto/unicode.rst:626
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr ""
"La première liste contient les noms de fichiers encodés en UTF-8 et la "
"seconde contient les versions Unicode."

#: ../Doc/howto/unicode.rst:629
msgid ""
"Note that on most occasions, the Unicode APIs should be used.  The bytes "
"APIs should only be used on systems where undecodable file names can be "
"present, i.e. Unix systems."
msgstr ""

#: ../Doc/howto/unicode.rst:635
msgid "Tips for Writing Unicode-aware Programs"
msgstr "Conseils pour écrire des programmes compatibles Unicode"

#: ../Doc/howto/unicode.rst:637
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr ""
"Cette section fournit quelques suggestions sur l'écriture de logiciels qui "
"traitent de l'Unicode."

#: ../Doc/howto/unicode.rst:640
msgid "The most important tip is:"
msgstr "Le conseil le plus important est :"

#: ../Doc/howto/unicode.rst:642
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr ""
"Il convient que le logiciel ne traite que des chaînes Unicode en interne, "
"décodant les données d'entrée dès que possible et encodant la sortie "
"uniquement à la fin."

#: ../Doc/howto/unicode.rst:645
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""
"Si vous essayez d'écrire des fonctions de traitement qui acceptent à la fois "
"les chaînes Unicode et les chaînes d'octets, les possibilités d'occurrences "
"de bogues dans votre programme augmentent partout où vous combinez les deux "
"différents types de chaînes. Il n'y a pas d'encodage ou de décodage "
"automatique : si vous faites par exemple ``str + octets``, une :exc:"
"`TypeError` est levée."

#: ../Doc/howto/unicode.rst:650
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using "
"the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"Lors de l'utilisation de données provenant d'un navigateur Web ou d'une "
"autre source non fiable, une technique courante consiste à vérifier la "
"présence de caractères illégaux dans une chaîne de caractères avant de "
"l'utiliser pour générer une ligne de commande ou de la stocker dans une base "
"de données. Si vous le faites, vérifiez bien la chaîne décodée, pas les "
"données d'octets codés ; certains encodages peuvent avoir des propriétés "
"intéressantes, comme ne pas être bijectifs ou ne pas être entièrement "
"compatibles avec l'ASCII. C'est particulièrement vrai si l'encodage est "
"spécifié explicitement dans vos données d'entrée, car l'attaquant peut alors "
"choisir un moyen intelligent de cacher du texte malveillant dans le flux de "
"données encodé."

#: ../Doc/howto/unicode.rst:661
msgid "Converting Between File Encodings"
msgstr "Conversion entre les encodages de fichiers"

#: ../Doc/howto/unicode.rst:663
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""
"La classe :class:`~codecs.StreamRecoder` peut convertir de manière "
"transparente entre les encodages : prenant un flux qui renvoie des données "
"dans l'encodage #1, elle se comporte comme un flux qui renvoie des données "
"dans l'encodage #2."

#: ../Doc/howto/unicode.rst:667
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""
"Par exemple, si vous avez un fichier d'entrée *f* qui est en Latin-1, vous "
"pouvez l'encapsuler dans un :class:`~codecs.StreamRecoder` pour qu'il "
"renvoie des octets encodés en UTF-8 ::"

#: ../Doc/howto/unicode.rst:681
msgid "Files in an Unknown Encoding"
msgstr "Fichiers dans un encodage inconnu"

#: ../Doc/howto/unicode.rst:683
msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want "
"to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""
"Vous avez besoin de modifier un fichier, mais vous ne connaissez pas son "
"encodage ? Si vous savez que l'encodage est compatible ASCII et que vous "
"voulez seulement examiner ou modifier les parties ASCII, vous pouvez ouvrir "
"le fichier avec le gestionnaire d'erreurs ``surrogateescape`` ::"

#: ../Doc/howto/unicode.rst:697
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in the Unicode Private Use Area ranging from U+DC80 to U+DCFF.  "
"These private code points will then be turned back into the same bytes when "
"the ``surrogateescape`` error handler is used when encoding the data and "
"writing it back out."
msgstr ""

#: ../Doc/howto/unicode.rst:707
msgid ""
"One section of `Mastering Python 3 Input/Output <http://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, a PyCon 2010 talk by David "
"Beazley, discusses text processing and binary data handling."
msgstr ""
"Une partie de la conférence `Mastering Python 3 Input/Output <http://pyvideo."
"org/video/289/pycon-2010--mastering-python-3-i-o>`_ (ressource en anglais), "
"donnée lors de *PyCon* 2010 de David Beazley, parle du traitement de texte "
"et du traitement des données binaires."

#: ../Doc/howto/unicode.rst:711
msgid ""
"The `PDF slides for Marc-André Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ discuss questions of "
"character encodings as well as how to internationalize and localize an "
"application.  These slides cover Python 2.x only."
msgstr ""
"Le `PDF du diaporama de la présentation de Marc-André Lemburg \"Writing "
"Unicodeaware Applications in Python\" <https://downloads.egenix.com/python/"
"LSM2005-Developing-Unicode-aware-applications-in-Python.pdf>`_ (ressource en "
"anglais) traite des questions d'encodage de caractères ainsi que de "
"l'internationalisation et de la localisation d'une application. Ces "
"diapositives ne couvrent que Python 2.x."

#: ../Doc/howto/unicode.rst:717
msgid ""
"`The Guts of Unicode in Python <http://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"`The Guts of Unicode in Python <http://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ (ressource en anglais) est une conférence *PyCon* 2013 "
"donnée par Benjamin Peterson qui traite de la représentation interne Unicode "
"en Python 3.3."

#: ../Doc/howto/unicode.rst:724
msgid "Acknowledgements"
msgstr "Remerciements"

#: ../Doc/howto/unicode.rst:726
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"La première ébauche de ce document a été rédigée par Andrew Kuchling. Il a "
"depuis été révisé par Alexander Belopolsky, Georg Brandl, Andrew Kuchling et "
"Ezio Melotti."

#: ../Doc/howto/unicode.rst:730
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: Éric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-André Lemburg, Martin von Löwis, "
"Terry J. Reedy, Chad Whitacre."
msgstr ""
