# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2023-03-26 17:48+0200\n"
"Last-Translator: Mathieu Dupuy\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "Guide Unicode"

#: howto/unicode.rst:0
msgid "Release"
msgstr "Version"

#: howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: howto/unicode.rst:9
msgid ""
"This HOWTO discusses Python's support for the Unicode specification for "
"representing textual data, and explains various problems that people "
"commonly encounter when trying to work with Unicode."
msgstr ""
"Ce guide d√©crit la gestion de la sp√©cification Unicode par Python pour les "
"donn√©es textuelles et explique les diff√©rents probl√®mes g√©n√©ralement "
"rencontr√©s par les utilisateurs qui travaillent avec Unicode."

#: howto/unicode.rst:15
msgid "Introduction to Unicode"
msgstr "Introduction √† Unicode"

#: howto/unicode.rst:18
msgid "Definitions"
msgstr "D√©finitions"

#: howto/unicode.rst:20
msgid ""
"Today's programs need to be able to handle a wide variety of characters.  "
"Applications are often internationalized to display messages and output in a "
"variety of user-selectable languages; the same program might need to output "
"an error message in English, French, Japanese, Hebrew, or Russian.  Web "
"content can be written in any of these languages and can also include a "
"variety of emoji symbols. Python's string type uses the Unicode Standard for "
"representing characters, which lets Python programs work with all these "
"different possible characters."
msgstr ""
"Les programmes d'aujourd'hui doivent √™tre capables de traiter une grande "
"vari√©t√© de caract√®res. Les applications sont souvent internationalis√©es pour "
"afficher les messages et les r√©sultats dans une vari√©t√© de langues "
"s√©lectionnables par l'utilisateur¬†; le m√™me programme peut avoir besoin "
"d'afficher un message d'erreur en anglais, fran√ßais, japonais, h√©breu ou "
"russe. Le contenu Web peut √™tre √©crit dans n'importe laquelle de ces langues "
"et peut √©galement inclure une vari√©t√© de symboles √©moji. Le type de cha√Æne "
"de caract√®res de Python utilise le standard Unicode pour repr√©senter les "
"caract√®res, ce qui permet aux programmes Python de travailler avec tous ces "
"diff√©rents caract√®res possibles."

#: howto/unicode.rst:30
msgid ""
"Unicode (https://www.unicode.org/) is a specification that aims to list "
"every character used by human languages and give each character its own "
"unique code.  The Unicode specifications are continually revised and updated "
"to add new languages and symbols."
msgstr ""
"Unicode (https://www.unicode.org/) est une sp√©cification qui vise √† lister "
"tous les caract√®res utilis√©s par les langues humaines et √† donner √† chaque "
"caract√®re son propre code unique. Les sp√©cifications Unicode sont "
"continuellement r√©vis√©es et mises √† jour pour ajouter de nouvelles langues "
"et de nouveaux symboles."

#: howto/unicode.rst:35
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are '√à' and '√ç'.  Characters "
"vary depending on the language or context you're talking about.  For "
"example, there's a character for \"Roman Numeral One\", '‚Ö†', that's separate "
"from the uppercase letter 'I'.  They'll usually look the same, but these are "
"two different characters that have different meanings."
msgstr ""
"Un **caract√®re** est le plus petit composant possible d'un texte. ¬´¬†A¬†¬ª, "
"¬´¬†B¬†¬ª, ¬´¬†C¬†¬ª, etc. sont tous des caract√®res diff√©rents. Il en va de m√™me "
"pour ¬´¬†√à¬†¬ª et ¬´¬†√ç¬†¬ª. Les caract√®res varient selon la langue ou le contexte "
"dont vous parlez. Par exemple, il y a un caract√®re pour ¬´¬†Chiffre Romain "
"Un¬†¬ª (*Roman Numeral One*), ¬´¬†‚Ö†¬†¬ª, qui est s√©par√© de la lettre majuscule "
"¬´¬†I¬†¬ª. Ils se ressemblent g√©n√©ralement, mais ce sont deux caract√®res "
"diff√©rents qui ont des significations diff√©rentes."

#: howto/unicode.rst:42
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point value is an integer in the range 0 to 0x10FFFF "
"(about 1.1 million values, the `actual number assigned <https://www.unicode."
"org/versions/latest/#Summary>`_ is less than that). In the standard and in "
"this document, a code point is written using the notation ``U+265E`` to mean "
"the character with value ``0x265e`` (9,822 in decimal)."
msgstr ""
"Le standard Unicode d√©crit comment les caract√®res sont repr√©sent√©s par les "
"**points de code**. Une valeur de point de code est un nombre entier compris "
"entre ``0`` et ``0x10FFFF`` (environ 1,1 million de valeurs possibles, le "
"`nombre de valeurs r√©ellement assign√©es <https://www.unicode.org/versions/"
"latest/#Summary>`_ est inf√©rieur √† ce nombre). Dans le standard et dans le "
"pr√©sent document, un point de code est √©crit en utilisant la notation "
"``U+265E`` pour d√©signer le caract√®re avec la valeur ``0x265e`` (9¬†822 en "
"d√©cimal)."

#: howto/unicode.rst:50
msgid ""
"The Unicode standard contains a lot of tables listing characters and their "
"corresponding code points:"
msgstr ""
"La standard Unicode contient de nombreux tableaux contenant la liste des "
"caract√®res et des points de code correspondants¬†:"

#: howto/unicode.rst:53
msgid ""
"0061    'a'; LATIN SMALL LETTER A\n"
"0062    'b'; LATIN SMALL LETTER B\n"
"0063    'c'; LATIN SMALL LETTER C\n"
"...\n"
"007B    '{'; LEFT CURLY BRACKET\n"
"...\n"
"2167    '‚Öß'; ROMAN NUMERAL EIGHT\n"
"2168    '‚Ö®'; ROMAN NUMERAL NINE\n"
"...\n"
"265E    '‚ôû'; BLACK CHESS KNIGHT\n"
"265F    '‚ôü'; BLACK CHESS PAWN\n"
"...\n"
"1F600   'üòÄ'; GRINNING FACE\n"
"1F609   'üòâ'; WINKING FACE\n"
"..."
msgstr ""

#: howto/unicode.rst:71
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+265E``'.  ``U+265E`` is a code point, which represents some "
"particular character; in this case, it represents the character 'BLACK CHESS "
"KNIGHT', '‚ôû'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""
"√Ä proprement parler, ces d√©finitions laissent entendre qu'il est inutile de "
"dire ¬´¬†c'est le caract√®re ``U+265E``¬†¬ª. ``U+265E`` est un point de code, qui "
"repr√©sente un caract√®re particulier¬†; dans ce cas, il repr√©sente le "
"caract√®re ¬´¬†BLACK CHESS KNIGHT¬†¬ª, ¬´¬†‚ôû¬†¬ª. Dans des contextes informels, cette "
"distinction entre les points de code et les caract√®res sera parfois oubli√©e."

#: howto/unicode.rst:78
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"Un caract√®re est repr√©sent√© sur un √©cran ou sur papier par un ensemble "
"d‚Äô√©l√©ments graphiques appel√© **glyphe**. Le glyphe d‚Äôun A majuscule, par "
"exemple, est deux traits diagonaux et un trait horizontal, bien que les "
"d√©tails exacts d√©pendent de la police utilis√©e. La plupart du code Python "
"n‚Äôa pas besoin de s‚Äôinqui√©ter des glyphes¬†; trouver le bon glyphe √† afficher "
"est g√©n√©ralement le travail d‚Äôune bo√Æte √† outils GUI ou du moteur de rendu "
"des polices d‚Äôun terminal."

#: howto/unicode.rst:87
msgid "Encodings"
msgstr "Encodages"

#: howto/unicode.rst:89
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence of code points needs to be represented in memory as a set of "
"**code units**, and **code units** are then mapped to 8-bit bytes.  The "
"rules for translating a Unicode string into a sequence of bytes are called a "
"**character encoding**, or just an **encoding**."
msgstr ""
"Pour r√©sumer la section pr√©c√©dente¬†: une cha√Æne Unicode est une s√©quence de "
"points de code, qui sont des nombres de ``0`` √† ``0x10FFFF`` (1¬†114¬†111 en "
"d√©cimal). Cette s√©quence de points de code doit √™tre stock√©e en m√©moire sous "
"la forme d'un ensemble de **unit√©s de code**, et les **unit√©s de code** sont "
"ensuite transpos√©es en octets de 8 bits. Les r√®gles de traduction d'une "
"cha√Æne Unicode en une s√©quence d'octets sont appel√©es un **encodage de "
"caract√®res** ou simplement un **encodage**."

#: howto/unicode.rst:97
msgid ""
"The first encoding you might think of is using 32-bit integers as the code "
"unit, and then using the CPU's representation of 32-bit integers. In this "
"representation, the string \"Python\" might look like this:"
msgstr ""
"Le premier encodage auquel vous pouvez penser est l'utilisation d'entiers 32 "
"bits comme unit√© de code, puis l'utilisation de la repr√©sentation des "
"entiers 32 bits par le CPU. Dans cette repr√©sentation, la cha√Æne ¬´¬†Python¬†¬ª "
"ressemblerait √† ceci¬†:"

#: howto/unicode.rst:101
msgid ""
"   P           y           t           h           o           n\n"
"0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00\n"
"   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"
msgstr ""

#: howto/unicode.rst:107
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr ""
"Cette repr√©sentation est simple mais son utilisation pose un certain nombre "
"de probl√®mes."

#: howto/unicode.rst:110
msgid "It's not portable; different processors order the bytes differently."
msgstr ""
"Elle n‚Äôest pas portable¬†; des processeurs diff√©rents ordonnent les octets "
"diff√©remment."

#: howto/unicode.rst:112
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points "
"are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"Elle g√¢che beaucoup d'espace. Dans la plupart des textes, la majorit√© des "
"points de code sont inf√©rieurs √† 127, ou √† 255, donc beaucoup d'espace est "
"occup√© par des octets ``0x00``. La cha√Æne ci-dessus occupe 24 octets, √† "
"comparer aux 6 octets n√©cessaires pour une repr√©sentation en ASCII. "
"L'utilisation suppl√©mentaire de RAM n'a pas trop d'importance (les "
"ordinateurs de bureau ont des gigaoctets de RAM et les cha√Ænes ne sont "
"g√©n√©ralement pas si grandes que √ßa), mais l'accroissement de notre "
"utilisation du disque et de la bande passante r√©seau par un facteur de 4 est "
"intol√©rable."

#: howto/unicode.rst:120
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new "
"family of wide string functions would need to be used."
msgstr ""
"Elle n‚Äôest pas compatible avec les fonctions C existantes telles que "
"``strlen()``, il faudrait donc utiliser une nouvelle famille de fonctions, "
"celle des cha√Ænes larges (*wide strings*)."

#: howto/unicode.rst:123
msgid ""
"Therefore this encoding isn't used very much, and people instead choose "
"other encodings that are more efficient and convenient, such as UTF-8."
msgstr ""
"Par cons√©quent, cet encodage n'est pas tr√®s utilis√© et d'autres encodages, "
"plus efficaces et pratiques comme UTF-8, sont plut√¥t choisis."

#: howto/unicode.rst:126
msgid ""
"UTF-8 is one of the most commonly used encodings, and Python often defaults "
"to using it.  UTF stands for \"Unicode Transformation Format\", and the '8' "
"means that 8-bit values are used in the encoding.  (There are also UTF-16 "
"and UTF-32 encodings, but they are less frequently used than UTF-8.)  UTF-8 "
"uses the following rules:"
msgstr ""
"UTF-8 est l‚Äôun des encodages les plus couramment utilis√©s et Python "
"l‚Äôutilise souvent par d√©faut. UTF signifie ¬´¬†Unicode Transformation Format¬†¬ª "
"(format de transformation Unicode) et ¬´¬†8¬†¬ª signifie que des nombres √† 8 "
"bits sont utilis√©s dans l'encodage (il existe √©galement des codages UTF-16 "
"et UTF-32, mais ils sont moins souvent utilis√©s que UTF-8). UTF-8 utilise "
"les r√®gles suivantes¬†:"

#: howto/unicode.rst:132
msgid ""
"If the code point is < 128, it's represented by the corresponding byte value."
msgstr ""
"Si le point de code est < 128, il est repr√©sent√© par la valeur de l'octet "
"correspondant."

#: howto/unicode.rst:133
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr ""
"Si le point de code est ‚â• 128, il est transform√© en une s√©quence de deux, "
"trois ou quatre octets, o√π chaque octet de la s√©quence est compris entre 128 "
"et 255."

#: howto/unicode.rst:136
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 a plusieurs propri√©t√©s int√©ressantes¬†:"

#: howto/unicode.rst:138
msgid "It can handle any Unicode code point."
msgstr "Il peut g√©rer n'importe quel point de code Unicode."

#: howto/unicode.rst:139
msgid ""
"A Unicode string is turned into a sequence of bytes that contains embedded "
"zero bytes only where they represent the null character (U+0000). This means "
"that UTF-8 strings can be processed by C functions such as ``strcpy()`` and "
"sent through protocols that can't handle zero bytes for anything other than "
"end-of-string markers."
msgstr ""
"Une cha√Æne Unicode est transform√©e en une s√©quence d‚Äôoctets qui contient des "
"octets z√©ro uniquement lorsqu‚Äôils repr√©sentent le caract√®re nul (U+0000). "
"Cela signifie que les cha√Ænes UTF-8 peuvent √™tre trait√©es par des fonctions "
"C telles que ``strcpy()`` et envoy√©es par des protocoles pour qui les octets "
"z√©ro signifient forc√©ment la fin de cha√Æne."

#: howto/unicode.rst:144
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "Une cha√Æne de texte ASCII est √©galement un texte UTF-8 valide."

#: howto/unicode.rst:145
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr ""
"UTF-8 est assez compact. La majorit√© des caract√®res couramment utilis√©s "
"peuvent √™tre repr√©sent√©s avec un ou deux octets."

#: howto/unicode.rst:147
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr ""
"Si des octets sont corrompus ou perdus, il est possible de d√©terminer le "
"d√©but du prochain point de code encod√© en UTF-8 et de se resynchroniser. Il "
"est √©galement improbable que des donn√©es 8-bits al√©atoires ressemblent √† du "
"UTF-8 valide."

#: howto/unicode.rst:150
msgid ""
"UTF-8 is a byte oriented encoding. The encoding specifies that each "
"character is represented by a specific sequence of one or more bytes. This "
"avoids the byte-ordering issues that can occur with integer and word "
"oriented encodings, like UTF-16 and UTF-32, where the sequence of bytes "
"varies depending on the hardware on which the string was encoded."
msgstr ""
"UTF-8 est un encodage orient√© octet. L'encodage sp√©cifie que chaque "
"caract√®re est repr√©sent√© par une s√©quence sp√©cifique d'un ou plusieurs "
"octets. Ceci permet d'√©viter les probl√®mes d'ordre des octets qui peuvent "
"survenir avec les encodages orient√©s entiers (*integer*) ou orient√©s mots "
"processeurs (*words*), comme UTF-16 et UTF-32, o√π la s√©quence des octets "
"varie en fonction du mat√©riel sur lequel la cha√Æne a √©t√© encod√©e."

#: howto/unicode.rst:514 howto/unicode.rst:735
msgid "References"
msgstr "R√©f√©rences"

#: howto/unicode.rst:160
msgid ""
"The `Unicode Consortium site <https://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology <https://www.unicode.org/"
"history/>`_ of the origin and development of Unicode is also available on "
"the site."
msgstr ""
"Le site du `Consortium Unicode <https://www.unicode.org>`_, en anglais, a "
"des diagrammes de caract√®res, un glossaire et des versions PDF de la "
"sp√©cification Unicode. Pr√©parez-vous √† une lecture difficile. Une "
"`chronologie <https://www.unicode.org/history/>`_ de l‚Äôorigine et du "
"d√©veloppement de l‚ÄôUnicode est √©galement disponible sur le site."

#: howto/unicode.rst:165
msgid ""
"On the Computerphile Youtube channel, Tom Scott briefly `discusses the "
"history of Unicode and UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ "
"(9 minutes 36 seconds)."
msgstr ""
"Sur la cha√Æne Youtube *Computerphile*, Tom Scott parle bri√®vement de "
"`l‚Äôhistoire d‚ÄôUnicode et d‚ÄôUTF-8 <https://www.youtube.com/watch?"
"v=MijmeoH9LT4>`_ (9 minutes et 36 secondes)."

#: howto/unicode.rst:169
msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://jkorpela.fi/unicode/guide.html>`_ to reading the Unicode "
"character tables."
msgstr ""
"Pour aider √† comprendre le standard, Jukka Korpela a √©crit `un guide "
"d‚Äôintroduction <https://jkorpela.fi/unicode/guide.html>`_ √† la lecture des "
"tables de caract√®res Unicode (ressource en anglais)."

#: howto/unicode.rst:173
msgid ""
"Another `good introductory article <https://www.joelonsoftware."
"com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-"
"positively-must-know-about-unicode-and-character-sets-no-excuses/>`_ was "
"written by Joel Spolsky. If this introduction didn't make things clear to "
"you, you should try reading this alternate article before continuing."
msgstr ""
"Un autre `bon article d'introduction <https://www.joelonsoftware."
"com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-"
"positively-must-know-about-unicode-and-character-sets-no-excuses/>`_ a √©t√© "
"√©crit par Joel Spolsky. Si cette pr√©sente introduction ne vous a pas "
"clarifi√© les choses, vous devriez essayer de lire cet article-l√† avant de "
"continuer."

#: howto/unicode.rst:178
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"Les pages Wikip√©dia sont souvent utiles¬†; voir les pages pour ¬´¬†`Codage des "
"caract√®res <https://fr.wikipedia.org/wiki/Codage_des_caract%C3%A8res>`_¬†¬ª et "
"`UTF-8 <https://fr.wikipedia.org/wiki/UTF-8>`_, par exemple."

#: howto/unicode.rst:184
msgid "Python's Unicode Support"
msgstr "Prise en charge Unicode de Python"

#: howto/unicode.rst:186
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr ""
"Maintenant que vous avez appris les rudiments de l'Unicode, nous pouvons "
"regarder les fonctionnalit√©s Unicode de Python."

#: howto/unicode.rst:190
msgid "The String Type"
msgstr "Le type *String*"

#: howto/unicode.rst:192
msgid ""
"Since Python 3.0, the language's :class:`str` type contains Unicode "
"characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"Depuis Python 3.0, le type :class:`str` du langage contient des caract√®res "
"Unicode, c'est-√†-dire n'importe quelle cha√Æne cr√©√©e √† l'aide de ``\"unicode "
"d√©chire¬†!\"``, ``'unicode d√©chire¬†!'`` ou la syntaxe √† triples guillemets "
"est enregistr√©e comme Unicode."

#: howto/unicode.rst:196
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr ""
"L'encodage par d√©faut pour le code source Python est UTF-8, il est donc "
"facile d'inclure des caract√®res Unicode dans une cha√Æne litt√©rale¬†::"

#: howto/unicode.rst:199
msgid ""
"try:\n"
"    with open('/tmp/input.txt', 'r') as f:\n"
"        ...\n"
"except OSError:\n"
"    # 'File not found' error message.\n"
"    print(\"Fichier non trouv√©\")"
msgstr ""

#: howto/unicode.rst:206
msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr ""
"Note¬†: Python 3 sait g√©rer les caract√®res Unicode dans les identifiants¬†::"

#: howto/unicode.rst:208
msgid ""
"r√©pertoire = \"/tmp/records.log\"\n"
"with open(r√©pertoire, \"w\") as f:\n"
"    f.write(\"test\\n\")"
msgstr ""

#: howto/unicode.rst:212
msgid ""
"If you can't enter a particular character in your editor or want to keep the "
"source code ASCII-only for some reason, you can also use escape sequences in "
"string literals. (Depending on your system, you may see the actual capital-"
"delta glyph instead of a \\u escape.) ::"
msgstr ""
"Si vous ne pouvez pas entrer un caract√®re particulier dans votre √©diteur ou "
"si vous voulez garder le code source uniquement en ASCII pour une raison "
"quelconque, vous pouvez √©galement utiliser des s√©quences d'√©chappement dans "
"les litt√©raux de cha√Æne (en fonction de votre syst√®me, il se peut que vous "
"voyiez le glyphe r√©el du *delta majuscule* au lieu d'une s√©quence "
"d'√©chappement ``\\u...``) ::"

#: howto/unicode.rst:217
msgid ""
">>> \"\\N{GREEK CAPITAL LETTER DELTA}\"  # Using the character name\n"
"'\\u0394'\n"
">>> \"\\u0394\"                          # Using a 16-bit hex value\n"
"'\\u0394'\n"
">>> \"\\U00000394\"                      # Using a 32-bit hex value\n"
"'\\u0394'"
msgstr ""

#: howto/unicode.rst:224
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"De plus, une cha√Æne de caract√®res peut √™tre cr√©√©e en utilisant la m√©thode :"
"func:`~bytes.decode` de la classe :class:`bytes`. Cette m√©thode prend un "
"argument *encoding*, ``UTF-8`` par exemple, et optionnellement un argument "
"*errors*."

#: howto/unicode.rst:228
msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument "
"are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"L'argument *errors* d√©termine la r√©ponse lorsque la cha√Æne en entr√©e ne peut "
"pas √™tre convertie selon les r√®gles de l'encodage. Les valeurs autoris√©es "
"pour cet argument sont ``'strict'`` (¬´¬†strict¬†¬ª¬†: l√®ve une exception :exc:"
"`UnicodeDecodeError`), ``'replace'`` (¬´¬†remplacer¬†¬ª¬†: utilise ``U+FFFD``, "
"``REPLACEMENT CARACTER``), ``'ignore'`` (¬´¬†ignorer¬†¬ª¬†: n'inclut pas le "
"caract√®re dans le r√©sultat Unicode) ou ``'backslashreplace'`` (¬´¬†remplacer "
"avec antislash¬†¬ª¬†: ins√®re une s√©quence d‚Äô√©chappement ``\\xNN``). Les "
"exemples suivants illustrent les diff√©rences¬†::"

#: howto/unicode.rst:236
msgid ""
">>> b'\\x80abc'.decode(\"utf-8\", \"strict\")  \n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0:\n"
"  invalid start byte\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"replace\")\n"
"'\\ufffdabc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"backslashreplace\")\n"
"'\\\\x80abc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"ignore\")\n"
"'abc'"
msgstr ""

#: howto/unicode.rst:248
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"comes with roughly 100 different encodings; see the Python Library Reference "
"at :ref:`standard-encodings` for a list.  Some encodings have multiple "
"names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' are all "
"synonyms for the same encoding."
msgstr ""
"Les encodages sont sp√©cifi√©s sous forme de cha√Ænes de caract√®res contenant "
"le nom de l'encodage. Python est livr√© avec une centaine d'encodages "
"diff√©rents¬†; voir la r√©f√©rence de la biblioth√®que Python sur les :ref:"
"`encodages standards <standard-encodings>` pour une liste. Certains "
"encodages ont plusieurs noms¬†; par exemple, ``'latin-1'``, ``'iso_8859_1'`` "
"et ``'8859'`` sont tous synonymes du m√™me encodage."

#: howto/unicode.rst:254
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` built-"
"in function, which takes integers and returns a Unicode string of length 1 "
"that contains the corresponding code point.  The reverse operation is the "
"built-in :func:`ord` function that takes a one-character Unicode string and "
"returns the code point value::"
msgstr ""
"Des cha√Ænes Unicode √† un caract√®re peuvent √©galement √™tre cr√©√©es avec la "
"fonction native :func:`chr`, qui prend des entiers et renvoie une cha√Æne "
"Unicode de longueur 1 qui contient le point de code correspondant. "
"L'op√©ration inverse est la fonction native :func:`ord` qui prend une cha√Æne "
"Unicode d'un caract√®re et renvoie la valeur du point de code¬†::"

#: howto/unicode.rst:260
msgid ""
">>> chr(57344)\n"
"'\\ue000'\n"
">>> ord('\\ue000')\n"
"57344"
msgstr ""

#: howto/unicode.rst:266
msgid "Converting to Bytes"
msgstr "Conversion en octets"

#: howto/unicode.rst:268
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
"La m√©thode inverse de :meth:`bytes.decode` est :meth:`str.encode`, qui "
"renvoie une repr√©sentation :class:`bytes` de la cha√Æne Unicode, cod√©e dans "
"l‚Äôencodage *encoding* demand√©."

#: howto/unicode.rst:272
msgid ""
"The *errors* parameter is the same as the parameter of the :meth:`~bytes."
"decode` method but supports a few more possible handlers. As well as "
"``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case inserts a "
"question mark instead of the unencodable character), there is also "
"``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"Le param√®tre *errors* est le m√™me que le param√®tre de la m√©thode :meth:"
"`~bytes.decode` mais poss√®de quelques gestionnaires suppl√©mentaires. En plus "
"de ``'strict'``, ``'ignore'`` et ``'remplace'`` (qui dans ce cas ins√®re un "
"point d'interrogation au lieu du caract√®re non encodable), il y a aussi "
"``'xmlcharrefreplace'`` (ins√®re une r√©f√©rence XML), ``backslashreplace`` "
"(ins√®re une s√©quence ``\\uNNNN``) et ``namereplace`` (ins√®re une s√©quence "
"``\\N{...}``)."

#: howto/unicode.rst:280
msgid "The following example shows the different results::"
msgstr "L'exemple suivant montre les diff√©rents r√©sultats¬†::"

#: howto/unicode.rst:282
msgid ""
">>> u = chr(40960) + 'abcd' + chr(1972)\n"
">>> u.encode('utf-8')\n"
"b'\\xea\\x80\\x80abcd\\xde\\xb4'\n"
">>> u.encode('ascii')  \n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeEncodeError: 'ascii' codec can't encode character '\\ua000' in\n"
"  position 0: ordinal not in range(128)\n"
">>> u.encode('ascii', 'ignore')\n"
"b'abcd'\n"
">>> u.encode('ascii', 'replace')\n"
"b'?abcd?'\n"
">>> u.encode('ascii', 'xmlcharrefreplace')\n"
"b'&#40960;abcd&#1972;'\n"
">>> u.encode('ascii', 'backslashreplace')\n"
"b'\\\\ua000abcd\\\\u07b4'\n"
">>> u.encode('ascii', 'namereplace')\n"
"b'\\\\N{YI SYLLABLE IT}abcd\\\\u07b4'"
msgstr ""

#: howto/unicode.rst:301
msgid ""
"The low-level routines for registering and accessing the available encodings "
"are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"Les routines de bas niveau pour enregistrer et acc√©der aux encodages "
"disponibles se trouvent dans le module :mod:`codecs`. L'impl√©mentation de "
"nouveaux encodages n√©cessite √©galement de comprendre le module :mod:"
"`codecs`. Cependant, les fonctions d'encodage et de d√©codage renvoy√©es par "
"ce module sont g√©n√©ralement de bas-niveau pour √™tre facilement utilis√©es et "
"l'√©criture de nouveaux encodages est une t√¢che tr√®s sp√©cialis√©e, donc le "
"module ne sera pas couvert dans ce guide."

#: howto/unicode.rst:310
msgid "Unicode Literals in Python Source Code"
msgstr "Litt√©raux Unicode dans le code source Python"

#: howto/unicode.rst:312
msgid ""
"In Python source code, specific Unicode code points can be written using the "
"``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"Dans le code source Python, des points de code Unicode sp√©cifiques peuvent "
"√™tre √©crits en utilisant la s√©quence d'√©chappement ``\\u``, suivie de quatre "
"chiffres hexad√©cimaux donnant le point de code. La s√©quence d'√©chappement "
"``\\U`` est similaire, mais attend huit chiffres hexad√©cimaux, pas quatre¬†::"

#: howto/unicode.rst:317
msgid ""
">>> s = \"a\\xac\\u1234\\u20ac\\U00008000\"\n"
"... #     ^^^^ two-digit hex escape\n"
"... #         ^^^^^^ four-digit Unicode escape\n"
"... #                     ^^^^^^^^^^ eight-digit Unicode escape\n"
">>> [ord(c) for c in s]\n"
"[97, 172, 4660, 8364, 32768]"
msgstr ""

#: howto/unicode.rst:324
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as "
"you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"L'utilisation de s√©quences d'√©chappement pour des points de code sup√©rieurs "
"√† 127 est acceptable √† faible dose, mais devient g√™nante si vous utilisez "
"beaucoup de caract√®res accentu√©s, comme c'est le cas dans un programme avec "
"des messages en fran√ßais ou dans une autre langue utilisant des lettres "
"accentu√©es. Vous pouvez √©galement assembler des cha√Ænes de caract√®res √† "
"l'aide de la fonction native :func:`chr`, mais c'est encore plus fastidieux."

#: howto/unicode.rst:330
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"Id√©alement, vous devriez √™tre capable d'√©crire des litt√©raux dans l'encodage "
"naturel de votre langue. Vous pourriez alors √©diter le code source de Python "
"avec votre √©diteur favori qui affiche les caract√®res accentu√©s "
"naturellement, et a les bons caract√®res utilis√©s au moment de l'ex√©cution."

#: howto/unicode.rst:335
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by "
"including a special comment as either the first or second line of the source "
"file::"
msgstr ""
"Python consid√®re que le code source est √©crit en UTF-8 par d√©faut, mais vous "
"pouvez utiliser presque n'importe quel encodage si vous d√©clarez l'encodage "
"utilis√©. Cela se fait en incluant un commentaire sp√©cial sur la premi√®re ou "
"la deuxi√®me ligne du fichier source¬†::"

#: howto/unicode.rst:339
msgid ""
"#!/usr/bin/env python\n"
"# -*- coding: latin-1 -*-\n"
"\n"
"u = 'abcd√©'\n"
"print(ord(u[-1]))"
msgstr ""

#: howto/unicode.rst:345
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to "
"a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"La syntaxe s'inspire de la notation d'*Emacs* pour sp√©cifier les variables "
"locales √† un fichier. *Emacs* supporte de nombreuses variables diff√©rentes, "
"mais Python ne g√®re que *coding*. Les symboles ``-*-`` indiquent √† *Emacs* "
"que le commentaire est sp√©cial¬†; ils n'ont aucune signification pour Python "
"mais sont une convention. Python cherche ``coding: name`` ou ``coding=name`` "
"dans le commentaire."

#: howto/unicode.rst:351
msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8 "
"as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"Si vous n'incluez pas un tel commentaire, l'encodage par d√©faut est UTF-8 "
"comme d√©j√† mentionn√©. Voir aussi la :pep:`263` pour plus d'informations."

#: howto/unicode.rst:356
msgid "Unicode Properties"
msgstr "Propri√©t√©s Unicode"

#: howto/unicode.rst:358
msgid ""
"The Unicode specification includes a database of information about code "
"points.  For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (for "
"characters representing numeric concepts such as the Roman numerals, "
"fractions such as one-third and four-fifths, etc.).  There are also display-"
"related properties, such as how to use the code point in bidirectional text."
msgstr ""
"La sp√©cification Unicode inclut une base de donn√©es d'informations sur les "
"points de code. Pour chaque point de code d√©fini, l'information comprend le "
"nom du caract√®re, sa cat√©gorie, la valeur num√©rique s'il y a lieu (pour les "
"caract√®res repr√©sentant des concepts num√©riques tels que les chiffres "
"romains, les fractions telles qu'un tiers et quatre cinqui√®mes, etc.). Il "
"existe √©galement des propri√©t√©s li√©es √† l'affichage, telles que "
"l'utilisation du point de code dans un texte bidirectionnel."

#: howto/unicode.rst:366
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr ""
"Le programme suivant affiche des informations sur plusieurs caract√®res et "
"affiche la valeur num√©rique d'un caract√®re particulier¬†::"

#: howto/unicode.rst:369
msgid ""
"import unicodedata\n"
"\n"
"u = chr(233) + chr(0x0bf2) + chr(3972) + chr(6000) + chr(13231)\n"
"\n"
"for i, c in enumerate(u):\n"
"    print(i, '%04x' % ord(c), unicodedata.category(c), end=\" \")\n"
"    print(unicodedata.name(c))\n"
"\n"
"# Get numeric value of second character\n"
"print(unicodedata.numeric(u[1]))"
msgstr ""

#: howto/unicode.rst:380
msgid "When run, this prints:"
msgstr "Si vous l'ex√©cutez, cela affiche¬†:"

#: howto/unicode.rst:382
msgid ""
"0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE\n"
"1 0bf2 No TAMIL NUMBER ONE THOUSAND\n"
"2 0f84 Mn TIBETAN MARK HALANTA\n"
"3 1770 Lo TAGBANWA LETTER SA\n"
"4 33af So SQUARE RAD OVER S SQUARED\n"
"1000.0"
msgstr ""

#: howto/unicode.rst:391
msgid ""
"The category codes are abbreviations describing the nature of the character. "
"These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation <https://www."
"unicode.org/reports/tr44/#General_Category_Values>`_ for a list of category "
"codes."
msgstr ""
"Les codes de cat√©gorie sont des abr√©viations d√©crivant la nature du "
"caract√®re. Celles-ci sont regroup√©es en cat√©gories telles que ¬´¬†Lettre¬†¬ª, "
"¬´¬†Nombre¬†¬ª, ¬´¬†Ponctuation¬†¬ª ou ¬´¬†Symbole¬†¬ª, qui sont √† leur tour divis√©es en "
"sous-cat√©gories. Pour prendre par exemple les codes de la sortie ci-dessus, "
"``'Ll'`` signifie ¬´¬†Lettre, minuscules¬†¬ª, ``'No'`` signifie ¬´¬†Nombre, "
"autre¬†¬ª, ``'Mn'`` est ¬´¬†Marque, non-espa√ßant¬†¬ª, et ``'So'`` est ¬´¬†Symbole, "
"autre¬†¬ª. Voir la section `Valeurs g√©n√©rales des cat√©gories de la "
"documentation de la base de donn√©es de caract√®res Unicode <https://www."
"unicode.org/reports/tr44/#General_Category_Values>`_ (ressource en anglais) "
"pour une liste de codes de cat√©gories."

#: howto/unicode.rst:402
msgid "Comparing Strings"
msgstr "Comparaison de cha√Ænes de caract√®res"

#: howto/unicode.rst:404
msgid ""
"Unicode adds some complication to comparing strings, because the same set of "
"characters can be represented by different sequences of code points.  For "
"example, a letter like '√™' can be represented as a single code point U+00EA, "
"or as U+0065 U+0302, which is the code point for 'e' followed by a code "
"point for 'COMBINING CIRCUMFLEX ACCENT'.  These will produce the same output "
"when printed, but one is a string of length 1 and the other is of length 2."
msgstr ""
"Unicode ajoute une certaine complication √† la comparaison des cha√Ænes de "
"caract√®res, car le m√™me jeu de caract√®res peut √™tre repr√©sent√© par "
"diff√©rentes s√©quences de points de code. Par exemple, une lettre comme ¬´¬†√™¬†¬ª "
"peut √™tre repr√©sent√©e comme un point de code unique ``U+00EA``, ou comme "
"``U+0065 U+0302``, qui est le point de code pour ¬´¬†e¬†¬ª suivi d'un point de "
"code pour ``COMBINING CIRCUMFLEX ACCENT``. Celles-ci produisent le m√™me "
"r√©sultat lorsqu'elles sont affich√©es, mais l'une est une cha√Æne de "
"caract√®res de longueur 1 et l'autre de longueur 2."

#: howto/unicode.rst:412
msgid ""
"One tool for a case-insensitive comparison is the :meth:`~str.casefold` "
"string method that converts a string to a case-insensitive form following an "
"algorithm described by the Unicode Standard.  This algorithm has special "
"handling for characters such as the German letter '√ü' (code point U+00DF), "
"which becomes the pair of lowercase letters 'ss'."
msgstr ""
"Un outil pour une comparaison insensible √† la casse est la m√©thode :meth:"
"`~str.casefold` qui convertit une cha√Æne en une forme insensible √† la casse "
"suivant un algorithme d√©crit par le standard Unicode. Cet algorithme a un "
"traitement sp√©cial pour les caract√®res tels que la lettre allemande ¬´¬†*√ü*¬†¬ª "
"(point de code ``U+00DF``), qui devient la paire de lettres minuscules "
"¬´¬†*ss*¬†¬ª."

#: howto/unicode.rst:421
msgid ""
">>> street = 'G√ºrzenichstra√üe'\n"
">>> street.casefold()\n"
"'g√ºrzenichstrasse'"
msgstr ""

#: howto/unicode.rst:425
#, fuzzy
msgid ""
"A second tool is the :mod:`unicodedata` module's :func:`~unicodedata."
"normalize` function that converts strings to one of several normal forms, "
"where letters followed by a combining character are replaced with single "
"characters.  :func:`~unicodedata.normalize` can be used to perform string "
"comparisons that won't falsely report inequality if two strings use "
"combining characters differently:"
msgstr ""
"Un deuxi√®me outil est la fonction :mod:`unicodedata` du module :func:"
"`~unicodedata.normalize` qui convertit les cha√Ænes de caract√®res en l'une de "
"plusieurs formes normales, o√π les lettres suivies d'un caract√®re de "
"combinaison sont remplac√©es par des caract√®res simples. :func:`normalize` "
"peut √™tre utilis√©e pour effectuer des comparaisons qui ne rapportent pas "
"faussement les in√©galit√©s si deux cha√Ænes utilisent diff√©rents caract√®res de "
"combinaison¬†:"

#: howto/unicode.rst:434
msgid ""
"import unicodedata\n"
"\n"
"def compare_strs(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(s1) == NFD(s2)\n"
"\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN SMALL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"print('length of first string=', len(single_char))\n"
"print('length of second string=', len(multiple_chars))\n"
"print(compare_strs(single_char, multiple_chars))"
msgstr ""

#: howto/unicode.rst:448
msgid "When run, this outputs:"
msgstr "Si vous l'ex√©cutez, cela affiche¬†:"

#: howto/unicode.rst:450
msgid ""
"$ python compare-strs.py\n"
"length of first string= 1\n"
"length of second string= 2\n"
"True"
msgstr ""

#: howto/unicode.rst:457
msgid ""
"The first argument to the :func:`~unicodedata.normalize` function is a "
"string giving the desired normalization form, which can be one of 'NFC', "
"'NFKC', 'NFD', and 'NFKD'."
msgstr ""
"Le premier argument de la fonction :func:`~unicodedata.normalize` est une "
"cha√Æne de caract√®res donnant la forme de normalisation d√©sir√©e, qui peut "
"√™tre une de celles-ci¬†: ``'NFC'``, ``'NFKC'``, ``'NFD'`` et ``'NFKD'``."

#: howto/unicode.rst:461
msgid "The Unicode Standard also specifies how to do caseless comparisons::"
msgstr ""
"La norme Unicode sp√©cifie √©galement comment faire des comparaisons "
"insensibles √† la casse¬†::"

#: howto/unicode.rst:463
msgid ""
"import unicodedata\n"
"\n"
"def compare_caseless(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(NFD(s1).casefold()) == NFD(NFD(s2).casefold())\n"
"\n"
"# Example usage\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN CAPITAL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"\n"
"print(compare_caseless(single_char, multiple_chars))"
msgstr ""

#: howto/unicode.rst:477
#, fuzzy
msgid ""
"This will print ``True``.  (Why is :func:`!NFD` invoked twice?  Because "
"there are a few characters that make :meth:`~str.casefold` return a non-"
"normalized string, so the result needs to be normalized again. See section "
"3.13 of the Unicode Standard for a discussion and an example.)"
msgstr ""
"Ceci affiche ``True``. (Pourquoi :func:`NFD` est-il invoqu√© deux fois¬†? "
"Parce qu'il y a quelques caract√®res qui font que :meth:`casefold` renvoie "
"une cha√Æne non normalis√©e, donc le r√©sultat doit √™tre normalis√© √† nouveau. "
"Voir la section 3.13 du standard Unicode pour une discussion et un exemple)."

#: howto/unicode.rst:484
msgid "Unicode Regular Expressions"
msgstr "Expressions r√©guli√®res Unicode"

#: howto/unicode.rst:486
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as "
"``\\d`` and ``\\w`` have different meanings depending on whether the pattern "
"is supplied as bytes or a string.  For example, ``\\d`` will match the "
"characters ``[0-9]`` in bytes but in strings will match any character that's "
"in the ``'Nd'`` category."
msgstr ""
"Les expressions r√©guli√®res g√©r√©es par le module :mod:`re` peuvent √™tre "
"fournies sous forme de cha√Æne d'octets ou de texte. Certaines s√©quences de "
"caract√®res sp√©ciaux telles que ``\\d`` et ``\\w`` ont des significations "
"diff√©rentes selon que le motif est fourni en octets ou en texte. Par "
"exemple, ``\\d`` correspond aux caract√®res ``[0-9]`` en octets mais dans les "
"cha√Ænes de caract√®res correspond √† tout caract√®re de la cat√©gorie ``'Nd'``."

#: howto/unicode.rst:493
msgid ""
"The string in this example has the number 57 written in both Thai and Arabic "
"numerals::"
msgstr ""
"Dans cet exemple, la cha√Æne contient le nombre 57 √©crit en chiffres arabes "
"et tha√Ølandais¬†::"

#: howto/unicode.rst:496
msgid ""
"import re\n"
"p = re.compile(r'\\d+')\n"
"\n"
"s = \"Over \\u0e55\\u0e57 57 flavours\"\n"
"m = p.search(s)\n"
"print(repr(m.group()))"
msgstr ""

#: howto/unicode.rst:503
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If "
"you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will "
"match the substring \"57\" instead."
msgstr ""
"Une fois ex√©cut√©, ``\\d+`` correspond aux chiffres tha√Ølandais et les "
"affiche. Si vous fournissez le drapeau :const:`re.ASCII` √† :func:`~re."
"compile`, ``\\d+`` correspond cette fois √† la cha√Æne \"57\"."

#: howto/unicode.rst:507
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"De m√™me, ``\\w`` correspond √† une grande vari√©t√© de caract√®res Unicode mais "
"seulement ``[a-zA-Z0-9_]`` en octets (ou si :const:`re.ASCII` est fourni) et "
"``\\s`` correspond soit aux caract√®res blancs Unicode soit aux caract√®res "
"``[ \\t\\n\\r\\f\\v]``."

#: howto/unicode.rst:518
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr ""
"Quelques bonnes discussions alternatives sur la gestion d'Unicode par Python "
"sont¬†:"

#: howto/unicode.rst:520
msgid ""
"`Processing Text Files in Python 3 <https://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, by Nick Coghlan."
msgstr ""
"`Processing Text Files in Python 3 <https://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, par Nick Coghlan."

#: howto/unicode.rst:521
msgid ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, une "
"pr√©sentation *PyCon* 2012 par Ned Batchelder."

#: howto/unicode.rst:523
msgid ""
"The :class:`str` type is described in the Python library reference at :ref:"
"`textseq`."
msgstr ""
"Le type :class:`str` est d√©crit dans la r√©f√©rence de la biblioth√®que Python "
"√† :ref:`textseq`."

#: howto/unicode.rst:526
msgid "The documentation for the :mod:`unicodedata` module."
msgstr "La documentation du module :mod:`unicodedata`."

#: howto/unicode.rst:528
msgid "The documentation for the :mod:`codecs` module."
msgstr "La documentation du module :mod:`codecs`."

#: howto/unicode.rst:530
msgid ""
"Marc-Andr√© Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"Marc-Andr√© Lemburg a donn√© une pr√©sentation intitul√©e `¬´¬†Python et Unicode¬†¬ª "
"(diapositives PDF) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk."
"pdf>`_ √† *EuroPython* 2002. Les diapositives sont un excellent aper√ßu de la "
"conception des fonctionnalit√©s Unicode de Python 2 (o√π le type de cha√Æne "
"Unicode est appel√© ``unicode`` et les litt√©raux commencent par ``u``)."

#: howto/unicode.rst:538
msgid "Reading and Writing Unicode Data"
msgstr "Lecture et √©criture de donn√©es Unicode"

#: howto/unicode.rst:540
msgid ""
"Once you've written some code that works with Unicode data, the next problem "
"is input/output.  How do you get Unicode strings into your program, and how "
"do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"Une fois que vous avez √©crit du code qui fonctionne avec des donn√©es "
"Unicode, le probl√®me suivant concerne les entr√©es/sorties. Comment obtenir "
"des cha√Ænes Unicode dans votre programme et comment convertir les cha√Ænes "
"Unicode dans une forme appropri√©e pour le stockage ou la transmission¬†?"

#: howto/unicode.rst:544
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used "
"in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"Il est possible que vous n'ayez rien √† faire en fonction de vos sources "
"d'entr√©e et des destinations de vos donn√©es de sortie¬†; il convient de "
"v√©rifier si les biblioth√®ques utilis√©es dans votre application g√®rent "
"l'Unicode nativement. Par exemple, les analyseurs XML renvoient souvent des "
"donn√©es Unicode. De nombreuses bases de donn√©es relationnelles prennent "
"√©galement en charge les colonnes encod√©es en Unicode et peuvent renvoyer des "
"valeurs Unicode √† partir d'une requ√™te SQL."

#: howto/unicode.rst:550
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"Les donn√©es Unicode sont g√©n√©ralement converties en un encodage particulier "
"avant d'√™tre √©crites sur le disque ou envoy√©es sur un connecteur r√©seau. Il "
"est possible de faire tout le travail vous-m√™me¬†: ouvrir un fichier, lire un "
"√©l√©ment 8-bits, puis convertir les octets avec ``bytes.decode(encoding)``. "
"Cependant, l'approche manuelle n'est pas recommand√©e."

#: howto/unicode.rst:555
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can "
"be represented by several bytes.  If you want to read the file in arbitrary-"
"sized chunks (say, 1024 or 4096 bytes), you need to write error-handling "
"code to catch the case where only part of the bytes encoding a single "
"Unicode character are read at the end of a chunk.  One solution would be to "
"read the entire file into memory and then perform the decoding, but that "
"prevents you from working with files that are extremely large; if you need "
"to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for at "
"least a moment you'd need to have both the encoded string and its Unicode "
"version in memory.)"
msgstr ""
"La nature multi-octets des encodages pose probl√®me¬†; un caract√®re Unicode "
"peut √™tre repr√©sent√© par plusieurs octets. Si vous voulez lire le fichier "
"par morceaux de taille arbitraire (disons 1024 ou 4096 octets), vous devez "
"√©crire un code de gestion des erreurs pour d√©tecter le cas o√π une partie "
"seulement des octets codant un seul caract√®re Unicode est lue √† la fin d'un "
"morceau. Une solution serait de lire le fichier entier en m√©moire et "
"d'effectuer le d√©codage, mais cela vous emp√™che de travailler avec des "
"fichiers extr√™mement volumineux¬†; si vous avez besoin de lire un fichier de "
"2¬†Gio, vous avez besoin de 2¬†Gio de RAM (plus que √ßa, en fait, puisque "
"pendant un moment, vous aurez besoin d'avoir √† la fois la cha√Æne encod√©e et "
"sa version Unicode en m√©moire)."

#: howto/unicode.rst:565
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already "
"been done for you: the built-in :func:`open` function can return a file-like "
"object that assumes the file's contents are in a specified encoding and "
"accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in :"
"meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""
"La solution serait d'utiliser l'interface de d√©codage de bas-niveau pour "
"intercepter le cas des s√©quences d'encodage incompl√®tes. Ce travail "
"d'impl√©mentation a d√©j√† √©t√© fait pour vous¬†: la fonction native :func:`open` "
"peut renvoyer un objet de type fichier qui suppose que le contenu du fichier "
"est dans un encodage sp√©cifi√© et accepte les param√®tres Unicode pour des "
"m√©thodes telles que :meth:`~io.TextIOBase.read` et :meth:`~io.TextIOBase."
"write`. Ceci fonctionne gr√¢ce aux param√®tres *encoding* et *errors* de :func:"
"`open` qui sont interpr√©t√©s comme ceux de :meth:`str.encode` et :meth:`bytes."
"decode`."

#: howto/unicode.rst:574
msgid "Reading Unicode from a file is therefore simple::"
msgstr "Lire de l'Unicode √† partir d'un fichier est donc simple¬†::"

#: howto/unicode.rst:576
msgid ""
"with open('unicode.txt', encoding='utf-8') as f:\n"
"    for line in f:\n"
"        print(repr(line))"
msgstr ""

#: howto/unicode.rst:580
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr ""
"Il est √©galement possible d'ouvrir des fichiers en mode ¬´¬†mise √† jour¬†¬ª, "
"permettant √† la fois la lecture et l'√©criture¬†::"

#: howto/unicode.rst:583
msgid ""
"with open('test', encoding='utf-8', mode='w+') as f:\n"
"    f.write('\\u4500 blah blah blah\\n')\n"
"    f.seek(0)\n"
"    print(repr(f.readline()[:1]))"
msgstr ""

#: howto/unicode.rst:588
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"Le caract√®re Unicode ``U+FEFFF`` est utilis√© comme marque pour indiquer le "
"boutisme (c'est-√†-dire l'ordre dans lequel les octets sont plac√©s pour "
"indiquer une valeur sur plusieurs octets, *byte-order mark* en anglais ou "
"*BOM*), et est souvent √©crit en t√™te (premier caract√®re) d'un fichier afin "
"d'aider √† l'auto-d√©tection du boutisme du fichier. Certains encodages, comme "
"UTF-16, s'attendent √† ce qu'une *BOM* soit pr√©sente au d√©but d'un fichier¬†; "
"lorsqu'un tel encodage est utilis√©, la *BOM* sera automatiquement √©crite "
"comme premier caract√®re et sera silencieusement retir√©e lorsque le fichier "
"sera lu. Il existe des variantes de ces encodages, comme ``utf-16-le`` et "
"``utf-16-be`` pour les encodages petit-boutiste et gros-boutiste, qui "
"sp√©cifient un ordre d'octets donn√© et ne sautent pas la *BOM*."

#: howto/unicode.rst:597
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  For "
"reading such files, use the 'utf-8-sig' codec to automatically skip the mark "
"if present."
msgstr ""
"Dans certains cas, il est √©galement d'usage d'utiliser une *BOM* au d√©but "
"des fichiers encod√©s en UTF-8¬†; le nom est trompeur puisque l'UTF-8 ne "
"d√©pend pas de l'ordre des octets. La marque annonce simplement que le "
"fichier est encod√© en UTF-8. Pour lire ces fichiers, utilisez le codec "
"``utf-8-sig`` pour sauter automatiquement la marque si elle est pr√©sente."

#: howto/unicode.rst:604
msgid "Unicode filenames"
msgstr "Noms de fichiers Unicode"

#: howto/unicode.rst:606
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  Today Python is converging on using UTF-8: Python on MacOS has "
"used UTF-8 for several versions, and Python 3.6 switched to using UTF-8 on "
"Windows as well.  On Unix systems, there will only be a :term:`filesystem "
"encoding <filesystem encoding and error handler>`. if you've set the "
"``LANG`` or ``LC_CTYPE`` environment variables; if you haven't, the default "
"encoding is again UTF-8."
msgstr ""
"La plupart des syst√®mes d'exploitation couramment utilis√©s aujourd'hui "
"prennent en charge les noms de fichiers qui contiennent des caract√®res "
"Unicode arbitraires. Habituellement, ceci est impl√©ment√© en convertissant la "
"cha√Æne Unicode en un encodage qui varie en fonction du syst√®me. Aujourd'hui, "
"Python converge vers l'utilisation d'UTF-8¬†: Python sous MacOS utilise UTF-8 "
"depuis plusieurs versions et Python 3.6 sous Windows est pass√© √† UTF-8 "
"√©galement. Sur les syst√®mes Unix, il n'y aura un :term:`encodage pour le "
"syst√®me de fichiers <filesystem encoding and error handler>` que si vous "
"avez d√©fini les variables d'environnement ``LANG`` ou ``LC_CTYPE``¬†; sinon, "
"l'encodage par d√©faut est UTF-8."

#: howto/unicode.rst:616
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
"La fonction :func:`sys.getfilesystemencoding` renvoie l'encodage √† utiliser "
"sur votre syst√®me actuel, au cas o√π vous voudriez faire l'encodage "
"manuellement, mais il n'y a pas vraiment de raisons de s'emb√™ter avec √ßa. "
"Lors de l'ouverture d'un fichier pour la lecture ou l'√©criture, vous pouvez "
"g√©n√©ralement simplement fournir la cha√Æne Unicode comme nom de fichier et "
"elle est automatiquement convertie √† l'encodage qui convient¬†::"

#: howto/unicode.rst:622
msgid ""
"filename = 'filename\\u4500abc'\n"
"with open(filename, 'w') as f:\n"
"    f.write('blah\\n')"
msgstr ""

#: howto/unicode.rst:626
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ""
"Les fonctions du module :mod:`os` telles que :func:`os.stat` acceptent "
"√©galement les noms de fichiers Unicode."

#: howto/unicode.rst:629
msgid ""
"The :func:`os.listdir` function returns filenames, which raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes "
"containing the encoded versions?  :func:`os.listdir` can do both, depending "
"on whether you provided the directory path as bytes or a Unicode string.  If "
"you pass a Unicode string as the path, filenames will be decoded using the "
"filesystem's encoding and a list of Unicode strings will be returned, while "
"passing a byte path will return the filenames as bytes.  For example, "
"assuming the default :term:`filesystem encoding <filesystem encoding and "
"error handler>` is UTF-8, running the following program::"
msgstr ""
"La fonction :func:`os.listdir` renvoie des noms de fichiers, ce qui soul√®ve "
"un probl√®me¬†: doit-elle renvoyer la version Unicode des noms de fichiers ou "
"doit-elle renvoyer des cha√Ænes d'octets contenant les versions encod√©es¬†? :"
"func:`os.listdir` peut faire les deux, selon que vous fournissez le chemin "
"du r√©pertoire en cha√Æne d'octets ou en cha√Æne Unicode. Si vous passez une "
"cha√Æne Unicode comme chemin d'acc√®s, les noms de fichiers sont d√©cod√©s en "
"utilisant l'encodage du syst√®me de fichiers et une liste de cha√Ænes Unicode "
"est renvoy√©e, tandis que passer un chemin d'acc√®s en cha√Æne d'octets renvoie "
"les noms de fichiers comme cha√Æne d'octets. Par exemple, en supposant que l':"
"term:`encodage par d√©faut du syst√®me de fichiers <filesystem encoding and "
"error handler>` est UTF-8, ex√©cuter le programme suivant¬†::"

#: howto/unicode.rst:639
msgid ""
"fn = 'filename\\u4500abc'\n"
"f = open(fn, 'w')\n"
"f.close()\n"
"\n"
"import os\n"
"print(os.listdir(b'.'))\n"
"print(os.listdir('.'))"
msgstr ""

#: howto/unicode.rst:647
msgid "will produce the following output:"
msgstr "produit la sortie suivante¬†:"

#: howto/unicode.rst:649
msgid ""
"$ python listdir-test.py\n"
"[b'filename\\xe4\\x94\\x80abc', ...]\n"
"['filename\\u4500abc', ...]"
msgstr ""

#: howto/unicode.rst:655
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr ""
"La premi√®re liste contient les noms de fichiers encod√©s en UTF-8 et la "
"seconde contient les versions Unicode."

#: howto/unicode.rst:658
msgid ""
"Note that on most occasions, you should can just stick with using Unicode "
"with these APIs.  The bytes APIs should only be used on systems where "
"undecodable file names can be present; that's pretty much only Unix systems "
"now."
msgstr ""
"Notez que, dans la plupart des cas, il convient de vous en tenir √† "
"l'utilisation d'Unicode avec ces *APIs*. Les *API* d'octets ne devraient "
"√™tre utilis√©es que sur les syst√®mes o√π des noms de fichiers non d√©codables "
"peuvent √™tre pr√©sents. Cela ne concerne pratiquement que des syst√®mes Unix "
"maintenant."

#: howto/unicode.rst:665
msgid "Tips for Writing Unicode-aware Programs"
msgstr "Conseils pour √©crire des programmes compatibles Unicode"

#: howto/unicode.rst:667
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr ""
"Cette section fournit quelques suggestions sur l'√©criture de logiciels qui "
"traitent de l'Unicode."

#: howto/unicode.rst:670
msgid "The most important tip is:"
msgstr "Le conseil le plus important est¬†:"

#: howto/unicode.rst:672
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr ""
"Il convient que le logiciel ne traite que des cha√Ænes Unicode en interne, "
"d√©codant les donn√©es d'entr√©e d√®s que possible et encodant la sortie "
"uniquement √† la fin."

#: howto/unicode.rst:675
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""
"Si vous essayez d'√©crire des fonctions de traitement qui acceptent √† la fois "
"les cha√Ænes Unicode et les cha√Ænes d'octets, les possibilit√©s d'occurrences "
"de bogues dans votre programme augmentent partout o√π vous combinez les deux "
"diff√©rents types de cha√Ænes. Il n'y a pas d'encodage ou de d√©codage "
"automatique¬†: si vous faites par exemple ``str + octets``, une :exc:"
"`TypeError` est lev√©e."

#: howto/unicode.rst:680
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using "
"the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"Lors de l'utilisation de donn√©es provenant d'un navigateur Web ou d'une "
"autre source non fiable, une technique courante consiste √† v√©rifier la "
"pr√©sence de caract√®res ill√©gaux dans une cha√Æne de caract√®res avant de "
"l'utiliser pour g√©n√©rer une ligne de commande ou de la stocker dans une base "
"de donn√©es. Si vous le faites, v√©rifiez bien la cha√Æne d√©cod√©e, pas les "
"donn√©es d'octets cod√©s¬†; certains encodages peuvent avoir des propri√©t√©s "
"int√©ressantes, comme ne pas √™tre bijectifs ou ne pas √™tre enti√®rement "
"compatibles avec l'ASCII. C'est particuli√®rement vrai si l'encodage est "
"sp√©cifi√© explicitement dans vos donn√©es d'entr√©e, car l'attaquant peut alors "
"choisir un moyen intelligent de cacher du texte malveillant dans le flux de "
"donn√©es encod√©."

#: howto/unicode.rst:691
msgid "Converting Between File Encodings"
msgstr "Conversion entre les encodages de fichiers"

#: howto/unicode.rst:693
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""
"La classe :class:`~codecs.StreamRecoder` peut convertir de mani√®re "
"transparente entre les encodages¬†: prenant un flux qui renvoie des donn√©es "
"dans l'encodage #1, elle se comporte comme un flux qui renvoie des donn√©es "
"dans l'encodage #2."

#: howto/unicode.rst:697
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""
"Par exemple, si vous avez un fichier d'entr√©e *f* qui est en Latin-1, vous "
"pouvez l'encapsuler dans un :class:`~codecs.StreamRecoder` pour qu'il "
"renvoie des octets encod√©s en UTF-8¬†::"

#: howto/unicode.rst:701
msgid ""
"new_f = codecs.StreamRecoder(f,\n"
"    # en/decoder: used by read() to encode its results and\n"
"    # by write() to decode its input.\n"
"    codecs.getencoder('utf-8'), codecs.getdecoder('utf-8'),\n"
"\n"
"    # reader/writer: used to read and write to the stream.\n"
"    codecs.getreader('latin-1'), codecs.getwriter('latin-1') )"
msgstr ""

#: howto/unicode.rst:711
msgid "Files in an Unknown Encoding"
msgstr "Fichiers dans un encodage inconnu"

#: howto/unicode.rst:713
msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want "
"to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""
"Vous avez besoin de modifier un fichier, mais vous ne connaissez pas son "
"encodage¬†? Si vous savez que l'encodage est compatible ASCII et que vous "
"voulez seulement examiner ou modifier les parties ASCII, vous pouvez ouvrir "
"le fichier avec le gestionnaire d'erreurs ``surrogateescape``¬†::"

#: howto/unicode.rst:718
msgid ""
"with open(fname, 'r', encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    data = f.read()\n"
"\n"
"# make changes to the string 'data'\n"
"\n"
"with open(fname + '.new', 'w',\n"
"          encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    f.write(data)"
msgstr ""

#: howto/unicode.rst:727
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in a special range running from U+DC80 to U+DCFF.  These code "
"points will then turn back into the same bytes when the ``surrogateescape`` "
"error handler is used to encode the data and write it back out."
msgstr ""
"Le gestionnaire d'erreurs ``surrogateescape`` d√©code tous les octets non-"
"ASCII comme points de code dans une plage sp√©ciale allant de ``U+DC80`` √† "
"``U+DCFF``. Ces points de code redeviennent alors les m√™mes octets lorsque "
"le gestionnaire d'erreurs ``surrogateescape`` est utilis√© pour encoder les "
"donn√©es et les r√©√©crire."

#: howto/unicode.rst:737
msgid ""
"One section of `Mastering Python 3 Input/Output <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, a PyCon 2010 talk by David "
"Beazley, discusses text processing and binary data handling."
msgstr ""
"Une partie de la conf√©rence `Mastering Python 3 Input/Output <https://"
"pyvideo.org/video/289/pycon-2010--mastering-python-3-i-o>`_ (ressource en "
"anglais), donn√©e lors de *PyCon* 2010 de David Beazley, parle du traitement "
"de texte et du traitement des donn√©es binaires."

#: howto/unicode.rst:741
msgid ""
"The `PDF slides for Marc-Andr√© Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ discuss questions of "
"character encodings as well as how to internationalize and localize an "
"application.  These slides cover Python 2.x only."
msgstr ""
"Le `PDF du diaporama de la pr√©sentation de Marc-Andr√© Lemburg \"Writing "
"Unicodeaware Applications in Python\" <https://downloads.egenix.com/python/"
"LSM2005-Developing-Unicode-aware-applications-in-Python.pdf>`_ (ressource en "
"anglais) traite des questions d'encodage de caract√®res ainsi que de "
"l'internationalisation et de la localisation d'une application. Ces "
"diapositives ne couvrent que Python 2.x."

#: howto/unicode.rst:747
msgid ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ (ressource en anglais) est une conf√©rence *PyCon* 2013 "
"donn√©e par Benjamin Peterson qui traite de la repr√©sentation interne Unicode "
"en Python 3.3."

#: howto/unicode.rst:754
msgid "Acknowledgements"
msgstr "Remerciements"

#: howto/unicode.rst:756
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"La premi√®re √©bauche de ce document a √©t√© r√©dig√©e par Andrew Kuchling. Il a "
"depuis √©t√© r√©vis√© par Alexander Belopolsky, Georg Brandl, Andrew Kuchling et "
"Ezio Melotti."

#: howto/unicode.rst:760
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: √âric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-Andr√© Lemburg, Martin von L√∂wis, "
"Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham Wideman."
msgstr ""
"Merci aux personnes suivantes qui ont not√© des erreurs ou qui ont fait des "
"suggestions sur cet article¬†: √âric Araujo, Nicholas Bastin, Nick Coghlan, "
"Marius Gedminas, Kent Johnson, Ken Krugler, Marc-Andr√© Lemburg, Martin von "
"L√∂wis, Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham "
"Wideman."
