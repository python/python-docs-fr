# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/howto/urllib2.rst:5
msgid "HOWTO Fetch Internet Resources Using urllib2"
msgstr ""

#: ../Doc/howto/urllib2.rst:7
msgid "`Michael Foord <http://www.voidspace.org.uk/python/index.shtml>`_"
msgstr ""

#: ../Doc/howto/urllib2.rst:11
msgid ""
"There is a French translation of an earlier revision of this HOWTO, "
"available at `urllib2 - Le Manuel manquant <http://www.voidspace.org.uk/"
"python/articles/urllib2_francais.shtml>`_."
msgstr ""

#: ../Doc/howto/urllib2.rst:18
msgid "Introduction"
msgstr "Introduction"

#: ../Doc/howto/urllib2.rst:0
msgid "Related Articles"
msgstr ""

#: ../Doc/howto/urllib2.rst:22
msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr ""

#: ../Doc/howto/urllib2.rst:25
msgid ""
"`Basic Authentication <http://www.voidspace.org.uk/python/articles/"
"authentication.shtml>`_"
msgstr ""

#: ../Doc/howto/urllib2.rst:27
msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr ""

#: ../Doc/howto/urllib2.rst:29
msgid ""
"**urllib2** is a Python module for fetching URLs (Uniform Resource "
"Locators). It offers a very simple interface, in the form of the *urlopen* "
"function. This is capable of fetching URLs using a variety of different "
"protocols. It also offers a slightly more complex interface for handling "
"common situations - like basic authentication, cookies, proxies and so on. "
"These are provided by objects called handlers and openers."
msgstr ""

#: ../Doc/howto/urllib2.rst:36
msgid ""
"urllib2 supports fetching URLs for many \"URL schemes\" (identified by the "
"string before the \":\" in URL - for example \"ftp\" is the URL scheme of "
"\"ftp://python.org/\") using their associated network protocols (e.g. FTP, "
"HTTP). This tutorial focuses on the most common case, HTTP."
msgstr ""

#: ../Doc/howto/urllib2.rst:41
msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon as "
"you encounter errors or non-trivial cases when opening HTTP URLs, you will "
"need some understanding of the HyperText Transfer Protocol. The most "
"comprehensive and authoritative reference to HTTP is :rfc:`2616`. This is a "
"technical document and not intended to be easy to read. This HOWTO aims to "
"illustrate using *urllib2*, with enough detail about HTTP to help you "
"through. It is not intended to replace the :mod:`urllib2` docs, but is "
"supplementary to them."
msgstr ""

#: ../Doc/howto/urllib2.rst:51
msgid "Fetching URLs"
msgstr ""

#: ../Doc/howto/urllib2.rst:53
msgid "The simplest way to use urllib2 is as follows::"
msgstr ""

#: ../Doc/howto/urllib2.rst:59
msgid ""
"Many uses of urllib2 will be that simple (note that instead of an 'http:' "
"URL we could have used a URL starting with 'ftp:', 'file:', etc.).  However, "
"it's the purpose of this tutorial to explain the more complicated cases, "
"concentrating on HTTP."
msgstr ""

#: ../Doc/howto/urllib2.rst:64
msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib2 mirrors this with a ``Request`` object which "
"represents the HTTP request you are making. In its simplest form you create "
"a Request object that specifies the URL you want to fetch. Calling "
"``urlopen`` with this Request object returns a response object for the URL "
"requested. This response is a file-like object, which means you can for "
"example call ``.read()`` on the response::"
msgstr ""

#: ../Doc/howto/urllib2.rst:78
msgid ""
"Note that urllib2 makes use of the same Request interface to handle all URL "
"schemes.  For example, you can make an FTP request like so::"
msgstr ""

#: ../Doc/howto/urllib2.rst:83
msgid ""
"In the case of HTTP, there are two extra things that Request objects allow "
"you to do: First, you can pass data to be sent to the server.  Second, you "
"can pass extra information (\"metadata\") *about* the data or the about "
"request itself, to the server - this information is sent as HTTP \"headers"
"\".  Let's look at each of these in turn."
msgstr ""

#: ../Doc/howto/urllib2.rst:90
msgid "Data"
msgstr ""

#: ../Doc/howto/urllib2.rst:92
msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a CGI "
"(Common Gateway Interface) script [#]_ or other web application). With HTTP, "
"this is often done using what's known as a **POST** request. This is often "
"what your browser does when you submit a HTML form that you filled in on the "
"web. Not all POSTs have to come from forms: you can use a POST to transmit "
"arbitrary data to your own application. In the common case of HTML forms, "
"the data needs to be encoded in a standard way, and then passed to the "
"Request object as the ``data`` argument. The encoding is done using a "
"function from the ``urllib`` library *not* from ``urllib2``. ::"
msgstr ""

#: ../Doc/howto/urllib2.rst:115
msgid ""
"Note that other encodings are sometimes required (e.g. for file upload from "
"HTML forms - see `HTML Specification, Form Submission <https://www.w3.org/TR/"
"REC-html40/interact/forms.html#h-17.13>`_ for more details)."
msgstr ""

#: ../Doc/howto/urllib2.rst:120
msgid ""
"If you do not pass the ``data`` argument, urllib2 uses a **GET** request. "
"One way in which GET and POST requests differ is that POST requests often "
"have \"side-effects\": they change the state of the system in some way (for "
"example by placing an order with the website for a hundredweight of tinned "
"spam to be delivered to your door).  Though the HTTP standard makes it clear "
"that POSTs are intended to *always* cause side-effects, and GET requests "
"*never* to cause side-effects, nothing prevents a GET request from having "
"side-effects, nor a POST requests from having no side-effects. Data can also "
"be passed in an HTTP GET request by encoding it in the URL itself."
msgstr ""

#: ../Doc/howto/urllib2.rst:130
msgid "This is done as follows::"
msgstr ""

#: ../Doc/howto/urllib2.rst:145
msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, followed "
"by the encoded values."
msgstr ""

#: ../Doc/howto/urllib2.rst:149
msgid "Headers"
msgstr ""

#: ../Doc/howto/urllib2.rst:151
msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr ""

#: ../Doc/howto/urllib2.rst:154
msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib2 identifies itself as "
"``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version "
"numbers of the Python release, e.g. ``Python-urllib/2.5``), which may "
"confuse the site, or just plain not work. The way a browser identifies "
"itself is through the ``User-Agent`` header [#]_. When you create a Request "
"object you can pass a dictionary of headers in. The following example makes "
"the same request as above, but identifies itself as a version of Internet "
"Explorer [#]_. ::"
msgstr ""

#: ../Doc/howto/urllib2.rst:180
msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr ""

#: ../Doc/howto/urllib2.rst:185
msgid "Handling Exceptions"
msgstr "Gestion des exceptions"

#: ../Doc/howto/urllib2.rst:187
msgid ""
"*urlopen* raises :exc:`URLError` when it cannot handle a response (though as "
"usual with Python APIs, built-in exceptions such as :exc:`ValueError`, :exc:"
"`TypeError` etc. may also be raised)."
msgstr ""

#: ../Doc/howto/urllib2.rst:191
msgid ""
":exc:`HTTPError` is the subclass of :exc:`URLError` raised in the specific "
"case of HTTP URLs."
msgstr ""

#: ../Doc/howto/urllib2.rst:195
msgid "URLError"
msgstr ""

#: ../Doc/howto/urllib2.rst:197
msgid ""
"Often, URLError is raised because there is no network connection (no route "
"to the specified server), or the specified server doesn't exist.  In this "
"case, the exception raised will have a 'reason' attribute, which is a tuple "
"containing an error code and a text error message."
msgstr ""

#: ../Doc/howto/urllib2.rst:202 ../Doc/howto/urllib2.rst:447
msgid "e.g. ::"
msgstr ""

#: ../Doc/howto/urllib2.rst:213
msgid "HTTPError"
msgstr ""

#: ../Doc/howto/urllib2.rst:215
msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil the "
"request. The default handlers will handle some of these responses for you "
"(for example, if the response is a \"redirection\" that requests the client "
"fetch the document from a different URL, urllib2 will handle that for you). "
"For those it can't handle, urlopen will raise an :exc:`HTTPError`. Typical "
"errors include '404' (page not found), '403' (request forbidden), and "
"'401' (authentication required)."
msgstr ""

#: ../Doc/howto/urllib2.rst:223
msgid "See section 10 of RFC 2616 for a reference on all the HTTP error codes."
msgstr ""

#: ../Doc/howto/urllib2.rst:225
msgid ""
"The :exc:`HTTPError` instance raised will have an integer 'code' attribute, "
"which corresponds to the error sent by the server."
msgstr ""

#: ../Doc/howto/urllib2.rst:229
msgid "Error Codes"
msgstr ""

#: ../Doc/howto/urllib2.rst:231
msgid ""
"Because the default handlers handle redirects (codes in the 300 range), and "
"codes in the 100-299 range indicate success, you will usually only see error "
"codes in the 400-599 range."
msgstr ""

#: ../Doc/howto/urllib2.rst:235
msgid ""
"``BaseHTTPServer.BaseHTTPRequestHandler.responses`` is a useful dictionary "
"of response codes in that shows all the response codes used by RFC 2616. The "
"dictionary is reproduced here for convenience ::"
msgstr ""

#: ../Doc/howto/urllib2.rst:307
msgid ""
"When an error is raised the server responds by returning an HTTP error code "
"*and* an error page. You can use the :exc:`HTTPError` instance as a response "
"on the page returned. This means that as well as the code attribute, it also "
"has read, geturl, and info, methods. ::"
msgstr ""

#: ../Doc/howto/urllib2.rst:328
msgid "Wrapping it Up"
msgstr ""

#: ../Doc/howto/urllib2.rst:330
msgid ""
"So if you want to be prepared for :exc:`HTTPError` *or* :exc:`URLError` "
"there are two basic approaches. I prefer the second approach."
msgstr ""

#: ../Doc/howto/urllib2.rst:334
msgid "Number 1"
msgstr ""

#: ../Doc/howto/urllib2.rst:355
msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError`` "
"will *also* catch an :exc:`HTTPError`."
msgstr ""

#: ../Doc/howto/urllib2.rst:359
msgid "Number 2"
msgstr ""

#: ../Doc/howto/urllib2.rst:379
msgid "info and geturl"
msgstr ""

#: ../Doc/howto/urllib2.rst:381
msgid ""
"The response returned by urlopen (or the :exc:`HTTPError` instance) has two "
"useful methods :meth:`info` and :meth:`geturl`."
msgstr ""

#: ../Doc/howto/urllib2.rst:384
msgid ""
"**geturl** - this returns the real URL of the page fetched. This is useful "
"because ``urlopen`` (or the opener object used) may have followed a "
"redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""

#: ../Doc/howto/urllib2.rst:388
msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an "
"``httplib.HTTPMessage`` instance."
msgstr ""

#: ../Doc/howto/urllib2.rst:392
msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See the "
"`Quick Reference to HTTP Headers <https://www.cs.tut.fi/~jkorpela/http."
"html>`_ for a useful listing of HTTP headers with brief explanations of "
"their meaning and use."
msgstr ""

#: ../Doc/howto/urllib2.rst:399
msgid "Openers and Handlers"
msgstr ""

#: ../Doc/howto/urllib2.rst:401
msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly-named :class:`urllib2.OpenerDirector`). Normally we have been "
"using the default opener - via ``urlopen`` - but you can create custom "
"openers. Openers use handlers. All the \"heavy lifting\" is done by the "
"handlers. Each handler knows how to open URLs for a particular URL scheme "
"(http, ftp, etc.), or how to handle an aspect of URL opening, for example "
"HTTP redirections or HTTP cookies."
msgstr ""

#: ../Doc/howto/urllib2.rst:409
msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or to "
"get an opener that does not handle redirections."
msgstr ""

#: ../Doc/howto/urllib2.rst:413
msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call ``."
"add_handler(some_handler_instance)`` repeatedly."
msgstr ""

#: ../Doc/howto/urllib2.rst:416
msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience function "
"for creating opener objects with a single function call.  ``build_opener`` "
"adds several handlers by default, but provides a quick way to add more and/"
"or override the default handlers."
msgstr ""

#: ../Doc/howto/urllib2.rst:421
msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr ""

#: ../Doc/howto/urllib2.rst:424
msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener you "
"have installed."
msgstr ""

#: ../Doc/howto/urllib2.rst:428
msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need to "
"call ``install_opener``, except as a convenience."
msgstr ""

#: ../Doc/howto/urllib2.rst:434
msgid "Basic Authentication"
msgstr ""

#: ../Doc/howto/urllib2.rst:436
msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject -- "
"including an explanation of how Basic Authentication works - see the `Basic "
"Authentication Tutorial <http://www.voidspace.org.uk/python/articles/"
"authentication.shtml>`_."
msgstr ""

#: ../Doc/howto/urllib2.rst:442
msgid ""
"When authentication is required, the server sends a header (as well as the "
"401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""

#: ../Doc/howto/urllib2.rst:452
msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is 'basic "
"authentication'. In order to simplify this process we can create an instance "
"of ``HTTPBasicAuthHandler`` and an opener to use this handler."
msgstr ""

#: ../Doc/howto/urllib2.rst:457
msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the server), "
"then you can use a ``HTTPPasswordMgr``. Frequently one doesn't care what the "
"realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default "
"username and password for a URL. This will be supplied in the absence of you "
"providing an alternative combination for a specific realm. We indicate this "
"by providing ``None`` as the realm argument to the ``add_password`` method."
msgstr ""

#: ../Doc/howto/urllib2.rst:467
msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr ""

#: ../Doc/howto/urllib2.rst:492
msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal situations "
"-- ``ProxyHandler`` (if a proxy setting such as an :envvar:`http_proxy` "
"environment variable is set), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``HTTPErrorProcessor``."
msgstr ""

#: ../Doc/howto/urllib2.rst:499
msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"\"http://example.com/\" *or* an \"authority\" (i.e. the hostname, optionally "
"including the port number) e.g. \"example.com\" or \"example.com:8080\" (the "
"latter example includes a port number).  The authority, if present, must NOT "
"contain the \"userinfo\" component - for example \"joe:password@example.com"
"\" is not correct."
msgstr ""

#: ../Doc/howto/urllib2.rst:509
msgid "Proxies"
msgstr ""

#: ../Doc/howto/urllib2.rst:511
msgid ""
"**urllib2** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain when "
"a proxy setting is detected.  Normally that's a good thing, but there are "
"occasions when it may not be helpful [#]_. One way to do this is to setup "
"our own ``ProxyHandler``, with no proxies defined. This is done using "
"similar steps to setting up a `Basic Authentication`_ handler: ::"
msgstr ""

#: ../Doc/howto/urllib2.rst:524
msgid ""
"Currently ``urllib2`` *does not* support fetching of ``https`` locations "
"through a proxy.  However, this can be enabled by extending urllib2 as shown "
"in the recipe [#]_."
msgstr ""

#: ../Doc/howto/urllib2.rst:530
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.getproxies`."
msgstr ""

#: ../Doc/howto/urllib2.rst:535
msgid "Sockets and Layers"
msgstr ""

#: ../Doc/howto/urllib2.rst:537
msgid ""
"The Python support for fetching resources from the web is layered. urllib2 "
"uses the httplib library, which in turn uses the socket library."
msgstr ""

#: ../Doc/howto/urllib2.rst:540
msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have to "
"fetch web pages. By default the socket module has *no timeout* and can hang. "
"Currently, the socket timeout is not exposed at the httplib or urllib2 "
"levels.  However, you can set the default timeout globally for all sockets "
"using ::"
msgstr ""

#: ../Doc/howto/urllib2.rst:563
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/howto/urllib2.rst:565
msgid "This document was reviewed and revised by John Lee."
msgstr ""

#: ../Doc/howto/urllib2.rst:567
msgid ""
"For an introduction to the CGI protocol see `Writing Web Applications in "
"Python <http://www.pyzine.com/Issue008/Section_Articles/article_CGIOne."
"html>`_."
msgstr ""

#: ../Doc/howto/urllib2.rst:569
msgid "Google for example."
msgstr ""

#: ../Doc/howto/urllib2.rst:570
msgid ""
"Browser sniffing is a very bad practise for website design - building sites "
"using web standards is much more sensible. Unfortunately a lot of sites "
"still send different versions to different browsers."
msgstr ""

#: ../Doc/howto/urllib2.rst:573
msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT "
"5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""

#: ../Doc/howto/urllib2.rst:575
msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr ""

#: ../Doc/howto/urllib2.rst:577
msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE is "
"set to use the proxy, which urllib2 picks up on. In order to test scripts "
"with a localhost server, I have to prevent urllib2 from using the proxy."
msgstr ""

#: ../Doc/howto/urllib2.rst:582
msgid ""
"urllib2 opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe "
"<https://code.activestate.com/recipes/456195/>`_."
msgstr ""
