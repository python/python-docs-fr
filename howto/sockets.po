# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-24 09:01+0200\n"
"PO-Revision-Date: 2020-05-08 15:38+0200\n"
"Last-Translator: Mathieu Dupuy <deronnax@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.3\n"

#: howto/sockets.rst:5
msgid "Socket Programming HOWTO"
msgstr "Guide pratique : programmation avec les *sockets*"

#: howto/sockets.rst:0
msgid "Author"
msgstr "Auteur"

#: howto/sockets.rst:7
msgid "Gordon McMillan"
msgstr "Gordon McMillan"

#: howto/sockets.rst:None
msgid "Abstract"
msgstr "Résumé"

#: howto/sockets.rst:12
msgid ""
"Sockets are used nearly everywhere, but are one of the most severely "
"misunderstood technologies around. This is a 10,000 foot overview of "
"sockets. It's not really a tutorial - you'll still have work to do in "
"getting things operational. It doesn't cover the fine points (and there are "
"a lot of them), but I hope it will give you enough background to begin using "
"them decently."
msgstr ""
"Les connecteurs (*sockets*, en anglais) sont utilisés presque partout, mais "
"ils sont l'une des technologies les plus méconnues. En voici un aperçu très "
"général. Ce n'est pas vraiment un tutoriel — vous aurez encore du travail à "
"faire pour avoir un résultat opérationnel. Il ne couvre pas les détails (et "
"il y en a beaucoup), mais j'espère qu'il vous donnera suffisamment "
"d'informations pour commencer à les utiliser correctement."

#: howto/sockets.rst:20
msgid "Sockets"
msgstr "Connecteurs (*sockets*)"

#: howto/sockets.rst:22
msgid ""
"I'm only going to talk about INET (i.e. IPv4) sockets, but they account for "
"at least 99% of the sockets in use. And I'll only talk about STREAM (i.e. "
"TCP) sockets - unless you really know what you're doing (in which case this "
"HOWTO isn't for you!), you'll get better behavior and performance from a "
"STREAM socket than anything else. I will try to clear up the mystery of what "
"a socket is, as well as some hints on how to work with blocking and non-"
"blocking sockets. But I'll start by talking about blocking sockets. You'll "
"need to know how they work before dealing with non-blocking sockets."
msgstr ""
"Je ne parlerai que des connecteurs *INET* (c'est-à-dire IPv4), mais ils "
"représentent au moins 99 % des connecteurs utilisés. Et je ne parlerai que "
"des connecteurs *STREAM* (c.-à-d. *TCP*) — à moins que vous ne sachiez "
"vraiment ce que vous faites (auquel cas ce guide n'est pas pour vous), vous "
"obtiendrez un meilleur comportement et de meilleures performances avec un "
"connecteur *STREAM* qu'avec n'importe quel autre. Je vais essayer "
"d'éclaircir le mystère de ce qu'est un connecteur, ainsi que quelques "
"conseils sur la façon de travailler avec des connecteurs bloquants et non "
"bloquants. Mais je commencerai par parler des connecteurs bloquants. Vous "
"devez savoir comment ils fonctionnent avant de vous intéresser aux "
"connecteurs non bloquants."

#: howto/sockets.rst:31
msgid ""
"Part of the trouble with understanding these things is that \"socket\" can "
"mean a number of subtly different things, depending on context. So first, "
"let's make a distinction between a \"client\" socket - an endpoint of a "
"conversation, and a \"server\" socket, which is more like a switchboard "
"operator. The client application (your browser, for example) uses \"client\" "
"sockets exclusively; the web server it's talking to uses both \"server\" "
"sockets and \"client\" sockets."
msgstr ""
"Une partie de la difficulté à comprendre ces choses est que « connecteur » "
"peut désigner plusieurs choses très légèrement différentes, selon le "
"contexte. Faisons donc d'abord une distinction entre un connecteur "
"« client » — point final d'une conversation — et un connecteur « serveur », "
"qui ressemble davantage à un standardiste. L'application cliente (votre "
"navigateur par exemple) utilise exclusivement des connecteurs « client » ; "
"le serveur web avec lequel elle parle utilise à la fois des connecteurs "
"« serveur » et des connecteurs « client »."

#: howto/sockets.rst:40
msgid "History"
msgstr "Historique"

#: howto/sockets.rst:42
msgid ""
"Of the various forms of :abbr:`IPC (Inter Process Communication)`, sockets "
"are by far the most popular.  On any given platform, there are likely to be "
"other forms of IPC that are faster, but for cross-platform communication, "
"sockets are about the only game in town."
msgstr ""
"Parmi les différentes formes d’:abbr:`IPC (Inter Process Communication)`, "
"les connecteurs sont de loin les plus populaires. Sur une plate-forme "
"donnée, il est probable que d'autres formes d'\\ *IPC* soient plus rapides, "
"mais pour la communication entre plates-formes, les connecteurs sont à peu "
"près la seule solution valable."

#: howto/sockets.rst:47
msgid ""
"They were invented in Berkeley as part of the BSD flavor of Unix. They "
"spread like wildfire with the Internet. With good reason --- the combination "
"of sockets with INET makes talking to arbitrary machines around the world "
"unbelievably easy (at least compared to other schemes)."
msgstr ""
"Ils ont été inventés à Berkeley dans le cadre de la déclinaison *BSD* "
"d'Unix. Ils se sont répandus comme une traînée de poudre avec Internet. Et "
"pour cause : la combinaison des connecteurs avec *INET* rend le dialogue "
"avec n’importe quelle machine dans le monde entier incroyablement facile (du "
"moins par rapport à d'autres systèmes)."

#: howto/sockets.rst:54
msgid "Creating a Socket"
msgstr "Création d'un connecteur"

#: howto/sockets.rst:56
msgid ""
"Roughly speaking, when you clicked on the link that brought you to this "
"page, your browser did something like the following::"
msgstr ""
"Grosso modo, lorsque vous avez cliqué sur le lien qui vous a amené à cette "
"page, votre navigateur a fait quelque chose comme ceci ::"

#: howto/sockets.rst:64
msgid ""
"When the ``connect`` completes, the socket ``s`` can be used to send in a "
"request for the text of the page. The same socket will read the reply, and "
"then be destroyed. That's right, destroyed. Client sockets are normally only "
"used for one exchange (or a small set of sequential exchanges)."
msgstr ""
"Lorsque l’appel à ``connect`` est terminé, le connecteur ``s`` peut être "
"utilisé pour envoyer une requête demandant le texte de la page. Le même "
"connecteur lira la réponse, puis sera mis au rebut. C'est exact, mis au "
"rebut. Les connecteurs clients ne sont normalement utilisés que pour un seul "
"échange (ou un petit ensemble d'échanges séquentiels)."

#: howto/sockets.rst:70
msgid ""
"What happens in the web server is a bit more complex. First, the web server "
"creates a \"server socket\"::"
msgstr ""
"Ce qui se passe dans le serveur web est un peu plus complexe. Tout d'abord, "
"le serveur web crée un « connecteur serveur » ::"

#: howto/sockets.rst:80
msgid ""
"A couple things to notice: we used ``socket.gethostname()`` so that the "
"socket would be visible to the outside world.  If we had used ``s."
"bind(('localhost', 80))`` or ``s.bind(('127.0.0.1', 80))`` we would still "
"have a \"server\" socket, but one that was only visible within the same "
"machine.  ``s.bind(('', 80))`` specifies that the socket is reachable by any "
"address the machine happens to have."
msgstr ""
"Quelques remarques : nous avons utilisé ``socket.gethostname()`` pour que le "
"connecteur soit visible par le monde extérieur.  Si nous avions utilisé ``s."
"bind(('localhost', 80))`` ou ``s.bind(('127.0.0.1', 80))``, nous aurions "
"toujours un connecteur « serveur », mais qui ne serait visible qu'à "
"l'intérieur de la même machine. ``s.bind(('', 80))`` précise que le "
"connecteur est accessible par n'importe quelle adresse que la machine "
"possède."

#: howto/sockets.rst:87
msgid ""
"A second thing to note: low number ports are usually reserved for \"well "
"known\" services (HTTP, SNMP etc). If you're playing around, use a nice high "
"number (4 digits)."
msgstr ""
"Une deuxième chose à noter : les ports dont le numéro est petit sont "
"généralement réservés aux services « bien connus » (HTTP, SNMP, etc.). Si "
"vous expérimentez, utilisez un nombre suffisamment élevé (4 chiffres)."

#: howto/sockets.rst:91
msgid ""
"Finally, the argument to ``listen`` tells the socket library that we want it "
"to queue up as many as 5 connect requests (the normal max) before refusing "
"outside connections. If the rest of the code is written properly, that "
"should be plenty."
msgstr ""
"Enfin, l'argument passé à ``listen`` indique à la bibliothèque de "
"connecteurs que nous voulons mettre en file d'attente jusqu'à 5 requêtes de "
"connexion (le maximum normal) avant de refuser les connexions externes. Si "
"le reste du code est écrit correctement, cela devrait suffire."

#: howto/sockets.rst:95
msgid ""
"Now that we have a \"server\" socket, listening on port 80, we can enter the "
"mainloop of the web server::"
msgstr ""
"Maintenant que nous avons un connecteur « serveur », en écoute sur le port "
"80, nous pouvons entrer dans la boucle principale du serveur web ::"

#: howto/sockets.rst:106
msgid ""
"There's actually 3 general ways in which this loop could work - dispatching "
"a thread to handle ``clientsocket``, create a new process to handle "
"``clientsocket``, or restructure this app to use non-blocking sockets, and "
"multiplex between our \"server\" socket and any active ``clientsocket``\\ s "
"using ``select``. More about that later. The important thing to understand "
"now is this: this is *all* a \"server\" socket does. It doesn't send any "
"data. It doesn't receive any data. It just produces \"client\" sockets. Each "
"``clientsocket`` is created in response to some *other* \"client\" socket "
"doing a ``connect()`` to the host and port we're bound to. As soon as we've "
"created that ``clientsocket``, we go back to listening for more connections. "
"The two \"clients\" are free to chat it up - they are using some dynamically "
"allocated port which will be recycled when the conversation ends."
msgstr ""
"Il y a en fait trois façons générales de faire fonctionner cette boucle : "
"mobiliser un fil d'exécution pour gérer les ``clientsocket``\\s, créer un "
"nouveau processus pour gérer les ``clientsocket``\\s, ou restructurer cette "
"application pour utiliser des connecteurs non bloquants, et multiplexer "
"entre notre connecteur « serveur » et n'importe quel ``clientsocket`` actif "
"en utilisant ``select``. Plus d'informations à ce sujet plus tard. La chose "
"importante à comprendre maintenant est la suivante : c'est *tout* ce que "
"fait un connecteur « serveur ». Il n'envoie aucune donnée. Il ne reçoit "
"aucune donnée. Il ne fait que produire des connecteurs « clients ». Chaque "
"``clientsocket`` est créé en réponse à un *autre* connecteur « client » qui "
"se connecte à l'hôte et au port auxquels nous sommes liés. Dès que nous "
"avons créé ce ``clientsocket``, nous retournons à l'écoute pour d'autres "
"connexions. Les deux « clients » sont libres de discuter — ils utilisent un "
"port alloué dynamiquement qui sera recyclé à la fin de la conversation."

#: howto/sockets.rst:121
msgid "IPC"
msgstr "*IPC* (Communication Entre Processus)"

#: howto/sockets.rst:123
msgid ""
"If you need fast IPC between two processes on one machine, you should look "
"into pipes or shared memory.  If you do decide to use AF_INET sockets, bind "
"the \"server\" socket to ``'localhost'``. On most platforms, this will take "
"a shortcut around a couple of layers of network code and be quite a bit "
"faster."
msgstr ""
"Si vous avez besoin d'une communication rapide entre deux processus sur une "
"même machine, vous devriez regarder comment utiliser les tubes (*pipe*, en "
"anglais) ou la mémoire partagée. Si vous décidez d'utiliser les connecteurs "
"*AF_INET*, liez le connecteur « serveur » à ``'localhost'``. Sur la plupart "
"des plates-formes, cela contourne quelques couches réseau et est un peu plus "
"rapide."

#: howto/sockets.rst:129
msgid ""
"The :mod:`multiprocessing` integrates cross-platform IPC into a higher-level "
"API."
msgstr ""
"Le :mod:`multiprocessing` intègre de l’IPC multiplateforme dans une API de "
"plus haut niveau."

#: howto/sockets.rst:134
msgid "Using a Socket"
msgstr "Utilisation d'un connecteur"

#: howto/sockets.rst:136
msgid ""
"The first thing to note, is that the web browser's \"client\" socket and the "
"web server's \"client\" socket are identical beasts. That is, this is a "
"\"peer to peer\" conversation. Or to put it another way, *as the designer, "
"you will have to decide what the rules of etiquette are for a conversation*. "
"Normally, the ``connect``\\ ing socket starts the conversation, by sending "
"in a request, or perhaps a signon. But that's a design decision - it's not a "
"rule of sockets."
msgstr ""
"La première chose à noter, c'est que la prise « client » du navigateur web "
"et la prise « client » du serveur web sont des bêtes identiques. C'est-à-"
"dire qu'il s'agit d'une conversation « pair à pair ». Ou pour le dire "
"autrement, *en tant que concepteur, vous devrez décider quelles sont les "
"règles d'étiquette pour une conversation*. Normalement, la connexion via "
"``connect`` lance la conversation en envoyant une demande, ou peut-être un "
"signe. Mais c'est une décision de conception — ce n'est pas une règle des "
"connecteurs."

#: howto/sockets.rst:143
msgid ""
"Now there are two sets of verbs to use for communication. You can use "
"``send`` and ``recv``, or you can transform your client socket into a file-"
"like beast and use ``read`` and ``write``. The latter is the way Java "
"presents its sockets. I'm not going to talk about it here, except to warn "
"you that you need to use ``flush`` on sockets. These are buffered \"files\", "
"and a common mistake is to ``write`` something, and then ``read`` for a "
"reply. Without a ``flush`` in there, you may wait forever for the reply, "
"because the request may still be in your output buffer."
msgstr ""
"Il y a maintenant deux ensembles de verbes à utiliser pour la communication. "
"Vous pouvez utiliser ``send`` et ``recv``, ou vous pouvez transformer votre "
"connecteur client en une bête imitant un fichier et utiliser ``read`` et "
"``write``. C'est la façon dont Java présente ses connecteurs. Je ne vais pas "
"en parler ici, sauf pour vous avertir que vous devez utiliser ``flush`` sur "
"les connecteurs. Ce sont des « fichiers », mis en mémoire tampon, et une "
"erreur courante est d'« écrire » via ``write`` quelque chose, puis de "
"« lire » via ``read`` pour obtenir une réponse. Sans un ``flush``, vous "
"pouvez attendre la réponse pour toujours, parce que la requête peut encore "
"être dans votre mémoire tampon de sortie."

#: howto/sockets.rst:152
msgid ""
"Now we come to the major stumbling block of sockets - ``send`` and ``recv`` "
"operate on the network buffers. They do not necessarily handle all the bytes "
"you hand them (or expect from them), because their major focus is handling "
"the network buffers. In general, they return when the associated network "
"buffers have been filled (``send``) or emptied (``recv``). They then tell "
"you how many bytes they handled. It is *your* responsibility to call them "
"again until your message has been completely dealt with."
msgstr ""
"Nous arrivons maintenant au principal écueil des connecteurs — ``send`` et "
"``recv`` fonctionnent sur les mémoires tampons du réseau. Ils ne traitent "
"pas nécessairement tous les octets que vous leur passez (ou que vous "
"attendez d'eux), car leur principal objectif est de gérer les tampons "
"réseau. En général, leur exécution se termine lorsque les tampons réseau "
"associés ont été remplis (``send``) ou vidés (``recv``). Ils vous indiquent "
"alors combien d'octets ils ont traité. Il est de *votre* responsabilité de "
"les rappeler jusqu'à ce que votre message ait été complètement traité."

#: howto/sockets.rst:160
msgid ""
"When a ``recv`` returns 0 bytes, it means the other side has closed (or is "
"in the process of closing) the connection.  You will not receive any more "
"data on this connection. Ever.  You may be able to send data successfully; "
"I'll talk more about this later."
msgstr ""
"Lorsqu'un ``recv`` renvoie 0 octet, cela signifie que l'autre partie a fermé "
"(ou est en train de fermer) la connexion. Vous ne recevrez plus de données "
"sur cette connexion. Jamais. Vous pouvez peut-être envoyer des données avec "
"succès. J’en parlerai plus tard."

#: howto/sockets.rst:165
msgid ""
"A protocol like HTTP uses a socket for only one transfer. The client sends a "
"request, then reads a reply.  That's it. The socket is discarded. This means "
"that a client can detect the end of the reply by receiving 0 bytes."
msgstr ""
"Un protocole comme HTTP utilise un connecteur pour un seul transfert. Le "
"client envoie une demande, puis lit une réponse. C'est tout. Le connecteur "
"est mis au rebut. Cela signifie qu'un client peut détecter la fin de la "
"réponse en recevant 0 octet."

#: howto/sockets.rst:169
msgid ""
"But if you plan to reuse your socket for further transfers, you need to "
"realize that *there is no* :abbr:`EOT (End of Transfer)` *on a socket.* I "
"repeat: if a socket ``send`` or ``recv`` returns after handling 0 bytes, the "
"connection has been broken.  If the connection has *not* been broken, you "
"may wait on a ``recv`` forever, because the socket will *not* tell you that "
"there's nothing more to read (for now).  Now if you think about that a bit, "
"you'll come to realize a fundamental truth of sockets: *messages must either "
"be fixed length* (yuck), *or be delimited* (shrug), *or indicate how long "
"they are* (much better), *or end by shutting down the connection*. The "
"choice is entirely yours, (but some ways are righter than others)."
msgstr ""
"Mais si vous prévoyez de réutiliser votre connecteur pour d'autres "
"transferts, vous devez réaliser qu'\\ *il n'y a pas* d':abbr:`EOT (End of "
"Transfer)` *sur un connecteur*. Je répète : si un appel à ``send`` ou "
"``recv`` se termine après avoir traité 0 octet, la connexion a été "
"interrompue. Si la connexion n'a *pas* été interrompue, vous pouvez attendre "
"sur un ``recv`` pour toujours, car le connecteur ne vous dira pas qu'il n'y "
"a plus rien à lire (pour le moment). Maintenant, si vous y réfléchissez un "
"peu, vous allez vous rendre compte d'une vérité fondamentale sur les "
"connecteurs : *les messages doivent être de longueur fixe* (beurk), *ou être "
"délimités* (bof), *ou indiquer de quelle longueur ils sont* (beaucoup "
"mieux), *ou terminer en coupant la connexion*. Le choix est entièrement de "
"votre côté (mais certaines façons sont meilleurs que d'autres)."

#: howto/sockets.rst:180
msgid ""
"Assuming you don't want to end the connection, the simplest solution is a "
"fixed length message::"
msgstr ""
"En supposant que vous ne vouliez pas terminer la connexion, la solution la "
"plus simple est un message de longueur fixe ::"

#: howto/sockets.rst:217
msgid ""
"The sending code here is usable for almost any messaging scheme - in Python "
"you send strings, and you can use ``len()`` to determine its length (even if "
"it has embedded ``\\0`` characters). It's mostly the receiving code that "
"gets more complex. (And in C, it's not much worse, except you can't use "
"``strlen`` if the message has embedded ``\\0``\\ s.)"
msgstr ""
"Le code d'envoi ici est utilisable pour presque tous les systèmes de "
"messagerie — en Python, vous envoyez des chaînes de caractères, et vous "
"pouvez utiliser ``len()`` pour en déterminer la longueur (même si elle "
"contient des caractères ``\\0``). C'est surtout le code de réception qui "
"devient plus complexe. (Et en C, ce n'est pas bien pire, sauf que vous ne "
"pouvez pas utiliser ``strlen`` si le message contient des ``\\0``\\ s)."

#: howto/sockets.rst:223
msgid ""
"The easiest enhancement is to make the first character of the message an "
"indicator of message type, and have the type determine the length. Now you "
"have two ``recv``\\ s - the first to get (at least) that first character so "
"you can look up the length, and the second in a loop to get the rest. If you "
"decide to go the delimited route, you'll be receiving in some arbitrary "
"chunk size, (4096 or 8192 is frequently a good match for network buffer "
"sizes), and scanning what you've received for a delimiter."
msgstr ""
"Le plus simple est de faire du premier caractère du message un indicateur du "
"type de message, et de faire en sorte que le type détermine la longueur. "
"Vous avez maintenant deux ``recv``\\ s — le premier pour obtenir (au moins) "
"ce premier caractère afin de pouvoir déterminer la longueur, et le second "
"dans une boucle pour obtenir le reste. Si vous décidez de suivre la route "
"délimitée, vous recevrez un morceau de taille arbitraire (4096 ou 8192 est "
"fréquemment une bonne valeur pour correspondre à la taille de la mémoire "
"tampon du réseau), et vous analyserez ce que vous avez reçu pour trouver un "
"délimiteur."

#: howto/sockets.rst:231
msgid ""
"One complication to be aware of: if your conversational protocol allows "
"multiple messages to be sent back to back (without some kind of reply), and "
"you pass ``recv`` an arbitrary chunk size, you may end up reading the start "
"of a following message. You'll need to put that aside and hold onto it, "
"until it's needed."
msgstr ""
"Une subtilité dont il faut être conscient : si votre protocole de "
"conversation permet de renvoyer plusieurs messages les uns à la suite des "
"autres (sans aucune sorte de réponse), et que vous passez à ``recv`` une "
"taille de morceau arbitraire, vous pouvez en arriver à lire le début du "
"message suivant. Vous devrez alors le mettre de côté et le conserver, "
"jusqu'à ce que vous en ayez besoin."

#: howto/sockets.rst:237
msgid ""
"Prefixing the message with its length (say, as 5 numeric characters) gets "
"more complex, because (believe it or not), you may not get all 5 characters "
"in one ``recv``. In playing around, you'll get away with it; but in high "
"network loads, your code will very quickly break unless you use two ``recv`` "
"loops - the first to determine the length, the second to get the data part "
"of the message. Nasty. This is also when you'll discover that ``send`` does "
"not always manage to get rid of everything in one pass. And despite having "
"read this, you will eventually get bit by it!"
msgstr ""
"Préfixer le message avec sa longueur (disons, sous la forme de 5 caractères "
"numériques) devient plus complexe, parce que (croyez-le ou non), vous pouvez "
"ne pas recevoir les 5 caractères en un seul ``recv``. Pour une utilisation "
"triviale, vous vous en tirerez à bon compte ; mais en cas de forte charge "
"réseau, votre code se cassera très rapidement, à moins que vous n’utilisiez "
"deux boucles ``recv`` — la première pour déterminer la longueur, la deuxième "
"pour obtenir la partie « données » du message. Vilain. C’est aussi à ce "
"moment que vous découvrirez que « l’envoi » via ``send`` ne parvient pas "
"toujours à tout évacuer en un seul passage. Et bien que vous ayez lu cet "
"avertissement, vous finirez par vous faire avoir par cette subtilité !"

#: howto/sockets.rst:246
msgid ""
"In the interests of space, building your character, (and preserving my "
"competitive position), these enhancements are left as an exercise for the "
"reader. Lets move on to cleaning up."
msgstr ""
"Pour garder une longueur raisonnable à cette page, pour forger votre "
"caractère (et afin de garder l’avantage concurrentiel que j’ai sur vous), "
"ces améliorations ne seront pas abordées et sont laissées en exercice au "
"lecteur. Passons maintenant au nettoyage."

#: howto/sockets.rst:252
msgid "Binary Data"
msgstr "Données binaires"

#: howto/sockets.rst:254
msgid ""
"It is perfectly possible to send binary data over a socket. The major "
"problem is that not all machines use the same formats for binary data. For "
"example, a Motorola chip will represent a 16 bit integer with the value 1 as "
"the two hex bytes 00 01. Intel and DEC, however, are byte-reversed - that "
"same 1 is 01 00. Socket libraries have calls for converting 16 and 32 bit "
"integers - ``ntohl, htonl, ntohs, htons`` where \"n\" means *network* and \"h"
"\" means *host*, \"s\" means *short* and \"l\" means *long*. Where network "
"order is host order, these do nothing, but where the machine is byte-"
"reversed, these swap the bytes around appropriately."
msgstr ""
"Il est parfaitement possible d’envoyer des données binaires sur un "
"connecteur. Le gros problème est que toutes les machines n’utilisent pas les "
"mêmes formats pour les données binaires. Par exemple, une puce Motorola code "
"l'entier 1, sous 16 bits, comme les deux octets hexadécimaux 00 01. Intel et "
"DEC, cependant, utilisent l’ordre d’octets inverse — ce même 1 est codé 01 "
"00. Les bibliothèques de connecteurs ont des appels pour convertir des "
"entiers de 16 et 32 bits — ``ntohl, htonl, ntohs, htons`` où ``n`` signifie "
"*réseau* (*network*, en anglais) et ``h`` signifie *hôte*, ``s`` signifie "
"*court* (*short*, en anglais) et ``l`` signifie *long*. Lorsque l’ordre du "
"réseau est l’ordre de l’hôte, ceux-ci ne font rien, mais lorsque la machine "
"utilise l’ordre d’octets inverse, ceux-ci échangent les octets de manière "
"appropriée."

#: howto/sockets.rst:264
msgid ""
"In these days of 32 bit machines, the ascii representation of binary data is "
"frequently smaller than the binary representation. That's because a "
"surprising amount of the time, all those longs have the value 0, or maybe 1. "
"The string \"0\" would be two bytes, while binary is four. Of course, this "
"doesn't fit well with fixed-length messages. Decisions, decisions."
msgstr ""
"De nos jours, avec les machines 32 bits, la représentation *ASCII* des "
"données binaires est souvent plus compacte que la représentation binaire. "
"C’est parce qu’un nombre surprenant de fois, tous ces *longs* ont la valeur "
"0, ou peut-être 1. La chaîne « 0 » serait codée sur deux octets, alors "
"qu'elle le serait sur quatre en binaire. Bien sûr, cela ne fonctionne pas "
"très bien avec les messages de longueur fixe. Ah, les décisions, les "
"décisions…"

#: howto/sockets.rst:272
msgid "Disconnecting"
msgstr "Déconnexion"

#: howto/sockets.rst:274
msgid ""
"Strictly speaking, you're supposed to use ``shutdown`` on a socket before "
"you ``close`` it.  The ``shutdown`` is an advisory to the socket at the "
"other end. Depending on the argument you pass it, it can mean \"I'm not "
"going to send anymore, but I'll still listen\", or \"I'm not listening, good "
"riddance!\".  Most socket libraries, however, are so used to programmers "
"neglecting to use this piece of etiquette that normally a ``close`` is the "
"same as ``shutdown(); close()``.  So in most situations, an explicit "
"``shutdown`` is not needed."
msgstr ""
"À proprement parler, vous êtes censé utiliser ``shutdown`` sur un connecteur "
"pour l’arrêter avant de le fermer via ``close``. Le ``shutdown`` est un "
"avertissement au connecteur de l’autre côté. Selon l’argument que vous lui "
"passez, cela peut signifier « Je ne vais plus envoyer, mais je vais quand "
"même écouter », ou « Je n’écoute pas, bon débarras ! ». La plupart des "
"bibliothèques de connecteurs, cependant, sont tellement habituées à ce que "
"les programmeurs négligent d’utiliser ce morceau d’étiquette que normalement "
"un ``close`` est équivalent à ``shutdown() ; close()``. Ainsi, dans la "
"plupart des situations, un ``shutdown`` explicite n’est pas nécessaire."

#: howto/sockets.rst:282
msgid ""
"One way to use ``shutdown`` effectively is in an HTTP-like exchange. The "
"client sends a request and then does a ``shutdown(1)``. This tells the "
"server \"This client is done sending, but can still receive.\"  The server "
"can detect \"EOF\" by a receive of 0 bytes. It can assume it has the "
"complete request.  The server sends a reply. If the ``send`` completes "
"successfully then, indeed, the client was still receiving."
msgstr ""
"Une façon d’utiliser efficacement le ``shutdown`` est d’utiliser un échange "
"de type HTTP. Le client envoie une requête et effectue ensuite un "
"``shutdown(1)``. Cela indique au serveur que « ce client a fini d’envoyer, "
"mais peut encore recevoir ». Le serveur peut détecter *EOF* par une "
"réception de 0 octet. Il peut supposer qu’il a la requête complète. Le "
"serveur envoie une réponse. Si le ``send`` se termine avec succès, alors, en "
"effet, le client était encore en train de recevoir."

#: howto/sockets.rst:289
msgid ""
"Python takes the automatic shutdown a step further, and says that when a "
"socket is garbage collected, it will automatically do a ``close`` if it's "
"needed. But relying on this is a very bad habit. If your socket just "
"disappears without doing a ``close``, the socket at the other end may hang "
"indefinitely, thinking you're just being slow. *Please* ``close`` your "
"sockets when you're done."
msgstr ""
"Python pousse l’arrêt automatique un peu plus loin, et dit que lorsqu’un "
"connecteur est collecté par le ramasse-miette, il effectue automatiquement "
"une fermeture via ``close`` si elle est nécessaire. Mais c’est une très "
"mauvaise habitude de s’appuyer sur ce système. Si votre connecteur disparaît "
"sans avoir fait un ``close``, le connecteur à l’autre bout peut rester "
"suspendu indéfiniment, pensant que vous êtes juste lent. Fermez vos "
"connecteurs quand vous avez terminé *s’il vous plait*."

#: howto/sockets.rst:297
msgid "When Sockets Die"
msgstr "Quand les connecteurs meurent"

#: howto/sockets.rst:299
msgid ""
"Probably the worst thing about using blocking sockets is what happens when "
"the other side comes down hard (without doing a ``close``). Your socket is "
"likely to hang. TCP is a reliable protocol, and it will wait a long, long "
"time before giving up on a connection. If you're using threads, the entire "
"thread is essentially dead. There's not much you can do about it. As long as "
"you aren't doing something dumb, like holding a lock while doing a blocking "
"read, the thread isn't really consuming much in the way of resources. Do "
"*not* try to kill the thread - part of the reason that threads are more "
"efficient than processes is that they avoid the overhead associated with the "
"automatic recycling of resources. In other words, if you do manage to kill "
"the thread, your whole process is likely to be screwed up."
msgstr ""
"Le pire dans l'utilisation de connecteurs bloquants est probablement ce qui "
"se passe lorsque l'autre côté s'interrompt brutalement (sans faire de "
"fermeture via ``close``). Votre connecteur risque d’attendre infiniment. TCP "
"est un protocole fiable, et il attendra très, très longtemps avant "
"d'abandonner une connexion. Si vous utilisez des fils d’exécution, le fil "
"entier est pratiquement mort. Il n'y a pas grand-chose que vous puissiez "
"faire à ce sujet. Du moment que vous ne faites rien de stupide, comme tenir "
"un verrou verrouillé pendant une lecture bloquante, le fil ne consomme pas "
"vraiment beaucoup de ressources. N'essayez *pas* de tuer le fil — si les "
"fils sont plus efficients que les processus, c'est en partie parce qu'ils "
"évitent les coûts significatifs liés au recyclage automatique des "
"ressources. En d'autres termes, si vous parvenez à tuer le fil, tout votre "
"processus risque d'être foutu."

#: howto/sockets.rst:313
msgid "Non-blocking Sockets"
msgstr "Connecteurs non bloquants"

#: howto/sockets.rst:315
msgid ""
"If you've understood the preceding, you already know most of what you need "
"to know about the mechanics of using sockets. You'll still use the same "
"calls, in much the same ways. It's just that, if you do it right, your app "
"will be almost inside-out."
msgstr ""
"Si vous avez compris ce qui précède, vous savez déjà tout ce que vous devez "
"savoir sur la mécanique de l’utilisation des connecteurs. Vous utiliserez "
"toujours les mêmes appels, de la même façon. Il n’y que ça. Si vous le "
"faites bien, c’est presque dans la poche."

#: howto/sockets.rst:320
#, fuzzy
msgid ""
"In Python, you use ``socket.setblocking(False)`` to make it non-blocking. In "
"C, it's more complex, (for one thing, you'll need to choose between the BSD "
"flavor ``O_NONBLOCK`` and the almost indistinguishable POSIX flavor "
"``O_NDELAY``, which is completely different from ``TCP_NODELAY``), but it's "
"the exact same idea. You do this after creating the socket, but before using "
"it. (Actually, if you're nuts, you can switch back and forth.)"
msgstr ""
"En Python, vous utilisez ``socket.setblocking(0)`` pour rendre non-bloquant. "
"En C, c’est plus complexe (pour commencer, vous devez choisir entre la "
"version BSD ``O_NONBLOCK`` et la version POSIX presque impossible à "
"distinguer ``O_NDELAY``, qui est complètement différente de "
"``TCP_NODELAY``), mais c’est exactement la même idée. Vous le faites après "
"avoir créé le connecteur mais avant de l’utiliser (en fait, si vous êtes "
"fou, vous pouvez alterner)."

#: howto/sockets.rst:327
msgid ""
"The major mechanical difference is that ``send``, ``recv``, ``connect`` and "
"``accept`` can return without having done anything. You have (of course) a "
"number of choices. You can check return code and error codes and generally "
"drive yourself crazy. If you don't believe me, try it sometime. Your app "
"will grow large, buggy and suck CPU. So let's skip the brain-dead solutions "
"and do it right."
msgstr ""
"La différence majeure de fonctionnement est que `send``, ``recv``, "
"``connect`` et ``accept`` peuvent rendre la main sans avoir rien fait. Vous "
"avez (bien sûr) un certain nombre de choix. Vous pouvez vérifier le code de "
"retour et les codes d'erreur et, en général, devenir fou. Si vous ne me "
"croyez pas, essayez un jour. Votre application va grossir, boguer et "
"vampiriser le processeur. Alors, évitons les solutions vouées à l’échec dès "
"le départ et faisons les choses correctement."

#: howto/sockets.rst:334
msgid "Use ``select``."
msgstr "Utilisation de ``select``."

#: howto/sockets.rst:336
msgid ""
"In C, coding ``select`` is fairly complex. In Python, it's a piece of cake, "
"but it's close enough to the C version that if you understand ``select`` in "
"Python, you'll have little trouble with it in C::"
msgstr ""
"En C, implémenter ``select`` est assez complexe. En Python, c'est du gâteau, "
"mais c'est assez proche de la version C ; aussi, si vous comprenez "
"``select`` en Python, vous aurez peu de problèmes en C ::"

#: howto/sockets.rst:347
msgid ""
"You pass ``select`` three lists: the first contains all sockets that you "
"might want to try reading; the second all the sockets you might want to try "
"writing to, and the last (normally left empty) those that you want to check "
"for errors. You should note that a socket can go into more than one list. "
"The ``select`` call is blocking, but you can give it a timeout. This is "
"generally a sensible thing to do - give it a nice long timeout (say a "
"minute) unless you have good reason to do otherwise."
msgstr ""
"Vous passez à ``select`` trois listes : la première contient tous les "
"connecteurs dont vous souhaiter lire le contenu ; la deuxième tous les "
"connecteurs sur lesquels vous voudriez écrire, et la dernière (normalement "
"laissée vide) ceux sur lesquels vous voudriez vérifier s’il y a des erreurs. "
"Prenez note qu'un connecteur peut figurer dans plus d'une liste. L'appel à "
"``select`` est bloquant, mais vous pouvez lui donner un délai d'attente. "
"C'est généralement une bonne chose à faire — donnez-lui un bon gros délai "
"d'attente (disons une minute), à moins que vous n'ayez une bonne raison de "
"ne pas le faire."

#: howto/sockets.rst:355
msgid ""
"In return, you will get three lists. They contain the sockets that are "
"actually readable, writable and in error. Each of these lists is a subset "
"(possibly empty) of the corresponding list you passed in."
msgstr ""
"En retour, vous recevrez trois listes. Elles contiennent les connecteurs qui "
"sont réellement lisibles, inscriptibles et en erreur. Chacune de ces listes "
"est un sous-ensemble (éventuellement vide) de la liste correspondante que "
"vous avez transmise."

#: howto/sockets.rst:359
msgid ""
"If a socket is in the output readable list, you can be as-close-to-certain-"
"as-we-ever-get-in-this-business that a ``recv`` on that socket will return "
"*something*. Same idea for the writable list. You'll be able to send "
"*something*. Maybe not all you want to, but *something* is better than "
"nothing.  (Actually, any reasonably healthy socket will return as writable - "
"it just means outbound network buffer space is available.)"
msgstr ""
"Si un connecteur se trouve dans la liste renvoyée des connecteurs lisibles, "
"vous pouvez être pratiquement certain qu'un ``recv`` sur ce connecteur "
"renvoie *quelque chose*. Même chose pour la liste renvoyée des connecteurs "
"inscriptibles. Vous pourrez envoyer *quelque chose*. Peut-être pas tout ce "
"que vous voudrez, mais *quelque chose* est mieux que rien (en fait, "
"n'importe quel connecteur raisonnablement sain sera présent dans la liste "
"des connecteurs inscriptibles — cela signifie simplement que l'espace tampon "
"réseau sortant est disponible)."

#: howto/sockets.rst:366
msgid ""
"If you have a \"server\" socket, put it in the potential_readers list. If it "
"comes out in the readable list, your ``accept`` will (almost certainly) "
"work. If you have created a new socket to ``connect`` to someone else, put "
"it in the potential_writers list. If it shows up in the writable list, you "
"have a decent chance that it has connected."
msgstr ""
"Si vous avez un connecteur « serveur », mettez-le dans la liste des "
"connecteurs potentiellement lisibles ``potential_readers``. S’il apparaît "
"dans la liste renvoyée des connecteurs que vous pouvez lire, votre "
"``accept`` fonctionnera (presque certainement). Si vous avez créé un nouveau "
"connecteur pour se connecter via ``connect`` à quelqu'un d'autre, mettez-le "
"dans la liste des connecteurs potentiellement inscriptibles. S’il apparaît "
"dans la liste renvoyée des connecteurs sur lesquels vous pouvez écrire, vous "
"avez une bonne chance qu'il se soit connecté."

#: howto/sockets.rst:372
msgid ""
"Actually, ``select`` can be handy even with blocking sockets. It's one way "
"of determining whether you will block - the socket returns as readable when "
"there's something in the buffers.  However, this still doesn't help with the "
"problem of determining whether the other end is done, or just busy with "
"something else."
msgstr ""
"En fait, ``select`` peut être pratique même avec des connecteurs bloquants. "
"C'est une façon de déterminer si vous allez bloquer — le connecteur est "
"renvoyé comme lisible lorsqu'il y a quelque chose dans les mémoires tampons. "
"Cependant, cela n'aide pas encore à déterminer si l'autre extrémité a "
"terminé, ou si elle est simplement occupée par autre chose."

#: howto/sockets.rst:377
msgid ""
"**Portability alert**: On Unix, ``select`` works both with the sockets and "
"files. Don't try this on Windows. On Windows, ``select`` works with sockets "
"only. Also note that in C, many of the more advanced socket options are done "
"differently on Windows. In fact, on Windows I usually use threads (which "
"work very, very well) with my sockets."
msgstr ""
"**Alerte de portabilité** : Sous Unix, ``select`` fonctionne aussi bien avec "
"les connecteurs qu'avec les fichiers. N'essayez pas cela sous Windows. Sous "
"Windows, ``select`` ne fonctionne qu'avec les connecteurs. Notez également "
"qu'en C, la plupart des options de connecteurs les plus avancées se font "
"différemment sous Windows. En fait, sous Windows, j'utilise habituellement "
"des fils d'exécution (qui fonctionnent très, très bien) avec mes connecteurs."
