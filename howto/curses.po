# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-18 15:46+0200\n"
"PO-Revision-Date: 2020-09-04 23:34+0200\n"
"Last-Translator: Khaïs COLIN <kh.col@orange.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.4\n"

#: howto/curses.rst:5
msgid "Curses Programming with Python"
msgstr "Programmation *Curses* avec Python"

#: howto/curses.rst:0
msgid "Author"
msgstr "Auteur"

#: howto/curses.rst:7
msgid "A.M. Kuchling, Eric S. Raymond"
msgstr "A.M. Kuchling, Eric S. Raymond"

#: howto/curses.rst:0
msgid "Release"
msgstr "Version"

#: howto/curses.rst:8
msgid "2.04"
msgstr "2.04"

#: howto/curses.rst:None
msgid "Abstract"
msgstr "Résumé"

#: howto/curses.rst:13
msgid ""
"This document describes how to use the :mod:`curses` extension module to "
"control text-mode displays."
msgstr ""
"Ce document décrit comment utiliser le module d'extension :mod:`curses` pour "
"contrôler l'affichage en mode texte."

#: howto/curses.rst:18
msgid "What is curses?"
msgstr "Qu'est-ce que *curses* ?"

#: howto/curses.rst:20
msgid ""
"The curses library supplies a terminal-independent screen-painting and "
"keyboard-handling facility for text-based terminals; such terminals include "
"VT100s, the Linux console, and the simulated terminal provided by various "
"programs.  Display terminals support various control codes to perform common "
"operations such as moving the cursor, scrolling the screen, and erasing "
"areas.  Different terminals use widely differing codes, and often have their "
"own minor quirks."
msgstr ""
"La bibliothèque *curses* fournit une capacité de dessin à l'écran et de "
"gestion du clavier indépendante du terminal pour les terminaux textuels ; "
"ces terminaux comprennent les *VT100*, la console Linux et le terminal "
"simulé fourni par divers programmes. Les terminaux d'affichage prennent en "
"charge divers codes de commande pour effectuer des opérations courantes "
"telles que déplacer le curseur, faire défiler l'écran et effacer des zones. "
"Différents terminaux utilisent des codes très différents et ont souvent "
"leurs propres bizarreries mineures."

#: howto/curses.rst:28
msgid ""
"In a world of graphical displays, one might ask \"why bother\"?  It's true "
"that character-cell display terminals are an obsolete technology, but there "
"are niches in which being able to do fancy things with them are still "
"valuable.  One niche is on small-footprint or embedded Unixes that don't run "
"an X server.  Another is tools such as OS installers and kernel "
"configurators that may have to run before any graphical support is available."
msgstr ""
"Dans un monde d'affichages graphiques, on pourrait se demander « pourquoi "
"s'embêter ? ». Il est vrai que les terminaux d'affichage caractère par "
"caractère sont une technologie obsolète, mais il existe des niches pour "
"lesquelles la possibilité de faire des choses fantaisistes est encore "
"précieuse. En exemple de niche, on peut citer les systèmes de type Unix de "
"petite taille ou embarqués qui n'utilisent pas de serveur X. Il y a aussi "
"les outils tels que les installateurs d'OS et les outils de configuration du "
"noyau qui doivent être exécutés avant qu'un support graphique ne soit "
"disponible."

#: howto/curses.rst:36
msgid ""
"The curses library provides fairly basic functionality, providing the "
"programmer with an abstraction of a display containing multiple non-"
"overlapping windows of text.  The contents of a window can be changed in "
"various ways---adding text, erasing it, changing its appearance---and the "
"curses library will figure out what control codes need to be sent to the "
"terminal to produce the right output.  curses doesn't provide many user-"
"interface concepts such as buttons, checkboxes, or dialogs; if you need such "
"features, consider a user interface library such as `Urwid <https://pypi.org/"
"project/urwid/>`_."
msgstr ""
"La bibliothèque *curses* propose des fonctionnalités assez basiques, "
"fournissant au programmeur une abstraction d'affichage contenant plusieurs "
"fenêtres de texte qui ne se chevauchent pas. Le contenu d'une fenêtre peut "
"être modifié de différentes manières — en ajoutant du texte, en l'effaçant "
"ou en changeant son apparence — et la bibliothèque *curses* trouve quels "
"codes de contrôle doivent être envoyés au terminal pour produire le bon "
"résultat. *curses* ne fournit pas beaucoup de concepts d'interface "
"utilisateur tels que boutons, cases à cocher ou dialogues ; si vous avez "
"besoin de telles fonctionnalités, pensez à une bibliothèque d'interface "
"utilisateur comme `Urwid <https://pypi.org/project/urwid/>`_."

#: howto/curses.rst:46
msgid ""
"The curses library was originally written for BSD Unix; the later System V "
"versions of Unix from AT&T added many enhancements and new functions. BSD "
"curses is no longer maintained, having been replaced by ncurses, which is an "
"open-source implementation of the AT&T interface.  If you're using an open-"
"source Unix such as Linux or FreeBSD, your system almost certainly uses "
"ncurses.  Since most current commercial Unix versions are based on System V "
"code, all the functions described here will probably be available.  The "
"older versions of curses carried by some proprietary Unixes may not support "
"everything, though."
msgstr ""
"La bibliothèque *curses* a été écrite à l'origine pour BSD Unix ; les "
"dernières versions *System V* d'Unix d'AT&T ont ajouté de nombreuses "
"améliorations et de nouvelles fonctions. BSD *curses* n'est plus maintenu, "
"ayant été remplacé par *ncurses*, qui est une implémentation open-source de "
"l'interface AT&T. Si vous utilisez un Unix open-source comme Linux ou "
"FreeBSD, votre système utilise presque certainement *ncurses*. Comme la "
"plupart des versions commerciales actuelles d'Unix sont basées sur le code "
"*System V*, toutes les fonctions décrites ici seront probablement "
"disponibles. Les anciennes versions de *curses* portées par certains Unix "
"propriétaires pourraient ne pas gérer toutes les fonctions."

#: howto/curses.rst:56
msgid ""
"The Windows version of Python doesn't include the :mod:`curses` module.  A "
"ported version called `UniCurses <https://pypi.org/project/UniCurses>`_ is "
"available."
msgstr ""
"La version Windows de Python n'inclut pas le module :mod:`curses`. Une "
"version portée appelée `UniCurses <https://pypi.org/project/UniCurses>`_ est "
"disponible."

#: howto/curses.rst:62
msgid "The Python curses module"
msgstr "Le module *curses* de Python"

#: howto/curses.rst:64
msgid ""
"The Python module is a fairly simple wrapper over the C functions provided "
"by curses; if you're already familiar with curses programming in C, it's "
"really easy to transfer that knowledge to Python.  The biggest difference is "
"that the Python interface makes things simpler by merging different C "
"functions such as :c:func:`addstr`, :c:func:`mvaddstr`, and :c:func:"
"`mvwaddstr` into a single :meth:`~curses.window.addstr` method.  You'll see "
"this covered in more detail later."
msgstr ""
"Le module Python est une surcouche assez simple enrobant les fonctions C "
"fournies par *curses* ; si vous êtes déjà familier avec la programmation "
"*curses* en C, il est très facile de transférer cette connaissance à Python. "
"La plus grande différence est que l'interface Python simplifie les choses en "
"fusionnant différentes fonctions C telles que :c:func:`addstr`, :c:func:"
"`mvaddstr` et :c:func:`mvwaddstr` en une seule méthode :meth:`~curses.window."
"addstr`. Nous voyons cela plus en détail ci-après."

#: howto/curses.rst:72
msgid ""
"This HOWTO is an introduction to writing text-mode programs with curses and "
"Python. It doesn't attempt to be a complete guide to the curses API; for "
"that, see the Python library guide's section on ncurses, and the C manual "
"pages for ncurses.  It will, however, give you the basic ideas."
msgstr ""
"Ce guide pratique est une introduction à l'écriture de programmes en mode "
"texte avec *curses* et Python. Il n'essaie pas d'être un guide complet de "
"l'API *curses* ; pour cela, consultez la section du guide de la bibliothèque "
"Python sur *ncurses* et les pages du manuel C pour *ncurses*. Il vous donne "
"cependant les idées de base."

#: howto/curses.rst:79
msgid "Starting and ending a curses application"
msgstr "Lancement et arrêt une application *curses*"

#: howto/curses.rst:81
msgid ""
"Before doing anything, curses must be initialized.  This is done by calling "
"the :func:`~curses.initscr` function, which will determine the terminal "
"type, send any required setup codes to the terminal, and create various "
"internal data structures.  If successful, :func:`initscr` returns a window "
"object representing the entire screen; this is usually called ``stdscr`` "
"after the name of the corresponding C variable. ::"
msgstr ""
"Avant de faire quoi que ce soit, *curses* doit être initialisé. Appelez pour "
"cela la fonction :func:`~curses.initscr`, elle détermine le type de "
"terminal, envoie tous les codes de configuration requis au terminal et crée "
"diverses structures de données internes. En cas de succès, :func:`initscr` "
"renvoie un objet fenêtre représentant l'écran entier ; il est généralement "
"appelé ``stdscr`` d'après le nom de la variable C correspondante. ::"

#: howto/curses.rst:92
msgid ""
"Usually curses applications turn off automatic echoing of keys to the "
"screen, in order to be able to read keys and only display them under certain "
"circumstances.  This requires calling the :func:`~curses.noecho` function. ::"
msgstr ""
"Habituellement, les applications *curses* désactivent l'écho automatique des "
"touches à l'écran, afin de pouvoir lire les touches et ne les afficher que "
"dans certaines circonstances. Cela nécessite d'appeler la fonction :func:"
"`~curses.noecho`. ::"

#: howto/curses.rst:99
msgid ""
"Applications will also commonly need to react to keys instantly, without "
"requiring the Enter key to be pressed; this is called cbreak mode, as "
"opposed to the usual buffered input mode. ::"
msgstr ""
"Également, les applications réagissent généralement instantanément aux "
"touches sans qu'il soit nécessaire d'appuyer sur la touche Entrée ; c'est ce "
"qu'on appelle le mode *cbreak*, par opposition au mode d'entrée habituel "
"avec un tampon. ::"

#: howto/curses.rst:105
msgid ""
"Terminals usually return special keys, such as the cursor keys or navigation "
"keys such as Page Up and Home, as a multibyte escape sequence.  While you "
"could write your application to expect such sequences and process them "
"accordingly, curses can do it for you, returning a special value such as :"
"const:`curses.KEY_LEFT`.  To get curses to do the job, you'll have to enable "
"keypad mode. ::"
msgstr ""
"Les terminaux renvoient généralement les touches spéciales, telles que les "
"touches de curseur ou les touches de navigation (Page précédente et Accueil "
"par exemple), comme une séquence d'échappement sur plusieurs octets. Bien "
"que vous puissiez écrire votre application pour vous attendre à de telles "
"séquences et les traiter en conséquence, *curses* peut le faire pour vous, "
"renvoyant une valeur spéciale telle que :const:`curses.KEY_LEFT`. Pour que "
"*curses* fasse le travail, vous devez activer le mode *keypad*. ::"

#: howto/curses.rst:114
msgid ""
"Terminating a curses application is much easier than starting one. You'll "
"need to call::"
msgstr ""
"Arrêter une application *curses* est beaucoup plus facile que d'en démarrer "
"une. Appelez ::"

#: howto/curses.rst:121
msgid ""
"to reverse the curses-friendly terminal settings. Then call the :func:"
"`~curses.endwin` function to restore the terminal to its original operating "
"mode. ::"
msgstr ""
"pour inverser les réglages du terminal mis en place pour *curses*. Ensuite, "
"appelez la fonction :func:`~curses.enddwin` pour restaurer le terminal dans "
"son mode de fonctionnement original. ::"

#: howto/curses.rst:127
msgid ""
"A common problem when debugging a curses application is to get your terminal "
"messed up when the application dies without restoring the terminal to its "
"previous state.  In Python this commonly happens when your code is buggy and "
"raises an uncaught exception.  Keys are no longer echoed to the screen when "
"you type them, for example, which makes using the shell difficult."
msgstr ""
"Un problème courant lors du débogage d'une application *curses* est de se "
"retrouver avec un terminal sans queue ni tête lorsque l'application meurt "
"sans restaurer le terminal à son état précédent. Avec Python, cela arrive "
"souvent lorsque votre code est bogué et lève une exception non interceptée. "
"Les touches ne sont plus répétées à l'écran lorsque vous les tapez, par "
"exemple, ce qui rend l'utilisation de l'interface de commande du *shell* "
"difficile."

#: howto/curses.rst:133
msgid ""
"In Python you can avoid these complications and make debugging much easier "
"by importing the :func:`curses.wrapper` function and using it like this::"
msgstr ""
"En Python, vous pouvez éviter ces complications et faciliter le débogage en "
"important la fonction :func:`curses.wrapper` et en l'utilisant comme suit ::"

#: howto/curses.rst:152
msgid ""
"The :func:`~curses.wrapper` function takes a callable object and does the "
"initializations described above, also initializing colors if color support "
"is present.  :func:`wrapper` then runs your provided callable. Once the "
"callable returns, :func:`wrapper` will restore the original state of the "
"terminal.  The callable is called inside a :keyword:`try`...\\ :keyword:"
"`except` that catches exceptions, restores the state of the terminal, and "
"then re-raises the exception.  Therefore your terminal won't be left in a "
"funny state on exception and you'll be able to read the exception's message "
"and traceback."
msgstr ""
"La fonction :func:`~curses.wrapper` prend un objet appelable et fait les "
"initialisations décrites ci-dessus, initialisant également les couleurs si "
"la gestion des couleurs est possible. :func:`wrapper` lance l'appelable "
"fourni. Une fois que l'appelable termine, :func:`wrapper` restaure l'état "
"d'origine du terminal. L'appelable est appelé à l'intérieur d'un :keyword:"
"`try`...\\ :keyword:`except` qui capture les exceptions, restaure l'état du "
"terminal, puis relève l'exception. Par conséquent, votre terminal ne reste "
"pas dans un drôle d'état au moment de l'exception et vous pourrez lire le "
"message de l'exception et la trace de la pile d'appels."

#: howto/curses.rst:164
msgid "Windows and Pads"
msgstr "Fenêtres et tampons (*pads* en anglais)"

#: howto/curses.rst:166
msgid ""
"Windows are the basic abstraction in curses.  A window object represents a "
"rectangular area of the screen, and supports methods to display text, erase "
"it, allow the user to input strings, and so forth."
msgstr ""
"Les fenêtres sont l'abstraction de base de *curses*. Un objet fenêtre "
"représente une zone rectangulaire de l'écran qui gère des méthodes pour "
"afficher du texte, l'effacer, permettre à l'utilisateur de saisir des "
"chaînes, etc."

#: howto/curses.rst:170
msgid ""
"The ``stdscr`` object returned by the :func:`~curses.initscr` function is a "
"window object that covers the entire screen.  Many programs may need only "
"this single window, but you might wish to divide the screen into smaller "
"windows, in order to redraw or clear them separately. The :func:`~curses."
"newwin` function creates a new window of a given size, returning the new "
"window object. ::"
msgstr ""
"L'objet ``stdscr`` renvoyé par la fonction :func:`~curses.initscr` est un "
"objet fenêtre qui couvre l'écran entier. De nombreux programmes peuvent "
"n'avoir besoin que de cette fenêtre unique, mais vous pouvez diviser l'écran "
"en fenêtres plus petites, afin de les redessiner ou de les effacer "
"séparément. La fonction :func:`~curses.newwin` crée une nouvelle fenêtre "
"d'une taille donnée, renvoyant le nouvel objet fenêtre. ::"

#: howto/curses.rst:181
msgid ""
"Note that the coordinate system used in curses is unusual. Coordinates are "
"always passed in the order *y,x*, and the top-left corner of a window is "
"coordinate (0,0).  This breaks the normal convention for handling "
"coordinates where the *x* coordinate comes first.  This is an unfortunate "
"difference from most other computer applications, but it's been part of "
"curses since it was first written, and it's too late to change things now."
msgstr ""
"Notez que le système de coordonnées utilisé dans *curses* est inhabituel. "
"Les coordonnées sont toujours passées dans l'ordre *y,x* et le coin "
"supérieur gauche d'une fenêtre a pour coordonnées (0,0). Ceci rompt la "
"convention normale des coordonnées où la coordonnée *x* vient en premier. "
"C'est une différence malheureuse par rapport à la plupart des autres "
"applications informatiques, mais elle fait partie de *curses* depuis qu'il a "
"été écrit et il est trop tard pour changer les choses maintenant."

#: howto/curses.rst:189
msgid ""
"Your application can determine the size of the screen by using the :data:"
"`curses.LINES` and :data:`curses.COLS` variables to obtain the *y* and *x* "
"sizes.  Legal coordinates will then extend from ``(0,0)`` to ``(curses.LINES "
"- 1, curses.COLS - 1)``."
msgstr ""
"Votre application peut déterminer la taille de l'écran en utilisant les "
"variables :data:`curses.LINES` et :data:`curses.COLS` pour obtenir les "
"tailles *y* et *x*. Les coordonnées licites s'étendent alors de ``(0,0)`` à "
"``(curses.LINES - 1, curses.COLS - 1)``."

#: howto/curses.rst:194
msgid ""
"When you call a method to display or erase text, the effect doesn't "
"immediately show up on the display.  Instead you must call the :meth:"
"`~curses.window.refresh` method of window objects to update the screen."
msgstr ""
"Quand vous appelez une méthode pour afficher ou effacer du texte, "
"l'affichage ne le reflète pas immédiatement. Vous devez appeler la méthode :"
"meth:`~curses.window.refresh` des objets fenêtre pour mettre à jour l'écran."

#: howto/curses.rst:199
msgid ""
"This is because curses was originally written with slow 300-baud terminal "
"connections in mind; with these terminals, minimizing the time required to "
"redraw the screen was very important.  Instead curses accumulates changes to "
"the screen and displays them in the most efficient manner when you call :"
"meth:`refresh`.  For example, if your program displays some text in a window "
"and then clears the window, there's no need to send the original text "
"because they're never visible."
msgstr ""
"C'est parce que *curses* a été écrit du temps des terminaux avec une "
"connexion à 300 bauds seulement ; avec ces terminaux, il était important de "
"minimiser le temps passé à redessiner l'écran. *curses* calcule donc les "
"modifications à apporter à l'écran pour les afficher de la manière la plus "
"efficace au moment où la méthode :meth:`refresh` est appelée. Par exemple, "
"si votre programme affiche du texte dans une fenêtre puis efface cette "
"fenêtre, il n'est pas nécessaire de l'afficher puisqu'il ne sera jamais "
"visible."

#: howto/curses.rst:208
msgid ""
"In practice, explicitly telling curses to redraw a window doesn't really "
"complicate programming with curses much. Most programs go into a flurry of "
"activity, and then pause waiting for a keypress or some other action on the "
"part of the user.  All you have to do is to be sure that the screen has been "
"redrawn before pausing to wait for user input, by first calling ``stdscr."
"refresh()`` or the :meth:`refresh` method of some other relevant window."
msgstr ""
"Pratiquement, le fait de devoir indiquer explicitement à *curses* de "
"redessiner une fenêtre ne rend pas la programmation plus compliquée. La "
"plupart des programmes effectuent une rafale de traitements puis attendent "
"qu'une touche soit pressée ou toute autre action de la part de "
"l'utilisateur. Tout ce que vous avez à faire consiste à vous assurer que "
"l'écran a bien été redessiné avant d'attendre une entrée utilisateur, en "
"appelant d'abord ``stdscr.refresh()`` ou la méthode :meth:`refresh` de la "
"fenêtre adéquate."

#: howto/curses.rst:216
msgid ""
"A pad is a special case of a window; it can be larger than the actual "
"display screen, and only a portion of the pad displayed at a time. Creating "
"a pad requires the pad's height and width, while refreshing a pad requires "
"giving the coordinates of the on-screen area where a subsection of the pad "
"will be displayed.  ::"
msgstr ""
"Un tampon (*pad* en anglais) est une forme spéciale de fenêtre ; il peut "
"être plus grand que l'écran effectif et il est possible de n'afficher qu'une "
"partie du tampon à la fois. La création d'un tampon nécessite de fournir sa "
"hauteur et sa largeur, tandis que pour le rafraîchissement du tampon, vous "
"devez fournir les coordonnées de la zone de l'écran où une partie du tampon "
"sera affichée."

#: howto/curses.rst:237
msgid ""
"The :meth:`refresh` call displays a section of the pad in the rectangle "
"extending from coordinate (5,5) to coordinate (20,75) on the screen; the "
"upper left corner of the displayed section is coordinate (0,0) on the pad.  "
"Beyond that difference, pads are exactly like ordinary windows and support "
"the same methods."
msgstr ""
"L'appel à :meth:`refresh` affiche une partie du tampon dans le rectangle "
"formé par les coins de coordonnées (5,5) et (20,75) de l'écran ; le coin "
"supérieur gauche de la partie affichée a pour coordonnées (0,0) dans le "
"tampon. À part cette différence, les tampons sont exactement comme les "
"fenêtres ordinaires et gèrent les mêmes méthodes."

#: howto/curses.rst:243
msgid ""
"If you have multiple windows and pads on screen there is a more efficient "
"way to update the screen and prevent annoying screen flicker as each part of "
"the screen gets updated.  :meth:`refresh` actually does two things:"
msgstr ""
"Si vous avez plusieurs fenêtres et tampons sur l'écran, il existe un moyen "
"plus efficace pour rafraîchir l'écran et éviter des scintillements agaçants "
"à chaque mise à jour. :meth:`refresh` effectue en fait deux choses :"

#: howto/curses.rst:248
msgid ""
"Calls the :meth:`~curses.window.noutrefresh` method of each window to update "
"an underlying data structure representing the desired state of the screen."
msgstr ""
"elle appelle la méthode :meth:`~curses.window.noutrefresh` de chaque fenêtre "
"pour mettre à jour les données sous-jacentes qui permettent d'obtenir "
"l'affichage voulu ;"

#: howto/curses.rst:251
msgid ""
"Calls the function :func:`~curses.doupdate` function to change the physical "
"screen to match the desired state recorded in the data structure."
msgstr ""
"elle appelle la fonction :func:`~curses.doupdate` pour modifier l'écran "
"physique afin de correspondre à l'état défini par les données sous-jacentes."

#: howto/curses.rst:254
msgid ""
"Instead you can call :meth:`noutrefresh` on a number of windows to update "
"the data structure, and then call :func:`doupdate` to update the screen."
msgstr ""
"Vous pouvez ainsi appeler :meth:`noutrefresh` sur les fenêtres dont vous "
"voulez mettre à jour des données, puis :func:`doupdate` pour mettre à jour "
"l'écran."

#: howto/curses.rst:260
msgid "Displaying Text"
msgstr "Affichage de texte"

#: howto/curses.rst:262
msgid ""
"From a C programmer's point of view, curses may sometimes look like a twisty "
"maze of functions, all subtly different.  For example, :c:func:`addstr` "
"displays a string at the current cursor location in the ``stdscr`` window, "
"while :c:func:`mvaddstr` moves to a given y,x coordinate first before "
"displaying the string. :c:func:`waddstr` is just like :c:func:`addstr`, but "
"allows specifying a window to use instead of using ``stdscr`` by default. :c:"
"func:`mvwaddstr` allows specifying both a window and a coordinate."
msgstr ""
"D'un point de vue de programmeur C, *curses* peut parfois ressembler à un "
"enchevêtrement de fonctions, chacune ayant sa subtilité. Par exemple, :c:"
"func:`addstr` affiche une chaîne à la position actuelle du curseur de la "
"fenêtre ``stdscr``, alors que :c:func:`mvaddstr` se déplace d'abord "
"jusqu'aux coordonnées (y,x) avant d'afficher la chaîne. :c:func:`waddstr` "
"est comme :c:func:`addstr`, mais permet de spécifier la fenêtre au lieu "
"d'utiliser ``stdscr`` par défaut. :c:func:`mvwaddstr` permet de spécifier à "
"la fois les coordonnées et la fenêtre."

#: howto/curses.rst:271
msgid ""
"Fortunately the Python interface hides all these details.  ``stdscr`` is a "
"window object like any other, and methods such as :meth:`~curses.window."
"addstr` accept multiple argument forms.  Usually there are four different "
"forms."
msgstr ""
"Heureusement, l'interface Python masque tous ces détails. ``stdscr`` est un "
"objet fenêtre comme les autres et les méthodes telles que :meth:`~curses."
"window.addstr` acceptent leurs arguments sous de multiples formes, "
"habituellement quatre."

#: howto/curses.rst:277
msgid "Form"
msgstr "Forme"

#: howto/curses.rst:346
msgid "Description"
msgstr "Description"

#: howto/curses.rst:279
msgid "*str* or *ch*"
msgstr "*str* ou *ch*"

#: howto/curses.rst:279
msgid "Display the string *str* or character *ch* at the current position"
msgstr "Affiche la chaîne *str* ou le caractère *ch* à la position actuelle"

#: howto/curses.rst:282
msgid "*str* or *ch*, *attr*"
msgstr "*str* ou *ch*, *attr*"

#: howto/curses.rst:282
msgid ""
"Display the string *str* or character *ch*, using attribute *attr* at the "
"current position"
msgstr ""
"Affiche la chaîne *str* ou le caractère *ch*, en utilisant l'attribut *attr* "
"à la position actuelle"

#: howto/curses.rst:286
msgid "*y*, *x*, *str* or *ch*"
msgstr "*y*, *x*, *str* ou *ch*"

#: howto/curses.rst:286
msgid "Move to position *y,x* within the window, and display *str* or *ch*"
msgstr ""
"Se déplace à la position *y,x* dans la fenêtre et affiche la chaîne *str* ou "
"le caractère *ch*"

#: howto/curses.rst:289
msgid "*y*, *x*, *str* or *ch*, *attr*"
msgstr "*y*, *x*, *str* ou *ch*, *attr*"

#: howto/curses.rst:289
msgid ""
"Move to position *y,x* within the window, and display *str* or *ch*, using "
"attribute *attr*"
msgstr ""
"Se déplace à la position *y,x* dans la fenêtre et affiche la chaîne *str* ou "
"le caractère *ch* en utilisant l'attribut *attr*"

#: howto/curses.rst:293
msgid ""
"Attributes allow displaying text in highlighted forms such as boldface, "
"underline, reverse code, or in color.  They'll be explained in more detail "
"in the next subsection."
msgstr ""
"Les attributs permettent de mettre en valeur du texte : gras, souligné, mode "
"vidéo inversé ou en couleur. Nous les voyons plus en détail dans la section "
"suivante."

#: howto/curses.rst:298
msgid ""
"The :meth:`~curses.window.addstr` method takes a Python string or bytestring "
"as the value to be displayed.  The contents of bytestrings are sent to the "
"terminal as-is.  Strings are encoded to bytes using the value of the "
"window's :attr:`encoding` attribute; this defaults to the default system "
"encoding as returned by :func:`locale.getpreferredencoding`."
msgstr ""
"La méthode :meth:`~curses.window.addstr` prend en argument une chaîne ou une "
"suite d'octets Python. Le contenu des chaînes d'octets est envoyé vers le "
"terminal tel quel. Les chaînes sont encodées en octets en utilisant la "
"valeur de l'attribut :attr:`encoding` de la fenêtre ; c'est par défaut "
"l'encodage du système tel que renvoyé par :func:`locale."
"getpreferredencoding`."

#: howto/curses.rst:305
msgid ""
"The :meth:`~curses.window.addch` methods take a character, which can be "
"either a string of length 1, a bytestring of length 1, or an integer."
msgstr ""
"Les méthodes :meth:`~curses.window.addch` prennent un caractère, soit sous "
"la forme d'une chaîne de longueur 1, d'une chaîne d'octets de longueur 1 ou "
"d'un entier."

#: howto/curses.rst:308
msgid ""
"Constants are provided for extension characters; these constants are "
"integers greater than 255.  For example, :const:`ACS_PLMINUS` is a +/- "
"symbol, and :const:`ACS_ULCORNER` is the upper left corner of a box (handy "
"for drawing borders).  You can also use the appropriate Unicode character."
msgstr ""
"Des constantes sont disponibles pour étendre les caractères ; ces constantes "
"sont des entiers supérieurs à 255. Par exemple, :const:`ACS_PLMINUS` "
"correspond au symbole +/- et :const:`ACS_ULCORNER` correspond au coin en "
"haut et à gauche d'une boîte (utile pour dessiner des encadrements). Vous "
"pouvez aussi utiliser les caractères Unicode adéquats."

#: howto/curses.rst:314
msgid ""
"Windows remember where the cursor was left after the last operation, so if "
"you leave out the *y,x* coordinates, the string or character will be "
"displayed wherever the last operation left off.  You can also move the "
"cursor with the ``move(y,x)`` method.  Because some terminals always display "
"a flashing cursor, you may want to ensure that the cursor is positioned in "
"some location where it won't be distracting; it can be confusing to have the "
"cursor blinking at some apparently random location."
msgstr ""
"Windows se souvient de l'endroit où le curseur était positionné lors de la "
"dernière opération, de manière à ce que si vous n'utilisez pas les "
"coordonnées *y,x*, l'affichage se produit au dernier endroit utilisé. Vous "
"pouvez aussi déplacer le curseur avec la méthode ``move(y,x)``. Comme "
"certains terminaux affichent un curseur clignotant, vous pouvez ainsi vous "
"assurer que celui-ci est positionné à un endroit où il ne distrait pas "
"l'utilisateur (il peut être déroutant d'avoir un curseur qui clignote à des "
"endroits apparemment aléatoires)."

#: howto/curses.rst:322
msgid ""
"If your application doesn't need a blinking cursor at all, you can call "
"``curs_set(False)`` to make it invisible.  For compatibility with older "
"curses versions, there's a ``leaveok(bool)`` function that's a synonym for :"
"func:`~curses.curs_set`.  When *bool* is true, the curses library will "
"attempt to suppress the flashing cursor, and you won't need to worry about "
"leaving it in odd locations."
msgstr ""
"Si votre application n'a pas besoin d'un curseur clignotant, vous pouvez "
"appeler ``curs_set(False)`` pour le rendre invisible. Par souci de "
"compatibilité avec les anciennes versions de *curses*, il existe la fonction "
"``leaveok(bool)`` qui est un synonyme de :func:`~curses.curs_set`. Quand "
"*bool* vaut ``True``, la bibliothèque *curses* essaie de supprimer le "
"curseur clignotant et vous n'avez plus besoin de vous soucier de le laisser "
"trainer à des endroits bizarres."

#: howto/curses.rst:331
msgid "Attributes and Color"
msgstr "Attributs et couleurs"

#: howto/curses.rst:333
msgid ""
"Characters can be displayed in different ways.  Status lines in a text-based "
"application are commonly shown in reverse video, or a text viewer may need "
"to highlight certain words.  curses supports this by allowing you to specify "
"an attribute for each cell on the screen."
msgstr ""
"Les caractères peuvent être affichés de différentes façons. Les lignes de "
"statut des applications en mode texte sont généralement affichées en mode "
"vidéo inversé ; vous pouvez avoir besoin de mettre en valeur certains mots. "
"À ces fins, *curses* vous permet de spécifier un attribut pour chaque "
"caractère à l'écran."

#: howto/curses.rst:338
msgid ""
"An attribute is an integer, each bit representing a different attribute.  "
"You can try to display text with multiple attribute bits set, but curses "
"doesn't guarantee that all the possible combinations are available, or that "
"they're all visually distinct.  That depends on the ability of the terminal "
"being used, so it's safest to stick to the most commonly available "
"attributes, listed here."
msgstr ""
"Un attribut est un entier dont chaque bit représente un attribut différent. "
"Vous pouvez essayer d'afficher du texte avec plusieurs attributs définis "
"simultanément mais *curses* ne garantit pas que toutes les combinaisons "
"soient prises en compte ou que le résultat soit visuellement différent. Cela "
"dépend de la capacité de chaque terminal utilisé, il est donc plus sage de "
"se cantonner aux attributs les plus communément utilisés, dont la liste est "
"fournie ci-dessous."

#: howto/curses.rst:346
msgid "Attribute"
msgstr "Attribut"

#: howto/curses.rst:348
msgid ":const:`A_BLINK`"
msgstr ":const:`A_BLINK`"

#: howto/curses.rst:348
msgid "Blinking text"
msgstr "Texte clignotant"

#: howto/curses.rst:350
msgid ":const:`A_BOLD`"
msgstr ":const:`A_BOLD`"

#: howto/curses.rst:350
msgid "Extra bright or bold text"
msgstr "Texte en surbrillance ou en gras"

#: howto/curses.rst:352
msgid ":const:`A_DIM`"
msgstr ":const:`A_DIM`"

#: howto/curses.rst:352
msgid "Half bright text"
msgstr "Texte en demi-ton"

#: howto/curses.rst:354
msgid ":const:`A_REVERSE`"
msgstr ":const:`A_REVERSE`"

#: howto/curses.rst:354
msgid "Reverse-video text"
msgstr "Texte en mode vidéo inversé"

#: howto/curses.rst:356
msgid ":const:`A_STANDOUT`"
msgstr ":const:`A_STANDOUT`"

#: howto/curses.rst:356
msgid "The best highlighting mode available"
msgstr "Le meilleur mode de mis en valeur pour le texte"

#: howto/curses.rst:358
msgid ":const:`A_UNDERLINE`"
msgstr ":const:`A_UNDERLINE`"

#: howto/curses.rst:358
msgid "Underlined text"
msgstr "Texte souligné"

#: howto/curses.rst:361
msgid ""
"So, to display a reverse-video status line on the top line of the screen, "
"you could code::"
msgstr ""
"Ainsi, pour mettre la ligne de statut située en haut de l'écran en mode "
"vidéo inversé, vous pouvez coder ::"

#: howto/curses.rst:368
msgid ""
"The curses library also supports color on those terminals that provide it. "
"The most common such terminal is probably the Linux console, followed by "
"color xterms."
msgstr ""
"La bibliothèque *curses* gère également les couleurs pour les terminaux "
"compatibles. Le plus répandu de ces terminaux est sûrement la console Linux, "
"suivie par *xterm* en couleurs."

#: howto/curses.rst:372
msgid ""
"To use color, you must call the :func:`~curses.start_color` function soon "
"after calling :func:`~curses.initscr`, to initialize the default color set "
"(the :func:`curses.wrapper` function does this automatically).  Once that's "
"done, the :func:`~curses.has_colors` function returns TRUE if the terminal "
"in use can actually display color.  (Note: curses uses the American spelling "
"'color', instead of the Canadian/British spelling 'colour'.  If you're used "
"to the British spelling, you'll have to resign yourself to misspelling it "
"for the sake of these functions.)"
msgstr ""
"Pour utiliser les couleurs, vous devez d'abord appeler la fonction :func:"
"`~curses.start_color` juste après avoir appelé :func:`~curses.initscr` afin "
"d'initialiser (la fonction :func:`curses.wrapper` le fait automatiquement). "
"Ensuite, la fonction :func:`~curses.has_colors` renvoie ``True`` si le "
"terminal utilisé gère les couleurs (note : *curses* utilise l'orthographe "
"américaine *color* et non pas l'orthographe britannique ou canadienne "
"*colour* ; si vous êtes habitué à l'orthographe britannique, vous devrez "
"vous résigner à mal l'orthographier tant que vous utilisez *curses*)."

#: howto/curses.rst:382
msgid ""
"The curses library maintains a finite number of color pairs, containing a "
"foreground (or text) color and a background color.  You can get the "
"attribute value corresponding to a color pair with the :func:`~curses."
"color_pair` function; this can be bitwise-OR'ed with other attributes such "
"as :const:`A_REVERSE`, but again, such combinations are not guaranteed to "
"work on all terminals."
msgstr ""
"La bibliothèque *curses* maintient un nombre restreint de paires de "
"couleurs, constituées d'une couleur de texte (*foreground*) et de fond "
"(*background*). Vous pouvez obtenir la valeur des attributs correspondant à "
"une paire de couleur avec la fonction :func:`~curses.color_pair` ; cette "
"valeur peut être combinée bit par bit (avec la fonction *OR*) avec les "
"autres attributs tels que :const:`A_REVERSE`,mais là encore, de telles "
"combinaisons risquent de ne pas fonctionner sur tous les terminaux."

#: howto/curses.rst:389
msgid "An example, which displays a line of text using color pair 1::"
msgstr ""
"Un exemple d'affichage d'une ligne de texte en utilisant la paire de couleur "
"1 ::"

#: howto/curses.rst:394
msgid ""
"As I said before, a color pair consists of a foreground and background "
"color. The ``init_pair(n, f, b)`` function changes the definition of color "
"pair *n*, to foreground color f and background color b.  Color pair 0 is "
"hard-wired to white on black, and cannot be changed."
msgstr ""
"Comme indiqué auparavant, une paire de couleurs est constituée d'une couleur "
"de texte et d'une couleur de fond. La fonction ``init_pair(n, f, b)`` change "
"la définition de la paire de couleurs *n*, en définissant la couleur de "
"texte à *f* et la couleur de fond à *b*. La paire de couleurs 0 est codée en "
"dur à blanc sur noir et ne peut être modifiée."

#: howto/curses.rst:399
msgid ""
"Colors are numbered, and :func:`start_color` initializes 8 basic colors when "
"it activates color mode.  They are: 0:black, 1:red, 2:green, 3:yellow, 4:"
"blue, 5:magenta, 6:cyan, and 7:white.  The :mod:`curses` module defines "
"named constants for each of these colors: :const:`curses.COLOR_BLACK`, :"
"const:`curses.COLOR_RED`, and so forth."
msgstr ""
"Les couleurs sont numérotées et :func:`start_color` initialise 8 couleurs "
"basiques lors de l'activation du mode en couleurs. Ce sont : 0 pour noir "
"(*black*), 1 pour rouge (*red*), 2 pour vert (*green*), 3 pour jaune "
"(*yellow*), 4 pour bleu *(blue*), 5 pour magenta, 6 pour cyan et 7 pour "
"blanc (*white*). Le module :mod:`curses` définit des constantes nommées pour "
"chacune de ces couleurs : :const:`curses.COLOR_BLACK`, :const:`curses."
"COLOR_RED` et ainsi de suite."

#: howto/curses.rst:405
msgid ""
"Let's put all this together. To change color 1 to red text on a white "
"background, you would call::"
msgstr ""
"Testons tout ça. Pour changer la couleur 1 à rouge sur fond blanc, appelez ::"

#: howto/curses.rst:410
msgid ""
"When you change a color pair, any text already displayed using that color "
"pair will change to the new colors.  You can also display new text in this "
"color with::"
msgstr ""
"Quand vous modifiez une paire de couleurs, tout le texte déjà affiché qui "
"utilise cette paire de couleur voit les nouvelles couleurs s'appliquer à "
"lui. Vous pouvez aussi afficher du nouveau texte dans cette couleur avec ::"

#: howto/curses.rst:416
msgid ""
"Very fancy terminals can change the definitions of the actual colors to a "
"given RGB value.  This lets you change color 1, which is usually red, to "
"purple or blue or any other color you like.  Unfortunately, the Linux "
"console doesn't support this, so I'm unable to try it out, and can't provide "
"any examples.  You can check if your terminal can do this by calling :func:"
"`~curses.can_change_color`, which returns ``True`` if the capability is "
"there.  If you're lucky enough to have such a talented terminal, consult "
"your system's man pages for more information."
msgstr ""
"Les terminaux « de luxe » peuvent définir les couleurs avec des valeurs "
"*RGB*. Cela vous permet de modifier la couleur 1, habituellement rouge, en "
"violet ou bleu voire toute autre couleur selon votre goût. Malheureusement, "
"la console Linux ne gère pas cette fonctionnalité, je suis donc bien "
"incapable de la tester et de vous en fournir un exemple. Vous pouvez "
"vérifier si votre terminal la prend en charge en appelant :func:`~curses."
"can_change_color`, qui renvoie ``True`` en cas de succès. Si vous avez la "
"chance d'avoir un terminal aussi perfectionné, consultez les pages du manuel "
"de votre système pour obtenir plus d'informations."

#: howto/curses.rst:427
msgid "User Input"
msgstr "Entrées de l'utilisateur"

#: howto/curses.rst:429
msgid ""
"The C curses library offers only very simple input mechanisms. Python's :mod:"
"`curses` module adds a basic text-input widget.  (Other libraries such as "
"`Urwid <https://pypi.org/project/urwid/>`_ have more extensive collections "
"of widgets.)"
msgstr ""
"La bibliothèque C *curses* ne propose que quelques mécanismes très simples "
"pour les entrées. Le module :mod:`curses` y ajoute un *widget* basique "
"d'entrée de texte (d'autres bibliothèques telles que `Urwid <https://pypi."
"org/project/urwid/>`_ ont un ensemble de *widgets* plus conséquent)."

#: howto/curses.rst:434
msgid "There are two methods for getting input from a window:"
msgstr "Il y a deux méthodes pour obtenir des entrées dans une fenêtre :"

#: howto/curses.rst:436
msgid ""
":meth:`~curses.window.getch` refreshes the screen and then waits for the "
"user to hit a key, displaying the key if :func:`~curses.echo` has been "
"called earlier.  You can optionally specify a coordinate to which the cursor "
"should be moved before pausing."
msgstr ""
":meth:`~curses.window.getch` rafraîchit l'écran et attend que l'utilisateur "
"appuie sur une touche, affichant cette touche si :func:`~curses.echo` a été "
"appelé auparavant. Vous pouvez en option spécifier des coordonnées où "
"positionner le curseur avant la mise en pause ;"

#: howto/curses.rst:441
msgid ""
":meth:`~curses.window.getkey` does the same thing but converts the integer "
"to a string.  Individual characters are returned as 1-character strings, and "
"special keys such as function keys return longer strings containing a key "
"name such as ``KEY_UP`` or ``^G``."
msgstr ""
":meth:`~curses.window.getkey` effectue la même chose mais convertit l'entier "
"en chaîne. Les caractères individuels sont renvoyés en chaînes de longueur 1 "
"alors que les touches spéciales (telles que les touches de fonction) "
"renvoient des chaînes plus longues contenant le nom de la touche (tel que "
"``KEY_UP`` ou ``^G``)."

#: howto/curses.rst:446
msgid ""
"It's possible to not wait for the user using the :meth:`~curses.window."
"nodelay` window method. After ``nodelay(True)``, :meth:`getch` and :meth:"
"`getkey` for the window become non-blocking. To signal that no input is "
"ready, :meth:`getch` returns ``curses.ERR`` (a value of -1) and :meth:"
"`getkey` raises an exception. There's also a :func:`~curses.halfdelay` "
"function, which can be used to (in effect) set a timer on each :meth:"
"`getch`; if no input becomes available within a specified delay (measured in "
"tenths of a second), curses raises an exception."
msgstr ""
"Il est possible de ne pas attendre l'utilisateur en utilisant la méthode de "
"fenêtre :meth:`~curses.window.nodelay`. Après ``nodelay(True)``, les "
"méthodes de fenêtre :meth:`getch` et :meth:`getkey` deviennent non "
"bloquantes. Pour indiquer qu'aucune entrée n'a eu lieu, :meth:`getch` "
"renvoie ``curses.ERR`` (ayant pour valeur −1) et :meth:`getkey` lève une "
"exception. Il existe aussi la fonction :func:`~curses.halfdelay`, qui peut "
"être utilisée pour définir un délai maximal pour chaque :meth:`getch` ; si "
"aucune entrée n'est disponible dans le délai spécifié (mesuré en dixièmes de "
"seconde), *curses* lève une exception."

#: howto/curses.rst:456
msgid ""
"The :meth:`getch` method returns an integer; if it's between 0 and 255, it "
"represents the ASCII code of the key pressed.  Values greater than 255 are "
"special keys such as Page Up, Home, or the cursor keys. You can compare the "
"value returned to constants such as :const:`curses.KEY_PPAGE`, :const:"
"`curses.KEY_HOME`, or :const:`curses.KEY_LEFT`.  The main loop of your "
"program may look something like this::"
msgstr ""
"La méthode :meth:`getch` renvoie un entier ; s'il est entre 0 et 255, c'est "
"le code ASCII de la touche pressée. Les valeurs supérieures à 255 sont des "
"touches spéciales telles que Page Précédente, Accueil ou les touches du "
"curseur. Vous pouvez comparer la valeur renvoyée aux constantes :const:"
"`curses.KEY_PPAGE`, :const:`curses.KEY_HOME`, :const:`curses.KEY_LEFT`, etc. "
"La boucle principale de votre programme pourrait ressembler à quelque chose "
"comme ::"

#: howto/curses.rst:472
msgid ""
"The :mod:`curses.ascii` module supplies ASCII class membership functions "
"that take either integer or 1-character string arguments; these may be "
"useful in writing more readable tests for such loops.  It also supplies "
"conversion functions  that take either integer or 1-character-string "
"arguments and return the same type.  For example, :func:`curses.ascii.ctrl` "
"returns the control character corresponding to its argument."
msgstr ""
"Le module :mod:`curses.ascii` fournit des fonctions pour déterminer si "
"l'entier ou la chaîne de longueur 1 passés en arguments font partie de la "
"classe ASCII ; elles peuvent s'avérer utile pour écrire du code plus lisible "
"dans ce genre de boucles. Il fournit également des fonctions de conversion "
"qui prennent un entier ou une chaîne de longueur 1 en entrée et renvoient le "
"type correspondant au nom de la fonction. Par exemple, :func:`curses.ascii."
"ctrl` renvoie le caractère de contrôle correspondant à son paramètre."

#: howto/curses.rst:479
msgid ""
"There's also a method to retrieve an entire string, :meth:`~curses.window."
"getstr`.  It isn't used very often, because its functionality is quite "
"limited; the only editing keys available are the backspace key and the Enter "
"key, which terminates the string.  It can optionally be limited to a fixed "
"number of characters. ::"
msgstr ""
"Il existe aussi une méthode pour récupérer une chaîne entière, :meth:"
"`~curses.window.getstr`. Elle n'est pas beaucoup utilisée car son utilité "
"est limitée : les seules touches d'édition disponibles sont le retour "
"arrière et la touche Entrée, qui termine la chaîne. Elle peut, en option, "
"être limitée à un nombre fixé de caractères. ::"

#: howto/curses.rst:490
msgid ""
"The :mod:`curses.textpad` module supplies a text box that supports an Emacs-"
"like set of keybindings.  Various methods of the :class:`~curses.textpad."
"Textbox` class support editing with input validation and gathering the edit "
"results either with or without trailing spaces.  Here's an example::"
msgstr ""
"Le module :mod:`curses.textpad` fournit un type de boîte texte qui gère des "
"touches de fonctions à la façon d'\\ *Emacs*. Plusieurs méthodes de la "
"classe :class:`~curses.textpad.Textbox` gèrent l'édition avec la validation "
"des entrées et le regroupement de l'entrée avec ou sans les espaces de début "
"et de fin. Par exemple ::"

#: howto/curses.rst:514
msgid ""
"See the library documentation on :mod:`curses.textpad` for more details."
msgstr ""
"Consultez la documentation de la bibliothèque pour plus de détails sur :mod:"
"`curses.textpad`."

#: howto/curses.rst:518
msgid "For More Information"
msgstr "Pour aller plus loin"

#: howto/curses.rst:520
msgid ""
"This HOWTO doesn't cover some advanced topics, such as reading the contents "
"of the screen or capturing mouse events from an xterm instance, but the "
"Python library page for the :mod:`curses` module is now reasonably "
"complete.  You should browse it next."
msgstr ""
"Ce guide pratique ne couvre pas certains sujets avancés, tels que la lecture "
"du contenu de l'écran ou la capture des événements relatifs à la souris dans "
"une instance *xterm*, mais la page de la bibliothèque Python du module :mod:"
"`curses` est maintenant suffisamment complète. Nous vous encourageons à la "
"parcourir."

#: howto/curses.rst:525
msgid ""
"If you're in doubt about the detailed behavior of the curses functions, "
"consult the manual pages for your curses implementation, whether it's "
"ncurses or a proprietary Unix vendor's.  The manual pages will document any "
"quirks, and provide complete lists of all the functions, attributes, and :"
"const:`ACS_\\*` characters available to you."
msgstr ""
"Si vous vous posez des questions sur le fonctionnement précis de fonctions "
"*curses*, consultez les pages de manuel de l'implémentation *curses* de "
"votre système, que ce soit *ncurses* ou une version propriétaire Unix. Les "
"pages de manuel documentent toutes les bizarreries et vous donneront les "
"listes complètes des fonctions, attributs et codes :const:`ACS_\\*` des "
"caractères disponibles."

#: howto/curses.rst:532
msgid ""
"Because the curses API is so large, some functions aren't supported in the "
"Python interface.  Often this isn't because they're difficult to implement, "
"but because no one has needed them yet.  Also, Python doesn't yet support "
"the menu library associated with ncurses. Patches adding support for these "
"would be welcome; see `the Python Developer's Guide <https://devguide.python."
"org/>`_ to learn more about submitting patches to Python."
msgstr ""
"Étant donné que l'API *curses* est si volumineuse, certaines fonctions ne "
"sont pas prises en charge dans l'interface Python. Souvent, ce n'est pas "
"parce qu'elles sont difficiles à implémenter, mais parce que personne n'en a "
"eu encore besoin. De plus, Python ne prend pas encore en charge la "
"bibliothèque de gestion des menus associée à *ncurses*. Les correctifs "
"ajoutant cette prise en charge seraient bienvenus ; reportez-vous au `guide "
"du développeur Python <https://devguide.python.org/>`_ pour apprendre "
"comment soumettre des améliorations à Python."

#: howto/curses.rst:540
#, fuzzy
msgid ""
"`Writing Programs with NCURSES <https://invisible-island.net/ncurses/ncurses-"
"intro.html>`_: a lengthy tutorial for C programmers."
msgstr ""
"`Writing Programs with NCURSES <http://invisible-island.net/ncurses/ncurses-"
"intro.html>`_ : un long tutoriel pour les programmeurs C (ressource en "
"anglais)."

#: howto/curses.rst:542
msgid "`The ncurses man page <https://linux.die.net/man/3/ncurses>`_"
msgstr "`La page de manuel ncurses <https://linux.die.net/man/3/ncurses>`_"

#: howto/curses.rst:543
#, fuzzy
msgid ""
"`The ncurses FAQ <https://invisible-island.net/ncurses/ncurses.faq.html>`_"
msgstr ""
"`La FAQ ncurses <http://invisible-island.net/ncurses/ncurses.faq.html>`_ "
"(ressource en anglais)"

#: howto/curses.rst:544
msgid ""
"`\"Use curses... don't swear\" <https://www.youtube.com/watch?"
"v=eN1eZtjLEnU>`_: video of a PyCon 2013 talk on controlling terminals using "
"curses or Urwid."
msgstr ""
"`\"Use curses... don't swear\" <https://www.youtube.com/watch?"
"v=eN1eZtjLEnU>`_ : vidéo d'une conférence lors de la PyCon 2013 sur la "
"gestion des terminaux à l'aide de *curses* et *Urwid* (vidéo en anglais)."

#: howto/curses.rst:546
#, fuzzy
msgid ""
"`\"Console Applications with Urwid\" <https://pyvideo.org/video/1568/console-"
"applications-with-urwid>`_: video of a PyCon CA 2012 talk demonstrating some "
"applications written using Urwid."
msgstr ""
"`\"Console Applications with Urwid\" <http://www.pyvideo.org/video/1568/"
"console-applications-with-urwid>`_ : vidéo d'une conférence lors de PyCon CA "
"2012 montrant quelques applications utilisant *Urwid*."

#~ msgid ""
#~ "The Windows version of Python doesn't include the :mod:`curses` module.  "
#~ "A ported version called `UniCurses <https://pypi.org/project/UniCurses>`_ "
#~ "is available.  You could also try `the Console module <http://effbot.org/"
#~ "zone/console-index.htm>`_ written by Fredrik Lundh, which doesn't use the "
#~ "same API as curses but provides cursor-addressable text output and full "
#~ "support for mouse and keyboard input."
#~ msgstr ""
#~ "La version Windows de Python n'inclut pas le module :mod:`curses`. Une "
#~ "version portée appelée `UniCurses <https://pypi.org/project/UniCurses>`_ "
#~ "est disponible. Vous pouvez également essayer le `Windows console driver "
#~ "<http://effbot.org/zone/console-index.htm>`_ écrit par Fredrik Lundh, qui "
#~ "n'utilise pas la même API que *curses*, mais fournit une sortie texte "
#~ "avec gestion du curseur et une prise en charge complète de la souris et "
#~ "du clavier."
