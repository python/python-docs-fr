# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-04 10:00+0100\n"
"PO-Revision-Date: 2020-03-28 16:08+0100\n"
"Last-Translator: Loc Cosnier <loc.cosnier@pm.me>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.0.6\n"

#: ../Doc/howto/pyporting.rst:5
msgid "Porting Python 2 Code to Python 3"
msgstr "Portage de code Python 2 vers Python 3"

#: ../Doc/howto/pyporting.rst:0
msgid "author"
msgstr "auteur"

#: ../Doc/howto/pyporting.rst:7
msgid "Brett Cannon"
msgstr "Brett Cannon"

#: ../Doc/howto/pyporting.rst:None
msgid "Abstract"
msgstr "Résumé"

#: ../Doc/howto/pyporting.rst:11
msgid ""
"With Python 3 being the future of Python while Python 2 is still in active "
"use, it is good to have your project available for both major releases of "
"Python. This guide is meant to help you figure out how best to support both "
"Python 2 & 3 simultaneously."
msgstr ""
"Python 3 étant le futur de Python tandis que Python 2 est encore activement "
"utilisé, il est préférable de faire en sorte que votre projet soit "
"disponible pour les deux versions majeures de Python. Ce guide est destiné à "
"vous aider à comprendre comment gérer simultanément Python 2 & 3."

#: ../Doc/howto/pyporting.rst:16
msgid ""
"If you are looking to port an extension module instead of pure Python code, "
"please see :ref:`cporting-howto`."
msgstr ""
"Si vous cherchez à porter un module d'extension plutôt que du pur Python, "
"veuillez consulter :ref:`cporting-howto`."

#: ../Doc/howto/pyporting.rst:19
msgid ""
"If you would like to read one core Python developer's take on why Python 3 "
"came into existence, you can read Nick Coghlan's `Python 3 Q & A`_ or Brett "
"Cannon's `Why Python 3 exists`_."
msgstr ""
"Si vous souhaitez lire l'avis d'un développeur principal de Python sur ce "
"qui a motivé la création de Python 3, vous pouvez lire le `Python 3 Q & A`_ "
"de Nick Coghlan ou bien `Why Python 3 exists`_ de Brett Cannon."

#: ../Doc/howto/pyporting.rst:23
msgid ""
"For help with porting, you can email the python-porting_ mailing list with "
"questions."
msgstr ""
"Vous pouvez solliciter par courriel l'aide de la liste de diffusion python-"
"porting_  pour vos questions liées au portage."

#: ../Doc/howto/pyporting.rst:27
msgid "The Short Explanation"
msgstr "La version courte"

#: ../Doc/howto/pyporting.rst:29
msgid ""
"To make your project be single-source Python 2/3 compatible, the basic steps "
"are:"
msgstr ""
"Afin de rendre votre projet compatible Python 2/3 avec le même code source, "
"les étapes de base sont :"

#: ../Doc/howto/pyporting.rst:32
msgid "Only worry about supporting Python 2.7"
msgstr "Ne se préoccuper que du support de Python 2.7"

#: ../Doc/howto/pyporting.rst:33
msgid ""
"Make sure you have good test coverage (coverage.py_ can help; ``pip install "
"coverage``)"
msgstr ""
"S'assurer d'une bonne couverture des tests (coverage.py_ peut aider ; ``pip "
"install coverage``)"

#: ../Doc/howto/pyporting.rst:35 ../Doc/howto/pyporting.rst:116
msgid "Learn the differences between Python 2 & 3"
msgstr "Apprendre les différences entre Python 2 et 3"

#: ../Doc/howto/pyporting.rst:36
msgid ""
"Use Futurize_ (or Modernize_) to update your code (e.g. ``pip install "
"future``)"
msgstr ""
"Utiliser Futurize_ (ou Modernize_) pour mettre à jour votre code (par "
"exemple ``pip install future``)"

#: ../Doc/howto/pyporting.rst:37
msgid ""
"Use Pylint_ to help make sure you don't regress on your Python 3 support "
"(``pip install pylint``)"
msgstr ""
"Utilisez Pylint_ pour vous assurer que vous ne régressez pas sur votre prise "
"en charge de Python 3 (``pip install pylint``)"

#: ../Doc/howto/pyporting.rst:39
msgid ""
"Use caniusepython3_ to find out which of your dependencies are blocking your "
"use of Python 3 (``pip install caniusepython3``)"
msgstr ""
"Utiliser `caniusepython3`_ pour déterminer quelles sont, parmi les "
"dépendances que vous utilisez, celles qui bloquent votre utilisation de "
"Python 3 (``pip install caniusepython3``)"

#: ../Doc/howto/pyporting.rst:41
msgid ""
"Once your dependencies are no longer blocking you, use continuous "
"integration to make sure you stay compatible with Python 2 & 3 (tox_ can "
"help test against multiple versions of Python; ``pip install tox``)"
msgstr ""
"Une fois que vos dépendances ne sont plus un obstacle, utiliser "
"l'intégration continue pour s'assurer que votre code demeure compatible "
"Python 2 & 3 (tox_ peut aider à tester la comptabilité de sources avec "
"plusieurs versions de Python; ``pip install tox``)"

#: ../Doc/howto/pyporting.rst:44
msgid ""
"Consider using optional static type checking to make sure your type usage "
"works in both Python 2 & 3 (e.g. use mypy_ to check your typing under both "
"Python 2 & Python 3)."
msgstr ""
"Envisager l'utilisation d'un vérifieur de type statique afin de vous assurer "
"que votre façon d'utiliser les types est compatible avec Python 2 et 3 (par "
"exemple en utilisant mypy_ pour vérifier votre typage sous Python 2 et 3)."

#: ../Doc/howto/pyporting.rst:50
msgid "Details"
msgstr "Détails"

#: ../Doc/howto/pyporting.rst:52
msgid ""
"A key point about supporting Python 2 & 3 simultaneously is that you can "
"start **today**! Even if your dependencies are not supporting Python 3 yet "
"that does not mean you can't modernize your code **now** to support Python "
"3. Most changes required to support Python 3 lead to cleaner code using "
"newer practices even in Python 2 code."
msgstr ""
"Un point clé du support simultané de Python 2 et 3 est qu'il vous est "
"possible de commencer **dès aujourd'hui** ! Même si vos dépendances ne sont "
"pas encore compatibles Python 3, vous pouvez moderniser votre code **dès "
"maintenant** pour gérer Python 3. La plupart des modifications nécessaires à "
"la compatibilité Python 3 donnent un code plus propre utilisant une syntaxe "
"plus récente, même dans du code Python 2."

#: ../Doc/howto/pyporting.rst:58
msgid ""
"Another key point is that modernizing your Python 2 code to also support "
"Python 3 is largely automated for you. While you might have to make some API "
"decisions thanks to Python 3 clarifying text data versus binary data, the "
"lower-level work is now mostly done for you and thus can at least benefit "
"from the automated changes immediately."
msgstr ""
"Un autre point important est que la modernisation de votre code Python 2 "
"pour le rendre compatible Python 3 est pratiquement automatique. Bien qu'il "
"soit possible d'avoir à effectuer des changements d'API compte-tenu de la "
"clarification de la gestion des données textuelles et binaires dans Python "
"3, le travail de bas niveau est en grande partie fait pour vous et vous "
"pouvez ainsi bénéficiez de ces modifications automatiques immédiatement."

#: ../Doc/howto/pyporting.rst:64
msgid ""
"Keep those key points in mind while you read on about the details of porting "
"your code to support Python 2 & 3 simultaneously."
msgstr ""
"Gardez ces points-clés en tête pendant que vous lisez les détails ci-dessous "
"concernant le portage de votre code vers une compatibilité simultanée Python "
"2 et 3."

#: ../Doc/howto/pyporting.rst:69
msgid "Drop support for Python 2.6 and older"
msgstr "Abandon de la compatibilité Python 2.6 et antérieures"

#: ../Doc/howto/pyporting.rst:71
msgid ""
"While you can make Python 2.5 work with Python 3, it is **much** easier if "
"you only have to work with Python 2.7. If dropping Python 2.5 is not an "
"option then the six_ project can help you support Python 2.5 & 3 "
"simultaneously (``pip install six``). Do realize, though, that nearly all "
"the projects listed in this HOWTO will not be available to you."
msgstr ""
"Bien qu'il soit possible de rendre Python 2.5 compatible avec Python 3, il "
"est **beaucoup** plus simple de n'avoir qu'à travailler avec Python 2.7. Si "
"abandonner Python 2.5 n'est pas une option, alors le projet six_ peut vous "
"aider à gérer simultanément Python 2.5 et 3 (``pip install six``). "
"Néanmoins, soyez conscient que la quasi-totalité des projets listés dans ce "
"guide pratique ne seront pas applicables à votre situation."

#: ../Doc/howto/pyporting.rst:77
msgid ""
"If you are able to skip Python 2.5 and older, then the required changes to "
"your code should continue to look and feel like idiomatic Python code. At "
"worst you will have to use a function instead of a method in some instances "
"or have to import a function instead of using a built-in one, but otherwise "
"the overall transformation should not feel foreign to you."
msgstr ""
"Si vous pouvez ignorer Python 2.5 et antérieur, les changements nécessaires "
"à appliquer à votre code devraient encore ressembler à vos yeux à du code "
"Python idiomatique. Dans le pire cas, vous devrez utiliser une fonction "
"plutôt qu'une méthode dans certains cas, ou bien vous devrez importer une "
"fonction plutôt qu'utiliser une fonction native, mais le reste du temps le "
"code transformé devrait vous rester familier."

#: ../Doc/howto/pyporting.rst:83
msgid ""
"But you should aim for only supporting Python 2.7. Python 2.6 is no longer "
"freely supported and thus is not receiving bugfixes. This means **you** will "
"have to work around any issues you come across with Python 2.6. There are "
"also some tools mentioned in this HOWTO which do not support Python 2.6 (e."
"g., Pylint_), and this will become more commonplace as time goes on. It will "
"simply be easier for you if you only support the versions of Python that you "
"have to support."
msgstr ""
"Mais nous vous conseillons de viser seulement un support de Python 2.7. "
"Python 2.6 n'est plus supporté gratuitement et par conséquent ne reçoit plus "
"aucun correctif. Cela signifie que **vous** devrez trouver des solutions de "
"contournement aux problèmes que vous rencontrez avec Python 2.6. Il existe "
"en outre des outils mentionnés dans ce guide pratique qui ne supportent pas "
"Python 2.6 (par exemple Pylint_), ce qui sera de plus en plus courant au fil "
"du temps. Il est simplement plus facile pour vous de n'assurer une "
"compatibilité qu'avec les versions de Python que vous avez l'obligation de "
"gérer."

#: ../Doc/howto/pyporting.rst:92
msgid ""
"Make sure you specify the proper version support in your ``setup.py`` file"
msgstr ""
"Assurez vous de spécifier la bonne version supportée dans le fichier ``setup."
"py``"

#: ../Doc/howto/pyporting.rst:94
msgid ""
"In your ``setup.py`` file you should have the proper `trove classifier`_ "
"specifying what versions of Python you support. As your project does not "
"support Python 3 yet you should at least have ``Programming Language :: "
"Python :: 2 :: Only`` specified. Ideally you should also specify each major/"
"minor version of Python that you do support, e.g. ``Programming Language :: "
"Python :: 2.7``."
msgstr ""
"Votre fichier ``setup.py`` devrait contenir le bon `trove classifier`_ "
"spécifiant les versions de Python avec lesquelles vous êtes compatible. "
"Comme votre projet ne supporte pas encore Python 3, vous devriez au moins "
"spécifier ``Programming Language :: Python :: 2 :: Only``. Dans l'idéal vous "
"devriez indiquer chaque version majeure/mineure de Python que vous gérez, "
"par exemple ``Programming Language :: Python :: 2.7``."

#: ../Doc/howto/pyporting.rst:103
msgid "Have good test coverage"
msgstr "Obtenir une bonne couverture de code"

#: ../Doc/howto/pyporting.rst:105
msgid ""
"Once you have your code supporting the oldest version of Python 2 you want "
"it to, you will want to make sure your test suite has good coverage. A good "
"rule of thumb is that if you want to be confident enough in your test suite "
"that any failures that appear after having tools rewrite your code are "
"actual bugs in the tools and not in your code. If you want a number to aim "
"for, try to get over 80% coverage (and don't feel bad if you find it hard to "
"get better than 90% coverage). If you don't already have a tool to measure "
"test coverage then coverage.py_ is recommended."
msgstr ""
"Une fois que votre code est compatible avec la plus ancienne version de "
"Python 2 que vous souhaitez, vous devez vous assurer que votre suite de test "
"a une couverture suffisante. Une bonne règle empirique consiste à avoir "
"suffisamment confiance en la suite de test pour qu'une erreur apparaissant "
"après la réécriture du code par les outils automatiques résulte de bogues de "
"ces derniers et non de votre code. Si vous souhaitez une valeur cible, "
"essayez de dépasser les 80 % de couverture (et ne vous sentez pas coupable "
"si vous trouvez difficile de faire mieux que 90 % de couverture). Si vous ne "
"disposez pas encore d'un outil pour mesurer la couverture de code, coverage."
"py_ est recommandé."

#: ../Doc/howto/pyporting.rst:118
msgid ""
"Once you have your code well-tested you are ready to begin porting your code "
"to Python 3! But to fully understand how your code is going to change and "
"what you want to look out for while you code, you will want to learn what "
"changes Python 3 makes in terms of Python 2. Typically the two best ways of "
"doing that is reading the :ref:`\"What's New\" <whatsnew-index>` doc for "
"each release of Python 3 and the `Porting to Python 3`_ book (which is free "
"online). There is also a handy `cheat sheet`_ from the Python-Future project."
msgstr ""
"Une fois que votre code est bien testé, vous êtes prêt à démarrer votre "
"portage vers Python 3 ! Mais afin de comprendre comment votre code va "
"changer et à quoi s'intéresser spécifiquement pendant que vous codez, vous "
"aurez sûrement envie de découvrir quels sont les changements introduits par "
"Python 3 par rapport à Python 2. Pour atteindre cet objectif, les deux "
"meilleurs moyens sont de lire le document :ref:`whatsnew-index` de chaque "
"version de Python 3 et le livre `Porting to Python 3`_ (gratuit en ligne, en "
"anglais). Il y a également une « anti-sèche » (`cheat sheet`_, ressource en "
"anglais) très pratique du projet Python-Future."

#: ../Doc/howto/pyporting.rst:128
msgid "Update your code"
msgstr "Mettre à jour votre code"

#: ../Doc/howto/pyporting.rst:130
msgid ""
"Once you feel like you know what is different in Python 3 compared to Python "
"2, it's time to update your code! You have a choice between two tools in "
"porting your code automatically: Futurize_ and Modernize_. Which tool you "
"choose will depend on how much like Python 3 you want your code to be. "
"Futurize_ does its best to make Python 3 idioms and practices exist in "
"Python 2, e.g. backporting the ``bytes`` type from Python 3 so that you have "
"semantic parity between the major versions of Python. Modernize_, on the "
"other hand, is more conservative and targets a Python 2/3 subset of Python, "
"directly relying on six_ to help provide compatibility. As Python 3 is the "
"future, it might be best to consider Futurize to begin adjusting to any new "
"practices that Python 3 introduces which you are not accustomed to yet."
msgstr ""
"Une fois que vous pensez en savoir suffisamment sur les différences entre "
"Python 3 et Python 2, il est temps de mettre à jour votre code ! Vous avez "
"le choix entre deux outils pour porter votre code automatiquement : "
"Futurize_ et Modernize_. Le choix de l'outil dépend de la dose de Python 3 "
"que vous souhaitez introduire dans votre code. Futurize_ s'efforce "
"d'introduire les idiomes et pratiques de Python 3 dans Python 2, par exemple "
"en réintroduisant le type ``bytes`` de Python 3 de telle sorte que la "
"sémantique soit identique entre les deux versions majeures de Python. En "
"revanche, Modernize_ est plus conservateur et vise un sous-ensemble "
"d'instructions Python 2/3, en s'appuyant directement sur six_ pour la "
"compatibilité. Python 3 étant le futur de Python, il pourrait être "
"préférable d'utiliser *Futurize* afin de commencer à s'ajuster aux nouvelles "
"pratiques introduites par Python 3 avec lesquelles vous n'êtes pas encore "
"habitué."

#: ../Doc/howto/pyporting.rst:142
msgid ""
"Regardless of which tool you choose, they will update your code to run under "
"Python 3 while staying compatible with the version of Python 2 you started "
"with. Depending on how conservative you want to be, you may want to run the "
"tool over your test suite first and visually inspect the diff to make sure "
"the transformation is accurate. After you have transformed your test suite "
"and verified that all the tests still pass as expected, then you can "
"transform your application code knowing that any tests which fail is a "
"translation failure."
msgstr ""
"Indépendamment de l'outil sur lequel se porte votre choix, celui-ci mettra à "
"jour votre code afin qu'il puisse être exécuté par Python 3 tout en "
"maintenant sa compatibilité avec la version de Python 2 dont vous êtes "
"parti. En fonction du niveau de prudence que vous visez, vous pouvez "
"exécuter l'outil sur votre suite de test d'abord puis inspecter visuellement "
"la différence afin de vous assurer que la transformation est exacte. Après "
"avoir transformé votre suite de test et vérifié que tous les tests "
"s'exécutent comme attendu, vous pouvez transformer le code de votre "
"application avec l'assurance que chaque test qui échoue correspond à un "
"échec de traduction."

#: ../Doc/howto/pyporting.rst:150
msgid ""
"Unfortunately the tools can't automate everything to make your code work "
"under Python 3 and so there are a handful of things you will need to update "
"manually to get full Python 3 support (which of these steps are necessary "
"vary between the tools). Read the documentation for the tool you choose to "
"use to see what it fixes by default and what it can do optionally to know "
"what will (not) be fixed for you and what you may have to fix on your own (e."
"g. using ``io.open()`` over the built-in ``open()`` function is off by "
"default in Modernize). Luckily, though, there are only a couple of things to "
"watch out for which can be considered large issues that may be hard to debug "
"if not watched for."
msgstr ""
"Malheureusement les outils ne peuvent pas automatiser tous les changements "
"requis pour permettre à votre code de s'exécuter sous Python 3 et il y a "
"donc quelques points sur lesquels vous devrez travailler manuellement afin "
"d'atteindre la compatibilité totale Python 3 (les étapes nécessaires peuvent "
"varier en fonction de l'outil utilisé). Lisez la documentation de l'outil "
"que vous avez choisi afin d'identifier ce qu'il corrige par défaut et ce qui "
"peut être appliqué de façon optionnelle afin de savoir ce qui sera (ou non) "
"corrigé pour vous ou ce que vous devrez modifier vous-même (par exemple, le "
"remplacement ``io.open()`` plutôt que la fonction native ``open()`` est "
"inactif par défaut dans *Modernize*). Heureusement, il n'y a que quelques "
"points à surveiller qui peuvent réellement être considérés comme des "
"problèmes difficiles à déboguer si vous n'y prêtez pas attention."

#: ../Doc/howto/pyporting.rst:162
msgid "Division"
msgstr "Division"

#: ../Doc/howto/pyporting.rst:164
msgid ""
"In Python 3, ``5 / 2 == 2.5`` and not ``2``; all division between ``int`` "
"values result in a ``float``. This change has actually been planned since "
"Python 2.2 which was released in 2002. Since then users have been encouraged "
"to add ``from __future__ import division`` to any and all files which use "
"the ``/`` and ``//`` operators or to be running the interpreter with the ``-"
"Q`` flag. If you have not been doing this then you will need to go through "
"your code and do two things:"
msgstr ""
"Dans Python 3, ``5 / 2 == 2.5`` et non ``2``; toutes les divisions entre des "
"valeurs ``int`` renvoient un ``float``. Ce changement était en réalité "
"planifié depuis Python 2.2, publié en 2002. Depuis cette date, les "
"utilisateurs ont été encouragés à ajouter ``from __future__ import "
"division`` à tous les fichiers utilisant les opérateurs ``/`` et ``//`` ou à "
"exécuter l'interpréteur avec l'option ``-Q``. Si vous n'avez pas suivi cette "
"recommandation, vous devrez manuellement modifier votre code et effectuer "
"deux changements :"

#: ../Doc/howto/pyporting.rst:172
msgid "Add ``from __future__ import division`` to your files"
msgstr "Ajouter ``from __future__ import division`` à vos fichiers"

#: ../Doc/howto/pyporting.rst:173
msgid ""
"Update any division operator as necessary to either use ``//`` to use floor "
"division or continue using ``/`` and expect a float"
msgstr ""
"Remplacer tous les opérateurs de division par ``//`` pour la division "
"entière, le cas échant, ou utiliser ``/`` et vous attendre à un résultat "
"flottant"

#: ../Doc/howto/pyporting.rst:176
msgid ""
"The reason that ``/`` isn't simply translated to ``//`` automatically is "
"that if an object defines a ``__truediv__`` method but not ``__floordiv__`` "
"then your code would begin to fail (e.g. a user-defined class that uses ``/"
"`` to signify some operation but not ``//`` for the same thing or at all)."
msgstr ""
"La raison pour laquelle  ``/`` n'est pas simplement remplacé par ``//`` "
"automatiquement est que si un objet définit une méthode ``__truediv__`` mais "
"pas de méthode ``__floordiv__``, alors votre code pourrait produire une "
"erreur (par exemple, une classe définie par l'utilisateur qui utilise ``/`` "
"pour définir une opération quelconque mais pour laquelle ``//`` n'a pas du "
"tout la même signification, voire n'est pas utilisé du tout)."

#: ../Doc/howto/pyporting.rst:183
msgid "Text versus binary data"
msgstr "Texte et données binaires"

#: ../Doc/howto/pyporting.rst:185
msgid ""
"In Python 2 you could use the ``str`` type for both text and binary data. "
"Unfortunately this confluence of two different concepts could lead to "
"brittle code which sometimes worked for either kind of data, sometimes not. "
"It also could lead to confusing APIs if people didn't explicitly state that "
"something that accepted ``str`` accepted either text or binary data instead "
"of one specific type. This complicated the situation especially for anyone "
"supporting multiple languages as APIs wouldn't bother explicitly supporting "
"``unicode`` when they claimed text data support."
msgstr ""
"Dans Python 2, il était possible d'utiliser le type ``str`` pour du texte et "
"pour des données binaires. Malheureusement cet amalgame entre deux concepts "
"différents peut conduire à du code fragile pouvant parfois fonctionner pour "
"les deux types de données et parfois non. Cela a également conduit à des API "
"confuses si les auteurs ne déclaraient pas explicitement que quelque chose "
"qui acceptait ``str`` était compatible avec du texte ou des données binaires "
"et pas un seul des deux types. Cela a compliqué la situation pour les "
"personnes devant gérer plusieurs langages avec des API qui ne se "
"préoccupaient pas de la gestion de ``unicode`` lorsqu'elles affirmaient être "
"compatibles avec des données au format texte."

#: ../Doc/howto/pyporting.rst:194
msgid ""
"To make the distinction between text and binary data clearer and more "
"pronounced, Python 3 did what most languages created in the age of the "
"internet have done and made text and binary data distinct types that cannot "
"blindly be mixed together (Python predates widespread access to the "
"internet). For any code that deals only with text or only binary data, this "
"separation doesn't pose an issue. But for code that has to deal with both, "
"it does mean you might have to now care about when you are using text "
"compared to binary data, which is why this cannot be entirely automated."
msgstr ""
"Afin de rendre la distinction entre texte et données binaires claire et "
"prononcée, Python 3 a suivi la voie pavée par la plupart des langages créés "
"à l'ère d'Internet et a séparé les types texte et données binaires de telle "
"sorte qu'il ne soit plus possible de les confondre (Python est antérieur à "
"la démocratisation de l'accès à Internet). Cette séparation ne pose pas de "
"problème pour du code ne gérant soit que du texte, soit que des données "
"binaires. Cependant un code source devant gérer les deux doit désormais se "
"préoccuper du type des données manipulées, ce qui explique que ce processus "
"ne peut pas être entièrement automatisé."

#: ../Doc/howto/pyporting.rst:203
msgid ""
"To start, you will need to decide which APIs take text and which take binary "
"(it is **highly** recommended you don't design APIs that can take both due "
"to the difficulty of keeping the code working; as stated earlier it is "
"difficult to do well). In Python 2 this means making sure the APIs that take "
"text can work with ``unicode`` and those that work with binary data work "
"with the ``bytes`` type from Python 3 (which is a subset of ``str`` in "
"Python 2 and acts as an alias for ``bytes`` type in Python 2). Usually the "
"biggest issue is realizing which methods exist on which types in Python 2 & "
"3 simultaneously (for text that's ``unicode`` in Python 2 and ``str`` in "
"Python 3, for binary that's ``str``/``bytes`` in Python 2 and ``bytes`` in "
"Python 3). The following table lists the **unique** methods of each data "
"type across Python 2 & 3 (e.g., the ``decode()`` method is usable on the "
"equivalent binary data type in either Python 2 or 3, but it can't be used by "
"the textual data type consistently between Python 2 and 3 because ``str`` in "
"Python 3 doesn't have the method). Do note that as of Python 3.5 the "
"``__mod__`` method was added to the bytes type."
msgstr ""
"Pour commencer, vous devrez choisir quelles API travaillent sur du texte et "
"lesquelles travaillent avec des données binaires (il est **fortement** "
"recommandé de ne pas concevoir d'API qui gèrent les deux types compte-tenu "
"de la difficulté supplémentaire que cela induit). Dans Python 2, cela "
"signifie s'assurer que les API recevant du texte en entrée peuvent gérer "
"``unicode`` et celles qui reçoivent des données binaires fonctionnent avec "
"le type ``bytes`` de Python 3 (qui est un sous-ensemble de ``str`` dans "
"Python 2 et opère comme un alias du type ``bytes`` de Python 2). En général, "
"le principal problème consiste à inventorier quelles méthodes existent et "
"opèrent sur quel type dans Python & 3 simultanément (pour le texte, il "
"s'agit de ``unicode`` dans Python 2 et ``str`` dans Python 3, pour le "
"binaire il s'agit de ``str``/``bytes`` dans Python 2 et ``bytes`` dans "
"Python 3). Le tableau ci-dessous liste les méthodes **spécifiques** à chaque "
"type de données dans Python 2 et 3 (par exemple, la méthode ``decode()`` "
"peut être utilisée sur des données binaires équivalentes en Python 2 et 3, "
"mais ne peut pas être utilisée de la même façon sur le type texte en Python "
"2 et 3 car le type ``str``  de Python 3 ne possède pas de telle méthode). "
"Notez que depuis Python 3.5, la méthode ``__mod__`` a été ajoutée au type "
"*bytes*."

#: ../Doc/howto/pyporting.rst:220
msgid "**Text data**"
msgstr "**Format texte**"

#: ../Doc/howto/pyporting.rst:220
msgid "**Binary data**"
msgstr "**Format binaire**"

#: ../Doc/howto/pyporting.rst:222
msgid "\\"
msgstr "\\"

#: ../Doc/howto/pyporting.rst:222
msgid "decode"
msgstr "decode"

#: ../Doc/howto/pyporting.rst:224
msgid "encode"
msgstr "encode"

#: ../Doc/howto/pyporting.rst:226
msgid "format"
msgstr "format"

#: ../Doc/howto/pyporting.rst:228
msgid "isdecimal"
msgstr "isdecimal"

#: ../Doc/howto/pyporting.rst:230
msgid "isnumeric"
msgstr "isnumeric"

#: ../Doc/howto/pyporting.rst:233
msgid ""
"Making the distinction easier to handle can be accomplished by encoding and "
"decoding between binary data and text at the edge of your code. This means "
"that when you receive text in binary data, you should immediately decode it. "
"And if your code needs to send text as binary data then encode it as late as "
"possible. This allows your code to work with only text internally and thus "
"eliminates having to keep track of what type of data you are working with."
msgstr ""
"Vous pouvez rendre le problème plus simple à gérer en réalisant les "
"opérations d'encodage et de décodage entre données binaires et texte aux "
"extrémités de votre code. Cela signifie que lorsque vous recevez du texte "
"dans un format binaire, vous devez immédiatement le décoder. À l'inverse si "
"votre code doit transmettre du texte sous forme binaire, encodez-le le plus "
"tard possible. Cela vous permet de ne manipuler que du texte à l'intérieur "
"de votre code et permet de ne pas se préoccuper du type des données sur "
"lesquelles vous travaillez."

#: ../Doc/howto/pyporting.rst:240
msgid ""
"The next issue is making sure you know whether the string literals in your "
"code represent text or binary data. You should add a ``b`` prefix to any "
"literal that presents binary data. For text you should add a ``u`` prefix to "
"the text literal. (there is a :mod:`__future__` import to force all "
"unspecified literals to be Unicode, but usage has shown it isn't as "
"effective as adding a ``b`` or ``u`` prefix to all literals explicitly)"
msgstr ""
"Le point suivant est de s'assurer que vous savez quelles chaînes de "
"caractères littérales de votre code correspondent à du texte ou à du "
"binaire. Vous devez préfixer par ``b`` tous les littéraux qui représentent "
"des données binaires et par ``u`` les littéraux qui représentent du texte "
"(il existe une importation du module :mod:`__future__` permettant de forcer "
"l'encodage de toutes les chaînes de caractères littérales non spécifiées en "
"Unicode, mais cette pratique s'est avérée moins efficace que l'ajout "
"explicite des préfixe ``b`` et ``u``)."

#: ../Doc/howto/pyporting.rst:247
msgid ""
"As part of this dichotomy you also need to be careful about opening files. "
"Unless you have been working on Windows, there is a chance you have not "
"always bothered to add the ``b`` mode when opening a binary file (e.g., "
"``rb`` for binary reading).  Under Python 3, binary files and text files are "
"clearly distinct and mutually incompatible; see the :mod:`io` module for "
"details. Therefore, you **must** make a decision of whether a file will be "
"used for binary access (allowing binary data to be read and/or written) or "
"textual access (allowing text data to be read and/or written). You should "
"also use :func:`io.open` for opening files instead of the built-in :func:"
"`open` function as the :mod:`io` module is consistent from Python 2 to 3 "
"while the built-in :func:`open` function is not (in Python 3 it's actually :"
"func:`io.open`). Do not bother with the outdated practice of using :func:"
"`codecs.open` as that's only necessary for keeping compatibility with Python "
"2.5."
msgstr ""
"Une conséquence de cette dichotomie est que vous devez être prudents lors de "
"l'ouverture d'un fichier. À moins que vous travailliez sous Windows, il y a "
"des chances pour que vous ne vous soyez jamais préoccupé de spécifier le "
"mode ``b`` lorsque vous ouvrez des fichiers binaires (par exemple ``rb`` "
"pour lire un fichier binaire). Sous Python 3, les fichiers binaire et texte "
"sont distincts et mutuellement incompatibles ; se référer au module :mod:"
"`io` pour plus de détails. Ainsi vous **devez** décider lorsque vous ouvrez "
"un fichier si vous y accéderez en mode binaire (ce qui permet de lire et "
"écrire des données binaires) ou en mode texte (ce qui permet de lire et "
"écrire du texte). Vous devez également utiliser :func:`io.open` pour ouvrir "
"des fichiers plutôt que la fonction native :func:`open` étant donné que le "
"module :mod:`io` est cohérent de Python 2 à 3, ce qui n'est pas vrai pour la "
"fonction :func:`open` (en Python 3, il s'agit en réalité de :func:`io."
"open`). Ne cherchez pas à appliquer l'ancienne pratique consistant à "
"utiliser :func:`codecs.open` qui n'est nécessaire que pour préserver une "
"compatibilité avec Python 2.5."

#: ../Doc/howto/pyporting.rst:261
msgid ""
"The constructors of both ``str`` and ``bytes`` have different semantics for "
"the same arguments between Python 2 & 3. Passing an integer to ``bytes`` in "
"Python 2 will give you the string representation of the integer: ``bytes(3) "
"== '3'``. But in Python 3, an integer argument to ``bytes`` will give you a "
"bytes object as long as the integer specified, filled with null bytes: "
"``bytes(3) == b'\\x00\\x00\\x00'``. A similar worry is necessary when "
"passing a bytes object to ``str``. In Python 2 you just get the bytes object "
"back: ``str(b'3') == b'3'``. But in Python 3 you get the string "
"representation of the bytes object: ``str(b'3') == \"b'3'\"``."
msgstr ""
"Les constructeurs des types ``str`` et ``bytes`` possèdent une sémantique "
"différente pour les mêmes arguments sous Python 2 et 3. Passer un entier à "
"``bytes`` sous Python 2 produit une représentation de cet entier en chaîne "
"de caractères : ``bytes(3) == '3'``. Mais sous Python 3, fournir un argument "
"entier à ``bytes`` produit un objet *bytes* de la longueur de l'entier "
"spécifié, rempli par des octets nuls : ``bytes(3) == b'\\x00\\x00\\x00'``. "
"La même prudence est nécessaire lorsque vous passez un objet *bytes* à "
"``str``. En Python 2, vous récupérez simplement l'objet *bytes* initial : "
"``str(b'3') == b'3'``. Mais en Python 3, vous récupérez la représentation en "
"chaîne de caractères de l'objet *bytes* : ``str(b'3') == \"b'3'\"``."

#: ../Doc/howto/pyporting.rst:271
msgid ""
"Finally, the indexing of binary data requires careful handling (slicing does "
"**not** require any special handling). In Python 2, ``b'123'[1] == b'2'`` "
"while in Python 3 ``b'123'[1] == 50``. Because binary data is simply a "
"collection of binary numbers, Python 3 returns the integer value for the "
"byte you index on. But in Python 2 because ``bytes == str``, indexing "
"returns a one-item slice of bytes. The six_ project has a function named "
"``six.indexbytes()`` which will return an integer like in Python 3: ``six."
"indexbytes(b'123', 1)``."
msgstr ""
"Enfin, l'indiçage des données binaires exige une manipulation prudente (bien "
"que le découpage, ou *slicing* en anglais, ne nécessite pas d'attention "
"particulière). En Python 2, ``b'123'[1] == b'2'`` tandis qu'en Python 3 "
"``b'123'[1] == 50``. Puisque les données binaires ne sont simplement qu'une "
"collection de nombres en binaire, Python 3 renvoie la valeur entière de "
"l'octet indicé. Mais en Python 2, étant donné que ``bytes == str``, "
"l'indiçage renvoie une tranche de longueur 1 de *bytes*. Le projet six_ "
"dispose d'une fonction appelée ``six.indexbytes()`` qui renvoie un entier "
"comme en Python 3 : ``six.indexbytes(b'123', 1)``."

#: ../Doc/howto/pyporting.rst:280
msgid "To summarize:"
msgstr "Pour résumer :"

#: ../Doc/howto/pyporting.rst:282
msgid "Decide which of your APIs take text and which take binary data"
msgstr ""
"Décidez lesquelles de vos API travaillent sur du texte et lesquelles "
"travaillent sur des données binaires"

#: ../Doc/howto/pyporting.rst:283
msgid ""
"Make sure that your code that works with text also works with ``unicode`` "
"and code for binary data works with ``bytes`` in Python 2 (see the table "
"above for what methods you cannot use for each type)"
msgstr ""
"Assurez vous que votre code travaillant sur du texte fonctionne aussi avec "
"le type ``unicode`` et que le code travaillant sur du binaire fonctionne "
"avec le type ``bytes`` en Python 2 (voir le tableau ci-dessus pour la liste "
"des méthodes utilisables par chaque type)"

#: ../Doc/howto/pyporting.rst:286
msgid ""
"Mark all binary literals with a ``b`` prefix, textual literals with a ``u`` "
"prefix"
msgstr ""
"Préfixez tous vos littéraux binaires par ``b`` et toutes vos chaînes de "
"caractères littérales par ``u``"

#: ../Doc/howto/pyporting.rst:288
msgid ""
"Decode binary data to text as soon as possible, encode text as binary data "
"as late as possible"
msgstr ""
"Décodez les données binaires en texte dès que possible, encodez votre texte "
"au format binaire le plus tard possible"

#: ../Doc/howto/pyporting.rst:290
msgid ""
"Open files using :func:`io.open` and make sure to specify the ``b`` mode "
"when appropriate"
msgstr ""
"Ouvrez les fichiers avec la fonction :func:`io.open` et assurez-vous de "
"spécifier le mode ``b`` le cas échéant"

#: ../Doc/howto/pyporting.rst:292
msgid "Be careful when indexing into binary data"
msgstr "Utilisez avec prudence l'indiçage sur des données binaires"

#: ../Doc/howto/pyporting.rst:296
msgid "Use feature detection instead of version detection"
msgstr ""
"Utilisez la détection de fonctionnalités plutôt que la détection de version"

#: ../Doc/howto/pyporting.rst:298
msgid ""
"Inevitably you will have code that has to choose what to do based on what "
"version of Python is running. The best way to do this is with feature "
"detection of whether the version of Python you're running under supports "
"what you need. If for some reason that doesn't work then you should make the "
"version check be against Python 2 and not Python 3. To help explain this, "
"let's look at an example."
msgstr ""
"Vous rencontrerez inévitablement du code devant décider quoi faire en "
"fonction de la version de Python qui s'exécute. La meilleure façon de gérer "
"ce cas est de détecter si les fonctionnalités dont vous avez besoin sont "
"gérées par la version de Python sous laquelle le code s'exécute. Si pour "
"certaines raisons cela ne fonctionne pas, alors vous devez tester si votre "
"version est Python 2 et non Python 3. Afin de clarifier cette pratique, "
"voici un exemple."

#: ../Doc/howto/pyporting.rst:305
msgid ""
"Let's pretend that you need access to a feature of :mod:`importlib` that is "
"available in Python's standard library since Python 3.3 and available for "
"Python 2 through importlib2_ on PyPI. You might be tempted to write code to "
"access e.g. the :mod:`importlib.abc` module by doing the following::"
msgstr ""
"Supposons que vous avez besoin d'accéder à une fonctionnalité de :mod:"
"`importlib` qui est disponible dans la bibliothèque standard de Python "
"depuis la version 3.3, dans celle de Python 2 via le module importlib2_ sur "
"*PyPI*. Vous pourriez être tenté d'écrire un code qui accède, par exemple, "
"au module :mod:`importlib.abc` avec l'approche suivante ::"

#: ../Doc/howto/pyporting.rst:317
msgid ""
"The problem with this code is what happens when Python 4 comes out? It would "
"be better to treat Python 2 as the exceptional case instead of Python 3 and "
"assume that future Python versions will be more compatible with Python 3 "
"than Python 2::"
msgstr ""
"Le problème est le suivant : que se passe-t-il lorsque Python 4 est publié ? "
"Il serait préférable de traiter le cas Python 2 comme l'exception plutôt que "
"Python 3 et de supposer que les versions futures de Python 2 seront plus "
"compatibles avec Python 3 qu'avec Python 2 ::"

#: ../Doc/howto/pyporting.rst:329
msgid ""
"The best solution, though, is to do no version detection at all and instead "
"rely on feature detection. That avoids any potential issues of getting the "
"version detection wrong and helps keep you future-compatible::"
msgstr ""
"Néanmoins la meilleure solution est de ne pas chercher à déterminer la "
"version de Python mais plutôt à détecter les fonctionnalités disponibles. "
"Cela évite les problèmes potentiels liés aux erreurs de détection de version "
"et facilite la compatibilité future ::"

#: ../Doc/howto/pyporting.rst:340
msgid "Prevent compatibility regressions"
msgstr "Prévenir les régressions de compatibilité"

#: ../Doc/howto/pyporting.rst:342
msgid ""
"Once you have fully translated your code to be compatible with Python 3, you "
"will want to make sure your code doesn't regress and stop working under "
"Python 3. This is especially true if you have a dependency which is blocking "
"you from actually running under Python 3 at the moment."
msgstr ""
"Une fois votre code traduit pour être compatible avec Python 3, vous devez "
"vous assurer que votre code n'a pas régressé ou qu'il ne fonctionne pas sous "
"Python 3. Ceci est particulièrement important si une de vos dépendances vous "
"empêche de réellement exécuter le code sous Python 3 pour le moment."

#: ../Doc/howto/pyporting.rst:347
msgid ""
"To help with staying compatible, any new modules you create should have at "
"least the following block of code at the top of it::"
msgstr ""
"Afin de vous aider à maintenir la compatibilité, nous préconisons que tous "
"les nouveaux modules que vous créez aient au moins le bloc de code suivant "
"en en-tête ::"

#: ../Doc/howto/pyporting.rst:354
msgid ""
"You can also run Python 2 with the ``-3`` flag to be warned about various "
"compatibility issues your code triggers during execution. If you turn "
"warnings into errors with ``-Werror`` then you can make sure that you don't "
"accidentally miss a warning."
msgstr ""
"Vous pouvez également lancer Python 2 avec le paramètre ``-3`` afin d'être "
"alerté en cas de divers problèmes de compatibilité que votre code déclenche "
"durant son exécution. Si vous transformez les avertissements en erreur avec "
"``-Werror``, vous pouvez être certain que ne passez pas accidentellement à "
"côté d'un avertissement."

#: ../Doc/howto/pyporting.rst:359
msgid ""
"You can also use the Pylint_ project and its ``--py3k`` flag to lint your "
"code to receive warnings when your code begins to deviate from Python 3 "
"compatibility. This also prevents you from having to run Modernize_ or "
"Futurize_ over your code regularly to catch compatibility regressions. This "
"does require you only support Python 2.7 and Python 3.4 or newer as that is "
"Pylint's minimum Python version support."
msgstr ""
"Vous pouvez également utiliser le projet Pylint_ et son option ``--py3k`` "
"afin de modifier votre code pour recevoir des avertissements lorsque celui-"
"ci dévie de la compatibilité Python 3. Cela vous évite par ailleurs "
"d'appliquer Modernize_ ou Futurize_ sur votre code régulièrement pour "
"détecter des régressions liées à la compatibilité. Cependant cela nécessite "
"de votre part le support de Python 2.7 et Python 3.4 ou ultérieur étant "
"donné qu'il s'agit de la version minimale gérée par Pylint."

#: ../Doc/howto/pyporting.rst:368
msgid "Check which dependencies block your transition"
msgstr "Vérifier quelles dépendances empêchent la migration"

#: ../Doc/howto/pyporting.rst:370
msgid ""
"**After** you have made your code compatible with Python 3 you should begin "
"to care about whether your dependencies have also been ported. The "
"caniusepython3_ project was created to help you determine which projects -- "
"directly or indirectly -- are blocking you from supporting Python 3. There "
"is both a command-line tool as well as a web interface at https://"
"caniusepython3.com."
msgstr ""
"**Après** avoir rendu votre code compatible avec Python 3, vous devez "
"commencer à vous intéresser au portage de vos dépendances. Le projet "
"`caniusepython3`_ a été créé afin de vous aider à déterminer quels projets "
"sont bloquants dans votre support de Python 3, directement ou indirectement. "
"Il existe un outil en ligne de commande ainsi qu'une interface web : https://"
"caniusepython3.com."

#: ../Doc/howto/pyporting.rst:377
msgid ""
"The project also provides code which you can integrate into your test suite "
"so that you will have a failing test when you no longer have dependencies "
"blocking you from using Python 3. This allows you to avoid having to "
"manually check your dependencies and to be notified quickly when you can "
"start running on Python 3."
msgstr ""
"Le projet fournit également du code intégrable dans votre suite de test qui "
"déclenchera un échec de test lorsque plus aucune de vos dépendances n'est "
"bloquante pour l'utilisation de Python 3. Cela vous permet de ne pas avoir à "
"vérifier manuellement vos dépendances et d'être notifié rapidement quand "
"vous pouvez exécuter votre application avec Python 3."

#: ../Doc/howto/pyporting.rst:384
msgid "Update your ``setup.py`` file to denote Python 3 compatibility"
msgstr ""
"Mettre à jour votre fichier ``setup.py`` pour spécifier la compatibilité "
"avec Python 3"

#: ../Doc/howto/pyporting.rst:386
msgid ""
"Once your code works under Python 3, you should update the classifiers in "
"your ``setup.py`` to contain ``Programming Language :: Python :: 3`` and to "
"not specify sole Python 2 support. This will tell anyone using your code "
"that you support Python 2 **and** 3. Ideally you will also want to add "
"classifiers for each major/minor version of Python you now support."
msgstr ""
"Une fois que votre code fonctionne sous Python 3, vous devez mettre à jour "
"vos classeurs dans votre ``setup.py`` pour inclure ``Programming Language :: "
"Python :: 3`` et non seulement le support de Python 2. Cela signifiera à "
"quiconque utilise votre code que vous gérez Python 2 **et** 3. Dans l'idéal "
"vous devrez aussi ajouter une mention pour chaque version majeure/mineure de "
"Python que vous supportez désormais."

#: ../Doc/howto/pyporting.rst:394
msgid "Use continuous integration to stay compatible"
msgstr "Utiliser l'intégration continue pour maintenir la compatibilité"

#: ../Doc/howto/pyporting.rst:396
msgid ""
"Once you are able to fully run under Python 3 you will want to make sure "
"your code always works under both Python 2 & 3. Probably the best tool for "
"running your tests under multiple Python interpreters is tox_. You can then "
"integrate tox with your continuous integration system so that you never "
"accidentally break Python 2 or 3 support."
msgstr ""
"Une fois que vous êtes en mesure d'exécuter votre code sous Python 3, vous "
"devrez vous assurer que celui-ci fonctionne toujours pour Python 2 & 3. tox_ "
"est vraisemblablement le meilleur outil pour exécuter vos tests avec "
"plusieurs interpréteurs Python. Vous pouvez alors intégrer *tox* à votre "
"système d'intégration continue afin de ne jamais accidentellement casser "
"votre gestion de Python 2 ou 3."

#: ../Doc/howto/pyporting.rst:402
msgid ""
"You may also want to use the ``-bb`` flag with the Python 3 interpreter to "
"trigger an exception when you are comparing bytes to strings or bytes to an "
"int (the latter is available starting in Python 3.5). By default type-"
"differing comparisons simply return ``False``, but if you made a mistake in "
"your separation of text/binary data handling or indexing on bytes you "
"wouldn't easily find the mistake. This flag will raise an exception when "
"these kinds of comparisons occur, making the mistake much easier to track "
"down."
msgstr ""
"Vous pouvez également utiliser l'option ``-bb`` de l'interpréteur Python 3 "
"afin de déclencher une exception lorsque vous comparez des *bytes* à des "
"chaînes de caractères ou à un entier (cette deuxième possibilité est "
"disponible à partir de Python 3.5). Par défaut, des comparaisons entre types "
"différents renvoient simplement ``False`` mais si vous avez fait une erreur "
"dans votre séparation de la gestion texte/données binaires ou votre indiçage "
"des *bytes*, vous ne trouverez pas facilement le bogue. Ce drapeau lève une "
"exception lorsque ce genre de comparaison apparaît, facilitant ainsi son "
"identification et sa localisation."

#: ../Doc/howto/pyporting.rst:410
msgid ""
"And that's mostly it! At this point your code base is compatible with both "
"Python 2 and 3 simultaneously. Your testing will also be set up so that you "
"don't accidentally break Python 2 or 3 compatibility regardless of which "
"version you typically run your tests under while developing."
msgstr ""
"Et c'est à peu près tout ! Une fois ceci fait, votre code source est "
"compatible avec Python 2 et 3 simultanément. Votre suite de test est "
"également en place de telle sorte que vous ne cassiez pas la compatibilité "
"Python 2 ou 3 indépendamment de la version que vous utilisez pendant le "
"développement."

#: ../Doc/howto/pyporting.rst:417
msgid "Consider using optional static type checking"
msgstr "Envisager l'utilisation d'un vérificateur de type statique optionnel"

#: ../Doc/howto/pyporting.rst:419
msgid ""
"Another way to help port your code is to use a static type checker like "
"mypy_ or pytype_ on your code. These tools can be used to analyze your code "
"as if it's being run under Python 2, then you can run the tool a second time "
"as if your code is running under Python 3. By running a static type checker "
"twice like this you can discover if you're e.g. misusing binary data type in "
"one version of Python compared to another. If you add optional type hints to "
"your code you can also explicitly state whether your APIs use textual or "
"binary data, helping to make sure everything functions as expected in both "
"versions of Python."
msgstr ""
"Une autre façon de faciliter le portage de votre code est d'utiliser un "
"vérificateur de type statique comme mypy_ ou pytype_. Ces outils peuvent "
"être utilisés pour analyser votre code comme s'il était exécuté sous Python "
"2, puis une seconde fois comme s'il était exécuté sous Python 3. "
"L'utilisation double d'un vérificateur de type statique de cette façon "
"permet de détecter si, par exemple, vous faites une utilisation inappropriée "
"des types de données binaires dans une version de Python par rapport à "
"l'autre. Si vous ajoutez les indices optionnels de typage à votre code, vous "
"pouvez alors explicitement déclarer que vos API attendent des données "
"binaires ou du texte, ce qui facilite alors la vérification du comportement "
"de votre code dans les deux versions de Python."
