# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-09-04 11:33+0200\n"
"PO-Revision-Date: 2019-10-31 15:33+0100\n"
"Last-Translator: Nabil Bendafi <nabil@bendafi.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.1\n"

#: ../Doc/howto/regex.rst:5
msgid "Regular Expression HOWTO"
msgstr "Guide des expressions régulières"

#: ../Doc/howto/regex.rst:0
msgid "Author"
msgstr "Auteur"

#: ../Doc/howto/regex.rst:7
msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

#: ../Doc/howto/regex.rst:None
msgid "Abstract"
msgstr "Résumé"

#: ../Doc/howto/regex.rst:18
msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr ""
"Ce document constitue un guide d'introduction à l'utilisation des "
"expressions régulières en Python avec le module :mod:`re`. Il fournit une "
"introduction plus abordable que la section correspondante dans le guide de "
"référence de la bibliothèque."

#: ../Doc/howto/regex.rst:24
msgid "Introduction"
msgstr "Introduction"

#: ../Doc/howto/regex.rst:26
msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"Les expressions régulières (notées RE ou motifs *regex* dans ce document) "
"sont essentiellement un petit langage de programmation hautement spécialisé "
"embarqué dans Python et dont la manipulation est rendue possible par "
"l'utilisation du module :mod:`re`. En utilisant ce petit langage, vous "
"définissez des règles pour spécifier une correspondance avec un ensemble "
"souhaité de chaînes de caractères ; ces chaînes peuvent être des phrases, "
"des adresses de courriel, des commandes TeX ou tout ce que vous voulez. Vous "
"pouvez ensuite poser des questions telles que \"Est-ce que cette chaîne de "
"caractères correspond au motif ?\" ou \"Y a-t-il une correspondance pour ce "
"motif à l'intérieur de la chaîne de caractères ?\". Vous pouvez aussi "
"utiliser les RE pour modifier une chaîne de caractères ou la découper de "
"différentes façons."

#: ../Doc/howto/regex.rst:35
msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"Un motif d'expression régulière est compilé en code intermédiaire "
"(*bytecode* en anglais) qui est ensuite exécuté par un moteur de "
"correspondance écrit en C. Pour une utilisation plus poussée, il peut "
"s'avérer nécessaire de s'intéresser à la manière dont le moteur exécute la "
"RE afin d'écrire une expression dont le code intermédiaire est plus rapide. "
"L'optimisation n'est pas traitée dans ce document, parce qu'elle nécessite "
"d'avoir une bonne compréhension des mécanismes internes du moteur de "
"correspondance."

#: ../Doc/howto/regex.rst:42
msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions.  "
"There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"Le langage des expressions régulières est relativement petit et restreint, "
"donc toutes les tâches de manipulation de chaînes de caractères ne peuvent "
"pas être réalisées à l'aide d'expressions régulières. Il existe aussi des "
"tâches qui *peuvent* être réalisées à l'aide d'expressions régulières mais "
"qui ont tendance à produire des expressions régulières très compliquées. "
"Dans ces cas, il est plus utile d'écrire du code Python pour réaliser le "
"traitement ; même si le code Python est plus lent qu'une expression "
"régulière élaborée, il sera probablement plus compréhensible."

#: ../Doc/howto/regex.rst:51
msgid "Simple Patterns"
msgstr "Motifs simples"

#: ../Doc/howto/regex.rst:53
msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr ""
"Nous commençons par étudier les expressions régulières les plus simples. "
"Dans la mesure où les expressions régulières sont utilisées pour manipuler "
"des chaînes de caractères, nous commençons par l'action la plus courante : "
"la correspondance de caractères."

#: ../Doc/howto/regex.rst:57
msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr ""
"Pour une explication détaillée sur le concept informatique sous-jacent aux "
"expressions régulières (automate à états déterministe ou non-déterministe), "
"vous pouvez vous référer à n'importe quel manuel sur l'écriture de "
"compilateurs."

#: ../Doc/howto/regex.rst:63
msgid "Matching Characters"
msgstr "Correspondance de caractères"

#: ../Doc/howto/regex.rst:65
msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"La plupart des lettres ou caractères correspondent simplement à eux-mêmes. "
"Par exemple, l'expression régulière ``test`` correspond à la chaîne de "
"caractères ``test``, précisément. Vous pouvez activer le mode non-sensible à "
"la casse qui permet à cette RE de correspondre également à ``Test`` ou "
"``TEST`` (ce sujet est traité par la suite)."

#: ../Doc/howto/regex.rst:70
msgid ""
"There are exceptions to this rule; some characters are special :dfn:"
"`metacharacters`, and don't match themselves.  Instead, they signal that "
"some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"Il existe des exceptions à cette règle ; certains caractères sont des :dfn:"
"`métacaractères` spéciaux et ne correspondent pas à eux-mêmes. Au lieu de "
"cela, ils signalent que certaines choses non ordinaires doivent "
"correspondre, ou ils affectent d'autre portions de la RE en les répétant ou "
"en changeant leur sens. Une grande partie de ce document est consacrée au "
"fonctionnement de ces métacaractères."

#: ../Doc/howto/regex.rst:76
msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr ""
"Voici une liste complète des métacaractères ; leur sens est décrit dans la "
"suite de ce guide."

#: ../Doc/howto/regex.rst:83
msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for "
"specifying a character class, which is a set of characters that you wish to "
"match.  Characters can be listed individually, or a range of characters can "
"be indicated by giving two characters and separating them by a ``'-'``.  For "
"example, ``[abc]`` will match any of the characters ``a``, ``b``, or ``c``; "
"this is the same as ``[a-c]``, which uses a range to express the same set of "
"characters.  If you wanted to match only lowercase letters, your RE would be "
"``[a-z]``."
msgstr ""
"Les premiers métacaractères que nous étudions sont ``[`` et ``]``. Ils sont "
"utilisés pour spécifier une classe de caractères, qui forme un ensemble de "
"caractères dont vous souhaitez trouver la correspondance. Les caractères "
"peuvent être listés individuellement, ou une plage de caractères peut être "
"indiquée en fournissant deux caractères séparés par un `'-'``. Par exemple, "
"``[abc]`` correspond à n'importe quel caractère parmi ``a``, ``b``, ou "
"``c`` ; c'est équivalent à ``[a-c]``, qui utilise une plage pour exprimer le "
"même ensemble de caractères. Si vous voulez trouver une chaîne qui ne "
"contient que des lettres en minuscules, la RE est ``[a-z]``."

#: ../Doc/howto/regex.rst:92
msgid ""
"Metacharacters are not active inside classes.  For example, ``[akm$]`` will "
"match any of the characters ``'a'``, ``'k'``, ``'m'``, or ``'$'``; ``'$'`` "
"is usually a metacharacter, but inside a character class it's stripped of "
"its special nature."
msgstr ""
"Les métacaractères ne sont pas actifs dans les classes. Par exemple, ``[akm"
"$]`` correspond à n'importe quel caractère parmi ``'a'``, ``'k'``, ``'m'`` "
"ou ``'$'`` ; ``'$'`` est habituellement un métacaractère mais dans une "
"classe de caractères, il est dépourvu de sa signification spéciale."

#: ../Doc/howto/regex.rst:97
msgid ""
"You can match the characters not listed within the class by :dfn:"
"`complementing` the set.  This is indicated by including a ``'^'`` as the "
"first character of the class. For example, ``[^5]`` will match any character "
"except ``'5'``.  If the caret appears elsewhere in a character class, it "
"does not have special meaning. For example: ``[5^]`` will match either a "
"``'5'`` or a ``'^'``."
msgstr ""
"Vous pouvez trouver une correspondance avec les caractères non listés dans "
"une classe en spécifiant le :dfn:`complément` de l'ensemble. Ceci est "
"indiqué en plaçant un ``'^'`` en tant que premier caractère de la classe. "
"Par exemple, ``[^5]`` correspond à tous les caractères, sauf ``'5'``. Si le "
"caret se trouve ailleurs dans la classe de caractères, il ne possède pas de "
"signification spéciale. Ainsi, ``[5^]`` correspond au ``'5'`` ou au "
"caractère ``'^'``."

#: ../Doc/howto/regex.rst:103
msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"Le métacaractère le plus important est probablement la barre oblique inverse "
"( *backslash* en anglais), ``\\``. Comme dans les chaînes de caractères en "
"Python, la barre oblique inverse peut être suivie par différents caractères "
"pour signaler différentes séquences spéciales. Elle est aussi utilisée pour "
"échapper tous les métacaractères afin d'en trouver les correspondances dans "
"les motifs ; par exemple, si vous devez trouver une correspondance pour "
"``[`` ou ``\\``, vous pouvez les précéder avec une barre oblique inverse "
"pour annuler leur signification spéciale : ``\\[`` ou ``\\\\``."

#: ../Doc/howto/regex.rst:110
msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set "
"of letters, or the set of anything that isn't whitespace."
msgstr ""
"Certaines séquences spéciales commençant par ``'\\'`` représentent des "
"ensembles de caractères prédéfinis qui sont souvent utiles, tels que "
"l'ensemble des chiffres, l'ensemble des lettres ou l'ensemble des caractères "
"qui ne sont pas des \"blancs\"."

#: ../Doc/howto/regex.rst:115
msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class ``[a-zA-"
"Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all the "
"characters marked as letters in the Unicode database provided by the :mod:"
"`unicodedata` module.  You can use the more restricted definition of ``\\w`` "
"in a string pattern by supplying the :const:`re.ASCII` flag when compiling "
"the regular expression."
msgstr ""
"Prenons un exemple : ``\\w`` correspond à n'importe quel caractère "
"alphanumérique. Si l'expression régulière est exprimée en *bytes*, c'est "
"équivalent à la classe ``[a-zA-Z0-9_]``. Si l'expression régulière est une "
"chaîne de caractères, ``\\w`` correspond à tous les caractères identifiés "
"comme lettre dans la base de données Unicode fournie par le module :mod:"
"`unicodedata`. Vous pouvez utiliser la définition plus restrictive de ``"
"\\w`` dans un motif exprimé en chaîne de caractères en spécifiant l'option :"
"const:`re.ASCII` lors de la compilation de l'expression régulière."

#: ../Doc/howto/regex.rst:123
msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see "
"the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"La liste de séquences spéciales suivante est incomplète. Pour une liste "
"complète des séquences et définitions de classes étendues relatives aux "
"motifs de chaînes de caractères Unicode, reportez-vous à la dernière partie "
"de la référence :ref:`Syntaxe d'Expressions Régulières <re-syntax>` de la "
"bibliothèque standard. En général, les versions Unicode trouvent une "
"correspondance avec n'importe quel caractère présent dans la catégorie "
"appropriée de la base de données Unicode."

#: ../Doc/howto/regex.rst:131
msgid "``\\d``"
msgstr "``\\d``"

#: ../Doc/howto/regex.rst:131
msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr ""
"Correspond à n'importe quel caractère numérique ; équivalent à la classe "
"``[0-9]``."

#: ../Doc/howto/regex.rst:134
msgid "``\\D``"
msgstr "``\\D``"

#: ../Doc/howto/regex.rst:134
msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr ""
"Correspond à n'importe caractère non numérique ; équivalent à la classe "
"``[^0-9]``."

#: ../Doc/howto/regex.rst:138
msgid "``\\s``"
msgstr "``\\s``"

#: ../Doc/howto/regex.rst:137
msgid ""
"Matches any whitespace character; this is equivalent to the class ``[ \\t\\n"
"\\r\\f\\v]``."
msgstr ""
"Correspond à n'importe quel caractère \"blanc\" ; équivalent à la classe "
"``[ \\t\\n\\r\\f\\v]``."

#: ../Doc/howto/regex.rst:142
msgid "``\\S``"
msgstr "``\\S``"

#: ../Doc/howto/regex.rst:141
msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"Correspond à n'importe caractère autre que \"blanc\" ; équivalent à la "
"classe ``[^ \\t\\n\\r\\f\\v]``."

#: ../Doc/howto/regex.rst:146
msgid "``\\w``"
msgstr "``\\w``"

#: ../Doc/howto/regex.rst:145
msgid ""
"Matches any alphanumeric character; this is equivalent to the class ``[a-zA-"
"Z0-9_]``."
msgstr ""
"Correspond à n'importe caractère alphanumérique ; équivalent à la classe "
"``[a-zA-Z0-9_]``."

#: ../Doc/howto/regex.rst:150
msgid "``\\W``"
msgstr "``\\W``"

#: ../Doc/howto/regex.rst:149
msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr ""
"Correspond à n'importe caractère non-alphanumérique ; équivalent à la classe "
"``[^a-zA-Z0-9_]``."

#: ../Doc/howto/regex.rst:152
msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr ""
"Ces séquences peuvent être incluses dans une classe de caractères. Par "
"exemple, ``[\\s,.]`` est une classe de caractères qui correspond à tous les "
"caractères \"blancs\" ou ``','`` ou ``'.'``."

#: ../Doc/howto/regex.rst:156
msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode (:const:`re."
"DOTALL`) where it will match even a newline.  ``.`` is often used where you "
"want to match \"any character\"."
msgstr ""
"Le dernier métacaractère de cette section est ``.``. Il correspond à tous "
"les caractères, à l'exception du caractère de retour à la ligne ; il existe "
"un mode alternatif (:const:`re.DOTALL`) dans lequel il correspond également "
"eu caractère de retour à la ligne. ``.`` est souvent utilisé lorsque l'on "
"veut trouver une correspondance avec \"n'importe quel caractère\"."

#: ../Doc/howto/regex.rst:163
msgid "Repeating Things"
msgstr "Répétitions"

#: ../Doc/howto/regex.rst:165
msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on "
"strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"Trouver des correspondances de divers ensembles de caractères est la "
"première utilisation des expressions régulières, ce que l'on ne peut pas "
"faire avec les méthodes des chaînes. Cependant, si c'était la seule "
"possibilité des expressions régulières, le gain ne serait pas significatif. "
"Une autre utilisation consiste à spécifier des portions d'une RE qui peuvent "
"être répétées un certain nombre de fois."

#: ../Doc/howto/regex.rst:171
msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""
"Le premier métacaractère pour la répétition que nous abordons est ``*``. "
"``*`` ne correspond pas au caractère littéral ``'*'`` ; à la place, il "
"spécifie que le caractère précédent peut correspondre zéro, une ou plusieurs "
"fois (au lieu d'une seule fois)."

#: ../Doc/howto/regex.rst:175
msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"Par exemple, ``cha*t`` correspond à ``'cht'`` (0 caractère ``'a'``), "
"``'chat'`` (1 ``'a'``), ``'chaaat'`` (3 caractères  ``'a'``) et ainsi de "
"suite."

#: ../Doc/howto/regex.rst:178
msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"Les répétitions telles que ``*`` sont :dfn:`gloutonnes` ; quand vous répétez "
"une RE, le moteur de correspondance essaie de trouver la correspondance la "
"plus longue en répétant le motif tant qu'il le peut. Si la suite du motif ne "
"correspond pas, le moteur de correspondance revient en arrière et essaie "
"avec moins de répétitions."

#: ../Doc/howto/regex.rst:183
msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"Un exemple étape par étape mettra les choses au clair. Considérons "
"l'expression ``a[bcd]*b``. Elle correspond à la lettre ``'a'``, suivi "
"d'aucune ou plusieurs lettres de la classe `[bcd]`` et finit par un ``'b'``. "
"Maintenant, supposons que nous cherchons une correspondance de cette RE avec "
"la chaîne de caractères ``'abcbd'``."

#: ../Doc/howto/regex.rst:189
msgid "Step"
msgstr "Étape"

#: ../Doc/howto/regex.rst:189
msgid "Matched"
msgstr "Correspond"

#: ../Doc/howto/regex.rst:189
msgid "Explanation"
msgstr "Explication"

#: ../Doc/howto/regex.rst:191
msgid "1"
msgstr "1"

#: ../Doc/howto/regex.rst:191
msgid "``a``"
msgstr "``a``"

#: ../Doc/howto/regex.rst:191
msgid "The ``a`` in the RE matches."
msgstr "Le ``a`` correspond dans la RE."

#: ../Doc/howto/regex.rst:193
msgid "2"
msgstr "2"

#: ../Doc/howto/regex.rst:193
msgid "``abcbd``"
msgstr "``abcbd``"

#: ../Doc/howto/regex.rst:193
msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr ""
"Le moteur de correspondance trouve ``[bcd]*``, va aussi loin qu'il le peut, "
"ce qui n'est pas la fin de la chaîne."

#: ../Doc/howto/regex.rst:197
msgid "3"
msgstr "3"

#: ../Doc/howto/regex.rst:197 ../Doc/howto/regex.rst:205
msgid "*Failure*"
msgstr "*échec*"

#: ../Doc/howto/regex.rst:197
msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr ""
"Le moteur essaie de trouver une correspondance avec ``b`` mais la position "
"courante est à la fin de la chaîne de caractères, donc il échoue."

#: ../Doc/howto/regex.rst:202
msgid "4"
msgstr "4"

#: ../Doc/howto/regex.rst:202 ../Doc/howto/regex.rst:213
msgid "``abcb``"
msgstr "``abcb``"

#: ../Doc/howto/regex.rst:202
msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr ""
"Retour en arrière, de manière à ce que ``[bcd]*`` corresponde avec un "
"caractère de moins."

#: ../Doc/howto/regex.rst:205
msgid "5"
msgstr "5"

#: ../Doc/howto/regex.rst:205
msgid ""
"Try ``b`` again, but the current position is at the last character, which is "
"a ``'d'``."
msgstr ""
"Essaie encore ``b``, mais la position courante est le dernier caractère, qui "
"est ``'d'``."

#: ../Doc/howto/regex.rst:209 ../Doc/howto/regex.rst:213
msgid "6"
msgstr "6"

#: ../Doc/howto/regex.rst:209
msgid "``abc``"
msgstr "``abc``"

#: ../Doc/howto/regex.rst:209
msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr ""
"Encore un retour en arrière, de manière à ce que ``[bcd]*`` ne corresponde "
"qu'à ``bc``."

#: ../Doc/howto/regex.rst:213
msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr ""
"Essaie ``b`` encore une fois. Cette fois, le caractère à la position "
"courante est ``'b'``, donc cela fonctionne."

#: ../Doc/howto/regex.rst:219
msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This "
"demonstrates how the matching engine goes as far as it can at first, and if "
"no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for "
"``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""
"La fin de la RE est maintenant atteinte et la correspondance trouvée est "
"``'abcb'``. Ceci démontre comment le moteur de correspondance essaie d'aller "
"le plus loin possible en premier et, si la correspondance échoue, il revient "
"progressivement en arrière et ré-essaie avec le reste de la RE encore et "
"encore. Il revient en arrière jusqu'à qu'il n'y ait aucune correspondance "
"pour ``[bcd]*`` et, si cela échoue toujours, le moteur conclut que la chaîne "
"de caractères et la RE ne correspondent pas du tout."

#: ../Doc/howto/regex.rst:226
msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"Un autre métacaractère de répétition est ``+``, qui fait correspondre une ou "
"plusieurs fois. Faites bien attention à la différence entre ``*`` et ``+`` ; "
"``*`` fait correspondre *zéro* fois ou plus, ainsi ce qui doit être répété "
"peut ne pas être présent du tout, alors que  ``+`` requiert au moins *une* "
"occurrence. Pour continuer avec le même exemple, ``cha+t`` correspond avec "
"``'chat'`` (1 ``'a'``), ``'chaaat'`` (3 ``'a'``) mais ne correspond pas avec "
"``'ct'``."

#: ../Doc/howto/regex.rst:233
msgid ""
"There are two more repeating qualifiers.  The question mark character, ``?"
"``, matches either once or zero times; you can think of it as marking "
"something as being optional.  For example, ``home-?brew`` matches either "
"``'homebrew'`` or ``'home-brew'``."
msgstr ""
"Il existe deux autres quantificateurs pour les répétitions. Le point "
"d'interrogation, ``?``, fait correspondre zéro ou une fois ; vous pouvez "
"vous le représenter comme indiquant une option. Par exemple, ``méta-?"
"caractère`` fait correspondre soit ``métacaractère``, soit ``méta-"
"caractère``."

#: ../Doc/howto/regex.rst:238
msgid ""
"The most complicated repeated qualifier is ``{m,n}``, where *m* and *n* are "
"decimal integers.  This qualifier means there must be at least *m* "
"repetitions, and at most *n*.  For example, ``a/{1,3}b`` will match ``'a/"
"b'``, ``'a//b'``, and ``'a///b'``.  It won't match ``'ab'``, which has no "
"slashes, or ``'a////b'``, which has four."
msgstr ""
"Le plus compliqué des quantificateurs est ``{m,n}`` où *m* et *n* sont des "
"entiers décimaux. Ce quantificateur indique qu'il faut au moins *m* "
"répétitions et au plus *n*. Par exemple, ``a/{1,3}b`` fait correspondre ``'a/"
"b'``, ``'a//b'`` et ``'a///b'``. Elle ne fait pas correspondre ``'ab'`` (pas "
"de barre oblique) ni ``'a////b'`` (quatre barres obliques)."

#: ../Doc/howto/regex.rst:244
msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""
"Vous pouvez omettre soit *m*, soit *n* ; dans ce cas, une valeur raisonnable "
"est prise pour la valeur manquante. Omettre *m* considère que la borne basse "
"est 0 alors qu'omettre *n* signifie qu'il n'y a pas de borne supérieure."

#: ../Doc/howto/regex.rst:248
msgid ""
"Readers of a reductionist bent may notice that the three other qualifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""
"Le lecteur attentif aura noté que les trois premiers quantificateurs peuvent "
"être exprimés en utilisant cette notation. ``{0,}`` est la même chose que "
"``*``, ``{1,}`` est équivalent à ``+`` et ``{0,1}`` se comporte comme ``?``. "
"Il est préférable d'utiliser ``*``, ``+`` ou ``?`` quand vous le pouvez, "
"simplement parce qu'ils sont plus courts et plus faciles à lire."

#: ../Doc/howto/regex.rst:256
msgid "Using Regular Expressions"
msgstr "Utilisation des expressions régulières"

#: ../Doc/howto/regex.rst:258
msgid ""
"Now that we've looked at some simple regular expressions, how do we actually "
"use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then "
"perform matches with them."
msgstr ""
"Maintenant que nous avons vu quelques expressions régulières simples, "
"utilisons-les concrètement. Le module :mod:`re` fournit une interface pour "
"le moteur de correspondance, ce qui permet de compiler les RE en objets et "
"d'effectuer des correspondances avec."

#: ../Doc/howto/regex.rst:265
msgid "Compiling Regular Expressions"
msgstr "Compilation des expressions régulières"

#: ../Doc/howto/regex.rst:267
msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr ""
"Les expressions régulières sont compilées en objets motifs, qui possèdent "
"des méthodes pour diverses opérations telles que la recherche de "
"correspondances ou les substitutions dans les chaînes. ::"

#: ../Doc/howto/regex.rst:276
msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable "
"various special features and syntax variations.  We'll go over the available "
"settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` accepte aussi une option *flags*, utilisée pour activer "
"des fonctionnalités particulières et des variations de syntaxe. Nous "
"étudierons la définition des variables plus tard et, pour l'instant, un seul "
"exemple suffit ::"

#: ../Doc/howto/regex.rst:282
msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language, "
"and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the :mod:"
"`socket` or :mod:`zlib` modules."
msgstr ""
"La RE passée à :func:`re.compile` est une chaîne. Les RE sont des chaînes "
"car les expressions régulières ne font pas partie intrinsèque du langage "
"Python et aucune syntaxe particulière n'a été créée pour les exprimer (il "
"existe des applications qui ne nécessitent aucune RE et il n'a donc aucune "
"raison de grossir les spécifications du langage en incluant les RE). Ainsi, "
"le module :mod:`re` est simplement un module d'extension en C inclus dans "
"Python, tout comme les modules :mod:`socket` ou :mod:`zlib`."

#: ../Doc/howto/regex.rst:289
msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr ""
"Exprimer les RE comme des chaînes de caractères garde le langage Python plus "
"simple mais introduit un inconvénient qui fait l'objet de la section "
"suivante."

#: ../Doc/howto/regex.rst:296
msgid "The Backslash Plague"
msgstr "La maudite barre oblique inverse"

#: ../Doc/howto/regex.rst:298
msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"Comme indiqué précédemment, les expressions régulières utilisent la barre "
"oblique inverse (*backslash* en anglais) pour indiquer des constructions "
"particulières ou pour autoriser des caractères spéciaux sans que leur "
"signification spéciale ne soit invoquée. C'est en contradiction avec l'usage "
"de Python qui est qu'un caractère doit avoir la même signification dans les "
"littéraux de chaînes de caractères."

#: ../Doc/howto/regex.rst:303
msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However, "
"to express this as a Python string literal, both backslashes must be escaped "
"*again*."
msgstr ""
"Considérons que vous voulez écrire une RE qui fait correspondre la chaîne de "
"caractères ``\\section`` (on en trouve dans un fichier LaTeX). Pour savoir "
"ce qu'il faut coder dans votre programme, commençons par la chaîne de "
"caractères cherchée. Ensuite, nous devons échapper chaque barre oblique "
"inverse et tout autre métacaractère en les précédant d'une barre oblique "
"inverse, ce qui donne la chaîne de caractères ``\\\\section``. La chaîne "
"résultante qui doit être passée à :func:`re.compile` est donc ``\\"
"\\section``. Comme nous devons l'exprimer sous la forme d'une chaîne "
"littérale Python, nous devons échapper les deux barres obliques inverses "
"*encore une fois*."

#: ../Doc/howto/regex.rst:312
msgid "Characters"
msgstr "Caractères"

#: ../Doc/howto/regex.rst:312
msgid "Stage"
msgstr "Niveau"

#: ../Doc/howto/regex.rst:314
msgid "``\\section``"
msgstr "``\\section``"

#: ../Doc/howto/regex.rst:314
msgid "Text string to be matched"
msgstr "Chaîne de caractère à chercher"

#: ../Doc/howto/regex.rst:316
msgid "``\\\\section``"
msgstr "``\\\\section``"

#: ../Doc/howto/regex.rst:316
msgid "Escaped backslash for :func:`re.compile`"
msgstr "Barre oblique inverse échappée pour :func:`re.compile`"

#: ../Doc/howto/regex.rst:318 ../Doc/howto/regex.rst:345
msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\section\"``"

#: ../Doc/howto/regex.rst:318
msgid "Escaped backslashes for a string literal"
msgstr ""
"Barres obliques inverses échappées pour un littéral de chaîne de caractères"

#: ../Doc/howto/regex.rst:321
msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to understand."
msgstr ""
"Pour faire court, si vous cherchez une correspondance pour une barre oblique "
"inverse littérale, écrivez ``'\\\\\\\\'`` dans votre chaîne RE, car "
"l'expression régulière doit être ``\\\\`` et que chaque barre oblique "
"inverse doit être exprimée comme ``\\\\`` dans un littéral chaîne de "
"caractères Python. Dans les RE qui comportent plusieurs barres obliques "
"inverses, cela conduit à beaucoup de barres obliques inverses et rend la "
"chaîne résultante difficile à comprendre."

#: ../Doc/howto/regex.rst:327
msgid ""
"The solution is to use Python's raw string notation for regular expressions; "
"backslashes are not handled in any special way in a string literal prefixed "
"with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'`` "
"and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this "
"raw string notation."
msgstr ""
"La solution consiste à utiliser les chaînes brutes Python pour les "
"expressions régulières ; les barres obliques inverses ne sont pas gérées "
"d'une manière particulière dans les chaînes littérales préfixées avec "
"``'r'``. Ainsi, ``r\"\\n\"`` est la chaîne de deux caractères contenant "
"``'\\'`` et ``'n'`` alors que ``\"\\n\"`` est la chaîne contenant uniquement "
"le caractère retour à la ligne. Les expressions régulières sont souvent "
"écrites dans le code Python en utilisant la notation \"chaînes brutes\"."

#: ../Doc/howto/regex.rst:333
msgid ""
"In addition, special escape sequences that are valid in regular expressions, "
"but not valid as Python string literals, now result in a :exc:"
"`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, which "
"means the sequences will be invalid if raw string notation or escaping the "
"backslashes isn't used."
msgstr ""
"En complément, les séquences d'échappement valides dans les expressions "
"régulières, mais non valides dans les littéraux chaînes classiques, "
"produisent dorénavant un :exc:`DeprecationWarning` et, possiblement, "
"deviendront une :exc:`SyntaxError`, ce qui signifie que les séquences seront "
"invalides si la notation \"chaîne brute\" ou l'échappement des barres "
"obliques inverses ne sont pas utilisés."

#: ../Doc/howto/regex.rst:341
msgid "Regular String"
msgstr "Chaîne normale"

#: ../Doc/howto/regex.rst:341
msgid "Raw string"
msgstr "Chaîne de caractères brute"

#: ../Doc/howto/regex.rst:343
msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

#: ../Doc/howto/regex.rst:343
msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

#: ../Doc/howto/regex.rst:345
msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\section\"``"

#: ../Doc/howto/regex.rst:347
msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

#: ../Doc/howto/regex.rst:347
msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

#: ../Doc/howto/regex.rst:352
msgid "Performing Matches"
msgstr "Recherche de correspondances"

#: ../Doc/howto/regex.rst:354
msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"Une fois que nous avons un objet représentant une expression régulière "
"compilée, qu'en faisons-nous ? Les objets motifs ont plusieurs méthodes et "
"attributs. Seuls les plus significatifs seront couverts ici ; consultez la "
"documentation :mod:`re` pour la liste complète."

#: ../Doc/howto/regex.rst:360 ../Doc/howto/regex.rst:418
#: ../Doc/howto/regex.rst:1064
msgid "Method/Attribute"
msgstr "Méthode/Attribut"

#: ../Doc/howto/regex.rst:360 ../Doc/howto/regex.rst:418
#: ../Doc/howto/regex.rst:1064
msgid "Purpose"
msgstr "Objectif"

#: ../Doc/howto/regex.rst:362
msgid "``match()``"
msgstr "``match()``"

#: ../Doc/howto/regex.rst:362
msgid "Determine if the RE matches at the beginning of the string."
msgstr "Détermine si la RE fait correspond dès le début de la chaîne."

#: ../Doc/howto/regex.rst:365
msgid "``search()``"
msgstr "``search()``"

#: ../Doc/howto/regex.rst:365
msgid "Scan through a string, looking for any location where this RE matches."
msgstr "Analyse la chaîne à la recherche d'une position où la RE correspond."

#: ../Doc/howto/regex.rst:368
msgid "``findall()``"
msgstr "``findall()``"

#: ../Doc/howto/regex.rst:368
msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr ""
"Trouve toutes les sous-chaînes qui correspondent à la RE et les renvoie sous "
"la forme d'une liste."

#: ../Doc/howto/regex.rst:371
msgid "``finditer()``"
msgstr "``finditer()``"

#: ../Doc/howto/regex.rst:371
msgid ""
"Find all substrings where the RE matches, and returns them as an :term:"
"`iterator`."
msgstr ""
"Trouve toutes les sous-chaînes qui correspondent à la RE et les renvoie sous "
"la forme d'un :term:`itérateur <iterator>`."

#: ../Doc/howto/regex.rst:375
msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""
":meth:`~re.Pattern.match` et :meth:`~re.Pattern.search` renvoient ``None`` "
"si aucune correspondance ne peut être trouvée. Si elles trouvent une "
"correspondance, une instance d'objet :ref:`correspondance <match-objects>` "
"est renvoyée, contenant les informations relatives à la correspondance : "
"position de départ et de fin, la sous-chaîne qui correspond et d'autres "
"informations."

#: ../Doc/howto/regex.rst:380
msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module.  If you have :mod:`tkinter` available, you may also want to look at :"
"source:`Tools/demo/redemo.py`, a demonstration program included with the "
"Python distribution.  It allows you to enter REs and strings, and displays "
"whether the RE matches or fails. :file:`redemo.py` can be quite useful when "
"trying to debug a complicated RE."
msgstr ""
"Vous pouvez apprendre leur fonctionnement en expérimentant de manière "
"interactive avec le module :mod:`re`. Si vous disposez de :mod:`tkinter`, "
"vous pouvez aussi regarder les sources de :source:`Tools/demo/redemo.py`, un "
"programme de démonstration inclus dans la distribution Python. Ce programme "
"vous permet de rentrer des RE et des chaînes, affichant si la RE correspond "
"ou pas. :file:`redemo.py` peut s'avérer particulièrement utile quand vous "
"devez déboguer une RE compliquée."

#: ../Doc/howto/regex.rst:387
msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run "
"the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"Ce guide utilise l'interpréteur standard de Python pour ses exemples. "
"Commencez par lancer l'interpréteur Python, importez le module :mod:`re` et "
"compilez une RE ::"

#: ../Doc/howto/regex.rst:395
msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case, "
"which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"Maintenant, vous pouvez tester des correspondances de la RE ``[a-z]+`` avec "
"différentes chaînes. Une chaîne vide ne doit pas correspondre, puisque ``+`` "
"indique \"une ou plusieurs occurrences\". :meth:`~re.Pattern.match` doit "
"renvoyer ``None`` dans ce cas, ce qui fait que l'interpréteur n'affiche "
"rien. Vous pouvez afficher le résultat de :meth:`!match` explicitement pour "
"que ce soit clair. ::"

#: ../Doc/howto/regex.rst:405
msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object <match-"
"objects>`, so you should store the result in a variable for later use. ::"
msgstr ""
"Maintenant, essayons sur une chaîne qui doit correspondre, par exemple "
"``tempo``. Dans ce cas, :meth:`~re.Pattern.match` renvoie un :ref:`objet "
"correspondance <match-objects>`, vous pouvez ainsi stocker le résultat dans "
"une variable pour une utilisation ultérieure. ::"

#: ../Doc/howto/regex.rst:413
msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods "
"and attributes; the most important ones are:"
msgstr ""
"Maintenant, vous pouvez interroger :ref:`l'objet correspondance <match-"
"objects>` pour obtenir des informations sur la chaîne qui correspond. Les "
"instances d'objets correspondances possèdent plusieurs méthodes et "
"attributs ; les plus importants sont :"

#: ../Doc/howto/regex.rst:420
msgid "``group()``"
msgstr "``group()``"

#: ../Doc/howto/regex.rst:420
msgid "Return the string matched by the RE"
msgstr "Renvoie la chaîne de caractères correspondant à la RE"

#: ../Doc/howto/regex.rst:422
msgid "``start()``"
msgstr "``start()``"

#: ../Doc/howto/regex.rst:422
msgid "Return the starting position of the match"
msgstr "Renvoie la position de début de la correspondance"

#: ../Doc/howto/regex.rst:424
msgid "``end()``"
msgstr "``end()``"

#: ../Doc/howto/regex.rst:424
msgid "Return the ending position of the match"
msgstr "Renvoie la position de fin de la correspondance"

#: ../Doc/howto/regex.rst:426
msgid "``span()``"
msgstr "``span()``"

#: ../Doc/howto/regex.rst:426
msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr ""
"Renvoie un *tuple* contenant les positions (début, fin) de la correspondance"

#: ../Doc/howto/regex.rst:430
msgid "Trying these methods will soon clarify their meaning::"
msgstr "Essayons ces méthodes pour clarifier leur signification ::"

#: ../Doc/howto/regex.rst:439
msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  :"
"meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end "
"indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only "
"checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that "
"case. ::"
msgstr ""
":meth:`~re.Match.group` renvoie la sous-chaîne qui correspond à la RE. :meth:"
"`~re.Match.start` et :meth:`~re.Match.end` renvoient les indices de début et "
"de fin de la correspondance. :meth:`~re.Match.span` renvoie les indices de "
"début et de fin dans un seul *tuple*. Comme la méthode :meth:`~re.Pattern."
"match` ne fait que vérifier si la RE correspond au début de la chaîne, :meth:"
"`!start` vaut toujours zéro. Cependant, la méthode :meth:`~re.Pattern."
"search` d'un motif analyse toute la chaîne, afin de trouver une "
"correspondance potentielle qui ne commence pas à zéro. ::"

#: ../Doc/howto/regex.rst:456
msgid ""
"In actual programs, the most common style is to store the :ref:`match object "
"<match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"Dans les programmes réels, la façon de faire la plus courante consiste à "
"stocker :ref:`l'objet correspondance <match-objects>` dans une variable, "
"puis à vérifier s'il vaut ``None``. Généralement, cela ressemble à ceci ::"

#: ../Doc/howto/regex.rst:467
msgid ""
"Two pattern methods return all of the matches for a pattern. :meth:`~re."
"Pattern.findall` returns a list of matching strings::"
msgstr ""
"Deux méthodes de motifs renvoient toutes les correspondances pour un motif. :"
"meth:`~re.Pattern.findall` renvoie une liste des chaînes qui correspondent ::"

#: ../Doc/howto/regex.rst:474
msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this "
"example because escape sequences in a normal \"cooked\" string literal that "
"are not recognized by Python, as opposed to regular expressions, now result "
"in a :exc:`DeprecationWarning` and will eventually become a :exc:"
"`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"Le préfixe ``r``, qui indique une chaîne brute littérale, est nécessaire "
"dans cet exemple car les séquences d'échappement dans une chaîne littérale "
"qui ne sont pas reconnues par Python, alors qu'elles le sont par les "
"expressions régulières, induisent maintenant un :exc:`DeprecationWarning` et "
"deviendront possiblement des :exc:`SyntaxError`.  Reportez-vous à :ref:`the-"
"backslash-plague`."

#: ../Doc/howto/regex.rst:480
msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an :term:"
"`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall` doit créer la liste entière avant d'être renvoyé "
"comme résultat. La méthode :meth:`~re.Pattern.finditer` renvoie une séquence "
"d'instances :ref:`d'objets correspondances <match-objects>` en tant :term:"
"`qu'itérateur <iterator>` ::"

#: ../Doc/howto/regex.rst:496
msgid "Module-Level Functions"
msgstr "Fonctions de niveau module"

#: ../Doc/howto/regex.rst:498
msgid ""
"You don't have to create a pattern object and call its methods; the :mod:"
"`re` module also provides top-level functions called :func:`~re.match`, :"
"func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"Vous n'avez pas besoin de créer un objet motif et d'appeler ses méthodes ; "
"le module :mod:`re` fournit des fonctions à son niveau, ce sont :func:`~re."
"match`, :func:`~re.search`, :func:`~re.findall`, :func:`~re.sub` et ainsi de "
"suite. Ces fonctions prennent les mêmes arguments que les méthodes "
"correspondantes des objets motifs, avec la chaîne RE ajoutée en tant que "
"premier argument. Elles renvoient toujours ``None`` ou une instance  :ref:"
"`d'objet correspondance <match-objects>`. ::"

#: ../Doc/howto/regex.rst:510
msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a "
"cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"En interne, ces fonctions créent simplement un objet motif pour vous et "
"appellent la méthode appropriée de cet objet. Elles stockent également "
"l'objet compilé dans un cache afin que les appels suivants qui utilisent la "
"même RE n'aient pas besoin d'analyser le motif une nouvelle fois."

#: ../Doc/howto/regex.rst:515
msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"Devez-vous utiliser ces fonctions au niveau des modules ou devez-vous "
"calculer le motif et appeler vous-même ses méthodes ? Si vous utilisez "
"l'expression régulière à l'intérieur d'une boucle, la pré-compilation permet "
"d'économiser quelques appels de fonctions. En dehors des boucles, il n'y a "
"pas beaucoup de différence grâce au cache interne."

#: ../Doc/howto/regex.rst:523
msgid "Compilation Flags"
msgstr "Options de compilation"

#: ../Doc/howto/regex.rst:525
msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as :const:"
"`I`.  (If you're familiar with Perl's pattern modifiers, the one-letter "
"forms use the same letters; the short form of :const:`re.VERBOSE` is :const:"
"`re.X`, for example.) Multiple flags can be specified by bitwise OR-ing "
"them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for "
"example."
msgstr ""
"Les options de compilation vous permettent de modifier le comportement des "
"expressions régulières. Ces options sont accessibles dans le module :mod:"
"`re` par deux noms, un long du type :const:`IGNORECASE` et un court (une "
"seule lettre) tel que :const:`I` (si vous êtes habitués aux modificateurs de "
"motifs Perl, la version courte utilise les mêmes lettres que Perl, par "
"exemple la version courte de :const:`re.VERBOSE` est :const:`re.X`). "
"Plusieurs options peuvent être spécifiées en appliquant l'opérateur bit-à-"
"bit *OR* ; par exemple, ``re.I | re.M`` active à la fois les options :const:"
"`I` et :const:`M`."

#: ../Doc/howto/regex.rst:533
msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr ""
"Vous trouvez ci-dessous le tableau des options disponibles, suivies "
"d'explications détaillées."

#: ../Doc/howto/regex.rst:537
msgid "Flag"
msgstr "Option"

#: ../Doc/howto/regex.rst:537
msgid "Meaning"
msgstr "Signification"

#: ../Doc/howto/regex.rst:539
msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

#: ../Doc/howto/regex.rst:539
msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr ""
"Transforme plusieurs échappements tels que ``\\w``, ``\\b``, ``\\s`` et ``"
"\\d`` de manière à ce qu'ils ne correspondent qu'à des caractères ASCII "
"ayant la propriété demandée."

#: ../Doc/howto/regex.rst:543
msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

#: ../Doc/howto/regex.rst:543
msgid "Make ``.`` match any character, including newlines."
msgstr ""
"Fait en sorte que ``.`` corresponde à n'importe quel caractère, caractère de "
"retour à la ligne inclus."

#: ../Doc/howto/regex.rst:546
msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

#: ../Doc/howto/regex.rst:546
msgid "Do case-insensitive matches."
msgstr "Recherche une correspondance sans tenir compte de la casse."

#: ../Doc/howto/regex.rst:548
msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

#: ../Doc/howto/regex.rst:548
msgid "Do a locale-aware match."
msgstr ""
"Recherche une correspondance en tenant compte de la configuration de la "
"région."

#: ../Doc/howto/regex.rst:550
msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

#: ../Doc/howto/regex.rst:550
msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr "Correspondance multi-lignes, affecte ``^`` et ``$``."

#: ../Doc/howto/regex.rst:553
msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ""
":const:`VERBOSE`, :const:`X` (pour *extended*, c-à-d étendu en anglais)"

#: ../Doc/howto/regex.rst:553
msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr ""
"Active les RE verbeuses, qui peuvent être organisées de manière plus propre "
"et compréhensible."

#: ../Doc/howto/regex.rst:562
msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase "
"letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns ``[a-"
"z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` flag, "
"they will match the 52 ASCII letters and 4 additional non-ASCII letters: "
"'İ' (U+0130, Latin capital letter I with dot above), 'ı' (U+0131, Latin "
"small letter dotless i), 'ſ' (U+017F, Latin small letter long s) and 'K' (U"
"+212A, Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, "
"``'spAM'``, or ``'ſpam'`` (the latter is matched only in Unicode mode). This "
"lowercasing doesn't take the current locale into account; it will if you "
"also set the :const:`LOCALE` flag."
msgstr ""
"Effectue une correspondance insensible à la casse ; les classes de "
"caractères et les littéraux de chaînes de caractères ignorent la casse pour "
"la correspondance. Par exemple, ``[A-Z]`` correspond aussi aux lettres "
"minuscules. La correspondance Unicode complète fonctionne également, sauf si "
"l'option :const:`ASCII` est utilisée pour désactiver les correspondances non "
"ASCII. Lorsque les motifs Unicode ``[a-z]`` ou ``[A-Z]`` sont utilisés en "
"combinaison avec l'option :const:`IGNORECASE`, ils correspondent avec les 52 "
"lettres ASCII et 4 lettres non ASCII supplémentaires : 'İ' (U+0130, lettre I "
"en majuscule latine avec un point au-dessus), 'ı' (U+0131, lettre minuscule "
"latine i sans point au-dessus), 'ſ' (U+017F, lettre minuscule latine longue "
"s) et 'K' (U+212A, signe du Kelvin). ``Spam`` correspond ainsi à ``'Spam'``, "
"``'spam'``, ``'spAM'`` ou ``'ſpam'`` (ce dernier ne correspond qu'en mode "
"Unicode). Le passage en minuscules ne prend pas en compte la configuration "
"de région courante ; elle le fait si vous mettez aussi l'option :const:"
"`LOCALE`."

#: ../Doc/howto/regex.rst:580
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""
"Rend ``\\w``, ``\\W``, ``\\b``, ``\\B`` et les correspondances non sensibles "
"à la casse dépendants de la configuration de la région courante au lieu de "
"la base de données Unicode."

#: ../Doc/howto/regex.rst:583
msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``é`` or ``ç``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``é`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+`` "
"to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""
"Les *locales* sont une caractéristique de la bibliothèque C destinées à "
"favoriser une programmation qui tient compte des différences linguistiques "
"(NdT : nous utilisons *configuration de région* dans cette page pour "
"désigner ce concept de la bibliothèque C). Par exemple, si vous traitez du "
"texte français, vous souhaitez pouvoir écrire ``\\w+`` pour faire "
"correspondre les mots, mais ``\\w`` ne correspond qu'à la classe de "
"caractères ``[A-Za-za-z]`` en octets ; cette classe ne correspond pas avec "
"les octets codant ``é`` ou ``ç``. Si votre système est configuré "
"correctement et que la configuration de région est définie sur 'français', "
"certaines fonctions C diront à votre programme que l'octet codant ``é`` doit "
"être considéré comme une lettre. Définir l'option :const:`LOCALE` lors de la "
"compilation d'une expression régulière fait que l'objet compilé résultant "
"utilise ces fonctions C pour ``\\w`` ; c'est plus lent mais cela permet à ``"
"\\w+`` de correspondre avec les mots français tel qu'attendu. L'utilisation "
"de cette option est déconseillée en Python 3 car le mécanisme de locale est "
"très peu fiable, il ne gère qu'une seule \"culture\" à la fois et il ne "
"fonctionne qu'avec des locales 8 bits. La correspondance Unicode est déjà "
"activée par défaut dans Python 3 pour les motifs Unicode (type *str*) et "
"elle est capable de gérer différentes configurations de régions."

#: ../Doc/howto/regex.rst:605
msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"Nota : ``^`` et ``$`` n'ont pas encore été expliqués ; ils sont introduits "
"dans la section :ref:`more-metacharacters`."

#: ../Doc/howto/regex.rst:608
msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string, "
"immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"Normalement, ``^`` correspond uniquement au début de la chaîne, et ``$`` "
"correspond uniquement à la fin de la chaîne et immédiatement avant la "
"nouvelle ligne (s'il y en a une) à la fin de la chaîne. Lorsque cette option "
"est spécifiée, ``^`` correspond au début de la chaîne de caractères et au "
"début de chaque ligne de la chaîne de caractères, immédiatement après le "
"début de la nouvelle ligne. De même, le métacaractère ``$`` correspond à la "
"fin de la chaîne de caractères ou à la fin de chaque ligne (précédant "
"immédiatement chaque nouvelle ligne)."

#: ../Doc/howto/regex.rst:621
msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Fait que le caractère spécial ``'.'`` corresponde avec n'importe quel "
"caractère, y compris le retour à la ligne ; sans cette option, ``'.'`` "
"correspond avec tout, *sauf* le retour à la ligne."

#: ../Doc/howto/regex.rst:629
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"Fait que ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` et ``\\S`` ne "
"correspondent qu'avec des caractères ASCII au lieu de l'ensemble des "
"caractères Unicode. Cette option n'a de sens que pour des motifs Unicode, "
"elle est ignorée pour les motifs *bytes*."

#: ../Doc/howto/regex.rst:638
msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag "
"also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"Cette option vous permet d'écrire des expressions régulières plus lisibles "
"en vous permettant plus de flexibilité pour le formatage. Lorsque cette "
"option est activée, les \"blancs\" dans la chaîne RE sont ignorés, sauf "
"lorsque le \"blanc\" se trouve dans une classe de caractères ou est précédé "
"d'une barre oblique inverse ; ceci vous permet d'organiser et d'indenter vos "
"RE plus clairement. Cette option vous permet également de placer des "
"commentaires dans une RE, ils seront ignorés par le moteur ; les "
"commentaires commencent par un ``'#'`` qui n'est ni dans une classe de "
"caractères, ni précédé d'une barre oblique inverse."

#: ../Doc/howto/regex.rst:647
msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr ""
"Par exemple, voici une RE qui utilise :const:`re.VERBOSE` ; vous pouvez "
"constater qu'elle est beaucoup plus facile à lire ::"

#: ../Doc/howto/regex.rst:660
msgid "Without the verbose setting, the RE would look like this::"
msgstr "Sans l'option verbeuse, cette RE ressemble à ceci ::"

#: ../Doc/howto/regex.rst:666
msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"Dans l'exemple ci-dessus, Python concatène automatiquement les littéraux "
"chaînes de caractères qui ont été utilisés pour séparer la RE en petits "
"morceaux, mais la RE reste plus difficile à comprendre que sa version "
"utilisant :const:`re.VERBOSE`."

#: ../Doc/howto/regex.rst:672
msgid "More Pattern Power"
msgstr "Des motifs plus puissants"

#: ../Doc/howto/regex.rst:674
msgid ""
"So far we've only covered a part of the features of regular expressions.  In "
"this section, we'll cover some new metacharacters, and how to use groups to "
"retrieve portions of the text that was matched."
msgstr ""
"Jusqu'à présent nous avons seulement couvert une partie des fonctionnalités "
"des expressions régulières. Dans cette section, nous couvrirons quelques "
"nouveaux métacaractères et l'utilisation des groupes pour récupérer des "
"portions de textes correspondantes."

#: ../Doc/howto/regex.rst:682
msgid "More Metacharacters"
msgstr "Plus de métacaractères"

#: ../Doc/howto/regex.rst:684
msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr ""
"Nous n'avons pas encore couvert tous les métacaractères. Cette section "
"traite de la plupart de ceux que nous n'avons pas abordés."

#: ../Doc/howto/regex.rst:687
msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For "
"example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means "
"that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"Certains métacaractères restants sont des :dfn:`assertions de largeur zéro` "
"(*zero-width assertions* en anglais). Ils ne font pas avancer le moteur dans "
"la chaîne de caractères ; ils ne consomment aucun caractère et ils "
"réussissent ou échouent tout simplement. Par exemple, ``\\b`` est une "
"assertion selon laquelle la position actuelle est située à la limite d'un "
"mot ; la position n'est pas modifiée par le \" \\b \". Cela signifie que les "
"assertions de largeur zéro ne doivent pas être répétées car, si elles "
"correspondent à un endroit donné, elles correspondent automatiquement un "
"nombre infini de fois."

#: ../Doc/howto/regex.rst:703
msgid "``|``"
msgstr "``|``"

#: ../Doc/howto/regex.rst:696
msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either "
"``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""
"Union ensembliste ou opérateur \"ou\". Si *A* et *B* sont des expressions "
"régulières, ``A|B`` correspond à toute chaine qui correspond à A ou à B. La "
"priorité de ``|`` est très faible afin de pouvoir effectuer simplement des "
"unions de chaînes de plusieurs caractères. ``Crow|Servo`` correspond avec "
"``'Crow'`` ou ``'Servo'``, mais pas avec ``'Cro'``, un ``'w'`` ou un "
"``'S'``, ou encore ``'ervo'``."

#: ../Doc/howto/regex.rst:702
msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr ""
"Pour correspondre avec un ``'|'`` littéral, utilisez ``\\|`` ou placez-le "
"dans une classe de caractères, comme ceci ``[|]``."

#: ../Doc/howto/regex.rst:718
msgid "``^``"
msgstr "``^``"

#: ../Doc/howto/regex.rst:706
msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In :const:"
"`MULTILINE` mode, this also matches immediately after each newline within "
"the string."
msgstr ""
"Correspond à un début de ligne. À moins que l'option :const:`MULTILINE` ne "
"soit activée, cela ne fait correspondre que le début de la chaîne. Dans le "
"mode :const:`MULTILINE`, cela fait aussi correspondre immédiatement après "
"chaque nouvelle ligne à l'intérieur de la chaîne."

#: ../Doc/howto/regex.rst:710
msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of "
"a line, the RE to use is ``^From``. ::"
msgstr ""
"Par exemple, si vous voulez trouver le mot ``From`` uniquement quand il est "
"en début de ligne, la RE à utiliser est ``^From``. ::"

#: ../Doc/howto/regex.rst:718
msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "Pour trouver un ``'^'`` littéral, utilisez ``\\^``."

#: ../Doc/howto/regex.rst:732
msgid "``$``"
msgstr "``$``"

#: ../Doc/howto/regex.rst:721
msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr ""
"Correspond à une fin de ligne, ce qui veut dire soit la fin de la chaîne, "
"soit tout emplacement qui est suivi du caractère de nouvelle ligne. ::"

#: ../Doc/howto/regex.rst:731
msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr ""
"Pour trouver un ``'$'`` littéral, utilisez ``\\$`` ou placez-le à "
"l'intérieur d'une classe de caractères, comme ceci ``[$]``."

#: ../Doc/howto/regex.rst:738
msgid "``\\A``"
msgstr "``\\A``"

#: ../Doc/howto/regex.rst:735
msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a "
"newline character."
msgstr ""
"Correspond au début de la chaîne de caractère, uniquement. Si l'option :"
"const:`MULTILINE` n'est pas activée, ``\\A`` et ``^`` sont équivalents. Dans "
"le mode :const:`MULTILINE`, ils sont différents : ``\\A`` ne correspond "
"toujours qu'au début de la chaîne alors que ``^`` correspond aussi aux "
"emplacements situés immédiatement après une nouvelle ligne à l'intérieur de "
"la chaîne."

#: ../Doc/howto/regex.rst:741
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../Doc/howto/regex.rst:741
msgid "Matches only at the end of the string."
msgstr "Correspond uniquement à la fin d'une chaîne de caractères."

#: ../Doc/howto/regex.rst:776
msgid "``\\b``"
msgstr "``\\b``"

#: ../Doc/howto/regex.rst:744
msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric "
"characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr ""
"Limite de mot. C'est une assertion de largeur zéro qui correspond uniquement "
"aux positions de début et de fin de mot. Un mot est défini comme une "
"séquence de caractères alphanumériques ; ainsi, la fin d'un mot est indiquée "
"par un \"blanc\" ou un caractère non-alphanumérique."

#: ../Doc/howto/regex.rst:749
msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr ""
"L'exemple suivant fait correspondre ``class`` seulement si c'est un mot "
"complet ; il n'y a pas de correspondance quand il est à l'intérieur d'un "
"autre mot. ::"

#: ../Doc/howto/regex.rst:760
msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, ``"
"\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our "
"previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"Quand vous utilisez cette séquence spéciale, gardez deux choses à l'esprit. "
"Tout d'abord, c'est la pire collision entre les littéraux des chaînes Python "
"et les séquences d'expressions régulières.  Dans les littéraux de chaîne de "
"caractères Python, ``\\b``` est le caractère de retour-arrière (*backspace* "
"en anglais), dont la valeur ASCII est 8.  Si vous n'utilisez pas les chaînes "
"de caractères brutes, alors Python convertit le ``\\b`` en retour-arrière, "
"et votre RE ne correspond pas à ce que vous attendez. L'exemple suivant "
"ressemble à notre RE précédente, mais nous avons omis le ```'r'`` devant la "
"chaîne RE. ::"

#: ../Doc/howto/regex.rst:774
msgid ""
"Second, inside a character class, where there's no use for this assertion, ``"
"\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr ""
"Ensuite, dans une classe de caractères, où cette assertion n'a pas lieu "
"d'être, ``\\b`` représente le caractère retour-arrière, afin d'être "
"compatible avec les littéraux de chaînes de caractères."

#: ../Doc/howto/regex.rst:781
msgid "``\\B``"
msgstr "``\\B``"

#: ../Doc/howto/regex.rst:779
msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching "
"when the current position is not at a word boundary."
msgstr ""
"Encore une assertion de largeur zéro, qui est l'opposée de ``\\b``, c'est-à-"
"dire qu'elle fait correspondre uniquement les emplacements qui ne sont pas à "
"la limite d'un mot."

#: ../Doc/howto/regex.rst:784
msgid "Grouping"
msgstr "Regroupement"

#: ../Doc/howto/regex.rst:786
msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components "
"of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""
"Souvent, vous avez besoin d'obtenir plus d'informations que le simple fait "
"que la RE corresponde ou non. Ainsi, les expressions régulières sont souvent "
"utilisées pour analyser des chaînes de caractères en écrivant une RE qui "
"divise une chaîne en plusieurs sous-groupes, correspondant chacun à une "
"information particulière. Par exemple, une ligne d'en-tête RFC-822 peut se "
"diviser en un nom d'en-tête et une valeur associée, séparés par un ``':'``, "
"comme ceci :"

#: ../Doc/howto/regex.rst:799
msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr ""
"Vous pouvez alors écrire une expression régulière qui fait correspondre une "
"ligne d'en-tête entière et qui comporte un groupe correspondant au nom de "
"l'en-tête, et un autre groupe correspondant à la valeur de l'en-tête."

#: ../Doc/howto/regex.rst:803
msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a repeating qualifier, such as ``*``, ``"
"+``, ``?``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""
"Les groupes sont délimités par les métacaractères marqueurs ``'('``et "
"``')'``. ``'('`` et ``')'`` ont à peu près le même sens que dans les "
"expressions mathématiques ; ils forment un groupe à partir des expressions "
"qu'ils encadrent ; vous pouvez répéter le contenu d'un groupe à l'aide d'un "
"quantificateur, comme ``*``, ``+``, ``?`` ou ``{m,n}``. Par exemple, "
"``(ab)*`` correspond à zéro, une ou plusieurs fois ``ab``. ::"

#: ../Doc/howto/regex.rst:814
msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re."
"Match.end`, and :meth:`~re.Match.span`.  Groups are numbered starting with "
"0.  Group 0 is always present; it's the whole RE, so :ref:`match object "
"<match-objects>` methods all have group 0 as their default argument.  Later "
"we'll see how to express groups that don't capture the span of text that "
"they match. ::"
msgstr ""
"Les groupes délimités par ``'('``et ``')'`` capturent également les indices "
"de début et de fin du texte avec lequel ils correspondent ; ces indices "
"peuvent être récupérés en passant un argument à :meth:`~re.Match.group`, :"
"meth:`~re.Match.start`, :meth:`~re.Match.end` ou :meth:`~re.Match.span`. Les "
"groupes sont numérotés à partir de 0, le groupe 0 est toujours présent ; "
"c'est l'ensemble de la RE, donc les méthodes de :ref:`l'objet correspondance "
"<match-objects>` ont le groupe 0 comme argument par défaut. Plus loin, nous "
"voyons comment exprimer les groupes qui ne capturent pas l'étendue du texte "
"avec lequel ils correspondent. ::"

#: ../Doc/howto/regex.rst:830
msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"Les sous-groupes sont numérotés de la gauche vers la droite, à partir de 1. "
"Les groupes peuvent être imbriqués ; pour déterminer le numéro, il vous "
"suffit de compter le nombre de parenthèses ouvrantes de la gauche vers la "
"droite. ::"

#: ../Doc/howto/regex.rst:843
msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ""
"Vous pouvez passer plusieurs numéros de groupes à :meth:`~re.Match.group` en "
"même temps, elle vous renvoie alors un *tuple* contenant les valeurs "
"correspondantes pour ces groupes. ::"

#: ../Doc/howto/regex.rst:849
msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ""
"La méthode  :meth:`~re.Match.groups` renvoie un *tuple* contenant les "
"chaînes pour tous les sous-groupes, en commençant par le numéro 1 jusqu'au "
"dernier. ::"

#: ../Doc/howto/regex.rst:855
msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"Les renvois dans un motif vous permettent de spécifier que le contenu d'un "
"groupe précédent doit aussi être trouvé à l'emplacement actuel dans la "
"chaîne. Par exemple, ``\\1`` réussit si le contenu du premier groupe se "
"trouve aussi à la position courante, sinon il échoue. Rappelez-vous que les "
"littéraux de chaînes Python utilisent aussi la barre oblique inverse suivie "
"d'un nombre pour insérer des caractères arbitraires dans une chaîne ; soyez "
"sûr d'utiliser une chaîne brute quand vous faites des renvois dans une RE."

#: ../Doc/howto/regex.rst:863
msgid "For example, the following RE detects doubled words in a string. ::"
msgstr ""
"Par exemple, la RE suivante détecte les mots doublés dans une chaîne. ::"

#: ../Doc/howto/regex.rst:869
msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"Les renvois tels que celui-ci ne sont pas très utiles pour effectuer une "
"simple recherche dans une chaîne --- il n'y a que peu de formats de textes "
"qui répètent des données ainsi --- mais vous verrez bientôt qu'ils sont "
"*très* utiles pour effectuer des substitutions dans les chaînes."

#: ../Doc/howto/regex.rst:875
msgid "Non-capturing and Named Groups"
msgstr "Groupes non de capture et groupes nommés"

#: ../Doc/howto/regex.rst:877
msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"Les RE élaborées peuvent utiliser de nombreux groupes, à la fois pour "
"capturer des sous-chaînes intéressantes ainsi que pour regrouper et "
"structurer la RE elle-même. Dans les RE complexes, il devient difficile de "
"garder la trace des numéros de groupes. Deux caractéristiques aident à "
"résoudre ce problème, toutes deux utilisant la même syntaxe d'extension des "
"expressions régulières. Nous allons donc commencer en examinant cette "
"syntaxe."

#: ../Doc/howto/regex.rst:883
msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with ``"
"\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Les puissantes extensions des expressions régulières de Perl 5 sont "
"réputées. Pour les mettre en œuvre, les développeurs Perl ne pouvaient pas "
"utiliser de nouveaux métacaractères simples ou de nouvelles séquences "
"commençant par ``\\`` sans que les RE Perl ne deviennent trop différentes "
"des RE standards au point de créer de la confusion. S'ils avaient choisi "
"``&`` comme nouveau métacaractère, par exemple, les expressions déjà écrites "
"auraient considéré que ``&`` était un caractère standard et ne l'aurait pas "
"échappé en écrivant ``\\&`` ou ``[&]``."

#: ../Doc/howto/regex.rst:890
msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any "
"compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"La solution adoptée par les développeurs Perl a été d'utiliser ``(?...)`` "
"comme syntaxe d'extension. Placer ``?`` immédiatement après une parenthèse "
"était une erreur de syntaxe, parce que le ``?`` n'a alors rien à répéter. "
"Ainsi, cela n'a pas introduit de problème de compatibilité. Les caractères "
"qui suivent immédiatement le ``?`` indiquent quelle extension est utilisée, "
"donc ``(?=truc)`` est une chose (une assertion positive anticipée) et ``(?:"
"truc)`` est une autre chose (la sous-expression ``truc`` que l'on groupe)."

#: ../Doc/howto/regex.rst:898
msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to "
"Perl's extension syntax.  If the first character after the question mark is "
"a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python gère plusieurs des extensions Perl et rajoute une extension à la "
"syntaxe des extensions Perl. Si le premier caractère après le point "
"d'interrogation est ``P``, cela signifie que c'est une extension spécifique "
"à Python."

#: ../Doc/howto/regex.rst:903
msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr ""
"Après avoir vu la syntaxe générale d'extension des RE, nous pouvons revenir "
"aux fonctionnalités qui simplifient le travail avec les groupes dans des RE "
"complexes."

#: ../Doc/howto/regex.rst:906
msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"Parfois, vous souhaitez utiliser un groupe pour marquer une partie de "
"l'expression régulière mais le contenu de ce groupe ne vous intéresse pas "
"vraiment. Vous pouvez l'indiquer explicitement en utilisant la syntaxe de "
"groupe, mais sans indiquer que vous voulez en capturer le contenu : "
"``(?:...)``, où vous remplacez les ``...`` par n'importe quelle expression "
"régulière. ::"

#: ../Doc/howto/regex.rst:918
msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"À part le fait que vous n'avez pas accès au contenu du groupe, un groupe se "
"comporte exactement de la même manière qu'un groupe de capture ; vous pouvez "
"placer n'importe quoi dedans, spécifier une répétition avec un métacaractère "
"tel que ``*`` et l'imbriquer dans un autre groupe (de capture ou pas). "
"``(?:...)`` est particulièrement utile quand vous modifiez des motifs "
"existants, puisque vous pouvez ajouter de nouveaux groupes sans changer la "
"façon dont les autres groupes sont numérotés. Nous devons mentionner ici "
"qu'il n'y a aucune différence de performance dans la recherche de groupes, "
"de capture ou non ; les deux formes travaillent à la même vitesse."

#: ../Doc/howto/regex.rst:927
msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr ""
"Une fonctionnalité plus importante est le nommage des groupes : au lieu d'y "
"faire référence par des nombres, vous pouvez référencer des groupes par leur "
"nom."

#: ../Doc/howto/regex.rst:930
msgid ""
"The syntax for a named group is one of the Python-specific extensions: ``(?"
"P<name>...)``.  *name* is, obviously, the name of the group.  Named groups "
"behave exactly like capturing groups, and additionally associate a name with "
"a group.  The :ref:`match object <match-objects>` methods that deal with "
"capturing groups all accept either integers that refer to the group by "
"number or strings that contain the desired group's name.  Named groups are "
"still given numbers, so you can retrieve information about a group in two "
"ways::"
msgstr ""
"La syntaxe pour nommer les groupes est l'une des extensions spécifiques à "
"Python : ``(?P<nom>....)```. *nom* est, vous vous en doutez, le nom du "
"groupe. Les groupes nommés se comportent exactement comme des groupes de "
"capture, sauf qu'ils associent en plus un nom à un groupe. Les méthodes des :"
"ref:`objets correspondances <match-objects>` qui gèrent les groupes de "
"capture acceptent soit des entiers qui font référence aux numéros des "
"groupes, soit des chaînes de caractères qui désignent les noms des groupes "
"désirés. Les groupes nommés se voient toujours attribuer un numéro, vous "
"pouvez ainsi récupérer les informations d'un groupe de deux façons ::"

#: ../Doc/howto/regex.rst:945
msgid ""
"Additionally, you can retrieve named groups as a dictionary with :meth:`~re."
"Match.groupdict`::"
msgstr ""
"De plus, vous pouvez récupérer les groupes nommés comme dictionnaire avec :"
"meth:`~re.Match.groupdict` ::"

#: ../Doc/howto/regex.rst:952
msgid ""
"Named groups are handy because they let you use easily-remembered names, "
"instead of having to remember numbers.  Here's an example RE from the :mod:"
"`imaplib` module::"
msgstr ""
"Les groupes nommés sont pratiques car il est plus facile de se rappeler un "
"nom qu'un numéro. Voici un exemple de RE tirée du module :mod:`imaplib` ::"

#: ../Doc/howto/regex.rst:963
msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr ""
"Il est évidemment plus facile de récupérer ``m.group('zonem')`` que de se "
"rappeler de récupérer le groupe 9."

#: ../Doc/howto/regex.rst:966
msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group "
"name instead of the number. This is another Python extension: ``(?P=name)`` "
"indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as ``\\b(?P<word>\\w+)\\s"
"+(?P=word)\\b``::"
msgstr ""
"La syntaxe des renvois dans une expression telle que ``(....)\\1`` fait "
"référence au numéro du groupe. Il y a naturellement une variante qui utilise "
"le nom du groupe au lieu du numéro. C'est une autre extension Python : ``(?"
"P=nom)`` indique que le contenu du groupe appelé *nom* doit correspondre à "
"nouveau avec l'emplacement courant. L'expression régulière pour trouver des "
"mots doublés, ``\\b(\\w+)\\s+\\1\\b`` peut ainsi être ré-écrite en ``\\b(?"
"P<mot>\\w+)\\s+(?P=mot)\\b`` ::"

#: ../Doc/howto/regex.rst:979
msgid "Lookahead Assertions"
msgstr "Assertions prédictives"

#: ../Doc/howto/regex.rst:981
msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr ""
"Une autre assertion de largeur zéro est l'assertion prédictive. Une "
"assertion prédictive peut s'exprimer sous deux formes, la positive et la "
"négative, comme ceci :"

#: ../Doc/howto/regex.rst:989
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../Doc/howto/regex.rst:985
msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current "
"location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"Assertion prédictive positive. Elle réussit si l'expression régulière "
"contenue, représentée ici par  ``...``, correspond effectivement à "
"l'emplacement courant ; dans le cas contraire, elle échoue. Mais, une fois "
"que l'expression contenue a été essayée, le moteur de correspondance "
"n'avance pas ; le reste du motif est testé à l'endroit même où l'assertion a "
"commencé."

#: ../Doc/howto/regex.rst:994
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../Doc/howto/regex.rst:992
msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr ""
"Assertion prédictive négative. C'est l'opposée de l'assertion positive ; "
"elle réussit si l'expression régulière contenue *ne* correspond *pas* à "
"l'emplacement courant dans la chaine."

#: ../Doc/howto/regex.rst:996
msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base "
"name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"Pour rendre ceci plus concret, regardons le cas où une prédiction est utile. "
"Considérons un motif simple qui doit faire correspondre un nom de fichier et "
"le diviser en un nom de base et une extension, séparés par un ``.``. Par "
"exemple, dans ``news.rc``, ``news`` est le nom de base et ``rc`` est "
"l'extension du nom de fichier."

#: ../Doc/howto/regex.rst:1001
msgid "The pattern to match this is quite simple:"
msgstr "Le motif de correspondance est plutôt simple :"

#: ../Doc/howto/regex.rst:1003
msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

#: ../Doc/howto/regex.rst:1005
msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all "
"the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"Notez que le ``.`` doit être traité spécialement car c'est un métacaractère, "
"nous le plaçons donc à l'intérieur d'une classe de caractères pour ne faire "
"correspondre que ce caractère spécifique. Notez également le ``$`` en fin ; "
"nous l'avons ajouté pour nous assurer que tout le reste de la chaîne est "
"bien inclus dans l'extension. Cette expression régulière fait correspondre "
"``truc.bar``, ``autoexec.bat``, ``sendmail.cf`` et ``printers.conf``."

#: ../Doc/howto/regex.rst:1012
msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr ""
"Maintenant, compliquons un peu le problème ; si nous voulons faire "
"correspondre les noms de fichiers dont l'extension n'est pas ``bat`` ? voici "
"quelques tentatives incorrectes :"

#: ../Doc/howto/regex.rst:1015
msgid ""
"``.*[.][^b].*$``  The first attempt above tries to exclude ``bat`` by "
"requiring that the first character of the extension is not a ``b``.  This is "
"wrong, because the pattern also doesn't match ``foo.bar``."
msgstr ""
"``.*[.][^b].*$`` Le premier essai ci-dessus tente d'exclure ``bat`` en "
"spécifiant que le premier caractère de l'extension ne doit pas être ``b``. "
"Cela ne fonctionne pas, car le motif n'accepte pas ``truc.bar``."

#: ../Doc/howto/regex.rst:1019
msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

#: ../Doc/howto/regex.rst:1021
msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects ``autoexec."
"bat``, but it requires a three-letter extension and won't accept a filename "
"with a two-letter extension such as ``sendmail.cf``.  We'll complicate the "
"pattern again in an effort to fix it."
msgstr ""
"L'expression devient plus confuse si nous essayons de réparer la première "
"solution en spécifiant l'un des cas suivants : le premier caractère de "
"l'extension n'est pas ``b`` ; le deuxième caractère n'est pas ``a`` ; ou le "
"troisième caractère n'est pas ``t```. Ce motif accepte ``truc.bar`` et "
"rejette ``autoexec.bat``, mais elle nécessite une extension de trois lettres "
"et n'accepte pas un nom de fichier avec une extension de deux lettres comme "
"``sendmail.cf``. Compliquons encore une fois le motif pour essayer de le "
"réparer."

#: ../Doc/howto/regex.rst:1029
msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

#: ../Doc/howto/regex.rst:1031
msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr ""
"Pour cette troisième tentative, les deuxième et troisième lettres sont "
"devenues facultatives afin de permettre la correspondance avec des "
"extensions plus courtes que trois caractères, comme ``sendmail.cf``."

#: ../Doc/howto/regex.rst:1035
msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"Le motif devient vraiment compliqué maintenant, ce qui le rend difficile à "
"lire et à comprendre. Pire, si le problème change et que vous voulez exclure "
"à la fois ``bat`` et ``exe`` en tant qu'extensions, le modèle deviendra "
"encore plus compliqué et confus."

#: ../Doc/howto/regex.rst:1040
msgid "A negative lookahead cuts through all this confusion:"
msgstr "Une assertion prédictive négative supprime toute cette confusion :"

#: ../Doc/howto/regex.rst:1042
msgid ""
"``.*[.](?!bat$)[^.]*$``  The negative lookahead means: if the expression "
"``bat`` doesn't match at this point, try the rest of the pattern; if ``bat"
"$`` does match, the whole pattern will fail.  The trailing ``$`` is required "
"to ensure that something like ``sample.batch``, where the extension only "
"starts with ``bat``, will be allowed.  The ``[^.]*`` makes sure that the "
"pattern works when there are multiple dots in the filename."
msgstr ""
"``.*[.](?!bat$)[^.]*$`` Cette assertion prédictive négative signifie : si "
"l'expression ``bat`` ne correspond pas à cet emplacement, essaie le reste du "
"motif ; si ``bat$`` correspond, tout le motif échoue. Le ``$`` est "
"nécessaire pour s'assurer que quelque chose comme ``sample.batch``, où c'est "
"seulement le début de l'extension qui vaut ``bat``, est autorisé. Le "
"``[^...]*`` s'assure que le motif fonctionne lorsqu'il y a plusieurs points "
"dans le nom de fichier."

#: ../Doc/howto/regex.rst:1049
msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr ""
"Exclure une autre extension de nom de fichier est maintenant facile ; il "
"suffit de l'ajouter comme alternative à l'intérieur de l'assertion. Le motif "
"suivant exclut les noms de fichiers qui se terminent par ``bat`` ou ``exe`` :"

#: ../Doc/howto/regex.rst:1053
msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

#: ../Doc/howto/regex.rst:1057
msgid "Modifying Strings"
msgstr "Modification de chaînes"

#: ../Doc/howto/regex.rst:1059
msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr ""
"Jusqu'à présent, nous avons simplement effectué des recherches dans une "
"chaîne statique. Les expressions régulières sont aussi couramment utilisées "
"pour modifier les chaînes de caractères de diverses manières, en utilisant "
"les méthodes suivantes des motifs :"

#: ../Doc/howto/regex.rst:1066
msgid "``split()``"
msgstr "``split()``"

#: ../Doc/howto/regex.rst:1066
msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr ""
"Découpe la chaîne de caractère en liste, la découpant partout où la RE "
"correspond"

#: ../Doc/howto/regex.rst:1069
msgid "``sub()``"
msgstr "``sub()``"

#: ../Doc/howto/regex.rst:1069
msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr ""
"Recherche toutes les sous-chaînes de caractères où la RE correspond et les "
"substitue par une chaîne de caractères différente"

#: ../Doc/howto/regex.rst:1072
msgid "``subn()``"
msgstr "``subn()``"

#: ../Doc/howto/regex.rst:1072
msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr ""
"Fait la même chose que :meth:`!sub`,  mais renvoie la nouvelle chaîne et le "
"nombre de remplacements effectués"

#: ../Doc/howto/regex.rst:1079
msgid "Splitting Strings"
msgstr "Découpage de chaînes"

#: ../Doc/howto/regex.rst:1081
msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to "
"the :meth:`~str.split` method of strings but provides much more generality "
"in the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""
"La méthode :meth:`~re.Pattern.Pattern.split` d'un motif divise une chaîne de "
"caractères à chaque fois que la RE correspond, retournant la liste des "
"morceaux. C'est similaire à la méthode :meth:`~str.split` mais est beaucoup "
"plus générale par les délimiteurs que vous pouvez spécifier ; la méthode  :"
"meth:`!split` du type *string* ne gère que les découpages en suivant les "
"\"blancs\" ou suivant une chaîne définie. Comme vous pouvez vous y attendre, "
"il y a aussi une fonction :func:`re.split` de niveau module."

#: ../Doc/howto/regex.rst:1092
msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as "
"part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"Découpe *string* en suivant les correspondances de l'expression régulière. "
"Si des parenthèses de capture sont utilisées dans la RE, leur contenu est "
"également renvoyé dans la liste résultante. Si *maxsplit* n'est pas nul, au "
"plus *maxsplit* découpages sont effectués."

#: ../Doc/howto/regex.rst:1097
msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"Vous pouvez limiter le nombre de découpages effectués en passant une valeur "
"pour *maxsplit*. Quand *maxsplit* n'est pas nul, au plus *maxsplit* "
"découpages sont effectués et le reste de la chaîne est renvoyé comme dernier "
"élément de la liste. Dans l'exemple suivant, le délimiteur est toute "
"séquence de caractères non alphanumériques. ::"

#: ../Doc/howto/regex.rst:1109
msgid ""
"Sometimes you're not only interested in what the text between delimiters is, "
"but also need to know what the delimiter was.  If capturing parentheses are "
"used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"Parfois, vous voulez récupérer le texte entre les délimiteurs mais aussi "
"quel était le délimiteur. Si des parenthèses de capture sont utilisées dans "
"la RE, leurs valeurs sont également renvoyées dans la liste. Comparons les "
"appels suivants ::"

#: ../Doc/howto/regex.rst:1121
msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr ""
"La fonction de niveau module :func:`re.split` ajoute la RE à utiliser comme "
"premier argument, mais est par ailleurs identique. ::"

#: ../Doc/howto/regex.rst:1133
msgid "Search and Replace"
msgstr "Recherche et substitution"

#: ../Doc/howto/regex.rst:1135
msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"Une autre tâche classique est de trouver toutes les correspondances d'un "
"motif et de les remplacer par une autre chaîne. La méthode :meth:`~re."
"Pattern.sub` prend une valeur de substitution, qui peut être une chaîne de "
"caractères ou une fonction, et la chaîne à traiter."

#: ../Doc/howto/regex.rst:1142
msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"Renvoie la chaîne obtenue en remplaçant les occurrences sans chevauchement "
"les plus à gauche de la RE dans *string* par la substitution *replacement*. "
"Si le motif n'est pas trouvé, *string* est renvoyée inchangée."

#: ../Doc/howto/regex.rst:1146
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr ""
"L'argument optionnel *count* est le nombre maximum d'occurrences du motif à "
"remplacer ; *count* doit être un entier positif ou nul. La valeur par défaut "
"de 0 signifie qu'il faut remplacer toutes les occurrences."

#: ../Doc/howto/regex.rst:1150
msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""
"Voici un exemple simple utilisant la méthode :meth:`~re.Pattern.sub`. Nous "
"remplaçons les noms des couleurs par le mot ``colour`` ::"

#: ../Doc/howto/regex.rst:1159
msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a 2-"
"tuple containing the new string value and the number of replacements  that "
"were performed::"
msgstr ""
"La méthode :meth:`~re.Pattern.subn.subn` fait la même chose mais renvoie un "
"couple contenant la nouvelle valeur de la chaîne de caractères et le nombre "
"de remplacements effectués ::"

#: ../Doc/howto/regex.rst:1168
msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr ""
"Les correspondances vides ne sont remplacées que lorsqu'elles ne sont pas "
"adjacentes à une correspondance vide précédente. ::"

#: ../Doc/howto/regex.rst:1175
msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as ``"
"\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with the "
"substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"Si *replacement* est une chaîne de caractères, toute barre oblique inverse "
"d'échappement est traitée.  C'est-à-dire que ```\\n`` est converti en "
"caractère de nouvelle ligne, ``\\r`` est converti en retour chariot, et "
"ainsi de suite. Les échappements inconnus comme ``\\&`` sont laissés tels "
"quels. Les renvois, tels que ``\\6``, sont remplacés par la sous-chaîne "
"correspondante au groupe dans le RE. Ceci vous permet d'incorporer des "
"parties du texte original dans la chaîne de remplacement résultante."

#: ../Doc/howto/regex.rst:1182
msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"Cet exemple fait correspondre le mot ``section`` suivi par une chaîne "
"encadrée par  ``{`` et ``}``, et modifie ``section`` en ``subsection`` ::"

#: ../Doc/howto/regex.rst:1189
msgid ""
"There's also a syntax for referring to named groups as defined by the ``(?"
"P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by the "
"group named ``name``, and  ``\\g<number>``  uses the corresponding group "
"number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous "
"in a replacement string such as ``\\g<2>0``.  (``\\20`` would be interpreted "
"as a reference to group 20, not a reference to group 2 followed by the "
"literal character ``'0'``.)  The following substitutions are all equivalent, "
"but use all three variations of the replacement string. ::"
msgstr ""
"Il existe aussi une syntaxe pour faire référence aux groupes nommés définis "
"par la syntaxe ``(?P<nom>....)``. ``\\g<nom>`` utilise la sous-chaîne "
"correspondante au groupe nommé ``nom`` et ``\\g<numéro>`` utilise le numéro "
"de groupe correspondant. ``\\g<2>`` est donc l'équivalent de ``\\2``, mais "
"n'est pas ambigu dans une chaîne de substitution telle que ``\\g<2>0`` (``"
"\\20`` serait interprété comme une référence au groupe 20 et non comme une "
"référence au groupe 2 suivie du caractère littéral ``'0'``). Les "
"substitutions suivantes sont toutes équivalentes mais utilisent les trois "
"variantes de la chaîne de remplacement. ::"

#: ../Doc/howto/regex.rst:1206
msgid ""
"*replacement* can also be a function, which gives you even more control.  If "
"*replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed "
"a :ref:`match object <match-objects>` argument for the match and can use "
"this information to compute the desired replacement string and return it."
msgstr ""
"*replacement* peut aussi être une fonction, ce qui vous donne encore plus de "
"contrôle. Si *replacement* est une fonction, la fonction est appelée pour "
"chaque occurrence non chevauchante de *pattern*. À chaque appel, un "
"argument :ref:`objet correspondance <match-objects>` est passé à la "
"fonction, qui peut utiliser cette information pour calculer la chaîne de "
"remplacement désirée et la renvoyer."

#: ../Doc/howto/regex.rst:1212
msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr ""
"Dans l'exemple suivant, la fonction de substitution convertit un nombre "
"décimal en hexadécimal ::"

#: ../Doc/howto/regex.rst:1224
msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use "
"a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"Quand vous utilisez la fonction de niveau module :func:`re.sub`, le motif "
"est passé comme premier argument. Vous pouvez fournir le motif sous forme "
"d'objet ou de chaîne de caractères ; si vous avez besoin de spécifier des "
"options pour l'expression régulière, vous devez soit utiliser un objet motif "
"comme premier paramètre, soit utiliser des modificateurs intégrés dans la "
"chaîne de caractères, par exemple ``sub(\"(?i)b+\", \"x\", \"bbbb BBBBB"
"\")```renvoie ``'x x'``."

#: ../Doc/howto/regex.rst:1232
msgid "Common Problems"
msgstr "Problèmes classiques"

#: ../Doc/howto/regex.rst:1234
msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common "
"pitfalls."
msgstr ""
"Les expressions régulières constituent un outil puissant pour certaines "
"applications mais, à certains égards, leur comportement n'est pas intuitif "
"et, parfois, elles ne se comportent pas comme vous pouvez vous y attendre.  "
"Cette section met en évidence certains des pièges les plus courants."

#: ../Doc/howto/regex.rst:1240
msgid "Use String Methods"
msgstr "Utilisez les méthodes du type *string*"

#: ../Doc/howto/regex.rst:1242
msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any :mod:"
"`re` features such as the :const:`~re.IGNORECASE` flag, then the full power "
"of regular expressions may not be required. Strings have several methods for "
"performing operations with fixed strings and they're usually much faster, "
"because the implementation is a single small C loop that's been optimized "
"for the purpose, instead of the large, more generalized regular expression "
"engine."
msgstr ""
"Parfois, il ne faut pas utiliser le module :mod:`re`. Si vous faites "
"correspondre une chaîne fixe, ou une classe à un seul caractère, et que vous "
"n'utilisez pas les fonctionnalités de :mod:`re` telles que l'option :const:"
"`~re.IGNORECASE`, alors la puissance des expressions régulières n'est pas "
"nécessaire. Les chaînes de caractères ont plusieurs méthodes pour opérer sur "
"des chaînes fixes et elles sont généralement beaucoup plus rapides, parce "
"que l'implémentation est une seule petite boucle C qui a été optimisée, au "
"lieu du gros moteur d'expressions régulières plus généraliste."

#: ../Doc/howto/regex.rst:1250
msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words, "
"turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that "
"``word`` have a word boundary on either side.  This takes the job beyond  :"
"meth:`!replace`'s abilities.)"
msgstr ""
"Nous pouvons prendre l'exemple du remplacement d'une seule chaîne fixe par "
"une autre ; vous souhaitez remplacer ``mot`` par ``acte``. :func:`re.sub` "
"semble être faite pour cela, mais regardons la méthode :meth:`~str.replace`. "
"Notons que :meth:`!replace` remplace aussi ``mot`` à l'intérieur des mots, "
"transformant ``moteur`` en ``acteeur``, mais la RE naïve ``mot`` aurait "
"aussi fait cela (pour éviter d'effectuer la substitution sur des parties de "
"mots, le motif doit être ``\\bmot\\b``, qui exige que ``mot`` soit en limite "
"de mot d'un côté et de l'autre ; c'est au-delà des capacités de la méthode :"
"meth:`!replace`)."

#: ../Doc/howto/regex.rst:1259
msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is "
"capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""
"Une autre tâche classique est de supprimer chaque occurrence d'un seul "
"caractère d'une chaîne de caractères ou de le remplacer par un autre "
"caractère unique. Vous pouvez le faire avec quelque chose comme ``re."
"sub('\\n', ' ', S)``, mais :meth:`~str.translate` en est capable et est plus "
"rapide que n'importe quelle opération d'expression régulière."

#: ../Doc/howto/regex.rst:1265
msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr ""
"Bref, avant de passer au module :mod:`re`, évaluez d'abord si votre problème "
"peut être résolu avec une méthode de chaîne plus rapide et plus simple."

#: ../Doc/howto/regex.rst:1270
msgid "match() versus search()"
msgstr "*match()* contre *search()*"

#: ../Doc/howto/regex.rst:1272
msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""
"La fonction :func:`~re.match` vérifie seulement si la RE correspond au début "
"de la chaîne de caractères tandis que :func:`~re.search` parcourt la chaîne "
"de caractères pour trouver une correspondance. Il est important de garder "
"cette distinction à l'esprit. Rappelez-vous, :func:`!match` ne trouve qu'une "
"correspondance qui commence à 0 ; si la correspondance commence plus loin, :"
"func:`!match` *ne la trouve pas*. ::"

#: ../Doc/howto/regex.rst:1283
msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr ""
"D'un autre côté, :func:`~re.search` balaie la chaîne de caractères, "
"rapportant la première correspondance qu'elle trouve. ::"

#: ../Doc/howto/regex.rst:1291
msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add ``."
"*`` to the front of your RE.  Resist this temptation and use :func:`re."
"search` instead.  The regular expression compiler does some analysis of REs "
"in order to speed up the process of looking for a match.  One such analysis "
"figures out what the first character of a match must be; for example, a "
"pattern starting with ``Crow`` must match starting with a ``'C'``.  The "
"analysis lets the engine quickly scan through the string looking for the "
"starting character, only trying the full match if a ``'C'`` is found."
msgstr ""
"Vous pouvez être tenté d'utiliser :func:`re.match` en ajoutant simplement ``."
"*`` au début de votre RE. Ce n'est pas une bonne idée, utilisez plutôt :func:"
"`re.search`. Le compilateur d'expressions régulières analyse les REs pour "
"optimiser le processus de recherche d'une correspondance. Cette analyse "
"permet de déterminer ce que doit être le premier caractère d'une "
"correspondance ; par exemple, un motif commençant par ``Corbeau`` doit faire "
"correspondre un ``'C'`` en tête. L'analyse permet au moteur de parcourir "
"rapidement la chaîne de caractères à la recherche du caractère de départ, "
"n'essayant la correspondance complète que si un \"C\" a déjà été trouvé."

#: ../Doc/howto/regex.rst:1300
msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"Ajouter ``.*`` annihile cette optimisation, nécessitant un balayage jusqu'à "
"la fin de la chaîne de caractères, puis un retour en arrière pour trouver "
"une correspondance pour le reste de la RE. Préférez l'utilisation :func:`re."
"search`."

#: ../Doc/howto/regex.rst:1306
msgid "Greedy versus Non-Greedy"
msgstr "Glouton contre non-glouton"

#: ../Doc/howto/regex.rst:1308
msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle "
"brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"Si vous répétez un motif dans une expression régulière, comme ``a*``, "
"l'action résultante est de consommer autant de motifs que possible. C'est un "
"problème lorsque vous essayez de faire correspondre une paire de "
"délimiteurs, comme des chevrons encadrant une balise HTML. Le motif naïf "
"pour faire correspondre une seule balise HTML ne fonctionne pas en raison de "
"la nature gloutonne de ``.*``. ::"

#: ../Doc/howto/regex.rst:1322
msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest "
"of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""
"La RE correspond au ``'<'`` de ``'<html>'`` et le ``.*``` consomme le reste "
"de la chaîne. Mais, comme il reste des éléments du motif dans la RE et que "
"le ``>`` ne peut pas correspondre à la fin de la chaîne de caractères, le "
"moteur d'expression régulière doit faire marche arrière caractère par "
"caractère jusqu'à ce qu'il trouve une correspondance pour le ``>``.  La "
"correspondance finale s'étend du ``'<'`` de ``'<html>'`` au ``'>'`` de ``'</"
"title>'``, ce qui n'est pas ce que vous voulez."

#: ../Doc/howto/regex.rst:1329
msgid ""
"In this case, the solution is to use the non-greedy qualifiers ``*?``, ``+?"
"``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In the "
"above example, the ``'>'`` is tried immediately after the first ``'<'`` "
"matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""
"Dans ce cas, la solution consiste à utiliser des quantificateurs non "
"gloutons tels que ``*?``, ``+?``, ``??`` ou ``{m,n}?``, qui effectuent une "
"correspondance aussi *petite* que possible. Dans l'exemple ci-dessus, le "
"``'>'`` est essayé immédiatement après que le ``'<'`` corresponde et, s'il "
"échoue, le moteur avance caractère par caractère, ré-essayant ``'>'`` à "
"chaque pas. Nous obtenons alors le bon résultat ::"

#: ../Doc/howto/regex.rst:1338
msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"Note : l'analyse du HTML ou du XML avec des expressions régulières est tout "
"sauf une sinécure. Les motifs écrits à la va-vite traiteront les cas "
"communs, mais HTML et XML ont des cas spéciaux qui font planter l'expression "
"régulière évidente ; quand vous aurez écrit une expression régulière qui "
"traite tous les cas possibles, les motifs seront *très* compliqués.  "
"Utilisez un module d'analyse HTML ou XML pour de telles tâches."

#: ../Doc/howto/regex.rst:1346
msgid "Using re.VERBOSE"
msgstr "Utilisez *re.VERBOSE*"

#: ../Doc/howto/regex.rst:1348
msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can "
"become lengthy collections of backslashes, parentheses, and metacharacters, "
"making them difficult to read and understand."
msgstr ""
"À présent, vous vous êtes rendu compte que les expressions régulières sont "
"une notation très compacte, mais qu'elles ne sont pas très lisibles. Une RE "
"modérément complexe  peut rapidement devenir une longue collection de barres "
"obliques inverses, de parenthèses et de métacaractères, ce qui la rend "
"difficile à lire et à comprendre."

#: ../Doc/howto/regex.rst:1353
msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""
"Pour de telles RE, activer l'option :const:`re.VERBOSE` à la compilation de "
"l'expression régulière peut être utile ; cela vous permet de formater "
"l'expression régulière de manière plus claire."

#: ../Doc/howto/regex.rst:1357
msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``, "
"or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"L'option ``re.VERBOSE`` a plusieurs effets. Les espaces dans l'expression "
"régulière qui *ne sont pas* à l'intérieur d'une classe de caractères sont "
"ignorées. Cela signifie qu'une expression comme ``chien | chat`` est "
"équivalente à ``chien|chat`` qui est moins lisible, mais ``[a b]`` "
"correspond toujours aux caractères ``'a'``, ``'b'`` ou à une espace. En "
"outre, vous avez la possibilité de mettre des commentaires à l'intérieur "
"d'une RE ; les commentaires s'étendent du caractère ``#`` à la nouvelle "
"ligne suivante. Lorsque vous l'utilisez avec des chaînes à triple "
"guillemets, cela permet aux RE d'être formatées plus proprement ::"

#: ../Doc/howto/regex.rst:1374
msgid "This is far more readable than::"
msgstr "Ceci est beaucoup plus lisible que ::"

#: ../Doc/howto/regex.rst:1380
msgid "Feedback"
msgstr "Vos commentaires"

#: ../Doc/howto/regex.rst:1382
msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"Les expressions régulières sont un sujet compliqué. Est-ce que ce document "
"vous a aidé à les comprendre ? Des parties ne sont pas claires, ou des "
"problèmes que vous avez rencontrés ne sont pas traités ici ? Si tel est le "
"cas, merci d'envoyer vos suggestions d'améliorations à l'auteur."

#: ../Doc/howto/regex.rst:1387
msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
"Le livre le plus complet sur les expressions régulières est certainement "
"Mastering Regular Expressions de Jeffrey Friedl, publié par O'Reilly. "
"Malheureusement, il se concentre sur les déclinaisons Perl et Java des "
"expressions régulières et ne contient aucun contenu pour Python ; il n'est "
"donc pas utile d'en faire référence pour la programmation Python. (La "
"première édition traitait du module Python :mod:`!regex`, maintenant "
"supprimé, ce qui ne vous aidera pas beaucoup.) Pensez à le retirer de votre "
"bibliothèque."
