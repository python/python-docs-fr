# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2022-10-18 12:29+0200\n"
"Last-Translator: Mindiell <mindiell@mindiell.net>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.1\n"

#: howto/clinic.rst:8
msgid "Argument Clinic How-To"
msgstr "Guide Argument Clinic"

#: howto/clinic.rst:13
msgid ""
"The Argument Clinic How-TO has been moved to the `Python Developer's Guide "
"<https://devguide.python.org/development-tools/clinic/>`__."
msgstr ""

#~ msgid "author"
#~ msgstr "auteur"

#~ msgid "Larry Hastings"
#~ msgstr "Larry Hastings"

#~ msgid "Abstract"
#~ msgstr "Résumé"

#, fuzzy
#~ msgid ""
#~ "Argument Clinic is a preprocessor for CPython C files. Its purpose is to "
#~ "automate all the boilerplate involved with writing argument parsing code "
#~ "for \"builtins\", module level functions, and class methods. This "
#~ "document is divided in three major sections:"
#~ msgstr ""
#~ "Argument Clinic est un préprocesseur pour les fichiers C de CPython. Il "
#~ "permet d'automatiser les tâches répétitives lors de la rédaction du code "
#~ "d'analyse d'arguments pour les modules natifs.  Ce document vous montre "
#~ "comment convertir votre première fonction C de façon à ce qu'elle "
#~ "fonctionne avec Argument Clinic, avant d'introduire des usages plus "
#~ "avancés d'Argument Clinic."

#, fuzzy
#~ msgid ""
#~ "Argument Clinic is considered internal-only for CPython.  Its use is not "
#~ "supported for files outside CPython, and no guarantees are made regarding "
#~ "backwards compatibility for future versions.  In other words: if you "
#~ "maintain an external C extension for CPython, you're welcome to "
#~ "experiment with Argument Clinic in your own code.  But the version of "
#~ "Argument Clinic that ships with the next version of CPython *could* be "
#~ "totally incompatible and break all your code."
#~ msgstr ""
#~ "Argument Clinic est pour le moment considéré comme un outil interne à "
#~ "CPython.  Il n'est pas conçu pour gérer des fichiers à l'extérieur de "
#~ "CPython, et sa compatibilité ascendante n'est pas garantie pour les "
#~ "versions futures. En d'autres termes, si vous êtes mainteneur d'une "
#~ "extension C pour CPython, vous pouvez bien sûr expérimenter avec Argument "
#~ "Clinic sur votre propre code. Mais la version d'Argument Clinic livrée "
#~ "avec la prochaine version de CPython *pourrait* être totalement "
#~ "incompatible et casser tout votre code."

#, fuzzy
#~ msgid "The goals of Argument Clinic"
#~ msgstr "Les objectifs d'Argument Clinic"

#~ msgid ""
#~ "Argument Clinic's primary goal is to take over responsibility for all "
#~ "argument parsing code inside CPython.  This means that, when you convert "
#~ "a function to work with Argument Clinic, that function should no longer "
#~ "do any of its own argument parsing—the code generated by Argument Clinic "
#~ "should be a \"black box\" to you, where CPython calls in at the top, and "
#~ "your code gets called at the bottom, with ``PyObject *args`` (and maybe "
#~ "``PyObject *kwargs``) magically converted into the C variables and types "
#~ "you need."
#~ msgstr ""
#~ "Le premier objectif d'Argument Clinic est de prendre en charge toute "
#~ "l'analyse d'arguments à l'intérieur de CPython. Cela signifie que si vous "
#~ "convertissez une fonction pour utiliser Argument Clinic, cette fonction "
#~ "n'a plus du tout besoin d'analyser ses propres arguments. Le code généré "
#~ "par Argument Clinic doit être une « boîte noire » avec en entrée l'appel "
#~ "de CPython, et en sortie l'appel à votre code. Entre les deux, ``PyObject "
#~ "*args`` (et éventuellement ``PyObject *kwargs``) sont convertis "
#~ "magiquement dans les variables et types C dont vous avez besoin."

#~ msgid ""
#~ "In order for Argument Clinic to accomplish its primary goal, it must be "
#~ "easy to use.  Currently, working with CPython's argument parsing library "
#~ "is a chore, requiring maintaining redundant information in a surprising "
#~ "number of places. When you use Argument Clinic, you don't have to repeat "
#~ "yourself."
#~ msgstr ""
#~ "Pour que le premier objectif d'Argument Clinic soit atteint, il faut "
#~ "qu'il soit facile à utiliser. Actuellement, travailler avec la "
#~ "bibliothèque d'analyse d'arguments de CPython est une corvée. Il faut "
#~ "maintenir une quantité surprenante d'informations redondantes. En "
#~ "utilisant Argument Clinic, il n'est plus nécessaire de se répéter."

#~ msgid ""
#~ "Obviously, no one would want to use Argument Clinic unless it's solving "
#~ "their problem—and without creating new problems of its own. So it's "
#~ "paramount that Argument Clinic generate correct code. It'd be nice if the "
#~ "code was faster, too, but at the very least it should not introduce a "
#~ "major speed regression.  (Eventually Argument Clinic *should* make a "
#~ "major speedup possible—we could rewrite its code generator to produce "
#~ "tailor-made argument parsing code, rather than calling the general-"
#~ "purpose CPython argument parsing library.  That would make for the "
#~ "fastest argument parsing possible!)"
#~ msgstr ""
#~ "Certainement, personne ne voudrait utiliser Argument Clinic s'il ne "
#~ "réglait pas son problème sans en créer de nouveaux. Il est donc de la "
#~ "première importance qu'Argument Clinic génère du code correct. Il est "
#~ "aussi souhaitable que le code soit aussi plus rapide. Au minimum, il ne "
#~ "doit pas introduire de régression significative sur la vitesse "
#~ "d'exécution. (Au bout du compte, Argument Clinic *devrait* permettre une "
#~ "accélération importante, on pourrait ré-écrire son générateur de code "
#~ "pour produire du code d'analyse d'arguments adapté au mieux, plutôt que "
#~ "d'utiliser la bibliothèque d'analyse d'arguments générique. On aurait "
#~ "ainsi l'analyse d'arguments la plus rapide possible !)"

#~ msgid ""
#~ "Additionally, Argument Clinic must be flexible enough to work with any "
#~ "approach to argument parsing.  Python has some functions with some very "
#~ "strange parsing behaviors; Argument Clinic's goal is to support all of "
#~ "them."
#~ msgstr ""
#~ "De plus, Argument Clinic doit être suffisamment flexible pour "
#~ "s'accommoder d'approches différentes de l'analyse d'arguments. Il y a des "
#~ "fonctions dans Python dont le traitement des arguments est très étrange ; "
#~ "le but d'Argument Clinic est de les gérer toutes."

#~ msgid ""
#~ "Finally, the original motivation for Argument Clinic was to provide "
#~ "introspection \"signatures\" for CPython builtins. It used to be, the "
#~ "introspection query functions would throw an exception if you passed in a "
#~ "builtin.  With Argument Clinic, that's a thing of the past!"
#~ msgstr ""
#~ "Finalement, la motivation première d'Argument Clinic était de fournir des "
#~ "« signatures » pour l'introspection des composants natifs de CPython. "
#~ "Précédemment, les fonctions d'introspection levaient une exception si "
#~ "vous passiez un composant natif. Grâce à Argument Clinic, ce comportement "
#~ "appartient au passé !"

#~ msgid ""
#~ "One idea you should keep in mind, as you work with Argument Clinic: the "
#~ "more information you give it, the better job it'll be able to do. "
#~ "Argument Clinic is admittedly relatively simple right now.  But as it "
#~ "evolves it will get more sophisticated, and it should be able to do many "
#~ "interesting and smart things with all the information you give it."
#~ msgstr ""
#~ "En travaillant avec Argument Clinic, il faut garder à l'esprit que plus "
#~ "vous lui donnez de détails, meilleur sera son boulot. Argument Clinic est "
#~ "bien sûr assez simple pour le moment. Mais à mesure qu'il évoluera et "
#~ "deviendra plus sophistiqué, il sera capable de faire beaucoup de choses "
#~ "intéressantes et intelligentes à partir de l'information à sa disposition."

#, fuzzy
#~ msgid "Basic concepts and usage"
#~ msgstr "Concepts de base et utilisation"

#~ msgid ""
#~ "Argument Clinic ships with CPython; you'll find it in ``Tools/clinic/"
#~ "clinic.py``. If you run that script, specifying a C file as an argument:"
#~ msgstr ""
#~ "Argument Clinic est livré avec CPython ; vous le trouverez dans ``Tools/"
#~ "clinic/clinic.py``. Si vous exécutez ce script, en spécifiant un fichier "
#~ "C comme argument :"

#~ msgid ""
#~ "Argument Clinic will scan over the file looking for lines that look "
#~ "exactly like this:"
#~ msgstr "Argument Clinic va parcourir le fichier en cherchant cette ligne :"

#~ msgid ""
#~ "When it finds one, it reads everything up to a line that looks exactly "
#~ "like this:"
#~ msgstr ""
#~ "Lorsqu'il en trouve une, il lit tout ce qui suit, jusqu'à cette ligne :"

#~ msgid ""
#~ "Everything in between these two lines is input for Argument Clinic. All "
#~ "of these lines, including the beginning and ending comment lines, are "
#~ "collectively called an Argument Clinic \"block\"."
#~ msgstr ""
#~ "Tout ce qui se trouve entre ces deux lignes est une entrée pour Argument "
#~ "Clinic. Toutes ces lignes, en incluant les commentaires de début et de "
#~ "fin, sont appelées collectivement un « bloc » d'Argument Clinic."

#~ msgid ""
#~ "When Argument Clinic parses one of these blocks, it generates output.  "
#~ "This output is rewritten into the C file immediately after the block, "
#~ "followed by a comment containing a checksum. The Argument Clinic block "
#~ "now looks like this:"
#~ msgstr ""
#~ "Lorsque *Argument Clinic* analyse l'un de ces blocs, il produit une "
#~ "sortie. Cette sortie est réécrite dans le fichier C immédiatement après "
#~ "le bloc, suivie par un commentaire contenant une somme de contrôle. Le "
#~ "bloc Argument Clinic ressemble maintenant à cela :"

#~ msgid ""
#~ "If you run Argument Clinic on the same file a second time, Argument "
#~ "Clinic will discard the old output and write out the new output with a "
#~ "fresh checksum line.  However, if the input hasn't changed, the output "
#~ "won't change either."
#~ msgstr ""
#~ "Si vous exécutez de nouveau Argument Clinic sur ce même fichier, Argument "
#~ "Clinic supprime la vieille sortie, et écrit la nouvelle sortie avec une "
#~ "ligne de somme de contrôle mise à jour. Cependant, si l'entrée n'a pas "
#~ "changé, la sortie ne change pas non plus."

#~ msgid ""
#~ "You should never modify the output portion of an Argument Clinic block.  "
#~ "Instead, change the input until it produces the output you want.  (That's "
#~ "the purpose of the checksum—to detect if someone changed the output, as "
#~ "these edits would be lost the next time Argument Clinic writes out fresh "
#~ "output.)"
#~ msgstr ""
#~ "Vous ne devez jamais modifier la sortie d'un bloc Argument Clinic. "
#~ "Changez plutôt l'entrée jusqu'à obtenir la sortie souhaitée (c'est "
#~ "précisément le but de la somme de contrôle, détecter si la sortie a été "
#~ "changée. En effet, ces modifications seront perdues après que Argument "
#~ "Clinic a écrit une nouvelle sortie)."

#~ msgid ""
#~ "For the sake of clarity, here's the terminology we'll use with Argument "
#~ "Clinic:"
#~ msgstr "Par souci de clarté, voilà la terminologie que nous emploierons :"

#~ msgid ""
#~ "The first line of the comment (``/*[clinic input]``) is the *start line*."
#~ msgstr ""
#~ "La première ligne du commentaire (``/*[clinic input]``) est la *ligne de "
#~ "début*."

#~ msgid ""
#~ "The last line of the initial comment (``[clinic start generated code]*/"
#~ "``) is the *end line*."
#~ msgstr ""
#~ "La dernière ligne du commentaire initial (``[clinic start generated "
#~ "code]*/``) est la *ligne de fin*."

#~ msgid ""
#~ "The last line (``/*[clinic end generated code: checksum=...]*/``) is the "
#~ "*checksum line*."
#~ msgstr ""
#~ "La dernière ligne (``/*[clinic end generated code: checksum=...]*/``) est "
#~ "la *ligne de contrôle*."

#~ msgid "In between the start line and the end line is the *input*."
#~ msgstr ""
#~ "On appelle *entrée* ce qui se trouve entre la ligne de début et la ligne "
#~ "de fin."

#~ msgid "In between the end line and the checksum line is the *output*."
#~ msgstr ""
#~ "Et on appelle *sortie* ce qui se trouve entre la ligne de fin et la ligne "
#~ "de contrôle."

#~ msgid ""
#~ "All the text collectively, from the start line to the checksum line "
#~ "inclusively, is the *block*.  (A block that hasn't been successfully "
#~ "processed by Argument Clinic yet doesn't have output or a checksum line, "
#~ "but it's still considered a block.)"
#~ msgstr ""
#~ "L'ensemble du texte, depuis la ligne de début jusqu'à la ligne de "
#~ "contrôle incluse s'appelle le *bloc*. (Un bloc qui n'a pas encore été "
#~ "traité avec succès par Argument Clinic n'a pas encore de sortie ni de "
#~ "ligne de contrôle mais est quand même considéré comme un bloc)"

#~ msgid ""
#~ "The best way to get a sense of how Argument Clinic works is to convert a "
#~ "function to work with it.  Here, then, are the bare minimum steps you'd "
#~ "need to follow to convert a function to work with Argument Clinic.  Note "
#~ "that for code you plan to check in to CPython, you really should take the "
#~ "conversion farther, using some of the advanced concepts you'll see later "
#~ "on in the document (like \"return converters\" and \"self converters\"). "
#~ "But we'll keep it simple for this walkthrough so you can learn."
#~ msgstr ""
#~ "La meilleure manière de comprendre le fonctionnement d'Argument Clinic "
#~ "est de convertir une fonction. Voici donc les étapes minimales que vous "
#~ "devez suivre pour convertir une fonction de manière à ce qu'elle "
#~ "fonctionne avec Argument Clinic. Remarquez que pour du code que vous "
#~ "comptez inclure dans CPython, vous devrez certainement pousser plus loin "
#~ "la conversion, en utilisant les concepts avancés que nous verrons plus "
#~ "loin dans ce document (comme ``return converters`` et ``self "
#~ "converters``). Mais concentrons nous pour le moment sur les choses "
#~ "simples."

#~ msgid "Let's dive in!"
#~ msgstr "En route !"

#~ msgid ""
#~ "Make sure you're working with a freshly updated checkout of the CPython "
#~ "trunk."
#~ msgstr ""
#~ "Assurez-vous que vous travaillez sur une copie récemment mise à jour du "
#~ "code de CPython."

#~ msgid ""
#~ "Find a Python builtin that calls either :c:func:`PyArg_ParseTuple` or :c:"
#~ "func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted to work "
#~ "with Argument Clinic yet. For my example I'm using ``_pickle.Pickler."
#~ "dump()``."
#~ msgstr ""
#~ "Trouvez une fonction native de Python qui fait appel à :c:func:"
#~ "`PyArg_ParseTuple` ou :c:func:`PyArg_ParseTupleAndKeywords`, et n'a pas "
#~ "encore été convertie par Argument Clinic. Pour cet exemple, j'utilise "
#~ "``_pickle.Pickler.dump()``."

#~ msgid ""
#~ "If the call to the ``PyArg_Parse`` function uses any of the following "
#~ "format units:"
#~ msgstr "Si l'appel à ``PyArg_Parse`` utilise l'un des formats suivants :"

#~ msgid ""
#~ "or if it has multiple calls to :c:func:`PyArg_ParseTuple`, you should "
#~ "choose a different function.  Argument Clinic *does* support all of these "
#~ "scenarios.  But these are advanced topics—let's do something simpler for "
#~ "your first function."
#~ msgstr ""
#~ "ou s'il y a de multiples appels à :c:func:`PyArg_ParseTuple`, choisissez "
#~ "une fonction différente. Argument Clinic gère tous ces scénarios, mais ce "
#~ "sont des sujets trop avancés pour notre première fonction."

#~ msgid ""
#~ "Also, if the function has multiple calls to :c:func:`PyArg_ParseTuple` "
#~ "or :c:func:`PyArg_ParseTupleAndKeywords` where it supports different "
#~ "types for the same argument, or if the function uses something besides "
#~ "PyArg_Parse functions to parse its arguments, it probably isn't suitable "
#~ "for conversion to Argument Clinic.  Argument Clinic doesn't support "
#~ "generic functions or polymorphic parameters."
#~ msgstr ""
#~ "Par ailleurs, si la fonction a des appels multiples à :c:func:"
#~ "`PyArg_ParseTuple` ou :c:func:`PyArg_ParseTupleAndKeywords` dans lesquels "
#~ "elle permet différents types pour les mêmes arguments, il n'est "
#~ "probablement pas possible de la convertir pour Argument Clinic. Argument "
#~ "Clinic ne gère pas les fonctions génériques ou les paramètres polymorphes."

#~ msgid ""
#~ "Add the following boilerplate above the function, creating our block::"
#~ msgstr ""
#~ "Ajoutez les lignes standard suivantes au-dessus de votre fonction pour "
#~ "créer notre bloc ::"

#~ msgid ""
#~ "Cut the docstring and paste it in between the ``[clinic]`` lines, "
#~ "removing all the junk that makes it a properly quoted C string. When "
#~ "you're done you should have just the text, based at the left margin, with "
#~ "no line wider than 80 characters. (Argument Clinic will preserve indents "
#~ "inside the docstring.)"
#~ msgstr ""
#~ "Coupez la *docstring* et collez-la entre les lignes commençant par "
#~ "``[clinic]``, en enlevant tout le bazar qui en fait une chaîne de "
#~ "caractères correcte en C. Une fois que c'est fait, vous devez avoir "
#~ "seulement le texte, aligné à gauche, sans ligne plus longue que 80 "
#~ "caractères (Argument Clinic préserve l'indentation à l'intérieur de la "
#~ "*docstring*)."

#~ msgid ""
#~ "If the old docstring had a first line that looked like a function "
#~ "signature, throw that line away.  (The docstring doesn't need it anymore—"
#~ "when you use ``help()`` on your builtin in the future, the first line "
#~ "will be built automatically based on the function's signature.)"
#~ msgstr ""
#~ "Si l'ancienne *docstring* commençait par une ligne qui ressemble à une "
#~ "signature de fonction, supprimez cette ligne. (Elle n'est plus nécessaire "
#~ "pour la *docstring*. Dans le futur, quand vous utiliserez ``help()`` pour "
#~ "une fonction native, la première ligne sera construite automatiquement à "
#~ "partir de la signature de la fonction.)"

#~ msgid "Sample::"
#~ msgstr "Échantillon ::"

#~ msgid ""
#~ "If your docstring doesn't have a \"summary\" line, Argument Clinic will "
#~ "complain.  So let's make sure it has one.  The \"summary\" line should be "
#~ "a paragraph consisting of a single 80-column line at the beginning of the "
#~ "docstring."
#~ msgstr ""
#~ "Si votre *docstring* ne contient pas de ligne « résumé », Argument Clinic "
#~ "va se plaindre. Assurons-nous donc qu'il y en a une. La ligne « résumé » "
#~ "doit être un paragraphe consistant en une seule ligne de 80 colonnes au "
#~ "début de la *docstring*."

#~ msgid ""
#~ "(Our example docstring consists solely of a summary line, so the sample "
#~ "code doesn't have to change for this step.)"
#~ msgstr ""
#~ "Dans notre exemple, la *docstring* est seulement composée d'une ligne de "
#~ "résumé, donc le code ne change pas à cette étape."

#~ msgid ""
#~ "Above the docstring, enter the name of the function, followed by a blank "
#~ "line.  This should be the Python name of the function, and should be the "
#~ "full dotted path to the function—it should start with the name of the "
#~ "module, include any sub-modules, and if the function is a method on a "
#~ "class it should include the class name too."
#~ msgstr ""
#~ "Au-dessus de la *docstring*, entrez le nom de la fonction, suivi d'une "
#~ "ligne vide. Ce doit être le nom de la fonction en Python et être le "
#~ "chemin complet jusqu'à la fonction. Il doit commencer par le nom du "
#~ "module, suivi de tous les sous-modules, puis, si la fonction est une "
#~ "méthode de classe, inclure aussi le nom de la classe."

#~ msgid ""
#~ "If this is the first time that module or class has been used with "
#~ "Argument Clinic in this C file, you must declare the module and/or "
#~ "class.  Proper Argument Clinic hygiene prefers declaring these in a "
#~ "separate block somewhere near the top of the C file, in the same way that "
#~ "include files and statics go at the top.  (In our sample code we'll just "
#~ "show the two blocks next to each other.)"
#~ msgstr ""
#~ "Si c'est la première fois que ce module ou cette classe est utilisée avec "
#~ "Argument Clinic dans ce fichier C, vous devez déclarer votre module et/ou "
#~ "votre classe. Pour suivre de bonnes pratiques avec Argument Clinic, il "
#~ "vaut mieux faire ces déclarations quelque part en tête du fichier C, "
#~ "comme les fichiers inclus et les statiques (dans cet extrait, nous "
#~ "montrons les deux blocs à côté l'un de l'autre)."

#~ msgid ""
#~ "The name of the class and module should be the same as the one seen by "
#~ "Python.  Check the name defined in the :c:type:`PyModuleDef` or :c:type:"
#~ "`PyTypeObject` as appropriate."
#~ msgstr ""
#~ "Le nom de la classe et du module doivent être les mêmes que ceux vus par "
#~ "Python. Selon le cas, référez-vous à :c:type:`PyModuleDef` ou :c:type:"
#~ "`PyTypeObject`"

#~ msgid ""
#~ "When you declare a class, you must also specify two aspects of its type "
#~ "in C: the type declaration you'd use for a pointer to an instance of this "
#~ "class, and a pointer to the :c:type:`PyTypeObject` for this class."
#~ msgstr ""
#~ "Quand vous déclarez une classe, vous devez aussi spécifier deux aspects "
#~ "de son type en C : la déclaration de type que vous utiliseriez pour un "
#~ "pointeur vers une instance de cette classe et un pointeur vers le :c:type:"
#~ "`PyTypeObject` de cette classe."

#~ msgid ""
#~ "Declare each of the parameters to the function.  Each parameter should "
#~ "get its own line.  All the parameter lines should be indented from the "
#~ "function name and the docstring."
#~ msgstr ""
#~ "Déclarez chacun des paramètres de la fonction. Chaque paramètre doit être "
#~ "sur une ligne séparée. Tous les paramètres doivent être indentés par "
#~ "rapport au nom de la fonction et à la *docstring*."

#~ msgid "The general form of these parameter lines is as follows:"
#~ msgstr "La forme générale de ces paramètres est la suivante :"

#~ msgid "If the parameter has a default value, add that after the converter:"
#~ msgstr ""
#~ "Si le paramètre a une valeur par défaut, ajoutez ceci après le "
#~ "convertisseur :"

#~ msgid ""
#~ "Argument Clinic's support for \"default values\" is quite sophisticated; "
#~ "please see :ref:`the section below on default values <default_values>` "
#~ "for more information."
#~ msgstr ""
#~ "Argument Clinic peut traiter les « valeurs par défaut » de manière assez "
#~ "sophistiquée ; voyez :ref:`la section ci-dessous sur les valeurs par "
#~ "défaut <default_values>` pour plus de détails."

#~ msgid "Add a blank line below the parameters."
#~ msgstr "Ajoutez une ligne vide sous les paramètres."

#~ msgid ""
#~ "What's a \"converter\"?  It establishes both the type of the variable "
#~ "used in C, and the method to convert the Python value into a C value at "
#~ "runtime. For now you're going to use what's called a \"legacy converter\"—"
#~ "a convenience syntax intended to make porting old code into Argument "
#~ "Clinic easier."
#~ msgstr ""
#~ "Que fait le « convertisseur » ? Il établit à la fois le type de variable "
#~ "utilisé en C et la méthode pour convertir la valeur Python en valeur C "
#~ "lors de l'exécution.  Pour le moment, vous allez utiliser ce qui "
#~ "s'appelle un « convertisseur hérité », une syntaxe de convenance qui "
#~ "facilite le portage de vieux code dans Argument Clinic."

#~ msgid ""
#~ "For each parameter, copy the \"format unit\" for that parameter from the "
#~ "``PyArg_Parse()`` format argument and specify *that* as its converter, as "
#~ "a quoted string.  (\"format unit\" is the formal name for the one-to-"
#~ "three character substring of the ``format`` parameter that tells the "
#~ "argument parsing function what the type of the variable is and how to "
#~ "convert it.  For more on format units please see :ref:`arg-parsing`.)"
#~ msgstr ""
#~ "Pour chaque paramètre, copiez la « spécification de format » de ce "
#~ "paramètre à partir de l'argument de ``PyArg_Parse()`` et spécifiez *ça* "
#~ "comme convertisseur, entre guillemets. (la « spécification de format » "
#~ "est le nom formel pour la partie du paramètre ``format``, de un à trois "
#~ "caractères, qui indique à la fonction d'analyse d'arguments quel est le "
#~ "type de la variable et comment la convertir. Pour plus d'information sur "
#~ "les spécifications de format, voyez :ref:`arg-parsing`.)"

#~ msgid ""
#~ "For multicharacter format units like ``z#``, use the entire two-or-three "
#~ "character string."
#~ msgstr ""
#~ "Pour des spécifications de format de plusieurs caractères, comme ``z#``, "
#~ "utilisez l'ensemble des 2 ou 3 caractères de la chaîne."

#~ msgid ""
#~ "If your function has ``|`` in the format string, meaning some parameters "
#~ "have default values, you can ignore it.  Argument Clinic infers which "
#~ "parameters are optional based on whether or not they have default values."
#~ msgstr ""
#~ "Si votre fonction a le caractère ``|`` dans son format, parce que "
#~ "certains paramètres ont des valeurs par défaut, vous pouvez l'ignorer. "
#~ "Argument Clinic infère quels paramètres sont optionnels selon s'ils ont "
#~ "ou non une valeur par défaut."

#~ msgid ""
#~ "If your function has ``$`` in the format string, meaning it takes keyword-"
#~ "only arguments, specify ``*`` on a line by itself before the first "
#~ "keyword-only argument, indented the same as the parameter lines."
#~ msgstr ""
#~ "Si votre fonction a le caractère ``$`` dans son format, parce qu'elle "
#~ "n'accepte que des arguments nommés, spécifiez ``*`` sur une ligne à part, "
#~ "avant le premier argument nommé, avec la même indentation que les lignes "
#~ "de paramètres."

#~ msgid "(``_pickle.Pickler.dump`` has neither, so our sample is unchanged.)"
#~ msgstr ""
#~ "(``_pickle.Pickler.dump`` n'a ni l'un ni l'autre, donc notre exemple est "
#~ "inchangé.)"

#~ msgid ""
#~ "If the existing C function calls :c:func:`PyArg_ParseTuple` (as opposed "
#~ "to :c:func:`PyArg_ParseTupleAndKeywords`), then all its arguments are "
#~ "positional-only."
#~ msgstr ""
#~ "Si la fonction C existante appelle :c:func:`PyArg_ParseTuple` (et pas :c:"
#~ "func:`PyArg_ParseTupleAndKeywords`), alors tous ses arguments sont "
#~ "uniquement positionnels."

#~ msgid ""
#~ "To mark all parameters as positional-only in Argument Clinic, add a ``/`` "
#~ "on a line by itself after the last parameter, indented the same as the "
#~ "parameter lines."
#~ msgstr ""
#~ "Pour marquer tous les paramètres comme uniquement positionnels dans "
#~ "Argument Clinic, ajoutez ``/`` sur une ligne à part après le dernier "
#~ "paramètre, avec la même indentation que les lignes de paramètres."

#~ msgid ""
#~ "Currently this is all-or-nothing; either all parameters are positional-"
#~ "only, or none of them are.  (In the future Argument Clinic may relax this "
#~ "restriction.)"
#~ msgstr ""
#~ "Pour le moment, c'est tout ou rien ; soit tous les paramètres sont "
#~ "uniquement positionnels, ou aucun ne l'est. (Dans le futur, Argument "
#~ "Clinic supprimera peut-être cette restriction.)"

#~ msgid ""
#~ "It's helpful to write a per-parameter docstring for each parameter. But "
#~ "per-parameter docstrings are optional; you can skip this step if you "
#~ "prefer."
#~ msgstr ""
#~ "Il est utile d'ajouter une *docstring* pour chaque paramètre, mais c'est "
#~ "optionnel ; vous pouvez passer cette étape si vous préférez."

#~ msgid ""
#~ "Here's how to add a per-parameter docstring.  The first line of the per-"
#~ "parameter docstring must be indented further than the parameter "
#~ "definition.  The left margin of this first line establishes the left "
#~ "margin for the whole per-parameter docstring; all the text you write will "
#~ "be outdented by this amount.  You can write as much text as you like, "
#~ "across multiple lines if you wish."
#~ msgstr ""
#~ "Voici comment ajouter la *docstring* d'un paramètre. La première ligne "
#~ "doit être plus indentée que la définition du paramètre. La marge gauche "
#~ "de cette première ligne établit la marge gauche pour l'ensemble de la "
#~ "*docstring* de ce paramètre ; tout le texte que vous écrivez sera indenté "
#~ "de cette quantité. Vous pouvez écrire autant de texte que vous le "
#~ "souhaitez, sur plusieurs lignes."

#~ msgid ""
#~ "Save and close the file, then run ``Tools/clinic/clinic.py`` on it.  With "
#~ "luck everything worked---your block now has output, and a ``.c.h`` file "
#~ "has been generated! Reopen the file in your text editor to see::"
#~ msgstr ""
#~ "Enregistrez puis fermez le fichier, puis exécutez ``Tools/clinic/clinic."
#~ "py`` dessus. Avec un peu de chance tout a fonctionné, votre bloc a "
#~ "maintenant une sortie, et un fichier ``.c.h`` a été généré ! Ré-ouvrez le "
#~ "fichier dans votre éditeur pour voir ::"

#~ msgid ""
#~ "Obviously, if Argument Clinic didn't produce any output, it's because it "
#~ "found an error in your input.  Keep fixing your errors and retrying until "
#~ "Argument Clinic processes your file without complaint."
#~ msgstr ""
#~ "Bien sûr, si Argument Clinic n'a pas produit de sortie, c'est qu'il a "
#~ "rencontré une erreur dans votre entrée. Corrigez vos erreurs et réessayez "
#~ "jusqu'à ce qu'Argument Clinic traite votre fichier sans problème."

#~ msgid ""
#~ "For readability, most of the glue code has been generated to a ``.c.h`` "
#~ "file.  You'll need to include that in your original ``.c`` file, "
#~ "typically right after the clinic module block::"
#~ msgstr ""
#~ "Pour plus de visibilité, la plupart du code a été écrit dans un fichier "
#~ "``.c.h``. Vous devez l'inclure dans votre fichier ``.c`` original, "
#~ "typiquement juste après le bloc du module *clinic* ::"

#~ msgid ""
#~ "Double-check that the argument-parsing code Argument Clinic generated "
#~ "looks basically the same as the existing code."
#~ msgstr ""
#~ "Vérifiez bien que le code d'analyse d'arguments généré par Argument "
#~ "Clinic ressemble bien au code existant."

#~ msgid ""
#~ "First, ensure both places use the same argument-parsing function. The "
#~ "existing code must call either :c:func:`PyArg_ParseTuple` or :c:func:"
#~ "`PyArg_ParseTupleAndKeywords`; ensure that the code generated by Argument "
#~ "Clinic calls the *exact* same function."
#~ msgstr ""
#~ "Assurez vous premièrement que les deux codes utilisent la même fonction "
#~ "pour analyser les arguments. Le code existant doit appeler soit :c:func:"
#~ "`PyArg_ParseTuple` soit :c:func:`PyArg_ParseTupleAndKeywords` ; assurez "
#~ "vous que le code généré par Argument Clinic appelle *exactement* la même "
#~ "fonction."

#~ msgid ""
#~ "Second, the format string passed in to :c:func:`PyArg_ParseTuple` or :c:"
#~ "func:`PyArg_ParseTupleAndKeywords` should be *exactly* the same as the "
#~ "hand-written one in the existing function, up to the colon or semi-colon."
#~ msgstr ""
#~ "Deuxièmement, la chaîne de caractère du format passée dans :c:func:"
#~ "`PyArg_ParseTuple` ou :c:func:`PyArg_ParseTupleAndKeywords` doit être "
#~ "*exactement* la même que celle écrite à la main, jusqu'aux deux points ou "
#~ "au point virgule."

#~ msgid ""
#~ "(Argument Clinic always generates its format strings with a ``:`` "
#~ "followed by the name of the function.  If the existing code's format "
#~ "string ends with ``;``, to provide usage help, this change is harmless—"
#~ "don't worry about it.)"
#~ msgstr ""
#~ "(Argument Clinic génère toujours ses chaînes de format avec ``:`` suivi "
#~ "du nom de la fonction. Si la chaîne de format du code existant termine "
#~ "par ``;``, pour fournir une aide sur l'utilisation, ce changement n'a "
#~ "aucun effet, ne vous en souciez pas.)"

#~ msgid ""
#~ "Third, for parameters whose format units require two arguments (like a "
#~ "length variable, or an encoding string, or a pointer to a conversion "
#~ "function), ensure that the second argument is *exactly* the same between "
#~ "the two invocations."
#~ msgstr ""
#~ "Troisièmement, pour des paramètres dont la spécification de format "
#~ "nécessite deux arguments (comme une variable de longueur, ou une chaîne "
#~ "d'encodage, ou un pointeur vers une fonction de conversion), assurez vous "
#~ "que ce deuxième argument est *exactement* le même entre les deux "
#~ "invocations."

#~ msgid ""
#~ "Fourth, inside the output portion of the block you'll find a preprocessor "
#~ "macro defining the appropriate static :c:type:`PyMethodDef` structure for "
#~ "this builtin::"
#~ msgstr ""
#~ "Quatrièmement, à l'intérieur de la section sortie du bloc, vous trouverez "
#~ "une macro pré-processeur qui définit les structures statiques :c:type:"
#~ "`PyMethodDef` appropriées pour ce module natif ::"

#~ msgid ""
#~ "This static structure should be *exactly* the same as the existing "
#~ "static :c:type:`PyMethodDef` structure for this builtin."
#~ msgstr ""
#~ "Cette structure statique doit être *exactement* la même que la structure "
#~ "statique :c:type:`PyMethodDef` existante pour ce module natif."

#~ msgid ""
#~ "If any of these items differ in *any way*, adjust your Argument Clinic "
#~ "function specification and rerun ``Tools/clinic/clinic.py`` until they "
#~ "*are* the same."
#~ msgstr ""
#~ "Si l'un de ces éléments diffère *de quelque façon que se soit*, ajustez "
#~ "la spécification de fonction d'Argument Clinic et exécutez de nouveau "
#~ "``Tools/clinic/clinic.py`` jusqu'à ce qu'elles soient identiques."

#~ msgid ""
#~ "Notice that the last line of its output is the declaration of your "
#~ "\"impl\" function.  This is where the builtin's implementation goes. "
#~ "Delete the existing prototype of the function you're modifying, but leave "
#~ "the opening curly brace.  Now delete its argument parsing code and the "
#~ "declarations of all the variables it dumps the arguments into. Notice how "
#~ "the Python arguments are now arguments to this impl function; if the "
#~ "implementation used different names for these variables, fix it."
#~ msgstr ""
#~ "Notez que la dernière ligne de cette sortie est la déclaration de votre "
#~ "fonction ``impl``. C'est là que se trouve l'implémentation de la fonction "
#~ "native. Supprimez le prototype de la fonction que vous modifiez, mais "
#~ "laissez l'accolade ouverte. Maintenant, supprimez tout le code d'analyse "
#~ "d'arguments et les déclarations de toutes les variables auxquelles il "
#~ "assigne les arguments. Vous voyez que désormais les arguments Python sont "
#~ "ceux de cette fonction ``impl`` ; si l'implémentation utilise des noms "
#~ "différents pour ces variables, corrigez-les."

#~ msgid ""
#~ "Let's reiterate, just because it's kind of weird.  Your code should now "
#~ "look like this::"
#~ msgstr ""
#~ "Comme c'est un peu bizarre, ça vaut la peine de répéter. Votre fonction "
#~ "doit ressembler à ça ::"

#~ msgid ""
#~ "Argument Clinic generated the checksum line and the function prototype "
#~ "just above it.  You should write the opening (and closing) curly braces "
#~ "for the function, and the implementation inside."
#~ msgstr ""
#~ "Argument Clinic génère une ligne de contrôle et la fonction prototype "
#~ "juste au-dessus. Vous devez écrire les accolades d'ouverture (et de "
#~ "fermeture) pour la fonction,  et l’implémentation à l'intérieur."

#~ msgid ""
#~ "Remember the macro with the :c:type:`PyMethodDef` structure for this "
#~ "function?  Find the existing :c:type:`PyMethodDef` structure for this "
#~ "function and replace it with a reference to the macro.  (If the builtin "
#~ "is at module scope, this will probably be very near the end of the file; "
#~ "if the builtin is a class method, this will probably be below but "
#~ "relatively near to the implementation.)"
#~ msgstr ""
#~ "Vous vous souvenez de la macro avec la structure :c:type:`PyMethodDef` "
#~ "pour cette fonction ? Trouvez la structure :c:type:`PyMethodDef` "
#~ "existante pour cette fonction et remplacez là par une référence à cette "
#~ "macro. (Si la fonction native est définie au niveau d'un module, vous le "
#~ "trouverez certainement vers la fin du fichier ; s'il s'agit d'une méthode "
#~ "de classe, se sera sans doute plus bas, mais relativement près de "
#~ "l'implémentation.)"

#~ msgid ""
#~ "Note that the body of the macro contains a trailing comma.  So when you "
#~ "replace the existing static :c:type:`PyMethodDef` structure with the "
#~ "macro, *don't* add a comma to the end."
#~ msgstr ""
#~ "Notez que le corps de la macro contient une virgule finale. Donc, lorsque "
#~ "vous remplacez la structure statique :c:type:`PyMethodDef` par la macro, "
#~ "*n'ajoutez pas* de virgule à la fin."

#, fuzzy
#~ msgid ""
#~ "Compile, then run the relevant portions of the regression-test suite. "
#~ "This change should not introduce any new compile-time warnings or errors, "
#~ "and there should be no externally visible change to Python's behavior."
#~ msgstr ""
#~ "Compilez, puis faites tourner les portions idoines de la suite de tests "
#~ "de régressions. Ce changement ne doit introduire aucun nouveau message "
#~ "d'erreur ou avertissement à la compilation, et il ne devrait y avoir "
#~ "aucun changement visible de l'extérieur au comportement de Python."

#~ msgid ""
#~ "Well, except for one difference: ``inspect.signature()`` run on your "
#~ "function should now provide a valid signature!"
#~ msgstr ""
#~ "Enfin, à part pour une différence : si vous exécutez ``inspect."
#~ "signature()`` sur votre fonction, vous obtiendrez maintenant une "
#~ "signature valide !"

#~ msgid ""
#~ "Congratulations, you've ported your first function to work with Argument "
#~ "Clinic!"
#~ msgstr ""
#~ "Félicitations, vous avez adapté votre première fonction pour qu'elle "
#~ "utilise Argument Clinic !"

#, fuzzy
#~ msgid ""
#~ "How to to rename C functions and variables generated by Argument Clinic"
#~ msgstr "Renommer les fonctions et variables C générées par Argument Clinic"

#~ msgid ""
#~ "Argument Clinic automatically names the functions it generates for you. "
#~ "Occasionally this may cause a problem, if the generated name collides "
#~ "with the name of an existing C function.  There's an easy solution: "
#~ "override the names used for the C functions.  Just add the keyword "
#~ "``\"as\"`` to your function declaration line, followed by the function "
#~ "name you wish to use. Argument Clinic will use that function name for the "
#~ "base (generated) function, then add ``\"_impl\"`` to the end and use that "
#~ "for the name of the impl function."
#~ msgstr ""
#~ "Argument Clinic nomme automatiquement les fonctions qu'il génère. "
#~ "Parfois, cela peut poser des problèmes, si le nom généré entre en "
#~ "collision avec le nom d'une fonction C existante. Il y a une solution "
#~ "simple : surcharger les noms utilisés par les fonctions C. Ajoutez "
#~ "simplement le mot clef ``\"as\"`` sur la ligne de la déclaration de la "
#~ "fonction, suivi par le nom de la fonction que vous souhaitez utiliser. "
#~ "Argument Clinic utilisera ce nom de fonction pour la fonction de base "
#~ "(celle générée), et ajoutera ``\"_impl\"`` à la fin et utilisera ce nom "
#~ "pour la fonction ``impl``."

#~ msgid ""
#~ "For example, if we wanted to rename the C function names generated for "
#~ "``pickle.Pickler.dump``, it'd look like this::"
#~ msgstr ""
#~ "Par exemple, si nous voulons renommer les noms de fonction C générés pour "
#~ "``pickle.Pickler.dump``, ça ressemblerait à ça ::"

#~ msgid ""
#~ "The base function would now be named ``pickler_dumper()``, and the impl "
#~ "function would now be named ``pickler_dumper_impl()``."
#~ msgstr ""
#~ "La fonction de base sera maintenant nommée ``pickler_dumper()``, et la "
#~ "fonction ``impl`` sera maintenant nommée ``pickler_dumper_impl()``."

#~ msgid ""
#~ "Similarly, you may have a problem where you want to give a parameter a "
#~ "specific Python name, but that name may be inconvenient in C.  Argument "
#~ "Clinic allows you to give a parameter different names in Python and in C, "
#~ "using the same ``\"as\"`` syntax::"
#~ msgstr ""
#~ "De même, vous pouvez avoir un problème quand vous souhaiterez donner à un "
#~ "paramètre un nom spécifique à Python, mais ce nom peut être gênant en C. "
#~ "Argument Clinic vous permet de donner à un paramètre des noms différents "
#~ "en Python et en C ::"

#~ msgid ""
#~ "Here, the name used in Python (in the signature and the ``keywords`` "
#~ "array) would be ``file``, but the C variable would be named ``file_obj``."
#~ msgstr ""
#~ "Ici, le nom utilisé en Python (dans la signature ainsi que le tableau des "
#~ "``keywords``) sera ``file``, et la variable C s'appellera ``file_obj``."

#~ msgid "You can use this to rename the ``self`` parameter too!"
#~ msgstr "Vous pouvez utiliser ceci pour renommer aussi le paramètre ``self``"

#, fuzzy
#~ msgid "How to convert functions using ``PyArg_UnpackTuple``"
#~ msgstr "Conversion des fonctions en utilisant *PyArg_UnpackTuple*"

#~ msgid ""
#~ "To convert a function parsing its arguments with :c:func:"
#~ "`PyArg_UnpackTuple`, simply write out all the arguments, specifying each "
#~ "as an ``object``.  You may specify the ``type`` argument to cast the type "
#~ "as appropriate.  All arguments should be marked positional-only (add a ``/"
#~ "`` on a line by itself after the last argument)."
#~ msgstr ""
#~ "Afin de convertir une fonction analysant ses arguments via :c:func:"
#~ "`PyArg_UnpackTuple`, écrivez simplement tous les arguments, en les "
#~ "spécifiant comme des ``object``. Vous pouvez spécifier également le "
#~ "``type`` d'argument afin de le forcer au type approprié. Tous les "
#~ "arguments devraient être marqués comme seulement positionnels (ajoutez un "
#~ "``/`` seul sur la ligne après le dernier argument)."

#~ msgid ""
#~ "Currently the generated code will use :c:func:`PyArg_ParseTuple`, but "
#~ "this will change soon."
#~ msgstr ""
#~ "Actuellement, le code généré utilise :c:func:`PyArg_ParseTuple`, mais "
#~ "cela va bientôt changer."

#, fuzzy
#~ msgid "How to use optional groups"
#~ msgstr "Groupes optionnels"

#~ msgid ""
#~ "Some legacy functions have a tricky approach to parsing their arguments: "
#~ "they count the number of positional arguments, then use a ``switch`` "
#~ "statement to call one of several different :c:func:`PyArg_ParseTuple` "
#~ "calls depending on how many positional arguments there are.  (These "
#~ "functions cannot accept keyword-only arguments.)  This approach was used "
#~ "to simulate optional arguments back before :c:func:"
#~ "`PyArg_ParseTupleAndKeywords` was created."
#~ msgstr ""
#~ "Certaines fonctions de base ont une approche particulière pour analyser "
#~ "leurs arguments : elles comptent le nombre d'arguments positionnels, puis "
#~ "elles utilisent une condition ``switch`` basée sur le nombre d'arguments "
#~ "présents pour appeler différentes :c:func:`PyArg_ParseTuple` disponibles "
#~ "(ces fonctions ne peuvent pas avoir des arguments passés uniquement en "
#~ "tant qu'arguments nommés). Cette approche était utilisée pour simuler des "
#~ "arguments optionnels avant que :c:func:`PyArg_ParseTupleAndKeywords` ne "
#~ "soit créée."

#~ msgid ""
#~ "While functions using this approach can often be converted to use :c:func:"
#~ "`PyArg_ParseTupleAndKeywords`, optional arguments, and default values, "
#~ "it's not always possible.  Some of these legacy functions have behaviors :"
#~ "c:func:`PyArg_ParseTupleAndKeywords` doesn't directly support. The most "
#~ "obvious example is the builtin function ``range()``, which has an "
#~ "optional argument on the *left* side of its required argument! Another "
#~ "example is ``curses.window.addch()``, which has a group of two arguments "
#~ "that must always be specified together.  (The arguments are called ``x`` "
#~ "and ``y``; if you call the function passing in ``x``, you must also pass "
#~ "in ``y``—and if you don't pass in ``x`` you may not pass in ``y`` either.)"
#~ msgstr ""
#~ "Alors que les fonctions utilisant cette approche peuvent normalement être "
#~ "converties pour utiliser :c:func:`PyArg_ParseTupleAndKeywords`, des "
#~ "arguments optionnels et des valeurs par défaut, ce n'est pas toujours "
#~ "possible. Certaines fonctions classiques ne peuvent pas être gérées par :"
#~ "c:func:`PyArg_ParseTupleAndKeywords`. L'exemple le plus évident est la "
#~ "fonction native ``range()``, qui possède un argument optionnel à *gauche* "
#~ "de ses arguments requis ! Un autre exemple est la fonction ``curses."
#~ "window.addch()``, qui possède un groupe de deux arguments qui doivent "
#~ "toujours être spécifiés ensemble (ces arguments s'appellent ``x`` et "
#~ "``y`` ; si vous appelez la fonction en passant ``x``, vous devez passer "
#~ "``y`` et si vous ne passez pas ``x``, vous ne devez pas passer ``y`` non "
#~ "plus)."

#~ msgid ""
#~ "In any case, the goal of Argument Clinic is to support argument parsing "
#~ "for all existing CPython builtins without changing their semantics. "
#~ "Therefore Argument Clinic supports this alternate approach to parsing, "
#~ "using what are called *optional groups*. Optional groups are groups of "
#~ "arguments that must all be passed in together. They can be to the left or "
#~ "the right of the required arguments.  They can *only* be used with "
#~ "positional-only parameters."
#~ msgstr ""
#~ "Dans tous les cas, le but d'Argument Clinic est de prendre en charge "
#~ "l'analyse des arguments pour toutes les fonctions natives de CPython sans "
#~ "avoir besoin de les modifier. C'est pourquoi Argument Clinic propose "
#~ "cette autre approche pour l'analyse, en utilisant ce qu'on appelle les "
#~ "*groupes optionnels*. Les groupes optionnels sont des groupes d'arguments "
#~ "qui doivent tous être transmis ensemble. Ils peuvent être situés à droite "
#~ "ou à gauche des arguments requis. Ils ne peuvent être utilisés "
#~ "*seulement* qu'en tant que paramètres positionnels."

#~ msgid ""
#~ "Optional groups are *only* intended for use when converting functions "
#~ "that make multiple calls to :c:func:`PyArg_ParseTuple`! Functions that "
#~ "use *any* other approach for parsing arguments should *almost never* be "
#~ "converted to Argument Clinic using optional groups.  Functions using "
#~ "optional groups currently cannot have accurate signatures in Python, "
#~ "because Python just doesn't understand the concept.  Please avoid using "
#~ "optional groups wherever possible."
#~ msgstr ""
#~ "Les groupes optionnels sont *uniquement* prévus pour convertir les "
#~ "fonctions faisant des appels multiples à :c:func:`PyArg_ParseTuple` ! Les "
#~ "fonctions qui utilisent *au moins une* des autres approches ne doivent "
#~ "*presque jamais* être converties à Argument Clinic en utilisant les "
#~ "groupes optionnels. Les fonctions utilisant ces groupes n'ont pas "
#~ "actuellement de signature précise en Python, parce que celui-ci ne peut "
#~ "simplement pas comprendre ce concept. Tâchez d'éviter au maximum "
#~ "d'utiliser ces groupes optionnels si possible."

#~ msgid ""
#~ "To specify an optional group, add a ``[`` on a line by itself before the "
#~ "parameters you wish to group together, and a ``]`` on a line by itself "
#~ "after these parameters.  As an example, here's how ``curses.window."
#~ "addch`` uses optional groups to make the first two parameters and the "
#~ "last parameter optional::"
#~ msgstr ""
#~ "Afin de signaler un groupe optionnel, ajoutez un ``[`` seul sur une ligne "
#~ "avant les paramètres que vous souhaitez inclure dans le groupe, puis un "
#~ "``]`` seul sur une ligne après ces paramètres. Voici, par exemple, "
#~ "comment ``curses.window.addch`` utilise les groupes optionnels pour "
#~ "rendre optionnel les deux premiers paramètres ainsi que le dernier ::"

#~ msgid "Notes:"
#~ msgstr "Notes :"

#~ msgid ""
#~ "For every optional group, one additional parameter will be passed into "
#~ "the impl function representing the group.  The parameter will be an int "
#~ "named ``group_{direction}_{number}``, where ``{direction}`` is either "
#~ "``right`` or ``left`` depending on whether the group is before or after "
#~ "the required parameters, and ``{number}`` is a monotonically increasing "
#~ "number (starting at 1) indicating how far away the group is from the "
#~ "required parameters.  When the impl is called, this parameter will be set "
#~ "to zero if this group was unused, and set to non-zero if this group was "
#~ "used. (By used or unused, I mean whether or not the parameters received "
#~ "arguments in this invocation.)"
#~ msgstr ""
#~ "Pour chaque groupe optionnel, un paramètre additionnel sera passé à la "
#~ "fonction ``impl`` représentant le groupe. Ce paramètre sera un entier "
#~ "nommé ``group_{direction}_{number}``, où ``{direction}`` peut être soit "
#~ "``right`` ou ``left`` suivant que le groupe est situé avant ou après les "
#~ "paramètres requis, et ``{number}`` sera un entier incrémenté (débutant à "
#~ "1) indiquant la distance entre le groupe et les paramètres requis. Quand "
#~ "la fonction ``impl`` est appelée, ce paramètre est positionné à zéro si "
#~ "le groupe n'a pas été utilisé, et positionné à un nombre entier positif "
#~ "sinon (par inutilisé, on entend que les paramètres n'ont pas reçu de "
#~ "valeur lors de cet appel)."

#~ msgid ""
#~ "If there are no required arguments, the optional groups will behave as if "
#~ "they're to the right of the required arguments."
#~ msgstr ""
#~ "S'il n'y a pas d'arguments requis, les groupes optionnels se comportent "
#~ "comme s'ils étaient à droite des arguments requis."

#~ msgid ""
#~ "In the case of ambiguity, the argument parsing code favors parameters on "
#~ "the left (before the required parameters)."
#~ msgstr ""
#~ "En cas d'ambiguïté, le code d'analyse des arguments favorise ceux situés "
#~ "à gauche (avant les paramètres obligatoires)."

#~ msgid "Optional groups can only contain positional-only parameters."
#~ msgstr ""
#~ "Les groupes optionnels ne peuvent contenir que des arguments positionnels."

#~ msgid ""
#~ "Optional groups are *only* intended for legacy code.  Please do not use "
#~ "optional groups for new code."
#~ msgstr ""
#~ "Les groupes optionnels sont *seulement* destinés au code hérité. Ne les "
#~ "utilisez pas dans du nouveau code."

#, fuzzy
#~ msgid ""
#~ "How to use real Argument Clinic converters, instead of \"legacy "
#~ "converters\""
#~ msgstr ""
#~ "Utilisation des adaptateurs d'Argument Clinic, en lieu et place des "
#~ "« adaptateurs de base »"

#~ msgid ""
#~ "To save time, and to minimize how much you need to learn to achieve your "
#~ "first port to Argument Clinic, the walkthrough above tells you to use "
#~ "\"legacy converters\".  \"Legacy converters\" are a convenience, designed "
#~ "explicitly to make porting existing code to Argument Clinic easier.  And "
#~ "to be clear, their use is acceptable when porting code for Python 3.4."
#~ msgstr ""
#~ "Afin de gagner du temps, et pour minimiser la courbe d'apprentissage pour "
#~ "pouvoir utiliser Argument Clinic, le guide ci-dessus préconise les "
#~ "« adaptateurs de base ». Ceux-ci sont un moyen simple conçu pour porter "
#~ "facilement du code existant sous Argument Clinic. Et pour être clair, "
#~ "leur utilisation est tout à fait acceptable pour porter du code Python "
#~ "3.4."

#~ msgid ""
#~ "However, in the long term we probably want all our blocks to use Argument "
#~ "Clinic's real syntax for converters.  Why?  A couple reasons:"
#~ msgstr ""
#~ "Cependant, sur le long terme, il est certainement préférable que tous vos "
#~ "blocs utilisent la syntaxe réelle des adaptateurs d'Argument Clinic. "
#~ "Pourquoi ? Voici quelques raisons :"

#~ msgid ""
#~ "The proper converters are far easier to read and clearer in their intent."
#~ msgstr "Les adaptateurs sont plus simples et plus clairs."

#~ msgid ""
#~ "There are some format units that are unsupported as \"legacy "
#~ "converters\", because they require arguments, and the legacy converter "
#~ "syntax doesn't support specifying arguments."
#~ msgstr ""
#~ "Il existe des formats qui ne sont pas gérés par les « adaptateurs de "
#~ "base », parce qu'ils nécessitent des arguments, et la syntaxe de ces "
#~ "adaptateurs ne supporte pas cela."

#~ msgid ""
#~ "In the future we may have a new argument parsing library that isn't "
#~ "restricted to what :c:func:`PyArg_ParseTuple` supports; this flexibility "
#~ "won't be available to parameters using legacy converters."
#~ msgstr ""
#~ "Dans le futur, on pourrait avoir une nouvelle bibliothèque d'analyse des "
#~ "arguments qui ne serait pas limitée à ce que :c:func:`PyArg_ParseTuple` "
#~ "accepte ; cette flexibilité ne serait pas accessible aux paramètres "
#~ "utilisant des adaptateurs de base."

#~ msgid ""
#~ "Therefore, if you don't mind a little extra effort, please use the normal "
#~ "converters instead of legacy converters."
#~ msgstr ""
#~ "Ainsi, si vous n'êtes pas contre un petit effort supplémentaire, vous "
#~ "devriez utiliser les adaptateurs normaux plutôt que ceux de base."

#~ msgid ""
#~ "In a nutshell, the syntax for Argument Clinic (non-legacy) converters "
#~ "looks like a Python function call.  However, if there are no explicit "
#~ "arguments to the function (all functions take their default values), you "
#~ "may omit the parentheses.  Thus ``bool`` and ``bool()`` are exactly the "
#~ "same converters."
#~ msgstr ""
#~ "En bref, la syntaxe des adaptateurs d'Argument Clinic ressemble à un "
#~ "appel de fonction Python. Mais, s'il n'y a pas d'argument explicite à la "
#~ "fonction (celle-ci utilisant ses valeurs par défaut), vous pouvez omettre "
#~ "les parenthèses. Ainsi ``bool`` et ``bool()`` représentent le même "
#~ "adaptateur."

#~ msgid ""
#~ "All arguments to Argument Clinic converters are keyword-only. All "
#~ "Argument Clinic converters accept the following arguments:"
#~ msgstr ""
#~ "Tous les arguments passés aux adaptateurs d'Argument Clinic sont nommés. "
#~ "Tous les adaptateurs d'Argument Clinic acceptent les arguments suivants :"

#~ msgid "``c_default``"
#~ msgstr "``c_default``"

#~ msgid ""
#~ "The default value for this parameter when defined in C. Specifically, "
#~ "this will be the initializer for the variable declared in the \"parse "
#~ "function\".  See :ref:`the section on default values <default_values>` "
#~ "for how to use this. Specified as a string."
#~ msgstr ""
#~ "La valeur par défaut de cet argument lorsqu'il est défini en C. "
#~ "Typiquement, il servira à initialiser la variable déclarée dans la "
#~ "« fonction d'analyse ». Voir la section relative aux :ref:`valeurs par "
#~ "défaut <default_values>` pour apprendre à l'utiliser. Spécifié en tant "
#~ "que chaîne de caractères."

#~ msgid "``annotation``"
#~ msgstr "``annotation``"

#~ msgid ""
#~ "The annotation value for this parameter.  Not currently supported, "
#~ "because :pep:`8` mandates that the Python library may not use annotations."
#~ msgstr ""
#~ "La valeur annotée pour ce paramètre. Actuellement non géré, car la :pep:"
#~ "`8` exige que les bibliothèques Python n'utilisent pas d'annotations."

#~ msgid ""
#~ "In addition, some converters accept additional arguments.  Here is a list "
#~ "of these arguments, along with their meanings:"
#~ msgstr ""
#~ "De plus, certains adaptateurs acceptent des arguments additionnels. Voici "
#~ "la liste de ces arguments, avec leur explication :"

#~ msgid "``accept``"
#~ msgstr "``accept``"

#~ msgid ""
#~ "A set of Python types (and possibly pseudo-types); this restricts the "
#~ "allowable Python argument to values of these types. (This is not a "
#~ "general-purpose facility; as a rule it only supports specific lists of "
#~ "types as shown in the legacy converter table.)"
#~ msgstr ""
#~ "Un ensemble de types Python (et potentiellement des pseudo-types) ; cela "
#~ "restreint l'argument Python autorisé aux valeurs de ces types (ce n'est "
#~ "pas destiné à une utilisation généralisée ; en fait, il gère seulement "
#~ "les types listés dans la table des adaptateurs de base)."

#~ msgid "To accept ``None``, add ``NoneType`` to this set."
#~ msgstr "Pour accepter ``None``, ajouter ``NoneType`` à cet ensemble."

#~ msgid "``bitwise``"
#~ msgstr "``bitwise``"

#~ msgid ""
#~ "Only supported for unsigned integers.  The native integer value of this "
#~ "Python argument will be written to the parameter without any range "
#~ "checking, even for negative values."
#~ msgstr ""
#~ "Autorisé seulement pour les entiers non signés. La valeur native de cet "
#~ "argument Python sera transcrite dans le paramètre sans aucune "
#~ "vérification de plage, même pour des valeurs négatives."

#~ msgid "``converter``"
#~ msgstr "``converter``"

#~ msgid ""
#~ "Only supported by the ``object`` converter.  Specifies the name of a :ref:"
#~ "`C \"converter function\" <o_ampersand>` to use to convert this object to "
#~ "a native type."
#~ msgstr ""
#~ "Autorisé seulement pour l'adaptateur ``object``. Spécifie le nom d'une :"
#~ "ref:`« fonction de conversion » depuis C <o_ampersand>` à utiliser pour "
#~ "convertir cet objet en type natif."

#~ msgid "``encoding``"
#~ msgstr "``encoding``"

#~ msgid ""
#~ "Only supported for strings.  Specifies the encoding to use when "
#~ "converting this string from a Python str (Unicode) value into a C ``char "
#~ "*`` value."
#~ msgstr ""
#~ "Autorisé seulement pour les chaînes de caractères. Spécifie l'encodage à "
#~ "utiliser lors de la conversion de cette chaîne depuis une valeur de type "
#~ "Python ``str`` (Unicode) en valeur C ``char *``."

#~ msgid "``subclass_of``"
#~ msgstr "``subclass_of``"

#~ msgid ""
#~ "Only supported for the ``object`` converter.  Requires that the Python "
#~ "value be a subclass of a Python type, as expressed in C."
#~ msgstr ""
#~ "Autorisé seulement pour l'adaptateur ``object``. Nécessite que la valeur "
#~ "Python soit une sous-classe d'un type Python, telle qu'exprimée en C."

#~ msgid "``type``"
#~ msgstr "``type``"

#~ msgid ""
#~ "Only supported for the ``object`` and ``self`` converters.  Specifies the "
#~ "C type that will be used to declare the variable.  Default value is "
#~ "``\"PyObject *\"``."
#~ msgstr ""
#~ "Autorisé seulement pour les adaptateurs ``object`` et ``self``. Spécifie "
#~ "le type C qui sera utilisé pour déclarer la variable. La valeur par "
#~ "défaut est ``\"PyObject *\"``."

#~ msgid "``zeroes``"
#~ msgstr "``zeroes``"

#~ msgid ""
#~ "Only supported for strings.  If true, embedded NUL bytes (``'\\\\0'``) "
#~ "are permitted inside the value.  The length of the string will be passed "
#~ "in to the impl function, just after the string parameter, as a parameter "
#~ "named ``<parameter_name>_length``."
#~ msgstr ""
#~ "Autorisé seulement pour les chaînes de caractères. Si vrai, les octets "
#~ "NUL (``'\\\\0'``) sont permis au sein de la valeur. La taille de la "
#~ "chaîne sera passée à la fonction ``impl``, juste après le paramètre "
#~ "chaîne, en tant que paramètre nommé ``<parameter_name>_length``."

#~ msgid ""
#~ "Please note, not every possible combination of arguments will work. "
#~ "Usually these arguments are implemented by specific ``PyArg_ParseTuple`` "
#~ "*format units*, with specific behavior.  For example, currently you "
#~ "cannot call ``unsigned_short`` without also specifying ``bitwise=True``. "
#~ "Although it's perfectly reasonable to think this would work, these "
#~ "semantics don't map to any existing format unit.  So Argument Clinic "
#~ "doesn't support it.  (Or, at least, not yet.)"
#~ msgstr ""
#~ "Attention de bien noter que toutes les combinaisons d'arguments ne "
#~ "fonctionnent pas. Normalement, ces arguments sont mis en place via des "
#~ "*formats* ``PyArg_ParseTuple`` au comportement spécifique. Par exemple, à "
#~ "l'heure actuelle vous ne pouvez pas appeler ``unsigned_short`` sans "
#~ "spécifier également ``bitwise=True``. Bien qu'il soit parfaitement "
#~ "raisonnable de penser que ça puisse fonctionner, cette écriture ne "
#~ "correspond à aucun format. Donc Argument Clinic ne le gère pas (en tous "
#~ "cas, pas pour le moment)."

#~ msgid ""
#~ "Below is a table showing the mapping of legacy converters into real "
#~ "Argument Clinic converters.  On the left is the legacy converter, on the "
#~ "right is the text you'd replace it with."
#~ msgstr ""
#~ "Vous pouvez voir, ci-dessous, une table présentant la correspondance "
#~ "entre les adaptateurs de base et ceux d'Argument Clinic. À gauche, sont "
#~ "listés les adaptateurs de base et, à droite, le texte qui les remplace."

#~ msgid "``'B'``"
#~ msgstr "``'B'``"

#~ msgid "``unsigned_char(bitwise=True)``"
#~ msgstr "``unsigned_char(bitwise=True)``"

#~ msgid "``'b'``"
#~ msgstr "``'b'``"

#~ msgid "``unsigned_char``"
#~ msgstr "``unsigned_char``"

#~ msgid "``'c'``"
#~ msgstr "``'c'``"

#~ msgid "``char``"
#~ msgstr "``char``"

#~ msgid "``'C'``"
#~ msgstr "``'C'``"

#~ msgid "``int(accept={str})``"
#~ msgstr "``int(accept={str})``"

#~ msgid "``'d'``"
#~ msgstr "``'d'``"

#~ msgid "``double``"
#~ msgstr "``double``"

#~ msgid "``'D'``"
#~ msgstr "``'D'``"

#~ msgid "``Py_complex``"
#~ msgstr "``Py_complex``"

#~ msgid "``'es'``"
#~ msgstr "``'es'``"

#~ msgid "``str(encoding='name_of_encoding')``"
#~ msgstr "``str(encoding='name_of_encoding')``"

#~ msgid "``'es#'``"
#~ msgstr "``'es#'``"

#~ msgid "``str(encoding='name_of_encoding', zeroes=True)``"
#~ msgstr "``str(encoding='name_of_encoding', zeroes=True)``"

#~ msgid "``'et'``"
#~ msgstr "``'et'``"

#~ msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
#~ msgstr ""
#~ "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"

#~ msgid "``'et#'``"
#~ msgstr "``'et#'``"

#~ msgid ""
#~ "``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
#~ "zeroes=True)``"
#~ msgstr ""
#~ "``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
#~ "zeroes=True)``"

#~ msgid "``'f'``"
#~ msgstr "``'f'``"

#~ msgid "``float``"
#~ msgstr "``float``"

#~ msgid "``'h'``"
#~ msgstr "``'h'``"

#~ msgid "``short``"
#~ msgstr "``short``"

#~ msgid "``'H'``"
#~ msgstr "``'H'``"

#~ msgid "``unsigned_short(bitwise=True)``"
#~ msgstr "``unsigned_short(bitwise=True)``"

#~ msgid "``'i'``"
#~ msgstr "``'i'``"

#~ msgid "``int``"
#~ msgstr "``int``"

#~ msgid "``'I'``"
#~ msgstr "``'I'``"

#~ msgid "``unsigned_int(bitwise=True)``"
#~ msgstr "``unsigned_int(bitwise=True)``"

#~ msgid "``'k'``"
#~ msgstr "``'k'``"

#~ msgid "``unsigned_long(bitwise=True)``"
#~ msgstr "``unsigned_long(bitwise=True)``"

#~ msgid "``'K'``"
#~ msgstr "``'K'``"

#~ msgid "``unsigned_long_long(bitwise=True)``"
#~ msgstr "``unsigned_long_long(bitwise=True)``"

#~ msgid "``'l'``"
#~ msgstr "``'l'``"

#~ msgid "``long``"
#~ msgstr "``long``"

#~ msgid "``'L'``"
#~ msgstr "``'L'``"

#~ msgid "``long long``"
#~ msgstr "``long long``"

#~ msgid "``'n'``"
#~ msgstr "``'n'``"

#~ msgid "``Py_ssize_t``"
#~ msgstr "``Py_ssize_t``"

#~ msgid "``'O'``"
#~ msgstr "``'O'``"

#~ msgid "``object``"
#~ msgstr "``object``"

#~ msgid "``'O!'``"
#~ msgstr "``'O!'``"

#~ msgid "``object(subclass_of='&PySomething_Type')``"
#~ msgstr "``object(subclass_of='&PySomething_Type')``"

#~ msgid "``'O&'``"
#~ msgstr "``'O&'``"

#~ msgid "``object(converter='name_of_c_function')``"
#~ msgstr "``object(converter='name_of_c_function')``"

#~ msgid "``'p'``"
#~ msgstr "``'p'``"

#~ msgid "``bool``"
#~ msgstr "``bool``"

#~ msgid "``'S'``"
#~ msgstr "``'S'``"

#~ msgid "``PyBytesObject``"
#~ msgstr "``PyBytesObject``"

#~ msgid "``'s'``"
#~ msgstr "``'s'``"

#~ msgid "``str``"
#~ msgstr "``str``"

#~ msgid "``'s#'``"
#~ msgstr "``'s#'``"

#~ msgid "``str(zeroes=True)``"
#~ msgstr "``str(zeroes=True)``"

#~ msgid "``'s*'``"
#~ msgstr "``'s*'``"

#~ msgid "``Py_buffer(accept={buffer, str})``"
#~ msgstr "``Py_buffer(accept={buffer, str})``"

#~ msgid "``'U'``"
#~ msgstr "``'U'``"

#~ msgid "``unicode``"
#~ msgstr "``unicode``"

#~ msgid "``'u'``"
#~ msgstr "``'u'``"

#~ msgid "``Py_UNICODE``"
#~ msgstr "``Py_UNICODE``"

#~ msgid "``'u#'``"
#~ msgstr "``'u#'``"

#~ msgid "``Py_UNICODE(zeroes=True)``"
#~ msgstr "``Py_UNICODE(zeroes=True)``"

#~ msgid "``'w*'``"
#~ msgstr "``'w*'``"

#~ msgid "``Py_buffer(accept={rwbuffer})``"
#~ msgstr "``Py_buffer(accept={rwbuffer})``"

#~ msgid "``'Y'``"
#~ msgstr "``'Y'``"

#~ msgid "``PyByteArrayObject``"
#~ msgstr "``PyByteArrayObject``"

#~ msgid "``'y'``"
#~ msgstr "``'y'``"

#~ msgid "``str(accept={bytes})``"
#~ msgstr "``str(accept={bytes})``"

#~ msgid "``'y#'``"
#~ msgstr "``'y#'``"

#~ msgid "``str(accept={robuffer}, zeroes=True)``"
#~ msgstr "``str(accept={robuffer}, zeroes=True)``"

#~ msgid "``'y*'``"
#~ msgstr "``'y*'``"

#~ msgid "``Py_buffer``"
#~ msgstr "``Py_buffer``"

#~ msgid "``'Z'``"
#~ msgstr "``'Z'``"

#~ msgid "``Py_UNICODE(accept={str, NoneType})``"
#~ msgstr "``Py_UNICODE(accept={str, NoneType})``"

#~ msgid "``'Z#'``"
#~ msgstr "``'Z#'``"

#~ msgid "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"
#~ msgstr "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"

#~ msgid "``'z'``"
#~ msgstr "``'z'``"

#~ msgid "``str(accept={str, NoneType})``"
#~ msgstr "``str(accept={str, NoneType})``"

#~ msgid "``'z#'``"
#~ msgstr "``'z#'``"

#~ msgid "``str(accept={str, NoneType}, zeroes=True)``"
#~ msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#~ msgid "``'z*'``"
#~ msgstr "``'z*'``"

#~ msgid "``Py_buffer(accept={buffer, str, NoneType})``"
#~ msgstr "``Py_buffer(accept={buffer, str, NoneType})``"

#~ msgid ""
#~ "As an example, here's our sample ``pickle.Pickler.dump`` using the proper "
#~ "converter::"
#~ msgstr ""
#~ "Par exemple, voici notre code ``pickle.Pickler.dump`` via l'adaptateur "
#~ "approprié ::"

#~ msgid ""
#~ "One advantage of real converters is that they're more flexible than "
#~ "legacy converters.  For example, the ``unsigned_int`` converter (and all "
#~ "the ``unsigned_`` converters) can be specified without ``bitwise=True``.  "
#~ "Their default behavior performs range checking on the value, and they "
#~ "won't accept negative numbers.  You just can't do that with a legacy "
#~ "converter!"
#~ msgstr ""
#~ "Un avantage des adaptateurs réels est qu'ils sont plus flexibles que les "
#~ "adaptateurs de base. Par exemple, l'adaptateur ``unsigned_int`` (ainsi "
#~ "que tous les adaptateurs ``unsigned_``) peut être utilisé sans "
#~ "``bitwise=True``. Leur comportement par défaut contrôle la valeur, et "
#~ "n'acceptera pas de nombres négatifs. On ne peut pas faire ça avec les "
#~ "adaptateurs de base !"

#~ msgid ""
#~ "Argument Clinic will show you all the converters it has available.  For "
#~ "each converter it'll show you all the parameters it accepts, along with "
#~ "the default value for each parameter. Just run ``Tools/clinic/clinic.py --"
#~ "converters`` to see the full list."
#~ msgstr ""
#~ "Argument Clinic sait lister tous les adaptateurs disponibles. Pour chaque "
#~ "adaptateur, il vous liste également l'ensemble des paramètres qu'ils "
#~ "acceptent, ainsi que les valeurs par défaut de chacun. Utilisez "
#~ "simplement la commande ``Tools/clinic/clinic.py --converters`` pour "
#~ "afficher la liste."

#~ msgid ""
#~ "When using the ``Py_buffer`` converter (or the ``'s*'``, ``'w*'``, "
#~ "``'*y'``, or ``'z*'`` legacy converters), you *must* not call :c:func:"
#~ "`PyBuffer_Release` on the provided buffer. Argument Clinic generates code "
#~ "that does it for you (in the parsing function)."
#~ msgstr ""
#~ "Lorsque vous utilisez l'adaptateur ``Py_buffer`` (ou bien les adaptateurs "
#~ "de base ``'s*'``, ``'w*'``, ``'*y'``, ou ``'z*'``), vous *ne devez pas* "
#~ "appeler :c:func:`PyBuffer_Release` sur le tampon fourni. Argument Clinic "
#~ "génère du code qui le fait pour vous (dans la fonction d'analyse)."

#, fuzzy
#~ msgid "How to use advanced converters"
#~ msgstr "Adaptateurs avancés"

#~ msgid ""
#~ "Remember those format units you skipped for your first time because they "
#~ "were advanced?  Here's how to handle those too."
#~ msgstr ""
#~ "Vous vous souvenez de ces spécifications de format que vous avez laissées "
#~ "de côté la première fois parce qu'il s'agissait de notions avancées ? "
#~ "Voici comment les utiliser."

#~ msgid ""
#~ "The trick is, all those format units take arguments—either conversion "
#~ "functions, or types, or strings specifying an encoding. (But \"legacy "
#~ "converters\" don't support arguments.  That's why we skipped them for "
#~ "your first function.)  The argument you specified to the format unit is "
#~ "now an argument to the converter; this argument is either ``converter`` "
#~ "(for ``O&``), ``subclass_of`` (for ``O!``), or ``encoding`` (for all the "
#~ "format units that start with ``e``)."
#~ msgstr ""
#~ "L'astuce est que toutes ces spécifications de format acceptent des "
#~ "arguments — aussi bien des fonctions de conversion que des types, ou des "
#~ "chaînes spécifiant un encodage. (mais les « adaptateurs de base » ne "
#~ "gèrent pas les arguments. C'est pourquoi nous les avions laissés de côté "
#~ "pour votre première fonction.) L'argument que vous aviez spécifié à la "
#~ "spécification de format est désormais un argument du convertisseur ; cet "
#~ "argument est soit ``converter`` (pour ``O&``), ``subclass_of`` (pour ``O!"
#~ "``), ou ``encoding`` (pour toutes les spécifications de format qui "
#~ "commencent par ``e``)."

#~ msgid ""
#~ "When using ``subclass_of``, you may also want to use the other custom "
#~ "argument for ``object()``: ``type``, which lets you set the type actually "
#~ "used for the parameter.  For example, if you want to ensure that the "
#~ "object is a subclass of ``PyUnicode_Type``, you probably want to use the "
#~ "converter ``object(type='PyUnicodeObject *', "
#~ "subclass_of='&PyUnicode_Type')``."
#~ msgstr ""
#~ "Lorsque vous utilisez ``subclass_of``, vous pouvez également vouloir "
#~ "utiliser les autres arguments usuels pour ``object()`` : ``type``, qui "
#~ "vous laisse spécifier le type à utiliser pour l'argument. Par exemple, si "
#~ "vous voulez vous assurer que l'objet est une sous-classe de "
#~ "``PyUnicode_Type``, vous utiliserez probablement le convertisseur "
#~ "``object(type='PyUnicodeObject *', subclass_of='&PyUnicode_Type')``."

#~ msgid ""
#~ "One possible problem with using Argument Clinic: it takes away some "
#~ "possible flexibility for the format units starting with ``e``.  When "
#~ "writing a ``PyArg_Parse`` call by hand, you could theoretically decide at "
#~ "runtime what encoding string to pass in to :c:func:`PyArg_ParseTuple`.   "
#~ "But now this string must be hard-coded at Argument-Clinic-preprocessing-"
#~ "time.  This limitation is deliberate; it made supporting this format unit "
#~ "much easier, and may allow for future optimizations. This restriction "
#~ "doesn't seem unreasonable; CPython itself always passes in static hard-"
#~ "coded encoding strings for parameters whose format units start with ``e``."
#~ msgstr ""
#~ "Mentionnons un problème potentiel d'utiliser *Argument Clinic* : cela "
#~ "retire la flexibilité des spécifications de format commençant par ``e``. "
#~ "Lorsque vous faites un appel à ``PyArg_Parse`` à la main, vous pourriez "
#~ "théoriquement décider quelle chaîne d'encodage passer à :c:func:"
#~ "`PyArg_ParseTuple`. Mais désormais cette chaîne doit être codée en dur au "
#~ "moment du pré-processus d'Argument-Clinic. Cette limitation est "
#~ "délibérée ; elle permet une gestion plus simple de cette spécification de "
#~ "format, et peut permettre de futures optimisations. Cette restriction ne "
#~ "semble pas déraisonnable ; CPython lui-même utilise toujours des chaînes "
#~ "d'encodage en dur pour les paramètres dont les spécifications de format "
#~ "commencent par ``e``."

#~ msgid ""
#~ "Default values for parameters can be any of a number of values. At their "
#~ "simplest, they can be string, int, or float literals:"
#~ msgstr ""
#~ "Les valeurs par défaut des paramètres peuvent être n'importe quelle "
#~ "valeur. Au plus simple, ce sont des chaînes, des entiers ou des nombres "
#~ "flottants :"

#~ msgid "They can also use any of Python's built-in constants:"
#~ msgstr ""
#~ "Vous pouvez également utiliser n'importe quelle constante native de "
#~ "Python :"

#~ msgid ""
#~ "There's also special support for a default value of ``NULL``, and for "
#~ "simple expressions, documented in the following sections."
#~ msgstr ""
#~ "La valeur ``NULL`` est également acceptée, ainsi que des expressions "
#~ "simples, comme expliqué dans les sections suivantes."

#~ msgid "The ``NULL`` default value"
#~ msgstr "La valeur par défaut ``NULL``"

#~ msgid ""
#~ "For string and object parameters, you can set them to ``None`` to "
#~ "indicate that there's no default.  However, that means the C variable "
#~ "will be initialized to ``Py_None``.  For convenience's sakes, there's a "
#~ "special value called ``NULL`` for just this reason: from Python's "
#~ "perspective it behaves like a default value of ``None``, but the C "
#~ "variable is initialized with ``NULL``."
#~ msgstr ""
#~ "Pour les paramètres chaînes et objets, vous pouvez les positionner à "
#~ "``None`` pour indiquer qu'il n'y a pas de valeur par défaut. Pour autant, "
#~ "cela signifie que la variable C sera initialisée à ``Py_None``. Par "
#~ "commodité, il existe une valeur spécifique appelée ``NULL`` juste pour "
#~ "cette raison : du point de vue de Python, cette valeur se comporte comme "
#~ "la valeur par défaut ``None``, mais la variable C est initialisée à "
#~ "``NULL``."

#~ msgid "Symbolic default values"
#~ msgstr "Valeurs par défaut"

#~ msgid ""
#~ "The default value you provide for a parameter can't be any arbitrary "
#~ "expression.  Currently the following are explicitly supported:"
#~ msgstr ""
#~ "La valeur par défaut que vous fournissez pour un paramètre ne peut pas "
#~ "être n'importe quelle expression. Actuellement, ce qui est géré :"

#~ msgid "Numeric constants (integer and float)"
#~ msgstr "Constantes numériques (entier ou nombre flottant)"

#~ msgid "String constants"
#~ msgstr "Chaînes constantes"

#~ msgid "``True``, ``False``, and ``None``"
#~ msgstr "``True``, ``False`` et ``None``"

#~ msgid ""
#~ "Simple symbolic constants like ``sys.maxsize``, which must start with the "
#~ "name of the module"
#~ msgstr ""
#~ "Constantes symboliques simples comme ``sys.maxsize``, qui doivent "
#~ "commencer par le nom du module"

#~ msgid ""
#~ "(In the future, this may need to get even more elaborate, to allow full "
#~ "expressions like ``CONSTANT - 1``.)"
#~ msgstr ""
#~ "(Dans le futur, il est possible que l'on ait besoin de l'améliorer, pour "
#~ "autoriser les expressions complètes comme ``CONSTANT - 1``.)"

#, fuzzy
#~ msgid "Expressions as default values"
#~ msgstr "Expressions spécifiées comme valeurs par défaut"

#~ msgid ""
#~ "The default value for a parameter can be more than just a literal value. "
#~ "It can be an entire expression, using math operators and looking up "
#~ "attributes on objects.  However, this support isn't exactly simple, "
#~ "because of some non-obvious semantics."
#~ msgstr ""
#~ "La valeur par défaut d'un paramètre peut être plus qu'une simple valeur "
#~ "littérale. Il peut s'agir d'une expression, utilisant des opérateurs "
#~ "mathématiques et des attributs d'objets. Cependant, cette possibilité "
#~ "n'est pas aussi simple, notamment à cause de sémantiques peu évidentes."

#~ msgid "Consider the following example:"
#~ msgstr "Examinons l'exemple suivant :"

#~ msgid "Function calls."
#~ msgstr "des appels de fonction."

#~ msgid "Inline if statements (``3 if foo else 5``)."
#~ msgstr "des instructions *if* en ligne (``3 if foo else 5``) ;"

#, fuzzy
#~ msgid "For example:"
#~ msgstr "Échantillon ::"

#~ msgid "Converting Your First Function"
#~ msgstr "Convertissez votre première fonction"

#~ msgid "Advanced Topics"
#~ msgstr "Sujets avancés"

#~ msgid ""
#~ "Now that you've had some experience working with Argument Clinic, it's "
#~ "time for some advanced topics."
#~ msgstr ""
#~ "Maintenant que vous avez un peu d'expérience avec Argument Clinic, c'est "
#~ "le moment pour des sujets avancés."

#~ msgid "Py_buffer"
#~ msgstr "Py_buffer"

#~ msgid "Parameter default values"
#~ msgstr "Valeurs par défaut des paramètres"

#~ msgid ""
#~ "In case you're curious, this is implemented in  ``from_builtin()`` in "
#~ "``Lib/inspect.py``."
#~ msgstr ""
#~ "Si par curiosité vous voulez lire l'implémentation, c'est "
#~ "``from_builtin()`` dans ``Lib/inspect.py``."
