# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-07-23 14:38+0200\n"
"PO-Revision-Date: 2023-07-21 12:47+0200\n"
"Last-Translator: \n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.1\n"

#: howto/enum.rst:3
msgid "Enum HOWTO"
msgstr "Guide sur l'utilisation d'*Enum*"

#: howto/enum.rst:9
msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful :func:"
"`repr()`, grouping, type-safety, and a few other features."
msgstr ""
"Une :class:`Enum` est un ensemble de noms symboliques associés à des valeurs "
"uniques. Elles sont similaires aux variables globales, mais elles offrent "
"des particularités utiles telles qu'une meilleure :func:`repr()`, le "
"regroupement, une sécurité concernant le typage et quelques autres "
"fonctionnalités."

#: howto/enum.rst:13
msgid ""
"They are most useful when you have a variable that can take one of a limited "
"selection of values.  For example, the days of the week::"
msgstr ""
"Elles sont particulièrement utiles lorsque vous avez une variable qui peut "
"prendre une valeur dans une plage limitée de valeurs. Par exemple, les jours "
"de la semaine ::"

#: howto/enum.rst:26
msgid "Or perhaps the RGB primary colors::"
msgstr "Ou alors les couleurs primaires *RVB* (NdT : *RGB* en anglais) ::"

#: howto/enum.rst:34
msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr ""
"Comme vous pouvez le voir, créer une :class:`Enum` est très simple à écrire, "
"il suffit qu'elle hérite de :class:`Enum` elle-même."

# suit un :
#: howto/enum.rst:37
msgid "Case of Enum Members"
msgstr "casse des membres d'une énumération"

#: howto/enum.rst:39
msgid ""
"Because Enums are used to represent constants we recommend using UPPER_CASE "
"names for members, and will be using that style in our examples."
msgstr ""
"Étant donné que les énumérations sont utilisées pour représenter des "
"constantes, nous vous recommandons d'utiliser des noms en MAJUSCULES pour "
"les membres, et nous utiliserons ce style dans nos exemples."

#: howto/enum.rst:42
msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr ""
"Selon la nature de l'énumération, il peut être important d'avoir accès à la "
"valeur d'un membre. Dans tous les cas, cette valeur peut être utilisée pour "
"obtenir le membre correspondant ::"

#: howto/enum.rst:49
msgid ""
"As you can see, the ``repr()`` of a member shows the enum name, the member "
"name, and the value.  The ``str()`` of a member shows only the enum name and "
"member name::"
msgstr ""
"Comme vous pouvez le constater, la ``repr()`` d'un membre affiche le nom de "
"l'énumération, le nom du membre et la valeur. La ``str()`` d'un membre "
"affiche uniquement le nom de l'énumération et le nom du membre ::"

#: howto/enum.rst:56
msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr ""
"Le *type* d'un membre d'énumération est l'énumération à laquelle il "
"appartient ::"

#: howto/enum.rst:63
msgid "Enum members have an attribute that contains just their :attr:`name`::"
msgstr ""
"Les membres d'une énumération possèdent un attribut :attr:`name` qui "
"contient leur nom ::"

#: howto/enum.rst:68
msgid "Likewise, they have an attribute for their :attr:`value`::"
msgstr "De même, ils ont un attribut :attr:`value` pour leur valeur ::"

#: howto/enum.rst:74
msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`weekday` and :meth:"
"`isoweekday`. The difference is that one of them counts from 0-6 and the "
"other from 1-7. Rather than keep track of that ourselves we can add a method "
"to the :class:`Weekday` enum to extract the day from the :class:`date` "
"instance and return the matching enum member::"
msgstr ""
"Contrairement à de nombreux langages qui traitent les énumérations "
"uniquement comme des paires nom-valeur, le comportement des énumérations "
"Python peut être augmenté. Par exemple, :class:`datetime.date` a deux "
"méthodes pour renvoyer le jour de la semaine : :meth:`weekday` et :meth:"
"`isoweekday`. La différence est que la première compte de 0 à 6 et la "
"seconde de 1 à 7. Plutôt que d'avoir à nous en rappeler nous-mêmes, nous "
"pouvons ajouter une méthode à l'énumération :class:`Weekday` pour extraire "
"le jour d'une instance :class:`date` et renvoyer le membre correspondant de "
"l'énumération ::"

#: howto/enum.rst:86
msgid "The complete :class:`Weekday` enum now looks like this::"
msgstr ""
"L'énumération :class:`Weekday` en entier ressemble maintenant à ceci ::"

#: howto/enum.rst:101
msgid "Now we can find out what today is!  Observe::"
msgstr ""
"Maintenant, nous pouvons découvrir quel jour nous sommes aujourd'hui ! "
"Regardez ::"

#: howto/enum.rst:107
msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr ""
"Bien sûr, si vous lisez cette page un autre jour, vous verrez ce jour-là à "
"la place."

#: howto/enum.rst:109
msgid ""
"This :class:`Weekday` enum is great if our variable only needs one day, but "
"what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""
"Cette énumération :class:`Weekday` est idéale si notre variable n'a besoin "
"que d'un jour, mais que se passe-t-il si nous en avons besoin de plusieurs ? "
"Par exemple si nous écrivons une fonction pour garder une trace des tâches "
"pendant une semaine, et que nous ne voulons pas utiliser une :class:`list` — "
"nous pouvons utiliser un autre type :class:`Enum` ::"

#: howto/enum.rst:124
msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values "
"are all powers of 2."
msgstr ""
"Nous avons changé deux choses : nous héritons de :class:`Flag` et les "
"valeurs sont toutes des puissances de 2."

#: howto/enum.rst:127
msgid ""
"Just like the original :class:`Weekday` enum above, we can have a single "
"selection::"
msgstr ""
"De la même manière que pour l'énumération originale :class:`Weekday` ci-"
"dessus, nous pouvons sélectionner un seul élément ::"

#: howto/enum.rst:133
msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr ""
"Mais :class:`Flag` nous permet aussi de combiner plusieurs membres en une "
"seule variable ::"

#: howto/enum.rst:140
msgid "You can even iterate over a :class:`Flag` variable::"
msgstr "Nous pouvons même itérer sur une variable :class:`Flag` ::"

#: howto/enum.rst:147
msgid "Okay, let's get some chores set up::"
msgstr "Bien, préparons quelques corvées ::"

#: howto/enum.rst:155
msgid "And a function to display the chores for a given day::"
msgstr "Et une fonction pour afficher les corvées d'un jour donné ::"

#: howto/enum.rst:164
msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto()` for the values::"
msgstr ""
"Au cas où les valeurs réelles des membres n'ont pas d'importance, nous "
"pouvons nous épargner du travail et utiliser :func:`auto()` pour les "
"valeurs ::"

#: howto/enum.rst:183
msgid "Programmatic access to enumeration members and their attributes"
msgstr "Accès par programme aux membres de l'énumération et à leurs attributs"

#: howto/enum.rst:185
msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"Il est parfois utile d'accéder aux membres d'une énumération "
"programmatiquement (c'est-à-dire les cas où ``Color.RED`` ne suffit pas car "
"la couleur exacte n'est pas connue au moment de l'écriture du programme). "
"``Enum`` permet de tels accès ::"

#: howto/enum.rst:194
msgid "If you want to access enum members by *name*, use item access::"
msgstr ""
"Si vous souhaitez accéder aux membres d'une énumération par leur nom, "
"utilisez l'accès par indice ::"

#: howto/enum.rst:201
msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr ""
"Si vous avez un membre d'une énumération et que vous avez besoin de son :"
"attr:`nom <name>` ou de sa :attr:`valeur <value>`, utilisez ses attributs ::"

#: howto/enum.rst:211
msgid "Duplicating enum members and values"
msgstr "Duplication des membres et des valeurs d'une énumération"

#: howto/enum.rst:213
msgid "Having two enum members with the same name is invalid::"
msgstr ""
"Il n'est pas licite d'avoir deux membres d'une énumération avec le même "
"nom ::"

#: howto/enum.rst:223
msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B`` "
"is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""
"Cependant, un membre peut avoir d'autres noms qui lui sont associés. Étant "
"donné deux entrées ``A`` et ``B`` avec la même valeur (et ``A`` définie en "
"premier), ``B`` est un synonyme (ou alias) du membre ``A``. La recherche par "
"valeur de la valeur de ``A`` renvoie le membre ``A``. La recherche par nom "
"de ``A`` renvoie le membre ``A``. La recherche par nom de ``B`` renvoie "
"également le membre ``A`` ::"

# suit un :
#: howto/enum.rst:244
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"tenter de créer un membre portant le même nom qu'un attribut déjà défini (un "
"autre membre, une méthode, etc.) ou tenter de créer un attribut portant le "
"même nom qu'un membre n'est pas autorisé."

#: howto/enum.rst:250
msgid "Ensuring unique enumeration values"
msgstr "Garantie de valeurs d'énumération uniques"

#: howto/enum.rst:252
msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, you can use the :func:`unique` decorator::"
msgstr ""
"Par défaut, les énumérations autorisent plusieurs noms comme synonymes pour "
"la même valeur. Lorsque ce comportement n'est pas souhaité, vous pouvez "
"utiliser le décorateur :func:`unique` ::"

#: howto/enum.rst:269
msgid "Using automatic values"
msgstr "Utilisation de valeurs automatiques"

#: howto/enum.rst:271
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr ""
"Si la valeur exacte n'est pas importante, vous pouvez utiliser :class:"
"`auto` ::"

#: howto/enum.rst:282
msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr ""
"Les valeurs sont choisies par :func:`_generate_next_value_`, qui peut être "
"surchargée ::"

# suit un :
#: howto/enum.rst:300
msgid ""
"The :meth:`_generate_next_value_` method must be defined before any members."
msgstr ""
"la méthode :meth:`_generate_next_value_` doit être définie avant tout membre."

#: howto/enum.rst:303
msgid "Iteration"
msgstr "Itération"

#: howto/enum.rst:305
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr ""
"L'itération sur les membres d'une énumération ne fournit pas les synonymes ::"

#: howto/enum.rst:312
msgid ""
"Note that the aliases ``Shape.ALIAS_FOR_SQUARE`` and ``Weekday.WEEKEND`` "
"aren't shown."
msgstr ""

#: howto/enum.rst:314
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"L'attribut spécial ``__members__`` est un tableau de correspondances ordonné "
"en lecture seule des noms vers les membres. Il inclut tous les noms définis "
"dans l'énumération, y compris les synonymes ::"

#: howto/enum.rst:326
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"L'attribut ``__members__`` peut être utilisé pour un accès programmatique "
"détaillé aux membres de l'énumération. Par exemple, trouver tous les "
"synonymes ::"

#: howto/enum.rst:334
msgid ""
"Aliases for flags include values with multiple flags set, such as ``3``, and "
"no flags set, i.e. ``0``."
msgstr ""

#: howto/enum.rst:339
msgid "Comparisons"
msgstr "Comparaisons"

#: howto/enum.rst:341
msgid "Enumeration members are compared by identity::"
msgstr "Les membres de l'énumération sont comparés par identité ::"

#: howto/enum.rst:350
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"Les comparaisons ordonnées entre les valeurs d'énumération *ne sont pas* "
"prises en charge. Les membres d'une énumération ne sont pas des entiers "
"(mais voir `IntEnum`_ plus bas) ::"

#: howto/enum.rst:358
msgid "Equality comparisons are defined though::"
msgstr "Les comparaisons d'égalité sont cependant définies ::"

#: howto/enum.rst:367
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr ""
"Les comparaisons avec des valeurs en dehors de l'énumération sont toujours "
"fausses (encore une fois, :class:`IntEnum` a été explicitement conçue pour "
"se comporter différemment, voir ci-dessous) ::"

#: howto/enum.rst:376
msgid ""
"It is possible to reload modules -- if a reloaded module contains enums, "
"they will be recreated, and the new members may not compare identical/equal "
"to the original members."
msgstr ""

#: howto/enum.rst:381
msgid "Allowed members and attributes of enumerations"
msgstr "Membres et attributs autorisés des énumérations"

#: howto/enum.rst:383
msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""
"La plupart des exemples ci-dessus utilisent des nombres entiers pour les "
"valeurs d'énumération. L'utilisation d'entiers est rapide et pratique (et "
"fournie par défaut par l'`API fonctionnelle`_), mais n'est pas strictement "
"obligatoire. Dans la grande majorité des cas, on ne se soucie pas de la "
"valeur réelle des membres d'une énumération. Mais si la valeur *est* "
"importante, les énumérations peuvent avoir des valeurs arbitraires."

#: howto/enum.rst:389
msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr ""
"Les énumérations sont des classes Python et peuvent avoir des méthodes ainsi "
"que des méthodes spéciales comme d'habitude. Prenons cette énumération ::"

#: howto/enum.rst:409
msgid "Then::"
msgstr "alors ::"

#: howto/enum.rst:418
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, :meth:"
"`__add__`, etc.), descriptors (methods are also descriptors), and variable "
"names listed in :attr:`_ignore_`."
msgstr ""
"Les règles concernant ce qui est autorisé ou pas sont les suivantes : les "
"noms qui commencent et se terminent par un seul caractère de soulignement "
"sont réservés par l'énumération et ne peuvent pas être utilisés ; tous les "
"autres attributs définis dans une énumération deviendront membres de cette "
"énumération, à l'exception des méthodes spéciales (:meth:`__str__`, :meth:"
"`__add__`, etc.), des descripteurs (les méthodes sont aussi des "
"descripteurs) et des noms de variables listés dans :attr:`_ignore_`."

#: howto/enum.rst:425
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__` "
"then any value(s) given to the enum member will be passed into those "
"methods. See `Planet`_ for an example."
msgstr ""
"Remarque : si votre énumération définit :meth:`__new__` ou :meth:`__init__`, "
"alors toute valeur donnée à un membre de l'énumération sera passée à ces "
"méthodes. Voir `Planète`_ pour un exemple."

#: howto/enum.rst:431
msgid "Restricted Enum subclassing"
msgstr "Restrictions sur la dérivation d'énumérations"

#: howto/enum.rst:433
msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"Une nouvelle classe :class:`Enum` doit avoir une classe mère *Enum*, jusqu'à "
"un type de données concret, et autant de classes mélangées filles de :class:"
"`object` que nécessaire. L'ordre de ces classes mères est ::"

#: howto/enum.rst:440
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr ""
"De plus, la dérivation d'une énumération n'est autorisée que si "
"l'énumération ne définit aucun membre. Donc ceci est interdit ::"

#: howto/enum.rst:450
msgid "But this is allowed::"
msgstr "Mais ceci est autorisé ::"

#: howto/enum.rst:461
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"Autoriser la dérivation d'énumérations qui définissent les membres "
"conduirait à une violation de certains invariants importants des types et "
"des instances. D'un autre côté, il est logique de permettre le partage d'un "
"comportement commun entre un groupe d'énumérations (voir `OrderedEnum`_ pour "
"un exemple)."

#: howto/enum.rst:468
msgid "Pickling"
msgstr "Sérialisation"

#: howto/enum.rst:470
msgid "Enumerations can be pickled and unpickled::"
msgstr "Les énumérations peuvent être sérialisées et désérialisées ::"

#: howto/enum.rst:477
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"Les restrictions habituelles pour la sérialisation s'appliquent : les "
"énumérations sérialisables doivent être définies au niveau supérieur d'un "
"module, car la sérialisation nécessite qu'elles puissent être importées à "
"partir de ce module."

# suit un :
#: howto/enum.rst:483
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"avec la version 4 du protocole *pickle*, il est possible de sérialiser "
"facilement les énumérations imbriquées dans d'autres classes."

#: howto/enum.rst:486
#, fuzzy
msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining :"
"meth:`__reduce_ex__` in the enumeration class.  The default method is by-"
"value, but enums with complicated values may want to use by-name::"
msgstr ""
"Il est possible de modifier la manière dont les membres de l'énumération "
"sont sérialisés-désérialisés en définissant :meth:`__reduce_ex__` dans la "
"classe d'énumération."

#: howto/enum.rst:495
msgid ""
"Using by-name for flags is not recommended, as unnamed aliases will not "
"unpickle."
msgstr ""

#: howto/enum.rst:500
msgid "Functional API"
msgstr "API fonctionnelle"

#: howto/enum.rst:502
msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ""
"La classe :class:`Enum` est appelable, elle fournit l'API fonctionnelle "
"suivante ::"

#: howto/enum.rst:512
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"La sémantique de cette API ressemble à celle des :class:`~collections."
"namedtuple`. Le premier argument de l'appel à :class:`Enum` est le nom de "
"l'énumération."

#: howto/enum.rst:515
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr ""
"Le deuxième argument est la *source* des noms des membres de l'énumération. "
"Il peut s'agir d'une chaîne de noms séparés par des espaces, d'une séquence "
"de noms, d'une séquence de couples clé-valeur, ou d'un tableau de "
"correspondances (par exemple, un dictionnaire) de noms vers des valeurs. Les "
"deux dernières options permettent d'attribuer des valeurs arbitraires aux "
"énumérations ; les autres assignent automatiquement des entiers croissants "
"commençant à 1 (utilisez le paramètre ``start`` pour spécifier une valeur de "
"départ différente). Une nouvelle classe dérivée d':class:`Enum` est "
"renvoyée. En d'autres termes, l'affectation ci-dessus à :class:`Animal` est "
"équivalente à ::"

#: howto/enum.rst:531
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""
"La raison de la valeur par défaut de ``1`` comme numéro de départ et non de "
"``0`` est que le sens booléen de ``0`` est ``False``. Or, par défaut, les "
"membres d'une énumération s'évaluent tous à ``True``."

#: howto/enum.rst:535
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in a separate module, and also may not work on IronPython or "
"Jython). The solution is to specify the module name explicitly as follows::"
msgstr ""
"La sérialisation d'énumérations créées avec l'API fonctionnelle peut être "
"délicat car les détails d'implémentation de la pile d'appels sont utilisés "
"pour essayer de déterminer dans quel module l'énumération est créée (par "
"exemple, cela échoue si vous utilisez une fonction utilitaire dans un module "
"séparé, et peut également ne pas fonctionner sur *IronPython* ou *Jython*). "
"La solution consiste à spécifier explicitement le nom du module comme suit ::"

# suit un :
#: howto/enum.rst:545
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"si le ``module`` n'est pas fourni et qu'*Enum* ne peut pas le déterminer, "
"les nouveaux membres de l'énumération ne pourront pas être sélectionnés ; "
"pour garder les erreurs au plus près de la source, la sérialisation est "
"désactivée."

#: howto/enum.rst:549
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~definition.__qualname__` being set to the location where pickle will be "
"able to find the class.  For example, if the class was made available in "
"class SomeData in the global scope::"
msgstr ""
"Le nouveau protocole *pickle* 4 s'appuie également, dans certaines "
"circonstances, sur :attr:`~definition.__qualname__` qui définit "
"l'emplacement où la sérialisation peut trouver la classe. Par exemple, si la "
"classe a été rendue disponible dans la classe *SomeData* avec une portée "
"globale ::"

#: howto/enum.rst:556
msgid "The complete signature is::"
msgstr "La signature complète est ::"

#: howto/enum.rst:0
msgid "value"
msgstr "*value*"

# suit un :
#: howto/enum.rst:568
msgid "What the new enum class will record as its name."
msgstr "ce que la nouvelle classe *enum* enregistre comme nom."

#: howto/enum.rst:0
msgid "names"
msgstr "*names*"

# suit un :
#: howto/enum.rst:570
msgid ""
"The enum members.  This can be a whitespace- or comma-separated string "
"(values will start at 1 unless otherwise specified)::"
msgstr ""
"les membres de l'énumération. Il peut s'agir d'une chaîne séparée par des "
"espaces ou des virgules (les valeurs commencent à 1 sauf indication "
"contraire) ::"

#: howto/enum.rst:575
msgid "or an iterator of names::"
msgstr "ou un itérateur sur des noms ::"

#: howto/enum.rst:579
msgid "or an iterator of (name, value) pairs::"
msgstr "ou un itérateur sur des paires (nom, valeur) ::"

#: howto/enum.rst:583
msgid "or a mapping::"
msgstr "ou un tableau de correspondances ::"

#: howto/enum.rst:0
msgid "module"
msgstr "*module*"

#: howto/enum.rst:587
msgid "name of module where new enum class can be found."
msgstr "nom du module où la nouvelle classe *enum* peut être trouvée."

#: howto/enum.rst:0
msgid "qualname"
msgstr "*qualname*"

#: howto/enum.rst:589
msgid "where in module new enum class can be found."
msgstr ""
"à quel endroit dans le module la nouvelle classe *enum* peut être trouvée."

#: howto/enum.rst:0
msgid "type"
msgstr "*type*"

#: howto/enum.rst:591
msgid "type to mix in to new enum class."
msgstr "types à mélanger avec la nouvelle classe *enum*."

#: howto/enum.rst:0
msgid "start"
msgstr "*start*"

#: howto/enum.rst:593
msgid "number to start counting at if only names are passed in."
msgstr ""
"nombre à partir duquel commencer à compter si seuls les noms sont transmis."

# suit un :
#: howto/enum.rst:595
msgid "The *start* parameter was added."
msgstr "le paramètre *start* a été ajouté."

#: howto/enum.rst:600
msgid "Derived Enumerations"
msgstr "Déclinaisons d'énumérations"

#: howto/enum.rst:603
msgid "IntEnum"
msgstr "*IntEnum*"

#: howto/enum.rst:605
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr ""
"La première variante de :class:`Enum` fournie est également une sous-classe "
"de :class:`int`. Les membres d'une :class:`IntEnum` peuvent être comparés à "
"des entiers ; par extension, des énumérations *IntEnum* de différents types "
"peuvent aussi être comparées ::"

#: howto/enum.rst:626
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr ""
"Cependant, elles ne peuvent toujours pas être comparées aux énumérations "
"classiques :class:`Enum` ::"

#: howto/enum.rst:639
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ""
"Les valeurs :class:`IntEnum` se comportent comme des entiers, comme vous "
"pouvez vous y attendre ::"

#: howto/enum.rst:650
msgid "StrEnum"
msgstr "*StrEnum*"

#: howto/enum.rst:652
msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass "
"of :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; "
"by extension, string enumerations of different types can also be compared to "
"each other."
msgstr ""
"La deuxième variante de :class:`Enum` fournie est également une sous-classe "
"de :class:`str`. Les membres d'une :class:`StrEnum` peuvent être comparés à "
"des chaînes ; par extension, les énumérations *StrEnum* de différents types "
"peuvent également être comparées les unes aux autres."

#: howto/enum.rst:661
msgid "IntFlag"
msgstr "*IntFlag*"

#: howto/enum.rst:663
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member, if possible.  Like :class:`IntEnum`, :class:"
"`IntFlag` members are also integers and can be used wherever an :class:`int` "
"is used."
msgstr ""
"La variante suivante fournie d':class:`Enum` est :class:`IntFlag`, également "
"basée sur :class:`int`. La différence étant que les membres :class:`IntFlag` "
"peuvent être combinés à l'aide des opérateurs bit-à-bit (&, \\|, ^, ~) et le "
"résultat est toujours un membre :class:`IntFlag`, si possible. Comme :class:"
"`IntEnum`, les membres de :class:`IntFlag` sont aussi des entiers et peuvent "
"être utilisés partout où on utilise un :class:`int`."

# suit un :
#: howto/enum.rst:671
msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr ""
"toute opération sur un membre :class:`IntFlag`, en dehors des opérations bit-"
"à-bit, fait perdre l'appartenance à :class:`IntFlag`."

#: howto/enum.rst:674
msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose "
"the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""
"Les opérations bit-à-bit qui entraînent des valeurs :class:`IntFlag` "
"invalides font perdre l'appartenance à :class:`IntFlag`. Voir :class:"
"`FlagBoundary` pour plus de détails."

#: howto/enum.rst:681
msgid "Sample :class:`IntFlag` class::"
msgstr "Classe exemple dérivée d':class:`Intflag` ::"

#: howto/enum.rst:697
msgid "It is also possible to name the combinations::"
msgstr "Il est également possible de nommer les combinaisons ::"

# suit un :
#: howto/enum.rst:713
msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr ""
"les combinaisons nommées sont considérées être des synonymes (ou alias). Les "
"synonymes n'apparaissent pas dans une itération, mais peuvent être renvoyés "
"à partir de recherches par valeur."

#: howto/enum.rst:718
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
"Une autre différence importante entre :class:`IntFlag` et :class:`Enum` est "
"que si aucun indicateur n'est défini (la valeur est 0), son évaluation "
"booléenne est :data:`False` ::"

#: howto/enum.rst:726
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""
"Comme les membres d'une :class:`IntFlag` sont aussi des sous-classes de :"
"class:`int`, ils peuvent être combinés avec eux (mais peuvent alors perdre "
"l'appartenance à :class:`IntFlag`) ::"

# suit un :
#: howto/enum.rst:737
msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with "
"a positive value::"
msgstr ""
"l'opérateur de négation, ``~``, renvoie toujours un membre :class:`IntFlag` "
"avec une valeur positive ::"

#: howto/enum.rst:743
msgid ":class:`IntFlag` members can also be iterated over::"
msgstr "On peut aussi itérer sur les membres d'une :class:`IntFlag` ::"

#: howto/enum.rst:752
msgid "Flag"
msgstr "*Flag*"

#: howto/enum.rst:754
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"La dernière variante est :class:`Flag`. Comme :class:`IntFlag`, les membres "
"de :class:`Flag` peuvent être combinés à l'aide des opérateurs bit-à-bit (&, "
"\\|, ^, ~). Contrairement à :class:`IntFlag`, ils ne peuvent être combinés "
"ni comparés à aucune autre énumération :class:`Flag`, ni à :class:`int`. "
"Bien qu'il soit possible de spécifier les valeurs directement, il est "
"recommandé d'utiliser :class:`auto` comme valeur et de laisser :class:`Flag` "
"sélectionner une valeur appropriée."

#: howto/enum.rst:763
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"Comme pour :class:`IntFlag`, si une combinaison de membres :class:`Flag` "
"entraîne qu'aucun indicateur n'est défini, l'évaluation booléenne est :data:"
"`False` ::"

#: howto/enum.rst:777
#, fuzzy
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags will not::"
msgstr ""
"Les indicateurs individuels doivent avoir des valeurs qui sont des "
"puissances de deux (1, 2, 4, 8…), tandis que les combinaisons d'indicateurs "
"ne le sont pas ::"

#: howto/enum.rst:789
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr ""
"Donner un nom à la condition « aucun indicateur défini » ne change pas sa "
"valeur booléenne ::"

#: howto/enum.rst:803
msgid ":class:`Flag` members can also be iterated over::"
msgstr "On peut aussi itérer sur les membres d'une :class:`Flag` ::"

# suit un :
#: howto/enum.rst:813
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"pour la majorité du code nouveau, :class:`Enum` et :class:`Flag` sont "
"fortement recommandées, car :class:`IntEnum` et :class:`IntFlag` brisent "
"certaines promesses sémantiques d'une énumération (en pouvant être comparées "
"à des entiers et donc, par transitivité, à d'autres énumérations sans "
"rapport). :class:`IntEnum` et :class:`IntFlag` ne doivent être utilisées que "
"dans les cas où :class:`Enum` et :class:`Flag` ne suffisent pas ; par "
"exemple, lorsque des constantes entières sont remplacées par des "
"énumérations, ou pour l'interopérabilité avec d'autres systèmes."

#: howto/enum.rst:823
msgid "Others"
msgstr "Autres énumérations"

#: howto/enum.rst:825
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
"Bien que :class:`IntEnum` fasse partie du module :mod:`enum`, il serait très "
"simple de l'implémenter indépendamment ::"

#: howto/enum.rst:831
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`FloatEnum` that mixes in :class:`float` instead of :class:"
"`int`."
msgstr ""
"Ceci montre comment définir des énumérations dérivées similaires ; par "
"exemple une :class:`FloatEnum` qui utilise :class:`float` au lieu de :class:"
"`int`."

#: howto/enum.rst:834
msgid "Some rules:"
msgstr "Quelques règles :"

#: howto/enum.rst:836
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before :class:"
"`Enum` itself in the sequence of bases, as in the :class:`IntEnum` example "
"above."
msgstr ""
"Lorsque vous dérivez :class:`Enum`, les classes mères mélangées doivent "
"apparaître avant :class:`Enum` elle-même dans la liste des classes mères, "
"comme dans l'exemple :class:`IntEnum` ci-dessus."

#: howto/enum.rst:839
msgid ""
"Mix-in types must be subclassable. For example, :class:`bool` and :class:"
"`range` are not subclassable and will throw an error during Enum creation if "
"used as the mix-in type."
msgstr ""
"Les types mélangés doivent pouvoir être sous-classés. Par exemple, :class:"
"`bool` et :class:`range` ne peuvent pas être sous-classés et génèrent une "
"erreur lors de la création d'une énumération s'ils sont utilisés comme type "
"de mélange."

#: howto/enum.rst:842
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another type."
msgstr ""
"Alors qu':class:`Enum` peut avoir des membres de n'importe quel type, une "
"fois que vous avez mélangé un type supplémentaire, tous les membres doivent "
"avoir des valeurs de ce type, par exemple :class:`int` ci-dessus. Cette "
"restriction ne s'applique pas aux classes de mélange qui ajoutent uniquement "
"des méthodes et ne spécifient pas d'autre type."

#: howto/enum.rst:846
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr ""
"Lorsqu'un autre type de données est mélangé, l'attribut :attr:`value` n'est "
"*pas le même* que le membre de l'énumération en tant que tel, bien qu'il "
"soit équivalent et renvoie égal lors d'une comparaison."

#: howto/enum.rst:849
msgid "A ``data type`` is a mixin that defines :meth:`__new__`."
msgstr ""

#: howto/enum.rst:850
msgid ""
"%-style formatting:  ``%s`` and ``%r`` call the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` respectively; other codes (such as ``%i`` or "
"``%h`` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""
"Formatage de style % : ``%s`` et ``%r`` appellent respectivement les "
"méthodes :meth:`__str__` et :meth:`__repr__` de la classe :class:`Enum` ; "
"d'autres codes (tels que ``%i`` ou ``%h`` pour *IntEnum*) traitent le membre "
"de l’énumération comme son type mélangé."

#: howto/enum.rst:853
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the enum's :meth:`__str__` method."
msgstr ""
":ref:`Les littéraux de chaîne formatés <f-strings>`, :meth:`str.format` et :"
"func:`format` utilisent la méthode :meth:`__str__` de l'énumération."

# suit un :
#: howto/enum.rst:858
#, fuzzy
msgid ""
"Because :class:`IntEnum`, :class:`IntFlag`, and :class:`StrEnum` are "
"designed to be drop-in replacements for existing constants, their :meth:"
"`__str__` method has been reset to their data types' :meth:`__str__` method."
msgstr ""
"étant donné que :class:`IntEnum`, :class:`IntFlag` et :class:`StrEnum` sont "
"conçus pour remplacer des constantes existantes, leur méthode :meth:"
"`__str__` a été réinitialisée à la méthode :meth:`__str__` de leur type de "
"donnée."

#: howto/enum.rst:864
msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
msgstr "Utilisation de :meth:`__new__` ou de :meth:`__init__`"

#: howto/enum.rst:866
msgid ""
":meth:`__new__` must be used whenever you want to customize the actual value "
"of the :class:`Enum` member.  Any other modifications may go in either :meth:"
"`__new__` or :meth:`__init__`, with :meth:`__init__` being preferred."
msgstr ""
":meth:`__new__` doit être utilisée chaque fois que vous souhaitez "
"personnaliser la valeur réelle des membres d'une :class:`Enum`. Pour les "
"autres personnalisations, elles peuvent être définies dans :meth:`__new__` "
"ou :meth:`__init__`, avec une préférence pour :meth:`__init__`."

#: howto/enum.rst:870
msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr ""
"Par exemple, si vous souhaitez passer plusieurs éléments au constructeur, "
"mais que vous souhaitez qu'un seul d'entre eux soit la valeur ::"

#: howto/enum.rst:897
msgid "Finer Points"
msgstr "Approfondissements"

#: howto/enum.rst:900
msgid "Supported ``__dunder__`` names"
msgstr "Noms de la forme ``__dunder__`` disponibles"

#: howto/enum.rst:902
msgid ""
":attr:`__members__` is a read-only ordered mapping of ``member_name``:"
"``member`` items.  It is only available on the class."
msgstr ""
":attr:`__members__` est un dictionnaire ordonné d'éléments en lecture seule "
"de la forme ``nom_du_membre`` : ``membre``. Il n'est disponible que dans la "
"classe."

#: howto/enum.rst:905
msgid ""
":meth:`__new__`, if specified, must create and return the enum members; it "
"is also a very good idea to set the member's :attr:`_value_` appropriately.  "
"Once all the members are created it is no longer used."
msgstr ""
"La méthode :meth:`__new__`, si elle est définie, doit créer et renvoyer les "
"membres de l'énumération ; affecter correctement l'attribut :attr:`_value_` "
"du membre est également conseillé. Une fois que tous les membres ont été "
"créés, cette méthode n'est plus utilisée."

#: howto/enum.rst:911
msgid "Supported ``_sunder_`` names"
msgstr "Noms de la forme ``_sunder_`` disponibles"

#: howto/enum.rst:913
msgid "``_name_`` -- name of the member"
msgstr "``_name_`` — nom du membre"

#: howto/enum.rst:914
msgid ""
"``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr ""
"``_value_`` — valeur du membre ; il est possible d'y accéder et de la "
"modifier dans ``__new__``"

#: howto/enum.rst:916
msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be "
"overridden"
msgstr ""
"``_missing_`` — fonction de recherche qui est appelée quand la valeur n'est "
"pas trouvée ; elle peut être surchargée"

#: howto/enum.rst:918
msgid ""
"``_ignore_`` -- a list of names, either as a :class:`list` or a :class:"
"`str`, that will not be transformed into members, and will be removed from "
"the final class"
msgstr ""
"``_ignore_`` — liste de noms, sous la forme d'une :func:`list` ou d'une :"
"func:`str`, qui ne sont pas convertis en membres et sont supprimés de la "
"classe résultante"

#: howto/enum.rst:921
msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is consistent "
"(class attribute, removed during class creation)"
msgstr ""
"``_order_`` — utilisé en Python 2 ou 3 pour s'assurer que l'ordre des "
"membres est cohérent (attribut de classe, supprimé durant la création de la "
"classe)"

#: howto/enum.rst:923
msgid ""
"``_generate_next_value_`` -- used by the `Functional API`_ and by :class:"
"`auto` to get an appropriate value for an enum member; may be overridden"
msgstr ""
"``_generate_next_value_`` — utilisé par l'`API fonctionnelle`_ et par :class:"
"`auto` pour obtenir une valeur appropriée pour un membre de l'énumération ; "
"elle peut être surchargée"

# suit un :
#: howto/enum.rst:929
msgid ""
"For standard :class:`Enum` classes the next value chosen is the last value "
"seen incremented by one."
msgstr ""
"pour les classes standard :class:`Enum`, la valeur choisie suivante est la "
"dernière valeur vue incrémentée de un."

#: howto/enum.rst:932
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two, regardless of the last value seen."
msgstr ""
"Pour les classes :class:`Flag`, la valeur choisie suivante est la prochaine "
"puissance de deux la plus élevée, quelle que soit la dernière valeur vue."

#: howto/enum.rst:935
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: howto/enum.rst:936
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: howto/enum.rst:938
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` attribute "
"can be provided.  It will be checked against the actual order of the "
"enumeration and raise an error if the two do not match::"
msgstr ""
"Pour aider à garder le code Python 2 / Python 3 synchronisé, un attribut :"
"attr:`_order_` peut être fourni. Il est vérifié par rapport à l'ordre réel "
"de l'énumération et lève une erreur si les deux ne correspondent pas ::"

# suit un :
#: howto/enum.rst:956
msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition "
"order is lost before it can be recorded."
msgstr ""
"dans le code Python 2, l'attribut :attr:`_order_` est nécessaire car l'ordre "
"de définition est perdu avant de pouvoir être enregistré."

#: howto/enum.rst:961
msgid "_Private__names"
msgstr "*_Private__names*"

#: howto/enum.rst:963
msgid ""
":ref:`Private names <private-name-mangling>` are not converted to enum "
"members, but remain normal attributes."
msgstr ""
":ref:`Les noms privés <private-name-mangling>` ne sont pas convertis en "
"membres de l'énumération, mais restent des attributs normaux."

#: howto/enum.rst:970
msgid "``Enum`` member type"
msgstr "Types des membres d'une ``Enum``"

#: howto/enum.rst:972
#, fuzzy
msgid ""
"Enum members are instances of their enum class, and are normally accessed as "
"``EnumClass.member``.  In certain situations, such as writing custom enum "
"behavior, being able to access one member directly from another is useful, "
"and is supported."
msgstr ""
"Les membres d'une énumération sont des instances de leur classe *Enum* et "
"sont normalement accessibles en tant que ``ClasseEnum.membre``. Dans les "
"versions Python ``3.5`` à ``3.10``, vous pouviez accéder aux membres à "
"partir d'autres membres — cette pratique était déconseillée et dans "
"``3.11`` :class:`Enum` ne l'autorise pas ::"

#: howto/enum.rst:981
msgid "Creating members that are mixed with other data types"
msgstr "Création de membres mélangés avec d'autres types de données"

#: howto/enum.rst:983
msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the ``=`` are passed to that data "
"type's constructor.  For example::"
msgstr ""
"Lorsque vous dérivez d'autres types de données, tels que :class:`int` ou :"
"class:`str`, avec une :class:`Enum`, toutes les valeurs après ``=`` sont "
"passées au constructeur de ce type de données. Par exemple ::"

#: howto/enum.rst:995
msgid "Boolean value of ``Enum`` classes and members"
msgstr "Valeur booléenne des classes et membres ``Enum``"

#: howto/enum.rst:997
msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as :class:"
"`int`, :class:`str`, etc.) are evaluated according to the mixed-in type's "
"rules; otherwise, all members evaluate as :data:`True`.  To make your own "
"enum's boolean evaluation depend on the member's value add the following to "
"your class::"
msgstr ""
"Les classes *Enum* mélangées avec des types non-:class:`Enum` (tels que :"
"class:`int`, :class:`str`, etc.) sont évaluées selon les règles du type "
"mélangé ; sinon, tous les membres sont évalués comme :data:`True`. Pour que "
"l'évaluation booléenne de votre propre énumération dépende de la valeur du "
"membre, ajoutez ce qui suit à votre classe ::"

#: howto/enum.rst:1006
msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr ""
"Les classes simples :class:`Enum` sont toujours évaluées comme :data:`True`."

#: howto/enum.rst:1010
msgid "``Enum`` classes with methods"
msgstr "Méthodes dans les classes ``Enum``"

#: howto/enum.rst:1012
msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"below, those methods will show up in a :func:`dir` of the member, but not of "
"the class::"
msgstr ""
"Si vous dotez votre sous-classe énumération de méthodes supplémentaires, "
"comme la classe `Planet`_ ci-dessous, ces méthodes apparaissent dans le :"
"func:`dir` des membres, mais pas dans celui de la classe ::"

#: howto/enum.rst:1023
msgid "Combining members of ``Flag``"
msgstr "Combinaisons de membres de ``Flag``"

#: howto/enum.rst:1025
msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr ""
"L'itération sur une combinaison de membres :class:`Flag` ne renvoie que les "
"membres dont un seul bit est à 1 ::"

#: howto/enum.rst:1043
msgid "``Flag`` and ``IntFlag`` minutia"
msgstr "Précisions sur ``Flag`` et ``IntFlag``"

#: howto/enum.rst:1045
msgid "Using the following snippet for our examples::"
msgstr "En utilisant l'extrait suivant pour nos exemples ::"

#: howto/enum.rst:1056
msgid "the following are true:"
msgstr "ce qui suit est vrai :"

#: howto/enum.rst:1058
msgid "single-bit flags are canonical"
msgstr "les membres dont un seul bit est à 1 sont canoniques ;"

#: howto/enum.rst:1059
msgid "multi-bit and zero-bit flags are aliases"
msgstr "ceux qui ont plusieurs bits à 1 ou aucun bit à 1 sont des synonymes ;"

#: howto/enum.rst:1060
msgid "only canonical flags are returned during iteration::"
msgstr "seuls les membres canoniques sont renvoyés pendant une itération ::"

#: howto/enum.rst:1065
msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr ""
"la négation d'un membre ou d'une composition de membres renvoie un nouveau "
"membre (ou composition de membres) avec la valeur entière positive "
"correspondante ::"

#: howto/enum.rst:1074
msgid "names of pseudo-flags are constructed from their members' names::"
msgstr ""
"les noms des pseudo-membres sont construits à partir des noms de leurs "
"membres ::"

#: howto/enum.rst:1079
msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr ""
"les membres avec plusieurs bits à 1 (des alias) peuvent être renvoyés par "
"les opérations ::"

#: howto/enum.rst:1090
msgid ""
"membership / containment checking: zero-valued flags are always considered "
"to be contained::"
msgstr ""
"pour la vérification d'appartenance, les membres dont la valeur est 0 sont "
"toujours considérés comme étant membres ::"

#: howto/enum.rst:1096
msgid ""
"otherwise, only if all bits of one flag are in the other flag will True be "
"returned::"
msgstr ""
"sinon, seulement si tous les bits à 1 d'un membre sont aussi à 1 dans "
"l'autre membre, renvoie *True* ::"

#: howto/enum.rst:1105
msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr ""
"Il existe un nouveau mécanisme de délimitation qui contrôle la façon dont "
"les bits hors plage/invalides sont gérés : ``STRICT``, ``CONFORM``, "
"``EJECT`` et ``KEEP`` :"

#: howto/enum.rst:1108
msgid "STRICT --> raises an exception when presented with invalid values"
msgstr ""
"*STRICT* --> lève une exception lorsqu'on lui présente des valeurs invalides"

#: howto/enum.rst:1109
msgid "CONFORM --> discards any invalid bits"
msgstr "*CONFORM* --> ignore les bits invalides"

#: howto/enum.rst:1110
msgid "EJECT --> lose Flag status and become a normal int with the given value"
msgstr ""
"*EJECT* --> la valeur présentée perd le statut de membre et devient un "
"entier normal"

#: howto/enum.rst:1114
msgid "KEEP --> keep the extra bits"
msgstr "*KEEP* --> garde les bits supplémentaires"

#: howto/enum.rst:1112
msgid "keeps Flag status and extra bits"
msgstr "garde le statut de membre avec les bits supplémentaires"

#: howto/enum.rst:1113
msgid "extra bits do not show up in iteration"
msgstr "les bits supplémentaires ne sont pas produits dans une itération"

#: howto/enum.rst:1114
msgid "extra bits do show up in repr() and str()"
msgstr ""
"les bits supplémentaires ne sont pas représentés par *repr()* et *str()*"

#: howto/enum.rst:1116
msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see ``ssl."
"Options`` for an example of when ``KEEP`` is needed)."
msgstr ""
"La valeur par défaut pour *Flag* est ``STRICT``, la valeur par défaut pour "
"``IntFlag`` est ``EJECT`` et la valeur par défaut pour ``_convert_`` est "
"``KEEP`` (voir ``ssl.Options`` pour un exemple de cas où ``KEEP`` est "
"nécessaire)."

#: howto/enum.rst:1124
#, fuzzy
msgid "How are Enums and Flags different?"
msgstr "En quoi les énumérations sont-elles différentes ?"

#: howto/enum.rst:1126
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived :"
"class:`Enum` classes and their instances (members)."
msgstr ""
"Les énumérations ont une métaclasse personnalisée qui modifie de nombreux "
"aspects des classes dérivées d':class:`Enum` et de leurs instances (membres)."

#: howto/enum.rst:1131
msgid "Enum Classes"
msgstr "Classes *Enum*"

#: howto/enum.rst:1133
#, fuzzy
msgid ""
"The :class:`EnumType` metaclass is responsible for providing the :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods that "
"allow one to do things with an :class:`Enum` class that fail on a typical "
"class, such as ``list(Color)`` or ``some_enum_var in Color``.  :class:"
"`EnumType` is responsible for ensuring that various other methods on the "
"final :class:`Enum` class are correct (such as :meth:`__new__`, :meth:"
"`__getnewargs__`, :meth:`__str__` and :meth:`__repr__`)."
msgstr ""
"La métaclasse :class:`EnumType` est chargée de fournir :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` et d'autres méthodes qui "
"permettent de faire des choses avec une classe :class:`Enum` et qui échouent "
"sur une classe typique, telle que ``list(Color)`` ou ``une_variable_enum in "
"Color``. :class:`EnumType` est chargée de s'assurer que diverses autres "
"méthodes de la classe finale :class:`Enum` sont correctes (telles que :meth:"
"`__new__`, :meth:`__getnewargs__`, :meth:`__str__` et :meth:`__repr__`)."

#: howto/enum.rst:1142
#, fuzzy
msgid "Flag Classes"
msgstr "Classes *Enum*"

#: howto/enum.rst:1144
msgid ""
"Flags have an expanded view of aliasing: to be canonical, the value of a "
"flag needs to be a power-of-two value, and not a duplicate name.  So, in "
"addition to the :class:`Enum` definition of alias, a flag with no value (a.k."
"a. ``0``) or with more than one power-of-two value (e.g. ``3``) is "
"considered an alias."
msgstr ""

#: howto/enum.rst:1150
msgid "Enum Members (aka instances)"
msgstr "Membres d'une *Enum* (les instances)"

#: howto/enum.rst:1152
msgid ""
"The most interesting thing about enum members is that they are singletons. :"
"class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`__new__` in place to ensure that no "
"new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"Le plus intéressant à propos des membres d'une énumération est que ce sont "
"des singletons. :class:`EnumType` les crée tous pendant qu'il crée la classe "
"*enum* elle-même, puis met en place une méthode :meth:`__new__` "
"personnalisée pour s'assurer qu'aucun nouveau membre n'est jamais instancié "
"(en renvoyant uniquement les instances de membres existantes)."

#: howto/enum.rst:1158
msgid "Flag Members"
msgstr ""

#: howto/enum.rst:1160
msgid ""
"Flag members can be iterated over just like the :class:`Flag` class, and "
"only the canonical members will be returned.  For example::"
msgstr ""

#: howto/enum.rst:1166
msgid "(Note that ``BLACK``, ``PURPLE``, and ``WHITE`` do not show up.)"
msgstr ""

#: howto/enum.rst:1168
msgid ""
"Inverting a flag member returns the corresponding positive value, rather "
"than a negative value --- for example::"
msgstr ""

#: howto/enum.rst:1174
msgid ""
"Flag members have a length corresponding to the number of power-of-two "
"values they contain.  For example::"
msgstr ""

#: howto/enum.rst:1184
msgid "Enum Cookbook"
msgstr ""

#: howto/enum.rst:1187
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and :"
"class:`IntFlag` are expected to cover the majority of use-cases, they cannot "
"cover them all.  Here are recipes for some different types of enumerations "
"that can be used directly, or as examples for creating one's own."
msgstr ""
":class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag` et :class:"
"`IntFlag` sont censées couvrir la majorité des cas d'utilisation, mais elles "
"ne peuvent pas tout couvrir. Voici quelques recettes pour différents types "
"d'énumérations qui peuvent être utilisées directement, ou pour servir "
"d'exemples afin de créer les vôtres."

#: howto/enum.rst:1194
msgid "Omitting values"
msgstr "Omission de valeurs"

#: howto/enum.rst:1196
msgid ""
"In many use-cases, one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr ""
"Dans de nombreux cas d'utilisation, on ne se soucie pas de la valeur réelle "
"d'une énumération. Il existe plusieurs manières de définir ce type "
"d'énumération simple :"

#: howto/enum.rst:1199
msgid "use instances of :class:`auto` for the value"
msgstr "utilisez des instances d':class:`auto` pour la valeur ;"

#: howto/enum.rst:1200
msgid "use instances of :class:`object` as the value"
msgstr "utilisez des instances d':class:`object` comme valeur ;"

#: howto/enum.rst:1201
msgid "use a descriptive string as the value"
msgstr "utilisez une chaîne de caractères descriptive comme valeur ;"

#: howto/enum.rst:1202
msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the tuple "
"with an :class:`int` value"
msgstr ""
"utilisez un *n*-uplet comme valeur et une :meth:`__new__` personnalisée pour "
"remplacer le *n*-uplet par une valeur :class:`int`."

#: howto/enum.rst:1205
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"L'utilisation de l'une de ces méthodes signifie au lecteur que ces valeurs "
"ne sont pas importantes et permet également d'ajouter, de supprimer ou de "
"réorganiser des membres sans avoir à renuméroter les autres membres."

#: howto/enum.rst:1211
msgid "Using :class:`auto`"
msgstr "Utilisation d':class:`auto`"

#: howto/enum.rst:1213
msgid "Using :class:`auto` would look like::"
msgstr "Voici un exemple où nous utilisons :class:`auto` ::"

#: howto/enum.rst:1225
msgid "Using :class:`object`"
msgstr "Utilisation d':class:`object`"

#: howto/enum.rst:1227
msgid "Using :class:`object` would look like::"
msgstr "Voici un exemple où nous utilisons :class:`object` ::"

#: howto/enum.rst:1237
msgid ""
"This is also a good example of why you might want to write your own :meth:"
"`__repr__`::"
msgstr ""
"Voici un bon exemple montrant pourquoi vouloir écrire sa propre :meth:"
"`__repr__` ::"

#: howto/enum.rst:1253
msgid "Using a descriptive string"
msgstr "Utilisation d'une chaîne de caractères descriptive"

#: howto/enum.rst:1255
msgid "Using a string as the value would look like::"
msgstr "Voici un exemple où nous utilisons une chaîne de caractères ::"

#: howto/enum.rst:1267
msgid "Using a custom :meth:`__new__`"
msgstr "Utilisation d'une méthode :meth:`__new__` personnalisée"

#: howto/enum.rst:1269
msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr "Cette méthode :meth:`__new__` numérote automatiquement ::"

#: howto/enum.rst:1286
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr ""
"Pour créer une ``AutoNumber`` plus générale, ajoutons ``*args`` à la "
"signature ::"

#: howto/enum.rst:1296
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"Ensuite, lorsque nous héritons de ``AutoNumber``, nous pouvons écrire notre "
"propre ``__init__`` pour gérer les arguments supplémentaires ::"

#: howto/enum.rst:1315
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ""
"la méthode :meth:`__new__`, si elle est définie, est utilisée lors de la "
"création des membres de l'énumération ; elle est ensuite remplacée par :meth:"
"`__new__` de l'*Enum* qui est utilisée après la création de la classe pour "
"la recherche des membres existants."

#: howto/enum.rst:1321
msgid "OrderedEnum"
msgstr "Énumération ordonnée"

#: howto/enum.rst:1323
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"Voici une énumération ordonnée qui n'est pas basée sur :class:`IntEnum` et "
"maintient donc les invariants normaux d':class:`Enum` (comme ne pas pouvoir "
"être comparée à d'autres énumérations) ::"

#: howto/enum.rst:1357
msgid "DuplicateFreeEnum"
msgstr "Énumération sans doublon"

# name est bien corrigé par value dans upstream
#: howto/enum.rst:1359
#, fuzzy
msgid ""
"Raises an error if a duplicate member value is found instead of creating an "
"alias::"
msgstr ""
"Lève une erreur si plusieurs membres ont la même valeur, au lieu de créer un "
"synonyme ::"

# suit un :
#: howto/enum.rst:1384
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"c'est un exemple utile de dérivation d'*Enum* pour ajouter ou modifier "
"d'autres comportements ainsi que pour interdire les synonymes. Si le seul "
"changement souhaité est l'interdiction des synonymes, le décorateur :func:"
"`unique` peut être utilisé à la place."

#: howto/enum.rst:1390
msgid "Planet"
msgstr "Planète"

#: howto/enum.rst:1392
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined, the value of the enum "
"member will be passed to those methods::"
msgstr ""
"Si :meth:`__new__` ou :meth:`__init__` est définie, la valeur du membre de "
"l'énumération est passée à ces méthodes ::"

#: howto/enum.rst:1421
msgid "TimePeriod"
msgstr "Intervalle de temps"

#: howto/enum.rst:1423
msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr "Exemple pour montrer l'utilisation de l'attribut :attr:`_ignore_` ::"

#: howto/enum.rst:1442
msgid "Subclassing EnumType"
msgstr "Dérivations d'*EnumType*"

#: howto/enum.rst:1444
msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
"Alors que la plupart des besoins d'énumérations peuvent être satisfaits en "
"sous-classant :class:`Enum`, avec des décorateurs de classe ou des fonctions "
"personnalisées, :class:`EnumType` peut être dérivée pour créer des "
"énumérations vraiment différentes."
