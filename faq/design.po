# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-21 15:04+0200\n"
"PO-Revision-Date: 2021-11-06 13:18+0100\n"
"Last-Translator: Jean Abou Samra <jean@abou-samra.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0\n"

#: faq/design.rst:3
msgid "Design and History FAQ"
msgstr "FAQ sur l'histoire et la conception"

#: faq/design.rst:6
msgid "Contents"
msgstr "Sommaire"

#: faq/design.rst:11
msgid "Why does Python use indentation for grouping of statements?"
msgstr ""
"Pourquoi Python utilise-t-il l'indentation pour grouper les instructions ?"

#: faq/design.rst:13
msgid ""
"Guido van Rossum believes that using indentation for grouping is extremely "
"elegant and contributes a lot to the clarity of the average Python program. "
"Most people learn to love this feature after a while."
msgstr ""
"Guido van Rossum considère que l'usage de l'indentation pour regrouper les "
"blocs d'instruction est élégant et contribue énormément à la clarté d'un "
"programme Python ordinaire. La plupart des gens finissent par aimer cette "
"particularité au bout d'un moment."

#: faq/design.rst:17
msgid ""
"Since there are no begin/end brackets there cannot be a disagreement between "
"grouping perceived by the parser and the human reader.  Occasionally C "
"programmers will encounter a fragment of code like this::"
msgstr ""
"Comme il n'y a pas d'accolades de début et fin, il ne peut y avoir de "
"différence entre le bloc perçu par l'analyseur syntaxique et le lecteur "
"humain. Parfois les programmeurs C pourront trouver un morceau de code comme "
"celui-ci ::"

#: faq/design.rst:26
msgid ""
"Only the ``x++`` statement is executed if the condition is true, but the "
"indentation leads many to believe otherwise.  Even experienced C programmers "
"will sometimes stare at it a long time wondering as to why ``y`` is being "
"decremented even for ``x > y``."
msgstr ""
"Seule l'instruction ``x++`` est exécutée si la condition est vraie, mais "
"l'indentation conduit beaucoup de gens à penser le contraire. Mêmes des "
"développeurs C expérimentés peuvent parfois rester pendant un moment à se "
"demander pourquoi ``y`` est décrémenté même si ``x > y``."

#: faq/design.rst:31
msgid ""
"Because there are no begin/end brackets, Python is much less prone to coding-"
"style conflicts.  In C there are many different ways to place the braces. "
"After becoming used to reading and writing code using a particular style, it "
"is normal to feel somewhat uneasy when reading (or being required to write) "
"in a different one."
msgstr ""
"Comme il n'y a pas d'accolades de début et fin, Python est moins sujet aux "
"conflits de style de code. En C, on peut placer les accolades de nombreuses "
"façons. Après s'être habitué à lire et écrire selon un style particulier, il "
"est normal de se sentir perturbé en lisant (ou en devant écrire) avec un "
"autre style."

#: faq/design.rst:38
msgid ""
"Many coding styles place begin/end brackets on a line by themselves.  This "
"makes programs considerably longer and wastes valuable screen space, making "
"it harder to get a good overview of a program.  Ideally, a function should "
"fit on one screen (say, 20--30 lines).  20 lines of Python can do a lot more "
"work than 20 lines of C.  This is not solely due to the lack of begin/end "
"brackets -- the lack of declarations and the high-level data types are also "
"responsible -- but the indentation-based syntax certainly helps."
msgstr ""
"Nombre de styles de programmation utilisent des accolades de début et fin "
"sur une ligne à part. Cela rend les programmes beaucoup plus longs et fait "
"perdre une bonne partie de l'espace visible sur l'écran, empêchant un peu "
"d'avoir une vue globale du programme. Idéalement, une fonction doit être "
"visible sur un écran (environ 20 ou 30 lignes). 20 lignes de Python peuvent "
"faire beaucoup plus que 20 lignes de C. Ce n'est pas seulement dû à "
"l'absence d'accolades de début et fin — l'absence de déclarations et la "
"présence de types de haut-niveau en sont également responsables — mais la "
"syntaxe basée sur l'indentation aide sûrement."

#: faq/design.rst:48
msgid "Why am I getting strange results with simple arithmetic operations?"
msgstr ""
"Pourquoi ai-je d'étranges résultats suite à de simples opérations "
"arithmétiques ?"

#: faq/design.rst:50
msgid "See the next question."
msgstr "Voir la question suivante."

#: faq/design.rst:54
msgid "Why are floating-point calculations so inaccurate?"
msgstr "Pourquoi les calculs à virgules flottantes sont si imprécis ?"

#: faq/design.rst:56
msgid "Users are often surprised by results like this::"
msgstr "Les gens sont très souvent surpris par des résultats comme celui-ci ::"

#: faq/design.rst:61
msgid ""
"and think it is a bug in Python.  It's not.  This has little to do with "
"Python, and much more to do with how the underlying platform handles "
"floating-point numbers."
msgstr ""
"et pensent que c'est un bogue dans Python. Ça n'en est pas un. Ceci n'a "
"d'ailleurs que peu à voir avec Python, mais avec la manière dont la "
"plateforme sous-jacente gère les nombres à virgule flottante."

#: faq/design.rst:65
msgid ""
"The :class:`float` type in CPython uses a C ``double`` for storage.  A :"
"class:`float` object's value is stored in binary floating-point with a fixed "
"precision (typically 53 bits) and Python uses C operations, which in turn "
"rely on the hardware implementation in the processor, to perform floating-"
"point operations. This means that as far as floating-point operations are "
"concerned, Python behaves like many popular languages including C and Java."
msgstr ""
"La classe :class:`float` dans CPython utilise le type double du langage C "
"comme stockage. La valeur d'un objet :class:`float` est stockée dans un "
"format binaire à virgule flottante avec une précision fixe (généralement 53 "
"bits). Python utilise des opérations qui proviennent du langage C qui à leur "
"tour reposent sur l'implémentation au niveau du processeur afin d'effectuer "
"des opérations en virgule flottante. Cela signifie que, dans le cadre des "
"opérations sur les nombres à virgule flottante, Python se comporte comme "
"beaucoup de langages populaires dont C et Java."

#: faq/design.rst:72
msgid ""
"Many numbers that can be written easily in decimal notation cannot be "
"expressed exactly in binary floating-point.  For example, after::"
msgstr ""
"Beaucoup de nombres pouvant être écrits facilement en notation décimale ne "
"peuvent pas s'exprimer de manière exacte en binaire à virgule flottante. Par "
"exemple, après ::"

#: faq/design.rst:77
msgid ""
"the value stored for ``x`` is a (very good) approximation to the decimal "
"value ``1.2``, but is not exactly equal to it.  On a typical machine, the "
"actual stored value is::"
msgstr ""
"la valeur stockée pour ``x`` est une (très bonne) approximation de la valeur "
"décimale ``1.2``, mais cette valeur n'est pas exacte. Sur une machine "
"typique, la valeur stockée est en fait ::"

#: faq/design.rst:83
msgid "which is exactly::"
msgstr "qui est, exactement ::"

#: faq/design.rst:87
msgid ""
"The typical precision of 53 bits provides Python floats with 15--16 decimal "
"digits of accuracy."
msgstr ""
"La précision typique de 53 bits des *floats* Python permet une précision de "
"15–16 décimales."

#: faq/design.rst:90
msgid ""
"For a fuller explanation, please see the :ref:`floating point arithmetic "
"<tut-fp-issues>` chapter in the Python tutorial."
msgstr ""
"Veuillez vous référer au chapitre sur :ref:`l'arithmétique en nombres à  "
"virgule flottante <tut-fp-issues>` du tutoriel Python pour de plus amples "
"informations."

#: faq/design.rst:95
msgid "Why are Python strings immutable?"
msgstr "Pourquoi les chaînes de caractères Python sont-elles immuables ?"

#: faq/design.rst:97
msgid "There are several advantages."
msgstr "Il y a plusieurs avantages."

#: faq/design.rst:99
msgid ""
"One is performance: knowing that a string is immutable means we can allocate "
"space for it at creation time, and the storage requirements are fixed and "
"unchanging.  This is also one of the reasons for the distinction between "
"tuples and lists."
msgstr ""
"La première concerne la performance : savoir qu'une chaîne de caractères est "
"immuable signifie que l'allocation mémoire allouée lors de la création de "
"cette chaîne est fixe et figée. C'est aussi l'une des raisons pour "
"lesquelles on fait la distinction entre les *n*-uplets et les listes."

#: faq/design.rst:104
msgid ""
"Another advantage is that strings in Python are considered as \"elemental\" "
"as numbers.  No amount of activity will change the value 8 to anything else, "
"and in Python, no amount of activity will change the string \"eight\" to "
"anything else."
msgstr ""
"Un autre avantage est que les chaînes en Python sont considérées aussi "
"« élémentaires » que les nombres. Aucun processus ne changera la valeur du "
"nombre 8 en autre chose et, en Python, aucun processus ne changera la chaîne "
"de caractères \"huit\" en autre chose."

#: faq/design.rst:112
msgid "Why must 'self' be used explicitly in method definitions and calls?"
msgstr ""
"Pourquoi *self* doit-il être explicitement utilisé dans les définitions et "
"les appels de méthodes ?"

#: faq/design.rst:114
msgid ""
"The idea was borrowed from Modula-3.  It turns out to be very useful, for a "
"variety of reasons."
msgstr ""
"L'idée a été empruntée à Modula-3. Cela s'avère très utile, pour diverses "
"raisons."

#: faq/design.rst:117
msgid ""
"First, it's more obvious that you are using a method or instance attribute "
"instead of a local variable.  Reading ``self.x`` or ``self.meth()`` makes it "
"absolutely clear that an instance variable or method is used even if you "
"don't know the class definition by heart.  In C++, you can sort of tell by "
"the lack of a local variable declaration (assuming globals are rare or "
"easily recognizable) -- but in Python, there are no local variable "
"declarations, so you'd have to look up the class definition to be sure.  "
"Some C++ and Java coding standards call for instance attributes to have an "
"``m_`` prefix, so this explicitness is still useful in those languages, too."
msgstr ""
"Tout d'abord, il est plus évident d'utiliser une méthode ou un attribut "
"d'instance par exemple au lieu d'une variable locale. Lire ``self.x`` ou "
"``self.meth()`` est sans ambiguïté sur le fait que c'est une variable "
"d'instance ou une méthode qui est utilisée, même si vous ne connaissez pas "
"la définition de classe par cœur. En C++, vous pouvez les reconnaître par "
"l'absence d'une déclaration de variable locale (en supposant que les "
"variables globales sont rares ou facilement reconnaissables) — mais en "
"Python, il n'y a pas de déclarations de variables locales, de sorte que vous "
"devriez chercher la définition de classe pour être sûr. Certaines normes de "
"programmation C++ et Java préfixent les attributs d'instance par ``m_``. "
"Cette syntaxe explicite est ainsi utile également pour ces langages."

#: faq/design.rst:127
msgid ""
"Second, it means that no special syntax is necessary if you want to "
"explicitly reference or call the method from a particular class.  In C++, if "
"you want to use a method from a base class which is overridden in a derived "
"class, you have to use the ``::`` operator -- in Python you can write "
"``baseclass.methodname(self, <argument list>)``.  This is particularly "
"useful for :meth:`__init__` methods, and in general in cases where a derived "
"class method wants to extend the base class method of the same name and thus "
"has to call the base class method somehow."
msgstr ""
"Ensuite, ça veut dire qu'aucune syntaxe spéciale n'est nécessaire si vous "
"souhaitez explicitement référencer ou appeler la méthode depuis une classe "
"en particulier. En C++, si vous utilisez la méthode d'une classe de base "
"elle-même surchargée par une classe dérivée, vous devez utiliser l'opérateur "
"``::`` — en Python vous pouvez écrire ``ClasseDeBase.nom_methode(self, "
"<argument list>)``. C'est particulièrement utile pour les méthodes :meth:"
"`__init__` et, de manière générale, dans les cas où une classe dérivée veut "
"étendre la méthode du même nom de la classe de base, et doit donc se "
"débrouiller pour appeler la méthode de la classe de base."

#: faq/design.rst:136
msgid ""
"Finally, for instance variables it solves a syntactic problem with "
"assignment: since local variables in Python are (by definition!) those "
"variables to which a value is assigned in a function body (and that aren't "
"explicitly declared global), there has to be some way to tell the "
"interpreter that an assignment was meant to assign to an instance variable "
"instead of to a local variable, and it should preferably be syntactic (for "
"efficiency reasons).  C++ does this through declarations, but Python doesn't "
"have declarations and it would be a pity having to introduce them just for "
"this purpose.  Using the explicit ``self.var`` solves this nicely.  "
"Similarly, for using instance variables, having to write ``self.var`` means "
"that references to unqualified names inside a method don't have to search "
"the instance's directories.  To put it another way, local variables and "
"instance variables live in two different namespaces, and you need to tell "
"Python which namespace to use."
msgstr ""
"Enfin, pour des variables d'instance, ça résout un problème syntactique pour "
"l'assignation : puisque les variables locales en Python sont (par "
"définition !) ces variables auxquelles les valeurs sont assignées dans le "
"corps d'une fonction (et n'étant pas déclarées explicitement globales), il "
"doit y avoir un moyen de dire à l'interpréteur qu'une assignation est censée "
"assigner une variable d'instance plutôt qu'une variable locale, et doit de "
"préférence être syntactique (pour des raisons d'efficacité). C++ fait ça au "
"travers de déclarations, mais Python n'a pas de déclarations et ça serait "
"dommage d'avoir à les introduire juste pour cette raison. Utiliser "
"explicitement ``self.var`` résout ça avec élégance. Pareillement, pour "
"utiliser des variables d'instance, avoir à écrire ``self.var`` signifie que "
"les références vers des noms non-qualifiés au sein d'une méthode n'ont pas à "
"être cherchés dans l'annuaire d'instances. En d'autres termes, les variables "
"locales et les variables d'instance vivent dans deux différents espaces de "
"nommage, et vous devez dire à Python quel espace de nommage utiliser."

#: faq/design.rst:154
msgid "Why can't I use an assignment in an expression?"
msgstr "Pourquoi ne puis-je pas utiliser d'assignation dans une expression ?"

#: faq/design.rst:156
msgid "Starting in Python 3.8, you can!"
msgstr "Depuis Python 3.8, c'est possible !"

#: faq/design.rst:158
msgid ""
"Assignment expressions using the walrus operator `:=` assign a variable in "
"an expression::"
msgstr ""
"Les expressions d'affectation qui utilisent l'opérateur morse `:=` affectent "
"une variable dans une expression ::"

#: faq/design.rst:164
msgid "See :pep:`572` for more information."
msgstr "Voir la :pep:`572` pour plus d'informations."

#: faq/design.rst:169
msgid ""
"Why does Python use methods for some functionality (e.g. list.index()) but "
"functions for other (e.g. len(list))?"
msgstr ""
"Pourquoi Python utilise des méthodes pour certaines fonctionnalités (ex : "
"``list.index()``) mais des fonctions pour d'autres (ex : ``len(list)``) ?"

#: faq/design.rst:171
msgid "As Guido said:"
msgstr "Comme l'a dit Guido :"

#: faq/design.rst:173
msgid ""
"(a) For some operations, prefix notation just reads better than postfix -- "
"prefix (and infix!) operations have a long tradition in mathematics which "
"likes notations where the visuals help the mathematician thinking about a "
"problem. Compare the easy with which we rewrite a formula like x*(a+b) into "
"x*a + x*b to the clumsiness of doing the same thing using a raw OO notation."
msgstr ""
"(a) Pour certaines opérations, la notation préfixe se lit mieux que celle "
"suffixe — les opérations préfixe (et infixe !) sont une longue tradition en "
"mathématique, où on apprécie les notations qui aident visuellement le "
"mathématicien à réfléchir sur un problème. Comparez la facilité avec "
"laquelle nous réécrivons une formule comme x*(a+b) en x*a + x*b à la "
"lourdeur de faire la même chose avec une notation orientée objet brute."

#: faq/design.rst:180
msgid ""
"(b) When I read code that says len(x) I *know* that it is asking for the "
"length of something. This tells me two things: the result is an integer, and "
"the argument is some kind of container. To the contrary, when I read x."
"len(), I have to already know that x is some kind of container implementing "
"an interface or inheriting from a class that has a standard len(). Witness "
"the confusion we occasionally have when a class that is not implementing a "
"mapping has a get() or keys() method, or something that isn't a file has a "
"write() method."
msgstr ""
"(b) Quand je lis du code qui dit ``len(x)`` *je sais* qu'il demande la "
"longueur de quelque chose. Cela me dit deux choses : le résultat est un "
"entier, et l'argument est une sorte de conteneur. Au contraire, quand je lis "
"``x.len()``, je dois déjà savoir que x est une sorte de conteneur "
"implémentant une interface ou héritant d'une classe qui a un ``len()`` "
"standard. Voyez la confusion qui arrive parfois quand une classe qui "
"n'implémente pas une interface de dictionnaire a une méthode ``get()`` ou "
"``key()``, ou quand un objet qui n'est pas un fichier implémente une méthode "
"``write()``."

#: faq/design.rst:207
msgid "https://mail.python.org/pipermail/python-3000/2006-November/004643.html"
msgstr ""
"https://mail.python.org/pipermail/python-3000/2006-November/004643.html"

#: faq/design.rst:193
msgid "Why is join() a string method instead of a list or tuple method?"
msgstr ""
"Pourquoi ``join()`` est une méthode de chaîne plutôt qu'une méthode de liste "
"ou de *n*-uplet ?"

#: faq/design.rst:195
msgid ""
"Strings became much more like other standard types starting in Python 1.6, "
"when methods were added which give the same functionality that has always "
"been available using the functions of the string module.  Most of these new "
"methods have been widely accepted, but the one which appears to make some "
"programmers feel uncomfortable is::"
msgstr ""
"Les chaînes sont devenues bien plus comme d'autres types standards à partir "
"de Python 1.6, lorsque les méthodes ont été ajoutées fournissant ainsi les "
"mêmes fonctionnalités que celles qui étaient déjà disponibles en utilisant "
"les fonctions du module string. La plupart de ces nouvelles méthodes ont été "
"largement acceptées, mais celle qui semble rendre certains programmeurs mal "
"à l'aise est ::"

#: faq/design.rst:203
msgid "which gives the result::"
msgstr "qui donne le résultat ::"

#: faq/design.rst:207
msgid "There are two common arguments against this usage."
msgstr "Il y a deux arguments fréquents contre cet usage."

#: faq/design.rst:209
msgid ""
"The first runs along the lines of: \"It looks really ugly using a method of "
"a string literal (string constant)\", to which the answer is that it might, "
"but a string literal is just a fixed value. If the methods are to be allowed "
"on names bound to strings there is no logical reason to make them "
"unavailable on literals."
msgstr ""
"Le premier argument peut se résumer à : « c'est vraiment moche d'utiliser "
"une méthode de chaîne littérale (c.-à-d. constante) ». La réponse est "
"« certes, mais une chaîne littérale est une valeur comme une autre, juste "
"fixe ». Si on utilise les méthodes sur des noms de variables, il n'y a pas "
"de raison à les interdire sur des chaînes littérales."

#: faq/design.rst:215
msgid ""
"The second objection is typically cast as: \"I am really telling a sequence "
"to join its members together with a string constant\".  Sadly, you aren't.  "
"For some reason there seems to be much less difficulty with having :meth:"
"`~str.split` as a string method, since in that case it is easy to see that ::"
msgstr ""
"Le second consiste à se demander : « suis-je réellement en train de dire à "
"une séquence de joindre ses membres avec une constante de chaîne ? ». "
"Malheureusement, ce n'est pas ça. Allez savoir, il semble être bien moins "
"difficile de comprendre ce qui se passe avec :meth:`~str.split` en tant que "
"méthode de chaîne, puisque dans ce cas il est facile de voir que ::"

#: faq/design.rst:222
msgid ""
"is an instruction to a string literal to return the substrings delimited by "
"the given separator (or, by default, arbitrary runs of white space)."
msgstr ""
"est une instruction à une chaîne littérale de renvoyer les sous-chaînes "
"délimitées par le séparateur fourni (ou, par défaut, les espaces ou groupes "
"d'espaces)."

#: faq/design.rst:225
msgid ""
":meth:`~str.join` is a string method because in using it you are telling the "
"separator string to iterate over a sequence of strings and insert itself "
"between adjacent elements.  This method can be used with any argument which "
"obeys the rules for sequence objects, including any new classes you might "
"define yourself. Similar methods exist for bytes and bytearray objects."
msgstr ""
":meth:`~str.join` est une méthode de chaîne parce qu'en l'utilisant vous "
"dites au séparateur de chaîne d'itérer une séquence de chaînes et de "
"s'insérer entre les éléments adjacents. Cette méthode peut être utilisée "
"avec n'importe quel argument qui obéit aux règles d'objets séquence, "
"incluant n'importe quelles nouvelles classes que vous pourriez définir vous-"
"même. Des méthodes similaires existent pour des objets ``bytes`` et "
"``bytearray``."

#: faq/design.rst:233
msgid "How fast are exceptions?"
msgstr "À quel point les exceptions sont-elles rapides ?"

#: faq/design.rst:235
msgid ""
"A try/except block is extremely efficient if no exceptions are raised.  "
"Actually catching an exception is expensive.  In versions of Python prior to "
"2.0 it was common to use this idiom::"
msgstr ""
"Un bloc ``try`` … ``except`` est extrêmement efficient tant qu'aucune "
"exception n'est levée. En effet, intercepter une exception s'avère coûteux. "
"Dans les versions antérieures à Python 2.0, il était courant d'écrire ceci ::"

#: faq/design.rst:245
msgid ""
"This only made sense when you expected the dict to have the key almost all "
"the time.  If that wasn't the case, you coded it like this::"
msgstr ""
"Cela n'a de sens que si vous vous attendez à ce que le dictionnaire ait la "
"clé presque tout le temps. Si ce n'était pas le cas, vous l'auriez codé "
"comme suit ::"

#: faq/design.rst:253
msgid ""
"For this specific case, you could also use ``value = dict.setdefault(key, "
"getvalue(key))``, but only if the ``getvalue()`` call is cheap enough "
"because it is evaluated in all cases."
msgstr ""
"Pour ce cas, vous pouvez également utiliser ``value = dict.setdefault(key, "
"getvalue(key))``, mais seulement si l'appel à ``getvalue()`` est "
"suffisamment peu coûteux car il est évalué dans tous les cas."

#: faq/design.rst:259
msgid "Why isn't there a switch or case statement in Python?"
msgstr ""
"Pourquoi n'y a-t-il pas une instruction *switch* ou une structure similaire "
"à *switch / case* en Python ?"

#: faq/design.rst:261
msgid ""
"You can do this easily enough with a sequence of ``if... elif... elif... "
"else``. For literal values, or constants within a namespace, you can also "
"use a ``match ... case`` statement."
msgstr ""
"Il est facile de réaliser cette structure avec une suite ``if... elif... "
"elif... else``. Pour comparer à des littéraux, ou à des constantes qui sont "
"encapsulées dans un espace de nommage, on peut aussi utiliser l'instruction "
"``match ... case``."

#: faq/design.rst:265
msgid ""
"For cases where you need to choose from a very large number of "
"possibilities, you can create a dictionary mapping case values to functions "
"to call.  For example::"
msgstr ""
"Dans les cas où vous devez choisir parmi un très grand nombre de "
"possibilités, vous pouvez créer un dictionnaire faisant correspondre des "
"valeurs à des fonctions à appeler. Par exemple ::"

#: faq/design.rst:279
msgid ""
"For calling methods on objects, you can simplify yet further by using the :"
"func:`getattr` built-in to retrieve methods with a particular name::"
msgstr ""
"Pour appeler les méthodes sur des objets, vous pouvez simplifier davantage "
"en utilisant la fonction native :func:`getattr` pour récupérer les méthodes "
"avec un nom donné ::"

#: faq/design.rst:291
msgid ""
"It's suggested that you use a prefix for the method names, such as "
"``visit_`` in this example.  Without such a prefix, if values are coming "
"from an untrusted source, an attacker would be able to call any method on "
"your object."
msgstr ""
"Il est suggéré que vous utilisiez un préfixe pour les noms de méthodes, "
"telles que ``visit_`` dans cet exemple. Sans ce préfixe, si les valeurs "
"proviennent d'une source non fiable, un attaquant serait en mesure d'appeler "
"n'importe quelle méthode sur votre objet."

#: faq/design.rst:297
msgid ""
"Can't you emulate threads in the interpreter instead of relying on an OS-"
"specific thread implementation?"
msgstr ""
"Est-il possible d'émuler des fils d'exécution dans l'interpréteur plutôt que "
"se baser sur les implémentations spécifiques aux systèmes d'exploitation ?"

#: faq/design.rst:299
msgid ""
"Answer 1: Unfortunately, the interpreter pushes at least one C stack frame "
"for each Python stack frame.  Also, extensions can call back into Python at "
"almost random moments.  Therefore, a complete threads implementation "
"requires thread support for C."
msgstr ""
"Réponse 1 : malheureusement, l'interpréteur pousse au moins un bloc de pile "
"C (*stack frame*) pour chaque bloc de pile de Python. Aussi, les extensions "
"peuvent rappeler dans Python à presque n'importe quel moment. Par "
"conséquent, une implémentation complète des fils d'exécution nécessiterait "
"une gestion complète pour le C."

#: faq/design.rst:304
msgid ""
"Answer 2: Fortunately, there is `Stackless Python <https://github.com/"
"stackless-dev/stackless/wiki>`_, which has a completely redesigned "
"interpreter loop that avoids the C stack."
msgstr ""
"Réponse 2 : heureusement, il existe `Stackless Python <https://github.com/"
"stackless-dev/stackless/wiki>`_, qui a complètement ré-architecturé la "
"boucle principale de l'interpréteur afin de ne pas utiliser la pile C."

#: faq/design.rst:309
msgid "Why can't lambda expressions contain statements?"
msgstr ""
"Pourquoi les expressions lambda ne peuvent pas contenir d'instructions ?"

#: faq/design.rst:311
msgid ""
"Python lambda expressions cannot contain statements because Python's "
"syntactic framework can't handle statements nested inside expressions.  "
"However, in Python, this is not a serious problem.  Unlike lambda forms in "
"other languages, where they add functionality, Python lambdas are only a "
"shorthand notation if you're too lazy to define a function."
msgstr ""
"Les expressions lambda de Python ne peuvent pas contenir d'instructions "
"parce que le cadre syntaxique de Python ne peut pas gérer les instructions "
"imbriquées à l'intérieur d'expressions. Cependant, en Python, ce n'est pas "
"vraiment un problème. Contrairement aux formes lambda dans d'autres "
"langages, où elles ajoutent des fonctionnalités,  les expressions lambda de "
"Python sont seulement une notation concise si vous êtes trop paresseux pour "
"définir une fonction."

#: faq/design.rst:317
msgid ""
"Functions are already first class objects in Python, and can be declared in "
"a local scope.  Therefore the only advantage of using a lambda instead of a "
"locally-defined function is that you don't need to invent a name for the "
"function -- but that's just a local variable to which the function object "
"(which is exactly the same type of object that a lambda expression yields) "
"is assigned!"
msgstr ""
"Les fonctions sont déjà des objets de première classe en Python et peuvent "
"être déclarées dans une portée locale. L'unique avantage d'utiliser une "
"fonction lambda au lieu d'une fonction définie localement est que vous "
"n'avez nullement besoin d'un nom pour la fonction — mais c'est juste une "
"variable locale à laquelle est affecté l'objet fonction (qui est exactement "
"le même type d'objet que celui renvoyé par une expression lambda) !"

#: faq/design.rst:325
msgid "Can Python be compiled to machine code, C or some other language?"
msgstr ""
"Python peut-il être compilé en code machine, en C ou dans un autre langage ?"

#: faq/design.rst:327
msgid ""
"`Cython <http://cython.org/>`_ compiles a modified version of Python with "
"optional annotations into C extensions.  `Nuitka <http://www.nuitka.net/>`_ "
"is an up-and-coming compiler of Python into C++ code, aiming to support the "
"full Python language. For compiling to Java you can consider `VOC <https://"
"voc.readthedocs.io>`_."
msgstr ""
"`Cython <http://cython.org/>`_ compile une version modifiée de Python avec "
"des annotations optionnelles en extensions C. `Nuitka <http://www.nuitka.net/"
">`_ est un nouveau compilateur de Python vers C++, visant à supporter le "
"langage Python entièrement. Pour compiler en Java, vous pouvez regarder `VOC "
"<https://voc.readthedocs.io>`_."

#: faq/design.rst:335
msgid "How does Python manage memory?"
msgstr "Comment Python gère la mémoire ?"

#: faq/design.rst:337
msgid ""
"The details of Python memory management depend on the implementation.  The "
"standard implementation of Python, :term:`CPython`, uses reference counting "
"to detect inaccessible objects, and another mechanism to collect reference "
"cycles, periodically executing a cycle detection algorithm which looks for "
"inaccessible cycles and deletes the objects involved. The :mod:`gc` module "
"provides functions to perform a garbage collection, obtain debugging "
"statistics, and tune the collector's parameters."
msgstr ""
"Les détails de la gestion de la mémoire en Python dépendent de "
"l'implémentation. En effet, l'implémentation standard de Python, :term:"
"`CPython`, utilise des compteurs de références afin de détecter des objets "
"inaccessibles et un autre mécanisme pour collecter les références "
"circulaires, exécutant périodiquement un algorithme de détection de cycles "
"qui recherche les cycles inaccessibles et supprime les objets impliqués. Le "
"module :mod:`gc` fournit des fonctions pour lancer le ramasse-miettes, "
"d'obtenir des statistiques de débogage et ajuster ses paramètres."

#: faq/design.rst:345
msgid ""
"Other implementations (such as `Jython <http://www.jython.org>`_ or `PyPy "
"<http://www.pypy.org>`_), however, can rely on a different mechanism such as "
"a full-blown garbage collector.  This difference can cause some subtle "
"porting problems if your Python code depends on the behavior of the "
"reference counting implementation."
msgstr ""
"Cependant, d'autres implémentations (par exemple `Jython <http://www.jython."
"org>`_ ou `PyPy <http://www.pypy.org>`_) peuvent compter sur un mécanisme "
"différent comme un véritable ramasse-miettes. Cette différence peut causer "
"de subtils problèmes de portabilité si votre code Python dépend du "
"comportement de l'implémentation du compteur de références."

#: faq/design.rst:351
msgid ""
"In some Python implementations, the following code (which is fine in "
"CPython) will probably run out of file descriptors::"
msgstr ""
"Dans certaines implémentations de Python, le code suivant (qui fonctionne "
"parfaitement avec *CPython*) aurait probablement manqué de descripteurs de "
"fichiers ::"

#: faq/design.rst:358
msgid ""
"Indeed, using CPython's reference counting and destructor scheme, each new "
"assignment to *f* closes the previous file.  With a traditional GC, however, "
"those file objects will only get collected (and closed) at varying and "
"possibly long intervals."
msgstr ""
"En effet, à l'aide du comptage de références et du destructeur d'objets de "
"*CPython*, chaque nouvelle affectation à *f* ferme le fichier précédent. "
"Cependant, avec un ramasse-miettes classique, ces objets sont collectés (et "
"fermés) à intervalles irréguliers, et potentiellement longs."

#: faq/design.rst:363
msgid ""
"If you want to write code that will work with any Python implementation, you "
"should explicitly close the file or use the :keyword:`with` statement; this "
"will work regardless of memory management scheme::"
msgstr ""
"Si vous souhaitez écrire du code qui fonctionne avec n'importe quelle "
"implémentation de Python, vous devez explicitement fermer le fichier ou "
"utiliser l'instruction :keyword:`with` ; ceci fonctionne indépendamment du "
"système de gestion de la mémoire ::"

#: faq/design.rst:373
msgid "Why doesn't CPython use a more traditional garbage collection scheme?"
msgstr ""
"Pourquoi CPython n'utilise-t-il pas un modèle de ramasse-miettes plus "
"traditionnel ?"

#: faq/design.rst:375
msgid ""
"For one thing, this is not a C standard feature and hence it's not portable. "
"(Yes, we know about the Boehm GC library.  It has bits of assembler code for "
"*most* common platforms, not for all of them, and although it is mostly "
"transparent, it isn't completely transparent; patches are required to get "
"Python to work with it.)"
msgstr ""
"D'une part, ce n'est pas une caractéristique normalisée en C et, par "
"conséquent, ce n'est pas portable. (Oui, nous connaissons la bibliothèque "
"*GC Boehm*. Elle contient du code assembleur pour la plupart des plateformes "
"classiques, mais pas toutes, et bien qu'elle soit le plus souvent "
"transparente, elle ne l'est pas complètement ; des correctifs sont "
"nécessaires afin que Python fonctionne correctement avec.)"

#: faq/design.rst:381
msgid ""
"Traditional GC also becomes a problem when Python is embedded into other "
"applications.  While in a standalone Python it's fine to replace the "
"standard malloc() and free() with versions provided by the GC library, an "
"application embedding Python may want to have its *own* substitute for "
"malloc() and free(), and may not want Python's.  Right now, CPython works "
"with anything that implements malloc() and free() properly."
msgstr ""
"Un ramasse-miettes classique devient également un problème lorsque Python "
"est incorporé dans d'autres applications. Bien que dans une application "
"Python, il ne soit pas gênant de remplacer les fonctions ``malloc()`` et "
"``free()`` avec les versions fournies par la bibliothèque du ramasse-"
"miettes, une application incluant Python peut vouloir avoir ses propres "
"implémentations de ``malloc()`` et ``free()`` et peut ne pas vouloir celles "
"de Python. À l'heure actuelle, CPython fonctionne avec n'importe quelle "
"implémentation correcte de ``malloc()`` et ``free()``."

#: faq/design.rst:390
msgid "Why isn't all memory freed when CPython exits?"
msgstr ""
"Pourquoi toute la mémoire n'est pas libérée lorsque *CPython* s'arrête ?"

#: faq/design.rst:392
msgid ""
"Objects referenced from the global namespaces of Python modules are not "
"always deallocated when Python exits.  This may happen if there are circular "
"references.  There are also certain bits of memory that are allocated by the "
"C library that are impossible to free (e.g. a tool like Purify will complain "
"about these).  Python is, however, aggressive about cleaning up memory on "
"exit and does try to destroy every single object."
msgstr ""
"Les objets référencés depuis les espaces de nommage globaux des modules "
"Python ne sont pas toujours désalloués lorsque Python s'arrête. Cela peut se "
"produire s'il y a des références circulaires. Il y a aussi certaines parties "
"de mémoire qui sont allouées par la bibliothèque C qui sont impossibles à "
"libérer (par exemple un outil comme *Purify* s'en plaindra). Python est, "
"cependant, agressif sur le nettoyage de la mémoire en quittant et cherche à "
"détruire chaque objet."

#: faq/design.rst:399
msgid ""
"If you want to force Python to delete certain things on deallocation use "
"the :mod:`atexit` module to run a function that will force those deletions."
msgstr ""
"Si vous voulez forcer Python à désallouer certains objets en quittant, "
"utilisez le module :mod:`atexit` pour exécuter une fonction qui va forcer "
"ces destructions."

#: faq/design.rst:404
msgid "Why are there separate tuple and list data types?"
msgstr ""
"Pourquoi les *n*-uplets et les *list* sont deux types de données séparés ?"

#: faq/design.rst:406
msgid ""
"Lists and tuples, while similar in many respects, are generally used in "
"fundamentally different ways.  Tuples can be thought of as being similar to "
"Pascal records or C structs; they're small collections of related data which "
"may be of different types which are operated on as a group.  For example, a "
"Cartesian coordinate is appropriately represented as a tuple of two or three "
"numbers."
msgstr ""
"Les listes et les *n*-uplets, bien que semblables à bien des égards, sont "
"généralement utilisés de façons fondamentalement différentes. Les *n*-uplets "
"peuvent être considérés comme étant similaires au *record* en Pascal ou aux "
"structures en C ; ce sont de petites collections de données associées qui "
"peuvent être de différents types qui sont utilisées ensemble. Par exemple, "
"des coordonnées cartésiennes sont correctement représentées par un *n*-uplet "
"de deux ou trois nombres."

#: faq/design.rst:413
msgid ""
"Lists, on the other hand, are more like arrays in other languages.  They "
"tend to hold a varying number of objects all of which have the same type and "
"which are operated on one-by-one.  For example, ``os.listdir('.')`` returns "
"a list of strings representing the files in the current directory.  "
"Functions which operate on this output would generally not break if you "
"added another file or two to the directory."
msgstr ""
"Les listes, ressemblent davantage à des tableaux dans d'autres langages. "
"Elles ont tendance à contenir un nombre variable d'objets de même type "
"manipulés individuellement. Par exemple, ``os.listdir('.')`` renvoie une "
"liste de chaînes représentant les fichiers dans le dossier courant. Les "
"fonctions travaillant sur cette sortie acceptent généralement sans aucun "
"problème que vous ajoutiez un ou deux fichiers supplémentaires dans le "
"dossier."

#: faq/design.rst:420
msgid ""
"Tuples are immutable, meaning that once a tuple has been created, you can't "
"replace any of its elements with a new value.  Lists are mutable, meaning "
"that you can always change a list's elements.  Only immutable elements can "
"be used as dictionary keys, and hence only tuples and not lists can be used "
"as keys."
msgstr ""
"Les *n*-uplets sont immuables, ce qui signifie que lorsqu'un *n*-uplet a été "
"créé, vous ne pouvez remplacer aucun de ses éléments par une nouvelle "
"valeur. Les listes sont muables, ce qui signifie que vous pouvez toujours "
"modifier les éléments d'une liste. Seuls des éléments immuables peuvent être "
"utilisés comme clés de dictionnaires, et donc de ``tuple`` et ``list`` seul "
"des *n*-uplets peuvent être utilisés comme clés."

#: faq/design.rst:427
msgid "How are lists implemented in CPython?"
msgstr "Comment les listes sont-elles implémentées dans CPython ?"

#: faq/design.rst:429
msgid ""
"CPython's lists are really variable-length arrays, not Lisp-style linked "
"lists. The implementation uses a contiguous array of references to other "
"objects, and keeps a pointer to this array and the array's length in a list "
"head structure."
msgstr ""
"Les listes en CPython sont de vrais tableaux de longueur variable "
"contrairement à des listes orientées *Lisp* (c.-à-d. des listes chaînées). "
"L'implémentation utilise un tableau contigu de références à d'autres objets. "
"Elle conserve également un pointeur vers ce tableau et la longueur du "
"tableau dans une structure de tête de liste."

#: faq/design.rst:433
msgid ""
"This makes indexing a list ``a[i]`` an operation whose cost is independent "
"of the size of the list or the value of the index."
msgstr ""
"Cela rend l'indexation d'une liste ``a[i]`` une opération dont le coût est "
"indépendant de la taille de la liste ou de la valeur de l'indice."

#: faq/design.rst:436
msgid ""
"When items are appended or inserted, the array of references is resized.  "
"Some cleverness is applied to improve the performance of appending items "
"repeatedly; when the array must be grown, some extra space is allocated so "
"the next few times don't require an actual resize."
msgstr ""
"Lorsque des éléments sont ajoutés ou insérés, le tableau de références est "
"redimensionné. Un savoir-faire ingénieux permet l'amélioration des "
"performances lors de l'ajout fréquent d'éléments ; lorsque le tableau doit "
"être étendu, un certain espace supplémentaire est alloué de sorte que pour "
"la prochaine fois, ceci ne nécessite plus un redimensionnement effectif."

#: faq/design.rst:443
msgid "How are dictionaries implemented in CPython?"
msgstr "Comment les dictionnaires sont-ils implémentés dans CPython ?"

#: faq/design.rst:445
msgid ""
"CPython's dictionaries are implemented as resizable hash tables.  Compared "
"to B-trees, this gives better performance for lookup (the most common "
"operation by far) under most circumstances, and the implementation is "
"simpler."
msgstr ""
"Les dictionnaires CPython sont implémentés sous forme de tables de hachage "
"redimensionnables.  Par rapport aux *B-trees*, cela donne de meilleures "
"performances pour la recherche (l'opération la plus courante de loin) dans "
"la plupart des circonstances, et leur implémentation est plus simple."

#: faq/design.rst:449
msgid ""
"Dictionaries work by computing a hash code for each key stored in the "
"dictionary using the :func:`hash` built-in function.  The hash code varies "
"widely depending on the key and a per-process seed; for example, \"Python\" "
"could hash to -539294296 while \"python\", a string that differs by a single "
"bit, could hash to 1142331976.  The hash code is then used to calculate a "
"location in an internal array where the value will be stored.  Assuming that "
"you're storing keys that all have different hash values, this means that "
"dictionaries take constant time -- O(1), in Big-O notation -- to retrieve a "
"key."
msgstr ""
"Les dictionnaires fonctionnent en calculant un condensat pour chaque clé "
"stockée dans le dictionnaire à l'aide de la fonction :func:`hash`. La valeur "
"du condensat varie grandement en fonction de la clé et de la graine utilisée "
"par le processus ; par exemple, la chaîne de caractère \"Python\" pourrait "
"avoir comme condensat la valeur – 539 294 296 tandis que la chaîne \"python"
"\",qui diffère de la première par un seul bit, pourrait avoir comme "
"condensat la valeur 1 142 331 976. Le condensat est ensuite utilisé pour "
"déterminer un emplacement dans le tableau interne où la valeur est stockée. "
"Dans l'hypothèse où vous stockez les clés qui ont toutes des condensats "
"différents, cela signifie que le temps pour récupérer une clé est constant — "
"O(1), en notation grand O de Landau."

#: faq/design.rst:460
msgid "Why must dictionary keys be immutable?"
msgstr "Pourquoi les clés du dictionnaire sont immuables ?"

#: faq/design.rst:462
msgid ""
"The hash table implementation of dictionaries uses a hash value calculated "
"from the key value to find the key.  If the key were a mutable object, its "
"value could change, and thus its hash could also change.  But since whoever "
"changes the key object can't tell that it was being used as a dictionary "
"key, it can't move the entry around in the dictionary.  Then, when you try "
"to look up the same object in the dictionary it won't be found because its "
"hash value is different. If you tried to look up the old value it wouldn't "
"be found either, because the value of the object found in that hash bin "
"would be different."
msgstr ""
"L'implémentation de la table de hachage des dictionnaires utilise une valeur "
"de hachage calculée à partir de la valeur de la clé pour trouver la clé elle-"
"même.  Si la clé était un objet muable, sa valeur peut changer, et donc son "
"hachage pourrait également changer.  Mais toute personne modifiant l'objet "
"clé ne peut pas dire qu'elle a été utilisée comme une clé de dictionnaire. "
"Il ne peut déplacer l'entrée dans le dictionnaire.  Ainsi, lorsque vous "
"essayez de rechercher le même objet dans le dictionnaire, il ne sera pas "
"disponible parce que sa valeur de hachage est différente. Si vous essayez de "
"chercher l'ancienne valeur, elle serait également introuvable car la valeur "
"de l'objet trouvé dans cet emplacement de hachage serait différente."

#: faq/design.rst:471
msgid ""
"If you want a dictionary indexed with a list, simply convert the list to a "
"tuple first; the function ``tuple(L)`` creates a tuple with the same entries "
"as the list ``L``.  Tuples are immutable and can therefore be used as "
"dictionary keys."
msgstr ""
"Si vous voulez un dictionnaire indexé avec une liste, il faut simplement "
"convertir la liste en un *n*-uplet ; la fonction ``tuple(L)`` crée un *n*-"
"uplet avec les mêmes entrées que la liste ``L``. Les *n*-uplets sont "
"immuables et peuvent donc être utilisés comme clés du dictionnaire."

#: faq/design.rst:475
msgid "Some unacceptable solutions that have been proposed:"
msgstr "Certaines solutions insatisfaisantes ont été proposées :"

#: faq/design.rst:477
msgid ""
"Hash lists by their address (object ID).  This doesn't work because if you "
"construct a new list with the same value it won't be found; e.g.::"
msgstr ""
"Hacher les listes par leur adresse (*ID* de l'objet). Cela ne fonctionne pas "
"parce que si vous créez une nouvelle liste avec la même valeur, elle ne sera "
"pas retrouvée ; par exemple ::"

#: faq/design.rst:483
msgid ""
"would raise a :exc:`KeyError` exception because the id of the ``[1, 2]`` "
"used in the second line differs from that in the first line.  In other "
"words, dictionary keys should be compared using ``==``, not using :keyword:"
"`is`."
msgstr ""
"lèverait une exception :exc:`KeyError` car l'ID de ``[1, 2]`` utilisé dans "
"la deuxième ligne diffère de celui de la première ligne. En d'autres termes, "
"les clés de dictionnaire doivent être comparées à l'aide du comparateur "
"``==`` et non à l'aide du mot clé :keyword:`is`."

#: faq/design.rst:487
msgid ""
"Make a copy when using a list as a key.  This doesn't work because the list, "
"being a mutable object, could contain a reference to itself, and then the "
"copying code would run into an infinite loop."
msgstr ""
"Faire une copie lors de l'utilisation d'une liste en tant que clé.  Cela ne "
"fonctionne pas puisque la liste, étant un objet muable, pourrait contenir "
"une référence à elle-même ou avoir une boucle infinie au niveau du code "
"copié."

#: faq/design.rst:491
msgid ""
"Allow lists as keys but tell the user not to modify them.  This would allow "
"a class of hard-to-track bugs in programs when you forgot or modified a list "
"by accident. It also invalidates an important invariant of dictionaries: "
"every value in ``d.keys()`` is usable as a key of the dictionary."
msgstr ""
"Autoriser les listes en tant que clés, mais indiquer à l'utilisateur de ne "
"pas les modifier. Cela permettrait un ensemble de bogues difficiles à suivre "
"dans les programmes lorsque vous avez oublié ou modifié une liste par "
"accident. Cela casse également un impératif important des dictionnaires : "
"chaque valeur de ``d.keys()`` est utilisable comme clé du dictionnaire."

#: faq/design.rst:496
msgid ""
"Mark lists as read-only once they are used as a dictionary key.  The problem "
"is that it's not just the top-level object that could change its value; you "
"could use a tuple containing a list as a key.  Entering anything as a key "
"into a dictionary would require marking all objects reachable from there as "
"read-only -- and again, self-referential objects could cause an infinite "
"loop."
msgstr ""
"Marquer les listes comme étant en lecture seule une fois qu'elles sont "
"utilisées comme clé de dictionnaire. Le problème est que ce n'est pas "
"seulement l'objet de niveau supérieur qui pourrait changer sa valeur ; vous "
"pourriez utiliser un *n*-uplet contenant une liste comme clé. Utiliser "
"n'importe quoi comme une clé dans un dictionnaire nécessiterait de marquer "
"tous les objets accessibles à partir de là comme en lecture seule — et "
"encore une fois, les objets se faisant référence pourraient provoquer une "
"boucle infinie."

#: faq/design.rst:502
msgid ""
"There is a trick to get around this if you need to, but use it at your own "
"risk: You can wrap a mutable structure inside a class instance which has "
"both a :meth:`__eq__` and a :meth:`__hash__` method.  You must then make "
"sure that the hash value for all such wrapper objects that reside in a "
"dictionary (or other hash based structure), remain fixed while the object is "
"in the dictionary (or other structure). ::"
msgstr ""
"Il y a un truc pour contourner ceci si vous en avez besoin, mais utilisez-le "
"à vos risques et périls. Vous pouvez encapsuler une structure mutable à "
"l'intérieur d'une instance de classe qui a à la fois une méthode :meth:"
"`__eq__` et :meth:`__hash__`. Vous devez ensuite vous assurer que la valeur "
"de hachage pour tous ces objets *wrapper* qui résident dans un dictionnaire "
"(ou une autre structure basée sur le hachage), restent fixes pendant que "
"l'objet est dans le dictionnaire (ou une autre structure). ::"

#: faq/design.rst:526
msgid ""
"Note that the hash computation is complicated by the possibility that some "
"members of the list may be unhashable and also by the possibility of "
"arithmetic overflow."
msgstr ""
"Notez que le calcul de hachage peut être compliqué car il est possible que "
"certains membres de la liste soient impossibles à hacher et aussi par la "
"possibilité de débordement arithmétique."

#: faq/design.rst:530
msgid ""
"Furthermore it must always be the case that if ``o1 == o2`` (ie ``o1."
"__eq__(o2) is True``) then ``hash(o1) == hash(o2)`` (ie, ``o1.__hash__() == "
"o2.__hash__()``), regardless of whether the object is in a dictionary or "
"not.  If you fail to meet these restrictions dictionaries and other hash "
"based structures will misbehave."
msgstr ""
"De plus, il faut toujours que, si ``o1 == o2`` (par exemple ``o1.__eq__(o2) "
"vaut True``) alors ``hash(o1) == hash(o2)`` (par exemple, ``o1.__hash__() == "
"o2.__hash__()``), que l’objet se trouve dans un dictionnaire ou pas. Si vous "
"ne remplissez pas ces conditions, les dictionnaires et autres structures "
"basées sur le hachage se comporteront mal."

#: faq/design.rst:535
msgid ""
"In the case of ListWrapper, whenever the wrapper object is in a dictionary "
"the wrapped list must not change to avoid anomalies.  Don't do this unless "
"you are prepared to think hard about the requirements and the consequences "
"of not meeting them correctly.  Consider yourself warned."
msgstr ""
"Dans le cas de *ListWrapper*, chaque fois que l'objet *wrapper* est dans un "
"dictionnaire, la liste encapsulée ne doit pas changer pour éviter les "
"anomalies. Ne faites pas cela à moins que vous n’ayez pensé aux potentielles "
"conséquences de ne pas satisfaire entièrement ces conditions. Vous avez été "
"prévenus."

#: faq/design.rst:542
msgid "Why doesn't list.sort() return the sorted list?"
msgstr "Pourquoi ``list.sort()`` ne renvoie pas la liste triée ?"

#: faq/design.rst:544
msgid ""
"In situations where performance matters, making a copy of the list just to "
"sort it would be wasteful. Therefore, :meth:`list.sort` sorts the list in "
"place. In order to remind you of that fact, it does not return the sorted "
"list.  This way, you won't be fooled into accidentally overwriting a list "
"when you need a sorted copy but also need to keep the unsorted version "
"around."
msgstr ""
"Dans les situations où la performance est importante, faire une copie de la "
"liste juste pour la classer serait un gaspillage. Par conséquent, :meth:"
"`list.sort` classe la liste en place. Afin de vous le rappeler, elle ne "
"renvoie pas la liste classée. De cette façon, vous ne serez pas dupés en "
"écrasant accidentellement une liste lorsque vous avez besoin d’une copie "
"triée tout en gardant sous la main la version non triée."

#: faq/design.rst:550
msgid ""
"If you want to return a new list, use the built-in :func:`sorted` function "
"instead.  This function creates a new list from a provided iterable, sorts "
"it and returns it.  For example, here's how to iterate over the keys of a "
"dictionary in sorted order::"
msgstr ""
"Si vous souhaitez qu'une nouvelle liste soit renvoyée, utilisez plutôt la "
"fonction native :func:`sorted`.  Cette fonction crée une nouvelle liste à "
"partir d’un itérable fourni, la classe et la renvoie. Par exemple, voici "
"comment itérer dans l’ordre sur les clés d’un dictionnaire ::"

#: faq/design.rst:560
msgid "How do you specify and enforce an interface spec in Python?"
msgstr ""
"Comment spécifier une interface et appliquer une spécification d’interface "
"en Python ?"

#: faq/design.rst:562
msgid ""
"An interface specification for a module as provided by languages such as C++ "
"and Java describes the prototypes for the methods and functions of the "
"module.  Many feel that compile-time enforcement of interface specifications "
"helps in the construction of large programs."
msgstr ""
"Une spécification d'interface pour un module fourni par des langages tels "
"que C++ et Java décrit les prototypes pour les méthodes et les fonctions du "
"module. Beaucoup estiment que la vérification au moment de la compilation "
"des spécifications d'interface facilite la construction de grands programmes."

#: faq/design.rst:567
msgid ""
"Python 2.6 adds an :mod:`abc` module that lets you define Abstract Base "
"Classes (ABCs).  You can then use :func:`isinstance` and :func:`issubclass` "
"to check whether an instance or a class implements a particular ABC.  The :"
"mod:`collections.abc` module defines a set of useful ABCs such as :class:"
"`~collections.abc.Iterable`, :class:`~collections.abc.Container`, and :class:"
"`~collections.abc.MutableMapping`."
msgstr ""
"Python 2.6 ajoute un module :mod:`abc` qui vous permet de définir des "
"classes de base abstraites (ABC pour *abstract base classes* en anglais). "
"Vous pouvez ensuite utiliser :func:`isinstance` et :func:`issubclass` pour "
"vérifier si une instance ou une classe implémente une ABC particulière. Le "
"module :mod:`collections.abc` définit un ensemble d'ABC utiles telles que :"
"class:`~collections.abc.Iterable`, :class:`~collections.abc.Container` et :"
"class:`collections.abc.MutableMapping`."

#: faq/design.rst:574
msgid ""
"For Python, many of the advantages of interface specifications can be "
"obtained by an appropriate test discipline for components."
msgstr ""
"Pour Python, la plupart des avantages des spécifications d'interface peuvent "
"être obtenus par une discipline de test appropriée pour les composants."

#: faq/design.rst:577
msgid ""
"A good test suite for a module can both provide a regression test and serve "
"as a module interface specification and a set of examples.  Many Python "
"modules can be run as a script to provide a simple \"self test.\"  Even "
"modules which use complex external interfaces can often be tested in "
"isolation using trivial \"stub\" emulations of the external interface.  The :"
"mod:`doctest` and :mod:`unittest` modules or third-party test frameworks can "
"be used to construct exhaustive test suites that exercise every line of code "
"in a module."
msgstr ""
"Une bonne suite de tests pour un module peut à la fois fournir un test de "
"non-régression et servir de spécification d'interface de module ainsi qu'un "
"ensemble d'exemples. De nombreux modules Python peuvent être exécutés en "
"tant que script pour fournir un simple « auto-test ». Même les modules qui "
"utilisent des interfaces externes complexes peuvent souvent être testés "
"isolément à l'aide d'émulations triviales embryonnaires de l'interface "
"externe. Les modules :mod:`doctest` et :mod:`UnitTest` ou des cadriciels de "
"test tiers peuvent être utilisés pour construire des suites de tests "
"exhaustives qui éprouvent chaque ligne de code dans un module."

#: faq/design.rst:585
msgid ""
"An appropriate testing discipline can help build large complex applications "
"in Python as well as having interface specifications would.  In fact, it can "
"be better because an interface specification cannot test certain properties "
"of a program.  For example, the :meth:`append` method is expected to add new "
"elements to the end of some internal list; an interface specification cannot "
"test that your :meth:`append` implementation will actually do this "
"correctly, but it's trivial to check this property in a test suite."
msgstr ""
"Une discipline de test appropriée peut aider à construire des applications "
"complexes de grande taille en Python aussi bien que le feraient des "
"spécifications d'interface. En fait, c'est peut être même mieux parce qu'une "
"spécification d'interface ne peut pas tester certaines propriétés d'un "
"programme. Par exemple, la méthode :meth:`Append` est censée ajouter de "
"nouveaux éléments à la fin d'une liste « sur place » ; une spécification "
"d'interface ne peut pas tester que votre implémentation de :meth:`append` va "
"réellement le faire correctement, mais il est trivial de vérifier cette "
"propriété dans une suite de tests."

#: faq/design.rst:593
msgid ""
"Writing test suites is very helpful, and you might want to design your code "
"to make it easily tested. One increasingly popular technique, test-driven "
"development, calls for writing parts of the test suite first, before you "
"write any of the actual code.  Of course Python allows you to be sloppy and "
"not write test cases at all."
msgstr ""
"L'écriture des suites de tests est très utile, et vous voudrez peut-être "
"concevoir votre code de manière à le rendre facilement testable. Une "
"technique de plus en plus populaire, le développement dirigé par les tests, "
"requiert d'écrire d'abord des éléments de la suite de tests, avant d'écrire "
"le code réel. Bien sûr, Python vous permet d'être laxiste et de ne pas "
"écrire de test du tout."

#: faq/design.rst:601
msgid "Why is there no goto?"
msgstr "Pourquoi n'y a-t-il pas de ``goto`` en Python ?"

#: faq/design.rst:603
msgid ""
"In the 1970s people realized that unrestricted goto could lead to messy "
"\"spaghetti\" code that was hard to understand and revise. In a high-level "
"language, it is also unneeded as long as there are ways to branch (in "
"Python, with ``if`` statements and ``or``, ``and``, and ``if-else`` "
"expressions) and loop (with ``while`` and ``for`` statements, possibly "
"containing ``continue`` and ``break``)."
msgstr ""
"Dans les années 1970, les gens se sont aperçus que le foisonnement de *goto* "
"conduisait à du code « spaghetti » difficile à comprendre et à modifier. "
"Dans les langages de haut niveau, c'est d'autant moins nécessaire qu'il "
"existe différentes manières de créer des branches (en Python, les "
"instructions ``if`` et les expressions ``or``, ``and`` et ``if-else``) et de "
"boucler (avec les instructions ``while`` et ``for``, qui peuvent contenir "
"des ``continue`` et ``break``)."

#: faq/design.rst:610
msgid ""
"One can also use exceptions to provide a \"structured goto\" that works even "
"across function calls.  Many feel that exceptions can conveniently emulate "
"all reasonable uses of the \"go\" or \"goto\" constructs of C, Fortran, and "
"other languages.  For example::"
msgstr ""
"Vous pouvez utiliser les exceptions afin de mettre en place un « *goto* "
"structuré » qui fonctionne même à travers les appels de fonctions. Beaucoup "
"de personnes estiment que les exceptions sont une façon commode d'émuler "
"l'utilisation raisonnable des constructions *go* ou *goto* du C, du Fortran "
"ou d'autres langages de programmation. Par exemple ::"

#: faq/design.rst:626
msgid ""
"This doesn't allow you to jump into the middle of a loop, but that's usually "
"considered an abuse of goto anyway.  Use sparingly."
msgstr ""
"Cela ne vous permet pas de sauter au milieu d'une boucle mais, ceci est de "
"toute façon généralement considéré comme un abus de ``goto``. À Utiliser "
"avec parcimonie."

#: faq/design.rst:631
msgid "Why can't raw strings (r-strings) end with a backslash?"
msgstr ""
"Pourquoi les chaînes de caractères brutes (r-strings) ne peuvent-elles pas "
"se terminer par un *backslash* ?"

#: faq/design.rst:633
msgid ""
"More precisely, they can't end with an odd number of backslashes: the "
"unpaired backslash at the end escapes the closing quote character, leaving "
"an unterminated string."
msgstr ""
"Plus précisément, elles ne peuvent pas se terminer par un nombre impair de "
"*backslashes* : le *backslash* non appairé à la fin échappe le caractère de "
"guillemet final, laissant la chaîne non terminée."

#: faq/design.rst:637
msgid ""
"Raw strings were designed to ease creating input for processors (chiefly "
"regular expression engines) that want to do their own backslash escape "
"processing. Such processors consider an unmatched trailing backslash to be "
"an error anyway, so raw strings disallow that.  In return, they allow you to "
"pass on the string quote character by escaping it with a backslash.  These "
"rules work well when r-strings are used for their intended purpose."
msgstr ""
"Les chaînes brutes ont été conçues pour faciliter la création de données "
"pour les processeurs de texte (principalement les moteurs d'expressions "
"régulières) qui veulent faire leur propre traitement d'échappement "
"d'*antislashes*. Ces processeurs considèrent un *antislash* de fin non-"
"appairé comme une erreur, alors les chaînes brutes ne le permettent pas. En "
"retour, elles vous permettent de transmettre le caractère de citation de la "
"chaîne en l'échappant avec un *antislash*. Ces règles fonctionnent bien "
"lorsque les chaînes brutes sont utilisées pour leur but premier."

#: faq/design.rst:644
msgid ""
"If you're trying to build Windows pathnames, note that all Windows system "
"calls accept forward slashes too::"
msgstr ""
"Si vous essayez de construire des chemins d'accès Windows, notez que tous "
"les appels système Windows acceptent également les *slashes* "
"« classiques » ::"

#: faq/design.rst:649
msgid ""
"If you're trying to build a pathname for a DOS command, try e.g. one of ::"
msgstr ""
"Si vous essayez de construire un chemin d'accès pour une commande DOS, "
"essayez par exemple l'un de ceux-ci ::"

#: faq/design.rst:657
msgid "Why doesn't Python have a \"with\" statement for attribute assignments?"
msgstr ""
"Pourquoi la déclaration ``with`` pour les assignations d'attributs n'existe "
"pas en Python ?"

#: faq/design.rst:659
msgid ""
"Python has a 'with' statement that wraps the execution of a block, calling "
"code on the entrance and exit from the block.  Some languages have a "
"construct that looks like this::"
msgstr ""
"Python a une instruction ``with`` qui encapsule l'exécution d'un bloc, en "
"appelant du code à l'entrée et la sortie du bloc. Certains langages "
"possèdent une construction qui ressemble à ceci ::"

#: faq/design.rst:667
msgid "In Python, such a construct would be ambiguous."
msgstr "En Python, une telle construction serait ambiguë."

#: faq/design.rst:669
msgid ""
"Other languages, such as Object Pascal, Delphi, and C++, use static types, "
"so it's possible to know, in an unambiguous way, what member is being "
"assigned to. This is the main point of static typing -- the compiler "
"*always* knows the scope of every variable at compile time."
msgstr ""
"Les autres langages, tels que Pascal, Delphi et C++ utilisent des types "
"statiques, il est donc possible de savoir d'une manière claire et directe ce "
"à quoi est attribué un membre. C'est le point principal du typage statique — "
"le compilateur connaît *toujours* la portée de toutes les variables au "
"moment de la compilation."

#: faq/design.rst:674
msgid ""
"Python uses dynamic types. It is impossible to know in advance which "
"attribute will be referenced at runtime. Member attributes may be added or "
"removed from objects on the fly. This makes it impossible to know, from a "
"simple reading, what attribute is being referenced: a local one, a global "
"one, or a member attribute?"
msgstr ""
"Python utilise le typage dynamique. Il est impossible de savoir à l'avance "
"quel attribut sera référencé lors de l'exécution. Les attributs membres "
"peuvent être ajoutés ou retirés des objets à la volée. Il est donc "
"impossible de savoir, d'une simple lecture, quel attribut est référencé : "
"s'il est local, global ou un attribut membre ?"

#: faq/design.rst:680
msgid "For instance, take the following incomplete snippet::"
msgstr "Prenons par exemple l'extrait incomplet suivant ::"

#: faq/design.rst:686
msgid ""
"The snippet assumes that \"a\" must have a member attribute called \"x\".  "
"However, there is nothing in Python that tells the interpreter this. What "
"should happen if \"a\" is, let us say, an integer?  If there is a global "
"variable named \"x\", will it be used inside the with block?  As you see, "
"the dynamic nature of Python makes such choices much harder."
msgstr ""
"L'extrait suppose que « a » doit avoir un attribut membre appelé « x ». "
"Néanmoins, il n'y a rien en Python qui en informe l'interpréteur. Que se "
"passe-t-il si « a » est, disons, un entier ? Si une variable globale nommée "
"« x » existe, est-elle utilisée dans le bloc ``with`` ?  Comme vous voyez, "
"la nature dynamique du Python rend ces choix beaucoup plus difficiles."

#: faq/design.rst:692
msgid ""
"The primary benefit of \"with\" and similar language features (reduction of "
"code volume) can, however, easily be achieved in Python by assignment.  "
"Instead of::"
msgstr ""
"L'avantage principal de ``with`` et des fonctionnalités de langage "
"similaires (réduction du volume de code) peut, cependant, être facilement "
"réalisé en Python par assignation.  Au lieu de ::"

#: faq/design.rst:699
msgid "write this::"
msgstr "écrivez ceci ::"

#: faq/design.rst:706
msgid ""
"This also has the side-effect of increasing execution speed because name "
"bindings are resolved at run-time in Python, and the second version only "
"needs to perform the resolution once."
msgstr ""
"Cela a également pour effet secondaire d'augmenter la vitesse d'exécution "
"car les liaisons de noms sont résolues au moment de l'exécution en Python, "
"et la deuxième version n'a besoin d'exécuter la résolution qu'une seule fois."

#: faq/design.rst:712
msgid "Why don't generators support the with statement?"
msgstr ""
"Pourquoi l'instruction ``with`` ne prend-elle pas en charge les générateurs ?"

#: faq/design.rst:714
msgid ""
"For technical reasons, a generator used directly as a context manager would "
"not work correctly.  When, as is most common, a generator is used as an "
"iterator run to completion, no closing is needed.  When it is, wrap it as "
"\"contextlib.closing(generator)\" in the 'with' statement."
msgstr ""
"Pour des raisons d'ordre technique, un générateur utilisé directement comme "
"gestionnaire de contexte ne pourrait pas fonctionner. Dans le cas le plus "
"courant, où un générateur est utilisé jusqu'à épuisement, il n'y a pas "
"besoin de le fermer. Sinon, on peut toujours mettre ``contextlib."
"closing(générateur)`` dans la ligne du ``with``."

#: faq/design.rst:721
msgid "Why are colons required for the if/while/def/class statements?"
msgstr ""
"Pourquoi les deux-points sont-ils nécessaires pour les déclarations ``if/"
"while/def/class`` ?"

#: faq/design.rst:723
msgid ""
"The colon is required primarily to enhance readability (one of the results "
"of the experimental ABC language).  Consider this::"
msgstr ""
"Le deux-points est principalement nécessaire pour améliorer la lisibilité "
"(l'un des résultats du langage expérimental ABC).  Considérez ceci ::"

#: faq/design.rst:729
msgid "versus ::"
msgstr "et cela ::"

#: faq/design.rst:734
msgid ""
"Notice how the second one is slightly easier to read.  Notice further how a "
"colon sets off the example in this FAQ answer; it's a standard usage in "
"English."
msgstr ""
"Remarquez comment le deuxième est un peu plus facile à lire.  Remarquez "
"aussi comment un deux-points introduit l'exemple dans cette réponse à la "
"FAQ ; c'est un usage standard en français (et en anglais)."

#: faq/design.rst:737
msgid ""
"Another minor reason is that the colon makes it easier for editors with "
"syntax highlighting; they can look for colons to decide when indentation "
"needs to be increased instead of having to do a more elaborate parsing of "
"the program text."
msgstr ""
"Une autre raison mineure est que les deux-points facilitent la tâche des "
"éditeurs avec coloration syntaxique ; ils peuvent rechercher les deux-points "
"pour décider quand l'indentation doit être augmentée au lieu d'avoir à faire "
"une analyse plus élaborée du texte du programme."

#: faq/design.rst:743
msgid "Why does Python allow commas at the end of lists and tuples?"
msgstr ""
"Pourquoi Python permet-il les virgules à la fin des listes et des *n*-"
"uplets ?"

#: faq/design.rst:745
msgid ""
"Python lets you add a trailing comma at the end of lists, tuples, and "
"dictionaries::"
msgstr ""
"Python vous permet d'ajouter une virgule à la fin des listes, des *n*-uplets "
"et des dictionnaires ::"

#: faq/design.rst:756
msgid "There are several reasons to allow this."
msgstr "Il y a plusieurs raisons d'accepter cela."

#: faq/design.rst:758
msgid ""
"When you have a literal value for a list, tuple, or dictionary spread across "
"multiple lines, it's easier to add more elements because you don't have to "
"remember to add a comma to the previous line.  The lines can also be "
"reordered without creating a syntax error."
msgstr ""
"Lorsque vous avez une valeur littérale pour une liste, un *n*-uplet ou un "
"dictionnaire réparti sur plusieurs lignes, il est plus facile d'ajouter plus "
"d'éléments parce que vous n'avez pas besoin de vous rappeler d'ajouter une "
"virgule à la ligne précédente.  Les lignes peuvent aussi être réorganisées "
"sans créer une erreur de syntaxe."

#: faq/design.rst:763
msgid ""
"Accidentally omitting the comma can lead to errors that are hard to "
"diagnose. For example::"
msgstr ""
"L'omission accidentelle de la virgule peut entraîner des erreurs difficiles "
"à diagnostiquer, par exemple ::"

#: faq/design.rst:773
msgid ""
"This list looks like it has four elements, but it actually contains three: "
"\"fee\", \"fiefoo\" and \"fum\".  Always adding the comma avoids this source "
"of error."
msgstr ""
"Cette liste a l'air d'avoir quatre éléments, mais elle en contient en fait "
"trois : \"*fee*\", \"*fiefoo*\" et \"*fum*\". Toujours ajouter la virgule "
"permet d'éviter cette source d'erreur."

#: faq/design.rst:776
msgid ""
"Allowing the trailing comma may also make programmatic code generation "
"easier."
msgstr ""
"Permettre la virgule de fin peut également faciliter la génération de code."

#~ msgid ""
#~ "You can do this easily enough with a sequence of ``if... elif... elif... "
#~ "else``. There have been some proposals for switch statement syntax, but "
#~ "there is no consensus (yet) on whether and how to do range tests.  See :"
#~ "pep:`275` for complete details and the current status."
#~ msgstr ""
#~ "Vous pouvez le faire assez facilement avec une séquence de ``if... "
#~ "elif... elif... else``. Il y a eu quelques propositions pour la syntaxe "
#~ "de l'instruction ``switch``, mais il n'y a pas (encore) de consensus sur "
#~ "le cas des intervalles. Voir la :pep:`275` pour tous les détails et "
#~ "l'état actuel."
