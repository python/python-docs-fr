# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-24 14:22+0100\n"
"PO-Revision-Date: 2019-02-20 23:27+0100\n"
"Last-Translator: Jules Lasne <jules.lasne@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.0.2\n"

#: ../Doc/reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "Les instructions simples"

#: ../Doc/reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""
"Une instruction simple est contenue dans une seule ligne logique. Plusieurs "
"instructions simples peuvent être écrites sur une seule ligne, séparées par "
"des points-virgules. La syntaxe d'une instruction simple est :"

#: ../Doc/reference/simple_stmts.rst:36
msgid "Expression statements"
msgstr "Les expressions"

#: ../Doc/reference/simple_stmts.rst:43
msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"Les expressions sont utilisées (généralement de manière interactive) comme "
"instructions pour calculer et écrire des valeurs, appeler une procédure (une "
"fonction dont le résultat renvoyé n'a pas d'importance ; en Python, les "
"procédures renvoient la valeur ``None``). D'autres utilisations des "
"expressions sont autorisées et parfois utiles. La syntaxe pour une "
"expression en tant qu'instruction est :"

#: ../Doc/reference/simple_stmts.rst:52
msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr ""
"Ce genre d'instruction évalue la liste d'expressions (qui peut se limiter à "
"une seule expression)."

#: ../Doc/reference/simple_stmts.rst:64
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"En mode interactif, si la valeur n'est pas ``None``, elle est convertie en "
"chaîne en utilisant la fonction native :func:`repr` et la chaîne résultante "
"est écrite sur la sortie standard sur sa propre ligne. Si le résultat est "
"``None``, rien n'est écrit ce qui est usuel pour les appels de procédures."

#: ../Doc/reference/simple_stmts.rst:72
msgid "Assignment statements"
msgstr "Les assignations"

#: ../Doc/reference/simple_stmts.rst:82
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""
"Les assignations sont utilisées pour lier ou relier des noms à des valeurs "
"et modifier des attributs ou des éléments d'objets muables :"

#: ../Doc/reference/simple_stmts.rst:96
msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*, "
"*subscription*, and *slicing*.)"
msgstr ""
"Voir la section :ref:`primaries` pour la définition des syntaxes de "
"*attributeref*, *subscription* et *slicing*."

#: ../Doc/reference/simple_stmts.rst:99
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"Une assignation évalue la liste d'expressions (gardez en mémoire que ce peut "
"être une simple expression ou une liste dont les éléments sont séparés par "
"des virgules, cette dernière produisant un n-uplet) et assigne l'unique "
"objet résultant à chaque liste cible, de la gauche vers la droite."

#: ../Doc/reference/simple_stmts.rst:108
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"Une assignation est définie récursivement en fonction de la forme de la "
"cible (une liste). Quand la cible est une partie d'un objet muable (une "
"référence à un attribut, une sélection ou une tranche), l'objet muable doit "
"effectuer l'assignation au final et décider de sa validité, voire lever une "
"exception si l'assignation n'est pas acceptable. Les règles suivies par les "
"différents types et les exceptions levées sont données dans les définitions "
"des types d'objets (voir la section :ref:`types`)."

#: ../Doc/reference/simple_stmts.rst:121
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr ""
"L'assignation d'un objet à une liste cible, optionnellement entourée par des "
"parenthèses ou des crochets, est définie récursivement comme suit."

#: ../Doc/reference/simple_stmts.rst:124
msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr ""
"Si la liste cible est une cible unique sans virgule de fin, optionnellement "
"entre parenthèses, l'objet est assigné à cette cible."

#: ../Doc/reference/simple_stmts.rst:127 ../Doc/reference/simple_stmts.rst:139
msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""
"Sinon : l'objet doit être un itérable avec le même nombre d'éléments qu'il y "
"a de cibles dans la liste cible ; les éléments sont assignés, de la gauche "
"vers la droite, vers les cibles correspondantes."

#: ../Doc/reference/simple_stmts.rst:131
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets "
"after the starred target.  A list of the remaining items in the iterable is "
"then assigned to the starred target (the list can be empty)."
msgstr ""
"Si la liste cible contient une cible préfixée par un astérisque, appelée "
"cible *étoilée* (*starred target* en anglais) : l'objet doit être un "
"itérable avec au moins autant d'éléments qu'il y a de cibles dans la liste "
"cible, moins un. Les premiers éléments de l'itérable sont assignés, de la "
"gauche vers la droite, aux cibles avant la cible étoilée. Les éléments de "
"queue de l'itérable sont assignés aux cibles après la cible étoilée. Une "
"liste des éléments restants dans l'itérable est alors assignée à la cible "
"étoilée (cette liste peut être vide)."

#: ../Doc/reference/simple_stmts.rst:143
msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""
"L'assignation d'un objet vers une cible unique est définie récursivement "
"comme suit."

#: ../Doc/reference/simple_stmts.rst:145
msgid "If the target is an identifier (name):"
msgstr "Si la cible est une variable (un nom) :"

#: ../Doc/reference/simple_stmts.rst:147
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"si le nom n'apparaît pas dans une instruction :keyword:`global` ou :keyword:"
"`nonlocal` (respectivement) du bloc de code courant : le nom est lié à "
"l'objet dans l'espace courant des noms locaux."

#: ../Doc/reference/simple_stmts.rst:151
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"Sinon : le nom est lié à l'objet dans l'espace des noms globaux ou dans un "
"espace de noms plus large déterminé par :keyword:`nonlocal`, respectivement."

#: ../Doc/reference/simple_stmts.rst:156
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"Le lien du nom est modifié si le nom était déjà lié. Ceci peut faire que le "
"compteur de références de l'objet auquel le nom était précédemment lié tombe "
"à zéro, entrainant la dé-allocation de l'objet et l'appel de son destructeur "
"(s'il existe)."

#: ../Doc/reference/simple_stmts.rst:162
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""
"Si la cible est une référence à un attribut : l'expression primaire de la "
"référence est évaluée. Elle doit produire un objet avec des attributs que "
"l'on peut assigner : si ce n'est pas le cas, une :exc:`TypeError` est levée. "
"Python demande alors à cet objet d'assigner l'attribut donné ; si ce n'est "
"pas possible, une exception est levée (habituellement, mais pas "
"nécessairement, :exc:`AttributeError`)."

#: ../Doc/reference/simple_stmts.rst:171
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the RHS expression, ``a.x`` can "
"access either an instance attribute or (if no instance attribute exists) a "
"class attribute.  The LHS target ``a.x`` is always set as an instance "
"attribute, creating it if necessary.  Thus, the two occurrences of ``a.x`` "
"do not necessarily refer to the same attribute: if the RHS expression refers "
"to a class attribute, the LHS creates a new instance attribute as the target "
"of the assignment::"
msgstr ""
"Note : si l'objet est une instance de classe et que la référence à "
"l'attribut apparaît des deux côtés de l'opérateur d'assignation, "
"l'expression \"à droite\", ``a.x`` peut accéder soit à l'attribut d'instance "
"ou (si cet attribut d'instance n'existe pas) à l'attribut de classe. "
"L'expression cible \"à gauche\" ``a.x`` est toujours définie comme un "
"attribut d'instance, en le créant si nécessaire. Ainsi, les deux occurrences "
"de ``a.x`` ne font pas nécessairement référence au même attribut : si "
"l'expression \"à droite\" fait référence à un attribut de classe, "
"l'expression \"à gauche\" crée un nouvel attribut d'instance comme cible de "
"l'assignation ::"

#: ../Doc/reference/simple_stmts.rst:185
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""
"Cette description ne s'applique pas nécessairement aux attributs des "
"descripteurs, telles que les propriétés créées avec :func:`property`."

#: ../Doc/reference/simple_stmts.rst:192
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""
"Si la cible est une sélection : l'expression primaire de la référence est "
"évaluée. Elle doit produire soit un objet séquence mutable (telle qu'une "
"liste) ou un objet tableau de correspondances (tel qu'un dictionnaire). "
"Ensuite, l'expression de la sélection est évaluée."

#: ../Doc/reference/simple_stmts.rst:201
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""
"Si la primaire est un objet séquence mutable (telle qu'une liste), la "
"sélection doit produire un entier. S'il est négatif, la longueur de la "
"séquence lui est ajoutée. La valeur résultante doit être un entier positif "
"ou nul, plus petit que la longueur de la séquence, et Python demande à la "
"séquence d'assigner l'objet à l'élément se trouvant à cet indice. Si "
"l'indice est hors limites, une :exc:`IndexError` est levée (une assignation "
"à une sélection dans une séquence ne peut pas ajouter de nouveaux éléments à "
"une liste)."

#: ../Doc/reference/simple_stmts.rst:212
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"Si la primaire est un objet tableau de correspondances (tel qu'un "
"dictionnaire), la sélection doit être d'un type compatible avec le type des "
"clés ; Python demande alors au tableau de correspondances de créer un couple "
"clé-valeur qui associe la sélection à l'objet assigné. Ceci peut remplacer "
"une correspondance déjà existante pour une clé donnée ou insérer un nouveau "
"couple clé-valeur."

#: ../Doc/reference/simple_stmts.rst:218
msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr ""
"Pour les objets allogènes, la méthode  :meth:`__setitem__` est appelée avec "
"les arguments appropriés."

#: ../Doc/reference/simple_stmts.rst:223
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to "
"it.  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""
"Si la cible est une tranche : l'expression primaire de la référence est "
"évaluée. Elle doit produire un objet séquence mutable (telle qu'une liste). "
"L'objet assigné doit être un objet séquence du même type. Ensuite, les "
"expressions de la borne inférieure et de la borne supérieure sont évaluées, "
"dans la mesure où elles sont spécifiées (les valeurs par défaut sont zéro et "
"la longueur de la séquence). Les bornes doivent être des entiers. Si une "
"borne est négative, la longueur de la séquence lui est ajoutée. Les bornes "
"résultantes sont coupées pour être dans l'intervalle zéro -- longueur de la "
"séquence, inclus. Finalement, Python demande à l'objet séquence de remplacer "
"la tranche avec les éléments de la séquence à assigner. La longueur de la "
"tranche peut être différent de la longueur de la séquence à assigner, ce qui "
"modifie alors la longueur de la séquence cible, si celle-ci le permet."

#: ../Doc/reference/simple_stmts.rst:237
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""
"Dans l'implémentation actuelle, la syntaxe pour les cibles est similaire à "
"celle des expressions. Toute syntaxe invalide est rejetée pendant la phase "
"de génération de code, ce qui produit des messages d'erreurs moins détaillés."

#: ../Doc/reference/simple_stmts.rst:241
msgid ""
"Although the definition of assignment implies that overlaps between the left-"
"hand side and the right-hand side are 'simultaneous' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables occur left-to-right, sometimes resulting in confusion.  For "
"instance, the following program prints ``[0, 2]``::"
msgstr ""
"Bien que la définition de l'assignation implique que le passage entre le "
"côté gauche et le côté droit soient \"simultanés\" (par exemple, ``a, b = b, "
"a`` permute les deux variables), le passage *à l'intérieur* des collections "
"de variables que l'on assigne intervient de la gauche vers la droite, ce qui "
"peut entraîner quelques confusions. Par exemple, le programme suivant "
"affiche ``[0, 2]`` ::"

#: ../Doc/reference/simple_stmts.rst:255
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` -- dépaquetage étendu d'itérable"

#: ../Doc/reference/simple_stmts.rst:256
msgid "The specification for the ``*target`` feature."
msgstr "Spécification de la fonctionnalité ``*cible``."

#: ../Doc/reference/simple_stmts.rst:262
msgid "Augmented assignment statements"
msgstr "Les assignations augmentées"

#: ../Doc/reference/simple_stmts.rst:280
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""
"Une assignation augmentée est la combinaison, dans une seule instruction, "
"d'une opération binaire et d'une assignation :"

#: ../Doc/reference/simple_stmts.rst:289
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr ""
"Voir la section :ref:`primaries` pour la définition des syntaxes des trois "
"derniers symboles."

#: ../Doc/reference/simple_stmts.rst:292
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""
"Une assignation augmentée évalue la cible (qui, au contraire des "
"assignations normales, ne peut pas être un dépaquetage) et la liste "
"d'expressions, effectue l'opération binaire (spécifique au type "
"d'assignation) sur les deux opérandes et assigne le résultat à la cible "
"originale. La cible n'est évaluée qu'une seule fois."

#: ../Doc/reference/simple_stmts.rst:297
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""
"Une assignation augmentée comme ``x += 1`` peut être ré-écrite en ``x = x + "
"1`` pour obtenir un effet similaire, mais pas exactement équivalent. Dans la "
"version augmentée. ``x`` n'est évalué qu'une seule fois. Aussi, lorsque "
"c'est possible, l'opération concrète est effectuée *sur place*, c'est-à-dire "
"que plutôt que de créer un nouvel objet et l'assigner à la cible, c'est le "
"vieil objet qui est modifié."

#: ../Doc/reference/simple_stmts.rst:303
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side "
"*before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"Au contraire des assignations normales, les assignations augmentées évaluent "
"la partie gauche *avant* d'évaluer la partie droite. Par exemple, ``a[i] += "
"f(x)`` commence par s'intéresser à ``a[i]``, puis Python évalue ``f(x)``, "
"effectue l'addition et, enfin, écrit le résultat dans ``a[i]``."

#: ../Doc/reference/simple_stmts.rst:308
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"À l'exception de l'assignation de tuples et de cibles multiples dans une "
"seule instruction, l'assignation effectuée par une assignation augmentée est "
"traitée de la même manière qu'une assignation normale. De même, à "
"l'exception du comportement possible *sur place*, l'opération binaire "
"effectuée par assignation augmentée est la même que les opérations binaires "
"normales."

#: ../Doc/reference/simple_stmts.rst:314
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"Pour les cibles qui sont des références à des attributs, la même :ref:`mise "
"en garde sur les attributs de classe et d'instances <attr-target-note>` "
"s'applique que pour les assignations normales."

#: ../Doc/reference/simple_stmts.rst:321
msgid "Annotated assignment statements"
msgstr "Les assignations annotées"

#: ../Doc/reference/simple_stmts.rst:328
msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a "
"single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ""
"Une assignation :term:`annotée <variable annotation>` est la combinaison, "
"dans une seule instruction, d'une annotation de variable ou d'attribut et "
"d'une assignation optionnelle :"

#: ../Doc/reference/simple_stmts.rst:334
msgid ""
"The difference from normal :ref:`assignment` is that only single target and "
"only single right hand side value is allowed."
msgstr ""
"La différence avec une assignation normale (voir :ref:`ci-dessus "
"<assignment>`) est qu'une seule cible et qu'une seule valeur à droite ne "
"sont autorisées."

#: ../Doc/reference/simple_stmts.rst:337
msgid ""
"For simple names as assignment targets, if in class or module scope, the "
"annotations are evaluated and stored in a special class or module attribute :"
"attr:`__annotations__` that is a dictionary mapping from variable names "
"(mangled if private) to evaluated annotations. This attribute is writable "
"and is automatically created at the start of class or module body execution, "
"if annotations are found statically."
msgstr ""
"Pour des noms simples en tant que cibles d'assignation, dans une portée de "
"classe ou de module, les annotations sont évaluées et stockées dans un "
"attribut de classe ou de module spécial, :attr:`__annotations__`, qui est un "
"dictionnaire dont les clés sont les noms de variables (réécrits si le nom "
"est privé) et les valeurs sont les annotations. Cet attribut est accessible "
"en écriture et est automatiquement créé au démarrage de l'exécution du corps "
"de la classe ou du module, si les annotations sont trouvées statiquement."

#: ../Doc/reference/simple_stmts.rst:345
msgid ""
"For expressions as assignment targets, the annotations are evaluated if in "
"class or module scope, but not stored."
msgstr ""
"Pour les expressions en tant que cibles d'assignations, les annotations sont "
"évaluées dans la portée de la classe ou du module, mais ne sont pas stockées."

#: ../Doc/reference/simple_stmts.rst:348
msgid ""
"If a name is annotated in a function scope, then this name is local for that "
"scope. Annotations are never evaluated and stored in function scopes."
msgstr ""
"Si le nom est annoté dans la portée d'une fonction, alors ce nom est local à "
"cette portée. Les annotations ne sont jamais évaluées et stockées dans les "
"portées des fonctions."

#: ../Doc/reference/simple_stmts.rst:351
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If the "
"right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last :meth:`__setitem__` or :"
"meth:`__setattr__` call."
msgstr ""
"Si la partie droite est présente, une assignation annotée effectue "
"l'assignation en tant que telle avant d'évaluer les annotations (là où c'est "
"possible). Si la partie droite n'est pas présente pour une cible "
"d'expression, alors l'interpréteur évalue la cible sauf pour le dernier "
"appel à :meth:`__setitem__` ou :meth:`__setattr__`."

#: ../Doc/reference/simple_stmts.rst:362
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` -- Syntaxe pour les annotations de variables"

#: ../Doc/reference/simple_stmts.rst:360
msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr ""
"La proposition qui a ajouté la syntaxe pour annoter les types de variables "
"(y compris les variables de classe et les variables d'instance), au lieu de "
"les exprimer par le biais de commentaires."

#: ../Doc/reference/simple_stmts.rst:366
msgid ":pep:`484` - Type hints"
msgstr ":pep:`484` -- Indices de type"

#: ../Doc/reference/simple_stmts.rst:365
msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr ""
"La proposition qui a ajouté le module :mod:`typing` pour fournir une syntaxe "
"standard pour les annotations de type qui peuvent être utilisées dans les "
"outils d'analyse statique et les EDIs."

#: ../Doc/reference/simple_stmts.rst:373
msgid "The :keyword:`!assert` statement"
msgstr "L'instruction :keyword:`!assert`"

#: ../Doc/reference/simple_stmts.rst:380
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""
"Les instructions ``assert`` sont une manière pratique d'insérer des tests de "
"débogage au sein d'un programme :"

#: ../Doc/reference/simple_stmts.rst:386
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "La forme la plus simple, ``assert expression``, est équivalente à ::"

#: ../Doc/reference/simple_stmts.rst:391
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""
"La forme étendue, ``assert expression1, expression2``, est équivalente à ::"

#: ../Doc/reference/simple_stmts.rst:400
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line "
"option :option:`-O`).  The current code generator emits no code for an "
"assert statement when optimization is requested at compile time.  Note that "
"it is unnecessary to include the source code for the expression that failed "
"in the error message; it will be displayed as part of the stack trace."
msgstr ""
"Ces équivalences supposent que :const:`__debug__` et :exc:`AssertionError` "
"font référence aux variables natives ainsi nommées. Dans l'implémentation "
"actuelle, la variable native :const:`__debug__` vaut ``True`` dans des "
"circonstances normales, ``False`` quand les optimisations sont demandées "
"(ligne de commande avec l'option :option:`-O`). Le générateur de code actuel "
"ne produit aucun code pour une instruction ``assert`` quand vous demandez "
"les optimisations à la compilation. Notez qu'il est superflu d'inclure le "
"code source dans le message d'erreur pour l'expression qui a échoué : il est "
"affiché dans la pile d'appels."

#: ../Doc/reference/simple_stmts.rst:409
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""
"Assigner vers  :const:`__debug__` est illégal. La valeur de cette variable "
"native est déterminée au moment où l'interpréteur démarre."

#: ../Doc/reference/simple_stmts.rst:416
msgid "The :keyword:`!pass` statement"
msgstr "L'instruction :keyword:`!pass`"

#: ../Doc/reference/simple_stmts.rst:426
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` est une opération vide --- quand elle est exécutée, rien ne "
"se passe. Elle est utile comme bouche-trou lorsqu'une instruction est "
"syntaxiquement requise mais qu'aucun code ne doit être exécuté. Par "
"exemple ::"

#: ../Doc/reference/simple_stmts.rst:438
msgid "The :keyword:`!del` statement"
msgstr "L'instruction :keyword:`!del`"

#: ../Doc/reference/simple_stmts.rst:448
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""
"La suppression est récursivement définie de la même manière que "
"l'assignation. Plutôt que de détailler cela de manière approfondie, voici "
"quelques indices."

#: ../Doc/reference/simple_stmts.rst:451
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""
"La suppression d'une liste cible (*target_list* dans la grammaire ci-dessus) "
"supprime récursivement chaque cible, de la gauche vers la droite."

#: ../Doc/reference/simple_stmts.rst:457
msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""
"La suppression d'un nom détruit le lien entre ce nom dans l'espace des noms "
"locaux, ou l'espace des noms globaux si ce nom apparaît dans une "
"instruction :keyword:`global` dans le même bloc de code. Si le nom n'est pas "
"lié, une exception  :exc:`NameError` est levée."

#: ../Doc/reference/simple_stmts.rst:464
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""
"La suppression d'une référence à un attribut, une sélection ou une tranche "
"est passée à l'objet primaire concerné : la suppression d'une tranche est en "
"général équivalente à l'assignation d'une tranche vide du type adéquat (mais "
"ceci est au final déterminé par l'objet que l'on tranche)."

#: ../Doc/reference/simple_stmts.rst:469
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""
"Auparavant, il était illégal de supprimer un nom dans l'espace des noms "
"locaux si celui-ci apparaissait comme variable libre dans un bloc imbriqué."

#: ../Doc/reference/simple_stmts.rst:477
msgid "The :keyword:`!return` statement"
msgstr "L'instruction :keyword:`!return`"

#: ../Doc/reference/simple_stmts.rst:487
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""
":keyword:`return` ne peut être placée qu'à l'intérieur d'une définition de "
"fonction, pas à l'intérieur d'une définition de classe."

#: ../Doc/reference/simple_stmts.rst:490
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""
"Si une liste d'expressions (*expression_list* dans la grammaire ci-dessus) "
"est présente, elle est évaluée, sinon ``None`` est utilisée comme valeur par "
"défaut."

#: ../Doc/reference/simple_stmts.rst:492
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""
":keyword:`return` quitte l'appel à la fonction courante avec la liste "
"d'expressions (ou ``None``) comme valeur de retour."

#: ../Doc/reference/simple_stmts.rst:497
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""
"Quand :keyword:`return` fait sortir d'une instruction :keyword:`try` avec "
"une clause :keyword:`finally`, cette clause :keyword:`!finally` est exécutée "
"avant de réellement quitter la fonction."

#: ../Doc/reference/simple_stmts.rst:501
msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct :exc:"
"`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"Dans une fonction générateur, l'instruction :keyword:`return` indique que le "
"générateur est terminé et provoque la levée d'une :exc:`StopIteration`. La "
"valeur de retour (s'il y en a une) est utilisée comme argument pour "
"construire l'exception :exc:`StopIteration` et devient l'attribut :attr:"
"`StopIteration.value`."

#: ../Doc/reference/simple_stmts.rst:506
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause :exc:"
"`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` statement "
"is a syntax error in an asynchronous generator function."
msgstr ""
"Dans une fonction générateur asynchrone, une instruction :keyword:`return` "
"vide indique que le générateur asynchrone est terminé et provoque la levée "
"d'une :exc:`StopAsyncIteration`. Une instruction :keyword:`!return` non vide "
"est une erreur de syntaxe dans une fonction générateur asynchrone."

#: ../Doc/reference/simple_stmts.rst:514
msgid "The :keyword:`!yield` statement"
msgstr "L'instruction :keyword:`!yield`"

#: ../Doc/reference/simple_stmts.rst:526
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The yield statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
"L'instruction :keyword:`yield` est sémantiquement équivalente à une :ref:"
"`expression yield <yieldexpr>`. L'instruction *yield* peut être utilisée "
"pour omettre les parenthèses qui seraient autrement requises dans "
"l'instruction équivalente d'expression *yield*. Par exemple, les "
"instructions *yield* ::"

#: ../Doc/reference/simple_stmts.rst:534
msgid "are equivalent to the yield expression statements ::"
msgstr "sont équivalentes aux instructions expressions *yield* ::"

#: ../Doc/reference/simple_stmts.rst:539
msgid ""
"Yield expressions and statements are only used when defining a :term:"
"`generator` function, and are only used in the body of the generator "
"function.  Using yield in a function definition is sufficient to cause that "
"definition to create a generator function instead of a normal function."
msgstr ""
"Les expressions et les instructions *yield* sont utilisées seulement dans la "
"définition des fonctions :term:`générateurs <generator>` et apparaissent "
"uniquement dans le corps de la fonction générateur. L'utilisation de *yield* "
"dans la définition d'une fonction est suffisant pour que cette définition "
"crée une fonction générateur au lieu d'une fonction normale."

#: ../Doc/reference/simple_stmts.rst:544
msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""
"Pour tous les détails sur la sémantique de :keyword:`yield`, reportez-vous à "
"la section :ref:`yieldexpr`."

#: ../Doc/reference/simple_stmts.rst:550
msgid "The :keyword:`!raise` statement"
msgstr "L'instruction :keyword:`!raise`"

#: ../Doc/reference/simple_stmts.rst:561
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the last exception "
"that was active in the current scope.  If no exception is active in the "
"current scope, a :exc:`RuntimeError` exception is raised indicating that "
"this is an error."
msgstr ""
"Si aucune expression n'est présente, :keyword:`raise` propage la dernière "
"exception active dans la portée courante. Si aucune exception n'est active "
"dans la portée courante, une exception :exc:`RuntimeError` est levée, "
"indiquant que c'est une erreur."

#: ../Doc/reference/simple_stmts.rst:566
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""
"Sinon,  :keyword:`raise` évalue la première expression en tant qu'objet "
"exception. Ce doit être une sous-classe ou une instance de :class:"
"`BaseException`. Si c'est une classe, l'instance de l'exception est obtenue "
"en instanciant la classe sans argument (au moment voulu)."

#: ../Doc/reference/simple_stmts.rst:571
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr ""
"Le :dfn:`type` de l'exception est la classe de l'instance de l'exception, "
"la :dfn:`value` est l'instance elle-même."

#: ../Doc/reference/simple_stmts.rst:576
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`__traceback__` attribute, which is "
"writable. You can create an exception and set your own traceback in one step "
"using the :meth:`with_traceback` exception method (which returns the same "
"exception instance, with its traceback set to its argument), like so::"
msgstr ""
"Normalement, un objet *trace d'appels* est créé automatiquement quand une "
"exception est levée et il lui est rattaché comme attribut  :attr:"
"`__traceback__`, en lecture-écriture. Vous pouvez créer une exception et "
"définir votre propre trace d'appels d'un seul coup en utilisant la méthode "
"des exceptions :meth:`with_traceback` (qui renvoie la même instance "
"d'exception avec sa trace d'appels passée en argument), comme ceci ::"

#: ../Doc/reference/simple_stmts.rst:588
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance, which will then be "
"attached to the raised exception as the :attr:`__cause__` attribute (which "
"is writable).  If the raised exception is not handled, both exceptions will "
"be printed::"
msgstr ""
"La clause ``from`` est utilisée pour chaîner les exceptions : si vous la "
"fournissez, la seconde \"expression\" doit être une autre classe ou instance "
"d'exception, qui est rattachée à l'exception levée en tant qu'attribut :attr:"
"`__cause__` (en lecture-écriture). Si l'exception levée n'est pas gérée, les "
"deux exceptions sont affichées ::"

#: ../Doc/reference/simple_stmts.rst:609
msgid ""
"A similar mechanism works implicitly if an exception is raised inside an "
"exception handler or a :keyword:`finally` clause: the previous exception is "
"then attached as the new exception's :attr:`__context__` attribute::"
msgstr ""
"Un mécanisme similaire est mis en œuvre implicitement si une exception est "
"levée à l'intérieur d'un gestionnaire d'exception ou d'une clause :keyword:"
"`finally` : la première exception est rattachée à l'attribut :attr:"
"`__context__` de la nouvelle exception ::"

#: ../Doc/reference/simple_stmts.rst:628
msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause::"
msgstr ""
"Le chaînage d'exceptions peut être explicitement supprimé en spécifiant :"
"const:`None` dans la clause ``from`` ::"

#: ../Doc/reference/simple_stmts.rst:640
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""
"Des informations complémentaires sur les exceptions sont disponibles dans la "
"section :ref:`exceptions` et sur la gestion des exceptions dans la section :"
"ref:`try`."

#: ../Doc/reference/simple_stmts.rst:643
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ""
":const:`None` est dorénavant autorisée en tant que ``Y`` dans ``raise X from "
"Y``."

#: ../Doc/reference/simple_stmts.rst:646
msgid ""
"The ``__suppress_context__`` attribute to suppress automatic display of the "
"exception context."
msgstr ""
"L'attribut ``__suppress_context__`` pour supprimer l'affichage automatique "
"du contexte de l'exception."

#: ../Doc/reference/simple_stmts.rst:653
msgid "The :keyword:`!break` statement"
msgstr "L'instruction :keyword:`!break`"

#: ../Doc/reference/simple_stmts.rst:664
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
"Une instruction :keyword:`break` ne peut apparaître qu'à l'intérieur d'une "
"boucle :keyword:`for` ou :keyword:`while`, mais pas dans une définition de "
"fonction ou de classe à l'intérieur de cette boucle."

#: ../Doc/reference/simple_stmts.rst:671
msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:`!"
"else` clause if the loop has one."
msgstr ""
"Elle termine la boucle la plus imbriquée, shuntant l'éventuelle clause :"
"keyword:`!else` de la boucle."

#: ../Doc/reference/simple_stmts.rst:674
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""
"Si une boucle :keyword:`for` est terminée par un :keyword:`break`, la cible "
"qui contrôle la boucle garde sa valeur."

#: ../Doc/reference/simple_stmts.rst:679
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""
"Quand :keyword:`break` passe le contrôle en dehors d'une instruction :"
"keyword:`try` qui comporte une clause :keyword:`finally`, cette clause :"
"keyword:`!finally` est exécutée avant de quitter la boucle."

#: ../Doc/reference/simple_stmts.rst:687
msgid "The :keyword:`!continue` statement"
msgstr "L'instruction :keyword:`!continue`"

#: ../Doc/reference/simple_stmts.rst:699
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"or :keyword:`finally` clause within that loop.  It continues with the next "
"cycle of the nearest enclosing loop."
msgstr ""
"L'instruction :keyword:`continue` ne peut apparaître qu'à l'intérieur d'une "
"boucle :keyword:`for` ou :keyword:`while`, mais pas dans une définition de "
"fonction ou de classe ni dans une clause :keyword:`finally`, à l'intérieur "
"de cette boucle. Elle fait continuer le flot d'exécution au prochain cycle "
"de la boucle la plus imbriquée."

#: ../Doc/reference/simple_stmts.rst:704
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
"Quand :keyword:`continue` passe le contrôle en dehors d'une instruction :"
"keyword:`try` qui comporte une clause :keyword:`finally`, cette clause :"
"keyword:`!finally` est exécutée avant de commencer le cycle suivant de la "
"boucle."

#: ../Doc/reference/simple_stmts.rst:713
msgid "The :keyword:`!import` statement"
msgstr "L'instruction :keyword:`!import`"

#: ../Doc/reference/simple_stmts.rst:734
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr ""
"L'instruction de base *import* (sans clause :keyword:`from`) est exécutée en "
"deux étapes :"

#: ../Doc/reference/simple_stmts.rst:737
msgid "find a module, loading and initializing it if necessary"
msgstr "trouve un module, le charge et l'initialise si nécessaire"

#: ../Doc/reference/simple_stmts.rst:738
msgid ""
"define a name or names in the local namespace for the scope where the :"
"keyword:`import` statement occurs."
msgstr ""
"définit un ou des noms (*name* dans la grammaire ci-dessus) dans l'espace "
"des noms locaux de la portée où l'instruction :keyword:`import` apparaît."

#: ../Doc/reference/simple_stmts.rst:741
msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses "
"had been separated out into individual import statements."
msgstr ""
"Quand l'instruction contient plusieurs clauses (séparées par des virgules), "
"les deux étapes sont menées séparément pour chaque clause, comme si les "
"clauses étaient séparées dans des instructions d'importations individuelles."

#: ../Doc/reference/simple_stmts.rst:746
msgid ""
"The details of the first step, finding and loading modules are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""
"Les détails de la première étape, de recherche et de chargement des modules "
"sont décrits largement dans la section relative au  :ref:`système "
"d'importation <importsystem>`, qui décrit également les différents types de "
"paquets et modules qui peuvent être importés, de même que les points "
"d'entrée pouvant être utilisés pour personnaliser le système d'importation. "
"Notez que des erreurs dans cette étape peuvent indiquer soit que le module "
"n'a pas été trouvé, soit qu'une erreur s'est produite lors de "
"l'initialisation du module, ce qui comprend l'exécution du code du module."

#: ../Doc/reference/simple_stmts.rst:754
msgid ""
"If the requested module is retrieved successfully, it will be made available "
"in the local namespace in one of three ways:"
msgstr ""
"Si le module requis est bien récupéré, il est mis à disposition de l'espace "
"de noms locaux suivant l'une des trois façons suivantes :"

#: ../Doc/reference/simple_stmts.rst:759
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"Si le nom du module est suivi par :keyword:`!as`, alors le nom suivant :"
"keyword:`!as` est directement lié au module importé."

#: ../Doc/reference/simple_stmts.rst:761
msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""
"si aucun autre nom n'est spécifié et que le module en cours d'importation "
"est un module de niveau le plus haut, le nom du module est lié dans l'espace "
"des noms locaux au module importé ;"

#: ../Doc/reference/simple_stmts.rst:764
msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"si le module en cours d'importation n'est *pas* un module de plus haut "
"niveau, alors le nom du paquet de plus haut niveau qui contient ce module "
"est lié dans l'espace des noms locaux au paquet de plus haut niveau. Vous "
"pouvez accéder au module importé en utilisant son nom pleinement qualifié et "
"non directement."

#: ../Doc/reference/simple_stmts.rst:774
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr "La forme :keyword:`from` utilise un processus un peu plus complexe :"

#: ../Doc/reference/simple_stmts.rst:776
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""
"trouve le module spécifié dans la clause :keyword:`from`, le charge et "
"l'initialise si nécessaire ;"

#: ../Doc/reference/simple_stmts.rst:778
msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr "pour chaque nom spécifié dans les clauses :keyword:`import` :"

#: ../Doc/reference/simple_stmts.rst:780
msgid "check if the imported module has an attribute by that name"
msgstr "vérifie si le module importé possède un attribut avec ce nom ;"

#: ../Doc/reference/simple_stmts.rst:781
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""
"si non, essaie d'importer un sous-module avec ce nom puis vérifie si le "
"module importé possède lui-même cet attribut ;"

#: ../Doc/reference/simple_stmts.rst:783
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr "si l'attribut n'est pas trouvé, une :exc:`ImportError` est levée."

#: ../Doc/reference/simple_stmts.rst:784
msgid ""
"otherwise, a reference to that value is stored in the local namespace, using "
"the name in the :keyword:`!as` clause if it is present, otherwise using the "
"attribute name"
msgstr ""
"sinon, une référence à cette valeur est stockée dans l'espace des noms "
"locaux, en utilisant le nom de la clause :keyword:`!as` si elle est "
"présente, sinon en utilisant le nom de l'attribut."

#: ../Doc/reference/simple_stmts.rst:788
msgid "Examples::"
msgstr "Exemples : ::"

#: ../Doc/reference/simple_stmts.rst:798
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names "
"defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""
"Si la liste des noms est remplacée par une étoile (``'*'``), tous les noms "
"publics définis dans le module sont liés dans l'espace des noms locaux de la "
"portée où apparaît l'instruction :keyword:`import`."

#: ../Doc/reference/simple_stmts.rst:804
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the module)."
msgstr ""
"Les *noms publics* définis par un module sont déterminés en cherchant dans "
"l'espace de noms du module une variable nommée ``__all__`` ; Si elle est "
"définie, elle doit être une séquence de chaînes désignant les noms définis "
"ou importés par ce module. Les noms donnés dans ``__all__`` sont tous "
"considérés publics et doivent exister. Si ``__all__`` n'est pas définie, "
"l'ensemble des noms publics contient tous les noms trouvés dans l'espace des "
"noms du module qui ne commencent pas par un caractère souligné (``_``). "
"``__all__`` doit contenir toute l'API publique. Elle est destinée à éviter "
"l'export accidentel d'éléments qui ne font pas partie de l'API (tels que des "
"modules de bibliothèques qui ont été importés et utilisé à l'intérieur du "
"module)."

#: ../Doc/reference/simple_stmts.rst:814
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"La forme d'\\ *import* avec astérisque --- ``from module import *`` --- est "
"autorisée seulement au niveau du module. Si vous essayez de l'utiliser dans "
"une définition de classe ou de fonction, cela lève une :exc:`SyntaxError`."

#: ../Doc/reference/simple_stmts.rst:821
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained "
"within :pep:`328`."
msgstr ""
"Quand vous spécifiez les modules à importer, vous n'avez pas besoin de "
"spécifier les noms absolus des modules. Quand un module ou un paquet est "
"contenu dans un autre paquet, il est possible d'effectuer une importation "
"relative à l'intérieur du même paquet de plus haut niveau sans avoir à "
"mentionner le nom du paquet. En utilisant des points en entête du module ou "
"du paquet spécifié après :keyword:`from`, vous pouvez spécifier combien de "
"niveaux vous souhaitez remonter dans la hiérarchie du paquet courant sans "
"spécifier de nom exact. Un seul point en tête signifie le paquet courant où "
"se situe le module qui effectue l'importation. Deux points signifient de "
"remonter d'un niveau. Trois points, remonter de deux niveaux et ainsi de "
"suite. Ainsi, si vous exécutez ``from . import mod`` dans un module du "
"paquet ``pkg``, vous importez finalement ``pkg.mod``. Et si vous exécutez "
"``from ..souspkg2 import mod`` depuis ``pkg.souspkg1``, vous importez "
"finalement ``pkg.souspkg2.mod``. La spécification des importations relatives "
"se situe dans la  :pep:`328`."

#: ../Doc/reference/simple_stmts.rst:834
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""
":func:`importlib.import_module` est fournie pour gérer les applications qui "
"déterminent dynamiquement les modules à charger."

#: ../Doc/reference/simple_stmts.rst:841
msgid "Future statements"
msgstr "L'instruction future"

#: ../Doc/reference/simple_stmts.rst:847
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
"Une :dfn:`instruction future` est une directive à l'attention du compilateur "
"afin qu'un module particulier soit compilé en utilisant une syntaxe ou une "
"sémantique qui sera disponible dans une future version de Python où cette "
"fonctionnalité est devenue un standard."

#: ../Doc/reference/simple_stmts.rst:851
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"L'instruction *future* a vocation à faciliter les migrations vers les "
"futures versions de Python qui introduisent des changements incompatibles au "
"langage. Cela permet l'utilisation de nouvelles fonctionnalités module par "
"module avant qu'une version n'officialise cette fonctionnalité comme un "
"standard."

#: ../Doc/reference/simple_stmts.rst:863
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""
"Une instruction *future* doit apparaître en haut du module. Les seules "
"lignes autorisées avant une instruction *future* sont :"

#: ../Doc/reference/simple_stmts.rst:866
msgid "the module docstring (if any),"
msgstr "la chaîne de documentation du module (si elle existe),"

#: ../Doc/reference/simple_stmts.rst:867
msgid "comments,"
msgstr "des commentaires,"

#: ../Doc/reference/simple_stmts.rst:868
msgid "blank lines, and"
msgstr "des lignes vides et"

#: ../Doc/reference/simple_stmts.rst:869
msgid "other future statements."
msgstr "d'autres instructions *future*."

#: ../Doc/reference/simple_stmts.rst:871
msgid ""
"The only feature in Python 3.7 that requires using the future statement is "
"``annotations``."
msgstr ""
"La seule fonctionnalité dans Python 3.7 qui nécessite l'utilisation de "
"l'instruction `future` est ``annotations``. "

#: ../Doc/reference/simple_stmts.rst:874
msgid ""
"All historical features enabled by the future statement are still recognized "
"by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""
"Toutes les fonctionnalités (*feature* dans la grammaire ci-dessus) "
"autorisées par l'instruction `future` sont toujours reconnues par Python 3. "
"Cette liste comprend ``absolute_import``, ``division``, ``generators``, "
"``generator_stop``, ``unicode_literals``, ``print_function``, "
"``nested_scopes`` et ``with_statement``. Elles sont toutes redondantes car "
"elles sont de toute manière activées ; elles ne sont conservées que par "
"souci de compatibilité descendante."

#: ../Doc/reference/simple_stmts.rst:881
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"Une instruction *future* est reconnue et traitée spécialement au moment de "
"la compilation : les modifications à la sémantique des constructions de base "
"sont souvent implémentées en générant un code différent. Il peut même "
"arriver qu'une nouvelle fonctionnalité ait une syntaxe incompatible (tel "
"qu'un nouveau mot réservé) ; dans ce cas, le compilateur a besoin d'analyser "
"le module de manière différente. De telles décisions ne peuvent pas être "
"différées au moment de l'exécution."

#: ../Doc/reference/simple_stmts.rst:888
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""
"Pour une version donnée, le compilateur sait quelles fonctionnalités ont été "
"définies et lève une erreur à la compilation si une instruction *future* "
"contient une fonctionnalité qui lui est inconnue."

#: ../Doc/reference/simple_stmts.rst:892
msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"La sémantique à l'exécution est la même que pour toute autre instruction "
"d'importation : il existe un module standard :mod:`__future__`, décrit plus "
"loin, qui est importé comme les autres au moment ou l'instruction *future* "
"est exécutée."

#: ../Doc/reference/simple_stmts.rst:896
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""
"La sémantique particulière à l'exécution dépend des fonctionnalités "
"apportées par l'instruction *future*."

#: ../Doc/reference/simple_stmts.rst:899
msgid "Note that there is nothing special about the statement::"
msgstr "Notez que l'instruction suivante est tout à fait normale ::"

#: ../Doc/reference/simple_stmts.rst:903
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""
"Ce n'est pas une instruction *future* ; c'est une instruction d'importation "
"ordinaire qui n'a aucune sémantique particulière ou restriction de syntaxe."

#: ../Doc/reference/simple_stmts.rst:906
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""
"Le code compilé par des appels aux fonctions natives :func:`exec` et :func:"
"`compile` dans un module :mod:`M` comportant une instruction *future* "
"utilise, par défaut, la nouvelle syntaxe ou sémantique associée à "
"l'instruction *future*. Ceci peut être contrôle par des arguments optionnels "
"à  :func:`compile` --- voir la documentation de cette fonction pour les "
"détails."

#: ../Doc/reference/simple_stmts.rst:912
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"Une instruction *future* entrée à l'invite de l'interpréteur interactif est "
"effective pour le reste de la session de l'interpréteur. Si l'interpréteur "
"est démarré avec l'option  :option:`-i`, qu'un nom de script est passé pour "
"être exécuté et que ce script contient une instruction *future*, elle est "
"effective pour la session interactive qui démarre après l'exécution du "
"script."

#: ../Doc/reference/simple_stmts.rst:920
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` -- retour vers le __future__"

#: ../Doc/reference/simple_stmts.rst:921
msgid "The original proposal for the __future__ mechanism."
msgstr "La proposition originale pour le mécanisme de __future__."

#: ../Doc/reference/simple_stmts.rst:927
msgid "The :keyword:`!global` statement"
msgstr "L'instruction :keyword:`!global`"

#: ../Doc/reference/simple_stmts.rst:937
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
"L'instruction :keyword:`global` est une déclaration qui couvre l'ensemble du "
"bloc de code courant. Elle signifie que les noms (*identifier* dans la "
"grammaire ci-dessus) listés doivent être interprétés comme globaux. Il est "
"impossible d'assigner une variable globale sans :keyword:`!global`, mais "
"rappelez-vous que les variables libres peuvent faire référence à des "
"variables globales sans avoir été déclarées en tant que telles."

#: ../Doc/reference/simple_stmts.rst:943
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`!global` statement."
msgstr ""
"Les noms listés dans l'instruction :keyword:`global` ne doivent pas être "
"utilisés, dans le même bloc de code, avant l'instruction :keyword:`!global`."

#: ../Doc/reference/simple_stmts.rst:946
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters or in a :keyword:`for` loop control target, :keyword:`class` "
"definition, function definition, :keyword:`import` statement, or variable "
"annotation."
msgstr ""
"Les noms listés dans l'instruction :keyword:`global` ne doivent pas être "
"définis en tant que paramètre formel, cible d'une boucle :keyword:`for`, "
"dans une définition de  :keyword:`class`, de fonction, d'instruction  :"
"keyword:`import` ou une annotation de variable."

#: ../Doc/reference/simple_stmts.rst:953
msgid ""
"The current implementation does not enforce some of these restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr ""
"L'implémentation actuelle ne vérifie pas toutes ces interdictions mais "
"n'abusez pas de cette liberté car les implémentations futures pourraient "
"faire la vérification ou modifier le comportement du programme sans vous "
"avertir."

#: ../Doc/reference/simple_stmts.rst:962
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`!global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""
"**Note pour les programmeurs :** :keyword:`global` est une directive à "
"l'attention de l'analyseur syntaxique. Elle s'applique uniquement au code "
"analysé en même temps que l'instruction :keyword:`!global`. En particulier, "
"une instruction :keyword:`!global` contenue dans une chaîne ou un objet code "
"fourni à la fonction native :func:`exec` n'affecte pas le code *contenant* "
"cet appel et le code contenu dans un telle chaîne n'est pas affecté par une "
"instruction :keyword:`!global` placée dans le code contenant l'appel. Il en "
"est de même pour les fonctions :func:`eval` et :func:`compile`."

#: ../Doc/reference/simple_stmts.rst:974
msgid "The :keyword:`!nonlocal` statement"
msgstr "L'instruction :keyword:`!nonlocal`"

#: ../Doc/reference/simple_stmts.rst:986
msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer to "
"previously bound variables in the nearest enclosing scope excluding globals. "
"This is important because the default behavior for binding is to search the "
"local namespace first.  The statement allows encapsulated code to rebind "
"variables outside of the local scope besides the global (module) scope."
msgstr ""
"L'instruction :keyword:`nonlocal` fait que les noms listés font référence "
"aux variables liées précédemment, dans la portée la plus petite entourant "
"l'instruction, à l'exception des variables globales. C'est important car le "
"comportement par défaut pour les liaisons consiste à chercher d'abord dans "
"l'espace des noms locaux. Cette instruction permet à du code encapsulé de se "
"lier à des variables en dehors de la portée locale du code mais sans avoir "
"de portée globale (c'est-à-dire de niveau module)."

#: ../Doc/reference/simple_stmts.rst:996
msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike those listed in a :"
"keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created cannot "
"be determined unambiguously)."
msgstr ""
"Les noms (*identifier* dans la grammaire ci-dessus) listés dans "
"l'instruction :keyword:`nonlocal`, au contraire de ceux listés dans une "
"instruction :keyword:`global`, doivent faire référence à des liaisons pré-"
"existantes dans les portées englobantes (en effet, la portée dans laquelle "
"devrait être créée la liaison ne peut pas être déterminée *a priori*)."

#: ../Doc/reference/simple_stmts.rst:1001
msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with pre-"
"existing bindings in the local scope."
msgstr ""
"Les noms listés dans l'instruction :keyword:`nonlocal` ne doivent entrer en "
"collision avec des liaisons déjà établies dans la portée locale."

#: ../Doc/reference/simple_stmts.rst:1006
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` -- Accès à des noms en dehors de la portée locale"

#: ../Doc/reference/simple_stmts.rst:1007
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr "Les spécifications pour l'instruction :keyword:`nonlocal`."

#~ msgid ""
#~ "If the target list is empty: The object must also be an empty iterable."
#~ msgstr ""
#~ "si la liste cible est vide : l'objet doit aussi être un itérable vide."

#~ msgid ""
#~ "If the target list is a comma-separated list of targets, or a single "
#~ "target in square brackets: The object must be an iterable with the same "
#~ "number of items as there are targets in the target list, and the items "
#~ "are assigned, from left to right, to the corresponding targets."
#~ msgstr ""
#~ "Si la liste cible est une liste de cibles dont les éléments sont séparés "
#~ "par des virgules, ou une cible unique entourée par des crochets : l'objet "
#~ "doit être un itérable avec le même nombre d'éléments qu'il y a de cibles "
#~ "dans la liste cible ; les éléments sont alors assignés, de la gauche vers "
#~ "la droite, aux cibles correspondantes."

#~ msgid ""
#~ ":pep:`526` - Variable and attribute annotation syntax :pep:`484` - Type "
#~ "hints"
#~ msgstr ""
#~ ":pep:`526` -- Syntaxe pour les annotations de variables et d'attributs, :"
#~ "pep:`484` -- Indications de types"
