# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2023-12-05 22:58+0100\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "Instructions composées"

#: reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Les instructions composées contiennent d'autres (groupes d’) instructions ; "
"elles affectent ou contrôlent l'exécution de ces autres instructions d'une "
"manière ou d'une autre. En général, une instruction composée couvre "
"plusieurs lignes bien que, dans sa forme la plus simple, une instruction "
"composée peut tenir sur une seule ligne."

#: reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
"Les instructions :keyword:`if`, :keyword:`while` et :keyword:`for` "
"implémentent les constructions classiques de contrôle de flux. :keyword:"
"`try` définit des gestionnaires d'exception et du code de nettoyage pour un "
"groupe d'instructions, tandis que l'instruction :keyword:`with` permet "
"l'exécution de code d'initialisation et de finalisation autour d'un bloc de "
"code. Les définitions de fonctions et de classes sont également, au sens "
"syntaxique, des instructions composées."

#: reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"Une instruction composée comporte une ou plusieurs « clauses ». Une clause "
"se compose d'un en-tête et d'une « suite ». Les en-têtes des clauses d'une "
"instruction composée particulière sont toutes placées au même niveau "
"d'indentation. Chaque en-tête de clause commence par un mot-clé spécifique "
"et se termine par le caractère deux-points (``:``) ; une suite est un groupe "
"d'instructions contrôlées par une clause ; une suite se compose, après les "
"deux points de l'en-tête, soit d'une ou plusieurs instructions simples "
"séparées par des points-virgules si elles sont sur la même ligne que l'en-"
"tête, soit d'une ou plusieurs instructions en retrait sur les lignes "
"suivantes. Seule cette dernière forme d'une suite peut contenir des "
"instructions composées ; ce qui suit n'est pas licite, principalement parce "
"qu'il ne serait pas clair de savoir à quelle clause :keyword:`if` se "
"rapporterait une clause :keyword:`else` placée en fin de ligne ::"

#: reference/compound_stmts.rst:37
msgid "if test1: if test2: print(x)"
msgstr ""

#: reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"Notez également que le point-virgule se lie plus étroitement que le deux-"
"points dans ce contexte, de sorte que dans l'exemple suivant, soit tous les "
"appels :func:`print` sont exécutés, soit aucun ne l'est ::"

#: reference/compound_stmts.rst:43
msgid "if x < y < z: print(x); print(y); print(z)"
msgstr ""

#: reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "En résumé :"

#: reference/compound_stmts.rst:69
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"Notez que ces instructions se terminent toujours par un lexème ``NEWLINE`` "
"suivi éventuellement d'un ``DEDENT``. Notez également que les clauses "
"facultatives qui suivent commencent toujours par un mot-clé qui ne peut pas "
"commencer une instruction. Ainsi, il n'y a pas d'ambiguïté (le problème du :"
"keyword:`else` dont on ne sait pas à quel ``if`` il est relié est résolu en "
"Python en exigeant que des instructions :keyword:`if` imbriquées soient "
"indentées les unes par rapport aux autres)."

#: reference/compound_stmts.rst:75
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"L'agencement des règles de grammaire dans les sections qui suivent place "
"chaque clause sur une ligne séparée pour plus de clarté."

#: reference/compound_stmts.rst:84
msgid "The :keyword:`!if` statement"
msgstr "L'instruction :keyword:`!if`"

#: reference/compound_stmts.rst:92
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ""
"L'instruction :keyword:`if` est utilisée pour exécuter des instructions en "
"fonction d'une condition :"

#: reference/compound_stmts.rst:99
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Elle sélectionne exactement une des suites en évaluant les expressions une "
"par une jusqu'à ce qu'une soit vraie (voir la section :ref:`booleans` pour "
"la définition de vrai et faux) ; ensuite cette suite est exécutée (et aucune "
"autre partie de l'instruction :keyword:`if` n'est exécutée ou évaluée). Si "
"toutes les expressions sont fausses, la suite de la clause :keyword:`else`, "
"si elle existe, est exécutée."

#: reference/compound_stmts.rst:109
msgid "The :keyword:`!while` statement"
msgstr "L'instruction :keyword:`!while`"

#: reference/compound_stmts.rst:117
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"L'instruction :keyword:`while` est utilisée pour exécuter des instructions "
"de manière répétée tant qu'une expression est vraie :"

#: reference/compound_stmts.rst:124
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"Python évalue l'expression de manière répétée et, tant qu'elle est vraie, "
"exécute la première suite ; si l'expression est fausse (ce qui peut arriver "
"même lors du premier test), la suite de la clause :keyword:`!else`, si elle "
"existe, est exécutée et la boucle se termine."

#: reference/compound_stmts.rst:133
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"Une instruction :keyword:`break` exécutée dans la première suite termine la "
"boucle sans exécuter la suite de la clause :keyword:`!else`. Une "
"instruction :keyword:`continue` exécutée dans la première suite saute le "
"reste de la suite et retourne au test de l'expression."

#: reference/compound_stmts.rst:142
msgid "The :keyword:`!for` statement"
msgstr "L'instruction :keyword:`!for`"

#: reference/compound_stmts.rst:153
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"L'instruction :keyword:`for` est utilisée pour itérer sur les éléments d'une "
"séquence (par exemple une chaîne, un *n*-uplet ou une liste) ou un autre "
"objet itérable :"

#: reference/compound_stmts.rst:160
msgid ""
"The ``starred_list`` expression is evaluated once; it should yield an :term:"
"`iterable` object.  An :term:`iterator` is created for that iterable. The "
"first item provided by the iterator is then assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and the "
"suite is executed.  This repeats for each item provided by the iterator.  "
"When the iterator is exhausted, the suite in the :keyword:`!else` clause, if "
"present, is executed, and the loop terminates."
msgstr ""
"L'expression ``starred_list`` n'est évaluée qu'une seule fois ; elle doit "
"produire un objet :term:`iterable`. Un :term:`iterator` est créé pour cet "
"itérable. Le premier élément produit par l'itérateur est assigné à la liste "
"cible (*target_list* dans la grammaire ci-dessus) en utilisant les règles "
"des affectations (voir :ref:`assignment`), puis la « suite » est exécutée. "
"Lorsque les éléments de l'itérateur sont épuisés, la « suite » de la clause :"
"keyword:`!else`, si elle existe, est exécutée et la boucle se termine."

#: reference/compound_stmts.rst:173
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"Une instruction :keyword:`break` exécutée dans la première suite termine la "
"boucle sans exécuter la suite de la clause :keyword:`!else`. Une "
"instruction :keyword:`continue` exécutée dans la première suite saute le "
"reste de la suite et continue avec l'élément suivant, ou avec la clause :"
"keyword:`!else` s'il n'y a pas d'élément suivant."

#: reference/compound_stmts.rst:179
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"La boucle ``for`` effectue des affectations aux variables de la liste cible, "
"ce qui écrase toutes les affectations antérieures de ces variables, y "
"compris celles effectuées dans la suite de la boucle ``for`` ::"

#: reference/compound_stmts.rst:183
msgid ""
"for i in range(10):\n"
"    print(i)\n"
"    i = 5             # this will not affect the for-loop\n"
"                      # because i will be overwritten with the next\n"
"                      # index in the range"
msgstr ""

#: reference/compound_stmts.rst:193
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in type :func:`range` represents immutable arithmetic "
"sequences of integers. For instance, iterating ``range(3)`` successively "
"yields 0, 1, and then 2."
msgstr ""
"Les noms dans la liste cible ne sont pas supprimés lorsque la boucle est "
"terminée mais, si la séquence est vide, ils n'auront pas du tout été "
"assignés par la boucle. Petite astuce : le type natif :func:`range` "
"représente des suites arithmétiques immuables de nombres entiers ; par "
"exemple, itérer sur ``range(3)`` renvoie successivement les entiers 0, 1 et "
"2."

# suit un :
#: reference/compound_stmts.rst:198
msgid "Starred elements are now allowed in the expression list."
msgstr ""
"les éléments étoilés sont maintenant autorisés dans l'expression liste."

#: reference/compound_stmts.rst:205
msgid "The :keyword:`!try` statement"
msgstr "L'instruction :keyword:`!try`"

#: reference/compound_stmts.rst:215
msgid ""
"The :keyword:`!try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"L'instruction :keyword:`!try` définit les gestionnaires d'exception ou le "
"code de nettoyage pour un groupe d'instructions :"

#: reference/compound_stmts.rst:231
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Vous trouvez des informations supplémentaires relatives aux exceptions dans "
"la section :ref:`exceptions` et, dans la section :ref:`raise`, des "
"informations relatives à l'utilisation de l'instruction :keyword:`raise` "
"pour produire des exceptions."

#: reference/compound_stmts.rst:239
msgid ":keyword:`!except` clause"
msgstr "clause :keyword:`!except`"

#: reference/compound_stmts.rst:241
#, fuzzy
msgid ""
"The :keyword:`!except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception handler "
"is executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started. This search inspects the :keyword:`!"
"except` clauses in turn until one is found that matches the exception. An "
"expression-less :keyword:`!except` clause, if present, must be last; it "
"matches any exception."
msgstr ""
"La ou les clauses :keyword:`!except` précisent un ou plusieurs gestionnaires "
"d'exceptions. Si aucune exception ne se produit dans la clause :keyword:"
"`try`, aucun gestionnaire d'exception n'est exécuté. Lorsqu'une exception se "
"produit dans la suite de :keyword:`!try`, Python recherche un gestionnaire "
"d'exception. Cette recherche inspecte les clauses :keyword:`!except`, l'une "
"après l'autre, jusqu'à trouver une correspondance. Une clause :keyword:`!"
"except` vide (c'est-à-dire sans expression), si elle est présente, doit être "
"la dernière ; elle correspond à toute exception. Pour une clause :keyword:`!"
"except` avec une expression, cette expression est évaluée et la clause "
"correspond si l'objet résultant est « compatible » avec l'exception. Un "
"objet est réputé compatible avec une exception s'il est la classe ou une "
"classe mère (mais pas une :term:`classe mère abstraite`) de l'objet "
"exception ou si c'est un *n*-uplet dont un élément est la classe ou une "
"classe mère (non-abstraite) de l'exception."

#: reference/compound_stmts.rst:249
msgid ""
"For an :keyword:`!except` clause with an expression, the expression must "
"evaluate to an exception type or a tuple of exception types. The raised "
"exception matches an :keyword:`!except` clause whose expression evaluates to "
"the class or a :term:`non-virtual base class <abstract base class>` of the "
"exception object, or to a tuple that contains such a class."
msgstr ""

#: reference/compound_stmts.rst:255
msgid ""
"If no :keyword:`!except` clause matches the exception, the search for an "
"exception handler continues in the surrounding code and on the invocation "
"stack.  [#]_"
msgstr ""
"Si aucune clause :keyword:`!except` ne correspond à l'exception, la "
"recherche d'un gestionnaire d'exception se poursuit dans le code englobant "
"et dans la pile d'appels. [#]_"

#: reference/compound_stmts.rst:259
msgid ""
"If the evaluation of an expression in the header of an :keyword:`!except` "
"clause raises an exception, the original search for a handler is canceled "
"and a search starts for the new exception in the surrounding code and on the "
"call stack (it is treated as if the entire :keyword:`try` statement raised "
"the exception)."
msgstr ""
"Si l'évaluation d'une expression dans l'en-tête d'une clause :keyword:`!"
"except` lève une exception, la recherche initiale d'un gestionnaire est "
"annulée et une recherche commence pour la nouvelle exception dans le code "
"englobant et dans la pile d'appels (c'est traité comme si l'instruction :"
"keyword:`try` avait levé l'exception)."

#: reference/compound_stmts.rst:267
msgid ""
"When a matching :keyword:`!except` clause is found, the exception is "
"assigned to the target specified after the :keyword:`!as` keyword in that :"
"keyword:`!except` clause, if present, and the :keyword:`!except` clause's "
"suite is executed. All :keyword:`!except` clauses must have an executable "
"block. When the end of this block is reached, execution continues normally "
"after the entire :keyword:`try` statement. (This means that if two nested "
"handlers exist for the same exception, and the exception occurs in the :"
"keyword:`!try` clause of the inner handler, the outer handler will not "
"handle the exception.)"
msgstr ""
"Lorsqu'une clause :keyword:`!except` correspond, l'exception est affectée à "
"la cible précisée après le mot-clé :keyword:`!as` dans cette clause :keyword:"
"`!except`, si cette cible existe, et la suite de clause :keyword:`!except` "
"est exécutée. Toutes les clauses :keyword:`!except` doivent avoir un bloc "
"exécutable. Lorsque la fin de ce bloc est atteinte, l'exécution continue "
"normalement après l'ensemble de l'instruction :keyword:`try` (cela signifie "
"que si deux gestionnaires imbriqués existent pour la même exception, et que "
"l'exception se produit dans la clause :keyword:`!try` du gestionnaire "
"interne, le gestionnaire externe ne gère pas l'exception)."

#: reference/compound_stmts.rst:278
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the :keyword:`!except` clause.  This is as if ::"
msgstr ""
"Lorsqu'une exception a été affectée en utilisant ``as cible``, elle est "
"effacée à la fin de la clause :keyword:`!except`. C'est comme si ::"

#: reference/compound_stmts.rst:281
msgid ""
"except E as N:\n"
"    foo"
msgstr ""

#: reference/compound_stmts.rst:284
msgid "was translated to ::"
msgstr "avait été traduit en \t::"

#: reference/compound_stmts.rst:286
msgid ""
"except E as N:\n"
"    try:\n"
"        foo\n"
"    finally:\n"
"        del N"
msgstr ""

#: reference/compound_stmts.rst:292
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the :keyword:`!except` clause. Exceptions are cleared "
"because with the traceback attached to them, they form a reference cycle "
"with the stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""
"Cela veut dire que l'exception doit être assignée à un nom différent pour "
"pouvoir s'y référer après la clause :keyword:`!except`. Les exceptions sont "
"effacées parce qu'avec la trace de la pile d'appels qui leur est attachée, "
"elles créent un cycle dans les pointeurs de références (avec le cadre de la "
"pile), ce qui conduit à conserver tous les noms locaux de ce cadre en "
"mémoire jusqu'au passage du ramasse-miettes."

#: reference/compound_stmts.rst:302
msgid ""
"Before an :keyword:`!except` clause's suite is executed, the exception is "
"stored in the :mod:`sys` module, where it can be accessed from within the "
"body of the :keyword:`!except` clause by calling :func:`sys.exception`. When "
"leaving an exception handler, the exception stored in the :mod:`sys` module "
"is reset to its previous value::"
msgstr ""
"Avant qu'une suite de clauses :keyword:`!except` ne soit exécutée, "
"l'exception est stockée dans le module :mod:`sys`, où elle est accessible "
"depuis le corps de la clause :keyword:`!except` en appelant :func:`sys."
"exception`. Lorsque vous quittez un gestionnaire d'exceptions, l'exception "
"stockée dans le module :mod:`sys` est réinitialisée à sa valeur précédente ::"

#: reference/compound_stmts.rst:308
msgid ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"
msgstr ""

#: reference/compound_stmts.rst:333
msgid ":keyword:`!except*` clause"
msgstr "clause :keyword:`!except*`"

#: reference/compound_stmts.rst:335
msgid ""
"The :keyword:`!except*` clause(s) are used for handling :exc:"
"`ExceptionGroup`\\s. The exception type for matching is interpreted as in "
"the case of :keyword:`except`, but in the case of exception groups we can "
"have partial matches when the type matches some of the exceptions in the "
"group. This means that multiple :keyword:`!except*` clauses can execute, "
"each handling part of the exception group. Each clause executes at most once "
"and handles an exception group of all matching exceptions.  Each exception "
"in the group is handled by at most one :keyword:`!except*` clause, the first "
"that matches it. ::"
msgstr ""
"Les clauses :keyword:`!except*` sont utilisées pour gérer des :exc:"
"`ExceptionGroup`. Le type de l'exception pour la correspondance est "
"interprété de la même manière que dans le cas d'un :keyword:`except` mais, "
"dans le cas d'un groupe d'exceptions, il est possible d'avoir une "
"correspondance partielle quand le type correspond à une ou plusieurs "
"exceptions dans le groupe. Cela veut dire que plusieurs clauses :keyword:`!"
"except*` peuvent être exécutées, chacune gérant une partie du groupe "
"d'exceptions. Chaque clause ne s'exécute (au maximum) qu'une fois et gère un "
"groupe d'exception constitué des exceptions qui correspondent. Chaque "
"exception du groupe est gérée par une clause :keyword:`!except*` au plus, la "
"première à laquelle elle correspond. ::"

#: reference/compound_stmts.rst:345
msgid ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"
msgstr ""

#: reference/compound_stmts.rst:363
#, fuzzy
msgid ""
"Any remaining exceptions that were not handled by any :keyword:`!except*` "
"clause are re-raised at the end, along with all exceptions that were raised "
"from within the :keyword:`!except*` clauses. If this list contains more than "
"one exception to reraise, they are combined into an exception group."
msgstr ""
"Toutes les exceptions restantes qui n'ont été gérées par aucune clause :"
"keyword:`!except*` sont réactivées à la fin, combinées dans un groupe "
"d'exceptions avec toutes les exceptions qui ont été levées à partir des "
"clauses :keyword:`!except*`."

#: reference/compound_stmts.rst:369
msgid ""
"If the raised exception is not an exception group and its type matches one "
"of the :keyword:`!except*` clauses, it is caught and wrapped by an exception "
"group with an empty message string. ::"
msgstr ""
"Si l'exception levée n'est pas un groupe d'exceptions et que son type "
"correspond à l'une des clauses :keyword:`!except*`, elle est interceptée et "
"encapsulée par un groupe d'exceptions avec une chaîne de message vide. ::"

#: reference/compound_stmts.rst:373
msgid ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"
msgstr ""

#: reference/compound_stmts.rst:380
msgid ""
"An :keyword:`!except*` clause must have a matching expression; it cannot be "
"``except*:``. Furthermore, this expression cannot contain exception group "
"types, because that would have ambiguous semantics."
msgstr ""

#: reference/compound_stmts.rst:384
#, fuzzy
msgid ""
"It is not possible to mix :keyword:`except` and :keyword:`!except*` in the "
"same :keyword:`try`. :keyword:`break`, :keyword:`continue` and :keyword:"
"`return` cannot appear in an :keyword:`!except*` clause."
msgstr ""
"Une clause :keyword:`!except*` doit avoir un type correspondant, et ce type "
"ne peut pas être une sous-classe de :exc:`BaseExceptionGroup`. Il n'est pas "
"possible de combiner :keyword:`except` et :keyword:`!except*` dans un même :"
"keyword:`try`. Aucune clause :keyword:`break`, :keyword:`continue` ou :"
"keyword:`return` ne peut apparaître dans une clause :keyword:`!except*`."

#: reference/compound_stmts.rst:399
msgid ":keyword:`!else` clause"
msgstr "clause :keyword:`!else`"

#: reference/compound_stmts.rst:401
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"La clause optionnelle :keyword:`!else` n'est exécutée que si l'exécution "
"atteint la fin de la clause :keyword:`try`, aucune exception n'a été levée, "
"et aucun :keyword:`return`, :keyword:`continue`, ou :keyword:`break` ont "
"étés exécutés. Les exceptions dans la clause :keyword:`!else` ne sont pas "
"gérées par les clauses :keyword:`except` précédentes."

#: reference/compound_stmts.rst:413
msgid ":keyword:`!finally` clause"
msgstr "clause :keyword:`!finally`"

#: reference/compound_stmts.rst:415
msgid ""
"If :keyword:`!finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else` clauses.  If an exception occurs in any of the clauses and is "
"not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded::"
msgstr ""
"Si :keyword:`!finally` est présente, elle définit un gestionnaire de "
"« nettoyage ». La clause :keyword:`try` est exécutée, y compris les clauses :"
"keyword:`except` et :keyword:`else`. Si une exception se produit dans l'une "
"des clauses et n'est pas traitée, l'exception est temporairement "
"sauvegardée. La clause :keyword:`!finally` est exécutée. S'il y a une "
"exception sauvegardée, elle est levée à nouveau à la fin de la clause :"
"keyword:`!finally`. Si la clause :keyword:`!finally` lève une autre "
"exception, l'exception sauvegardée est définie comme le contexte de la "
"nouvelle exception. Si la clause :keyword:`!finally` exécute une "
"instruction :keyword:`return`, :keyword:`break` ou :keyword:`continue`, "
"l'exception sauvegardée est jetée ::"

#: reference/compound_stmts.rst:425
msgid ""
">>> def f():\n"
"...     try:\n"
"...         1/0\n"
"...     finally:\n"
"...         return 42\n"
"...\n"
">>> f()\n"
"42"
msgstr ""

#: reference/compound_stmts.rst:434
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`!finally` clause."
msgstr ""
"L'information relative à l'exception n'est pas disponible pour le programme "
"pendant l'exécution de la clause :keyword:`!finally`."

#: reference/compound_stmts.rst:442
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`!finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"Lorsqu'une instruction :keyword:`return`, :keyword:`break` ou :keyword:"
"`continue` est exécutée dans la suite d'une instruction :keyword:`try` d'une "
"construction :keyword:`!try`…\\ :keyword:`!finally`, la clause :keyword:`!"
"finally` est aussi exécutée « à la sortie »."

#: reference/compound_stmts.rst:446
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`!finally` clause always executes, "
"a :keyword:`!return` statement executed in the :keyword:`!finally` clause "
"will always be the last one executed::"
msgstr ""
"La valeur de retour d'une fonction est déterminée par la dernière "
"instruction :keyword:`return` exécutée. Puisque la clause :keyword:`!"
"finally` s'exécute toujours, une instruction :keyword:`!return` exécutée "
"dans le :keyword:`!finally` sera toujours la dernière clause exécutée ::"

#: reference/compound_stmts.rst:451
msgid ""
">>> def foo():\n"
"...     try:\n"
"...         return 'try'\n"
"...     finally:\n"
"...         return 'finally'\n"
"...\n"
">>> foo()\n"
"'finally'"
msgstr ""

#: reference/compound_stmts.rst:460
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`!finally` clause due to a problem with the implementation."
msgstr ""
"Avant Python 3.8, une instruction :keyword:`continue` n'était pas licite "
"dans une clause :keyword:`!finally` en raison d'un problème dans "
"l'implémentation."

#: reference/compound_stmts.rst:469
msgid "The :keyword:`!with` statement"
msgstr "L'instruction :keyword:`!with`"

#: reference/compound_stmts.rst:478
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"L'instruction :keyword:`with` est utilisée pour encapsuler l'exécution d'un "
"bloc avec des méthodes définies par un gestionnaire de contexte (voir la "
"section :ref:`context-managers`). Cela permet d'utiliser de manière simple "
"le patron de conception classique :keyword:`try`…\\ :keyword:`except`…\\ :"
"keyword:`finally`."

#: reference/compound_stmts.rst:488
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"L'exécution de l'instruction :keyword:`with` avec un seul « élément » "
"(*item* dans la grammaire) se déroule comme suit :"

#: reference/compound_stmts.rst:490
msgid ""
"The context expression (the expression given in the :token:`~python-grammar:"
"with_item`) is evaluated to obtain a context manager."
msgstr ""
"L'expression de contexte (l'expression donnée dans le :token:`~python-"
"grammar:with_item`) est évaluée pour obtenir un gestionnaire de contexte."

#: reference/compound_stmts.rst:493
#, fuzzy
msgid ""
"The context manager's :meth:`~object.__enter__` is loaded for later use."
msgstr ""
"La méthode :meth:`__enter__` du gestionnaire de contexte est chargée pour "
"une utilisation ultérieure."

#: reference/compound_stmts.rst:495
#, fuzzy
msgid "The context manager's :meth:`~object.__exit__` is loaded for later use."
msgstr ""
"La méthode :meth:`__exit__` du gestionnaire de contexte est chargée pour une "
"utilisation ultérieure."

#: reference/compound_stmts.rst:497
#, fuzzy
msgid "The context manager's :meth:`~object.__enter__` method is invoked."
msgstr "La méthode :meth:`__enter__` du gestionnaire de contexte est invoquée."

#: reference/compound_stmts.rst:499
#, fuzzy
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`~object.__enter__` is assigned to it."
msgstr ""
"Si une cible (*target* dans la grammaire ci-dessus) a été incluse dans "
"l'instruction :keyword:`with`, la valeur de retour de :meth:`__enter__` lui "
"est assignée."

#: reference/compound_stmts.rst:504
#, fuzzy
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`~object."
"__enter__` method returns without an error, then :meth:`~object.__exit__` "
"will always be called. Thus, if an error occurs during the assignment to the "
"target list, it will be treated the same as an error occurring within the "
"suite would be. See step 7 below."
msgstr ""
"L'instruction :keyword:`with` garantit que si la méthode :meth:`__enter__` "
"se termine sans erreur, alors la méthode :meth:`__exit__` est toujours "
"appelée. Ainsi, si une erreur se produit pendant l'affectation à la liste "
"cible, elle est traitée de la même façon qu'une erreur se produisant dans la "
"suite. Voir l'étape 7 ci-dessous."

#: reference/compound_stmts.rst:510
msgid "The suite is executed."
msgstr "La suite est exécutée."

#: reference/compound_stmts.rst:512
#, fuzzy
msgid ""
"The context manager's :meth:`~object.__exit__` method is invoked.  If an "
"exception caused the suite to be exited, its type, value, and traceback are "
"passed as arguments to :meth:`~object.__exit__`. Otherwise, three :const:"
"`None` arguments are supplied."
msgstr ""
"La méthode :meth:`__exit__` du gestionnaire de contexte est invoquée. Si une "
"exception a causé la sortie de la suite, son type, sa valeur et sa pile "
"d'appels sont passés en arguments à :meth:`__exit__`. Sinon, trois "
"arguments :const:`None` sont fournis."

#: reference/compound_stmts.rst:517
#, fuzzy
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`~object.__exit__` method was false, the exception is reraised.  If the "
"return value was true, the exception is suppressed, and execution continues "
"with the statement following the :keyword:`with` statement."
msgstr ""
"Si l'on est sorti de la suite en raison d'une exception et que la valeur de "
"retour de la méthode :meth:`__exit__` était fausse, l'exception est levée à "
"nouveau. Si la valeur de retour était vraie, l'exception est supprimée et "
"l'exécution continue avec l'instruction qui suit l'instruction :keyword:"
"`with`."

#: reference/compound_stmts.rst:522
#, fuzzy
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`~object.__exit__` is ignored, and execution proceeds at "
"the normal location for the kind of exit that was taken."
msgstr ""
"Si l'on est sorti de la suite pour une raison autre qu'une exception, la "
"valeur de retour de :meth:`__exit__` est ignorée et l'exécution se poursuit "
"à l'endroit normal pour le type de sortie prise."

#: reference/compound_stmts.rst:526 reference/compound_stmts.rst:1547
#: reference/compound_stmts.rst:1588
msgid "The following code::"
msgstr "Le code suivant ::"

#: reference/compound_stmts.rst:528
msgid ""
"with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""

#: reference/compound_stmts.rst:531 reference/compound_stmts.rst:556
#: reference/compound_stmts.rst:1593
msgid "is semantically equivalent to::"
msgstr "est sémantiquement équivalent à ::"

#: reference/compound_stmts.rst:533
msgid ""
"manager = (EXPRESSION)\n"
"enter = type(manager).__enter__\n"
"exit = type(manager).__exit__\n"
"value = enter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        exit(manager, None, None, None)"
msgstr ""

#: reference/compound_stmts.rst:550
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"Avec plus d'un élément, les gestionnaires de contexte sont traités comme si "
"plusieurs instructions :keyword:`with` étaient imbriquées ::"

#: reference/compound_stmts.rst:553
msgid ""
"with A() as a, B() as b:\n"
"    SUITE"
msgstr ""

#: reference/compound_stmts.rst:558
msgid ""
"with A() as a:\n"
"    with B() as b:\n"
"        SUITE"
msgstr ""

#: reference/compound_stmts.rst:562
msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr ""
"Vous pouvez aussi écrire des gestionnaires de contexte sur plusieurs lignes "
"pour plus d'un élément si ceux-ci sont placés entre parenthèses. Par "
"exemple ::"

#: reference/compound_stmts.rst:565
msgid ""
"with (\n"
"    A() as a,\n"
"    B() as b,\n"
"):\n"
"    SUITE"
msgstr ""

#: reference/compound_stmts.rst:571
msgid "Support for multiple context expressions."
msgstr "Prise en charge de multiples expressions de contexte."

# Pas de majuscule car après un :
#: reference/compound_stmts.rst:574
msgid ""
"Support for using grouping parentheses to break the statement in multiple "
"lines."
msgstr ""
"prise en charge des parenthèses pour pouvoir écrire l'instruction sur "
"plusieurs lignes."

#: reference/compound_stmts.rst:579
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` — L'instruction « *with* »"

#: reference/compound_stmts.rst:580
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"La spécification, les motivations et des exemples de l'instruction :keyword:"
"`with` en Python."

#: reference/compound_stmts.rst:586
msgid "The :keyword:`!match` statement"
msgstr "L'instruction :keyword:`!match`"

#: reference/compound_stmts.rst:600
msgid "The match statement is used for pattern matching.  Syntax:"
msgstr ""
"L'instruction *match* est utilisée pour le filtrage par motif. Sa syntaxe "
"est :"

# Pas de majuscule car après un :
#: reference/compound_stmts.rst:609
msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr ""
"cette section utilise les guillemets simples pour désigner les :ref:`mots-"
"clés ad-hoc <soft-keywords>`."

#: reference/compound_stmts.rst:612
msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a subject "
"value (following ``match``).  The pattern (which may contain subpatterns) is "
"matched against the subject value.  The outcomes are:"
msgstr ""
"Le filtrage par motif prend un motif en entrée (``pattern`` après ``case``) "
"et un champ de recherche (``subject_expr`` après ``match``). Le motif du "
"filtre (qui peut contenir des sous-motifs de filtrage) est confronté au "
"contenu du champ de recherche. La sortie est composée de :"

# énumération
#: reference/compound_stmts.rst:616
msgid "A match success or failure (also termed a pattern success or failure)."
msgstr ""
"un indicateur de réussite ou d'échec pour le filtrage (on peut aussi dire "
"que le motif a réussi ou échoué) ;"

# énumération
#: reference/compound_stmts.rst:618
msgid ""
"Possible binding of matched values to a name.  The prerequisites for this "
"are further discussed below."
msgstr ""
"la possibilité de lier les valeurs filtrées à un nom. Les pré-requis sont "
"indiqués plus bas."

#: reference/compound_stmts.rst:621
msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-keywords>`."
msgstr ""
"Les mots-clés ``match`` et ``case`` sont des :ref:`mots-clés ad-hoc <soft-"
"keywords>`."

#: reference/compound_stmts.rst:625 reference/compound_stmts.rst:1182
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` — Spécifications pour le filtrage par motif"

#: reference/compound_stmts.rst:626 reference/compound_stmts.rst:1183
msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ":pep:`636` — Tutoriel pour le filtrage par motif"

#: reference/compound_stmts.rst:630
msgid "Overview"
msgstr "Aperçu"

#: reference/compound_stmts.rst:632
msgid "Here's an overview of the logical flow of a match statement:"
msgstr "Voici un aperçu du déroulement logique d'un filtrage par motif :"

#: reference/compound_stmts.rst:635
msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting subject "
"value obtained. If the subject expression contains a comma, a tuple is "
"constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""
"L'expression confrontée aux filtres, ``subject_expr``, est évaluée pour "
"obtenir la valeur résultante. Si l'expression contient une virgule, un *n*-"
"uplet est construit en utilisant les :ref:`règles classiques <typesseq-"
"tuple>`."

#: reference/compound_stmts.rst:639
msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The "
"match attempt can also bind some or all of the standalone names within the "
"pattern. The precise pattern binding rules vary per pattern type and are "
"specified below.  **Name bindings made during a successful pattern match "
"outlive the executed block and can be used after the match statement**."
msgstr ""
"Chaque filtre des blocs ``case_block`` est confronté à la valeur résultante "
"du champ de recherche. Les règles particulières pour la réussite ou l'échec "
"sont décrites plus bas. La confrontation du filtre peut aussi conduire à "
"lier un ou plusieurs noms présents dans le motif. Les règles pour lier les "
"noms des motifs dépendent du type de filtre et sont décrites plus bas. **Le "
"nommage effectué lors d'un filtrage par motif qui a réussi persiste à "
"l'extérieur du bloc et le nom peut être utilisé après l'instruction** "
"``match``."

# Pas de majuscule car après ':'
#: reference/compound_stmts.rst:648
msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely on "
"bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior is "
"dependent on implementation and may vary.  This is an intentional decision "
"made to allow different implementations to add optimizations."
msgstr ""
"en cas d'échec de la recherche, certains sous-filtres peuvent avoir réussi. "
"Ne vous fiez pas aux nommages faits lors d'un filtrage qui a échoué. "
"Inversement, ne vous fiez pas aux variables qui restent inchangées après un "
"filtrage infructueux. Le comportement exact dépend de l'implémentation et "
"peut varier. Il s'agit d'un choix intentionnel afin de permettre aux "
"implémentations d'ajouter des optimisations."

#: reference/compound_stmts.rst:655
msgid ""
"If the pattern succeeds, the corresponding guard (if present) is evaluated. "
"In this case all name bindings are guaranteed to have happened."
msgstr ""
"Si la recherche réussit, la garde correspondante (si elle existe) est "
"évaluée. Dans ce cas, on est sûr que les nommages ont bien eu lieu."

#: reference/compound_stmts.rst:658
msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr ""
"Si la garde s'évalue à vrai ou s'il n'y a pas de garde, le ``block`` à "
"l'intérieur du ``case_block`` est exécuté."

#: reference/compound_stmts.rst:661
msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr "Sinon, le ``case_block`` est testé comme décrit ci-dessus."

#: reference/compound_stmts.rst:663
msgid "If there are no further case blocks, the match statement is completed."
msgstr "S'il n'y a plus de bloc ``case_block``, l'instruction est terminée."

# Pas de majuscule car après ':'
#: reference/compound_stmts.rst:667
msgid ""
"Users should generally never rely on a pattern being evaluated.  Depending "
"on implementation, the interpreter may cache values or use other "
"optimizations which skip repeated evaluations."
msgstr ""
"l'utilisateur ne doit jamais faire confiance à un filtre en cours "
"d'évaluation. En fonction de l'implémentation, l'interpréteur peut mettre "
"des valeurs en cache ou utiliser des optimisations qui évitent des "
"réévaluations."

#: reference/compound_stmts.rst:671
msgid "A sample match statement::"
msgstr "Voici un exemple d'instruction de filtrage par motif ::"

#: reference/compound_stmts.rst:673
msgid ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # Mismatch: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # Successful match, but guard fails\n"
"...        print('Case 2')\n"
"...    case (100, y):  # Matches and binds y to 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # Pattern not attempted\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"
msgstr ""

#: reference/compound_stmts.rst:687
msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr ""
"Dans cet exemple, ``if flag`` est une garde. Plus de détails sont fournis "
"dans la prochaine section."

#: reference/compound_stmts.rst:690
msgid "Guards"
msgstr "Gardes"

#: reference/compound_stmts.rst:697
msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside the "
"``case`` block to execute.  It takes the form: :keyword:`if` followed by an "
"expression."
msgstr ""
"Une garde (``guard`` qui fait partie du ``case``) doit s'évaluer à vrai pour "
"que le code à l'intérieur du bloc ``case`` soit exécuté. Elle s'écrit sous "
"la forme du mot-clé :keyword:`if` suivi d'une expression."

#: reference/compound_stmts.rst:702
msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr ""
"Le déroulement logique d'un bloc ``case`` qui comprend une garde est le "
"suivant :"

#: reference/compound_stmts.rst:704
msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr ""
"Vérification que le filtrage dans le bloc ``case`` est fructueux. Si le "
"filtrage échoue, la garde n'est pas évaluée et on passe au bloc ``case`` "
"suivant."

#: reference/compound_stmts.rst:708
msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr "Si le filtrage est fructueux, évaluation de la garde."

#: reference/compound_stmts.rst:710
msgid ""
"If the ``guard`` condition evaluates as true, the case block is selected."
msgstr "Si la garde s'évalue à *vrai*, le bloc est sélectionné."

#: reference/compound_stmts.rst:713
msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr "Si la garde s'évalue à *faux*, le bloc n'est pas sélectionné."

#: reference/compound_stmts.rst:716
msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr ""
"Si une exception est levée lors de l'évaluation de la garde, cette exception "
"est propagée."

#: reference/compound_stmts.rst:719
msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., guard "
"evaluation must happen in order.) Guard evaluation must stop once a case "
"block is selected."
msgstr ""
"Les gardes étant des expressions, il est possible qu'elles aient des effets "
"secondaires. L'ordre d'évaluation des gardes est du premier au dernier bloc "
"``case``, un à la fois, en sautant les blocs ``case`` dont la recherche de "
"motif échouent. L'évaluation des gardes s'arrête dès qu'un bloc ``case`` est "
"sélectionné."

#: reference/compound_stmts.rst:729
msgid "Irrefutable Case Blocks"
msgstr "Bloc ``case`` attrape-tout"

#: reference/compound_stmts.rst:733
msgid ""
"An irrefutable case block is a match-all case block.  A match statement may "
"have at most one irrefutable case block, and it must be last."
msgstr ""
"Un bloc ``case`` attrape-tout est un bloc qui réussit toujours. Une "
"instruction ``match`` ne peut avoir qu'un seul bloc attrape-tout, et ce doit "
"être le dernier."

#: reference/compound_stmts.rst:736
msgid ""
"A case block is considered irrefutable if it has no guard and its pattern is "
"irrefutable.  A pattern is considered irrefutable if we can prove from its "
"syntax alone that it will always succeed.  Only the following patterns are "
"irrefutable:"
msgstr ""
"Un bloc ``case`` est considéré attrape-tout s'il n'y a pas de garde et que "
"le motif est attrape-tout. Un motif est attrape-tout si l'on peut "
"déterminer, simplement à partir de sa syntaxe, qu'il correspond toujours. "
"Seuls les motifs suivants sont attrape-tout :"

#: reference/compound_stmts.rst:741
msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr "Les :ref:`as-patterns` pour lesquels la partie gauche est attrape-tout"

#: reference/compound_stmts.rst:743
msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr "Les :ref:`or-patterns` contenant au moins un filtre attrape-tout"

#: reference/compound_stmts.rst:745
msgid ":ref:`capture-patterns`"
msgstr "Les :ref:`capture-patterns`"

#: reference/compound_stmts.rst:747
msgid ":ref:`wildcard-patterns`"
msgstr "Les :ref:`wildcard-patterns`"

#: reference/compound_stmts.rst:749
msgid "parenthesized irrefutable patterns"
msgstr "les filtres attrape-tout entre parenthèses"

#: reference/compound_stmts.rst:753
msgid "Patterns"
msgstr "Filtres"

#: reference/compound_stmts.rst:760
msgid "This section uses grammar notations beyond standard EBNF:"
msgstr ""
"Cette section utilise des notations grammaticales qui ne font pas partie du "
"standard EBNF :"

#: reference/compound_stmts.rst:762
msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr "la notation ``SEP.REGLE+`` désigne ``REGLE (SEP REGLE)*``"

#: reference/compound_stmts.rst:764
msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr ""
"la notation ``!REGLE`` désigne la négation logique de l'assertion ``REGLE``"

#: reference/compound_stmts.rst:767
msgid "The top-level syntax for ``patterns`` is:"
msgstr "La syntaxe générale pour les filtres ``patterns`` est :"

#: reference/compound_stmts.rst:781
msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond Hettinger "
"for a document that inspired most of the descriptions). Note that these "
"descriptions are purely for illustration purposes and **may not** reflect "
"the underlying implementation.  Furthermore, they do not cover all valid "
"forms."
msgstr ""
"Les explications ci-dessous décrivent « en termes simples » ce qu'un modèle "
"fait (merci à Raymond Hettinger pour son document qui a inspiré la plupart "
"des descriptions). Notez que ces descriptions sont purement à fin "
"d'illustration et peuvent ne **pas** être strictement conformes à "
"l'implémentation sous-jacente. De plus, nous ne couvrons pas toutes les "
"formes valides."

#: reference/compound_stmts.rst:791
msgid "OR Patterns"
msgstr "Filtres OU"

#: reference/compound_stmts.rst:793
msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr ""
"Un filtre OU est composé de deux filtres ou plus séparés par des barres "
"verticales ``|``. La syntaxe est :"

#: reference/compound_stmts.rst:799
msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, and "
"each subpattern must bind the same set of names to avoid ambiguity."
msgstr ""
"Seul le dernier sous-filtre peut être :ref:`attrape-tout <irrefutable_case>` "
"et chaque sous-filtre doit être lié au même ensemble de noms pour éviter "
"toute ambigüité."

#: reference/compound_stmts.rst:802
msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject value, "
"until one succeeds.  The OR pattern is then considered successful.  "
"Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr ""
"Un filtre OU confronte chacun des sous-filtres à tour de rôle à la valeur du "
"champ de recherche, jusqu'à ce que l'un d'eux réussisse. Le filtre OU "
"réussit si l'un des sous-filtres a réussi, sinon il échoue."

#: reference/compound_stmts.rst:806
msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails it "
"will try to match ``P2``, succeeding immediately if any succeeds, failing "
"otherwise."
msgstr ""
"En termes plus simples, ``M1 | M2 | ...`` teste le filtre par motif ``M1``, "
"s'il échoue il teste le filtre par motif ``M2``, réussit immédiatement si "
"l'un d'eux réussit, échoue dans le cas contraire."

#: reference/compound_stmts.rst:812
msgid "AS Patterns"
msgstr "Filtres AS"

#: reference/compound_stmts.rst:814
msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` keyword "
"against a subject.  Syntax:"
msgstr ""
"Un filtre AS confronte un filtre OU sur la gauche du mot-clé :keyword:`as` "
"au champ de recherche. La syntaxe est la suivante :"

#: reference/compound_stmts.rst:820
msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern "
"binds the subject to the name on the right of the as keyword and succeeds. "
"``capture_pattern`` cannot be a ``_``."
msgstr ""
"Si le filtre OU échoue, le filtre AS échoue. Sinon, le filtre AS lie le "
"champ de recherche au nom sur la droite du mot-clé ``as`` et réussit. "
"``capture_pattern`` ne peut pas être un ``_``."

#: reference/compound_stmts.rst:824
msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it will "
"set ``NAME = <subject>``."
msgstr ""
"En termes simples, ``M as NOM`` filtre avec le motif ``M`` et, s'il réussit, "
"définit ``NOM = <subject>``."

#: reference/compound_stmts.rst:831
msgid "Literal Patterns"
msgstr "Filtres littéraux"

#: reference/compound_stmts.rst:833
msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in Python.  "
"Syntax:"
msgstr ""
"Un filtre littéral effectue une correspondance avec la plupart des :ref:"
"`littéraux <literals>` en Python. La syntaxe est la suivante :"

#: reference/compound_stmts.rst:846
msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in the :doc:"
"`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings` "
"are not supported."
msgstr ""
"La règle ``strings`` et le lexème ``NUMBER`` sont définis dans :doc:`la "
"grammaire de Python standard <./grammar>`. Les chaînes avec triples "
"guillemets sont gérées. Les chaînes brutes et les chaînes d'octets sont "
"gérées. Les :ref:`f-strings` ne sont pas gérées."

#: reference/compound_stmts.rst:851
msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` are "
"for expressing :ref:`complex numbers <imaginary>`; they require a real "
"number on the left and an imaginary number on the right. E.g. ``3 + 4j``."
msgstr ""
"Les formes ``signed_number '+' NUMBER`` et ``signed_number '-' NUMBER`` "
"permettent d'exprimer des :ref:`nombres complexes <imaginary>` ; vous devez "
"indiquer un nombre réel sur la gauche et un nombre imaginaire sur la droite. "
"Par exemple, ``3 + 4j``."

#: reference/compound_stmts.rst:855
msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == LITERAL``. "
"For the singletons ``None``, ``True`` and ``False``, the :keyword:`is` "
"operator is used."
msgstr ""
"En termes simples, ``LITERAL`` réussit seulement si ``<subject> == "
"LITERAL``. Pour les singletons ``None``, ``True`` et ``False``, l'opérateur :"
"keyword:`is` est utilisé."

#: reference/compound_stmts.rst:861
msgid "Capture Patterns"
msgstr "Filtres de capture"

#: reference/compound_stmts.rst:863
msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr ""
"Un filtre de capture lie la valeur du champ de recherche à un nom. La "
"syntaxe est la suivante :"

#: reference/compound_stmts.rst:869
msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'`` "
"expresses). It is instead treated as a :token:`~python-grammar:"
"wildcard_pattern`."
msgstr ""
"Un simple caractère souligné ``_`` n'est pas un filtre de capture (c'est ce "
"que ``!'_'`` veut dire). C'est le motif pour désigner un filtre attrape-tout "
"(lexème :token:`~python-grammar:wilcard_pattern`, voir plus bas)."

#: reference/compound_stmts.rst:873
msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, "
"x: ...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""
"Dans un filtre donné, un nom ne peut être lié qu'une seule fois. Par "
"exemple, ``case x, x: ...`` est invalide mais ``case [x] | x: ...`` est "
"autorisé."

#: reference/compound_stmts.rst:876
msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name "
"becomes a local variable in the closest containing function scope unless "
"there's an applicable :keyword:`global` or :keyword:`nonlocal` statement."
msgstr ""
"Les filtres de capture réussissent toujours. La portée du lien est conforme "
"aux règles définies pour l'opérateur d'affectation indiquées dans la :pep:"
"`572` ; le nom devient une variable locale dans la fonction la plus "
"intérieure à moins qu'il n'y ait une instruction :keyword:`global` ou :"
"keyword:`nonlocal` qui s'applique."

#: reference/compound_stmts.rst:881
msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr ""
"En termes simples, ``NAME`` réussit toujours et définit ``NAME = <subject>``."

#: reference/compound_stmts.rst:886
msgid "Wildcard Patterns"
msgstr "Filtres attrape-tout"

#: reference/compound_stmts.rst:888
msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name.  "
"Syntax:"
msgstr ""
"Un filtre attrape-tout réussit toujours (quel que soit le champ de "
"recherche) et ne lie aucun nom. La syntaxe est la suivante :"

#: reference/compound_stmts.rst:894
msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but only "
"within patterns.  It is an identifier, as usual, even within ``match`` "
"subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""
"``_`` est un :ref:`mot-clé ad-hoc <soft-keywords>` dans un filtre par motif, "
"mais seulement dans un filtre. Ailleurs, c'est un identifiant, comme "
"d'habitude, même à l'intérieur d'une expression champ de recherche de "
"``match``, d'une garde ou d'un bloc ``case``."

#: reference/compound_stmts.rst:898
msgid "In simple terms, ``_`` will always succeed."
msgstr "En termes simples, ``_`` réussit toujours."

#: reference/compound_stmts.rst:903
msgid "Value Patterns"
msgstr "Filtres par valeurs"

#: reference/compound_stmts.rst:905
msgid "A value pattern represents a named value in Python. Syntax:"
msgstr ""
"Un filtre par valeur représente une valeur nommée de Python. Sa syntaxe est "
"la suivante :"

#: reference/compound_stmts.rst:913
msgid ""
"The dotted name in the pattern is looked up using standard Python :ref:`name "
"resolution rules <resolve_names>`.  The pattern succeeds if the value found "
"compares equal to the subject value (using the ``==`` equality operator)."
msgstr ""
"Le nom qualifié dans le filtre est recherché en utilisant la :ref:`méthode "
"de résolution des noms <resolve_names>` standard de Python. Le filtrage "
"réussit si la valeur trouvée vérifie l'égalité avec la valeur du champ de "
"recherche (en utilisant l'opérateur d'égalité ``==``)."

#: reference/compound_stmts.rst:918
msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == NAME1."
"NAME2``"
msgstr ""
"En termes plus simples, ``NOM1.NOM2`` réussit seulement si ``<subject> == "
"NOM1.NOM2``"

# Pas de majuscule car suit :
#: reference/compound_stmts.rst:922
msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than repeat "
"the same lookup.  This cache is strictly tied to a given execution of a "
"given match statement."
msgstr ""
"si la même valeur apparaît plusieurs fois dans la même instruction "
"``match``, l'interpréteur peut mettre en cache la première valeur trouvée et "
"la réutiliser plutôt que de refaire une recherche. Ce cache est strictement "
"limité à l'exécution de l'instruction ``match`` donnée."

#: reference/compound_stmts.rst:930
msgid "Group Patterns"
msgstr "Filtres de groupes"

#: reference/compound_stmts.rst:932
msgid ""
"A group pattern allows users to add parentheses around patterns to emphasize "
"the intended grouping.  Otherwise, it has no additional syntax. Syntax:"
msgstr ""
"Un filtre de groupe permet au programmeur de souligner l’intention de "
"regrouper des motifs en plaçant ceux-ci entre parenthèses. À part ça, il "
"n’introduit aucune syntaxe supplémentaire. Sa syntaxe est la suivante :"

#: reference/compound_stmts.rst:939
msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr "En termes plus simples, ``(P)`` équivaut à ``P``."

#: reference/compound_stmts.rst:944
msgid "Sequence Patterns"
msgstr "Filtres de séquences"

#: reference/compound_stmts.rst:946
msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or tuple."
msgstr ""
"Un filtre de séquence contient des sous-filtres par motif dont chacun doit "
"correspondre à un élément d’une séquence. La syntaxe est similaire au "
"déballage d’une liste ou d’un *n*-uplet."

#: reference/compound_stmts.rst:957
msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr ""
"Vous pouvez utiliser indifféremment des parenthèses ``(...)`` ou des "
"crochets ``[...]`` pour encadrer les filtres à regrouper."

# Pas de majuscule car suit :
#: reference/compound_stmts.rst:961
msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. ``(3 "
"| 4)``) is a :ref:`group pattern <group-patterns>`. While a single pattern "
"enclosed in square brackets (e.g. ``[3 | 4]``) is still a sequence pattern."
msgstr ""
"un filtre seul entre parenthèses qui ne se termine pas par une virgule (par "
"exemple ``(3 | 4)``) est un :ref:`filtre de groupe <group-patterns>`. En "
"revanche, un filtre seul entre crochets (par exemple ``[3 | 4]``) reste un "
"filtre de séquence."

#: reference/compound_stmts.rst:966
msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, the "
"sequence pattern is a fixed-length sequence pattern; otherwise it is a "
"variable-length sequence pattern."
msgstr ""
"Il peut y avoir au plus un sous-filtre étoilé (lexème ``star_pattern``) dans "
"un filtre de séquence. Le filtre étoilé peut se trouver à n’importe quelle "
"position. S’il n’y en a pas, le filtre de séquence est un filtre de séquence "
"à longueur fixe, sinon c’est un filtre de séquence à longueur variable."

#: reference/compound_stmts.rst:971
msgid ""
"The following is the logical flow for matching a sequence pattern against a "
"subject value:"
msgstr ""
"Voici le déroulement logique d’un filtrage par motif de séquence sur une "
"valeur du champ de recherche :"

#: reference/compound_stmts.rst:974
msgid ""
"If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr ""
"Si la valeur du champ de recherche n’est pas une séquence [#]_, le filtre de "
"séquence échoue."

#: reference/compound_stmts.rst:977
msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or ``bytearray`` "
"the sequence pattern fails."
msgstr ""
"Si la valeur du champ de recherche est une instance de ``str``, ``bytes`` ou "
"``bytearray``, le filtre de séquence échoue."

#: reference/compound_stmts.rst:980
msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr ""
"Les étapes suivantes dépendent de la longueur fixe ou non du filtre de "
"séquence."

#: reference/compound_stmts.rst:983
msgid "If the sequence pattern is fixed-length:"
msgstr "Si le filtre de séquence est de longueur fixe :"

# Fin de la phrase donc se termine par un point.
#: reference/compound_stmts.rst:985
msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr ""
"Si la longueur de la séquence champ de recherche n’est pas égale au nombre "
"de sous-filtres, le filtre de séquence échoue."

#: reference/compound_stmts.rst:988
msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding items "
"in the subject sequence from left to right.  Matching stops as soon as a "
"subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr ""
"Les sous-filtres de la séquence sont confrontés aux éléments correspondants "
"dans la séquence champ de recherche, de la gauche vers la droite. La "
"recherche de correspondance s’arrête dès qu’un sous-filtre échoue. Si tous "
"les sous-filtres réussissent la confrontation à l’élément du champ de "
"recherche correspondant, le filtre de séquence réussit."

#: reference/compound_stmts.rst:993
msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr "Sinon, si le filtre de séquence est de longueur variable :"

#: reference/compound_stmts.rst:995
msgid ""
"If the length of the subject sequence is less than the number of non-star "
"subpatterns, the sequence pattern fails."
msgstr ""
"Si la longueur de la séquence champ de recherche est plus petite que le "
"nombre de sous-filtres sans étoile, le filtre de séquence échoue."

#: reference/compound_stmts.rst:998
msgid ""
"The leading non-star subpatterns are matched to their corresponding items as "
"for fixed-length sequences."
msgstr ""
"Les sous-filtres sans étoile du début sont confrontés aux éléments "
"correspondants comme pour un filtre de séquences de longueur fixe."

#: reference/compound_stmts.rst:1001
msgid ""
"If the previous step succeeds, the star subpattern matches a list formed of "
"the remaining subject items, excluding the remaining items corresponding to "
"non-star subpatterns following the star subpattern."
msgstr ""
"Si les étapes précédentes ont réussi, le sous-filtre étoilé correspond à une "
"liste formée des éléments restants du champ de recherche, en excluant les "
"éléments restants qui correspondent à des sous-filtres sans étoile qui "
"suivent le sous-filtre étoilé."

#: reference/compound_stmts.rst:1005
msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject "
"items, as for a fixed-length sequence."
msgstr ""
"Les sous-filtres sans étoile qui restent sont confrontés aux éléments "
"restants du champ de recherche, comme pour un filtre de séquences de "
"longueur fixe."

# Pas de majuscule car suit :
#: reference/compound_stmts.rst:1008
msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via "
"the :meth:`__len__` protocol).  This length may be cached by the interpreter "
"in a similar manner as :ref:`value patterns <value-patterns>`."
msgstr ""
"la longueur de la séquence champ de recherche est obtenue par :func:`len` "
"(c.-à-d. avec le protocole :meth:`__len__`). Cette longueur peut être mise "
"en cache par l’interpréteur de la même manière que pour les :ref:`filtres "
"par valeur <value-patterns>`."

#: reference/compound_stmts.rst:1014
msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr ""
"En termes plus simples, ``[M1, M2, M3,`` … ``, M<N>]`` réussit seulement si "
"tout ce qui suit a lieu :"

#: reference/compound_stmts.rst:1017
msgid "check ``<subject>`` is a sequence"
msgstr "vérification que ``<subject>`` est une séquence,"

#: reference/compound_stmts.rst:1018
msgid "``len(subject) == <N>``"
msgstr "``len(subject) == <N>``,"

#: reference/compound_stmts.rst:1019
msgid ""
"``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr ""
"``M1`` correspond à ``<subject>[0]`` (notez que cette correspondance peut "
"lier des noms),"

#: reference/compound_stmts.rst:1020
msgid ""
"``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr ""
"``M2`` correspond à ``<subject>[1]`` (notez que cette correspondance peut "
"lier des noms),"

#: reference/compound_stmts.rst:1021
msgid "... and so on for the corresponding pattern/element."
msgstr "et ainsi de suite pour chaque filtre par motif / élément."

#: reference/compound_stmts.rst:1026
msgid "Mapping Patterns"
msgstr "Filtres associatifs"

#: reference/compound_stmts.rst:1028
msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is "
"similar to the construction of a dictionary. Syntax:"
msgstr ""
"Un filtre associatif contient un ou plusieurs motifs clé-valeur. La syntaxe "
"est similaire à la construction d’un dictionnaire :"

#: reference/compound_stmts.rst:1039
msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr ""
"Un seul sous-filtre doublement étoilé peut être présent dans le filtre "
"associatif. Le filtre doublement étoilé doit être le dernier sous-filtre du "
"filtre associatif."

#: reference/compound_stmts.rst:1042
msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys "
"will raise a :exc:`SyntaxError`. Two keys that otherwise have the same value "
"will raise a :exc:`ValueError` at runtime."
msgstr ""
"Il est interdit d’avoir des clés en double dans les filtres associatifs. Une "
"clé en double sous forme littérale lève une :exc:`Syntax Error`. Deux clés "
"qui ont la même valeur lèvent une :exc:`ValueError` à l’exécution."

#: reference/compound_stmts.rst:1046
msgid ""
"The following is the logical flow for matching a mapping pattern against a "
"subject value:"
msgstr ""
"Voici le déroulement d’un filtrage associatif sur la valeur du champ de "
"recherche :"

#: reference/compound_stmts.rst:1049
msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr ""
"Si la valeur du champ de recherche n'est pas un tableau associatif [#]_, le "
"filtre associatif échoue."

#: reference/compound_stmts.rst:1051
msgid ""
"If every key given in the mapping pattern is present in the subject mapping, "
"and the pattern for each key matches the corresponding item of the subject "
"mapping, the mapping pattern succeeds."
msgstr ""
"Si chaque clé donnée dans le filtre associatif est présente dans le tableau "
"associatif du champ de recherche, et que le filtre pour chaque clé "
"correspond aux éléments du tableau associatif champ de recherche, le filtre "
"associatif réussit."

#: reference/compound_stmts.rst:1055
msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""
"Si des clés identiques sont détectées dans le filtre par motif, le filtre "
"est déclaré invalide. Une :exc:`SyntaxError` est levée pour les valeurs "
"littérales dupliquées ou une :exc:`ValueError` pour des clés s'évaluant à la "
"même valeur."

# Pas de majuscule car suit :
#: reference/compound_stmts.rst:1059
#, fuzzy
msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be present "
"in the mapping, and not created on-the-fly via :meth:`__missing__` or :meth:"
"`~object.__getitem__`."
msgstr ""
"les paires clé-valeur sont associées en utilisant la forme à deux arguments "
"de la méthode ``get()`` du champ de recherche. Les paires clé-valeurs "
"associées doivent déjà être présentes dans le tableau associatif et ne sont "
"pas créées à la volée *via* :meth:`__missing__` ou :meth:`__getitem__`."

#: reference/compound_stmts.rst:1064
msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr ""
"En termes simples, ``{CLÉ1: M1, CLÉ2: M2, ... }`` réussit seulement si tout "
"ce qui suit a lieu :"

#: reference/compound_stmts.rst:1067
msgid "check ``<subject>`` is a mapping"
msgstr "vérification que ``<subject>`` est un tableau associatif,"

#: reference/compound_stmts.rst:1068
msgid "``KEY1 in <subject>``"
msgstr "``CLÉ1 in <subject>``,"

#: reference/compound_stmts.rst:1069
msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr "``M1`` correspond à ``<subject>[CLÉ1]``,"

#: reference/compound_stmts.rst:1070
msgid "... and so on for the corresponding KEY/pattern pair."
msgstr "et ainsi de suite pour chaque paire CLÉ/Motif."

#: reference/compound_stmts.rst:1076
msgid "Class Patterns"
msgstr "Filtres de classes"

#: reference/compound_stmts.rst:1078
msgid ""
"A class pattern represents a class and its positional and keyword arguments "
"(if any).  Syntax:"
msgstr ""
"Un filtre de classe représente une classe et ses arguments positionnels et "
"par mots-clés (s'il y en a). La syntaxe est la suivante :"

#: reference/compound_stmts.rst:1089
msgid "The same keyword should not be repeated in class patterns."
msgstr "Le même mot-clé ne doit pas être répété dans les filtres de classes."

#: reference/compound_stmts.rst:1091
msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr ""
"Voici le déroulement d’un filtrage de classe sur la valeur du champ de "
"recherche :"

#: reference/compound_stmts.rst:1094
msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , raise :"
"exc:`TypeError`."
msgstr ""
"Si ``name_or_attr`` n'est pas une instance de la classe native :class:"
"`type`, lève une :exc:`TypeError`."

#: reference/compound_stmts.rst:1097
msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested via :"
"func:`isinstance`), the class pattern fails."
msgstr ""
"Si la valeur du champ de recherche n'est pas une instance de "
"``name_or_attr`` (testé *via* :func:`isinstance`), le filtre de classe "
"échoue."

#: reference/compound_stmts.rst:1100
msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, the "
"subsequent steps depend on whether keyword or positional argument patterns "
"are present."
msgstr ""
"S'il n'y a pas d'argument au filtre, le filtre réussit. Sinon, les étapes "
"suivantes dépendent de la présence ou non de motifs pour les arguments "
"positionnels ou par mot-clé."

#: reference/compound_stmts.rst:1104
msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these types "
"keyword patterns also work as for other types."
msgstr ""
"Pour un certain nombre de types natifs (indiqués ci-dessous), un motif "
"positionnel seul est accepté, qui est confronté au champ de recherche en "
"entier ; pour ces types, les motifs par mots-clés fonctionnent comme les "
"autres types."

#: reference/compound_stmts.rst:1108
msgid ""
"If only keyword patterns are present, they are processed as follows, one by "
"one:"
msgstr ""
"S'il n'y a que des motifs par mot-clé (NdT : dans le sens « argument par mot-"
"clé »), ils sont évalués comme ceci, un par un :"

#: reference/compound_stmts.rst:1111
msgid "I. The keyword is looked up as an attribute on the subject."
msgstr "I. Le mot-clé est recherché en tant qu'attribut du champ de recherche."

#: reference/compound_stmts.rst:1113
msgid ""
"If this raises an exception other than :exc:`AttributeError`, the exception "
"bubbles up."
msgstr ""
"Si cela lève une exception autre que :exc:`AttributeError`, l'exception est "
"propagée vers le haut."

#: reference/compound_stmts.rst:1116
msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr "Si cela lève l'exception :exc:`AttributeError`, le filtre échoue."

#: reference/compound_stmts.rst:1118
msgid ""
"Else, the subpattern associated with the keyword pattern is matched against "
"the subject's attribute value.  If this fails, the class pattern fails; if "
"this succeeds, the match proceeds to the next keyword."
msgstr ""
"Sinon, le motif associé au mot-clé est confronté à la valeur de l'attribut "
"du champ de recherche. Si cela échoue, le filtre de classe échoue ; si cela "
"réussit, le filtre passe au mot-clé suivant."

#: reference/compound_stmts.rst:1123
msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr ""
"II. Si tous les motifs par mot-clé ont réussi, le filtre de classe réussit."

#: reference/compound_stmts.rst:1125
msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""
"Si des motifs positionnels sont présents, ils sont convertis en motifs par "
"mot-clé en utilisant l'attribut :data:`~object.__match_args__` de la classe "
"``name_or_attr`` avant le filtrage :"

#: reference/compound_stmts.rst:1129
msgid ""
"I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr ""
"I. L'équivalent de ``getattr(cls, \"__match_args__\", ())`` est appelé."

#: reference/compound_stmts.rst:1131
msgid "If this raises an exception, the exception bubbles up."
msgstr "Si cela lève une exception, elle est propagée vers le haut."

#: reference/compound_stmts.rst:1133
msgid ""
"If the returned value is not a tuple, the conversion fails and :exc:"
"`TypeError` is raised."
msgstr ""
"Si la valeur de retour n'est pas un *n*-uplet, la conversion échoue et une :"
"exc:`TypeError` est levée."

#: reference/compound_stmts.rst:1136
msgid ""
"If there are more positional patterns than ``len(cls.__match_args__)``, :exc:"
"`TypeError` is raised."
msgstr ""
"S'il y a plus de motifs positionnels que ``len(cls.__match_args__)``, une :"
"exc:`TypeError` est levée."

#: reference/compound_stmts.rst:1139
msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern using "
"``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must be a "
"string; if not :exc:`TypeError` is raised."
msgstr ""
"Sinon, le motif positionnel ``i`` est converti en motif par mot-clé (le mot-"
"clé sera ``__match_args__[i]``). ``__match_args__[i]`` doit être une chaîne, "
"sinon une :exc:`TypeError` est levée."

#: reference/compound_stmts.rst:1143
msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr "Si un mot-clé est dupliqué, une :exc:`TypeError` est levée."

#: reference/compound_stmts.rst:1145
msgid ":ref:`class-pattern-matching`"
msgstr ":ref:`class-pattern-matching`"

#: reference/compound_stmts.rst:1147
msgid ""
"II. Once all positional patterns have been converted to keyword patterns,"
msgstr ""
"II. Une fois que tous les motifs positionnels ont été convertis en motifs "
"par mot-clé,"

#: reference/compound_stmts.rst:1148
msgid "the match proceeds as if there were only keyword patterns."
msgstr ""
"le filtre se déroule comme si tous les motifs étaient des motifs par mots-"
"clés."

#: reference/compound_stmts.rst:1150
msgid ""
"For the following built-in types the handling of positional subpatterns is "
"different:"
msgstr ""
"Pour les types natifs suivants, le traitement des motifs positionnels est "
"différent :"

#: reference/compound_stmts.rst:1153
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: reference/compound_stmts.rst:1154
msgid ":class:`bytearray`"
msgstr ":class:`bytearray`"

#: reference/compound_stmts.rst:1155
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: reference/compound_stmts.rst:1156
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: reference/compound_stmts.rst:1157
msgid ":class:`float`"
msgstr ":class:`float`"

#: reference/compound_stmts.rst:1158
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: reference/compound_stmts.rst:1159
msgid ":class:`int`"
msgstr ":class:`int`"

#: reference/compound_stmts.rst:1160 reference/compound_stmts.rst:1863
msgid ":class:`list`"
msgstr ":class:`list`"

#: reference/compound_stmts.rst:1161
msgid ":class:`set`"
msgstr ":class:`set`"

#: reference/compound_stmts.rst:1162
msgid ":class:`str`"
msgstr ":class:`str`"

#: reference/compound_stmts.rst:1163 reference/compound_stmts.rst:1866
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: reference/compound_stmts.rst:1165
msgid ""
"These classes accept a single positional argument, and the pattern there is "
"matched against the whole object rather than an attribute. For example "
"``int(0|1)`` matches the value ``0``, but not the value ``0.0``."
msgstr ""
"Ces classes acceptent un argument positionnel seul et le filtre s'applique "
"alors sur l'ensemble de l'objet plutôt que sur un simple attribut. Par "
"exemple, ``int(0|1)`` réussit lorsqu'il est confronté à la valeur ``0``, "
"mais pas lorsque c'est la valeur ``0.0``."

#: reference/compound_stmts.rst:1169
msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following happens:"
msgstr ""
"En termes simples, ``CLS(P1, attr=P2)`` réussit seulement si la séquence "
"suivante est déroulée :"

#: reference/compound_stmts.rst:1171
msgid "``isinstance(<subject>, CLS)``"
msgstr "``isinstance(<subject>, CLS)``"

#: reference/compound_stmts.rst:1172
msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr ""
"convertit ``P1`` vers un motif par mot-clé en utilisant ``CLS."
"__match_args__``"

#: reference/compound_stmts.rst:1173
msgid "For each keyword argument ``attr=P2``:"
msgstr "Pour chaque argument par mot-clé ``attr=P2`` :"

#: reference/compound_stmts.rst:1175
msgid "``hasattr(<subject>, \"attr\")``"
msgstr "``hasattr(<subject>, \"attr\")``"

#: reference/compound_stmts.rst:1176
msgid "``P2`` matches ``<subject>.attr``"
msgstr "``P2`` correspond à ``<subject>.attr``"

#: reference/compound_stmts.rst:1178
msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr "… et ainsi de suite pour les paires motif/argument par mot-clé."

#: reference/compound_stmts.rst:1193
msgid "Function definitions"
msgstr "Définition de fonctions"

#: reference/compound_stmts.rst:1208
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"Une définition de fonction définit un objet fonction défini par "
"l'utilisateur (voir la section :ref:`types`) :"

#: reference/compound_stmts.rst:1228
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"Une définition de fonction est une instruction qui est exécutée. Son "
"exécution lie le nom de la fonction, dans l'espace de nommage local courant, "
"à un objet fonction (un objet qui encapsule le code exécutable de la "
"fonction). Cet objet fonction contient une référence à l'espace des noms "
"globaux courant comme espace des noms globaux à utiliser lorsque la fonction "
"est appelée."

#: reference/compound_stmts.rst:1234
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"La définition de la fonction n'exécute pas le corps de la fonction ; elle "
"n'est exécutée que lorsque la fonction est appelée. [#]_"

#: reference/compound_stmts.rst:1240
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"Une définition de fonction peut être encapsulée dans une ou plusieurs "
"expressions :term:`decorator` ; les décorateurs sont évalués lorsque la "
"fonction est définie, dans la portée qui contient la définition de "
"fonction ; le résultat doit être un appelable, qui est invoqué avec l'objet "
"fonction comme seul argument ; la valeur renvoyée est liée au nom de la "
"fonction en lieu et place de l'objet fonction. Lorsqu'il y a plusieurs "
"décorateurs, ils sont appliqués par imbrication ; par exemple, le code "
"suivant ::"

#: reference/compound_stmts.rst:1247
msgid ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"
msgstr ""

#: reference/compound_stmts.rst:1251 reference/compound_stmts.rst:1446
msgid "is roughly equivalent to ::"
msgstr "est à peu près équivalent à ::"

#: reference/compound_stmts.rst:1253
msgid ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"
msgstr ""

#: reference/compound_stmts.rst:1256
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"sauf que la fonction originale n'est pas temporairement liée au nom ``func``."

# Pas de majuscule : ok.
#: reference/compound_stmts.rst:1258
msgid ""
"Functions may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"les fonctions peuvent être décorées par toute :token:`expression "
"d'affectation <~python-grammar:assignment_expression>` valide. Auparavant, "
"la grammaire était beaucoup plus restrictive ; voir la :pep:`614` pour "
"obtenir les détails."

#: reference/compound_stmts.rst:1263
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets between the function's name and the opening parenthesis for its "
"parameter list. This indicates to static type checkers that the function is "
"generic. At runtime, the type parameters can be retrieved from the "
"function's :attr:`~function.__type_params__` attribute. See :ref:`generic-"
"functions` for more."
msgstr ""

#: reference/compound_stmts.rst:1270 reference/compound_stmts.rst:1465
msgid "Type parameter lists are new in Python 3.12."
msgstr ""

#: reference/compound_stmts.rst:1278
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"Lorsqu'un ou plusieurs :term:`paramètres <parameter>` sont de la forme "
"*parameter* ``=`` *expression*, on dit que la fonction a des « valeurs de "
"paramètres par défaut ». Pour un paramètre avec une valeur par défaut, l’:"
"term:`argument` correspondant peut être omis lors de l'appel, la valeur par "
"défaut du paramètre est alors utilisée. Si un paramètre a une valeur par "
"défaut, tous les paramètres suivants jusqu'à \"``*``\" doivent aussi avoir "
"une valeur par défaut — ceci est une restriction syntaxique qui n'est pas "
"exprimée dans la grammaire."

#: reference/compound_stmts.rst:1286
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default parameter value is in effect modified.  This "
"is generally not what was intended.  A way around this is to use ``None`` as "
"the default, and explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**Les valeurs par défaut des paramètres sont évaluées de la gauche vers la "
"droite quand la définition de la fonction est exécutée**. Cela signifie que "
"l'expression est évaluée une fois, lorsque la fonction est définie, et que "
"c'est la même valeur « pré-calculée » qui est utilisée à chaque appel. C'est "
"particulièrement important à comprendre lorsque la valeur d'un paramètre par "
"défaut est un objet mutable (cas d'une liste ou un dictionnaire par "
"exemple) : si la fonction modifie l'objet (par exemple en ajoutant un "
"élément à une liste), la valeur par défaut est modifiée. En général, ce "
"n'est pas l'effet voulu. Une façon d'éviter cet écueil est d'utiliser "
"``None`` par défaut et de tester explicitement la valeur dans le corps de la "
"fonction. Par exemple ::"

#: reference/compound_stmts.rst:1296
msgid ""
"def whats_on_the_telly(penguin=None):\n"
"    if penguin is None:\n"
"        penguin = []\n"
"    penguin.append(\"property of the zoo\")\n"
"    return penguin"
msgstr ""

#: reference/compound_stmts.rst:1307
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from positional arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"La sémantique de l'appel de fonction est décrite plus en détail dans la "
"section :ref:`calls`. Un appel de fonction assigne toujours des valeurs à "
"tous les paramètres mentionnés dans la liste des paramètres, soit à partir "
"d'arguments positionnels, d'arguments par mots-clés ou de valeurs par "
"défaut. S'il y a un paramètre de la forme ``*identifier``, il est initialisé "
"à un *n*-uplet recevant les paramètres positionnels en surplus, la valeur "
"par défaut étant le *n*-uplet vide. S'il y a un paramètre de la forme "
"``**identifier``, il est initialisé à un nouveau tableau associatif ordonné "
"qui récupère tous les arguments par mot-clé en surplus, la valeur par défaut "
"étant un tableau associatif vide du même type. Les paramètres après ``*`` ou "
"``*identifier`` sont forcément des paramètres par mot-clé et ne peuvent être "
"passés qu'en utilisant des arguments par mot-clé. Au contraire, ceux avant "
"``/`` ne peuvent être passés qu'avec des arguments positionnels."

# pas de majuscule car suit un :
#: reference/compound_stmts.rst:1319
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""
"ajout de la syntaxe avec ``/`` pour indiquer les paramètre exclusivement "
"positionnels (voir la :pep:`570`)."

#: reference/compound_stmts.rst:1328
#, fuzzy
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``. "
"(As a special case, parameters of the form ``*identifier`` may have an "
"annotation \"``: *expression``\".) Functions may have \"return\" annotation "
"of the form \"``-> expression``\" after the parameter list.  These "
"annotations can be any valid Python expression.  The presence of annotations "
"does not change the semantics of a function.  The annotation values are "
"available as values of a dictionary keyed by the parameters' names in the :"
"attr:`__annotations__` attribute of the function object.  If the "
"``annotations`` import from :mod:`__future__` is used, annotations are "
"preserved as strings at runtime which enables postponed evaluation.  "
"Otherwise, they are evaluated when the function definition is executed.  In "
"this case annotations may be evaluated in a different order than they appear "
"in the source code."
msgstr ""
"Les paramètres peuvent avoir une :term:`annotation <function annotation>` "
"sous la forme \"``: expression``\" après le nom du paramètre. Tout paramètre "
"peut avoir une annotation, même ceux de la forme ``*identifier`` ou "
"``**identifier``. Les fonctions peuvent avoir une annotation pour la valeur "
"de retour, sous la forme \"``-> expression``\" après la liste des "
"paramètres. Ces annotations peuvent prendre la forme de toute expression "
"Python valide. Leur présence ne change pas la sémantique de la fonction. Les "
"valeurs des annotations sont accessibles comme valeurs d'un dictionnaire "
"dont les clés sont les noms des paramètres et défini comme attribut :attr:"
"`__annotations__` de l'objet fonction. Si ``annotations`` est importé de :"
"mod:`__future__`, les annotations sont conservées sous la forme de chaînes "
"de caractères, permettant leur évaluation différée. Autrement, elles sont "
"interprétées en même temps que la déclaration des fonctions. Dans le premier "
"cas, les annotations peuvent être interprétées dans un ordre différent de "
"l'ordre dans lequel elles apparaissent dans le fichier."

#: reference/compound_stmts.rst:1342
msgid ""
"Parameters of the form \"``*identifier``\" may have an annotation \"``: "
"*expression``\". See :pep:`646`."
msgstr ""

#: reference/compound_stmts.rst:1348
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"Il est aussi possible de créer des fonctions anonymes (fonctions non liées à "
"un nom), pour une utilisation immédiate dans des expressions. Utilisez alors "
"des expressions lambda, décrites dans la section :ref:`lambda`. Notez qu'une "
"expression lambda est simplement un raccourci pour définir une fonction "
"simple ; une fonction définie par une instruction \":keyword:`def`\" peut "
"être passée (en argument) ou assignée à un autre nom, tout comme une "
"fonction définie par une expression lambda. La forme \":keyword:`!def`\" est "
"en fait plus puissante puisqu'elle permet l'exécution de plusieurs "
"instructions et les annotations."

#: reference/compound_stmts.rst:1356
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**Note pour les programmeurs :** les fonctions sont des objets de première "
"classe. Une instruction \"``def``\" exécutée à l'intérieur d'une définition "
"de fonction définit une fonction locale qui peut être renvoyée ou passée en "
"tant qu'argument. Les variables libres utilisées dans la fonction imbriquée "
"ont accès aux variables locales de la fonction contenant le \"``def``\".  "
"Voir la section :ref:`naming` pour plus de détails."

#: reference/compound_stmts.rst:1364
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` — Annotations de fonctions"

#: reference/compound_stmts.rst:1365
msgid "The original specification for function annotations."
msgstr "La spécification originale pour les annotations de fonctions."

#: reference/compound_stmts.rst:1367
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` — Indications de types"

#: reference/compound_stmts.rst:1368
msgid "Definition of a standard meaning for annotations: type hints."
msgstr ""
"Définition de la signification standard pour les annotations : indications "
"de types."

#: reference/compound_stmts.rst:1370
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` — Syntaxe pour les annotations de variables"

#: reference/compound_stmts.rst:1371
#, fuzzy
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables."
msgstr ""
"Capacité d'indiquer des types pour les déclarations de variables, y compris "
"les variables de classes et les variables d'instances"

#: reference/compound_stmts.rst:1374
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` — Évaluation différée des annotations"

#: reference/compound_stmts.rst:1375
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"Gestion des références postérieures à l'intérieur des annotations en "
"préservant les annotations sous forme de chaînes à l'exécution au lieu d'une "
"évaluation directe."

#: reference/compound_stmts.rst:1378
#, fuzzy
msgid ":pep:`318` - Decorators for Functions and Methods"
msgstr ":pep:`3107` — Annotations de fonctions"

#: reference/compound_stmts.rst:1379
#, fuzzy
msgid ""
"Function and method decorators were introduced. Class decorators were "
"introduced in :pep:`3129`."
msgstr ""
"La proposition qui a ajouté des décorateurs de classe. Les décorateurs de "
"fonction et de méthode ont été introduits dans :pep:`318`."

#: reference/compound_stmts.rst:1385
msgid "Class definitions"
msgstr "Définition de classes"

#: reference/compound_stmts.rst:1400
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""
"Une définition de classe définit un objet classe (voir la section :ref:"
"`types`) :"

#: reference/compound_stmts.rst:1407
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"Une définition de classe est une instruction qui est exécutée. La liste "
"d'héritage (*inheritance* entre crochets dans la grammaire ci-dessus) donne "
"habituellement une liste de classes mères (voir :ref:`metaclasses` pour des "
"utilisations plus avancées). Donc chaque élément de la liste doit pouvoir "
"être évalué comme un objet classe qui autorise les sous-classes. Les classes "
"sans liste d'héritage héritent, par défaut, de la classe mère :class:"
"`object` ; d'où ::"

#: reference/compound_stmts.rst:1413
msgid ""
"class Foo:\n"
"    pass"
msgstr ""

#: reference/compound_stmts.rst:1416
msgid "is equivalent to ::"
msgstr "est équivalente à ::"

#: reference/compound_stmts.rst:1418
msgid ""
"class Foo(object):\n"
"    pass"
msgstr ""

#: reference/compound_stmts.rst:1421
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"La suite de la classe est ensuite exécutée dans un nouveau cadre d'exécution "
"(voir :ref:`naming`), en utilisant un espace de nommage local nouvellement "
"créé et l'espace de nommage global d'origine (habituellement, la suite "
"contient principalement des définitions de fonctions). Lorsque la suite de "
"la classe termine son exécution, son cadre d'exécution est abandonné mais "
"son espace des noms locaux est sauvegardé [#]_. Un objet classe est alors "
"créé en utilisant la liste d'héritage pour les classes mères et l'espace de "
"nommage sauvegardé comme dictionnaire des attributs. Le nom de classe est "
"lié à l'objet classe dans l'espace de nommage local original."

#: reference/compound_stmts.rst:1430
#, fuzzy
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's :attr:`~type.__dict__`.  Note that this is reliable only "
"right after the class is created and only for classes that were defined "
"using the definition syntax."
msgstr ""
"L'ordre dans lequel les attributs sont définis dans le corps de la classe "
"est préservé dans le ``__dict__`` de la nouvelle classe. Notez que ceci "
"n'est fiable que juste après la création de la classe et seulement pour les "
"classes qui ont été définies en utilisant la syntaxe de définition."

#: reference/compound_stmts.rst:1435
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"La création de classes peut être fortement personnalisée en utilisant les :"
"ref:`métaclasses <metaclasses>`."

#: reference/compound_stmts.rst:1440
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""
"Les classes peuvent aussi être décorées. Comme pour les décorateurs de "
"fonctions ::"

#: reference/compound_stmts.rst:1442
msgid ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"
msgstr ""

#: reference/compound_stmts.rst:1448
msgid ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"
msgstr ""

#: reference/compound_stmts.rst:1451
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"Les règles d'évaluation pour les expressions de décorateurs sont les mêmes "
"que pour les décorateurs de fonctions. Le résultat est alors lié au nom de "
"la classe."

#: reference/compound_stmts.rst:1454
msgid ""
"Classes may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"les classes peuvent être décorées par toute :token:`expression d'affectation "
"<~python-grammar:assignment_expression>` valide. Auparavant, la grammaire "
"était beaucoup plus restrictive ; voir la :pep:`614` pour obtenir les "
"détails."

#: reference/compound_stmts.rst:1459
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets immediately after the class's name. This indicates to static type "
"checkers that the class is generic. At runtime, the type parameters can be "
"retrieved from the class's :attr:`~type.__type_params__` attribute. See :ref:"
"`generic-classes` for more."
msgstr ""

#: reference/compound_stmts.rst:1468
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**Note pour les programmeurs :** les variables définies dans la définition "
"de classe sont des attributs de classe ; elles sont partagées par les "
"instances. Les attributs d'instance peuvent être définis dans une méthode en "
"utilisant ``self.name = value``. Les attributs de classe et d'instance sont "
"accessibles par la notation \"``self.name``\", et un attribut d'instance "
"masque un attribut de classe de même nom lorsqu'on y accède de cette façon. "
"Les attributs de classe peuvent être utilisés comme valeurs par défaut pour "
"les attributs d'instances, mais l'utilisation de valeurs mutables peut "
"conduire à des résultats inattendus. Les :ref:`descripteurs <descriptors>` "
"peuvent être utilisés pour créer des variables d'instances avec des détails "
"d'implémentation différents."

#: reference/compound_stmts.rst:1480
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` — Métaclasses dans Python 3000"

#: reference/compound_stmts.rst:1481
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"La proposition qui a modifié la déclaration de métaclasses à la syntaxe "
"actuelle, et la sémantique pour la façon dont les classes avec métaclasses "
"sont construites."

#: reference/compound_stmts.rst:1485
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` — Décorateurs de classes"

#: reference/compound_stmts.rst:1486
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"La proposition qui a ajouté des décorateurs de classe. Les décorateurs de "
"fonction et de méthode ont été introduits dans :pep:`318`."

#: reference/compound_stmts.rst:1493
msgid "Coroutines"
msgstr "Coroutines"

#: reference/compound_stmts.rst:1501
msgid "Coroutine function definition"
msgstr "Définition de fonctions coroutines"

#: reference/compound_stmts.rst:1511
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`). :keyword:`await` expressions, :keyword:`async for` "
"and :keyword:`async with` can only be used in the body of a coroutine "
"function."
msgstr ""
"L'exécution de coroutines Python peut être suspendue et reprise à plusieurs "
"endroits (voir :term:`coroutine`). Les expressions :keyword:`await`, :"
"keyword:`async for` et :keyword:`async with` ne peuvent être utilisées que "
"dans les corps de coroutines."

#: reference/compound_stmts.rst:1515
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"Les fonctions définies avec la syntaxe ``async def`` sont toujours des "
"fonctions coroutines, même si elles ne contiennent aucun mot-clé ``await`` "
"ou ``async``."

#: reference/compound_stmts.rst:1518
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"C'est une :exc:`SyntaxError` d'utiliser une expression ``yield from`` dans "
"une coroutine."

#: reference/compound_stmts.rst:1521
msgid "An example of a coroutine function::"
msgstr "Un exemple de fonction coroutine ::"

#: reference/compound_stmts.rst:1523
msgid ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await some_coroutine()"
msgstr ""

#: reference/compound_stmts.rst:1527
msgid ""
"``await`` and ``async`` are now keywords; previously they were only treated "
"as such inside the body of a coroutine function."
msgstr ""
"``await`` et ``async`` sont dorénavant des mots-clés ; auparavant, ils "
"n'étaient traités comme tels que dans le corps d'une fonction coroutine."

#: reference/compound_stmts.rst:1535
msgid "The :keyword:`!async for` statement"
msgstr "L'instruction :keyword:`!async for`"

#: reference/compound_stmts.rst:1540
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
"Un :term:`itérable asynchrone <asynchronous iterable>` fournit une méthode "
"``__aiter__`` qui renvoie directement un :term:`itérateur asynchrone "
"<asynchronous iterator>`, celui-ci pouvant appeler du code asynchrone dans "
"sa méthode ``__anext__``."

#: reference/compound_stmts.rst:1544
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr ""
"L'instruction ``async for`` permet d'itérer facilement sur des itérables "
"asynchrones."

#: reference/compound_stmts.rst:1549
msgid ""
"async for TARGET in ITER:\n"
"    SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""

#: reference/compound_stmts.rst:1554
msgid "Is semantically equivalent to::"
msgstr "est sémantiquement équivalent à ::"

#: reference/compound_stmts.rst:1556
msgid ""
"iter = (ITER)\n"
"iter = type(iter).__aiter__(iter)\n"
"running = True\n"
"\n"
"while running:\n"
"    try:\n"
"        TARGET = await type(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""

#: reference/compound_stmts.rst:1570
msgid ""
"See also :meth:`~object.__aiter__` and :meth:`~object.__anext__` for details."
msgstr ""
"Voir aussi :meth:`~object.__aiter__` et :meth:`~object.__anext__` pour plus "
"de détails."

#: reference/compound_stmts.rst:1572
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"C'est une :exc:`SyntaxError` d'utiliser une instruction ``async for`` en "
"dehors d'une fonction coroutine."

#: reference/compound_stmts.rst:1580
msgid "The :keyword:`!async with` statement"
msgstr "L'instruction :keyword:`!async with`"

#: reference/compound_stmts.rst:1585
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
"Un :term:`gestionnaire de contexte asynchrone <asynchronous context "
"manager>` est un :term:`gestionnaire de contexte <context manager>` qui est "
"capable de suspendre l'exécution dans ses méthodes *enter* et *exit*."

#: reference/compound_stmts.rst:1590
msgid ""
"async with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""

#: reference/compound_stmts.rst:1595
msgid ""
"manager = (EXPRESSION)\n"
"aenter = type(manager).__aenter__\n"
"aexit = type(manager).__aexit__\n"
"value = await aenter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        await aexit(manager, None, None, None)"
msgstr ""

#: reference/compound_stmts.rst:1612
msgid ""
"See also :meth:`~object.__aenter__` and :meth:`~object.__aexit__` for "
"details."
msgstr ""
"Voir aussi :meth:`~object.__aenter__` et :meth:`~object.__aexit__` pour plus "
"de détails."

#: reference/compound_stmts.rst:1614
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"C'est une :exc:`SyntaxError` d'utiliser l'instruction ``async with`` en "
"dehors d'une fonction coroutine."

#: reference/compound_stmts.rst:1619
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` — Coroutines avec les syntaxes *async* et *await*"

#: reference/compound_stmts.rst:1620
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"La proposition qui a fait que les coroutines soient un concept propre en "
"Python, et a ajouté la syntaxe de prise en charge de celles-ci."

#: reference/compound_stmts.rst:1626
#, fuzzy
msgid "Type parameter lists"
msgstr "liste de paramètres"

#: reference/compound_stmts.rst:1640
msgid ""
":ref:`Functions <def>` (including :ref:`coroutines <async def>`), :ref:"
"`classes <class>` and :ref:`type aliases <type>` may contain a type "
"parameter list::"
msgstr ""

#: reference/compound_stmts.rst:1644
msgid ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"
msgstr ""

#: reference/compound_stmts.rst:1659
msgid ""
"Semantically, this indicates that the function, class, or type alias is "
"generic over a type variable. This information is primarily used by static "
"type checkers, and at runtime, generic objects behave much like their non-"
"generic counterparts."
msgstr ""

#: reference/compound_stmts.rst:1664
msgid ""
"Type parameters are declared in square brackets (``[]``) immediately after "
"the name of the function, class, or type alias. The type parameters are "
"accessible within the scope of the generic object, but not elsewhere. Thus, "
"after a declaration ``def func[T](): pass``, the name ``T`` is not available "
"in the module scope. Below, the semantics of generic objects are described "
"with more precision. The scope of type parameters is modeled with a special "
"function (technically, an :ref:`annotation scope <annotation-scopes>`) that "
"wraps the creation of the generic object."
msgstr ""

#: reference/compound_stmts.rst:1673
msgid ""
"Generic functions, classes, and type aliases have a :attr:`~definition."
"__type_params__` attribute listing their type parameters."
msgstr ""

#: reference/compound_stmts.rst:1676
msgid "Type parameters come in three kinds:"
msgstr ""

#: reference/compound_stmts.rst:1678
msgid ""
":data:`typing.TypeVar`, introduced by a plain name (e.g., ``T``). "
"Semantically, this represents a single type to a type checker."
msgstr ""

#: reference/compound_stmts.rst:1680
msgid ""
":data:`typing.TypeVarTuple`, introduced by a name prefixed with a single "
"asterisk (e.g., ``*Ts``). Semantically, this stands for a tuple of any "
"number of types."
msgstr ""

#: reference/compound_stmts.rst:1683
msgid ""
":data:`typing.ParamSpec`, introduced by a name prefixed with two asterisks "
"(e.g., ``**P``). Semantically, this stands for the parameters of a callable."
msgstr ""

#: reference/compound_stmts.rst:1686
msgid ""
":data:`typing.TypeVar` declarations can define *bounds* and *constraints* "
"with a colon (``:``) followed by an expression. A single expression after "
"the colon indicates a bound (e.g. ``T: int``). Semantically, this means that "
"the :data:`!typing.TypeVar` can only represent types that are a subtype of "
"this bound. A parenthesized tuple of expressions after the colon indicates a "
"set of constraints (e.g. ``T: (str, bytes)``). Each member of the tuple "
"should be a type (again, this is not enforced at runtime). Constrained type "
"variables can only take on one of the types in the list of constraints."
msgstr ""

#: reference/compound_stmts.rst:1695
msgid ""
"For :data:`!typing.TypeVar`\\ s declared using the type parameter list "
"syntax, the bound and constraints are not evaluated when the generic object "
"is created, but only when the value is explicitly accessed through the "
"attributes ``__bound__`` and ``__constraints__``. To accomplish this, the "
"bounds or constraints are evaluated in a separate :ref:`annotation scope "
"<annotation-scopes>`."
msgstr ""

#: reference/compound_stmts.rst:1701
msgid ""
":data:`typing.TypeVarTuple`\\ s and :data:`typing.ParamSpec`\\ s cannot have "
"bounds or constraints."
msgstr ""

#: reference/compound_stmts.rst:1704
msgid ""
"The following example indicates the full set of allowed type parameter "
"declarations::"
msgstr ""

#: reference/compound_stmts.rst:1706
msgid ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple,\n"
"   **SimpleParamSpec,\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithBound,\n"
"   c: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *d: SimpleTypeVarTuple,\n"
"): ..."
msgstr ""

#: reference/compound_stmts.rst:1722
#, fuzzy
msgid "Generic functions"
msgstr "fonction"

#: reference/compound_stmts.rst:1724
msgid "Generic functions are declared as follows::"
msgstr ""

#: reference/compound_stmts.rst:1726
msgid "def func[T](arg: T): ..."
msgstr ""

#: reference/compound_stmts.rst:1728 reference/compound_stmts.rst:1788
#, fuzzy
msgid "This syntax is equivalent to::"
msgstr "est sémantiquement équivalent à ::"

#: reference/compound_stmts.rst:1730
msgid ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    return func\n"
"func = TYPE_PARAMS_OF_func()"
msgstr ""

#: reference/compound_stmts.rst:1737
msgid ""
"Here ``annotation-def`` indicates an :ref:`annotation scope <annotation-"
"scopes>`, which is not actually bound to any name at runtime. (One other "
"liberty is taken in the translation: the syntax does not go through "
"attribute access on the :mod:`typing` module, but creates an instance of :"
"data:`typing.TypeVar` directly.)"
msgstr ""

#: reference/compound_stmts.rst:1743
msgid ""
"The annotations of generic functions are evaluated within the annotation "
"scope used for declaring the type parameters, but the function's defaults "
"and decorators are not."
msgstr ""

#: reference/compound_stmts.rst:1747
msgid ""
"The following example illustrates the scoping rules for these cases, as well "
"as for additional flavors of type parameters::"
msgstr ""

#: reference/compound_stmts.rst:1750
msgid ""
"@decorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."
msgstr ""

#: reference/compound_stmts.rst:1754
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the :class:"
"`~typing.TypeVar` bound, this is equivalent to::"
msgstr ""

#: reference/compound_stmts.rst:1757
msgid ""
"DEFAULT_OF_arg = some_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        return int\n"
"    # In reality, BOUND_OF_T() is evaluated only on demand.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    return func\n"
"func = decorator(TYPE_PARAMS_OF_func())"
msgstr ""

#: reference/compound_stmts.rst:1776
msgid ""
"The capitalized names like ``DEFAULT_OF_arg`` are not actually bound at "
"runtime."
msgstr ""

#: reference/compound_stmts.rst:1782
msgid "Generic classes"
msgstr ""

#: reference/compound_stmts.rst:1784
msgid "Generic classes are declared as follows::"
msgstr ""

#: reference/compound_stmts.rst:1786
msgid "class Bag[T]: ..."
msgstr ""

#: reference/compound_stmts.rst:1790
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"
msgstr ""

#: reference/compound_stmts.rst:1798
msgid ""
"Here again ``annotation-def`` (not a real keyword) indicates an :ref:"
"`annotation scope <annotation-scopes>`, and the name ``TYPE_PARAMS_OF_Bag`` "
"is not actually bound at runtime."
msgstr ""

#: reference/compound_stmts.rst:1802
msgid ""
"Generic classes implicitly inherit from :data:`typing.Generic`. The base "
"classes and keyword arguments of generic classes are evaluated within the "
"type scope for the type parameters, and decorators are evaluated outside "
"that scope. This is illustrated by this example::"
msgstr ""

#: reference/compound_stmts.rst:1808
msgid ""
"@decorator\n"
"class Bag(Base[T], arg=T): ..."
msgstr ""

#: reference/compound_stmts.rst:1811
#, fuzzy
msgid "This is equivalent to::"
msgstr "est équivalente à ::"

#: reference/compound_stmts.rst:1813
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = decorator(TYPE_PARAMS_OF_Bag())"
msgstr ""

#: reference/compound_stmts.rst:1824
msgid "Generic type aliases"
msgstr ""

#: reference/compound_stmts.rst:1826
#, fuzzy
msgid ""
"The :keyword:`type` statement can also be used to create a generic type "
"alias::"
msgstr ""
"L'instruction :keyword:`if` est utilisée pour exécuter des instructions en "
"fonction d'une condition :"

#: reference/compound_stmts.rst:1828
msgid "type ListOrSet[T] = list[T] | set[T]"
msgstr ""

#: reference/compound_stmts.rst:1830
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the value, this "
"is equivalent to::"
msgstr ""

#: reference/compound_stmts.rst:1833
msgid ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # In reality, the value is lazily evaluated\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), "
"type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"
msgstr ""

#: reference/compound_stmts.rst:1842
msgid ""
"Here, ``annotation-def`` (not a real keyword) indicates an :ref:`annotation "
"scope <annotation-scopes>`. The capitalized names like "
"``TYPE_PARAMS_OF_ListOrSet`` are not actually bound at runtime."
msgstr ""

#: reference/compound_stmts.rst:1847
msgid "Footnotes"
msgstr "Notes"

#: reference/compound_stmts.rst:1848
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"L'exception est propagée à la pile d'appels à moins qu'il n'y ait une "
"clause :keyword:`finally` qui lève une autre exception, ce qui entraîne la "
"perte de l'ancienne exception. Cette nouvelle exception entraîne la perte "
"pure et simple de l'ancienne."

#: reference/compound_stmts.rst:1852
msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr "Dans le filtrage par motif, une séquence est définie comme suit :"

#: reference/compound_stmts.rst:1854
msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr "une classe qui hérite de :class:`collections.abc.Sequence`"

#: reference/compound_stmts.rst:1855
msgid ""
"a Python class that has been registered as :class:`collections.abc.Sequence`"
msgstr ""
"une classe Python qui a été enregistrée en tant que :class:`collections.abc."
"Sequence`"

#: reference/compound_stmts.rst:1856
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` bit set"
msgstr ""
"une classe native dont le bit (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` est à "
"1"

#: reference/compound_stmts.rst:1857 reference/compound_stmts.rst:1876
msgid "a class that inherits from any of the above"
msgstr "une classe qui hérite d'une classe citée ci-dessus"

#: reference/compound_stmts.rst:1859
msgid "The following standard library classes are sequences:"
msgstr "Les classes suivantes de la bibliothèque standard sont des séquences :"

#: reference/compound_stmts.rst:1861
msgid ":class:`array.array`"
msgstr ":class:`array.array`"

#: reference/compound_stmts.rst:1862
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: reference/compound_stmts.rst:1864
msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

#: reference/compound_stmts.rst:1865
msgid ":class:`range`"
msgstr ":class:`range`"

#: reference/compound_stmts.rst:1868
msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match "
"sequence patterns."
msgstr ""
"Les champs de recherche du type ``str``, ``bytes`` et ``bytearray`` ne "
"correspondent pas avec des filtres de séquence."

#: reference/compound_stmts.rst:1871
msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr ""
"Dans le filtrage par motif, un tableau associatif est défini comme suit :"

#: reference/compound_stmts.rst:1873
msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr "une classe qui hérite de :class:`collections.abc.Mapping`"

#: reference/compound_stmts.rst:1874
msgid ""
"a Python class that has been registered as :class:`collections.abc.Mapping`"
msgstr ""
"une classe Python qui a été enregistrée en tant que :class:`collections.abc."
"Mapping`"

#: reference/compound_stmts.rst:1875
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_MAPPING` bit set"
msgstr ""
"une classe native dont le bit (CPython) :c:macro:`Py_TPFLAGS_MAPPING` est à 1"

#: reference/compound_stmts.rst:1878
msgid ""
"The standard library classes :class:`dict` and :class:`types."
"MappingProxyType` are mappings."
msgstr ""
"Les classes  :class:`dict` et :class:`types.MappingProxyType` de la "
"bibliothèque standard sont des tableaux associatifs."

#: reference/compound_stmts.rst:1881
#, fuzzy
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's :attr:`~function.__doc__` attribute and "
"therefore the function's :term:`docstring`."
msgstr ""
"Une chaîne littérale apparaissant comme première instruction dans le corps "
"de la fonction est transformée en attribut ``__doc__`` de la fonction et "
"donc en :term:`docstring` de la fonction."

#: reference/compound_stmts.rst:1885
#, fuzzy
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's :attr:`~type.__doc__` item and therefore "
"the class's :term:`docstring`."
msgstr ""
"Une chaîne littérale apparaissant comme première instruction dans le corps "
"de la classe est transformée en élément ``__doc__`` de l'espace de nommage "
"et donc en :term:`docstring` de la classe."

#: reference/compound_stmts.rst:7
msgid "compound"
msgstr "composé"

#: reference/compound_stmts.rst:86 reference/compound_stmts.rst:111
#: reference/compound_stmts.rst:129 reference/compound_stmts.rst:144
#: reference/compound_stmts.rst:169 reference/compound_stmts.rst:207
#: reference/compound_stmts.rst:390 reference/compound_stmts.rst:437
#: reference/compound_stmts.rst:471 reference/compound_stmts.rst:588
#: reference/compound_stmts.rst:1195 reference/compound_stmts.rst:1387
#: reference/compound_stmts.rst:1497 reference/compound_stmts.rst:1531
#: reference/compound_stmts.rst:1576
msgid "statement"
msgstr "instruction"

#: reference/compound_stmts.rst:21
msgid "clause"
msgstr "clause"

#: reference/compound_stmts.rst:21
msgid "suite"
msgstr "suite"

#: reference/compound_stmts.rst:21
msgid "; (semicolon)"
msgstr "; (point-virgule)"

#: reference/compound_stmts.rst:64
msgid "NEWLINE token"
msgstr "lexème NEWLINE"

#: reference/compound_stmts.rst:64
msgid "DEDENT token"
msgstr "lexème DEDENT"

#: reference/compound_stmts.rst:64
msgid "dangling"
msgstr "fantôme"

#: reference/compound_stmts.rst:64 reference/compound_stmts.rst:86
#: reference/compound_stmts.rst:111 reference/compound_stmts.rst:144
#: reference/compound_stmts.rst:207 reference/compound_stmts.rst:390
msgid "else"
msgstr "else"

#: reference/compound_stmts.rst:86 reference/compound_stmts.rst:588
msgid "if"
msgstr "if"

#: reference/compound_stmts.rst:86 reference/compound_stmts.rst:111
#: reference/compound_stmts.rst:144 reference/compound_stmts.rst:207
#: reference/compound_stmts.rst:327 reference/compound_stmts.rst:390
#: reference/compound_stmts.rst:408 reference/compound_stmts.rst:471
#: reference/compound_stmts.rst:588 reference/compound_stmts.rst:1507
msgid "keyword"
msgstr "mot-clé"

#: reference/compound_stmts.rst:86
msgid "elif"
msgstr "elif"

#: reference/compound_stmts.rst:86 reference/compound_stmts.rst:111
#: reference/compound_stmts.rst:144 reference/compound_stmts.rst:207
#: reference/compound_stmts.rst:471 reference/compound_stmts.rst:588
#: reference/compound_stmts.rst:1195 reference/compound_stmts.rst:1323
#: reference/compound_stmts.rst:1387
msgid ": (colon)"
msgstr ": (deux-points)"

#: reference/compound_stmts.rst:86 reference/compound_stmts.rst:111
#: reference/compound_stmts.rst:144 reference/compound_stmts.rst:207
#: reference/compound_stmts.rst:471 reference/compound_stmts.rst:588
#: reference/compound_stmts.rst:1195 reference/compound_stmts.rst:1387
msgid "compound statement"
msgstr "instruction composée"

#: reference/compound_stmts.rst:111
msgid "while"
msgstr "while"

#: reference/compound_stmts.rst:111 reference/compound_stmts.rst:144
msgid "loop"
msgstr "boucle"

#: reference/compound_stmts.rst:129 reference/compound_stmts.rst:169
#: reference/compound_stmts.rst:390 reference/compound_stmts.rst:437
msgid "break"
msgstr "break"

#: reference/compound_stmts.rst:129 reference/compound_stmts.rst:169
#: reference/compound_stmts.rst:390 reference/compound_stmts.rst:437
msgid "continue"
msgstr "continue"

#: reference/compound_stmts.rst:144
msgid "for"
msgstr "for"

#: reference/compound_stmts.rst:144
msgid "in"
msgstr "in"

#: reference/compound_stmts.rst:144
msgid "target"
msgstr "cible"

#: reference/compound_stmts.rst:144
msgid "list"
msgstr "liste"

#: reference/compound_stmts.rst:144 reference/compound_stmts.rst:298
#: reference/compound_stmts.rst:1195 reference/compound_stmts.rst:1387
msgid "object"
msgstr "objet"

#: reference/compound_stmts.rst:144
msgid "sequence"
msgstr "séquence"

#: reference/compound_stmts.rst:190
msgid "built-in function"
msgstr "fonction native"

#: reference/compound_stmts.rst:190
msgid "range"
msgstr "range"

#: reference/compound_stmts.rst:207
msgid "try"
msgstr "try"

#: reference/compound_stmts.rst:207
msgid "except"
msgstr "except"

#: reference/compound_stmts.rst:207 reference/compound_stmts.rst:408
msgid "finally"
msgstr "finally"

#: reference/compound_stmts.rst:207 reference/compound_stmts.rst:265
#: reference/compound_stmts.rst:471 reference/compound_stmts.rst:588
msgid "as"
msgstr "as"

#: reference/compound_stmts.rst:265
msgid "except clause"
msgstr "clause except"

#: reference/compound_stmts.rst:298
msgid "module"
msgstr "module"

#: reference/compound_stmts.rst:298
msgid "sys"
msgstr "sys"

#: reference/compound_stmts.rst:298
msgid "traceback"
msgstr "trace d'appels"

#: reference/compound_stmts.rst:327
msgid "except_star"
msgstr "except_star"

#: reference/compound_stmts.rst:390 reference/compound_stmts.rst:437
msgid "return"
msgstr "return"

#: reference/compound_stmts.rst:471
msgid "with"
msgstr "with"

#: reference/compound_stmts.rst:471
msgid "with statement"
msgstr "instruction *with*"

#: reference/compound_stmts.rst:471 reference/compound_stmts.rst:1195
#: reference/compound_stmts.rst:1387
msgid ", (comma)"
msgstr ", (virgule)"

#: reference/compound_stmts.rst:588
msgid "match"
msgstr "match"

#: reference/compound_stmts.rst:588
msgid "case"
msgstr "case"

#: reference/compound_stmts.rst:588
msgid "pattern matching"
msgstr "filtrage par motif"

#: reference/compound_stmts.rst:588
msgid "match statement"
msgstr "instruction *match*"

#: reference/compound_stmts.rst:692
msgid "guard"
msgstr "garde"

#: reference/compound_stmts.rst:731
msgid "irrefutable case block"
msgstr "bloc attrape-tout"

#: reference/compound_stmts.rst:731
msgid "case block"
msgstr "bloc *case*"

#: reference/compound_stmts.rst:755
msgid "! patterns"
msgstr "! motifs"

#: reference/compound_stmts.rst:755
msgid "AS pattern, OR pattern, capture pattern, wildcard pattern"
msgstr "motif AS, motif OR, motif de capture, motif attrape-tout"

#: reference/compound_stmts.rst:1186 reference/compound_stmts.rst:1273
msgid "parameter"
msgstr "paramètre"

#: reference/compound_stmts.rst:1186 reference/compound_stmts.rst:1195
#: reference/compound_stmts.rst:1237 reference/compound_stmts.rst:1273
#: reference/compound_stmts.rst:1302
msgid "function definition"
msgstr "définition de fonction"

#: reference/compound_stmts.rst:1195
msgid "def"
msgstr "def"

#: reference/compound_stmts.rst:1195 reference/compound_stmts.rst:1323
msgid "function"
msgstr "fonction"

#: reference/compound_stmts.rst:1195 reference/compound_stmts.rst:1387
msgid "definition"
msgstr "définition"

#: reference/compound_stmts.rst:1195 reference/compound_stmts.rst:1387
msgid "name"
msgstr "nom"

#: reference/compound_stmts.rst:1195 reference/compound_stmts.rst:1387
msgid "binding"
msgstr "liaison"

#: reference/compound_stmts.rst:1195
msgid "user-defined function"
msgstr "fonction définie par l'utilisateur"

#: reference/compound_stmts.rst:1195 reference/compound_stmts.rst:1387
msgid "() (parentheses)"
msgstr "() (parenthèses)"

#: reference/compound_stmts.rst:1195
msgid "parameter list"
msgstr "liste de paramètres"

#: reference/compound_stmts.rst:1237 reference/compound_stmts.rst:1437
msgid "@ (at)"
msgstr "@ (arobase)"

#: reference/compound_stmts.rst:1273
msgid "default"
msgstr "par défaut"

#: reference/compound_stmts.rst:1273
msgid "value"
msgstr "valeur"

#: reference/compound_stmts.rst:1273
msgid "argument"
msgstr "argument"

#: reference/compound_stmts.rst:1273
msgid "= (equals)"
msgstr "= (égal)"

#: reference/compound_stmts.rst:1302
msgid "/ (slash)"
msgstr "/ (barre oblique)"

#: reference/compound_stmts.rst:1302
msgid "* (asterisk)"
msgstr "* (astérisque)"

#: reference/compound_stmts.rst:1302
msgid "**"
msgstr "**"

#: reference/compound_stmts.rst:1323
msgid "annotations"
msgstr "annotations"

#: reference/compound_stmts.rst:1323
msgid "->"
msgstr "->"

#: reference/compound_stmts.rst:1323
msgid "function annotations"
msgstr "annotations de fonction"

#: reference/compound_stmts.rst:1346
msgid "lambda"
msgstr "lambda"

#: reference/compound_stmts.rst:1346
msgid "expression"
msgstr "expression"

#: reference/compound_stmts.rst:1387
msgid "class"
msgstr "classe"

#: reference/compound_stmts.rst:1387
msgid "execution"
msgstr "exécution"

#: reference/compound_stmts.rst:1387
msgid "frame"
msgstr "cadre"

#: reference/compound_stmts.rst:1387
msgid "inheritance"
msgstr "héritage"

#: reference/compound_stmts.rst:1387
msgid "docstring"
msgstr "chaîne de documentation"

#: reference/compound_stmts.rst:1387 reference/compound_stmts.rst:1437
msgid "class definition"
msgstr "définition de classe"

#: reference/compound_stmts.rst:1387
msgid "expression list"
msgstr "liste d'expressions"

#: reference/compound_stmts.rst:1497
msgid "async def"
msgstr "async def"

#: reference/compound_stmts.rst:1507
msgid "async"
msgstr "async"

#: reference/compound_stmts.rst:1507
msgid "await"
msgstr "await"

#: reference/compound_stmts.rst:1531
msgid "async for"
msgstr "async for"

#: reference/compound_stmts.rst:1576
msgid "async with"
msgstr "async with"

#: reference/compound_stmts.rst:1630
#, fuzzy
msgid "type parameters"
msgstr "paramètre"

#~ msgid ""
#~ "From version 3.11.4, when the entire :exc:`ExceptionGroup` is handled and "
#~ "only one exception is raised from an :keyword:`!except*` clause, this "
#~ "exception is no longer wrapped to form a new :exc:`ExceptionGroup`."
#~ msgstr ""
#~ "À partir de la version 3.11.4, lorsque l'intégralité de :exc:"
#~ "`ExceptionGroup` est gérée et qu'une seule exception est levée à partir "
#~ "d'une clause :keyword:`!except*`, cette exception n'est plus encapsulée "
#~ "pour former un nouveau :exc:`ExceptionGroup`."

#, fuzzy
#~ msgid ""
#~ "Before an :keyword:`!except` clause's suite is executed, details about "
#~ "the exception are stored in the :mod:`sys` module and can be accessed "
#~ "via :func:`sys.exc_info`. :func:`sys.exc_info` returns a 3-tuple "
#~ "consisting of the exception class, the exception instance and a traceback "
#~ "object (see section :ref:`types`) identifying the point in the program "
#~ "where the exception occurred.  The details about the exception accessed "
#~ "via :func:`sys.exc_info` are restored to their previous values when "
#~ "leaving an exception handler::"
#~ msgstr ""
#~ "Avant l'exécution de la suite d'une clause ``except``, les détails de "
#~ "l'exception sont stockés dans le module :mod:`sys` et sont accessibles "
#~ "*via* :func:`sys.exc_info`. :func:`sys.exc_info` renvoie un triplet "
#~ "composé de la classe de l'exception, de l'instance de l'exception et d'un "
#~ "objet trace (voir la section :ref:`types`) qui identifie l'endroit du "
#~ "programme où l'exception est survenue. Les détails de l’exception "
#~ "accessibles par :func:`sys.exc_info` sont remis à leurs valeurs d’origine "
#~ "en sortant du gestionnaire d’exception ::"

#~ msgid ""
#~ "There is a subtlety when the sequence is being modified by the loop (this "
#~ "can only occur for mutable sequences, e.g. lists).  An internal counter "
#~ "is used to keep track of which item is used next, and this is incremented "
#~ "on each iteration.  When this counter has reached the length of the "
#~ "sequence the loop terminates.  This means that if the suite deletes the "
#~ "current (or a previous) item from the sequence, the next item will be "
#~ "skipped (since it gets the index of the current item which has already "
#~ "been treated).  Likewise, if the suite inserts an item in the sequence "
#~ "before the current item, the current item will be treated again the next "
#~ "time through the loop. This can lead to nasty bugs that can be avoided by "
#~ "making a temporary copy using a slice of the whole sequence, e.g., ::"
#~ msgstr ""
#~ "Il y a une subtilité lorsque la séquence est modifiée par la boucle (cela "
#~ "ne peut se produire que pour les séquences mutables, c'est-à-dire les "
#~ "listes). Un compteur interne est utilisé pour savoir quel est l'élément "
#~ "suivant, et ce compteur est incrémenté à chaque itération. Lorsqu'il a "
#~ "atteint la longueur de la séquence, la boucle se termine. Cela signifie "
#~ "que si la suite supprime l'élément courant (ou un élément précédent) de "
#~ "la séquence, l'élément suivant est sauté (puisqu'il reçoit l'indice de "
#~ "l'élément courant qui a déjà été traité). De même, si la suite insère un "
#~ "élément avant l'élément courant, l'élément courant est traité une "
#~ "deuxième fois à la prochaine itération. Ceci peut conduire à de méchants "
#~ "bugs, que vous pouvez éviter en effectuant une copie temporaire d'une "
#~ "tranche ou de la séquence complète, par exemple ::"
