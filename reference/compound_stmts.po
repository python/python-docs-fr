# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "Instructions composées"

#: ../Doc/reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Les instructions composées contiennent d'autres (groupes d’) instructions ; "
"elles affectent ou contrôlent l'exécution de ces autres instructions d'une "
"manière ou d'une autre. En général, une instruction composée couvre "
"plusieurs lignes bien que, dans sa forme la plus simple, une instruction "
"composée peut tenir sur une seule ligne."

#: ../Doc/reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements.  Function and class "
"definitions are also syntactically compound statements."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:23
msgid ""
"Compound statements consist of one or more 'clauses.'  A clause consists of "
"a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong:   ::"
msgstr ""

#: ../Doc/reference/compound_stmts.rst:36
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :keyword:`print` "
"statements are executed::"
msgstr ""

#: ../Doc/reference/compound_stmts.rst:42
msgid "Summarizing:"
msgstr "En résumé :"

#: ../Doc/reference/compound_stmts.rst:62
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``. Also note that optional continuation clauses always begin with a "
"keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:68
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"L'agencement des règles de grammaire dans les sections qui suivent place "
"chaque clause sur une ligne séparée pour plus de clarté."

#: ../Doc/reference/compound_stmts.rst:77
msgid "The :keyword:`if` statement"
msgstr "L'instruction :keyword:`if`"

#: ../Doc/reference/compound_stmts.rst:84
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ""
"L'instruction :keyword:`if` est utilisée pour exécuter des instructions en "
"fonction d'une condition :"

#: ../Doc/reference/compound_stmts.rst:91
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Elle sélectionne exactement une des suites en évaluant les expressions une "
"par une jusqu'à ce qu'une soit vraie (voir la section :ref:`booleans` pour "
"la définition de vrai et faux) ; ensuite cette suite est exécutée (et aucune "
"autre partie de l'instruction :keyword:`if` n'est exécutée ou évaluée). Si "
"toutes les expressions sont fausses, la suite de la clause :keyword:`else`, "
"si elle existe, est exécutée."

#: ../Doc/reference/compound_stmts.rst:101
msgid "The :keyword:`while` statement"
msgstr "L'instruction :keyword:`while`"

#: ../Doc/reference/compound_stmts.rst:108
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"L'instruction :keyword:`while` est utilisée pour exécuter des instructions "
"de manière répétée tant qu'une expression est vraie :"

#: ../Doc/reference/compound_stmts.rst:115
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"Python évalue l'expression de manière répétée et, tant qu'elle est vraie, "
"exécute la première suite ; si l'expression est fausse (ce qui peut arriver "
"même lors du premier test), la suite de la clause :keyword:`else`, si elle "
"existe, est exécutée et la boucle se termine."

#: ../Doc/reference/compound_stmts.rst:124
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`else` clause's suite.  A :keyword:`continue` "
"statement executed in the first suite skips the rest of the suite and goes "
"back to testing the expression."
msgstr ""
"Une instruction :keyword:`break` exécutée dans la première suite termine la "
"boucle sans exécuter la suite de la clause :keyword:`else`. Une instruction :"
"keyword:`continue` exécutée dans la première suite saute le reste de la "
"suite et retourne au test de l'expression."

#: ../Doc/reference/compound_stmts.rst:133
msgid "The :keyword:`for` statement"
msgstr "L'instruction :keyword:`for`"

#: ../Doc/reference/compound_stmts.rst:143
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"L'instruction :keyword:`for` est utilisée pour itérer sur les éléments d'une "
"séquence (par exemple une chaîne, un tuple ou une liste) ou un autre objet "
"itérable :"

#: ../Doc/reference/compound_stmts.rst:150
msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite "
"is then executed once for each item provided by the iterator, in the order "
"of ascending indices.  Each item in turn is assigned to the target list "
"using the standard rules for assignments, and then the suite is executed.  "
"When the items are exhausted (which is immediately when the sequence is "
"empty), the suite in the :keyword:`else` clause, if present, is executed, "
"and the loop terminates."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:162
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`else` clause's suite.  A :keyword:`continue` "
"statement executed in the first suite skips the rest of the suite and "
"continues with the next item, or with the :keyword:`else` clause if there "
"was no next item."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:168
msgid ""
"The suite may assign to the variable(s) in the target list; this does not "
"affect the next item assigned to it."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:175
msgid ""
"The target list is not deleted when the loop is finished, but if the "
"sequence is empty, it will not have been assigned to at all by the loop.  "
"Hint: the built-in function :func:`range` returns a sequence of integers "
"suitable to emulate the effect of Pascal's ``for i := a to b do``; e.g., "
"``range(3)`` returns the list ``[0, 1, 2]``."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:187
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this "
"can only occur for mutable sequences, i.e. lists). An internal counter is "
"used to keep track of which item is used next, and this is incremented on "
"each iteration.  When this counter has reached the length of the sequence "
"the loop terminates.  This means that if the suite deletes the current (or a "
"previous) item from the sequence, the next item will be skipped (since it "
"gets the index of the current item which has already been treated).  "
"Likewise, if the suite inserts an item in the sequence before the current "
"item, the current item will be treated again the next time through the loop. "
"This can lead to nasty bugs that can be avoided by making a temporary copy "
"using a slice of the whole sequence, e.g., ::"
msgstr ""

#: ../Doc/reference/compound_stmts.rst:208
msgid "The :keyword:`try` statement"
msgstr "L'instruction :keyword:`try`"

#: ../Doc/reference/compound_stmts.rst:215
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"L'instruction :keyword:`try` spécifie les gestionnaires d'exception ou le "
"code de nettoyage pour un groupe d'instructions :"

#: ../Doc/reference/compound_stmts.rst:227
msgid ""
"In previous versions of Python, :keyword:`try`...\\ :keyword:`except`...\\ :"
"keyword:`finally` did not work. :keyword:`try`...\\ :keyword:`except` had to "
"be nested in :keyword:`try`...\\ :keyword:`finally`."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:232
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When "
"no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`try` suite, a search for "
"an exception handler is started.  This search inspects the except clauses in "
"turn until one is found that matches the exception.  An expression-less "
"except clause, if present, must be last; it matches any exception.  For an "
"except clause with an expression, that expression is evaluated, and the "
"clause matches the exception if the resulting object is \"compatible\" with "
"the exception.  An object is compatible with an exception if it is the class "
"or a base class of the exception object, or a tuple containing an item "
"compatible with the exception."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:243
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""
"Si aucune clause ``except`` ne correspond à l'exception, la recherche d'un "
"gestionnaire d'exception se poursuit dans le code englobant et dans la pile "
"d'appels [#]_."

#: ../Doc/reference/compound_stmts.rst:246
msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""
"Si l'évaluation d'une expression dans l'en-tête d'une clause ``except`` lève "
"une exception, la recherche initiale d'un gestionnaire est annulée et une "
"recherche commence pour la nouvelle exception dans le code englobant et dans "
"la pile d'appels (c'est traité comme si l'instruction :keyword:`try` avait "
"levé l'exception)."

#: ../Doc/reference/compound_stmts.rst:251
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified in that except clause, if present, and the except clause's "
"suite is executed.  All except clauses must have an executable block.  When "
"the end of this block is reached, execution continues normally after the "
"entire try statement.  (This means that if two nested handlers exist for the "
"same exception, and the exception occurs in the try clause of the inner "
"handler, the outer handler will not handle the exception.)"
msgstr ""

#: ../Doc/reference/compound_stmts.rst:266
msgid ""
"Before an except clause's suite is executed, details about the exception are "
"assigned to three variables in the :mod:`sys` module: ``sys.exc_type`` "
"receives the object identifying the exception; ``sys.exc_value`` receives "
"the exception's parameter; ``sys.exc_traceback`` receives a traceback object "
"(see section :ref:`types`) identifying the point in the program where the "
"exception occurred. These details are also available through the :func:`sys."
"exc_info` function, which returns a tuple ``(exc_type, exc_value, "
"exc_traceback)``.  Use of the corresponding variables is deprecated in favor "
"of this function, since their use is unsafe in a threaded program.  As of "
"Python 1.5, the variables are restored to their previous values (before the "
"call) when returning from a function that handled an exception."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:284
msgid ""
"The optional :keyword:`else` clause is executed if and when control flows "
"off the end of the :keyword:`try` clause. [#]_ Exceptions in the :keyword:"
"`else` clause are not handled by the preceding :keyword:`except` clauses."
msgstr ""
"La clause optionnelle :keyword:`else` n'est exécutée que si l'exécution "
"atteint la fin de la clause :keyword:`try` [#]_. Les exceptions dans la "
"clause :keyword:`else` ne sont pas gérées par les clauses :keyword:`except` "
"qui la précèdent."

#: ../Doc/reference/compound_stmts.rst:290
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else` clauses.  If an exception occurs in any of the clauses and is "
"not handled, the exception is temporarily saved. The :keyword:`finally` "
"clause is executed.  If there is a saved exception, it is re-raised at the "
"end of the :keyword:`finally` clause. If the :keyword:`finally` clause "
"raises another exception or executes a :keyword:`return` or :keyword:`break` "
"statement, the saved exception is discarded::"
msgstr ""

#: ../Doc/reference/compound_stmts.rst:308
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr ""
"L'information relative à l'exception n'est pas disponible pour le programme "
"pendant l'exécution de la clause :keyword:`finally`."

#: ../Doc/reference/compound_stmts.rst:316
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`try`...\\ :keyword:"
"`finally` statement, the :keyword:`finally` clause is also executed 'on the "
"way out.' A :keyword:`continue` statement is illegal in the :keyword:"
"`finally` clause. (The reason is a problem with the current implementation "
"--- this restriction may be lifted in the future)."
msgstr ""
"Lorsqu'une instruction :keyword:`return`, :keyword:`break` ou :keyword:"
"`continue` est exécutée dans la suite d'une instruction :keyword:`try` d'une "
"construction :keyword:`try`...\\ :keyword:`finally`, la clause :keyword:"
"`finally` est aussi exécutée à la sortie. Une instruction :keyword:"
"`continue` est illégale dans une clause :keyword:`finally` (la raison est "
"que l'implémentation actuelle pose problème --- il est possible que cette "
"restriction soit levée dans le futur)."

#: ../Doc/reference/compound_stmts.rst:323
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`finally` clause always executes, a :"
"keyword:`return` statement executed in the :keyword:`finally` clause will "
"always be the last one executed::"
msgstr ""
"La valeur de retour d'une fonction est déterminée par la dernière "
"instruction :keyword:`return` exécutée.  Puisque la clause :keyword:"
"`finally` s'exécute toujours, une instruction :keyword:`return` exécutée "
"dans le :keyword:`finally` sera toujours la dernière clause exécutée ::"

#: ../Doc/reference/compound_stmts.rst:337
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Vous trouvez des informations supplémentaires relatives aux exceptions dans "
"la section :ref:`exceptions` et, dans la section :ref:`raise`, des "
"informations relatives à l'utilisation de l'instruction :keyword:`raise` "
"pour produire des exceptions."

#: ../Doc/reference/compound_stmts.rst:346
msgid "The :keyword:`with` statement"
msgstr "L'instruction :keyword:`with`"

#: ../Doc/reference/compound_stmts.rst:354
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"L'instruction :keyword:`with` est utilisée pour encapsuler l'exécution d'un "
"bloc avec des méthodes définies par un gestionnaire de contexte (voir la "
"section :ref:`context-managers`). Cela permet d'utiliser de manière simple "
"le patron de conception classique :keyword:`try`....\\ :keyword:`except`..."
"\\ \\ :keyword:`finally`."

#: ../Doc/reference/compound_stmts.rst:363
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"L'exécution de l'instruction :keyword:`with` avec un seul \"élément"
"\" (*item* dans la grammaire) se déroule comme suit :"

#: ../Doc/reference/compound_stmts.rst:365
msgid ""
"The context expression (the expression given in the :token:`with_item`) is "
"evaluated to obtain a context manager."
msgstr ""
"L'expression de contexte (l'expression donnée dans le :token:`with_item`) "
"est évaluée pour obtenir un gestionnaire de contexte."

#: ../Doc/reference/compound_stmts.rst:368
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""
"La méthode :meth:`__exit__` du gestionnaire de contexte est chargée pour une "
"utilisation ultérieure."

#: ../Doc/reference/compound_stmts.rst:370
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "La méthode :meth:`__enter__` du gestionnaire de contexte est invoquée."

#: ../Doc/reference/compound_stmts.rst:372
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""
"Si une cible (*target* dans la grammaire ci-dessus) a été incluse dans "
"l'instruction :keyword:`with`, la valeur de retour de :meth:`__enter__` lui "
"est assignée."

#: ../Doc/reference/compound_stmts.rst:377
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 6 below."
msgstr ""
"L'instruction :keyword:`with` garantit que si la méthode :meth:`__enter__` "
"se termine sans erreur, alors la méthode :meth:`__exit__` est toujours "
"appelée. Ainsi, si une erreur se produit pendant l'assignation à la liste "
"cible, elle est traitée de la même façon qu'une erreur se produisant dans la "
"suite. Voir l'étape 6 ci-dessous."

#: ../Doc/reference/compound_stmts.rst:382
msgid "The suite is executed."
msgstr "La suite est exécutée."

#: ../Doc/reference/compound_stmts.rst:384
msgid ""
"The context manager's :meth:`__exit__` method is invoked. If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:389
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised. If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:394
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""
"Si l'on est sorti de la suite pour une raison autre qu'une exception, la "
"valeur de retour de :meth:`__exit__` est ignorée et l'exécution se poursuit "
"à l'endroit normal pour le type de sortie prise."

#: ../Doc/reference/compound_stmts.rst:398
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"Avec plus d'un élément, les gestionnaires de contexte sont traités comme si "
"plusieurs instructions :keyword:`with` étaient imbriquées ::"

#: ../Doc/reference/compound_stmts.rst:404
msgid "is equivalent to ::"
msgstr "est équivalente à : ::"

#: ../Doc/reference/compound_stmts.rst:412
msgid ""
"In Python 2.5, the :keyword:`with` statement is only allowed when the "
"``with_statement`` feature has been enabled.  It is always enabled in Python "
"2.6."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:416
msgid "Support for multiple context expressions."
msgstr "Prise en charge de multiples expressions de contexte."

#: ../Doc/reference/compound_stmts.rst:422
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - The \"with\" statement"

#: ../Doc/reference/compound_stmts.rst:422
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"La spécification, les motivations et des exemples de l'instruction :keyword:"
"`with` en Python."

#: ../Doc/reference/compound_stmts.rst:433
msgid "Function definitions"
msgstr "Définition de fonctions"

#: ../Doc/reference/compound_stmts.rst:443
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"Une définition de fonction définit un objet fonction allogène (voir la "
"section :ref:`types`) :"

#: ../Doc/reference/compound_stmts.rst:461
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"Une définition de fonction est une instruction qui est exécutée. Son "
"exécution lie le nom de la fonction, dans l'espace de noms local courant, à "
"un objet fonction (un objet qui encapsule le code exécutable de la "
"fonction).  Cet objet fonction contient une référence à l'espace des noms "
"globaux courant comme espace des noms globaux à utiliser lorsque la fonction "
"est appelée."

#: ../Doc/reference/compound_stmts.rst:467
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"La définition de la fonction n'exécute pas le corps de la fonction ; elle "
"n'est exécutée que lorsque la fonction est appelée [#]_."

#: ../Doc/reference/compound_stmts.rst:473
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code::"
msgstr ""

#: ../Doc/reference/compound_stmts.rst:484
msgid "is equivalent to::"
msgstr "est équivalente à ::"

#: ../Doc/reference/compound_stmts.rst:493
msgid ""
"When one or more top-level :term:`parameters <parameter>` have the form "
"*parameter* ``=`` *expression*, the function is said to have \"default "
"parameter values.\"  For a parameter with a default value, the "
"corresponding :term:`argument` may be omitted from a call, in which case the "
"parameter's default value is substituted.  If a parameter has a default "
"value, all following parameters must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:501
msgid ""
"**Default parameter values are evaluated when the function definition is "
"executed.**  This means that the expression is evaluated once, when the "
"function is defined, and that the same \"pre-computed\" value is used for "
"each call.  This is especially important to understand when a default "
"parameter is a mutable object, such as a list or a dictionary: if the "
"function modifies the object (e.g. by appending an item to a list), the "
"default value is in effect modified. This is generally not what was "
"intended.  A way around this  is to use ``None`` as the default, and "
"explicitly test for it in the body of the function, e.g.::"
msgstr ""

#: ../Doc/reference/compound_stmts.rst:520
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from position arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple.  If the form \"``**identifier``\" "
"is present, it is initialized to a new dictionary receiving any excess "
"keyword arguments, defaulting to a new empty dictionary."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:530
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`def`\" form is actually more powerful since it allows the execution "
"of multiple statements."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:538
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"form executed inside a function definition defines a local function that can "
"be returned or passed around.  Free variables used in the nested function "
"can access the local variables of the function containing the def.  See "
"section :ref:`naming` for details."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:548
msgid "Class definitions"
msgstr "Définition de classes"

#: ../Doc/reference/compound_stmts.rst:560
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""
"Une définition de classe définit un objet classe (voir la section :ref:"
"`types`) :"

#: ../Doc/reference/compound_stmts.rst:567
msgid ""
"A class definition is an executable statement.  It first evaluates the "
"inheritance list, if present.  Each item in the inheritance list should "
"evaluate to a class object or class type which allows subclassing.  The "
"class's suite is then executed in a new execution frame (see section :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains only function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:578
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"variables; they are shared by all instances.  To create instance variables, "
"they can be set in a method with ``self.name = value``.  Both class and "
"instance variables are accessible through the notation \"``self.name``\", "
"and an instance variable hides a class variable with the same name when "
"accessed in this way. Class variables can be used as defaults for instance "
"variables, but using mutable values there can lead to unexpected results.  "
"For :term:`new-style class`\\es, descriptors can be used to create instance "
"variables with different implementation details."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:588
msgid ""
"Class definitions, like function definitions, may be wrapped by one or more :"
"term:`decorator` expressions.  The evaluation rules for the decorator "
"expressions are the same as for functions.  The result must be a class "
"object, which is then bound to the class name."
msgstr ""

#: ../Doc/reference/compound_stmts.rst:594
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/reference/compound_stmts.rst:595
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"L'exception est propagée à la pile d'appels à moins qu'il n'y ait une "
"clause :keyword:`finally` qui lève une autre exception, ce qui entraîne la "
"perte de l'ancienne exception. Cette nouvelle exception entraîne la perte "
"pure et simple de l'ancienne."

#: ../Doc/reference/compound_stmts.rst:599
msgid ""
"Currently, control \"flows off the end\" except in the case of an exception "
"or the execution of a :keyword:`return`, :keyword:`continue`, or :keyword:"
"`break` statement."
msgstr ""
"Actuellement, l'exécution \"atteint la fin\" sauf dans le cas d'une "
"exception, de l'exécution de l'instruction :keyword:`return`, :keyword:"
"`continue` ou :keyword:`break`."

#: ../Doc/reference/compound_stmts.rst:603
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"Une chaîne littérale apparaissant comme première instruction dans le corps "
"de la fonction est transformée en attribut ``__doc__`` de la fonction et "
"donc en :term:`docstring` de la fonction."

#: ../Doc/reference/compound_stmts.rst:607
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""
"Une chaîne littérale apparaissant comme première instruction dans le corps "
"de la classe est transformée en élément ``__doc__`` de l'espace de noms et "
"donc en :term:`docstring` de la classe."
