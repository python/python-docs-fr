# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-04 10:00+0100\n"
"PO-Revision-Date: 2019-09-22 20:57+0200\n"
"Last-Translator: Jules Lasne <jules.lasne@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.3\n"

#: ../Doc/reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "Instructions composées"

#: ../Doc/reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Les instructions composées contiennent d'autres (groupes d’) instructions ; "
"elles affectent ou contrôlent l'exécution de ces autres instructions d'une "
"manière ou d'une autre. En général, une instruction composée couvre "
"plusieurs lignes bien que, dans sa forme la plus simple, une instruction "
"composée peut tenir sur une seule ligne."

#: ../Doc/reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
"Les instructions :keyword:`if`, :keyword:`while` et :keyword:`for` "
"implémentent les constructions classiques de contrôle de flux. :keyword:"
"`try` spécifie des gestionnaires d'exception et du code de nettoyage pour un "
"groupe d'instructions, tandis que l'instruction :keyword:`with` permet "
"l'exécution de code d'initialisation et de finalisation autour d'un bloc de "
"code. Les définitions de fonctions et de classes sont également, au sens "
"syntaxique, des instructions composées."

#: ../Doc/reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"Une instruction composée comporte une ou plusieurs « clauses ». Une clause "
"se compose d'un en-tête et d'une « suite ». Les en-têtes des clauses d'une "
"instruction composée particulière sont toutes placées au même niveau "
"d'indentation. Chaque en-tête de clause commence par un mot-clé spécifique "
"et se termine par le caractère deux-points (`:`) ; une suite est un groupe "
"d'instructions contrôlées par une clause ; une suite se compose, après les "
"deux points de l'en-tête, soit d'une ou plusieurs instructions simples "
"séparées par des points-virgules si elles sont sur la même ligne que l'en-"
"tête, soit d'une ou plusieurs instructions en retrait sur les lignes "
"suivantes. Seule cette dernière forme d'une suite peut contenir des "
"instructions composées ; ce qui suit n'est pas licite, principalement parce "
"qu'il ne serait pas clair de savoir à quelle clause :keyword:`if` se "
"rapporterait une clause :keyword:`else` placée en fin de ligne :"

#: ../Doc/reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"Notez également que le point-virgule se lie plus étroitement que le deux-"
"points dans ce contexte, de sorte que dans l'exemple suivant, soit tous les "
"appels :func:`print` sont exécutés, soit aucun ne l'est :"

#: ../Doc/reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "En résumé :"

#: ../Doc/reference/compound_stmts.rst:67
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"Notez que ces instructions se terminent toujours par un lexème ``NEWLINE`` "
"suivi éventuellement d'un ``DEDENT``. Notez également que les clauses "
"facultatives qui suivent commencent toujours par un mot-clé qui ne peut pas "
"commencer une instruction. Ainsi, il n'y a pas d'ambiguïté (le problème du :"
"keyword:`else` dont on ne sait pas à quel ``if`` il est relié est résolu en "
"Python en exigeant que des instructions :keyword:`if` imbriquées soient "
"indentées les unes par rapport aux autres)."

#: ../Doc/reference/compound_stmts.rst:73
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"L'agencement des règles de grammaire dans les sections qui suivent place "
"chaque clause sur une ligne séparée pour plus de clarté."

#: ../Doc/reference/compound_stmts.rst:82
msgid "The :keyword:`!if` statement"
msgstr "L'instruction :keyword:`!if`"

#: ../Doc/reference/compound_stmts.rst:90
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ""
"L'instruction :keyword:`if` est utilisée pour exécuter des instructions en "
"fonction d'une condition :"

#: ../Doc/reference/compound_stmts.rst:97
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Elle sélectionne exactement une des suites en évaluant les expressions une "
"par une jusqu'à ce qu'une soit vraie (voir la section :ref:`booleans` pour "
"la définition de vrai et faux) ; ensuite cette suite est exécutée (et aucune "
"autre partie de l'instruction :keyword:`if` n'est exécutée ou évaluée). Si "
"toutes les expressions sont fausses, la suite de la clause :keyword:`else`, "
"si elle existe, est exécutée."

#: ../Doc/reference/compound_stmts.rst:107
msgid "The :keyword:`!while` statement"
msgstr "L'instruction :keyword:`!while`"

#: ../Doc/reference/compound_stmts.rst:115
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"L'instruction :keyword:`while` est utilisée pour exécuter des instructions "
"de manière répétée tant qu'une expression est vraie :"

#: ../Doc/reference/compound_stmts.rst:122
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"Python évalue l'expression de manière répétée et, tant qu'elle est vraie, "
"exécute la première suite ; si l'expression est fausse (ce qui peut arriver "
"même lors du premier test), la suite de la clause :keyword:`!else`, si elle "
"existe, est exécutée et la boucle se termine."

#: ../Doc/reference/compound_stmts.rst:131
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"Une instruction :keyword:`break` exécutée dans la première suite termine la "
"boucle sans exécuter la suite de la clause :keyword:`!else`. Une "
"instruction :keyword:`continue` exécutée dans la première suite saute le "
"reste de la suite et retourne au test de l'expression."

#: ../Doc/reference/compound_stmts.rst:140
msgid "The :keyword:`!for` statement"
msgstr "L'instruction :keyword:`!for`"

#: ../Doc/reference/compound_stmts.rst:151
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"L'instruction :keyword:`for` est utilisée pour itérer sur les éléments d'une "
"séquence (par exemple une chaîne, un tuple ou une liste) ou un autre objet "
"itérable :"

#: ../Doc/reference/compound_stmts.rst:158
msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite "
"is then executed once for each item provided by the iterator, in the order "
"returned by the iterator.  Each item in turn is assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and then "
"the suite is executed.  When the items are exhausted (which is immediately "
"when the sequence is empty or an iterator raises a :exc:`StopIteration` "
"exception), the suite in the :keyword:`!else` clause, if present, is "
"executed, and the loop terminates."
msgstr ""
"La liste des expressions (*expression_list* dans la grammaire ci-dessus) est "
"évaluée une seule fois ; elle doit produire un objet itérable. Un itérateur "
"est créé pour le résultat de cette liste d'expression. La suite est ensuite "
"exécutée une fois pour chaque élément fourni par l'itérateur, dans l'ordre "
"renvoyé par l'itérateur. Chaque élément est assigné, à tour de rôle, à la "
"liste cible (*target_list* dans la grammaire ci-dessus) en utilisant les "
"règles des assignations (voir :ref:`assignment`), et ensuite la suite est "
"exécutée. Lorsque les éléments sont épuisés (ce qui est immédiat lorsque la "
"séquence est vide ou si un itérateur lève une exception :exc:"
"`StopIteration`), la suite de la clause :keyword:`!else`, si elle existe, "
"est exécutée et la boucle se termine."

#: ../Doc/reference/compound_stmts.rst:171
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"Une instruction :keyword:`break` exécutée dans la première suite termine la "
"boucle sans exécuter la suite de la clause :keyword:`!else`. Une "
"instruction :keyword:`continue` exécutée dans la première suite saute le "
"reste de la suite et continue avec l'élément suivant, ou avec la clause :"
"keyword:`!else` s'il n'y a pas d'élément suivant."

#: ../Doc/reference/compound_stmts.rst:177
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"La boucle ``for`` effectue des affectations aux variables de la liste cible, "
"ce qui écrase toutes les affectations antérieures de ces variables, y "
"compris celles effectuées dans la suite de la boucle ``for`` ::"

#: ../Doc/reference/compound_stmts.rst:191
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in function :func:`range` returns an iterator of "
"integers suitable to emulate the effect of Pascal's ``for i := a to b do``; "
"e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""
"Les noms dans la liste cible ne sont pas supprimés lorsque la boucle est "
"terminée mais, si la séquence est vide, ils n'auront pas du tout été "
"assignés par la boucle. Petite astuce : la fonction native :func:`range` "
"renvoie un itérateur sur des entiers approprié pour émuler la boucle "
"classique en Pascal sur des entiers ``for i := a to b do`` ; par exemple, "
"``list(range(3))`` renvoie la liste ``[0, 1, 2]``."

#: ../Doc/reference/compound_stmts.rst:203
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this "
"can only occur for mutable sequences, e.g. lists).  An internal counter is "
"used to keep track of which item is used next, and this is incremented on "
"each iteration.  When this counter has reached the length of the sequence "
"the loop terminates.  This means that if the suite deletes the current (or a "
"previous) item from the sequence, the next item will be skipped (since it "
"gets the index of the current item which has already been treated).  "
"Likewise, if the suite inserts an item in the sequence before the current "
"item, the current item will be treated again the next time through the loop. "
"This can lead to nasty bugs that can be avoided by making a temporary copy "
"using a slice of the whole sequence, e.g., ::"
msgstr ""
"Il y a une subtilité lorsque la séquence est modifiée par la boucle (cela ne "
"peut se produire que pour les séquences mutables, c'est-à-dire les listes). "
"Un compteur interne est utilisé pour savoir quel est l'élément suivant, et "
"ce compteur est incrémenté à chaque itération. Lorsqu'il a atteint la "
"longueur de la séquence, la boucle se termine. Cela signifie que si la suite "
"supprime l'élément courant (ou un élément précédent) de la séquence, "
"l'élément suivant est sauté (puisqu'il reçoit l'indice de l'élément courant "
"qui a déjà été traité). De même, si la suite insère un élément avant "
"l'élément courant, l'élément courant est traité une deuxième fois à la "
"prochaine itération. Ceci peut conduire à de méchants bugs, que vous pouvez "
"éviter en effectuant une copie temporaire d'une tranche ou de la séquence "
"complète, par exemple ::"

#: ../Doc/reference/compound_stmts.rst:224
msgid "The :keyword:`!try` statement"
msgstr "L'instruction :keyword:`!try`"

#: ../Doc/reference/compound_stmts.rst:234
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"L'instruction :keyword:`try` spécifie les gestionnaires d'exception ou le "
"code de nettoyage pour un groupe d'instructions :"

#: ../Doc/reference/compound_stmts.rst:247
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When "
"no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started.  This search inspects the except "
"clauses in turn until one is found that matches the exception.  An "
"expression-less except clause, if present, must be last; it matches any "
"exception.  For an except clause with an expression, that expression is "
"evaluated, and the clause matches the exception if the resulting object is "
"\"compatible\" with the exception.  An object is compatible with an "
"exception if it is the class or a base class of the exception object or a "
"tuple containing an item compatible with the exception."
msgstr ""
"La ou les clauses :keyword:`except` spécifient un ou plusieurs gestionnaires "
"d'exceptions. Si aucune exception ne se produit dans la clause :keyword:"
"`try`, aucun gestionnaire d'exception n'est exécuté. Lorsqu'une exception se "
"produit dans la suite de :keyword:`!try`, Python recherche un gestionnaire "
"d'exception. Cette recherche inspecte les clauses ``except``, l'une après "
"l'autre, jusqu'à trouver une correspondance. Une clause ``except`` vide "
"(c'est-à-dire sans expression), si elle est présente, doit être la "
"dernière ; elle correspond à toute exception. Pour une clause ``except`` "
"avec une expression, cette expression est évaluée et la clause correspond si "
"l'objet résultant est « compatible » avec l'exception. Un objet est réputé "
"compatible avec une exception s'il est la classe ou une classe de base de "
"l'objet exception ou si c'est un tuple contenant un élément qui est "
"compatible avec l'exception."

#: ../Doc/reference/compound_stmts.rst:258
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""
"Si aucune clause ``except`` ne correspond à l'exception, la recherche d'un "
"gestionnaire d'exception se poursuit dans le code englobant et dans la pile "
"d'appels. [#]_"

#: ../Doc/reference/compound_stmts.rst:261
msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""
"Si l'évaluation d'une expression dans l'en-tête d'une clause ``except`` lève "
"une exception, la recherche initiale d'un gestionnaire est annulée et une "
"recherche commence pour la nouvelle exception dans le code englobant et dans "
"la pile d'appels (c'est traité comme si l'instruction :keyword:`try` avait "
"levé l'exception)."

#: ../Doc/reference/compound_stmts.rst:268
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`!as` keyword in that except clause, if "
"present, and the except clause's suite is executed.  All except clauses must "
"have an executable block.  When the end of this block is reached, execution "
"continues normally after the entire try statement.  (This means that if two "
"nested handlers exist for the same exception, and the exception occurs in "
"the try clause of the inner handler, the outer handler will not handle the "
"exception.)"
msgstr ""
"Lorsqu'une clause d'exception correspond, l'exception est assignée à la "
"cible spécifiée après le mot-clé :keyword:`!as` dans cette clause "
"``except``, si cette cible existe, et la suite de clause ``except`` est "
"exécutée. Toutes les clauses ``except`` doivent avoir un bloc exécutable. "
"Lorsque la fin de ce bloc est atteinte, l'exécution continue normalement "
"après l'ensemble de l'instruction ``try`` (cela signifie que si deux "
"gestionnaires imbriqués existent pour la même exception, et que l'exception "
"se produit dans la clause ``try`` du gestionnaire interne, le gestionnaire "
"externe ne gère pas l'exception)."

#: ../Doc/reference/compound_stmts.rst:276
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the except clause.  This is as if ::"
msgstr ""
"Lorsqu'une exception a été assignée en utilisant ``as cible``, elle est "
"effacée à la fin de la clause ``except``. C'est comme si ::"

#: ../Doc/reference/compound_stmts.rst:282
msgid "was translated to ::"
msgstr "avait été traduit en ::"

#: ../Doc/reference/compound_stmts.rst:290
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the except clause.  Exceptions are cleared because with "
"the traceback attached to them, they form a reference cycle with the stack "
"frame, keeping all locals in that frame alive until the next garbage "
"collection occurs."
msgstr ""
"Cela veut dire que l'exception doit être assignée à un nom différent pour "
"pouvoir s'y référer après la clause ``except``. Les exceptions sont effacées "
"parce qu'avec la trace de la pile d'appels qui leur est attachée, elles "
"créent un cycle dans les pointeurs de références (avec le cadre de la pile), "
"ce qui conduit à conserver tous les noms locaux de ce cadre en mémoire "
"jusqu'au passage du ramasse-miettes."

#: ../Doc/reference/compound_stmts.rst:299
msgid ""
"Before an except clause's suite is executed, details about the exception are "
"stored in the :mod:`sys` module and can be accessed via :func:`sys."
"exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of the "
"exception class, the exception instance and a traceback object (see section :"
"ref:`types`) identifying the point in the program where the exception "
"occurred.  :func:`sys.exc_info` values are restored to their previous values "
"(before the call) when returning from a function that handled an exception."
msgstr ""
"Avant l'exécution de la suite d'une clause ``except``, les détails de "
"l'exception sont stockés dans le module :mod:`sys` et sont accessibles "
"*via* :func:`sys.exc_info`. :func:`sys.exc_info` renvoie un triplet composé "
"de la classe de l'exception, de l'instance d'exception et d'un objet trace "
"(voir la section :ref:`types`) identifiant le point du programme où "
"l'exception est survenue. Les valeurs de :func:`sys.exc_info` sont remises à "
"leurs anciennes valeurs (celles d'avant l'appel) au retour d'une fonction "
"qui a géré une exception."

#: ../Doc/reference/compound_stmts.rst:313
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"La clause optionnelle :keyword:`!else` n'est exécutée que si l'exécution "
"atteint la fin de la clause :keyword:`try`, aucune exception n'a été levée, "
"et aucun :keyword:`return`, :keyword:`continue`, ou :keyword:`break` ont "
"étés exécutés. Les exceptions dans la clause :keyword:`!else` ne sont pas "
"gérées par les clauses :keyword:`except` précédentes."

#: ../Doc/reference/compound_stmts.rst:321
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`!else` clauses.  If an exception occurs in any of the clauses and "
"is not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded::"
msgstr ""
"Si :keyword:`finally` est présente, elle spécifie un gestionnaire de "
"« nettoyage ». La clause :keyword:`try` est exécutée, y compris les clauses :"
"keyword:`except` et :keyword:`!else`. Si une exception se produit dans l'une "
"des clauses et n'est pas traitée, l'exception est temporairement "
"sauvegardée. La clause :keyword:`!finally` est exécutée. S'il y a une "
"exception sauvegardée, elle est levée à nouveau à la fin de la clause :"
"keyword:`!finally`. Si la clause :keyword:`!finally` lève une autre "
"exception, l'exception sauvegardée est définie comme le contexte de la "
"nouvelle exception. Si la clause :keyword:`!finally` exécute une "
"instruction :keyword:`return`, :keyword:`break` ou :keyword:`continue`, "
"l'exception sauvegardée est jetée ::"

#: ../Doc/reference/compound_stmts.rst:340
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr ""
"L'information relative à l'exception n'est pas disponible pour le programme "
"pendant l'exécution de la clause :keyword:`finally`."

#: ../Doc/reference/compound_stmts.rst:348
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"Lorsqu'une instruction :keyword:`return`, :keyword:`break` ou :keyword:"
"`continue` est exécutée dans la suite d'une instruction :keyword:`try` d'une "
"construction :keyword:`!try`…\\ :keyword:`!finally`, la clause :keyword:"
"`finally` est aussi exécutée « à la sortie »."

#: ../Doc/reference/compound_stmts.rst:352
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`finally` clause always executes, a :"
"keyword:`!return` statement executed in the :keyword:`!finally` clause will "
"always be the last one executed::"
msgstr ""
"La valeur de retour d'une fonction est déterminée par la dernière "
"instruction :keyword:`return` exécutée. Puisque la clause :keyword:`finally` "
"s'exécute toujours, une instruction :keyword:`!return` exécutée dans le :"
"keyword:`!finally` sera toujours la dernière clause exécutée ::"

#: ../Doc/reference/compound_stmts.rst:366
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Vous trouvez des informations supplémentaires relatives aux exceptions dans "
"la section :ref:`exceptions` et, dans la section :ref:`raise`, des "
"informations relatives à l'utilisation de l'instruction :keyword:`raise` "
"pour produire des exceptions."

#: ../Doc/reference/compound_stmts.rst:370
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`finally` clause due to a problem with the implementation."
msgstr ""
"Avant Python 3.8, une instruction :keyword:`continue` n'était pas licite "
"dans une clause :keyword:`finally` en raison d'un problème dans "
"l'implémentation."

#: ../Doc/reference/compound_stmts.rst:379
msgid "The :keyword:`!with` statement"
msgstr "L'instruction :keyword:`!with`"

#: ../Doc/reference/compound_stmts.rst:388
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"L'instruction :keyword:`with` est utilisée pour encapsuler l'exécution d'un "
"bloc avec des méthodes définies par un gestionnaire de contexte (voir la "
"section :ref:`context-managers`). Cela permet d'utiliser de manière simple "
"le patron de conception classique :keyword:`try`…\\ :keyword:`except`…\\ :"
"keyword:`finally`."

#: ../Doc/reference/compound_stmts.rst:397
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"L'exécution de l'instruction :keyword:`with` avec un seul "
"« élément » (*item* dans la grammaire) se déroule comme suit :"

#: ../Doc/reference/compound_stmts.rst:399
msgid ""
"The context expression (the expression given in the :token:`with_item`) is "
"evaluated to obtain a context manager."
msgstr ""
"L'expression de contexte (l'expression donnée dans le :token:`with_item`) "
"est évaluée pour obtenir un gestionnaire de contexte."

#: ../Doc/reference/compound_stmts.rst:402
#, fuzzy
msgid "The context manager's :meth:`__enter__` is loaded for later use."
msgstr ""
"La méthode :meth:`__exit__` du gestionnaire de contexte est chargée pour une "
"utilisation ultérieure."

#: ../Doc/reference/compound_stmts.rst:404
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""
"La méthode :meth:`__exit__` du gestionnaire de contexte est chargée pour une "
"utilisation ultérieure."

#: ../Doc/reference/compound_stmts.rst:406
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "La méthode :meth:`__enter__` du gestionnaire de contexte est invoquée."

#: ../Doc/reference/compound_stmts.rst:408
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""
"Si une cible (*target* dans la grammaire ci-dessus) a été incluse dans "
"l'instruction :keyword:`with`, la valeur de retour de :meth:`__enter__` lui "
"est assignée."

#: ../Doc/reference/compound_stmts.rst:413
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 6 below."
msgstr ""
"L'instruction :keyword:`with` garantit que si la méthode :meth:`__enter__` "
"se termine sans erreur, alors la méthode :meth:`__exit__` est toujours "
"appelée. Ainsi, si une erreur se produit pendant l'assignation à la liste "
"cible, elle est traitée de la même façon qu'une erreur se produisant dans la "
"suite. Voir l'étape 6 ci-dessous."

#: ../Doc/reference/compound_stmts.rst:419
msgid "The suite is executed."
msgstr "La suite est exécutée."

#: ../Doc/reference/compound_stmts.rst:421
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""
"La méthode :meth:`__exit__` du gestionnaire de contexte est invoquée. Si une "
"exception a causé la sortie de la suite, son type, sa valeur et sa pile "
"d'appels sont passés en arguments à :meth:`__exit__`. Sinon, trois "
"arguments :const:`None` sont fournis."

#: ../Doc/reference/compound_stmts.rst:426
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised.  If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""
"Si l'on est sorti de la suite en raison d'une exception et que la valeur de "
"retour de la méthode :meth:`__exit__` était fausse, l'exception est levée à "
"nouveau. Si la valeur de retour était vraie, l'exception est supprimée et "
"l'exécution continue avec l'instruction qui suit l'instruction :keyword:"
"`with`."

#: ../Doc/reference/compound_stmts.rst:431
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""
"Si l'on est sorti de la suite pour une raison autre qu'une exception, la "
"valeur de retour de :meth:`__exit__` est ignorée et l'exécution se poursuit "
"à l'endroit normal pour le type de sortie prise."

#: ../Doc/reference/compound_stmts.rst:435
#: ../Doc/reference/compound_stmts.rst:798
#: ../Doc/reference/compound_stmts.rst:839
msgid "The following code::"
msgstr "Le code suivant ::"

#: ../Doc/reference/compound_stmts.rst:440
#: ../Doc/reference/compound_stmts.rst:465
#: ../Doc/reference/compound_stmts.rst:844
#, fuzzy
msgid "is semantically equivalent to::"
msgstr "est sémantiquement équivalent à ::"

#: ../Doc/reference/compound_stmts.rst:459
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"Avec plus d'un élément, les gestionnaires de contexte sont traités comme si "
"plusieurs instructions :keyword:`with` étaient imbriquées ::"

#: ../Doc/reference/compound_stmts.rst:471
msgid "Support for multiple context expressions."
msgstr "Prise en charge de multiples expressions de contexte."

#: ../Doc/reference/compound_stmts.rst:477
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` — L'instruction « *with* »"

#: ../Doc/reference/compound_stmts.rst:477
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"La spécification, les motivations et des exemples de l'instruction :keyword:"
"`with` en Python."

#: ../Doc/reference/compound_stmts.rst:488
msgid "Function definitions"
msgstr "Définition de fonctions"

#: ../Doc/reference/compound_stmts.rst:503
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"Une définition de fonction définit un objet fonction allogène (voir la "
"section :ref:`types`) :"

#: ../Doc/reference/compound_stmts.rst:523
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"Une définition de fonction est une instruction qui est exécutée. Son "
"exécution lie le nom de la fonction, dans l'espace de nommage local courant, "
"à un objet fonction (un objet qui encapsule le code exécutable de la "
"fonction). Cet objet fonction contient une référence à l'espace des noms "
"globaux courant comme espace des noms globaux à utiliser lorsque la fonction "
"est appelée."

#: ../Doc/reference/compound_stmts.rst:529
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"La définition de la fonction n'exécute pas le corps de la fonction ; elle "
"n'est exécutée que lorsque la fonction est appelée. [#]_"

#: ../Doc/reference/compound_stmts.rst:535
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"Une définition de fonction peut être encapsulée dans une ou plusieurs "
"expressions :term:`decorator` ; les décorateurs sont évalués lorsque la "
"fonction est définie, dans la portée qui contient la définition de "
"fonction ; le résultat doit être un appelable, qui est invoqué avec l'objet "
"fonction comme seul argument ; la valeur renvoyée est liée au nom de la "
"fonction en lieu et place de l'objet fonction. Lorsqu'il y a plusieurs "
"décorateurs, ils sont appliqués par imbrication ; par exemple, le code "
"suivant ::"

#: ../Doc/reference/compound_stmts.rst:546
#: ../Doc/reference/compound_stmts.rst:712
msgid "is roughly equivalent to ::"
msgstr "est à peu près équivalent à ::"

#: ../Doc/reference/compound_stmts.rst:551
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"sauf que la fonction originale n'est pas temporairement liée au nom ``func``."

#: ../Doc/reference/compound_stmts.rst:558
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"Lorsqu'un ou plusieurs :term:`paramètres <parameter>` sont de la forme "
"*parameter* ``=`` *expression*, on dit que la fonction a des « valeurs de "
"paramètres par défaut ». Pour un paramètre avec une valeur par défaut, l’:"
"term:`argument` correspondant peut être omis lors de l'appel, la valeur par "
"défaut du paramètre est alors utilisée. Si un paramètre a une valeur par "
"défaut, tous les paramètres suivants jusqu'à \"``*``\" doivent aussi avoir "
"une valeur par défaut — ceci est une restriction syntaxique qui n'est pas "
"exprimée dans la grammaire."

#: ../Doc/reference/compound_stmts.rst:566
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter is a mutable object, such as a list or a "
"dictionary: if the function modifies the object (e.g. by appending an item "
"to a list), the default value is in effect modified.  This is generally not "
"what was intended.  A way around this is to use ``None`` as the default, and "
"explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**Les valeurs par défaut des paramètres sont évaluées de la gauche vers la "
"droite quand la définition de la fonction est exécutée**. Cela signifie que "
"l'expression est évaluée une fois, lorsque la fonction est définie, et que "
"c'est la même valeur « pré-calculée » qui est utilisée à chaque appel. C'est "
"particulièrement important à comprendre lorsqu'un paramètre par défaut est "
"un objet mutable, tel qu'une liste ou un dictionnaire : si la fonction "
"modifie l'objet (par exemple en ajoutant un élément à une liste), la valeur "
"par défaut est modifiée. En général, ce n'est pas l'effet voulu. Une façon "
"d'éviter cet écueil est d'utiliser ``None`` par défaut et de tester "
"explicitement la valeur dans le corps de la fonction. Par exemple ::"

#: ../Doc/reference/compound_stmts.rst:586
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from position arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed used keyword arguments."
msgstr ""
"La sémantique de l'appel de fonction est décrite plus en détail dans la "
"section :ref:`calls`. Un appel de fonction assigne toujours des valeurs à "
"tous les paramètres mentionnés dans la liste des paramètres, soit à partir "
"d'arguments positionnels, d'arguments par mots-clés ou de valeurs par "
"défaut. S'il y a un paramètre de la forme \"``*identifier``\", il est "
"initialisé à un tuple recevant les paramètres positionnels en surplus, la "
"valeur par défaut étant le tuple vide. S'il y a un paramètre de la forme "
"\"``**identifier``\", il est initialisé à un nouveau tableau associatif "
"ordonné qui récupère tous les arguments par mot-clé en surplus, la valeur "
"par défaut étant un tableau associatif vide. Les paramètres après \"``*``\" "
"ou \"``*identifier``\" sont forcément des paramètres par mot-clé et ne "
"peuvent être passés qu'en utilisant des arguments par mot-clé."

#: ../Doc/reference/compound_stmts.rst:602
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``.  "
"Functions may have \"return\" annotation of the form \"``-> expression``\" "
"after the parameter list.  These annotations can be any valid Python "
"expression.  The presence of annotations does not change the semantics of a "
"function.  The annotation values are available as values of a dictionary "
"keyed by the parameters' names in the :attr:`__annotations__` attribute of "
"the function object.  If the ``annotations`` import from :mod:`__future__` "
"is used, annotations are preserved as strings at runtime which enables "
"postponed evaluation.  Otherwise, they are evaluated when the function "
"definition is executed.  In this case annotations may be evaluated in a "
"different order than they appear in the source code."
msgstr ""
"Les paramètres peuvent avoir une :term:`annotation <function annotation>` "
"sous la forme \"``: expression``\" après le nom du paramètre. Tout paramètre "
"peut avoir une annotation, même ceux de la forme ``*identifier`` ou "
"``**identifier``. Les fonctions peuvent avoir une annotation pour la valeur "
"de retour, sous la forme \"``-> expression``\" après la liste des "
"paramètres. Ces annotations peuvent prendre la forme de toute expression "
"Python valide. Leur présence ne change pas la sémantique de la fonction. Les "
"valeurs des annotations sont accessibles comme valeurs d'un dictionnaire "
"dont les clés sont les noms des paramètres et défini comme attribut :attr:"
"`__annotations__` de l'objet fonction. Si ``annotations`` est importé de :"
"mod:`__future__`, les annotations sont conservées sous la forme de chaînes "
"de caractères, permettant leur évaluation différée. Autrement, elles sont "
"interprétées en même temps que la déclaration des fonctions. Dans le premier "
"cas, les annotations peuvent être interprétées dans un ordre différent de "
"l'ordre dans lequel elles apparaissent dans le fichier."

#: ../Doc/reference/compound_stmts.rst:617
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"Il est aussi possible de créer des fonctions anonymes (fonctions non liées à "
"un nom), pour une utilisation immédiate dans des expressions. Utilisez alors "
"des expressions lambda, décrites dans la section :ref:`lambda`. Notez qu'une "
"expression lambda est simplement un raccourci pour définir une fonction "
"simple ; une fonction définie par une instruction \":keyword:`def`\" peut "
"être passée (en argument) ou assignée à un autre nom, tout comme une "
"fonction définie par une expression lambda. La forme \":keyword:`!def`\" est "
"en fait plus puissante puisqu'elle permet l'exécution de plusieurs "
"instructions et les annotations."

#: ../Doc/reference/compound_stmts.rst:625
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**Note pour les programmeurs :** les fonctions sont des objets de première "
"classe. Une instruction \"``def``\" exécutée à l'intérieur d'une définition "
"de fonction définit une fonction locale qui peut être renvoyée ou passée en "
"tant qu'argument. Les variables libres utilisées dans la fonction imbriquée "
"ont accès aux variables locales de la fonction contenant le \"``def``\".  "
"Voir la section :ref:`naming` pour plus de détails."

#: ../Doc/reference/compound_stmts.rst:634
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` — Annotations de fonctions"

#: ../Doc/reference/compound_stmts.rst:634
msgid "The original specification for function annotations."
msgstr "La spécification originale pour les annotations de fonctions."

#: ../Doc/reference/compound_stmts.rst:637
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` — Indications de types"

#: ../Doc/reference/compound_stmts.rst:637
msgid "Definition of a standard meaning for annotations: type hints."
msgstr ""
"Définition de la signification standard pour les annotations : indications "
"de types."

#: ../Doc/reference/compound_stmts.rst:641
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` — Syntaxe pour les annotations de variables"

#: ../Doc/reference/compound_stmts.rst:640
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables"
msgstr ""
"Capacité d'indiquer des types pour les déclarations de variables, y compris "
"les variables de classes et les variables d'instances"

#: ../Doc/reference/compound_stmts.rst:644
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` — Évaluation différée des annotations"

#: ../Doc/reference/compound_stmts.rst:644
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"Gestion des références postérieures à l'intérieur des annotations en "
"préservant les annotations sous forme de chaînes à l'exécution au lieu d'une "
"évaluation directe."

#: ../Doc/reference/compound_stmts.rst:651
msgid "Class definitions"
msgstr "Définition de classes"

#: ../Doc/reference/compound_stmts.rst:666
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""
"Une définition de classe définit un objet classe (voir la section :ref:"
"`types`) :"

#: ../Doc/reference/compound_stmts.rst:673
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"Une définition de classe est une instruction qui est exécutée. La liste "
"d'héritage (*inheritance* entre crochets dans la grammaire ci-dessus) donne "
"habituellement une liste de classes de base (voir :ref:`metaclasses` pour "
"des utilisations plus avancées). Donc chaque élément de la liste doit "
"pouvoir être évalué comme un objet classe qui autorise les sous-classes. Les "
"classes sans liste d'héritage héritent, par défaut, de la classe de base :"
"class:`object` ; d'où ::"

#: ../Doc/reference/compound_stmts.rst:682
msgid "is equivalent to ::"
msgstr "est équivalente à ::"

#: ../Doc/reference/compound_stmts.rst:687
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"La suite de la classe est ensuite exécutée dans un nouveau cadre d'exécution "
"(voir :ref:`naming`), en utilisant un espace de nommage local nouvellement "
"créé et l'espace de nommage global d'origine (habituellement, la suite "
"contient principalement des définitions de fonctions). Lorsque la suite de "
"la classe termine son exécution, son cadre d'exécution est abandonné mais "
"son espace des noms locaux est sauvegardé [#]_. Un objet classe est alors "
"créé en utilisant la liste d'héritage pour les classes de base et l'espace "
"de nommage sauvegardé comme dictionnaire des attributs. Le nom de classe est "
"lié à l'objet classe dans l'espace de nommage local original."

#: ../Doc/reference/compound_stmts.rst:696
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's ``__dict__``.  Note that this is reliable only right after "
"the class is created and only for classes that were defined using the "
"definition syntax."
msgstr ""
"L'ordre dans lequel les attributs sont définis dans le corps de la classe "
"est préservé dans le ``__dict__`` de la nouvelle classe. Notez que ceci "
"n'est fiable que juste après la création de la classe et seulement pour les "
"classes qui ont été définies en utilisant la syntaxe de définition."

#: ../Doc/reference/compound_stmts.rst:701
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"La création de classes peut être fortement personnalisée en utilisant les :"
"ref:`métaclasses <metaclasses>`."

#: ../Doc/reference/compound_stmts.rst:706
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""
"Les classes peuvent aussi être décorées : comme pour les décorateurs de "
"fonctions, ::"

#: ../Doc/reference/compound_stmts.rst:717
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"Les règles d'évaluation pour les expressions de décorateurs sont les mêmes "
"que pour les décorateurs de fonctions. Le résultat est alors lié au nom de "
"la classe."

#: ../Doc/reference/compound_stmts.rst:720
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**Note pour les programmeurs :** les variables définies dans la définition "
"de classe sont des attributs de classe ; elles sont partagées par les "
"instances. Les attributs d'instance peuvent être définis dans une méthode en "
"utilisant ``self.name = value``. Les attributs de classe et d'instance sont "
"accessibles par la notation \"``self.name``\", et un attribut d'instance "
"masque un attribut de classe de même nom lorsqu'on y accède de cette façon. "
"Les attributs de classe peuvent être utilisés comme valeurs par défaut pour "
"les attributs d'instances, mais l'utilisation de valeurs mutables peut "
"conduire à des résultats inattendus. Les :ref:`descripteurs <descriptors>` "
"peuvent être utilisés pour créer des variables d'instances avec des détails "
"d'implémentation différents."

#: ../Doc/reference/compound_stmts.rst:735
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` — Métaclasses dans Python 3000"

#: ../Doc/reference/compound_stmts.rst:733
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"La proposition qui a modifié la déclaration de métaclasses à la syntaxe "
"actuelle, et la sémantique pour la façon dont les classes avec métaclasses "
"sont construites."

#: ../Doc/reference/compound_stmts.rst:738
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` — Décorateurs de classes"

#: ../Doc/reference/compound_stmts.rst:738
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"La proposition qui a ajouté des décorateurs de classe. Les décorateurs de "
"fonction et de méthode ont été introduits dans :pep:`318`."

#: ../Doc/reference/compound_stmts.rst:745
msgid "Coroutines"
msgstr "Coroutines"

#: ../Doc/reference/compound_stmts.rst:753
msgid "Coroutine function definition"
msgstr "Définition de fonctions coroutines"

#: ../Doc/reference/compound_stmts.rst:763
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`).  Inside the body of a coroutine function, ``await`` "
"and ``async`` identifiers become reserved keywords; :keyword:`await` "
"expressions, :keyword:`async for` and :keyword:`async with` can only be used "
"in coroutine function bodies."
msgstr ""
"L'exécution de coroutines Python peut être suspendue et reprise à plusieurs "
"endroits (voir :term:`coroutine`). Dans le corps d'une coroutine, tout "
"identificateur ``await`` ou ``async`` devient un mots-clé réservé ; les "
"expressions :keyword:`await`, :keyword:`async for` et :keyword:`async with` "
"ne peuvent être utilisées que dans les corps de coroutines."

#: ../Doc/reference/compound_stmts.rst:769
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"Les fonctions définies avec la syntaxe ``async def`` sont toujours des "
"fonctions coroutines, même si elles ne contiennent aucun mot-clé ``await`` "
"ou ``async``."

#: ../Doc/reference/compound_stmts.rst:772
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"C'est une :exc:`SyntaxError` d'utiliser une expression ``yield from`` dans "
"une coroutine."

#: ../Doc/reference/compound_stmts.rst:775
msgid "An example of a coroutine function::"
msgstr "Un exemple de fonction coroutine ::"

#: ../Doc/reference/compound_stmts.rst:786
msgid "The :keyword:`!async for` statement"
msgstr "L'instruction :keyword:`!async for`"

#: ../Doc/reference/compound_stmts.rst:791
msgid ""
"An :term:`asynchronous iterable` is able to call asynchronous code in its "
"*iter* implementation, and :term:`asynchronous iterator` can call "
"asynchronous code in its *next* method."
msgstr ""
"Un :term:`itérable asynchrone <asynchronous iterable>` est capable d'appeler "
"du code asynchrone dans l'implémentation de sa méthode *iter* ; un :term:"
"`itérateur asynchrone <asynchronous iterator>` peut appeler du code "
"asynchrone dans sa méthode *next*."

#: ../Doc/reference/compound_stmts.rst:795
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterators."
msgstr ""
"L'instruction ``async for`` permet d'itérer facilement sur des itérateurs "
"asynchrones."

#: ../Doc/reference/compound_stmts.rst:805
msgid "Is semantically equivalent to::"
msgstr "est sémantiquement équivalent à ::"

#: ../Doc/reference/compound_stmts.rst:821
msgid "See also :meth:`__aiter__` and :meth:`__anext__` for details."
msgstr ""
"Voir aussi :meth:`__aiter__` et :meth:`__anext__` pour plus de détails."

#: ../Doc/reference/compound_stmts.rst:823
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"C'est une :exc:`SyntaxError` d'utiliser une instruction ``async for`` en "
"dehors d'une fonction coroutine."

#: ../Doc/reference/compound_stmts.rst:831
msgid "The :keyword:`!async with` statement"
msgstr "L'instruction :keyword:`!async with`"

#: ../Doc/reference/compound_stmts.rst:836
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
"Un :term:`gestionnaire de contexte asynchrone <asynchronous context "
"manager>` est un :term:`gestionnaire de contexte <context manager>` qui est "
"capable de suspendre l'exécution dans ses méthodes *enter* et *exit*."

#: ../Doc/reference/compound_stmts.rst:863
msgid "See also :meth:`__aenter__` and :meth:`__aexit__` for details."
msgstr ""
"Voir aussi :meth:`__aenter__` et :meth:`__aexit__` pour plus de détails."

#: ../Doc/reference/compound_stmts.rst:865
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"C'est une :exc:`SyntaxError` d'utiliser l'instruction ``async with`` en "
"dehors d'une fonction coroutine."

#: ../Doc/reference/compound_stmts.rst:871
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` — Coroutines avec les syntaxes *async* et *await*"

#: ../Doc/reference/compound_stmts.rst:871
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"La proposition qui a fait que les coroutines soient un concept propre en "
"Python, et a ajouté la syntaxe de prise en charge de celles-ci."

#: ../Doc/reference/compound_stmts.rst:876
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/reference/compound_stmts.rst:877
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"L'exception est propagée à la pile d'appels à moins qu'il n'y ait une "
"clause :keyword:`finally` qui lève une autre exception, ce qui entraîne la "
"perte de l'ancienne exception. Cette nouvelle exception entraîne la perte "
"pure et simple de l'ancienne."

#: ../Doc/reference/compound_stmts.rst:881
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"Une chaîne littérale apparaissant comme première instruction dans le corps "
"de la fonction est transformée en attribut ``__doc__`` de la fonction et "
"donc en :term:`docstring` de la fonction."

#: ../Doc/reference/compound_stmts.rst:885
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""
"Une chaîne littérale apparaissant comme première instruction dans le corps "
"de la classe est transformée en élément ``__doc__`` de l'espace de nommage "
"et donc en :term:`docstring` de la classe."

#~ msgid ""
#~ "Currently, control \"flows off the end\" except in the case of an "
#~ "exception or the execution of a :keyword:`return`, :keyword:`continue`, "
#~ "or :keyword:`break` statement."
#~ msgstr ""
#~ "Actuellement, l'exécution \"atteint la fin\" sauf dans le cas d'une "
#~ "exception, de l'exécution de l'instruction :keyword:`return`, :keyword:"
#~ "`continue` ou :keyword:`break`."
