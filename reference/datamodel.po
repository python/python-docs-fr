# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-17 16:05+0100\n"
"PO-Revision-Date: 2020-06-01 16:54+0900\n"
"Last-Translator: Samuel Giffard <samuel@giffard.co>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.3.1\n"

#: reference/datamodel.rst:6
msgid "Data model"
msgstr "Modèle de données"

#: reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "Objets, valeurs et types"

#: reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""
"En Python, les données sont représentées sous forme :dfn:`d'objets`. Toutes "
"les données d'un programme Python sont représentées par des objets ou par "
"des relations entre les objets (dans un certain sens, et en conformité avec "
"le modèle de Von Neumann d'« ordinateur à programme enregistré », le code "
"est aussi représenté par des objets)."

#: reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""
"Chaque objet possède un identifiant, un type et une valeur. *L'identifiant* "
"d'un objet ne change jamais après sa création ; vous pouvez vous le "
"représenter comme l'adresse de l'objet en mémoire. L'opérateur :keyword:`is` "
"compare les identifiants de deux objets ; la fonction :func:`id` renvoie un "
"entier représentant cet identifiant."

#: reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "en CPython, ``id(x)`` est l'adresse mémoire où est stocké ``x``."

#: reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects "
"of that type.  The :func:`type` function returns an object's type (which is "
"an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"Le type de l'objet détermine les opérations que l'on peut appliquer à "
"l'objet (par exemple, « a-t-il une longueur ? ») et définit aussi les "
"valeurs possibles pour les objets de ce type. La fonction :func:`type` "
"renvoie le type de l'objet (qui est lui-même un objet). Comme l'identifiant, "
"le :dfn:`type` d'un objet ne peut pas être modifié [#]_."

#: reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is "
"more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"La *valeur* de certains objets peut changer. Les objets dont la valeur peut "
"changer sont dits *muables* (*mutable* en anglais) ; les objets dont la "
"valeur est définitivement fixée à leur création sont dits *immuables* "
"(*immutable* en anglais). La valeur d'un objet conteneur immuable qui "
"contient une référence vers un objet muable peut varier lorsque la valeur de "
"l'objet muable change ; cependant, le conteneur est quand même considéré "
"comme immuable parce que l'ensemble des objets qu'il contient ne peut pas "
"être modifié. Ainsi, l'immuabilité n'est pas strictement équivalente au fait "
"d'avoir une valeur non modifiable, c'est plus subtil. La muabilité d'un "
"objet est définie par son type ; par exemple, les nombres, les chaînes de "
"caractères et les *n*-uplets sont immuables alors que les dictionnaires et "
"les listes sont muables."

#: reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"Un objet n'est jamais explicitement détruit ; cependant, lorsqu'il ne peut "
"plus être atteint, il a vocation à être supprimé par le ramasse-miettes "
"(*garbage-collector* en anglais). L'implémentation peut retarder cette "
"opération ou même ne pas la faire du tout — la façon dont fonctionne le "
"ramasse-miette est particulière à chaque implémentation, l'important étant "
"qu'il ne supprime pas d'objet qui peut encore être atteint."

#: reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"CPython utilise aujourd'hui un mécanisme de compteur de références avec une "
"détection, en temps différé et optionnelle, des cycles d'objets. Ce "
"mécanisme supprime la plupart des objets dès qu'ils ne sont plus accessibles "
"mais il ne garantit pas la suppression des objets où il existe des "
"références circulaires. Consultez la documentation du module :mod:`gc` pour "
"tout ce qui concerne la suppression des cycles. D'autres implémentations "
"agissent différemment et CPython pourrait évoluer. Ne vous reposez pas sur "
"la finalisation immédiate des objets devenus inaccessibles (ainsi, vous "
"devez toujours fermer les fichiers explicitement)."

#: reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr ""
"Notez que si vous utilisez les fonctionnalités de débogage ou de trace de "
"l'implémentation, il est possible que des références qui seraient "
"normalement supprimées soient toujours présentes. Notez aussi que capturer "
"une exception avec l'instruction :keyword:`try`...\\ :keyword:`except` peut "
"conserver des objets en vie."

#: reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`close` method. Programs are strongly recommended "
"to explicitly close such objects.  The ':keyword:`try`...\\ :keyword:"
"`finally`' statement and the ':keyword:`with`' statement provide convenient "
"ways to do this."
msgstr ""
"Certains objets font référence à des ressources « externes » telles que des "
"fichiers ouverts ou des fenêtres. Ces objets libèrent ces ressources au "
"moment où ils sont supprimés, mais comme le ramasse-miettes ne garantit pas "
"qu'il supprime tous les objets, ces objets fournissent également un moyen "
"explicite de libérer la ressource externe, généralement sous la forme d'une "
"méthode :meth:`close`. Nous incitons fortement les programmeurs à fermer "
"explicitement de tels objets. Les instructions :keyword:`try`...\\ :keyword:"
"`finally` et :keyword:`with` sont très pratiques pour cela."

#: reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"Certains objets contiennent des références à d'autres objets ; on les "
"appelle *conteneurs*. Comme exemples de conteneurs, nous pouvons citer les "
"*n*-uplets, les listes et les dictionnaires. Les références sont parties "
"intégrantes de la valeur d'un conteneur. Dans la plupart des cas, lorsque "
"nous parlons de la valeur d'un conteneur, nous parlons des valeurs, pas des "
"identifiants des objets contenus ; cependant, lorsque nous parlons de la "
"muabilité d'un conteneur, seuls les identifiants des objets immédiatement "
"contenus sont concernés. Ainsi, si un conteneur immuable (comme un *n*-"
"uplet) contient une référence à un objet muable, sa valeur change si cet "
"objet muable est modifié."

#: reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer "
"to the same object with the value one, depending on the implementation, but "
"after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr ""
"Presque tous les comportements d'un objet dépendent du type de l'objet. Même "
"son identifiant est concerné dans un certain sens : pour les types "
"immuables, les opérations qui calculent de nouvelles valeurs peuvent en fait "
"renvoyer une référence à n'importe quel objet existant avec le même type et "
"la même valeur, alors que pour les objets muables cela n'est pas autorisé. "
"Par exemple, après ``a = 1 ; b = 1``, ``a`` et ``b`` peuvent ou non se "
"référer au même objet avec la valeur un, en fonction de l'implémentation. "
"Mais après ``c = [] ; d = []``, il est garanti que ``c`` et ``d`` font "
"référence à deux listes vides distinctes nouvellement créées. Notez que ``c "
"= d = []`` attribue le même objet à ``c`` et ``d``."

#: reference/datamodel.rst:120
msgid "The standard type hierarchy"
msgstr "Hiérarchie des types standards"

#: reference/datamodel.rst:129
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"Vous trouvez ci-dessous une liste des types natifs de Python. Des modules "
"d'extension (écrits en C, Java ou d'autres langages) peuvent définir des "
"types supplémentaires. Les futures versions de Python pourront ajouter des "
"types à cette hiérarchie (par exemple les nombres rationnels, des tableaux "
"d'entiers stockés efficacement, etc.), bien que de tels ajouts se trouvent "
"souvent plutôt dans la bibliothèque standard."

#: reference/datamodel.rst:140
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"Quelques descriptions des types ci-dessous contiennent un paragraphe listant "
"des « attributs spéciaux ». Ces attributs donnent accès à l'implémentation "
"et n'ont, en général, pas vocation à être utilisés. Leur définition peut "
"changer dans le futur."

#: reference/datamodel.rst:150
msgid "None"
msgstr "``None``"

#: reference/datamodel.rst:147
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"Ce type ne possède qu'une seule valeur. Il n'existe qu'un seul objet avec "
"cette valeur. Vous accédez à cet objet avec le nom natif ``None``. Il est "
"utilisé pour signifier l'absence de valeur dans de nombreux cas, par exemple "
"pour des fonctions qui ne retournent rien explicitement. Sa valeur booléenne "
"est fausse."

#: reference/datamodel.rst:170
msgid "NotImplemented"
msgstr "NotImplemented"

#: reference/datamodel.rst:155
#, fuzzy
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods should return this value if they "
"do not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  It should not be evaluated in a boolean context."
msgstr ""
"Ce type ne possède qu'une seule valeur. Il n'existe qu'un seul objet avec "
"cette valeur. Vous accédez à cet objet avec le nom natif ``NotImplemented``. "
"Les méthodes numériques et les comparaisons riches doivent renvoyer cette "
"valeur si elles n'implémentent pas l'opération pour les opérandes fournis "
"(l'interpréteur essaie alors l'opération en permutant les opérandes ou tout "
"autre stratégie de contournement, en fonction de l'opérateur). Sa valeur "
"booléenne est vraie."

#: reference/datamodel.rst:162
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr ""
"Consultez :ref:`implementing-the-arithmetic-operations` pour davantage de "
"détails."

#: reference/datamodel.rst:166
msgid ""
"Evaluating ``NotImplemented`` in a boolean context is deprecated. While it "
"currently evaluates as true, it will emit a :exc:`DeprecationWarning`. It "
"will raise a :exc:`TypeError` in a future version of Python."
msgstr ""

#: reference/datamodel.rst:179
msgid "Ellipsis"
msgstr "Ellipse"

#: reference/datamodel.rst:177
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"Ce type ne possède qu'une seule valeur. Il n'existe qu'un seul objet avec "
"cette valeur. Vous accédez à cet objet avec le littéral ``...`` ou le nom "
"natif ``Ellipsis``. Sa valeur booléenne est vraie."

#: reference/datamodel.rst:267
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: reference/datamodel.rst:184
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"Ces objets sont créés par les littéraux numériques et renvoyés en tant que "
"résultats par les opérateurs et les fonctions arithmétiques natives. Les "
"objets numériques sont immuables ; une fois créés, leur valeur ne change "
"pas. Les nombres Python sont bien sûr très fortement corrélés aux nombres "
"mathématiques mais ils sont soumis aux limitations des représentations "
"numériques par les ordinateurs."

#: reference/datamodel.rst:190
msgid ""
"The string representations of the numeric classes, computed by :meth:"
"`__repr__` and :meth:`__str__`, have the following properties:"
msgstr ""

#: reference/datamodel.rst:194
msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr ""

#: reference/datamodel.rst:198
msgid "The representation is in base 10, when possible."
msgstr ""

#: reference/datamodel.rst:200
msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, are "
"not shown."
msgstr ""

#: reference/datamodel.rst:203
msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, are "
"not shown."
msgstr ""

#: reference/datamodel.rst:206
msgid "A sign is shown only when the number is negative."
msgstr ""

#: reference/datamodel.rst:208
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr ""
"Python distingue les entiers, les nombres à virgule flottante et les nombres "
"complexes :"

#: reference/datamodel.rst:242
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral`"

#: reference/datamodel.rst:214
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""
"Ils représentent des éléments de l'ensemble mathématique des entiers "
"(positifs ou négatifs)."

#: reference/datamodel.rst:217
msgid "There are two types of integers:"
msgstr "Il existe deux types d'entiers :"

#: reference/datamodel.rst:219
msgid "Integers (:class:`int`)"
msgstr "Entiers (:class:`int`)"

#: reference/datamodel.rst:221
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"Ils représentent les nombres, sans limite de taille, sous réserve de pouvoir "
"être stockés en mémoire (virtuelle). Afin de pouvoir effectuer des décalages "
"et appliquer des masques, on considère qu'ils ont une représentation "
"binaire. Les nombres négatifs sont représentés comme une variante du "
"complément à 2, qui donne l'illusion d'une chaîne infinie de bits de signe "
"s'étendant vers la gauche."

#: reference/datamodel.rst:237
msgid "Booleans (:class:`bool`)"
msgstr "Booléens (:class:`bool`)"

#: reference/datamodel.rst:233
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of the integer type, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or ``\"True"
"\"`` are returned, respectively."
msgstr ""
"Ils représentent les valeurs *faux* et *vrai*. Deux objets, ``False`` et "
"``True``, sont les seuls objets booléens. Le type booléen est un sous-type "
"du type entier et les valeurs booléennes se comportent comme les valeurs 0 "
"(pour ``False``) et 1 (pour ``True``) dans presque tous les contextes. "
"L'exception concerne la conversion en chaîne de caractères où ``\"False\"`` "
"et ``\"True\"`` sont renvoyées."

#: reference/datamodel.rst:241
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr ""
"Les règles pour la représentation des entiers ont pour objet de donner "
"l'interprétation la plus naturelle pour les opérations de décalage et "
"masquage qui impliquent des entiers négatifs."

#: reference/datamodel.rst:257
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

#: reference/datamodel.rst:251
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating point numbers."
msgstr ""
"Ils représentent les nombres à virgule flottante en double précision, tels "
"que manipulés directement par la machine. Vous dépendez donc de "
"l'architecture machine sous-jacente (et de l'implémentation C ou Java) pour "
"les intervalles gérés et le traitement des débordements. Python ne gère pas "
"les nombres à virgule flottante en précision simple ; les gains en puissance "
"de calcul et mémoire, qui sont généralement la raison de l'utilisation des "
"nombres en simple précision, sont annihilés par le fait que Python encapsule "
"de toute façon ces nombres dans des objets. Il n'y a donc aucune raison de "
"compliquer le langage avec deux types de nombres à virgule flottante."

#: reference/datamodel.rst:267
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: reference/datamodel.rst:264
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"Ils représentent les nombres complexes, sous la forme d'un couple de nombres "
"à virgule flottante en double précision, tels que manipulés directement par "
"la machine. Les mêmes restrictions s'appliquent que pour les nombres à "
"virgule flottante. La partie réelle et la partie imaginaire d'un nombre "
"complexe ``z`` peuvent être demandées par les attributs en lecture seule ``z."
"real`` et ``z.imag``."

#: reference/datamodel.rst:384
msgid "Sequences"
msgstr "Séquences"

#: reference/datamodel.rst:277
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""
"Ils représentent des ensembles de taille finie indicés par des entiers "
"positifs ou nuls. La fonction native :func:`len` renvoie le nombre "
"d'éléments de la séquence. Quand la longueur d'une séquence est *n*, "
"l'ensemble des indices contient les entiers 0, 1 ..., *n-1*. On accède à "
"l'élément d'indice *i* de la séquence *a* par ``a[i]``."

#: reference/datamodel.rst:284
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr ""
"Les séquences peuvent aussi être découpées en tranches (*slicing* en "
"anglais) : ``a[i:j]`` sélectionne tous les éléments d'indice *k* tel que *i* "
"``<=`` *k* ``<`` *j*. Quand on l'utilise dans une expression, la tranche est "
"du même type que la séquence. Ceci veut dire que l'ensemble des indices de "
"la tranche est renuméroté de manière à partir de 0."

#: reference/datamodel.rst:289
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"Quelques séquences gèrent le « découpage étendu » (*extended slicing* en "
"anglais) avec un troisième paramètre : ``a[i:j:k]`` sélectionne tous les "
"éléments de *a* d'indice *x* où ``x = i + n*k``, avec *n* ``>=`` ``0`` et "
"*i* ``<=`` *x* ``<`` *j*."

#: reference/datamodel.rst:293
msgid "Sequences are distinguished according to their mutability:"
msgstr "Les séquences se différencient en fonction de leur muabilité :"

#: reference/datamodel.rst:350
msgid "Immutable sequences"
msgstr "Séquences immuables"

#: reference/datamodel.rst:300
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"Un objet de type de séquence immuable ne peut pas être modifié une fois "
"qu'il a été créé. Si l'objet contient des références à d'autres objets, ces "
"autres objets peuvent être muables et peuvent être modifiés ; cependant, les "
"objets directement référencés par un objet immuable ne peuvent pas être "
"modifiés."

#: reference/datamodel.rst:305
msgid "The following types are immutable sequences:"
msgstr "Les types suivants sont des séquences immuables :"

#: reference/datamodel.rst:328
msgid "Strings"
msgstr "Chaînes de caractères"

#: reference/datamodel.rst:318
msgid ""
"A string is a sequence of values that represent Unicode code points. All the "
"code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:type:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form "
"to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string "
"object. :meth:`str.encode` can be used to convert a :class:`str` to :class:"
"`bytes` using the given text encoding, and :meth:`bytes.decode` can be used "
"to achieve the opposite."
msgstr ""
"Une chaîne de caractères (*string* en anglais) est une séquence de valeurs "
"qui représentent des caractères Unicode. Tout caractère dont le code est "
"dans l'intervalle ``U+0000 - U+10FFFF`` peut être représenté dans une "
"chaîne. Python ne possède pas de type :c:type:`char` ; à la place, chaque "
"caractère Unicode dans la chaîne est représenté par un objet chaîne de "
"longueur ``1``. La fonction native :func:`ord` convertit un caractère "
"Unicode de la représentation en chaîne vers un entier dans l'intervalle ``0 "
"- 10FFFF`` ; la fonction :func:`chr` convertit un entier de l'intervalle ``0 "
"- 10FFFF`` vers l'objet chaîne de longueur ``1`` correspondant. :meth:`str."
"encode` peut être utilisée pour convertir un objet :class:`str` vers :class:"
"`bytes` selon l'encodage spécifié et :meth:`bytes.decode` effectue "
"l'opération inverse."

#: reference/datamodel.rst:341
msgid "Tuples"
msgstr "*n*-uplets (*tuples* en anglais)"

#: reference/datamodel.rst:336
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"Les éléments d'un *n*-uplet peuvent être n'importe quel objet Python. Les "
"*n*-uplets de deux éléments ou plus sont formés par une liste d'expressions "
"dont les éléments sont séparés par des virgules. Un *n*-uplet composé d'un "
"seul élément (un « singleton ») est formé en suffixant une expression avec "
"une virgule (une expression en tant que telle ne crée pas un *n*-uplet car "
"les parenthèses doivent rester disponibles pour grouper les expressions). Un "
"*n*-uplet vide est formé à l'aide d'une paire de parenthèses vide."

#: reference/datamodel.rst:350
msgid "Bytes"
msgstr "Chaînes d'octets (ou *bytes*)"

#: reference/datamodel.rst:346
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes()` constructor can be used to "
"create bytes objects.  Also, bytes objects can be decoded to strings via "
"the :meth:`~bytes.decode` method."
msgstr ""
"Les objets *bytes* sont des tableaux immuables. Les éléments sont des octets "
"(donc composés de 8 bits), représentés par des entiers dans l'intervalle 0 à "
"255 inclus. Les littéraux *bytes* (tels que ``b'abc'``) et la fonction "
"native constructeur :func:`bytes()` peuvent être utilisés pour créer des "
"objets *bytes*. Aussi, un objet *bytes* peut être décodé vers une chaîne "
"*via* la méthode :meth:`~bytes.decode`."

#: reference/datamodel.rst:384
msgid "Mutable sequences"
msgstr "Séquences muables"

#: reference/datamodel.rst:360
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""
"Les séquences muables peuvent être modifiées après leur création. Les "
"notations de tranches et de sous-ensembles peuvent être utilisées en tant "
"que cibles d'une assignation ou de l'instruction :keyword:`del` "
"(suppression)."

#: reference/datamodel.rst:364
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "Il existe aujourd'hui deux types intrinsèques de séquences muables :"

#: reference/datamodel.rst:371
msgid "Lists"
msgstr "Listes"

#: reference/datamodel.rst:369
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"N'importe quel objet Python peut être élément d'une liste. Les listes sont "
"créées en plaçant entre crochets une liste d'expressions dont les éléments "
"sont séparés par des virgules (notez que les listes de longueur 0 ou 1 ne "
"sont pas des cas particuliers)."

#: reference/datamodel.rst:379
msgid "Byte Arrays"
msgstr "Tableaux d'octets"

#: reference/datamodel.rst:376
msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"Un objet *bytearray* est un tableau muable. Il est créé par la fonction "
"native constructeur :func:`bytearray`. À part la propriété d'être muable (et "
"donc de ne pas pouvoir calculer son empreinte par hachage), un tableau "
"d'octets possède la même interface et les mêmes fonctionnalités qu'un objet "
"immuable :class:`bytes`."

#: reference/datamodel.rst:383
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type, as does the :mod:`collections` module."
msgstr ""
"Le module d'extension :mod:`array` fournit un autre exemple de type de "
"séquence muable, de même que le module :mod:`collections`."

#: reference/datamodel.rst:418
msgid "Set types"
msgstr "Ensembles"

#: reference/datamodel.rst:391
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""
"Ils représentent les ensembles d'objets, non ordonnés, finis et dont les "
"éléments sont uniques. Tels quels, ils ne peuvent pas être indicés. "
"Cependant, il est possible d'itérer dessus et la fonction native :func:`len` "
"renvoie le nombre d'éléments de l'ensemble. Les utilisations classiques des "
"ensembles sont les tests d'appartenance rapides, la suppression de doublons "
"dans une séquence et le calcul d'opérations mathématiques telles que "
"l'intersection, l'union, la différence et le complémentaire."

#: reference/datamodel.rst:398
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"Pour les éléments des ensembles, les mêmes règles concernant l'immuabilité "
"s'appliquent que pour les clés de dictionnaires. Notez que les types "
"numériques obéissent aux règles normales pour les comparaisons numériques : "
"si deux nombres sont égaux (pour l'opération de comparaison, par exemple "
"``1`` et ``1.0``), un seul élément est conservé dans l'ensemble."

#: reference/datamodel.rst:403
msgid "There are currently two intrinsic set types:"
msgstr "Actuellement, il existe deux types d'ensembles natifs :"

#: reference/datamodel.rst:410
msgid "Sets"
msgstr "Ensembles"

#: reference/datamodel.rst:408
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr ""
"Ils représentent les ensembles muables. Un ensemble est créé par la fonction "
"native constructeur :func:`set` et peut être modifié par la suite à l'aide "
"de différentes méthodes, par exemple :meth:`~set.add`."

#: reference/datamodel.rst:418
msgid "Frozen sets"
msgstr "Ensembles figés"

#: reference/datamodel.rst:415
msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""
"Ils représentent les ensembles immuables. Ils sont créés par la fonction "
"native constructeur :func:`frozenset`. Comme un ensemble figé est immuable "
"et :term:`hachable`, il peut être utilisé comme élément d'un autre ensemble "
"ou comme clé de dictionnaire."

#: reference/datamodel.rst:465
msgid "Mappings"
msgstr "Tableaux de correspondances"

#: reference/datamodel.rst:426
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"Ils représentent les ensembles finis d'objets indicés par des ensembles "
"index arbitraires. La notation ``a[k]`` sélectionne l'élément indicé par "
"``k`` dans le tableau de correspondance ``a`` ; elle peut être utilisée dans "
"des expressions, comme cible d'une assignation ou avec l'instruction :"
"keyword:`del`. La fonction native :func:`len` renvoie le nombre d'éléments "
"du tableau de correspondances."

#: reference/datamodel.rst:432
msgid "There is currently a single intrinsic mapping type:"
msgstr ""
"Il n'existe actuellement qu'un seul type natif pour les tableaux de "
"correspondances :"

#: reference/datamodel.rst:465
msgid "Dictionaries"
msgstr "Dictionnaires"

#: reference/datamodel.rst:437
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"Ils représentent les ensembles finis d'objets indicés par des valeurs "
"presque arbitraires. Les seuls types de valeurs non reconnus comme clés sont "
"les valeurs contenant des listes, des dictionnaires ou les autres types "
"muables qui sont comparés par valeur plutôt que par l'identifiant de "
"l'objet. La raison de cette limitation est qu'une implémentation efficace de "
"dictionnaire requiert que l'empreinte par hachage des clés reste constante "
"dans le temps. Les types numériques obéissent aux règles normales pour les "
"comparaisons numériques : si deux nombres sont égaux pour l'opération de "
"comparaison, par exemple ``1`` et ``1.0``, alors ces deux nombres peuvent "
"être utilisés indifféremment pour désigner la même entrée du dictionnaire."

#: reference/datamodel.rst:446
msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced in "
"the same order they were added sequentially over the dictionary. Replacing "
"an existing key does not change the order, however removing a key and re-"
"inserting it will add it to the end instead of keeping its old place."
msgstr ""
"Les dictionnaires préservent l’ordre d’insertion, ce qui signifie que les "
"clés sont renvoyées séquentiellement dans le même ordre que celui de "
"l’insertion. Remplacer une clé existante ne change pas l’ordre. Par contre, "
"la retirer puis la réinsérer la met à la fin et non à sa précédente position."

#: reference/datamodel.rst:451
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see "
"section :ref:`dict`)."
msgstr ""
"Les dictionnaires sont muables : ils peuvent être créés par la notation "
"``{...}`` (reportez-vous à la section :ref:`dict`)."

#: reference/datamodel.rst:458
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"Les modules d'extensions :mod:`dbm.ndbm` et :mod:`dbm.gnu` apportent "
"d'autres exemples de types tableaux de correspondances, de même que le "
"module :mod:`collections`."

#: reference/datamodel.rst:462
msgid ""
"Dictionaries did not preserve insertion order in versions of Python before "
"3.6. In CPython 3.6, insertion order was preserved, but it was considered an "
"implementation detail at that time rather than a language guarantee."
msgstr ""
"Les dictionnaires ne conservaient pas l’ordre d’insertion dans les versions "
"antérieures à Python 3.6. Dans CPython 3.6, l’ordre d’insertion était déjà "
"conservé, mais considéré comme un détail d’implémentation et non comme une "
"garantie du langage."

#: reference/datamodel.rst:723
msgid "Callable types"
msgstr "Types appelables"

#: reference/datamodel.rst:474
msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr ""
"Ce sont les types sur lesquels on peut faire un appel de fonction (lisez la "
"section :ref:`calls`) :"

#: reference/datamodel.rst:577
msgid "User-defined functions"
msgstr "Fonctions allogènes"

#: reference/datamodel.rst:483
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"Un objet fonction allogène (ou fonction définie par l'utilisateur, mais ce "
"n'est pas forcément l'utilisateur courant qui a défini cette fonction) est "
"créé par la définition d'une fonction (voir la section :ref:`function`). Il "
"doit être appelé avec une liste d'arguments contenant le même nombre "
"d'éléments que la liste des paramètres formels de la fonction."

#: reference/datamodel.rst:488
msgid "Special attributes:"
msgstr "Attributs spéciaux :"

#: reference/datamodel.rst:506
msgid "Attribute"
msgstr "Attribut"

#: reference/datamodel.rst:506
msgid "Meaning"
msgstr "Signification"

#: reference/datamodel.rst:508
msgid ":attr:`__doc__`"
msgstr ":attr:`__doc__`"

#: reference/datamodel.rst:508
msgid ""
"The function's documentation string, or ``None`` if unavailable; not "
"inherited by subclasses."
msgstr ""
"Texte de documentation de la fonction ou ``None`` s'il n'en existe pas ; "
"n'est pas héritée par les sous-classes."

#: reference/datamodel.rst:513 reference/datamodel.rst:521
#: reference/datamodel.rst:531 reference/datamodel.rst:552
#: reference/datamodel.rst:559
msgid "Writable"
msgstr "Accessible en écriture"

#: reference/datamodel.rst:513
msgid ":attr:`~definition.\\ __name__`"
msgstr ":attr:`~definition.\\ __name__`"

#: reference/datamodel.rst:513
msgid "The function's name."
msgstr "Nom de la fonction."

#: reference/datamodel.rst:516
msgid ":attr:`~definition.\\ __qualname__`"
msgstr ":attr:`~definition.\\ __qualname__`"

#: reference/datamodel.rst:516
msgid "The function's :term:`qualified name`."
msgstr ":term:`Nom qualifié <qualified name>` de la fonction."

#: reference/datamodel.rst:521
msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

#: reference/datamodel.rst:521
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""
"Nom du module où la fonction est définie ou ``None`` si ce nom n'est pas "
"disponible."

#: reference/datamodel.rst:525
msgid ":attr:`__defaults__`"
msgstr ":attr:`__defaults__`"

#: reference/datamodel.rst:525
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr ""
"Tuple contenant les valeurs des arguments par défaut pour ceux qui en sont "
"dotés ou ``None`` si aucun argument n'a de valeur par défaut."

#: reference/datamodel.rst:531
msgid ":attr:`__code__`"
msgstr ":attr:`__code__`"

#: reference/datamodel.rst:531
msgid "The code object representing the compiled function body."
msgstr "Objet code représentant le corps de la fonction compilée."

#: reference/datamodel.rst:534
msgid ":attr:`__globals__`"
msgstr ":attr:`__globals__`"

#: reference/datamodel.rst:534
msgid ""
"A reference to the dictionary that holds the function's global variables --- "
"the global namespace of the module in which the function was defined."
msgstr ""
"Référence pointant vers le dictionnaire contenant les variables globales de "
"la fonction — l'espace de noms global du module dans lequel la fonction est "
"définie."

#: reference/datamodel.rst:545
msgid "Read-only"
msgstr "Accessible en lecture seule"

#: reference/datamodel.rst:541
msgid ":attr:`~object.__dict__`"
msgstr ":attr:`~object.__dict__`"

#: reference/datamodel.rst:541
msgid "The namespace supporting arbitrary function attributes."
msgstr "Espace de nommage accueillant les attributs de la fonction."

#: reference/datamodel.rst:545
msgid ":attr:`__closure__`"
msgstr ":attr:`__closure__`"

#: reference/datamodel.rst:545
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables. See below for information on the ``cell_contents`` attribute."
msgstr ""
"``None`` ou *n*-uplet de cellules qui contient un lien pour chaque variable "
"libre de la fonction. Voir ci-dessous pour les informations relatives à "
"l'attribut ``cell_contents``."

#: reference/datamodel.rst:552
msgid ":attr:`__annotations__`"
msgstr ":attr:`__annotations__`"

#: reference/datamodel.rst:552
msgid ""
"A dict containing annotations of parameters.  The keys of the dict are the "
"parameter names, and ``'return'`` for the return annotation, if provided."
msgstr ""
"Dictionnaire contenant les annotations des paramètres. Les clés du "
"dictionnaire sont les noms des paramètres et la clé ``\"return\"`` est "
"utilisée pour les annotations de la valeur renvoyée. Les entrées du "
"dictionnaire ne sont présentes que si les paramètres sont effectivement "
"annotés."

#: reference/datamodel.rst:559
msgid ":attr:`__kwdefaults__`"
msgstr ":attr:`__kwdefaults__`"

#: reference/datamodel.rst:559
msgid "A dict containing defaults for keyword-only parameters."
msgstr ""
"Dictionnaire contenant les valeurs par défaut pour les paramètres passés par "
"mot-clé."

#: reference/datamodel.rst:563
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr ""
"La plupart des attributs étiquetés « Accessible en écriture » vérifient le "
"type de la valeur qu'on leur assigne."

#: reference/datamodel.rst:565
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined "
"functions. Function attributes on built-in functions may be supported in the "
"future.*"
msgstr ""
"Les objets fonctions acceptent également l'assignation et la lecture "
"d'attributs arbitraires. Vous pouvez utiliser cette fonctionnalité pour, par "
"exemple, associer des métadonnées aux fonctions. La notation classique par "
"point est utilisée pour définir et lire de tels attributs. *Notez que "
"l'implémentation actuelle accepte seulement les attributs de fonction sur "
"les fonctions définies par l'utilisateur. Les attributs de fonction pour les "
"fonctions natives seront peut-être acceptés dans le futur.*"

#: reference/datamodel.rst:571
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to get "
"the value of the cell, as well as set the value."
msgstr ""
"Un objet cellule possède un attribut ``cell_contents``. Il peut être utilisé "
"pour obtenir la valeur de la cellule et pour en définir la valeur."

#: reference/datamodel.rst:574
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below. The :data:"
"`cell <types.CellType>` type can be accessed in the :mod:`types` module."
msgstr ""
"Vous trouvez davantage d'informations sur la définition de fonctions dans le "
"code de cet objet ; la description des types internes est donnée plus bas. "
"Le type :data:`cell <types.CellType>` est accessible dans le module :mod:"
"`types`."

#: reference/datamodel.rst:640
msgid "Instance methods"
msgstr "Méthodes d'instances"

#: reference/datamodel.rst:585
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""
"Un objet méthode d'instance combine une classe, une instance de classe et "
"tout objet appelable (normalement une fonction définie par l'utilisateur)."

#: reference/datamodel.rst:595
msgid ""
"Special read-only attributes: :attr:`__self__` is the class instance "
"object, :attr:`__func__` is the function object; :attr:`__doc__` is the "
"method's documentation (same as ``__func__.__doc__``); :attr:`~definition."
"__name__` is the method name (same as ``__func__.__name__``); :attr:"
"`__module__` is the name of the module the method was defined in, or "
"``None`` if unavailable."
msgstr ""
"Attributs spéciaux en lecture seule : :attr:`__self__` est l'objet instance "
"de classe, :attr:`__func__` est l'objet fonction ; :attr:`__doc__` est la "
"documentation de la méthode (comme ``__func__.__doc__``) ; :attr:"
"`~definition.__name__` est le nom de la méthode (comme ``__func__."
"__name__``) ; :attr:`__module__` est le nom du module où la méthode est "
"définie ou ``None`` s'il n'est pas disponible."

#: reference/datamodel.rst:601
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr ""
"Les méthodes savent aussi accéder (mais pas modifier) les attributs de la "
"fonction de l'objet fonction sous-jacent."

#: reference/datamodel.rst:604
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object or a class method object."
msgstr ""
"Les objets méthodes définies par l'utilisateur peuvent être créés quand vous "
"récupérez un attribut de classe (par exemple *via* une instance de cette "
"classe) si cet attribut est un objet fonction définie par l'utilisateur ou "
"un objet méthode de classe."

#: reference/datamodel.rst:608
msgid ""
"When an instance method object is created by retrieving a user-defined "
"function object from a class via one of its instances, its :attr:`__self__` "
"attribute is the instance, and the method object is said to be bound.  The "
"new method's :attr:`__func__` attribute is the original function object."
msgstr ""
"Quand un objet méthode d'instance est créé à partir d'un objet fonction "
"définie par l'utilisateur *via* une des instances, son attribut :attr:"
"`__self__` est l'instance et l'objet méthode est réputé lié. Le nouvel "
"attribut de la méthode :attr:`__func__` est l'objet fonction original."

#: reference/datamodel.rst:614
msgid ""
"When an instance method object is created by retrieving a class method "
"object from a class or instance, its :attr:`__self__` attribute is the class "
"itself, and its :attr:`__func__` attribute is the function object underlying "
"the class method."
msgstr ""
"Quand un objet méthode d'instance est créé à partir d'un autre objet méthode "
"de la classe ou de l'instance, son attribut :attr:`__self__` est la classe "
"elle-même et son attribut :attr:`__func__` est l'objet fonction sous-jacent "
"la méthode de classe."

#: reference/datamodel.rst:619
msgid ""
"When an instance method object is called, the underlying function (:attr:"
"`__func__`) is called, inserting the class instance (:attr:`__self__`) in "
"front of the argument list.  For instance, when :class:`C` is a class which "
"contains a definition for a function :meth:`f`, and ``x`` is an instance of :"
"class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x, 1)``."
msgstr ""
"Quand un objet méthode d'instance est appelé, la fonction sous-jacente (:"
"attr:`__func__`) est appelée et l'objet instance de la classe (:attr:"
"`__self__`) est inséré en tête de liste des arguments. Par exemple, si :"
"class:`C` est une classe qui contient la définition d'une fonction :meth:`f` "
"et que ``x`` est une instance de :class:`C`, alors appeler ``x.f(1)`` est "
"équivalent à appeler ``C.f(x, 1)``."

#: reference/datamodel.rst:626
msgid ""
"When an instance method object is derived from a class method object, the "
"\"class instance\" stored in :attr:`__self__` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""
"Quand un objet méthode d'instance est dérivé à partir d'un objet méthode de "
"classe, l'instance de classe stockée dans :attr:`__self__` est en fait la "
"classe elle-même. Ainsi, appeler ``x.f(1)`` ou ``C.f(1)`` est équivalent à "
"appeler ``f(C, 1)`` où ``f`` est la fonction sous-jacente."

#: reference/datamodel.rst:631
msgid ""
"Note that the transformation from function object to instance method object "
"happens each time the attribute is retrieved from the instance.  In some "
"cases, a fruitful optimization is to assign the attribute to a local "
"variable and call that local variable. Also notice that this transformation "
"only happens for user-defined functions; other callable objects (and all non-"
"callable objects) are retrieved without transformation.  It is also "
"important to note that user-defined functions which are attributes of a "
"class instance are not converted to bound methods; this *only* happens when "
"the function is an attribute of the class."
msgstr ""
"Notez que la transformation d'objet fonction en objet méthode d'instance se "
"produit à chaque fois que l'attribut est récupéré à partir de l'instance. "
"Dans certains cas, assigner l'attribut à une variable locale et appeler "
"cette variable locale constitue une bonne optimisation. Notez aussi que "
"cette transformation n'a lieu que pour les fonctions définies par "
"l'utilisateur : les autres objets appelables (et les objets non appelables) "
"sont récupérés sans transformation. Il est aussi important de noter que les "
"fonctions définies par l'utilisateur qui sont attributs d'une instance de "
"classe ne sont pas converties en méthodes liées ; ceci n'a lieu que pour les "
"fonctions qui sont attributs de la classe."

#: reference/datamodel.rst:655
msgid "Generator functions"
msgstr "Fonctions générateurs"

#: reference/datamodel.rst:647
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an iterator object which can be used to execute the "
"body of the function:  calling the iterator's :meth:`iterator.__next__` "
"method will cause the function to execute until it provides a value using "
"the :keyword:`!yield` statement.  When the function executes a :keyword:"
"`return` statement or falls off the end, a :exc:`StopIteration` exception is "
"raised and the iterator will have reached the end of the set of values to be "
"returned."
msgstr ""
"Une fonction ou une méthode qui utilise l'instruction :keyword:`yield` (voir "
"la section :ref:`yield`) est appelée :dfn:`fonction générateur`. Une telle "
"fonction, lorsqu'elle est appelée, retourne toujours un objet itérateur qui "
"peut être utilisé pour exécuter le corps de la fonction : appeler la "
"méthode :meth:`iterator.__next__` de l'itérateur exécute la fonction jusqu'à "
"ce qu'elle renvoie une valeur à l'aide de l'instruction :keyword:`!yield`. "
"Quand la fonction exécute l'instruction :keyword:`return` ou se termine, une "
"exception :exc:`StopIteration` est levée et l'itérateur a atteint la fin de "
"l'ensemble de valeurs qu'il peut renvoyer."

#: reference/datamodel.rst:665
msgid "Coroutine functions"
msgstr "Fonctions coroutines"

#: reference/datamodel.rst:661
msgid ""
"A function or method which is defined using :keyword:`async def` is called "
"a :dfn:`coroutine function`.  Such a function, when called, returns a :term:"
"`coroutine` object.  It may contain :keyword:`await` expressions, as well "
"as :keyword:`async with` and :keyword:`async for` statements. See also the :"
"ref:`coroutine-objects` section."
msgstr ""
"Une fonction ou méthode définie en utilisant :keyword:`async def` est "
"appelée :dfn:`fonction coroutine`. Une telle fonction, quand elle est "
"appelée, renvoie un objet :term:`coroutine`. Elle peut contenir des "
"expressions :keyword:`await` ou :keyword:`async with` ou des instructions :"
"keyword:`async for`. Voir également la section :ref:`coroutine-objects`."

#: reference/datamodel.rst:684
msgid "Asynchronous generator functions"
msgstr "Fonctions générateurs asynchrones"

#: reference/datamodel.rst:672
msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator "
"function`.  Such a function, when called, returns an asynchronous iterator "
"object which can be used in an :keyword:`async for` statement to execute the "
"body of the function."
msgstr ""
"Une fonction ou une méthode définie avec :keyword:`async def` et qui utilise "
"l'instruction :keyword:`yield` est appelée :dfn:`fonction générateur "
"asynchrone`. Une telle fonction, quand elle est appelée, renvoie un objet "
"itérateur asynchrone qui peut être utilisé dans des instructions :keyword:"
"`async for` pour exécuter le corps de la fonction."

#: reference/datamodel.rst:678
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__` method will "
"return an :term:`awaitable` which when awaited will execute until it "
"provides a value using the :keyword:`yield` expression.  When the function "
"executes an empty :keyword:`return` statement or falls off the end, a :exc:"
"`StopAsyncIteration` exception is raised and the asynchronous iterator will "
"have reached the end of the set of values to be yielded."
msgstr ""
"Appeler la méthode :meth:`aiterator.__anext__` de l'itérateur asynchrone "
"renvoie un :term:`awaitable` qui, lorsqu'on l'attend, s'exécute jusqu'à ce "
"qu'il fournisse une valeur à l'aide de l'expression :keyword:`yield`. Quand "
"la fonction exécute une instruction :keyword:`return` (sans valeur) ou "
"arrive à la fin, une exception :exc:`StopAsynciteration` est levée et "
"l'itérateur asynchrone a atteint la fin de l'ensemble des valeurs qu'il peut "
"produire."

#: reference/datamodel.rst:699
msgid "Built-in functions"
msgstr "Fonctions natives"

#: reference/datamodel.rst:692
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; :attr:"
"`~definition.__name__` is the function's name; :attr:`__self__` is set to "
"``None`` (but see the next item); :attr:`__module__` is the name of the "
"module the function was defined in or ``None`` if unavailable."
msgstr ""
"Un objet fonction native est une enveloppe autour d'une fonction C. Nous "
"pouvons citer :func:`len` et :func:`math.sin` (:mod:`math` est un module "
"standard natif) comme fonctions natives. Le nombre et le type des arguments "
"sont déterminés par la fonction C. Des attributs spéciaux en lecture seule "
"existent : :attr:`__doc__` contient le texte de documentation de la fonction "
"(ou ``None`` s'il n'y en a pas) ; :attr:`~definition.__name__` est le nom de "
"la fonction ; :attr:`__self__` est défini à ``None`` ; :attr:`__module__` "
"est le nom du module où la fonction est définie ou ``None`` s'il n'est pas "
"disponible."

#: reference/datamodel.rst:711
msgid "Built-in methods"
msgstr "Méthodes natives"

#: reference/datamodel.rst:707
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`__self__` is set to the object denoted by *alist*."
msgstr ""
"Ce sont des fonctions natives déguisées, contenant un objet passé à une "
"fonction C en tant qu'argument supplémentaire implicite. Un exemple de "
"méthode native est ``une_liste.append()`` (``une_liste`` étant un objet "
"liste). Dans ce cas, l'attribut spécial en lecture seule :attr:`__self__` "
"est défini à l'objet *une_liste*."

#: reference/datamodel.rst:718
msgid "Classes"
msgstr "Classes"

#: reference/datamodel.rst:714
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`__new__`.  The arguments of the call are passed to :meth:"
"`__new__` and, in the typical case, to :meth:`__init__` to initialize the "
"new instance."
msgstr ""
"Les classes sont des appelables. Ces objets sont normalement utilisés pour "
"créer des instances d'elles-mêmes mais des variations sont possibles pour "
"les types de classes qui surchargent :meth:`__new__`. Les arguments de "
"l'appel sont passés à :meth:`__new__` et, dans le cas classique, :meth:"
"`__new__` initialise une nouvelle instance."

#: reference/datamodel.rst:723
msgid "Class Instances"
msgstr "Instances de classe"

#: reference/datamodel.rst:721
msgid ""
"Instances of arbitrary classes can be made callable by defining a :meth:"
"`__call__` method in their class."
msgstr ""
"Les instances d'une classe peuvent devenir des appelables si vous définissez "
"la méthode :meth:`__call__` de leur classe."

#: reference/datamodel.rst:773
msgid "Modules"
msgstr "Modules"

#: reference/datamodel.rst:730
msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the :keyword:"
"`import` statement, or by calling functions such as :func:`importlib."
"import_module` and built-in :func:`__import__`.  A module object has a "
"namespace implemented by a dictionary object (this is the dictionary "
"referenced by the ``__globals__`` attribute of functions defined in the "
"module).  Attribute references are translated to lookups in this dictionary, "
"e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``. A module object does "
"not contain the code object used to initialize the module (since it isn't "
"needed once the initialization is done)."
msgstr ""
"Les modules constituent l'organisation de base du code Python et sont créés "
"par le :ref:`mécanisme d'import <importsystem>` soit avec l'instruction :"
"keyword:`import`, soit en appelant des fonctions telles que :func:`importlib."
"import_module` ou la fonction native :func:`__import__`. Un objet module "
"possède un espace de nommage implémenté par un objet dictionnaire (c'est le "
"dictionnaire référencé par l'attribut ``__globals__`` des fonctions définies "
"dans le module). Les références à un attribut sont traduites en recherches "
"dans ce dictionnaire, par exemple ``m.x`` est équivalent à ``m.__dict__[\"x"
"\"]``. Un objet module ne contient pas l'objet code utilisé pour initialiser "
"le module (puisque celui-ci n'est plus nécessaire une fois l'initialisation "
"terminée)."

#: reference/datamodel.rst:742
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"L'assignation d'un attribut met à jour le dictionnaire d'espace de nommage "
"du module, par exemple ``m.x = 1`` est équivalent à ``m.__dict__[\"x\"] = "
"1``."

#: reference/datamodel.rst:752
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; :"
"attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__annotations__` (optional) is a dictionary containing :"
"term:`variable annotations <variable annotation>` collected during module "
"body execution; :attr:`__file__` is the pathname of the file from which the "
"module was loaded, if it was loaded from a file. The :attr:`__file__` "
"attribute may be missing for certain types of modules, such as C modules "
"that are statically linked into the interpreter; for extension modules "
"loaded dynamically from a shared library, it is the pathname of the shared "
"library file."
msgstr ""
"Attributs prédéfinis (en lecture-écriture) : :attr:`__name__` est le nom du "
"module ; :attr:`__doc__` est le texte de documentation du module (ou "
"``None`` s'il n'y en a pas) ; :attr:`__annotations__` (optionnel) est un "
"dictionnaire contenant les :term:`annotations de variables <variable "
"annotation>` collectées durant l'exécution du corps du module ; :attr:"
"`__file__` est le chemin vers le fichier à partir duquel le module a été "
"chargé, s'il a été chargé depuis un fichier. L'attribut :attr:`__file__` "
"peut être manquant pour certains types de modules, tels que les modules C "
"qui sont statiquement liés à l'interpréteur ; pour les modules d'extension "
"chargés dynamiquement à partir d'une bibliothèque partagée, c'est le chemin "
"vers le fichier de la bibliothèque partagée."

#: reference/datamodel.rst:765
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr ""
"Attribut spécial en lecture seule : :attr:`~object.__dict__` est l'objet "
"dictionnaire répertoriant l'espace de nommage du module."

#: reference/datamodel.rst:770
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"en raison de la manière dont CPython nettoie les dictionnaires de modules, "
"le dictionnaire du module est effacé quand le module n'est plus visible, "
"même si le dictionnaire possède encore des références actives. Pour éviter "
"ceci, copiez le dictionnaire ou gardez le module dans votre champ de "
"visibilité tant que vous souhaitez utiliser le dictionnaire directement."

#: reference/datamodel.rst:832
msgid "Custom classes"
msgstr "Classes déclarées par le développeur"

#: reference/datamodel.rst:776
msgid ""
"Custom class types are typically created by class definitions (see section :"
"ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, e."
"g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the "
"base classes. This search of the base classes uses the C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found in the documentation accompanying the 2.3 release at https://www."
"python.org/download/releases/2.3/mro/."
msgstr ""
"Le type d'une classe déclarée par le développeur est créé au moment de la "
"définition de la classe (voir la section :ref:`class`). Une classe possède "
"un espace de nommage implémenté sous la forme d'un objet dictionnaire. Les "
"références vers les attributs de la classe sont traduits en recherches dans "
"ce dictionnaire, par exemple ``C.x`` est traduit en ``C.__dict__[\"x\"]`` "
"(bien qu'il existe un certain nombre de fonctions automatiques qui "
"permettent de trouver des attributs par d'autres moyens). Si le nom "
"d'attribut n'est pas trouvé dans ce dictionnaire, la recherche continue dans "
"les classes de base. Les classes de base sont trouvées en utilisant l'ordre "
"de résolution des méthodes (*method resolution order* en anglais, ou MRO) "
"*C3* qui a un comportement cohérent même en présence d'héritages en \"diamant"
"\", où différentes branches d'héritages conduisent vers un ancêtre commun. "
"Vous trouverez plus de détails sur l'ordre de résolution des méthodes MRO "
"*C3* utilisé par Python dans la documentation de la version 2.3 disponible "
"sur https://www.python.org/download/releases/2.3/mro/."

#: reference/datamodel.rst:800
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"class method object, it is transformed into an instance method object whose :"
"attr:`__self__` attribute is :class:`C`.  When it would yield a static "
"method object, it is transformed into the object wrapped by the static "
"method object. See section :ref:`descriptors` for another way in which "
"attributes retrieved from a class may differ from those actually contained "
"in its :attr:`~object.__dict__`."
msgstr ""
"Quand une référence à un attribut de classe (disons la classe :class:`C`) "
"pointe vers un objet méthode de classe, elle est transformée en objet "
"méthode d'instance dont l'attribut :attr:`__self__` est :class:`C`. Quand "
"elle pointe vers un objet méthode statique, elle est transformée en objet "
"encapsulé par l'objet méthode statique. Reportez-vous à la section :ref:"
"`descriptors` pour une autre manière dont les attributs d'une classe "
"diffèrent de ceux réellement contenus dans son :attr:`~objet.__dict__`."

#: reference/datamodel.rst:810
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"Les assignations d'un attribut de classe mettent à jour le dictionnaire de "
"la classe, jamais le dictionnaire d'une classe de base."

#: reference/datamodel.rst:815
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"Un objet classe peut être appelé (voir ci-dessus) pour produire une instance "
"de classe (voir ci-dessous)."

#: reference/datamodel.rst:825
msgid ""
"Special attributes: :attr:`~definition.__name__` is the class name; :attr:"
"`__module__` is the module name in which the class was defined; :attr:"
"`~object.__dict__` is the dictionary containing the class's namespace; :attr:"
"`~class.__bases__` is a tuple containing the base classes, in the order of "
"their occurrence in the base class list; :attr:`__doc__` is the class's "
"documentation string, or ``None`` if undefined; :attr:`__annotations__` "
"(optional) is a dictionary containing :term:`variable annotations <variable "
"annotation>` collected during class body execution."
msgstr ""
"Attributs spéciaux : :attr:`~definition.__name__` est le nom de la classe ; :"
"attr:`__module__` est le nom du module dans lequel la classe est définie ; :"
"attr:`~object.__dict__` est le dictionnaire contenant l'espace de nommage de "
"la classe ; :attr:`~class.__bases__` est un *n*-uplet contenant les classes "
"de base, dans l'ordre d'apparition dans la liste des classes de base ; :attr:"
"`__doc__` est le texte de documentation de la classe (ou ``None`` s’il n’y "
"en a pas) ; :attr:`__annotations__` (optionnel) est un dictionnaire "
"contenant les :term:`annotations de variables <variable annotation>` "
"collectées durant l'exécution du corps de la classe."

#: reference/datamodel.rst:875
msgid "Class instances"
msgstr "Instances de classe"

#: reference/datamodel.rst:841
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`__self__` attribute is the instance.  Static "
"method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has a :meth:`__getattr__` "
"method, that is called to satisfy the lookup."
msgstr ""
"Une instance de classe est créée en appelant un objet classe (voir ci-"
"dessus). Une instance de classe possède un espace de nommage implémenté sous "
"la forme d'un dictionnaire qui est le premier endroit où sont recherchées "
"les références aux attributs. Quand un attribut n'est pas trouvé dans ce "
"dictionnaire et que la classe de l'instance contient un attribut avec ce "
"nom, la recherche continue avec les attributs de la classe. Si un attribut "
"de classe est trouvé et que c'est un objet fonction définie par "
"l'utilisateur, il est transformé en objet méthode d'instance dont "
"l'attribut :attr:`__self__` est l'instance. Les objets méthodes statiques et "
"méthodes de classe sont aussi transformés ; reportez-vous ci-dessous à "
"« Classes ». Lisez la section :ref:`descriptors` pour une autre façon de "
"récupérer les attributs d'une classe, où la récupération *via* ses instances "
"peut différer des objets réellement stockés dans le :attr:`~object.__dict__` "
"de la classe. Si aucun attribut de classe n'est trouvé et que la classe de "
"l'objet possède une méthode :meth:`__getattr__`, cette méthode est appelée "
"pour rechercher une correspondance."

#: reference/datamodel.rst:857
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`__setattr__` or :meth:"
"`__delattr__` method, this is called instead of updating the instance "
"dictionary directly."
msgstr ""
"Les assignations et suppressions d'attributs mettent à jour le dictionnaire "
"de l'instance, jamais le dictionnaire de la classe. Si la classe possède une "
"méthode :meth:`__setattr__` ou :meth:`__delattr__`, elle est appelée au lieu "
"de mettre à jour le dictionnaire de l'instance directement."

#: reference/datamodel.rst:867
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"Les instances de classes peuvent prétendre être des nombres, des séquences "
"ou des tableaux de correspondance si elles ont des méthodes avec des noms "
"spéciaux. Voir la section :ref:`specialnames`."

#: reference/datamodel.rst:874
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; :"
"attr:`~instance.__class__` is the instance's class."
msgstr ""
"Attributs spéciaux : :attr:`~object.__dict__` est le dictionnaire des "
"attributs ; :attr:`~instance.__class__` est la classe de l'instance."

#: reference/datamodel.rst:901
msgid "I/O objects (also known as file objects)"
msgstr "Objets Entrées-Sorties (ou objets fichiers)"

#: reference/datamodel.rst:891
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`~socket.socket."
"makefile` method of socket objects (and perhaps by other functions or "
"methods provided by extension modules)."
msgstr ""
"Un :term:`objet fichier` représente un fichier ouvert. Différents raccourcis "
"existent pour créer des objets fichiers : la fonction native :func:`open` et "
"aussi :func:`os.popen`, :func:`os.fdopen` ou la méthode :meth:`~socket."
"socket.makefile` des objets connecteurs (et sûrement d'autres fonctions ou "
"méthodes fournies par les modules d'extensions)."

#: reference/datamodel.rst:897
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized "
"to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"Les objets ``sys.stdin``, ``sys.stdout`` et ``sys.stderr`` sont initialisés "
"à des objets fichiers correspondant à l'entrée standard, la sortie standard "
"et le flux d'erreurs de l'interpréteur ; ils sont tous ouverts en mode texte "
"et se conforment donc à l'interface définie par la classe abstraite :class:"
"`io.TextIOBase`."

#: reference/datamodel.rst:1146
msgid "Internal types"
msgstr "Types internes"

#: reference/datamodel.rst:908
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"Quelques types utilisés en interne par l'interpréteur sont accessibles à "
"l'utilisateur. Leur définition peut changer dans les futures versions de "
"l'interpréteur mais ils sont donnés ci-dessous à fin d'exhaustivité."

#: reference/datamodel.rst:983
msgid "Code objects"
msgstr "Objets Code"

#: reference/datamodel.rst:915
msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""
"Un objet code représente le code Python sous sa forme compilée en :term:"
"`bytecode`. La différence entre un objet code et un objet fonction est que "
"l'objet fonction contient une référence explicite vers les globales de la "
"fonction (le module dans lequel elle est définie) alors qu'un objet code ne "
"contient aucun contexte ; par ailleurs, les valeurs par défaut des arguments "
"sont stockées dans l'objet fonction, pas dans l'objet code (parce que ce "
"sont des valeurs calculées au moment de l'exécution). Contrairement aux "
"objets fonctions, les objets codes sont immuables et ne contiennent aucune "
"référence (directe ou indirecte) à des objets muables."

#: reference/datamodel.rst:942
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; :attr:"
"`co_argcount` is the total number of positional arguments (including "
"positional-only arguments and arguments with default values); :attr:"
"`co_posonlyargcount` is the number of positional-only arguments (including "
"arguments with default values); :attr:`co_kwonlyargcount` is the number of "
"keyword-only arguments (including arguments with default values); :attr:"
"`co_nlocals` is the number of local variables used by the function "
"(including arguments); :attr:`co_varnames` is a tuple containing the names "
"of the local variables (starting with the argument names); :attr:"
"`co_cellvars` is a tuple containing the names of local variables that are "
"referenced by nested functions; :attr:`co_freevars` is a tuple containing "
"the names of free variables; :attr:`co_code` is a string representing the "
"sequence of bytecode instructions; :attr:`co_consts` is a tuple containing "
"the literals used by the bytecode; :attr:`co_names` is a tuple containing "
"the names used by the bytecode; :attr:`co_filename` is the filename from "
"which the code was compiled; :attr:`co_firstlineno` is the first line number "
"of the function; :attr:`co_lnotab` is a string encoding the mapping from "
"bytecode offsets to line numbers (for details see the source code of the "
"interpreter); :attr:`co_stacksize` is the required stack size; :attr:"
"`co_flags` is an integer encoding a number of flags for the interpreter."
msgstr ""
"Attributs spéciaux en lecture seule : :attr:`co_name` donne le nom de la "
"fonction ; :attr:`co_argcount` est le nombre total d'arguments positionnels "
"(y compris les arguments uniquement positionnels et les arguments avec des "
"valeurs par défaut) ; :attr:`co_posonlyargcount` est le nombre d'arguments "
"uniquement positionnels (y compris les arguments avec des valeurs par "
"défaut) ; :attr:`co_kwonlyargcount` est le nombre d'arguments par mots-clés "
"(y compris les arguments avec des valeurs par défaut) ; :attr:`co_nlocals` "
"est le nombre de variables locales utilisées par la fonction (y compris les "
"arguments) ; :attr:`co_varnames` est un *n*-uplet contenant les noms des "
"variables locales (en commençant par les noms des arguments) ; :attr:"
"`co_cellvars` est un *n*-uplet contenant les noms des variables locales qui "
"sont référencées par des fonctions imbriquées ; :attr:`co_freevars` est un "
"*n*-uplet contenant les noms des variables libres ; :attr:`co_code` est une "
"chaîne représentant la séquence des instructions de code intermédiaire ; :"
"attr:`co_consts` est un *n*-uplet contenant les littéraux utilisés par le "
"code intermédiaire ; :attr:`co_names` est un *n*-uplet contenant les noms "
"utilisés par le code intermédiaire ; :attr:`co_filename` est le nom de "
"fichier à partir duquel le code a été compilé ; :attr:`co_firstlineno` est "
"numéro de la première ligne de la fonction ; :attr:`co_lnotab` est une "
"chaîne codant la correspondance entre les décalages du code intermédiaire et "
"les numéros de ligne (pour plus de détails, voir le code source de "
"l'interpréteur) ; :attr:`co_stacksize` est la taille de pile requise ; :attr:"
"`co_flags` est un entier qui code différents drapeaux pour l'interpréteur."

#: reference/datamodel.rst:966
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the "
"``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` is "
"set if the function is a generator."
msgstr ""
"Les drapeaux suivants sont codés par des bits dans :attr:`co_flags` : le bit "
"``0x04`` est positionné à 1 si la fonction utilise la syntaxe ``*arguments`` "
"pour accepter un nombre arbitraire d'arguments positionnels ; le bit "
"``0x08`` est positionné à 1 si la fonction utilise la syntaxe ``**keywords`` "
"pour accepter un nombre arbitraire d'arguments nommés ; le bit ``0x20`` est "
"positionné à 1 si la fonction est un générateur."

#: reference/datamodel.rst:972
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with "
"a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr ""
"Les déclarations de fonctionnalité future ``from __future__ import "
"division`` utilisent aussi des bits dans :attr:`co_flags` pour indiquer si "
"l'objet code a été compilé avec une fonctionnalité future : le bit "
"``0x2000`` est positionné à 1 si la fonction a été compilée avec la division "
"future activée ; les bits ``0x10`` et ``0x1000`` étaient utilisés dans les "
"versions antérieures de Python."

#: reference/datamodel.rst:978
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr "Les autres bits de :attr:`co_flags` sont réservés à un usage interne."

#: reference/datamodel.rst:982
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr ""
"Si l'objet code représente une fonction, le premier élément dans :attr:"
"`co_consts` est le texte de documentation de la fonction (ou ``None`` s'il "
"n'y en a pas)."

#: reference/datamodel.rst:1042
msgid "Frame objects"
msgstr "Objets cadres"

#: reference/datamodel.rst:990
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below), and are also passed to registered trace functions."
msgstr ""
"Un objet cadre représente le cadre d'exécution. Il apparait dans des objets "
"traces (voir plus loin) et est passé comme argument aux fonctions de traçage "
"actives."

#: reference/datamodel.rst:1001
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; :attr:"
"`f_code` is the code object being executed in this frame; :attr:`f_locals` "
"is the dictionary used to look up local variables; :attr:`f_globals` is used "
"for global variables; :attr:`f_builtins` is used for built-in (intrinsic) "
"names; :attr:`f_lasti` gives the precise instruction (this is an index into "
"the bytecode string of the code object)."
msgstr ""
"Attributs spéciaux en lecture seule : :attr:`f_back` pointe vers le cadre "
"précédent (l'appelant) ou ``None`` si c'est le pied de la pile d'appel ; :"
"attr:`f_code` est l'objet code en cours d'exécution dans ce cadre ; :attr:"
"`f_locals` est le dictionnaire dans lequel sont cherchées les variables "
"locales ; :attr:`f_globals` est utilisé pour les variables globales ; :attr:"
"`f_builtins` est utilisé pour les noms natifs ; :attr:`f_lasti` donne "
"l'instruction précise (c'est un indice dans la chaîne de *bytecode* de "
"l'objet code)."

#: reference/datamodel.rst:1015
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function "
"called for various events during code execution (this is used by the "
"debugger). Normally an event is triggered for each new source line - this "
"can be disabled by setting :attr:`f_trace_lines` to :const:`False`."
msgstr ""
"Attributs spéciaux en lecture-écriture : :attr:`f_trace`, s'il n'est pas "
"``None``, c'est une fonction appelée à différentes occasions durant "
"l'exécution du code (elle est utilisée par le débogueur). Normalement, un "
"événement est déclenché pour chaque ligne de code source — ce comportement "
"peut être désactivé en définissant :attr:`f_trace_lines` à :const:`False`."

#: reference/datamodel.rst:1020
msgid ""
"Implementations *may* allow per-opcode events to be requested by setting :"
"attr:`f_trace_opcodes` to :const:`True`. Note that this may lead to "
"undefined interpreter behaviour if exceptions raised by the trace function "
"escape to the function being traced."
msgstr ""
"Une implémentation *peut* autoriser le déclenchement des événements *opcode* "
"par *opcode* en définissant :attr:`f_trace_opcodes` à :const:`True`. Notez "
"que cela peut conduire à un comportement erratique de l'interpréteur si des "
"exceptions levées la fonction de traçage s'échappent vers la fonction en "
"train d'être tracée."

#: reference/datamodel.rst:1025
msgid ""
":attr:`f_lineno` is the current line number of the frame --- writing to this "
"from within a trace function jumps to the given line (only for the bottom-"
"most frame).  A debugger can implement a Jump command (aka Set Next "
"Statement) by writing to f_lineno."
msgstr ""
":attr:`f_lineno` est le numéro de la ligne courante du cadre — écrire dedans "
"depuis une fonction trace fait sauter à la ligne demandée (seulement pour le "
"cadre le plus bas). Un débogueur peut implémenter une commande « sauter "
"vers » (aussi appelée « Définir la prochaine instruction » ou *Set Next "
"Statement* en anglais) en écrivant dans ``f_lineno``."

#: reference/datamodel.rst:1030
msgid "Frame objects support one method:"
msgstr "Les objets cadres comprennent une méthode :"

#: reference/datamodel.rst:1034
msgid ""
"This method clears all references to local variables held by the frame.  "
"Also, if the frame belonged to a generator, the generator is finalized.  "
"This helps break reference cycles involving frame objects (for example when "
"catching an exception and storing its traceback for later use)."
msgstr ""
"Cette méthode efface toutes les références aux variables locales conservées "
"dans le cadre. Par ailleurs, si le cadre est celui d'un générateur, le "
"générateur se termine. Ceci permet de casser des références cycliques qui "
"incluent des objets cadres (par exemple, lors de la capture d'une exception "
"et du stockage de la pile d'appels pour une utilisation future)."

#: reference/datamodel.rst:1040
msgid ":exc:`RuntimeError` is raised if the frame is currently executing."
msgstr ":exc:`RuntimeError` est levée si le cadre est en cours d'exécution."

#: reference/datamodel.rst:1102
msgid "Traceback objects"
msgstr "Objets traces"

#: reference/datamodel.rst:1057
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is implicitly created when an exception occurs, and may also be "
"explicitly created by calling :class:`types.TracebackType`."
msgstr ""
"Les objets traces représentent la pile de traces d'une exception. Un objet "
"trace est implicitement créé quand une exception apparaît et peut être "
"explicitement créé en appelant :class:`types.TracebackType`."

#: reference/datamodel.rst:1061
msgid ""
"For implicitly created tracebacks, when the search for an exception handler "
"unwinds the execution stack, at each unwound level a traceback object is "
"inserted in front of the current traceback.  When an exception handler is "
"entered, the stack trace is made available to the program. (See section :ref:"
"`try`.) It is accessible as the third item of the tuple returned by ``sys."
"exc_info()``, and as the ``__traceback__`` attribute of the caught exception."
msgstr ""
"Pour les traces créées implicitement, quand l'interpréteur recherche un "
"gestionnaire d'exception en remontant la pile d'exécution, un objet trace "
"est inséré devant l'objet trace courant à chaque nouveau niveau. Quand il "
"entre dans le gestionnaire d'exception, la pile d'appels est rendue "
"accessible au programme (voir la section :ref:`try`). Elle est accessible "
"par le troisième élément du triplet renvoyé par ``sys.exc_info()`` et comme "
"attribut ``__traceback__`` de l'exception qui est traitée."

#: reference/datamodel.rst:1069
msgid ""
"When the program contains no suitable handler, the stack trace is written "
"(nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as ``sys.last_traceback``."
msgstr ""
"Quand le programme ne contient aucun gestionnaire adéquat, la pile de traces "
"est écrite (joliment formatée) sur la sortie d'erreur standard ; si "
"l'interpréteur est interactif, elle est rendue disponible pour l'utilisateur "
"en tant que ``sys.last_traceback``."

#: reference/datamodel.rst:1074
msgid ""
"For explicitly created tracebacks, it is up to the creator of the traceback "
"to determine how the ``tb_next`` attributes should be linked to form a full "
"stack trace."
msgstr ""
"Pour les traces créées explicitement, il revient au créateur de la trace de "
"déterminer comment les attributs ``tb_next`` doivent être liés pour former "
"la pile complète des traces."

#: reference/datamodel.rst:1084
msgid ""
"Special read-only attributes: :attr:`tb_frame` points to the execution frame "
"of the current level; :attr:`tb_lineno` gives the line number where the "
"exception occurred; :attr:`tb_lasti` indicates the precise instruction. The "
"line number and last instruction in the traceback may differ from the line "
"number of its frame object if the exception occurred in a :keyword:`try` "
"statement with no matching except clause or with a finally clause."
msgstr ""
"Attributs spéciaux en lecture seule : :attr:`tb_frame` pointe vers le cadre "
"d'exécution du niveau courant ; :attr:`tb_lineno` donne le numéro de ligne "
"où l'exception a été levée ; :attr:`tb_lasti` indique l'instruction précise. "
"Le numéro de ligne et la dernière instruction dans la trace peuvent différer "
"du numéro de ligne de l'objet cadre si l'exception a eu lieu dans une "
"instruction :keyword:`try` sans qu'il n'y ait de clause :keyword:`!except` "
"adéquate ou sans clause *finally*."

#: reference/datamodel.rst:1096
msgid ""
"Special writable attribute: :attr:`tb_next` is the next level in the stack "
"trace (towards the frame where the exception occurred), or ``None`` if there "
"is no next level."
msgstr ""
"Attributs spéciaux en lecture-écriture :attr:`tb_next` est le niveau suivant "
"dans la pile d'exécution (en direction du cadre où l'exception a eu lieu) ou "
"``None`` s'il n'y a pas de niveau suivant."

#: reference/datamodel.rst:1100
msgid ""
"Traceback objects can now be explicitly instantiated from Python code, and "
"the ``tb_next`` attribute of existing instances can be updated."
msgstr ""
"Les objets de traces d'appels peuvent maintenant être explicitement "
"instanciés depuis le code Python et l'attribut ``tb_next`` des instances "
"existantes peut être mis à jour."

#: reference/datamodel.rst:1128
msgid "Slice objects"
msgstr "Objets tranches"

#: reference/datamodel.rst:1107
msgid ""
"Slice objects are used to represent slices for :meth:`__getitem__` methods.  "
"They are also created by the built-in :func:`slice` function."
msgstr ""
"Un objet tranche est utilisé pour représenter des découpes des méthodes :"
"meth:`__getitem__`. Ils sont aussi créés par la fonction native :func:"
"`slice`."

#: reference/datamodel.rst:1115
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"Attributs spéciaux en lecture seule : :attr:`~decoupe.start` est la borne "
"inférieure ; :attr:`~decoupe.stop` est la borne supérieure ; :attr:`~decoupe."
"step` est la valeur du pas ; chaque attribut vaut ``None`` s'il est omis. "
"Ces attributs peuvent être de n'importe quel type."

#: reference/datamodel.rst:1119
msgid "Slice objects support one method:"
msgstr "Les objets tranches comprennent une méthode :"

#: reference/datamodel.rst:1123
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"Cette méthode prend un argument entier *length* et calcule les informations "
"de la tranche que l'objet découpe décrit s'il est appliqué à une séquence de "
"*length* éléments. Elle renvoie un triplet d'entiers ; respectivement, ce "
"sont les indices de *début* et *fin* ainsi que le *pas* de découpe. Les "
"indices manquants ou en dehors sont gérés de manière cohérente avec les "
"tranches normales."

#: reference/datamodel.rst:1138
msgid "Static method objects"
msgstr "Objets méthodes statiques"

#: reference/datamodel.rst:1131
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are not themselves "
"callable, although the objects they wrap usually are. Static method objects "
"are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"Les objets méthodes statiques permettent la transformation des objets "
"fonctions en objets méthodes décrits au-dessus. Un objet méthode statique "
"encapsule tout autre objet, souvent un objet méthode définie par "
"l'utilisateur. Quand un objet méthode statique est récupéré depuis une "
"classe ou une instance de classe, l'objet réellement renvoyé est un objet "
"encapsulé, qui n'a pas vocation à être transformé encore une fois. Les "
"objets méthodes statiques ne sont pas appelables en tant que tels, bien que "
"les objets qu'ils encapsulent le soient souvent. Les objets méthodes "
"statiques sont créés par le constructeur natif :func:`staticmethod`."

#: reference/datamodel.rst:1146
msgid "Class method objects"
msgstr "Objets méthodes de classes"

#: reference/datamodel.rst:1141
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr ""
"Un objet méthode de classe, comme un objet méthode statique, encapsule un "
"autre objet afin de modifier la façon dont cet objet est récupéré depuis les "
"classes et instances de classes. Le comportement des objets méthodes de "
"classes dans le cas d'une telle récupération est décrit plus haut, dans "
"« méthodes définies par l'utilisateur ». Les objets méthodes de classes sont "
"créés par le constructeur natif :func:`classmethod`."

#: reference/datamodel.rst:1151
msgid "Special method names"
msgstr "Méthodes spéciales"

#: reference/datamodel.rst:1157
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` is "
"roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""
"Une classe peut implémenter certaines opérations que l'on invoque par une "
"syntaxe spéciale (telles que les opérations arithmétiques ou la découpe en "
"tranches) en définissant des méthodes aux noms particuliers. C'est "
"l'approche utilisée par Python pour la :dfn:`surcharge d'opérateur`, "
"permettant à une classe de définir son propre comportement vis-à-vis des "
"opérateurs du langage. Par exemple, si une classe définit une méthode :meth:"
"`__getitem__` et que ``x`` est une instance de cette classe, alors ``x[i]`` "
"est globalement équivalent à ``type(x).__getitem__(x, i)``. Sauf lorsque "
"c'est mentionné, toute tentative d'appliquer une opération alors que la "
"méthode appropriée n'est pas définie lève une exception (typiquement :exc:"
"`AttributeError` ou :exc:`TypeError`)."

#: reference/datamodel.rst:1167
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets :meth:`__iter__` "
"to ``None``, the class is not iterable, so calling :func:`iter` on its "
"instances will raise a :exc:`TypeError` (without falling back to :meth:"
"`__getitem__`). [#]_"
msgstr ""
"Définir une méthode spéciale à ``None`` indique que l'opération "
"correspondante n'est pas disponible. Par exemple, si une classe assigne "
"``None`` à :meth:`__iter__`, vous ne pouvez pas itérer sur la classe et "
"appeler :func:`iter` sur une instance lève :exc:`TypeError` (sans se replier "
"sur :meth:`__getitem__`) [#]_."

#: reference/datamodel.rst:1173
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""
"Lorsque vous implémentez une classe qui émule un type natif, il est "
"important que cette émulation n'implémente que ce qui fait sens pour l'objet "
"qui est modélisé. Par exemple, la recherche d'éléments individuels d'une "
"séquence peut faire sens, mais pas l'extraction d'une tranche (un exemple "
"est l'interface de :class:`~xml.dom.NodeList` dans le modèle objet des "
"documents W3C)."

#: reference/datamodel.rst:1184
msgid "Basic customization"
msgstr "Personnalisation de base"

#: reference/datamodel.rst:1190
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"Appelée pour créer une nouvelle instance de la classe *cls*. La méthode :"
"meth:`__new__` est statique (c'est un cas particulier, vous n'avez pas "
"besoin de la déclarer comme telle) qui prend comme premier argument la "
"classe pour laquelle on veut créer une instance. Les autres arguments sont "
"ceux passés à l'expression de l'objet constructeur (l'appel à la classe). La "
"valeur de retour de :meth:`__new__` doit être l'instance du nouvel objet "
"(classiquement une instance de *cls*)."

#: reference/datamodel.rst:1197
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly-created instance as "
"necessary before returning it."
msgstr ""
"Une implémentation typique crée une nouvelle instance de la classe en "
"invoquant la méthode :meth:`__new__` de la superclasse à l'aide de ``super()."
"__new__(cls[, ...])`` avec les arguments adéquats, puis modifie l'instance "
"nouvellement créée en tant que de besoin avant de la renvoyer."

#: reference/datamodel.rst:1202
msgid ""
"If :meth:`__new__` is invoked during object construction and it returns an "
"instance or subclass of *cls*, then the new instance’s :meth:`__init__` "
"method will be invoked like ``__init__(self[, ...])``, where *self* is the "
"new instance and the remaining arguments are the same as were passed to the "
"object constructor."
msgstr ""
"Si :meth:`__new__` est appelée pendant la construction de l'objet et renvoie "
"une instance de *cls* ou d'une de ses sous-classes, alors la méthode :meth:"
"`__init__` de la nouvelle instance est invoquée avec "
"``__init__(self[, ...])`` où *self* est la nouvelle instance et les autres "
"arguments sont les mêmes que ceux passés au constructeur de l'objet."

#: reference/datamodel.rst:1207
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"Si :meth:`__new__` ne renvoie pas une instance de *cls*, alors la méthode :"
"meth:`__init__` de la nouvelle instance n'est pas invoquée."

#: reference/datamodel.rst:1210
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
"L'objectif de :meth:`__new__` est principalement, pour les sous-classes de "
"types immuables (comme ``int``, ``str`` ou ``tuple``), d'autoriser la "
"création sur mesure des instances. Elle est aussi souvent surchargée dans "
"les méta-classes pour particulariser la création des classes."

#: reference/datamodel.rst:1219
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"Appelée après la création de l'instance (par :meth:`__new__`), mais avant le "
"retour vers l'appelant. Les arguments sont ceux passés à l'expression du "
"constructeur de classe. Si une classe de base possède une méthode :meth:"
"`__init__`, la méthode :meth:`__init__` de la classe dérivée, si elle "
"existe, doit explicitement appeler cette méthode pour assurer une "
"initialisation correcte de la partie classe de base de l'instance ; par "
"exemple : ``super().__init__([args...])``."

#: reference/datamodel.rst:1226
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
"Comme :meth:`__new__` et :meth:`__init__` travaillent ensemble pour créer "
"des objets (:meth:`__new__` pour le créer, :meth:`__init__` pour le "
"particulariser), :meth:`__init__` ne doit pas renvoyer de valeur ``None`` ; "
"sinon une exception :exc:`TypeError` est levée à l'exécution."

#: reference/datamodel.rst:1239
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has a :meth:"
"`__del__` method, the derived class's :meth:`__del__` method, if any, must "
"explicitly call it to ensure proper deletion of the base class part of the "
"instance."
msgstr ""
"Appelée au moment où une instance est sur le point d'être détruite. On "
"l'appelle aussi finaliseur ou (improprement) destructeur. Si une classe de "
"base possède une méthode :meth:`__del__`, la méthode :meth:`__del__` de la "
"classe dérivée, si elle existe, doit explicitement l'appeler pour s'assurer "
"de l'effacement correct de la partie classe de base de l'instance."

#: reference/datamodel.rst:1245
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is "
"about to be destroyed; the current :term:`CPython` implementation only calls "
"it once."
msgstr ""
"Il est possible (mais pas recommandé) que la méthode :meth:`__del__` retarde "
"la destruction de l'instance en créant une nouvelle référence vers cet "
"objet. Python appelle ceci la *résurrection* d'objet. En fonction de "
"l'implémentation, :meth:`__del__` peut être appelée une deuxième fois au "
"moment où l'objet ressuscité va être détruit ; l'implémentation actuelle de :"
"term:`CPython` ne l'appelle qu'une fois."

#: reference/datamodel.rst:1252
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits."
msgstr ""
"Il n'est pas garanti que soient appelées les méthodes :meth:`__del__` des "
"objets qui existent toujours quand l'interpréteur termine."

#: reference/datamodel.rst:1257
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` n'appelle pas directement ``x.__del__()`` — la première décrémente "
"le compteur de références de ``x``. La seconde n'est appelée que quand le "
"compteur de références de ``x`` atteint zéro."

#: reference/datamodel.rst:1272
msgid "Documentation for the :mod:`gc` module."
msgstr "Documentation du module :mod:`gc`."

#: reference/datamodel.rst:1276
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
"En raison des conditions particulières qui règnent quand :meth:`__del__` est "
"appelée, les exceptions levées pendant son exécution sont ignorées et, à la "
"place, un avertissement est affiché sur ``sys.stderr``. En particulier :"

#: reference/datamodel.rst:1280
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to execute :meth:"
"`__del__`."
msgstr ""
":meth:`__del__` peut être invoquée quand du code arbitraire est en cours "
"d'exécution, et ce dans n'importe quel fil d'exécution. Si :meth:`__del__` a "
"besoin de poser un verrou ou d'accéder à tout autre ressource bloquante, "
"elle peut provoquer un blocage mutuel (*deadlock* en anglais) car la "
"ressource peut être déjà utilisée par le code qui est interrompu pour "
"exécuter la méthode :meth:`__del__`."

#: reference/datamodel.rst:1286
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees "
"that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""
":meth:`__del__` peut être exécutée pendant que l'interpréteur se ferme. En "
"conséquence, les variables globales auxquelles elle souhaite accéder (y "
"compris les autres modules) peuvent déjà être détruites ou assignées à "
"``None``. Python garantit que les variables globales dont le nom commence "
"par un tiret bas sont supprimées de leur module avant que les autres "
"variables globales ne le soient ; si aucune autre référence vers ces "
"variables globales n'existe, cela peut aider à s'assurer que les modules "
"importés soient toujours accessibles au moment où la méthode :meth:`__del__` "
"est appelée."

#: reference/datamodel.rst:1301
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with "
"the same value (given an appropriate environment).  If this is not possible, "
"a string of the form ``<...some useful description...>`` should be returned. "
"The return value must be a string object. If a class defines :meth:"
"`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when "
"an \"informal\" string representation of instances of that class is required."
msgstr ""
"Appelée par la fonction native :func:`repr` pour calculer la représentation "
"« officielle » en chaîne de caractères d'un objet. Tout est fait pour que "
"celle-ci ressemble à une expression Python valide pouvant être utilisée pour "
"recréer un objet avec la même valeur (dans un environnement donné). Si ce "
"n'est pas possible, une chaîne de la forme ``<...une description utile...>`` "
"est renvoyée. La valeur renvoyée doit être un objet chaîne de caractères. Si "
"une classe définit :meth:`__repr__` mais pas :meth:`__str__`, alors :meth:"
"`__repr__` est aussi utilisée quand une représentation « informelle » en "
"chaîne de caractères est demandée pour une instance de cette classe."

#: reference/datamodel.rst:1310
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr ""
"Cette fonction est principalement utilisée à fins de débogage, il est donc "
"important que la représentation donne beaucoup d'informations et ne soit pas "
"ambigüe."

#: reference/datamodel.rst:1321
msgid ""
"Called by :func:`str(object) <str>` and the built-in functions :func:"
"`format` and :func:`print` to compute the \"informal\" or nicely printable "
"string representation of an object.  The return value must be a :ref:`string "
"<textseq>` object."
msgstr ""
"Appelée par :func:`str(objet)<str>` ainsi que les fonctions natives :func:"
"`format` et :func:`print` pour calculer une chaîne de caractères "
"« informelle » ou joliment mise en forme de représentation de l'objet. La "
"valeur renvoyée doit être un objet :ref:`string <textseq>`."

#: reference/datamodel.rst:1326
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
"Cette méthode diffère de :meth:`object.__repr__` car il n'est pas attendu "
"que :meth:`__str__` renvoie une expression Python valide : une "
"représentation plus agréable à lire ou plus concise peut être utilisée."

#: reference/datamodel.rst:1330
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"C'est l'implémentation par défaut des appels à :meth:`object.__repr__` du "
"type natif :class:`object`."

#: reference/datamodel.rst:1340
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object."
msgstr ""
"Appelée par :ref:`bytes <func-bytes>` pour calculer une représentation en "
"chaîne *bytes* d'un objet. Elle doit renvoyer un objet :class:`bytes`."

#: reference/datamodel.rst:1351
msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation "
"of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"*format_spec* argument is a string that contains a description of the "
"formatting options desired. The interpretation of the *format_spec* argument "
"is up to the type implementing :meth:`__format__`, however most classes will "
"either delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
"Appelée par la fonction native :func:`format` et, par extension, lors de "
"l'évaluation de :ref:`formatted string literals <f-strings>` et la méthode :"
"meth:`str.format`. Elle produit une chaîne de caractères « formatée » "
"représentant un objet. L'argument ``format_spec`` est une chaîne de "
"caractères contenant la description des options de formatage voulues. "
"L'interprétation de l'argument ``format_spec`` est laissée au type "
"implémentant :meth:`__format__`. Cependant, la plupart des classes délèguent "
"le formatage aux types natifs ou utilisent une syntaxe similaire d'options "
"de formatage."

#: reference/datamodel.rst:1361
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""
"Lisez :ref:`formatspec` pour une description de la syntaxe standard du "
"formatage."

#: reference/datamodel.rst:1363
msgid "The return value must be a string object."
msgstr "La valeur renvoyée doit être un objet chaîne de caractères."

#: reference/datamodel.rst:1365
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"La méthode ``__format__`` de ``object`` lui-même lève une :exc:`TypeError` "
"si vous lui passez une chaîne non vide."

#: reference/datamodel.rst:1369
#, fuzzy
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(x), '')``."
msgstr ""
"``object.__format__(x, '')`` est maintenant équivalent à ``str(x)`` plutôt "
"qu'à ``format(str(self), '')``."

#: reference/datamodel.rst:1385
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls ``x."
"__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, "
"``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` "
"calls ``x.__ge__(y)``."
msgstr ""
"Ce sont les méthodes dites de « comparaisons riches ». La correspondance "
"entre les symboles opérateurs et les noms de méthodes est la suivante : "
"``x<y`` appelle ``x.__lt__(y)``, ``x<=y`` appelle ``x.__le__(y)``, ``x==y`` "
"appelle ``x.__eq__(y)``, ``x!=y`` appelle ``x.__ne__(y)``, ``x>y`` appelle "
"``x.__gt__(y)`` et ``x>=y`` appelle ``x.__ge__(y)``."

#: reference/datamodel.rst:1391
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"Une méthode de comparaison riche peut renvoyer le singleton "
"``NotImplemented`` si elle n'implémente pas l'opération pour une paire "
"donnée d'arguments. Par convention, ``False`` et ``True`` sont renvoyées "
"pour une comparaison qui a réussi. Cependant, ces méthodes peuvent renvoyer "
"n'importe quelle valeur donc, si l'opérateur de comparaison est utilisé dans "
"un contexte booléen (par exemple dans une condition d'une instruction "
"``if``), Python appelle :func:`bool` sur la valeur pour déterminer si le "
"résultat est faux ou vrai."

#: reference/datamodel.rst:1398
#, fuzzy
msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, returning "
"``NotImplemented`` in the case of a false comparison: ``True if x is y else "
"NotImplemented``. For :meth:`__ne__`, by default it delegates to :meth:"
"`__eq__` and inverts the result unless it is ``NotImplemented``.  There are "
"no other implied relationships among the comparison operators or default "
"implementations; for example, the truth of ``(x<y or x==y)`` does not imply "
"``x<=y``. To automatically generate ordering operations from a single root "
"operation, see :func:`functools.total_ordering`."
msgstr ""
"Par défaut, :meth:`__ne__` délègue à :meth:`__eq__` et renvoie le résultat "
"inverse, sauf si c'est ``NotImplemented``. Il n'y a pas d'autres relations "
"implicites pour les opérateurs de comparaison. Par exemple, ``(x<y or "
"x==y)`` n'implique pas ``x<=y``. Pour obtenir une relation d'ordre total "
"automatique à partir d'une seule opération, reportez-vous à :func:`functools."
"total_ordering`."

#: reference/datamodel.rst:1407
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating :"
"term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr ""
"Lisez le paragraphe :meth:`__hash__` pour connaître certaines notions "
"importantes relatives à la création d'objets :term:`hashable` qui acceptent "
"les opérations de comparaison personnalisées et qui sont utilisables en tant "
"que clés de dictionnaires."

#: reference/datamodel.rst:1411
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection. If the operands are of "
"different types, and right operand's type is a direct or indirect subclass "
"of the left operand's type, the reflected method of the right operand has "
"priority, otherwise the left operand's method has priority.  Virtual "
"subclassing is not considered."
msgstr ""
"Il n'y a pas de versions avec les arguments interchangés de ces "
"méthodes (qui seraient utilisées quand l'argument de gauche ne connaît pas "
"l'opération alors que l'argument de droite la connaît) ; en lieu et place, :"
"meth:`__lt__` et :meth:`__gt__` sont la réflexion l'une de l'autre, :meth:"
"`__le__` et :meth:`__ge__` sont la réflexion l'une de l'autre et :meth:"
"`__eq__` ainsi que :meth:`__ne__` sont réflexives. Si les opérandes sont de "
"types différents et que l'opérande de droite est d'un type qui une sous-"
"classe directe ou indirecte du type de l'opérande de gauche, alors la "
"méthode symétrique de l'opérande de droite est prioritaire, sinon c'est la "
"méthode de l'opérande de gauche qui est prioritaire. Les sous-classes "
"virtuelles ne sont pas prises en compte."

#: reference/datamodel.rst:1428
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  :meth:`__hash__` should return an integer. The only required "
"property is that objects which compare equal have the same hash value; it is "
"advised to mix together the hash values of the components of the object that "
"also play a part in comparison of objects by packing them into a tuple and "
"hashing the tuple. Example::"
msgstr ""
"Appelée par la fonction native :func:`hash` et par les opérations sur les "
"membres de collections hachées (ce qui comprend :class:`set`, :class:"
"`frozenset` et :class:`dict`). :meth:`__hash__` doit renvoyer un entier. La "
"seule propriété requise est que les objets qui sont égaux pour la "
"comparaison doivent avoir la même valeur de hachage ; il est conseillé de "
"mélanger les valeurs de hachage des composants d'un objet qui jouent un rôle "
"de la comparaison des objets, en les plaçant dans un *n*-uplet dont on "
"calcule l'empreinte. Par exemple ::"

#: reference/datamodel.rst:1441
msgid ""
":func:`hash` truncates the value returned from an object's custom :meth:"
"`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is typically "
"8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an object's   :"
"meth:`__hash__` must interoperate on builds of different bit sizes, be sure "
"to check the width on all supported builds.  An easy way to do this is with "
"``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` limite la valeur renvoyée d'un objet ayant une méthode :meth:"
"`__hash__` personnalisée à la taille d'un :c:type:`Py_ssize_t`. C'est "
"classiquement 8 octets pour une implémentation 64 bits et 4 octets sur une "
"implémentation 32 bits. Si la méthode :meth:`__hash__` d'un objet doit être "
"interopérable sur des plateformes ayant des implémentations différentes, "
"assurez-vous de vérifier la taille du hachage sur toutes les plateformes. "
"Une manière facile de le faire est la suivante : ``python -c \"import sys; "
"print(sys.hash_info.width)\"``."

#: reference/datamodel.rst:1449
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a :"
"meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:"
"`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an :meth:"
"`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of hashable collections requires that a key's hash value is "
"immutable (if the object's hash value changes, it will be in the wrong hash "
"bucket)."
msgstr ""
"Si une classe ne définit pas de méthode :meth:`__eq__`, elle ne doit pas "
"définir l'opération :meth:`__hash__` non plus ; si elle définit :meth:"
"`__eq__` mais pas :meth:`__hash__`, les instances ne peuvent pas être "
"utilisées en tant qu'élément dans une collection de hachables. Si une classe "
"définit des objets mutables et implémente la méthode :meth:`__eq__`, elle ne "
"doit pas implémenter :meth:`__hash__` puisque l'implémentation des "
"collections hachables requiert que les clés soient des empreintes immuables "
"(si l'empreinte d'un objet change, il ne sera plus trouvé correctement dans "
"le stockage du dictionnaire)."

#: reference/datamodel.rst:1458
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and "
"``x.__hash__()`` returns an appropriate value such that ``x == y`` implies "
"both that ``x is y`` and ``hash(x) == hash(y)``."
msgstr ""
"Les classes définies par l'utilisateur possèdent des méthodes :meth:`__eq__` "
"et :meth:`__hash__` par défaut ; ces méthodes répondent que tous les objets "
"sont différents (sauf avec eux-mêmes) et ``x.__hash__()`` renvoie une valeur "
"telle que ``x == y`` implique à la fois ``x is y`` et ``hash(x) == hash(y)``."

#: reference/datamodel.rst:1463
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the :meth:"
"`__hash__` method of a class is ``None``, instances of the class will raise "
"an appropriate :exc:`TypeError` when a program attempts to retrieve their "
"hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.abc.Hashable)``."
msgstr ""
"Une classe qui surcharge :meth:`__eq__` et qui ne définit pas :meth:"
"`__hash__` a sa méthode :meth:`__hash__` implicitement assignée à ``None``. "
"Quand la méthode :meth:`__hash__` d'une classe est ``None``, une instance de "
"cette classe lève :exc:`TypeError` quand un programme essaie de demander son "
"empreinte et elle est correctement identifiée comme *non hachable* quand on "
"vérifie ``isinstance(obj, collections.abc.Hashable)``."

#: reference/datamodel.rst:1470
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
"Si une classe qui surcharge :meth:`__eq__` a besoin de conserver "
"l'implémentation de :meth:`__hash__` de la classe parente, vous devez "
"l'indiquer explicitement à l'interpréteur en définissant ``__hash__ = "
"<ClasseParente>.__hash__``."

#: reference/datamodel.rst:1474
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a :exc:"
"`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
"Si une classe ne surcharge pas :meth:`__eq__` et veut supprimer le calcul "
"des empreintes, elle doit inclure ``__hash__ = None`` dans la définition de "
"la classe. Une classe qui définit sa propre méthode :meth:`__hash__` qui "
"lève explicitement :exc:`TypeError` serait incorrectement identifiée comme "
"hachable par un appel à ``isinstance(obj, collections.abc.Hashable)``."

#: reference/datamodel.rst:1483
msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are \"salted"
"\" with an unpredictable random value.  Although they remain constant within "
"an individual Python process, they are not predictable between repeated "
"invocations of Python."
msgstr ""
"Par défaut, les valeurs renvoyées par :meth:`__hash__` pour les chaînes et "
"les *bytes* sont « salées » avec une valeur aléatoire non prévisible. Bien "
"qu'une empreinte reste constante tout au long d'un processus Python, sa "
"valeur n'est pas prévisible entre deux invocations de Python."

#: reference/datamodel.rst:1488
msgid ""
"This is intended to provide protection against a denial-of-service caused by "
"carefully-chosen inputs that exploit the worst case performance of a dict "
"insertion, O(n^2) complexity.  See http://www.ocert.org/advisories/"
"ocert-2011-003.html for details."
msgstr ""
"C'est un comportement voulu pour se protéger contre un déni de service qui "
"utiliserait des entrées malicieusement choisies pour effectuer des "
"insertions dans le dictionnaire dans le pire cas, avec une complexité en "
"O(n^2). Lisez http://www.ocert.org/advisories/ocert-2011-003.html pour en "
"obtenir les détails (article en anglais)."

#: reference/datamodel.rst:1493
msgid ""
"Changing hash values affects the iteration order of sets. Python has never "
"made guarantees about this ordering (and it typically varies between 32-bit "
"and 64-bit builds)."
msgstr ""
"Modifier les empreintes obtenues par hachage modifie l'ordre d'itération sur "
"les *sets*. Python n'a jamais donné de garantie sur cet ordre (d'ailleurs, "
"l'ordre n'est pas le même entre les implémentations 32 et 64 bits)."

#: reference/datamodel.rst:1497
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr "Voir aussi :envvar:`PYTHONHASHSEED`."

#: reference/datamodel.rst:1499
msgid "Hash randomization is enabled by default."
msgstr "la randomisation des empreintes est activée par défaut."

#: reference/datamodel.rst:1507
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`__len__` is called, if it is defined, and the object is "
"considered true if its result is nonzero.  If a class defines neither :meth:"
"`__len__` nor :meth:`__bool__`, all its instances are considered true."
msgstr ""
"Appelée pour implémenter les tests booléens et l'opération native "
"``bool()`` ; elle doit renvoyer ``False`` ou ``True``. Quand cette méthode "
"n'est pas définie, :meth:`__len__` est appelée, si elle est définie, et "
"l'objet est considéré vrai si le résultat est non nul. Si une classe ne "
"définit ni :meth:`__len__` ni :meth:`__bool__`, toutes ses instances sont "
"considérées comme vraies."

#: reference/datamodel.rst:1518
msgid "Customizing attribute access"
msgstr "Personnalisation de l'accès aux attributs"

#: reference/datamodel.rst:1520
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"Les méthodes suivantes peuvent être définies pour personnaliser l'accès aux "
"attributs (utilisation, assignation, suppression de ``x.name``) pour les "
"instances de classes."

#: reference/datamodel.rst:1528
msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError` "
"(either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property raises :exc:"
"`AttributeError`).  This method should either return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception."
msgstr ""
"Appelée lorsque l'accès par défaut à l'attribut échoue en levant :exc:"
"`AttributeError` (soit :meth:`__getattribute__` lève :exc:`AttributeError` "
"car *name* n'est pas un attribut de l'instance ou un attribut dans "
"l'arborescence de la classe de ``self`` ; ou :meth:`__get__` de la propriété "
"*name* lève :exc:`AttributeError`). Cette méthode doit retourner soit la "
"valeur (calculée) de l'attribut, soit lever une exception :exc:"
"`AttributeError`."

#: reference/datamodel.rst:1535
msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""
"Notez que si l'attribut est trouvé par le mécanisme normal, :meth:"
"`__getattr__` n'est pas appelée (c'est une asymétrie voulue entre :meth:"
"`__getattr__` et :meth:`__setattr__`). Ce comportement est adopté à la fois "
"pour des raisons de performance et parce que, sinon, :meth:`__getattr__` "
"n'aurait aucun moyen d'accéder aux autres attributs de l'instance. Notez "
"que, au moins pour ce qui concerne les variables d'instance, vous pouvez "
"simuler un contrôle total en n'insérant aucune valeur dans le dictionnaire "
"des attributs de l'instance (mais en les insérant dans un autre objet à la "
"place). Lisez la partie relative à la méthode :meth:`__getattribute__` ci-"
"dessous pour obtenir un contrôle total effectif sur l'accès aux attributs."

#: reference/datamodel.rst:1548
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""
"Appelée de manière inconditionnelle pour implémenter l'accès aux attributs "
"des instances de la classe. Si la classe définit également :meth:"
"`__getattr__`, cette dernière n'est pas appelée à moins que :meth:"
"`__getattribute__` ne l'appelle explicitement ou ne lève une exception :exc:"
"`AttributeError`. Cette méthode doit renvoyer la valeur (calculée) de "
"l'attribut ou lever une exception :exc:`AttributeError`. Afin d'éviter une "
"récursion infinie sur cette méthode, son implémentation doit toujours "
"appeler la méthode de la classe de base avec le même paramètre *name* pour "
"accéder à n'importe quel attribut dont elle a besoin. Par exemple, ``object."
"__getattribute__(self, name)``."

#: reference/datamodel.rst:1559
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`special-lookup`."
msgstr ""
"Cette méthode peut être shuntée lorsque la recherche porte sur les méthodes "
"spéciales en tant que résultat d'une invocation implicite *via* la syntaxe "
"du langage ou les fonctions natives. Lisez :ref:`special-lookup`."

#: reference/datamodel.rst:None
msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__getattr__`` with "
"arguments ``obj``, ``name``."
msgstr ""

#: reference/datamodel.rst:1565
msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""

#: reference/datamodel.rst:1572
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"Appelée lors d'une assignation d'attribut. Elle est appelée à la place du "
"mécanisme normal (c'est-à-dire stocker la valeur dans le dictionnaire de "
"l'instance). *name* est le nom de l'attribut, *value* est la valeur à "
"assigner à cet attribut."

#: reference/datamodel.rst:1576
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""
"Si :meth:`__setattr__` veut assigner un attribut d'instance, elle doit "
"appeler la méthode de la classe de base avec le même nom, par exemple "
"``object.__setattr__(self, name, value)``."

#: reference/datamodel.rst:None
msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__setattr__`` with "
"arguments ``obj``, ``name``, ``value``."
msgstr ""

#: reference/datamodel.rst:1582
msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing event "
"<auditing>` ``object.__setattr__`` with arguments ``obj``, ``name``, "
"``value``."
msgstr ""

#: reference/datamodel.rst:1589
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
"Comme :meth:`__setattr__` mais pour supprimer un attribut au lieu de "
"l'assigner. Elle ne doit être implémentée que si ``del obj.name`` a du sens "
"pour cet objet."

#: reference/datamodel.rst:None
msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__delattr__`` with "
"arguments ``obj``, ``name``."
msgstr ""

#: reference/datamodel.rst:1594
msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event "
"<auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""

#: reference/datamodel.rst:1601
msgid ""
"Called when :func:`dir` is called on the object. A sequence must be "
"returned. :func:`dir` converts the returned sequence to a list and sorts it."
msgstr ""
"Appelée quand :func:`dir` est appelée sur l'objet. Elle doit renvoyer une "
"séquence. :func:`dir` convertit la séquence renvoyée en liste et effectue le "
"classement."

#: reference/datamodel.rst:1606
msgid "Customizing module attribute access"
msgstr "Personnalisation de l'accès aux attributs d'un module"

#: reference/datamodel.rst:1613
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to customize "
"access to module attributes. The ``__getattr__`` function at the module "
"level should accept one argument which is the name of an attribute and "
"return the computed value or raise an :exc:`AttributeError`. If an attribute "
"is not found on a module object through the normal lookup, i.e. :meth:"
"`object.__getattribute__`, then ``__getattr__`` is searched in the module "
"``__dict__`` before raising an :exc:`AttributeError`. If found, it is called "
"with the attribute name and the result is returned."
msgstr ""
"Les noms spéciaux ``__getattr__`` et ``__dir__`` peuvent aussi être "
"personnalisés pour accéder aux attributs du module. La fonction "
"``__getattr__`` au niveau du module doit accepter un argument qui est un nom "
"d'attribut et doit renvoyer la valeur calculée ou lever une :exc:"
"`AttributeError`. Si un attribut n'est pas trouvé dans l'objet module en "
"utilisant la recherche normale, c'est-à-dire :meth:`object."
"__getattribute__`, alors Python recherche ``__getattr__`` dans le "
"``__dict__`` du module avant de lever une :exc:`AttributeError`. S'il la "
"trouve, il l'appelle avec le nom de l'attribut et renvoie le résultat."

#: reference/datamodel.rst:1622
msgid ""
"The ``__dir__`` function should accept no arguments, and return a sequence "
"of strings that represents the names accessible on module. If present, this "
"function overrides the standard :func:`dir` search on a module."
msgstr ""
"La fonction ``__dir__`` ne prend aucun argument et renvoie une séquence de "
"chaînes qui représente les noms accessibles du module. Si elle existe, cette "
"fonction surcharge la fonction de recherche standard :func:`dir` du module."

#: reference/datamodel.rst:1626
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"Pour une personnalisation plus fine du comportement d'un module (assignation "
"des attributs, propriétés, etc.), vous pouvez assigner l'attribut "
"``__class__`` d'un objet module à une sous-classe de :class:`types."
"ModuleType`. Par exemple ::"

#: reference/datamodel.rst:1644
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only affect "
"lookups made using the attribute access syntax -- directly accessing the "
"module globals (whether by code within the module, or via a reference to the "
"module's globals dictionary) is unaffected."
msgstr ""
"Définir ``__getattr__`` du module et ``__class__`` pour le module affecte "
"uniquement les recherches qui utilisent la syntaxe d'accès aux attributs — "
"accéder directement aux globales d'un module (soit par le code dans le "
"module, soit *via* une référence au dictionnaire des variables globales du "
"module) fonctionne toujours de la même façon."

#: reference/datamodel.rst:1649
msgid "``__class__`` module attribute is now writable."
msgstr "l'attribut ``__class__`` du module est maintenant en lecture-écriture."

#: reference/datamodel.rst:1652
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "attributs ``__getattr__`` et ``__dir__`` du module."

#: reference/datamodel.rst:1657
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` — ``__getattr__`` et ``__dir__`` pour un module"

#: reference/datamodel.rst:1658
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "Décrit les fonctions ``__getattr__`` et ``__dir__`` des modules."

#: reference/datamodel.rst:1664
msgid "Implementing Descriptors"
msgstr "Implémentation de descripteurs"

#: reference/datamodel.rst:1666
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the attribute"
"\" refers to the attribute whose name is the key of the property in the "
"owner class' :attr:`~object.__dict__`."
msgstr ""
"Les méthodes qui suivent s'appliquent seulement quand une instance de la "
"classe (dite classe *descripteur*) contenant la méthode apparaît dans une "
"classe *propriétaire* (*owner* en anglais) ; la classe descripteur doit "
"figurer dans le dictionnaire de la classe propriétaire ou dans le "
"dictionnaire de la classe d'un des parents. Dans les exemples ci-dessous, "
"« l'attribut » fait référence à l'attribut dont le nom est une clé du :attr:"
"`~object.__dict__` de la classe propriétaire."

#: reference/datamodel.rst:1676
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). The optional "
"*owner* argument is the owner class, while *instance* is the instance that "
"the attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*."
msgstr ""
"Appelée pour obtenir l'attribut de la classe propriétaire (accès à un "
"attribut de classe) ou d'une instance de cette classe (accès à un attribut "
"d'instance). L'argument optionnel *owner* est la classe propriétaire alors "
"que *instance* est l'instance par laquelle on accède à l'attribut ou "
"``None`` lorsque l'on accède par la classe *owner*."

#: reference/datamodel.rst:1682
msgid ""
"This method should return the computed attribute value or raise an :exc:"
"`AttributeError` exception."
msgstr ""
"Il convient que cette méthode renvoie la valeur calculée de l'attribut ou "
"lève une exception :exc:`AttributeError`."

#: reference/datamodel.rst:1685
msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification; "
"however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required or "
"not."
msgstr ""
"La :pep:`252` spécifie que :meth:`__get__` soit un appelable avec un ou deux "
"arguments. Les descripteurs natifs de Python suivent cette spécification ; "
"cependant, il est probable que des outils tiers aient des descripteurs qui "
"requièrent les deux arguments. L'implémentation de :meth:`__getattribute__` "
"de Python passe toujours les deux arguments, qu'ils soient requis ou non."

#: reference/datamodel.rst:1694
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""
"Appelée pour définir l'attribut d'une instance *instance* de la classe "
"propriétaire à la nouvelle valeur *value*."

#: reference/datamodel.rst:1697
msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` for "
"more details."
msgstr ""
"Notez que ajouter :meth:`__set__` ou :meth:`__delete__` modifie la nature du "
"descripteur vers un « descripteur de donnée ». Reportez-vous à :ref:"
"`descriptor-invocation` pour plus de détails."

#: reference/datamodel.rst:1703
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"Appelée pour supprimer l'attribut de l'instance *instance* de la classe "
"propriétaire."

#: reference/datamodel.rst:1708
msgid ""
"Called at the time the owning class *owner* is created. The descriptor has "
"been assigned to *name*."
msgstr ""
"Appelée au moment où la classe propriétaire *owner* est créée. La classe "
"descripteur a été assignée à *name*."

#: reference/datamodel.rst:1713
msgid ""
":meth:`__set_name__` is only called implicitly as part of the :class:`type` "
"constructor, so it will need to be called explicitly with the appropriate "
"parameters when a descriptor is added to a class after initial creation::"
msgstr ""
":meth:`__set_name__` n'est appelée implicitement que par le constructeur de :"
"class:`type`, vous devez donc l'appeler explicitement avec les paramètres "
"adéquats quand un descripteur est ajouté à une classe après sa création ::"

#: reference/datamodel.rst:1724
msgid "See :ref:`class-object-creation` for more details."
msgstr "Consultez :ref:`class-object-creation` pour davantage de détails."

#: reference/datamodel.rst:1728
msgid ""
"The attribute :attr:`__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""
"L'attribut :attr:`__objclass__` est interprété par le module :mod:`inspect` "
"comme spécifiant la classe où cet objet a été défini (le définir "
"correctement peut vous aider dans l'introspection des classes dynamiques à "
"l'exécution). Pour les appelables, cela peut indiquer qu'une instance d'un "
"certain type (ou d'une certaine sous-classe) est attendue ou requise comme "
"premier argument positionnel (par exemple, CPython définit cet attribut pour "
"les méthodes non liées qui sont implémentées en C)."

#: reference/datamodel.rst:1739
msgid "Invoking Descriptors"
msgstr "Invocation des descripteurs"

#: reference/datamodel.rst:1741
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any "
"of those methods are defined for an object, it is said to be a descriptor."
msgstr ""
"En général, un descripteur est un attribut d'objet dont le comportement est "
"« lié » (*binding dehavior* en anglais), c'est-à-dire que les accès aux "
"attributs ont été surchargés par des méthodes conformes au protocole des "
"descripteurs : :meth:`__get__`, :meth:`__set__` et :meth:`__delete__`. Si "
"l'une de ces méthodes est définie pour un objet, il est réputé être un "
"descripteur."

#: reference/datamodel.rst:1746
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"Le comportement par défaut pour la gestion d'un attribut est de définir, "
"obtenir et supprimer cet attribut du dictionnaire de l'objet. Par exemple, "
"pour ``a.x`` Python commence d'abord par rechercher ``a.__dict__['x']``, "
"puis ``type(a).__dict__['x']`` ; ensuite Python continue en remontant les "
"classes de base de ``type(a)``, en excluant les méta-classes."

#: reference/datamodel.rst:1751
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"Cependant, si la valeur cherchée est un objet qui définit une des méthodes "
"de descripteur, alors Python modifie son comportement et invoque la méthode "
"du descripteur à la place. Le moment où cela intervient dans la recherche "
"citée ci-dessus dépend de l'endroit où a été définie la méthode de "
"descripteur et comment elle a été appelée."

#: reference/datamodel.rst:1756
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"Le point de départ pour une invocation de descripteur est la liaison ``a."
"x``. La façon dont les arguments sont assemblés dépend de ``a`` :"

#: reference/datamodel.rst:1761
msgid "Direct Call"
msgstr "Appel direct"

#: reference/datamodel.rst:1760
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"Le plus simple et le plus rare des appels est quand l'utilisateur code "
"directement l'appel à la méthode du descripteur : ``x.__get__(a)``."

#: reference/datamodel.rst:1765
msgid "Instance Binding"
msgstr "Liaison avec une instance"

#: reference/datamodel.rst:1764
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"Si elle est liée à un objet instance, ``a.x`` est transformé en l'appel "
"suivant : ``type(a).__dict__['x'].__get__(a, type(a))``."

#: reference/datamodel.rst:1769
msgid "Class Binding"
msgstr "Liaison avec une classe"

#: reference/datamodel.rst:1768
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""
"Si elle est liée à une classe, ``A.x`` est transformé en l'appel suivant : "
"``A.__dict__['x'].__get__(None, A)``."

#: reference/datamodel.rst:1775
msgid "Super Binding"
msgstr "Liaison super"

#: reference/datamodel.rst:1772
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, obj)."
"m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""
"Si ``a`` est une instance de :class:`super`, alors ``super(B, obj).m()`` "
"recherche ``obj.__class__.__mro__`` pour la classe de base ``A`` "
"immédiatement avant ``B`` puis invoque le descripteur avec l'appel suivant : "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."

#: reference/datamodel.rst:1777
#, fuzzy
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If "
"it does not define :meth:`__get__`, then accessing the attribute will return "
"the descriptor object itself unless there is a value in the object's "
"instance dictionary.  If the descriptor defines :meth:`__set__` and/or :meth:"
"`__delete__`, it is a data descriptor; if it defines neither, it is a non-"
"data descriptor.  Normally, data descriptors define both :meth:`__get__` "
"and :meth:`__set__`, while non-data descriptors have just the :meth:"
"`__get__` method.  Data descriptors with :meth:`__get__` and :meth:`__set__` "
"(and/or :meth:`__delete__`) defined always override a redefinition in an "
"instance dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""
"Pour des liaisons avec des instances, la priorité à l'invocation du "
"descripteur dépend des méthodes que le descripteur a définies. Un "
"descripteur peut définir n'importe quelle combinaison de :meth:`__get__`, :"
"meth:`__set__` et :meth:`__delete__`. S'il ne définit pas :meth:`__get__`, "
"alors accéder à l'attribut retourne l'objet descripteur lui-même sauf s'il "
"existe une valeur dans le dictionnaire de l'objet instance. Si le "
"descripteur définit :meth:`__set__` ou :meth:`__delete__`, c'est un "
"descripteur de données ; s'il ne définit aucune méthode, c'est un "
"descripteur hors-donnée. Normalement, les descripteurs de données "
"définissent à la fois :meth:`__get__` et :meth:`__set__`, alors que les "
"descripteurs hors-données définissent seulement la méthode :meth:`__get__`. "
"Les descripteurs de données qui définissent :meth:`__set__` et :meth:"
"`__get__` sont toujours prioritaires face à une redéfinition du dictionnaire "
"de l'instance. En revanche, les descripteurs hors-données peuvent être "
"shuntés par les instances."

#: reference/datamodel.rst:1790
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) are "
"implemented as non-data descriptors.  Accordingly, instances can redefine "
"and override methods.  This allows individual instances to acquire behaviors "
"that differ from other instances of the same class."
msgstr ""
"Les méthodes Python (y compris :func:`staticmethod` et :func:`classmethod`) "
"sont implémentées comme des descripteurs hors-donnée. De la même manière, "
"les instances peuvent redéfinir et surcharger les méthodes. Ceci permet à "
"chaque instance d'avoir un comportement qui diffère des autres instances de "
"la même classe."

#: reference/datamodel.rst:1795
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
"La fonction :func:`property` est implémentée en tant que descripteur de "
"données. Ainsi, les instances ne peuvent pas surcharger le comportement "
"d'une propriété."

#: reference/datamodel.rst:1802
msgid "__slots__"
msgstr "``__slots__``"

#: reference/datamodel.rst:1804
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of *__dict__* and *__weakref__* (unless explicitly "
"declared in *__slots__* or available in a parent.)"
msgstr ""
"Les ``__slots__`` vous permettent de déclarer des membres d'une donnée "
"(comme une propriété) et d'interdire la création de *__dict__* ou de "
"*__weakref__* (à moins qu'ils ne soient explicitement déclarés dans le "
"``__slots__`` ou présent dans le parent)."

#: reference/datamodel.rst:1808
msgid ""
"The space saved over using *__dict__* can be significant. Attribute lookup "
"speed can be significantly improved as well."
msgstr ""
"L'espace gagné par rapport à l'utilisation d'un *__dict__* peut être "
"significatif. La recherche d'attribut peut aussi s'avérer beaucoup plus "
"rapide."

#: reference/datamodel.rst:1813
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of *__dict__* "
"and *__weakref__* for each instance."
msgstr ""
"Cette variable de classe peut être assignée avec une chaîne, un itérable ou "
"une séquence de chaînes avec les noms de variables utilisés par les "
"instances. *__slots__* réserve de la place pour ces variables déclarées et "
"interdit la création automatique de *__dict__* et *__weakref__* pour chaque "
"instance."

#: reference/datamodel.rst:1820
msgid "Notes on using *__slots__*"
msgstr "Note sur l'utilisation de *__slots__*"

#: reference/datamodel.rst:1822
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* and "
"*__weakref__* attribute of the instances will always be accessible."
msgstr ""
"Lorsque vous héritez d'une classe sans *__slots__*, les attributs *__dict__* "
"et *__weakref__* des instances sont toujours accessibles."

#: reference/datamodel.rst:1825
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables "
"not listed in the *__slots__* definition.  Attempts to assign to an unlisted "
"variable name raises :exc:`AttributeError`. If dynamic assignment of new "
"variables is desired, then add ``'__dict__'`` to the sequence of strings in "
"the *__slots__* declaration."
msgstr ""
"Sans variable *__dict__*, les instances ne peuvent pas assigner de nouvelles "
"variables (non listées dans la définition de *__slots__*). Les tentatives "
"d'assignation sur un nom de variable non listé lève :exc:`AttributeError`. "
"Si l'assignation dynamique de nouvelles variables est nécessaire, ajoutez "
"``'__dict__'`` à la séquence de chaînes dans la déclaration *__slots__*."

#: reference/datamodel.rst:1831
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence of "
"strings in the *__slots__* declaration."
msgstr ""
"Sans variable *__weakref__* pour chaque instance, les classes qui "
"définissent *__slots__* ne gèrent pas les références faibles vers leurs "
"instances. Si vous avez besoin de gérer des références faibles, ajoutez "
"``'__weakref__'`` à la séquence de chaînes dans la déclaration de "
"*__slots__*."

#: reference/datamodel.rst:1836
msgid ""
"*__slots__* are implemented at the class level by creating descriptors (:ref:"
"`descriptors`) for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""
"Les *__slots__* sont implémentés au niveau de la classe en créant des "
"descripteurs (:ref:`descriptors`) pour chaque nom de variable. Ainsi, les "
"attributs de classe ne peuvent pas être utilisés pour des valeurs par défaut "
"aux variables d'instances définies par *__slots__* ; sinon, l'attribut de "
"classe surchargerait l'assignation par descripteur."

#: reference/datamodel.rst:1842
msgid ""
"The action of a *__slots__* declaration is not limited to the class where it "
"is defined.  *__slots__* declared in parents are available in child classes. "
"However, child subclasses will get a *__dict__*  and *__weakref__* unless "
"they also define *__slots__* (which should only contain names of any "
"*additional* slots)."
msgstr ""
"L'action de la déclaration du *__slots__* ne se limite pas à la classe où il "
"est défini. Les *__slots__* déclarés par les parents sont disponibles dans "
"les classes enfants. Cependant, les sous-classes enfants ont un *__dict__* "
"et un *__weakref__* à moins qu'elles ne définissent aussi un *__slots__* "
"(qui ne doit contenir alors que les noms *supplémentaires* du *slot*)."

#: reference/datamodel.rst:1848
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"Si une classe définit un *slot* déjà défini dans une classe de base, la "
"variable d'instance définie par la classe de base est inaccessible (sauf à "
"utiliser le descripteur de la classe de base directement). Cela rend la "
"signification du programme indéfinie. Dans le futur, une vérification sera "
"ajoutée pour empêcher cela."

#: reference/datamodel.rst:1853
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-length"
"\" built-in types such as :class:`int`, :class:`bytes` and :class:`tuple`."
msgstr ""
"Un *__slot__* non vide ne fonctionne pas pour les classes dérivées des types "
"natifs à longueur variable tels que :class:`int`, :class:`bytes` et :class:"
"`tuple`."

#: reference/datamodel.rst:1856
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also be "
"used; however, in the future, special meaning may be assigned to the values "
"corresponding to each key."
msgstr ""
"Tout itérable qui n'est pas une chaîne peut être assigné à un *__slots__*. "
"Les tableaux de correspondance peuvent aussi être utilisés ; cependant, dans "
"le futur, des significations spéciales pourraient être associées à chacune "
"des clés."

#: reference/datamodel.rst:1860
msgid ""
"*__class__* assignment works only if both classes have the same *__slots__*."
msgstr ""
"Les assignations de *__class__* ne fonctionnent que si les deux classes ont "
"le même *__slots__*."

#: reference/datamodel.rst:1862
msgid ""
"Multiple inheritance with multiple slotted parent classes can be used, but "
"only one parent is allowed to have attributes created by slots (the other "
"bases must have empty slot layouts) - violations raise :exc:`TypeError`."
msgstr ""
"L'héritage multiple avec plusieurs classes parentes qui ont des *__slots__* "
"est possible, mais seul un parent peut avoir des attributs créés par "
"*__slots__* (les autres classes parentes doivent avoir des *__slots__* "
"vides). La violation de cette règle lève :exc:`TypeError`."

#: reference/datamodel.rst:1867
msgid ""
"If an iterator is used for *__slots__* then a descriptor is created for each "
"of the iterator's values. However, the *__slots__* attribute will be an "
"empty iterator."
msgstr ""
"Si un itérateur est utilisé pour *__slots__*, alors un descripteur est créé "
"pour chacune des valeurs de l'itérateur. Cependant, l'attribut de "
"*__slots__* est un itérateur vide."

#: reference/datamodel.rst:1874
msgid "Customizing class creation"
msgstr "Personnalisation de la création de classes"

#: reference/datamodel.rst:1876
msgid ""
"Whenever a class inherits from another class, *__init_subclass__* is called "
"on that class. This way, it is possible to write classes which change the "
"behavior of subclasses. This is closely related to class decorators, but "
"where class decorators only affect the specific class they're applied to, "
"``__init_subclass__`` solely applies to future subclasses of the class "
"defining the method."
msgstr ""
"Quand une classe hérite d'une classe parente, *__init_subclass__* de la "
"classe parente est appelée. Ainsi, il est possible d'écrire des classes qui "
"modifient le comportement des sous-classes. Ce comportement est corrélé aux "
"décorateurs de classes mais, alors que les décorateurs de classes agissent "
"seulement sur la classe qu'ils décorent, ``__init_subclass__`` agit "
"uniquement sur les futures sous-classes de la classe qui définit cette "
"méthode."

#: reference/datamodel.rst:1885
msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr ""
"Cette méthode est appelée quand la classe est sous-classée. *cls* est alors "
"la nouvelle sous-classe. Si elle est définie en tant que méthode d'instance "
"normale, cette méthode est implicitement convertie en méthode de classe."

#: reference/datamodel.rst:1889
msgid ""
"Keyword arguments which are given to a new class are passed to the parent's "
"class ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""
"Les arguments nommés qui sont donnés à la nouvelle classe sont passés à "
"``__init_subclass__`` de la classe parente. Par souci de compatibilité avec "
"les autres classes qui utilisent ``__init_subclass__``, vous devez enlever "
"les arguments nommés dont vous avez besoin et passer les autres à la classe "
"de base, comme ci-dessous ::"

#: reference/datamodel.rst:1903
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr ""
"L'implémentation par défaut ``object.__init_subclass__`` ne fait rien mais "
"lève une erreur si elle est appelée avec un argument."

#: reference/datamodel.rst:1908
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The "
"actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"L'indication de méta-classe ``metaclass`` est absorbée par le reste du "
"mécanisme de types et n'est jamais passée à l'implémentation de "
"``__init_subclass__``. La méta-classe réelle (plutôt que l'indication "
"explicite) peut être récupérée par ``type(cls)``."

#: reference/datamodel.rst:1919
msgid "Metaclasses"
msgstr "Méta-classes"

#: reference/datamodel.rst:1926
msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"Par défaut, les classes sont construites en utilisant :func:`type`. Le corps "
"de la classe est exécuté dans un nouvel espace de nommage et le nom de la "
"classe est lié localement au résultat de `type(name, bases, namespace)``."

#: reference/datamodel.rst:1930
msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"Le déroulement de création de la classe peut être personnalisé en passant "
"l'argument nommé ``metaclass`` dans la ligne de définition de la classe ou "
"en héritant d'une classe existante qui comporte déjà un tel argument. Dans "
"l'exemple qui suit, ``MyClass`` et ``MySubclass`` sont des instances de "
"``Meta`` ::"

#: reference/datamodel.rst:1944
msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr ""
"Tout autre argument nommé spécifié dans la définition de la classe est passé "
"aux opérations de méta-classes décrites auparavant."

#: reference/datamodel.rst:1947
msgid "When a class definition is executed, the following steps occur:"
msgstr ""
"Quand la définition d'une classe est exécutée, les différentes étapes "
"suivies sont :"

#: reference/datamodel.rst:1949
msgid "MRO entries are resolved;"
msgstr "Les entrées MRO sont résolues ;"

#: reference/datamodel.rst:1950
msgid "the appropriate metaclass is determined;"
msgstr "la méta-classe appropriée est déterminée ;"

#: reference/datamodel.rst:1951
msgid "the class namespace is prepared;"
msgstr "l'espace de nommage de la classe est préparé ;"

#: reference/datamodel.rst:1952
msgid "the class body is executed;"
msgstr "le corps de la classe est exécuté ;"

#: reference/datamodel.rst:1953
msgid "the class object is created."
msgstr "l'objet classe est crée."

#: reference/datamodel.rst:1957
msgid "Resolving MRO entries"
msgstr "Résolution des entrées MRO"

#: reference/datamodel.rst:1959
msgid ""
"If a base that appears in class definition is not an instance of :class:"
"`type`, then an ``__mro_entries__`` method is searched on it. If found, it "
"is called with the original bases tuple. This method must return a tuple of "
"classes that will be used instead of this base. The tuple may be empty, in "
"such case the original base is ignored."
msgstr ""
"Si une classe de base qui apparaît dans la définition d'une classe n'est pas "
"une instance de :class:`type`, alors Python y recherche une méthode "
"``__mro_entries__``. S'il la trouve, il l'appelle avec le *n*-uplet original "
"des classes de bases. Cette méthode doit renvoyer un *n*-uplet de classes "
"qui est utilisé à la place de la classe de base. Le *n*-uplet peut être "
"vide, dans ce cas la classe de base originale est ignorée."

#: reference/datamodel.rst:2157
msgid ":pep:`560` - Core support for typing module and generic types"
msgstr ""
":pep:`560` — Gestion de base pour les types modules et les types génériques"

#: reference/datamodel.rst:1971
msgid "Determining the appropriate metaclass"
msgstr "Détermination de la méta-classe appropriée"

#: reference/datamodel.rst:1975
msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr ""
"La méta-classe appropriée pour une définition de classe est déterminée de la "
"manière suivante :"

#: reference/datamodel.rst:1977
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used;"
msgstr ""
"si aucune classe et aucune métaclasse n'est donnée, alors :func:`type` est "
"utilisée ;"

#: reference/datamodel.rst:1978
msgid ""
"if an explicit metaclass is given and it is *not* an instance of :func:"
"`type`, then it is used directly as the metaclass;"
msgstr ""
"si une méta-classe explicite est donnée et que *ce n'est pas* une instance "
"de :func:`type`, alors elle est utilisée directement en tant que méta-"
"classe ;"

#: reference/datamodel.rst:1980
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used."
msgstr ""
"Si une instance de :func:`type` est donnée comme méta-classe explicite ou si "
"*bases* est définie, alors la méta-classe la plus dérivée est utilisée."

#: reference/datamodel.rst:1983
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified "
"base classes. The most derived metaclass is one which is a subtype of *all* "
"of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"La méta-classe la plus dérivée est choisie à partir des méta-classes "
"explicitement spécifiées (s'il y en a) et les méta-classes (c'est-à-dire les "
"``type(cls)``) de toutes les classes de base spécifiées. La méta-classe la "
"plus dérivée est celle qui est un sous-type de *toutes* ces méta-classes "
"candidates. Si aucune des méta-classes candidates ne remplit ce critère, "
"alors la définition de la classe échoue en levant ``TypeError``."

#: reference/datamodel.rst:1993
msgid "Preparing the class namespace"
msgstr "Préparation de l'espace de nommage de la classe"

#: reference/datamodel.rst:1998
msgid ""
"Once the appropriate metaclass has been identified, then the class namespace "
"is prepared. If the metaclass has a ``__prepare__`` attribute, it is called "
"as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition). The "
"``__prepare__`` method should be implemented as a :func:`classmethod`. The "
"namespace returned by ``__prepare__`` is passed in to ``__new__``, but when "
"the final class object is created the namespace is copied into a new "
"``dict``."
msgstr ""
"Une fois que la méta-classe appropriée est identifiée, l'espace de nommage "
"de la classe est préparé. Si la méta-classe possède un attribut "
"``__prepare__``, il est appelé avec ``namespace = metaclass."
"__prepare__(name, bases, **kwds)`` (où les arguments nommés supplémentaires, "
"s'il y en a, sont les arguments de la définition de la classe). La méthode "
"``__prepare__`` doit être implémentée comme une méthode de classe (:func:"
"`classmethod`). L’espace de nommage renvoyé par ``__prepare__`` est passé à "
"``__new__``, mais quand l’instance finale est créée, l’espace de nommage est "
"copié vers un nouveau ``dict``."

#: reference/datamodel.rst:2006
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr ""
"Si la méta-classe ne possède pas d'attribut ``__prepare__``, alors l'espace "
"de nommage de la classe est initialisé en tant que tableau de "
"correspondances ordonné."

#: reference/datamodel.rst:2011
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` — Méta-classes dans Python 3000"

#: reference/datamodel.rst:2012
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr ""
"introduction de la fonction automatique ``__prepare__`` de l'espace de "
"nommage"

#: reference/datamodel.rst:2016
msgid "Executing the class body"
msgstr "Exécution du corps de la classe"

#: reference/datamodel.rst:2021
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"Le corps de la classe est exécuté (approximativement) avec ``exec(body, "
"globals(), namespace)``. La principale différence avec un appel normal à :"
"func:`exec` est que la portée lexicale autorise le corps de la classe (y "
"compris les méthodes) à faire référence aux noms de la portée courante et "
"des portées externes lorsque la définition de classe a lieu dans une "
"fonction."

#: reference/datamodel.rst:2027
msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"Cependant, même quand une définition de classe intervient dans une fonction, "
"les méthodes définies à l'intérieur de la classe ne peuvent pas voir les "
"noms définis en dehors de la portée de la classe. On accède aux variables de "
"la classe *via* le premier paramètre des méthodes d'instance ou de classe, "
"ou *via* la référence implicite ``__class__`` incluse dans la portée "
"lexicale et décrite dans la section suivante."

#: reference/datamodel.rst:2036
msgid "Creating the class object"
msgstr "Création de l'objet classe"

#: reference/datamodel.rst:2043
msgid ""
"Once the class namespace has been populated by executing the class body, the "
"class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"Quand l'espace de nommage a été rempli en exécutant le corps de la classe, "
"l'objet classe est créé en appelant ``metaclass(name, bases, namespace, "
"**kwds)`` (les arguments nommés supplémentaires passés ici sont les mêmes "
"que ceux passés à ``__prepare__``)."

#: reference/datamodel.rst:2048
msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of :func:"
"`super` to correctly identify the class being defined based on lexical "
"scoping, while the class or instance that was used to make the current call "
"is identified based on the first argument passed to the method."
msgstr ""
"Cet objet classe est celui qui est référencé par la forme sans argument de :"
"func:`super`. ``__class__`` est une référence implicite créée par le "
"compilateur si une méthode du corps de la classe fait référence soit à "
"``__class__``, soit à ``super``. Ceci permet que la forme sans argument de :"
"func:`super` identifie la classe en cours de définition en fonction de la "
"portée lexicale, tandis que la classe ou l'instance utilisée pour effectuer "
"l'appel en cours est identifiée en fonction du premier argument transmis à "
"la méthode."

#: reference/datamodel.rst:2058
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a :exc:`RuntimeError` "
"in Python 3.8."
msgstr ""
"Dans CPython 3.6 et suivants, la cellule ``__class__`` est passée à la méta-"
"classe en tant qu'entrée ``__classcell__`` dans l'espace de nommage de la "
"classe. Si elle est présente, elle doit être propagée à l'appel ``type .__ "
"new__`` pour que la classe soit correctement initialisée. Ne pas le faire se "
"traduit par un :exc:`RuntimeError` dans Python 3.8."

#: reference/datamodel.rst:2064
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customisation "
"steps are invoked after creating the class object:"
msgstr ""
"Quand vous utilisez la méta-classe par défaut :class:`type` ou toute autre "
"méta-classe qui finit par appeler ``type.__new__``, les étapes de "
"personnalisation supplémentaires suivantes sont suivies après la création de "
"l'objet classe :"

#: reference/datamodel.rst:2068
msgid ""
"first, ``type.__new__`` collects all of the descriptors in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"d'abord, ``type.__new__`` récupère, dans l'espace de nommage de la classe, "
"tous les descripteurs qui définissent une méthode :meth:`~object."
"__set_name__` ;"

#: reference/datamodel.rst:2070
msgid ""
"second, all of these ``__set_name__`` methods are called with the class "
"being defined and the assigned name of that particular descriptor;"
msgstr ""
"ensuite, toutes ces méthodes ``__set_name__`` sont appelées avec la classe "
"en cours de définition et le nom assigné à chaque descripteur ;"

#: reference/datamodel.rst:2072
msgid ""
"finally, the :meth:`~object.__init_subclass__` hook is called on the "
"immediate parent of the new class in its method resolution order."
msgstr ""
"finalement, la méthode automatique :meth:`~object.__init_subclass__` est "
"appelée sur le parent immédiat de la nouvelle classe en utilisant l'ordre de "
"résolution des méthodes."

#: reference/datamodel.rst:2075
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""
"Après la création de l'objet classe, il est passé aux décorateurs de la "
"classe, y compris ceux inclus dans la définition de la classe (s'il y en a) "
"et l'objet résultant est lié à l'espace de nommage local en tant que classe "
"définie."

#: reference/datamodel.rst:2079
msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~object.__dict__` attribute of the class object."
msgstr ""
"Quand une nouvelle classe est créée *via* ``type.__new__``, l'objet fourni "
"en tant que paramètre d'espace de nommage est copié vers un nouveau tableau "
"de correspondances ordonné et l'objet original est laissé de côté. La "
"nouvelle copie est encapsulée dans un mandataire en lecture seule qui "
"devient l'attribut :attr:`~object.__dict__` de l'objet classe."

#: reference/datamodel.rst:2086
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` — Nouvelle méthode super"

#: reference/datamodel.rst:2087
msgid "Describes the implicit ``__class__`` closure reference"
msgstr ""
"Décrit la référence à la fermeture (*closure* en anglais) de la "
"``__class__`` implicite"

#: reference/datamodel.rst:2091
msgid "Uses for metaclasses"
msgstr "Cas d'utilisations des métaclasses"

#: reference/datamodel.rst:2093
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"Les utilisations possibles des méta-classes sont immenses. Quelques pistes "
"ont déjà été explorées comme l'énumération, la gestion des traces, le "
"contrôle des interfaces, la délégation automatique, la création automatique "
"de propriétés, les mandataires, les *frameworks* ainsi que le verrouillage "
"ou la synchronisation automatique de ressources."

#: reference/datamodel.rst:2100
msgid "Customizing instance and subclass checks"
msgstr "Personnalisation des instances et vérification des sous-classes"

#: reference/datamodel.rst:2102
msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"Les méthodes suivantes sont utilisées pour surcharger le comportement par "
"défaut des fonctions natives :func:`isinstance` et :func:`issubclass`."

#: reference/datamodel.rst:2105
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"En particulier, la méta-classe :class:`abc.ABCMeta` implémente ces méthodes "
"pour autoriser l'ajout de classes de base abstraites (ABC pour *Abstract "
"Base Classes* en anglais) en tant que « classes de base virtuelles » pour "
"toute classe ou type (y compris les types natifs)."

#: reference/datamodel.rst:2112
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"Renvoie ``True`` si *instance* doit être considérée comme une instance "
"(directe ou indirecte) de *class*. Si elle est définie, elle est appelée "
"pour implémenter ``isinstance(instance, class)``."

#: reference/datamodel.rst:2119
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""
"Renvoie ``True`` si *subclass* doit être considérée comme une sous-classe "
"(directe ou indirecte) de *class*. Si elle est définie, appelée pour "
"implémenter ``issubclass(subclass, class)``."

#: reference/datamodel.rst:2124
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"Notez que ces méthodes sont recherchées dans le type (la méta-classe) d'une "
"classe. Elles ne peuvent pas être définies en tant que méthodes de classe "
"dans la classe réelle. C'est cohérent avec la recherche des méthodes "
"spéciales qui sont appelées pour les instances, sauf qu'ici l'instance est "
"elle-même une classe."

#: reference/datamodel.rst:2135
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` — Introduction aux classes de bases abstraites"

#: reference/datamodel.rst:2132
msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~class.__instancecheck__` and :meth:"
"`~class.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""
"Inclut la spécification pour la personnalisation du comportement de :func:"
"`isinstance` et :func:`issubclass` à travers :meth:`~class."
"__instancecheck__` et :meth:`~class.__subclasscheck__`, avec comme "
"motivation pour cette fonctionnalité l'ajout les classes de base abstraites "
"(voir le module :mod:`abc`) au langage."

#: reference/datamodel.rst:2140
msgid "Emulating generic types"
msgstr "Émulation de types génériques"

#: reference/datamodel.rst:2142
msgid ""
"One can implement the generic class syntax as specified by :pep:`484` (for "
"example ``List[int]``) by defining a special method:"
msgstr ""
"Vous pouvez implémenter la syntaxe générique des classes comme spécifié par "
"la :pep:`484` (par exemple ``List[int]``) en définissant une méthode "
"spéciale :"

#: reference/datamodel.rst:2147
msgid ""
"Return an object representing the specialization of a generic class by type "
"arguments found in *key*."
msgstr ""
"Renvoie un objet représentant la spécialisation d'une classe générique en "
"fonction des arguments types trouvés dans *key*."

#: reference/datamodel.rst:2150
msgid ""
"This method is looked up on the class object itself, and when defined in the "
"class body, this method is implicitly a class method.  Note, this mechanism "
"is primarily reserved for use with static type hints, other usage is "
"discouraged."
msgstr ""
"Python recherche cette méthode dans l'objet de classe lui-même et, "
"lorsqu'elle est définie dans le corps de la classe, cette méthode est "
"implicitement une méthode de classe. Notez que ce mécanisme est "
"principalement réservé à une utilisation avec des indications de type "
"statiques, d'autres utilisations sont déconseillées."

#: reference/datamodel.rst:2163
msgid "Emulating callable objects"
msgstr "Émulation d'objets appelables"

#: reference/datamodel.rst:2170
#, fuzzy
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to ``type(x).__call__(x, "
"arg1, ...)``."
msgstr ""
"Appelée quand l'instance est « appelée » en tant que fonction ; si la "
"méthode est définie, ``x(arg1, arg2, ...)`` est un raccourci pour ``x."
"__call__(arg1, arg2, ...)``."

#: reference/datamodel.rst:2177
msgid "Emulating container types"
msgstr "Émulation de types conteneurs"

#: reference/datamodel.rst:2179
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings (like "
"dictionaries), but can represent other containers as well.  The first set of "
"methods is used either to emulate a sequence or to emulate a mapping; the "
"difference is that for a sequence, the allowable keys should be the integers "
"*k* for which ``0 <= k < N`` where *N* is the length of the sequence, or "
"slice objects, which define a range of items.  It is also recommended that "
"mappings provide the methods :meth:`keys`, :meth:`values`, :meth:`items`, :"
"meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:`pop`, :meth:"
"`popitem`, :meth:`!copy`, and :meth:`update` behaving similar to those for "
"Python's standard dictionary objects.  The :mod:`collections.abc` module "
"provides a :class:`~collections.abc.MutableMapping` abstract base class to "
"help create those methods from a base set of :meth:`__getitem__`, :meth:"
"`__setitem__`, :meth:`__delitem__`, and :meth:`keys`. Mutable sequences "
"should provide methods :meth:`append`, :meth:`count`, :meth:`index`, :meth:"
"`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse` and :"
"meth:`sort`, like Python standard list objects.  Finally, sequence types "
"should implement addition (meaning concatenation) and multiplication "
"(meaning repetition) by defining the methods :meth:`__add__`, :meth:"
"`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__` and :meth:"
"`__imul__` described below; they should not define other numerical "
"operators.  It is recommended that both mappings and sequences implement "
"the :meth:`__contains__` method to allow efficient use of the ``in`` "
"operator; for mappings, ``in`` should search the mapping's keys; for "
"sequences, it should search through the values.  It is further recommended "
"that both mappings and sequences implement the :meth:`__iter__` method to "
"allow efficient iteration through the container; for mappings, :meth:"
"`__iter__` should iterate through the object's keys; for sequences, it "
"should iterate through the values."
msgstr ""
"Les fonctions suivantes peuvent être définies pour implémenter des objets "
"conteneurs. Les conteneurs sont habituellement des séquences (telles que les "
"*n*-uplets ou les listes) ou des tableaux de correspondances (comme les "
"dictionnaires), mais ils peuvent aussi représenter d'autres conteneurs. Le "
"premier ensemble de méthodes est utilisé soit pour émuler une séquence, soit "
"pour émuler un tableau de correspondances ; la différence est que, pour une "
"séquence, les clés doivent être soit des entiers *k* tels que ``0 <= k < N`` "
"où *N* est la longueur de la séquence, soit des objets tranches qui "
"définissent un intervalle d'éléments. Il est aussi recommandé que les "
"tableaux de correspondances fournissent les méthodes :meth:`keys`, :meth:"
"`values`, :meth:`items`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :"
"meth:`pop`, :meth:`popitem`, :meth:`!copy` et :meth:`update` avec un "
"comportement similaire aux objets dictionnaires standards de Python. Le "
"module :mod:`collections.abc` fournit une classe de base abstraite :class:"
"`~collections.abc.MutableMapping` pour aider à la création de ces méthodes à "
"partir d'un ensemble de base composé de :meth:`__getitem__`, :meth:"
"`__setitem__`, :meth:`__delitem__` et :meth:`keys`. Les séquences muables "
"doivent fournir les méthodes :meth:`append`, :meth:`count`, :meth:`index`, :"
"meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse` "
"et :meth:`sort`, comme les objets listes standards de Python. Enfin, les "
"types séquences doivent implémenter l'addition (dans le sens de la "
"concaténation) et la multiplication (dans le sens de la répétition) en "
"définissant les méthodes :meth:`__add__`, :meth:`__radd__`, :meth:"
"`__iadd__`, :meth:`__mul__`, :meth:`__rmul__` et :meth:`__imul__` décrites "
"ci-dessous ; ils ne doivent pas définir d'autres opérateurs numériques. Il "
"est recommandé que les tableaux de correspondances et les séquences "
"implémentent la méthode :meth:`__contains__` pour permettre l'utilisation "
"efficace de l'opérateur ``in`` ; concernant les tableaux de correspondances, "
"``in`` doit rechercher dans les clés du tableau ; pour les séquences, il "
"doit chercher dans les valeurs. Il est de plus recommandé que les tableaux "
"de correspondances et les séquences implémentent la méthode :meth:`__iter__` "
"pour permettre une itération efficace dans le conteneur ; pour les tableaux "
"de correspondances, :meth:`__iter__` doit itérer sur les clés de l'objet ; "
"pour les séquences, elle doit itérer sur les valeurs."

#: reference/datamodel.rst:2214
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__bool__` method and whose :meth:`__len__` method returns "
"zero is considered to be false in a Boolean context."
msgstr ""
"Appelée pour implémenter la fonction native :func:`len`. Elle doit renvoyer "
"la longueur de l'objet, un entier ``>=`` 0. Par ailleurs, un objet qui ne "
"définit pas de méthode :meth:`__bool__` et dont la méthode :meth:`__len__` "
"renvoie zéro est considéré comme valant ``False`` dans un contexte booléen."

#: reference/datamodel.rst:2221
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If the "
"length is larger than :attr:`!sys.maxsize` some features (such as :func:"
"`len`) may raise :exc:`OverflowError`.  To prevent raising :exc:`!"
"OverflowError` by truth value testing, an object must define a :meth:"
"`__bool__` method."
msgstr ""
"En CPython, la longueur doit valoir au maximum :attr:`sys.maxsize`. Si la "
"longueur est plus grande que :attr:`!sys.maxsize`, des propriétés (telles "
"que :func:`len`) peuvent lever :exc:`OverflowError`. Afin d'éviter de lever :"
"exc:`!OverflowError` lors de tests booléens, un objet doit définir la "
"méthode :meth:`__bool__`."

#: reference/datamodel.rst:2230
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated "
"length for the object (which may be greater or less than the actual length). "
"The length must be an integer ``>=`` 0. The return value may also be :const:"
"`NotImplemented`, which is treated the same as if the ``__length_hint__`` "
"method didn't exist at all. This method is purely an optimization and is "
"never required for correctness."
msgstr ""
"Appelée pour implémenter :func:`operator.length_hint`. Elle doit renvoyer "
"une longueur estimée de l'objet (qui peut être plus grande ou plus petite "
"que la longueur réelle). La longueur doit être un entier ``>=`` 0. La valeur "
"de retour peut aussi être :const:`NotImplemented`, qui est traitée de la "
"même façon que si la méthode ``__length_hint__`` n'existait pas. Cette "
"méthode est utilisée uniquement pour optimiser les traitements et n'est "
"jamais tenue de renvoyer un résultat exact."

#: reference/datamodel.rst:2244
msgid ""
"Slicing is done exclusively with the following three methods.  A call like ::"
msgstr ""
"Le découpage est effectué uniquement à l'aide des trois méthodes suivantes. "
"Un appel comme ::"

#: reference/datamodel.rst:2248
msgid "is translated to ::"
msgstr "est traduit en ::"

#: reference/datamodel.rst:2252
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "et ainsi de suite. Les éléments manquants sont remplacés par ``None``."

#: reference/datamodel.rst:2257
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the special "
"interpretation of negative indexes (if the class wishes to emulate a "
"sequence type) is up to the :meth:`__getitem__` method. If *key* is of an "
"inappropriate type, :exc:`TypeError` may be raised; if of a value outside "
"the set of indexes for the sequence (after any special interpretation of "
"negative values), :exc:`IndexError` should be raised. For mapping types, if "
"*key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr ""
"Appelée pour implémenter l'évaluation de ``self[key]``. Pour les types "
"séquences, les clés autorisées sont les entiers et les objets tranches "
"(*slice*). Notez que l'interprétation spéciale des indices négatifs (si la "
"classe souhaite émuler un type séquence) est du ressort de la méthode :meth:"
"`__getitem__`. Si *key* n'est pas du bon type, une :exc:`TypeError` peut "
"être levée ; si la valeur est en dehors de l'ensemble des indices de la "
"séquence (après interprétation éventuelle des valeurs négatives), une :exc:"
"`IndexError` doit être levée. Pour les tableaux de correspondances, si *key* "
"n'existe pas dans le conteneur, une :exc:`KeyError` doit être levée."

#: reference/datamodel.rst:2268
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` s'attend à ce qu'une :exc:`IndexError` soit levée en cas "
"d'indice illégal afin de détecter correctement la fin de la séquence."

#: reference/datamodel.rst:2274
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"Appelée pour implémenter l'assignation à ``self[key]``. La même note que "
"pour :meth:`__getitem__` s'applique. Elle ne doit être implémentée que pour "
"les tableaux de correspondances qui autorisent les modifications de valeurs "
"des clés, ceux pour lesquels on peut ajouter de nouvelles clés ou, pour les "
"séquences, celles dont les éléments peuvent être remplacés. Les mêmes "
"exceptions que pour la méthode :meth:`__getitem__` doivent être levées en "
"cas de mauvaises valeurs de clés."

#: reference/datamodel.rst:2283
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""
"Appelée pour implémenter la suppression de ``self[key]``. La même note que "
"pour :meth:`__getitem__` s'applique. Elle ne doit être implémentée que pour "
"les tableaux de correspondances qui autorisent les suppressions de clés ou "
"pour les séquences dont les éléments peuvent être supprimés de la séquence. "
"Les mêmes exceptions que pour la méthode :meth:`__getitem__` doivent être "
"levées en cas de mauvaises valeurs de clés."

#: reference/datamodel.rst:2292
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""
"Appelée par :class:`dict`\\ .\\ :meth:`__getitem__` pour implémenter "
"``self[key]`` dans les sous-classes de dictionnaires lorsque la clé n'est "
"pas dans le dictionnaire."

#: reference/datamodel.rst:2298
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys of "
"the container."
msgstr ""
"Cette méthode est appelée quand un itérateur est requis pour un conteneur. "
"Cette méthode doit renvoyer un nouvel objet itérateur qui peut itérer sur "
"tous les objets du conteneur. Pour les tableaux de correspondances, elle "
"doit itérer sur les clés du conteneur."

#: reference/datamodel.rst:2302
msgid ""
"Iterator objects also need to implement this method; they are required to "
"return themselves.  For more information on iterator objects, see :ref:"
"`typeiter`."
msgstr ""
"Les objets itérateurs doivent aussi implémenter cette méthode ; ils doivent "
"alors se renvoyer eux-mêmes. Pour plus d'information sur les objets "
"itérateurs, lisez :ref:`typeiter`."

#: reference/datamodel.rst:2308
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
"Appelée (si elle existe) par la fonction native :func:`reversed` pour "
"implémenter l'itération en sens inverse. Elle doit renvoyer un nouvel objet "
"itérateur qui itère sur tous les objets du conteneur en sens inverse."

#: reference/datamodel.rst:2312
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""
"Si la méthode :meth:`__reversed__` n'est pas fournie, la fonction native :"
"func:`reversed` se replie sur le protocole de séquence (:meth:`__len__` et :"
"meth:`__getitem__`). Les objets qui connaissent le protocole de séquence ne "
"doivent fournir :meth:`__reversed__` que si l'implémentation qu'ils "
"proposent est plus efficace que celle de :func:`reversed`."

#: reference/datamodel.rst:2319
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be iterable."
msgstr ""
"Les opérateurs de tests d'appartenance (:keyword:`in` et :keyword:`not in`) "
"sont normalement implémentés comme des itérations sur un conteneur. "
"Cependant, les objets conteneurs peuvent fournir les méthodes spéciales "
"suivantes avec une implémentation plus efficace, qui ne requièrent "
"d'ailleurs pas que l'objet soit itérable."

#: reference/datamodel.rst:2326
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"Appelée pour implémenter les opérateurs de test d'appartenance. Elle doit "
"renvoyer ``True`` si *item* est dans *self* et ``False`` sinon. Pour les "
"tableaux de correspondances, seules les clés sont considérées (pas les "
"valeurs des paires clés-valeurs)."

#: reference/datamodel.rst:2330
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
"Pour les objets qui ne définissent pas :meth:`__contains__`, les tests "
"d'appartenance essaient d'abord d'itérer avec :meth:`__iter__` puis avec le "
"vieux protocole d'itération sur les séquences *via* :meth:`__getitem__`, "
"reportez-vous à :ref:`cette section dans la référence du langage <membership-"
"test-details>`."

#: reference/datamodel.rst:2339
msgid "Emulating numeric types"
msgstr "Émulation de types numériques"

#: reference/datamodel.rst:2341
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"Les méthodes suivantes peuvent être définies pour émuler des objets "
"numériques. Les méthodes correspondant à des opérations qui ne sont pas "
"autorisées pour la catégorie de nombres considérée (par exemple, les "
"opérations bit à bit pour les nombres qui ne sont pas entiers) doivent être "
"laissées indéfinies."

#: reference/datamodel.rst:2367
msgid ""
"These methods are called to implement the binary arithmetic operations (``"
"+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, "
"``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to evaluate the "
"expression ``x + y``, where *x* is an instance of a class that has an :meth:"
"`__add__` method, ``x.__add__(y)`` is called.  The :meth:`__divmod__` method "
"should be the equivalent to using :meth:`__floordiv__` and :meth:`__mod__`; "
"it should not be related to :meth:`__truediv__`.  Note that :meth:`__pow__` "
"should be defined to accept an optional third argument if the ternary "
"version of the built-in :func:`pow` function is to be supported."
msgstr ""
"Ces méthodes sont appelées pour implémenter les opérations arithmétiques "
"binaires (``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :"
"func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``). Par exemple, pour "
"évaluer l'expression ``x + y``, où *x* est une instance d'une classe qui "
"possède une méthode :meth:`__add__`, ``x.__add__(y)`` est appelée. La "
"méthode :meth:`__divmod__` doit être l'équivalent d'appeler :meth:"
"`__floordiv__` et :meth:`__mod__` ; elle ne doit pas être reliée à :meth:"
"`__truediv__`. Notez que :meth:`__pow__` doit être définie de manière à "
"accepter un troisième argument optionnel si la version ternaire de la "
"fonction native :func:`pow` est autorisée."

#: reference/datamodel.rst:2378
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr ""
"Si l'une de ces méthodes n'autorise pas l'opération avec les arguments "
"donnés, elle doit renvoyer ``NotImplemented``."

#: reference/datamodel.rst:2401
msgid ""
"These methods are called to implement the binary arithmetic operations (``"
"+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, "
"``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) "
"operands.  These functions are only called if the left operand does not "
"support the corresponding operation [#]_ and the operands are of different "
"types. [#]_ For instance, to evaluate the expression ``x - y``, where *y* is "
"an instance of a class that has an :meth:`__rsub__` method, ``y."
"__rsub__(x)`` is called if ``x.__sub__(y)`` returns *NotImplemented*."
msgstr ""
"Ces méthodes sont appelées pour implémenter les opérations arithmétiques "
"binaires (``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :"
"func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) avec des opérandes "
"renversés (intervertis). Ces fonctions ne sont appelées que si l'opérande de "
"gauche n'autorise pas l'opération correspondante [#]_ et si les opérandes "
"sont de types différents [#]_. Par exemple, pour évaluer l'expression ``x - "
"y``, où *y* est une instance d'une classe qui possède une méthode :meth:"
"`__rsub__`, ``y.__rsub__(x)`` est appelée si ``x.__sub__(y)`` renvoie "
"*NotImplemented*."

#: reference/datamodel.rst:2412
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"Notez que la fonction ternaire :func:`pow` n'essaie pas d'appeler :meth:"
"`__rpow__` (les règles de coercition seraient trop compliquées)."

#: reference/datamodel.rst:2417
#, fuzzy
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method "
"for the operation, this method will be called before the left operand's non-"
"reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""
"Si le type de l'opérande de droite est une sous-classe du type de l'opérande "
"de gauche et que cette sous-classe fournit la méthode symétrique pour "
"l'opération, cette méthode sera appelée avant la méthode originelle de "
"l'opérande gauche. Ce comportement permet à des sous-classes de surcharger "
"les opérations de leurs ancêtres."

#: reference/datamodel.rst:2438
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be, "
"but does not have to be, *self*).  If a specific method is not defined, the "
"augmented assignment falls back to the normal methods.  For instance, if *x* "
"is an instance of a class with an :meth:`__iadd__` method, ``x += y`` is "
"equivalent to ``x = x.__iadd__(y)`` . Otherwise, ``x.__add__(y)`` and ``y."
"__radd__(x)`` are considered, as with the evaluation of ``x + y``. In "
"certain situations, augmented assignment can result in unexpected errors "
"(see :ref:`faq-augmented-assignment-tuple-error`), but this behavior is in "
"fact part of the data model."
msgstr ""
"Ces méthodes sont appelées pour implémenter les assignations arithmétiques "
"augmentées (``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, "
"``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``). Ces méthodes doivent "
"essayer d'effectuer l'opération « sur place » (c'est-à-dire de modifier "
"*self*) et de renvoyer le résultat (qui peut être, mais pas nécessairement, "
"*self*). Si une méthode spécifique n'est pas définie, l'assignation "
"augmentée se replie vers la méthode normale correspondante. Par exemple, si "
"*x* est une instance d'une classe qui possède une méthode :meth:`__iadd__`, "
"``x += y`` est équivalent à ``x = x.__iadd__(y)`` . Sinon, ``x.__add__(y)`` "
"et ``y.__radd__(x)`` sont essayées, comme pour l'évaluation de ``x + y``. "
"Dans certaines situations, les assignations augmentées peuvent causer des "
"erreurs inattendues (voir :ref:`faq-augmented-assignment-tuple-error`), mais "
"ce comportement est en fait partie intégrante du modèle de données."

#: reference/datamodel.rst:2453
msgid ""
"Due to a bug in the dispatching mechanism for ``**=``, a class that defines :"
"meth:`__ipow__` but returns ``NotImplemented`` would fail to fall back to "
"``x.__pow__(y)`` and ``y.__rpow__(x)``. This bug is fixed in Python 3.10."
msgstr ""

#: reference/datamodel.rst:2466
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""
"Appelée pour implémenter les opérations arithmétiques unaires (``-``, ``"
"+``, :func:`abs` et ``~``)."

#: reference/datamodel.rst:2479
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` and :"
"func:`float`.  Should return a value of the appropriate type."
msgstr ""
"Appelées pour implémenter les fonctions natives :func:`complex`, :func:`int` "
"et :func:`float`. Elles doivent renvoyer une valeur du type approprié."

#: reference/datamodel.rst:2486
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"Appelée pour implémenter :func:`operator.index` et lorsque Python a besoin "
"de convertir sans perte un objet numérique en objet entier (pour un "
"découpage ou dans les fonctions natives :func:`bin`, :func:`hex` et :func:"
"`oct`). La présence de cette méthode indique que l'objet numérique est un "
"type entier. Elle doit renvoyer un entier."

#: reference/datamodel.rst:2492
msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` "
"and :func:`complex` fall back to :meth:`__index__`."
msgstr ""
"Si :meth:`__int__`, :meth:`__float__` et :meth:`__complex__` ne sont pas "
"définies, alors les fonctions natives :func:`int`, :func:`float` et :func:"
"`complex` redirigent par défaut vers :meth:`__index__`."

#: reference/datamodel.rst:2504
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"Appelée pour implémenter la fonction native :func:`round` et les fonctions "
"du module :mod:`math` :func:`~math.trunc`, :func:`~math.floor` et :func:"
"`~math.ceil`. À moins que *ndigits* ne soit passé à :meth:`!__round__`, "
"toutes ces méthodes doivent renvoyer la valeur de l'objet tronquée pour "
"donner un :class:`~numbers.Integral` (typiquement un :class:`int`)."

#: reference/datamodel.rst:2510
msgid ""
"If :meth:`__int__` is not defined then the built-in function :func:`int` "
"falls back to :meth:`__trunc__`."
msgstr ""
"Si :meth:`__int__` n'est pas définie, alors la fonction native :func:`int` "
"se replie sur :meth:`__trunc__`."

#: reference/datamodel.rst:2517
msgid "With Statement Context Managers"
msgstr "Gestionnaire de contexte With"

#: reference/datamodel.rst:2519
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`!with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""
"Un :dfn:`gestionnaire de contexte` est un objet qui met en place un contexte "
"prédéfini au moment de l'exécution de l'instruction :keyword:`with`. Le "
"gestionnaire de contexte gère l'entrée et la sortie de ce contexte "
"d'exécution pour tout un bloc de code. Les gestionnaires de contextes sont "
"normalement invoqués en utilisant une instruction :keyword:`!with` (décrite "
"dans la section :ref:`with`), mais ils peuvent aussi être directement "
"invoqués par leurs méthodes."

#: reference/datamodel.rst:2530
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"Les utilisations classiques des gestionnaires de contexte sont la sauvegarde "
"et la restauration d'états divers, le verrouillage et le déverrouillage de "
"ressources, la fermeture de fichiers ouverts, etc."

#: reference/datamodel.rst:2533
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr ""
"Pour plus d'informations sur les gestionnaires de contexte, lisez :ref:"
"`typecontextmanager`."

#: reference/datamodel.rst:2538
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`!as` clause of the statement, if any."
msgstr ""
"Entre dans le contexte d'exécution relatif à cet objet. L'instruction :"
"keyword:`with` lie la valeur de retour de cette méthode à une (ou plusieurs) "
"cible spécifiée par la clause :keyword:`!as` de l'instruction, si elle est "
"spécifiée."

#: reference/datamodel.rst:2545
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"Sort du contexte d'exécution relatif à cet objet. Les paramètres décrivent "
"l'exception qui a causé la sortie du contexte. Si l'on sort du contexte sans "
"exception, les trois arguments sont à :const:`None`."

#: reference/datamodel.rst:2549
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"Si une exception est indiquée et que la méthode souhaite supprimer "
"l'exception (c'est-à-dire qu'elle ne veut pas que l'exception soit "
"propagée), elle doit renvoyer ``True``. Sinon, l'exception est traitée "
"normalement à la sortie de cette méthode."

#: reference/datamodel.rst:2553
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""
"Notez qu'une méthode :meth:`__exit__` ne doit pas lever à nouveau "
"l'exception qu'elle reçoit ; c'est du ressort de l'appelant."

#: reference/datamodel.rst:2560
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` — L'instruction ``with``"

#: reference/datamodel.rst:2560
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"La spécification, les motivations et des exemples de l'instruction :keyword:"
"`with` en Python."

#: reference/datamodel.rst:2567
msgid "Special method lookup"
msgstr "Recherche des méthodes spéciales"

#: reference/datamodel.rst:2569
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"Pour les classes définies par le développeur, l'invocation implicite de "
"méthodes spéciales n'est garantie que si ces méthodes sont définies par le "
"type d'objet, pas dans le dictionnaire de l'objet instance. Ce comportement "
"explique pourquoi le code suivant lève une exception ::"

#: reference/datamodel.rst:2584
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all "
"objects, including type objects. If the implicit lookup of these methods "
"used the conventional lookup process, they would fail when invoked on the "
"type object itself::"
msgstr ""
"La raison de ce comportement vient de certaines méthodes spéciales telles "
"que :meth:`__hash__` et :meth:`__repr__` qui sont implémentées par tous les "
"objets, y compris les objets types. Si la recherche effectuée par ces "
"méthodes utilisait le processus normal de recherche, elles ne "
"fonctionneraient pas si on les appelait sur l'objet type lui-même ::"

#: reference/datamodel.rst:2597
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""
"Essayer d'invoquer une méthode non liée d'une classe de cette manière est "
"parfois appelé « confusion de méta-classe » et se contourne en shuntant "
"l'instance lors de la recherche des méthodes spéciales ::"

#: reference/datamodel.rst:2606
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""
"En plus de shunter les attributs des instances pour fonctionner "
"correctement, la recherche des méthodes spéciales implicites shunte aussi la "
"méthode :meth:`__getattribute__` même dans la méta-classe de l'objet ::"

#: reference/datamodel.rst:2632
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides "
"significant scope for speed optimisations within the interpreter, at the "
"cost of some flexibility in the handling of special methods (the special "
"method *must* be set on the class object itself in order to be consistently "
"invoked by the interpreter)."
msgstr ""
"En shuntant le mécanisme de :meth:`__getattribute__` de cette façon, cela "
"permet d'optimiser la vitesse de l'interpréteur moyennant une certaine "
"manœuvre dans la gestion des méthodes spéciales (la méthode spéciale *doit* "
"être définie sur l'objet classe lui-même afin d'être invoquée de manière "
"cohérente par l'interpréteur)."

#: reference/datamodel.rst:2643
msgid "Coroutines"
msgstr "Coroutines"

#: reference/datamodel.rst:2647
msgid "Awaitable Objects"
msgstr "Objets *attendables* (*awaitable*)"

#: reference/datamodel.rst:2649
#, fuzzy
msgid ""
"An :term:`awaitable` object generally implements an :meth:`__await__` "
"method. :term:`Coroutine objects <coroutine>` returned from :keyword:`async "
"def` functions are awaitable."
msgstr ""
"Un objet :term:`awaitable` implémente généralement une méthode :meth:"
"`__await__`. Les objets :term:`Coroutine` renvoyés par les fonctions :"
"keyword:`async def` sont des *attendables* (*awaitable*)."

#: reference/datamodel.rst:2655
msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` or :func:`asyncio.coroutine` are also "
"awaitable, but they do not implement :meth:`__await__`."
msgstr ""
"Les objets :term:`itérateur de générateur` renvoyés par les générateurs "
"décorés par :func:`types.coroutine` ou :func:`asyncio.coroutine` sont aussi "
"des *attendables* (*awaitable*), mais ils n'implémentent pas :meth:"
"`__await__`."

#: reference/datamodel.rst:2661
msgid ""
"Must return an :term:`iterator`.  Should be used to implement :term:"
"`awaitable` objects.  For instance, :class:`asyncio.Future` implements this "
"method to be compatible with the :keyword:`await` expression."
msgstr ""
"Doit renvoyer un :term:`itérateur`. Doit être utilisé pour implémenter les "
"objets :term:`awaitable`. Par exemple, :class:`asyncio.Future` implémente "
"cette méthode pour être compatible avec les expressions :keyword:`await`."

#: reference/datamodel.rst:2667
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ""
":pep:`492` pour les informations relatives aux objets *attendables* "
"(*awaitable*)."

#: reference/datamodel.rst:2673
msgid "Coroutine Objects"
msgstr "Objets coroutines"

#: reference/datamodel.rst:2675
#, fuzzy
msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling :meth:`__await__` and "
"iterating over the result.  When the coroutine has finished executing and "
"returns, the iterator raises :exc:`StopIteration`, and the exception's :attr:"
"`~StopIteration.value` attribute holds the return value.  If the coroutine "
"raises an exception, it is propagated by the iterator.  Coroutines should "
"not directly raise unhandled :exc:`StopIteration` exceptions."
msgstr ""
"Les objets :term:`Coroutine` sont des objets :term:`awaitable`. L'exécution "
"d'une coroutine peut être contrôlée en appelant :meth:`__await__` et en "
"itérant sur le résultat. Quand la coroutine a fini de s'exécuter et termine, "
"l'itérateur lève :exc:`StopIteration` et l'attribut :attr:`~StopIteration."
"value` de l'exception contient la valeur de retour. Si la coroutine lève une "
"exception, elle est propagée par l'itérateur. Les coroutines ne doivent pas "
"lever directement des exceptions :exc:`StopIteration` non gérées."

#: reference/datamodel.rst:2683
msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"Les coroutines disposent aussi des méthodes listées ci-dessous, analogues à "
"celles des générateurs (voir :ref:`generator-methods`). Cependant, au "
"contraire des générateurs, vous ne pouvez pas itérer directement sur des "
"coroutines."

#: reference/datamodel.rst:2687
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr ""
"Utiliser *await* plus d'une fois sur une coroutine lève une :exc:"
"`RuntimeError`."

#: reference/datamodel.rst:2693
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned by :meth:`__await__`.  If "
"*value* is not ``None``, this method delegates to the :meth:`~generator."
"send` method of the iterator that caused the coroutine to suspend.  The "
"result (return value, :exc:`StopIteration`, or other exception) is the same "
"as when iterating over the :meth:`__await__` return value, described above."
msgstr ""
"Démarre ou reprend l'exécution d'une coroutine. Si *value* est ``None``, "
"c'est équivalent à avancer l'itérateur renvoyé par :meth:`__await__`. Si "
"*value* ne vaut pas ``None``, cette méthode appelle la méthode :meth:"
"`~generator.send` de l'itérateur qui a causé la suspension de la coroutine. "
"Le résultat (valeur de retour, :exc:`StopIteration` ou une autre exception) "
"est le même que lorsque vous itérez sur la valeur de retour de :meth:"
"`__await__`, décrite ci-dessus."

#: reference/datamodel.rst:2703
msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return value, :exc:"
"`StopIteration`, or other exception) is the same as when iterating over the :"
"meth:`__await__` return value, described above.  If the exception is not "
"caught in the coroutine, it propagates back to the caller."
msgstr ""
"Lève l'exception spécifiée dans la coroutine. Cette méthode délègue à la "
"méthode :meth:`~generator.throw` de l'itérateur qui a causé la suspension de "
"la coroutine, s'il possède une telle méthode. Sinon, l'exception est levée "
"au point de suspension. Le résultat (valeur de retour, :exc:`StopIteration` "
"ou une autre exception) est le même que lorsque vous itérez sur la valeur de "
"retour de :meth:`__await__`, décrite ci-dessus. Si l'exception n'est pas "
"gérée par la coroutine, elle est propagée à l'appelant."

#: reference/datamodel.rst:2714
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine "
"is marked as having finished executing, even if it was never started."
msgstr ""
"Demande à la coroutine de faire le ménage et de se terminer. Si la coroutine "
"est suspendue, cette méthode délègue d'abord à la méthode :meth:`~generator."
"close` de l'itérateur qui a causé la suspension de la coroutine, s'il "
"possède une telle méthode. Ensuite, elle lève :exc:`GeneratorExit` au point "
"de suspension, ce qui fait le ménage dans la coroutine immédiatement. Enfin, "
"la coroutine est marquée comme ayant terminé son exécution, même si elle n'a "
"jamais démarré."

#: reference/datamodel.rst:2722
msgid ""
"Coroutine objects are automatically closed using the above process when they "
"are about to be destroyed."
msgstr ""
"Les objets coroutines sont automatiquement fermés en utilisant le processus "
"décrit au-dessus au moment où ils sont détruits."

#: reference/datamodel.rst:2728
msgid "Asynchronous Iterators"
msgstr "Itérateurs asynchrones"

#: reference/datamodel.rst:2730
msgid ""
"An *asynchronous iterator* can call asynchronous code in its ``__anext__`` "
"method."
msgstr ""
"Un *itérateur asynchrone* peut appeler du code asynchrone dans sa méthode "
"``__anext__``."

#: reference/datamodel.rst:2733
msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr ""
"Les itérateurs asynchrones peuvent être utilisés dans des instructions :"
"keyword:`async for`."

#: reference/datamodel.rst:2737
msgid "Must return an *asynchronous iterator* object."
msgstr "Doit renvoyer un objet *itérateur asynchrone*."

#: reference/datamodel.rst:2741
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr ""
"Doit renvoyer un *attendable* (*awaitable*) qui se traduit par la valeur "
"suivante de l'itérateur. Doit lever une :exc:`StopAsyncIteration` quand "
"l'itération est terminée."

#: reference/datamodel.rst:2744
msgid "An example of an asynchronous iterable object::"
msgstr "Un exemple d'objet itérateur asynchrone ::"

#: reference/datamodel.rst:2761
msgid ""
"Prior to Python 3.7, ``__aiter__`` could return an *awaitable* that would "
"resolve to an :term:`asynchronous iterator <asynchronous iterator>`."
msgstr ""
"Avant Python 3.7, ``__aiter__`` pouvait renvoyer un *attendable* "
"(*awaitable*) qui se résolvait potentiellement en un :term:`itérateur "
"asynchrone <asynchronous iterator>`."

#: reference/datamodel.rst:2766
msgid ""
"Starting with Python 3.7, ``__aiter__`` must return an asynchronous iterator "
"object.  Returning anything else will result in a :exc:`TypeError` error."
msgstr ""
"À partir de Python 3.7, ``__aiter__`` doit renvoyer un objet itérateur "
"asynchrone. Renvoyer autre chose entraine une erreur :exc:`TypeError`."

#: reference/datamodel.rst:2774
msgid "Asynchronous Context Managers"
msgstr "Gestionnaires de contexte asynchrones"

#: reference/datamodel.rst:2776
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"Un *gestionnaire de contexte asynchrone* est un *gestionnaire de contexte* "
"qui est capable de suspendre son exécution dans ses méthodes ``__aenter__`` "
"et ``__aexit__``."

#: reference/datamodel.rst:2779
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr ""
"Les gestionnaires de contexte asynchrones peuvent être utilisés dans des "
"instructions :keyword:`async with`."

#: reference/datamodel.rst:2783
msgid ""
"Semantically similar to :meth:`__enter__`, the only difference being that it "
"must return an *awaitable*."
msgstr ""
"Sémantiquement équivalente à :meth:`__enter__`, à la seule différence près "
"qu'elle doit renvoyer un *attendable* (*awaitable*)."

#: reference/datamodel.rst:2788
msgid ""
"Semantically similar to :meth:`__exit__`, the only difference being that it "
"must return an *awaitable*."
msgstr ""
"Sémantiquement équivalente à :meth:`__exit__`, à la seule différence près "
"qu'elle doit renvoyer un *attendable* (*awaitable*)."

#: reference/datamodel.rst:2791
msgid "An example of an asynchronous context manager class::"
msgstr "Un exemple de classe de gestionnaire de contexte asynchrone ::"

#: reference/datamodel.rst:2804
msgid "Footnotes"
msgstr "Notes de bas de page"

#: reference/datamodel.rst:2805
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"Il *est* possible, dans certains cas, de changer le type d'un objet, sous "
"certaines conditions. Cependant, ce n'est généralement pas une bonne idée "
"car cela peut conduire à un comportement très étrange si ce n'est pas géré "
"correctement."

#: reference/datamodel.rst:2809
msgid ""
"The :meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, and :meth:"
"`__contains__` methods have special handling for this; others will still "
"raise a :exc:`TypeError`, but may do so by relying on the behavior that "
"``None`` is not callable."
msgstr ""
"Les méthodes :meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__` et :"
"meth:`__contains__` ont une gestion particulière pour cela ; les autres "
"lèvent toujours :exc:`TypeError`, mais le font en considérant que ``None`` "
"n'est pas un appelable."

#: reference/datamodel.rst:2814
msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns ``NotImplemented``.  Do not set the method to ``None`` if you "
"want to force fallback to the right operand's reflected method—that will "
"instead have the opposite effect of explicitly *blocking* such fallback."
msgstr ""
"*n'autorise pas* signifie ici que la classe ne possède pas de méthode "
"adéquate ou que la méthode renvoie ``NotImplemented``. N'assignez pas "
"``None`` à la méthode si vous voulez un repli vers la méthode symétrique de "
"l'opérande de droite — cela aurait pour effet de *bloquer* un tel repli."

#: reference/datamodel.rst:2820
#, fuzzy
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method -- such as :meth:`__add__` -- fails then the overall operation is not "
"supported, which is why the reflected method is not called."
msgstr ""
"Pour des opérandes de même type, on considère que si la méthode originelle "
"(telle que :meth:`__add__`) échoue, l'opération n'est pas autorisée et donc "
"la méthode symétrique n'est pas appelée."
