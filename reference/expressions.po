# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-22 22:57+0100\n"
"PO-Revision-Date: 2022-10-18 16:15+0200\n"
"Last-Translator: Jean Abou Samra <jean@abou-samra.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0\n"

#: reference/expressions.rst:6
msgid "Expressions"
msgstr "Expressions"

#: reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr ""
"Ce chapitre explique la signification des éléments des expressions en Python."

#: reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""
"**Notes sur la syntaxe :** dans ce chapitre et le suivant, nous utilisons la "
"notation BNF étendue pour décrire la syntaxe, pas l'analyse lexicale. Quand "
"une règle de syntaxe est de la forme"

#: reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""
"et qu'aucune sémantique n'est donnée, la sémantique de ``name`` est la même "
"que celle de ``othername``."

#: reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr "Conversions arithmétiques"

#: reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type\", this means that the "
"operator implementation for built-in types works as follows:"
msgstr ""
"Quand la description d'un opérateur arithmétique ci-dessous utilise la "
"phrase « les arguments numériques sont convertis vers un type commun », cela "
"signifie que l'implémentation de l'opérateur fonctionne de la manière "
"suivante pour les types natifs :"

#: reference/expressions.rst:34
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr ""
"Si l'un des deux arguments est du type nombre complexe, l'autre est converti "
"en nombre complexe ;"

#: reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""
"sinon, si l'un des arguments est un nombre à virgule flottante, l'autre est "
"converti en nombre à virgule flottante ;"

#: reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr ""
"sinon, les deux doivent être des entiers et aucune conversion n'est "
"nécessaire."

#: reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""
"Des règles supplémentaires s'appliquent pour certains opérateurs (par "
"exemple, une chaîne comme opérande de gauche pour l'opérateur ``%``). Les "
"extensions doivent définir leurs propres règles de conversion."

#: reference/expressions.rst:49
msgid "Atoms"
msgstr "Atomes"

#: reference/expressions.rst:53
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""
"Les atomes sont les éléments de base des expressions. Les atomes les plus "
"simples sont les identifiants et les littéraux. Les expressions entre "
"parenthèses, crochets ou accolades sont aussi classées syntaxiquement comme "
"des atomes. La syntaxe pour les atomes est :"

#: reference/expressions.rst:66
msgid "Identifiers (Names)"
msgstr "Identifiants (noms)"

#: reference/expressions.rst:70
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"Un identifiant qui apparaît en tant qu'atome est un nom. Lisez la section :"
"ref:`identifiers` pour la définition lexicale et la section :ref:`naming` "
"pour la documentation sur les noms et les liaisons afférentes."

#: reference/expressions.rst:76
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""
"Quand un nom est lié à un objet, l'évaluation de l'atome produit cet objet. "
"Quand le nom n'est pas lié, toute tentative de l'évaluer lève une exception :"
"exc:`NameError`."

#: reference/expressions.rst:86
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading "
"underscores removed and a single underscore inserted, in front of the name.  "
"For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""
"**Transformation des noms privés :** lorsqu'un identificateur qui apparaît "
"textuellement dans la définition d'une classe commence par deux (ou plus) "
"caractères de soulignement et ne se termine pas par deux (ou plus) "
"caractères de soulignement, il est considéré comme un :dfn:`nom privé "
"<private name>` de cette classe. Les noms privés sont transformés en une "
"forme plus longue avant que le code ne soit généré pour eux. La "
"transformation insère le nom de la classe, avec les soulignés enlevés et un "
"seul souligné inséré devant le nom. Par exemple, l'identificateur ``__spam`` "
"apparaissant dans une classe nommée ``Ham`` est transformé en "
"``_Ham__spam``. Cette transformation est indépendante du contexte syntaxique "
"dans lequel l'identificateur est utilisé. Si le nom transformé est "
"extrêmement long (plus de 255 caractères), l'implémentation peut le "
"tronquer. Si le nom de la classe est constitué uniquement de traits de "
"soulignement, aucune transformation n'est effectuée."

#: reference/expressions.rst:102
msgid "Literals"
msgstr "Littéraux"

#: reference/expressions.rst:106
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""
"Python gère les littéraux de chaînes de caractères, de chaînes d'octets et "
"de plusieurs autres types numériques :"

#: reference/expressions.rst:112
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating point number, complex number) with the given value.  The "
"value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""
"L'évaluation d'un littéral produit un objet du type donné (chaîne de "
"caractères, chaîne d'octets, entier, nombre à virgule flottante, nombre "
"complexe) avec la valeur donnée. La valeur peut être approximée dans le cas "
"des nombres à virgule flottante et des nombres imaginaires (complexes). "
"Reportez-vous à la section :ref:`literals` pour les détails."

#: reference/expressions.rst:121
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"Tous les littéraux sont de types immuables et donc l'identifiant de l'objet "
"est moins important que sa valeur. Des évaluations multiples de littéraux "
"avec la même valeur (soit la même occurrence dans le texte du programme, "
"soit une autre occurrence) résultent dans le même objet ou un objet "
"différent avec la même valeur."

#: reference/expressions.rst:131
msgid "Parenthesized forms"
msgstr "Formes parenthésées"

#: reference/expressions.rst:137
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""
"Une forme parenthésée est une liste d'expressions (cette liste est en fait "
"optionnelle) placée à l'intérieur de parenthèses :"

#: reference/expressions.rst:142
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"Une liste d'expressions entre parenthèses produit ce que la liste de ces "
"expressions produirait : si la liste contient au moins une virgule, elle "
"produit un *n*-uplet (type *n*-uplet) ; sinon, elle produit l'expression "
"elle-même (qui constitue donc elle-même la liste d'expressions)."

#: reference/expressions.rst:148
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the same rules as for literals apply (i.e., two occurrences of "
"the empty tuple may or may not yield the same object)."
msgstr ""
"Une paire de parenthèses vide produit un objet *n*-uplet vide. Comme les n-"
"uplets sont immuables, la même règle que pour les littéraux s'applique "
"(c'est-à-dire que deux occurrences du *n*-uplet vide peuvent, ou pas, "
"produire le même objet)."

#: reference/expressions.rst:156
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would "
"cause ambiguities and allow common typos to pass uncaught."
msgstr ""
"Notez que les *n*-uplets ne sont pas créés par les parenthèses mais par "
"l'utilisation de la virgule. L'exception est le *n*-uplet vide, pour lequel "
"les parenthèses *sont requises* (autoriser que « rien » ne soit pas "
"parenthésé dans les expressions aurait généré des ambigüités et aurait "
"permis à certaines coquilles de passer inaperçu)."

#: reference/expressions.rst:165
msgid "Displays for lists, sets and dictionaries"
msgstr "Agencements des listes, ensembles et dictionnaires"

#: reference/expressions.rst:169
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""
"Pour construire une liste, un ensemble ou un dictionnaire, Python fournit "
"des syntaxes spéciales dites « agencements » (*displays* en anglais), chaque "
"agencement comportant deux variantes :"

#: reference/expressions.rst:172
msgid "either the container contents are listed explicitly, or"
msgstr "soit le contenu du conteneur est listé explicitement,"

#: reference/expressions.rst:174
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""
"soit il est calculé à l'aide de la combinaison d'une boucle et "
"d'instructions de filtrage, appelée une :dfn:`compréhension` (dans le sens "
"de ce qui sert à définir un concept, par opposition à *extension*)."

#: reference/expressions.rst:182
msgid "Common syntax elements for comprehensions are:"
msgstr ""
"Les compréhensions sont constituées des éléments de syntaxe communs "
"suivants :"

#: reference/expressions.rst:190
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`!for` clause and zero or more :keyword:`!for` or :keyword:`!if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`!for` or :keyword:`!"
"if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce an element each time the innermost block is reached."
msgstr ""
"Une compréhension est constituée par une seule expression suivie par au "
"moins une clause :keyword:`!for` et zéro ou plus clauses :keyword:`!for` ou :"
"keyword:`!if`. Dans ce cas, les éléments du nouveau conteneur sont ceux qui "
"auraient été produits si l'on avait considéré toutes les clauses :keyword:`!"
"for` ou :keyword:`!if` comme des blocs, imbriqués de la gauche vers la "
"droite, et évalué l'expression pour produire un élément à chaque fois que le "
"bloc le plus imbriqué était atteint."

#: reference/expressions.rst:197
msgid ""
"However, aside from the iterable expression in the leftmost :keyword:`!for` "
"clause, the comprehension is executed in a separate implicitly nested scope. "
"This ensures that names assigned to in the target list don't \"leak\" into "
"the enclosing scope."
msgstr ""
"Cependant, à part l'expression de l'itérable dans la clause :keyword:`!for` "
"la plus à gauche, la compréhension est exécutée dans une portée séparée, "
"implicitement imbriquée. Ceci assure que les noms assignés dans la liste "
"cible ne « fuient » pas en dehors de cette portée."

#: reference/expressions.rst:201
msgid ""
"The iterable expression in the leftmost :keyword:`!for` clause is evaluated "
"directly in the enclosing scope and then passed as an argument to the "
"implicitly nested scope. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``[x*y for x in range(10) for y in range(x, x+10)]``."
msgstr ""
"L'expression de l'itérable dans la clause :keyword:`!for` la plus à gauche "
"est évaluée directement dans la portée englobante puis passée en tant "
"qu'argument à la portée implicite imbriquée. Les clauses :keyword:`!for` "
"suivantes et les filtres conditionnels de la clause :keyword:`!for` la plus "
"à gauche ne peuvent pas être évalués dans la portée englobante, car ils "
"peuvent dépendre de valeurs obtenues à partir de l'itérable le plus à "
"gauche. Par exemple : ``[x*y for x in range(10) for y in range(x, x+10)]``."

#: reference/expressions.rst:208
msgid ""
"To ensure the comprehension always results in a container of the appropriate "
"type, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly nested scope."
msgstr ""
"Pour assurer que le résultat de la compréhension soit un conteneur du type "
"approprié, les expressions ``yield`` et ``yield from`` sont interdites dans "
"la portée implicite imbriquée."

#: reference/expressions.rst:215
msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`!async "
"for` clause may be used to iterate over a :term:`asynchronous iterator`. A "
"comprehension in an :keyword:`!async def` function may consist of either a :"
"keyword:`!for` or :keyword:`!async for` clause following the leading "
"expression, may contain additional :keyword:`!for` or :keyword:`!async for` "
"clauses, and may also use :keyword:`await` expressions. If a comprehension "
"contains either :keyword:`!async for` clauses or :keyword:`!await` "
"expressions it is called an :dfn:`asynchronous comprehension`.  An "
"asynchronous comprehension may suspend the execution of the coroutine "
"function in which it appears. See also :pep:`530`."
msgstr ""
"Depuis Python 3.6, dans une fonction :keyword:`async def`, une clause :"
"keyword:`!async for` peut être utilisée pour itérer sur un :term:`itérateur "
"asynchrone <asynchronous iterator>`. Une compréhension dans une fonction :"
"keyword:`!async def` consiste alors à avoir une clause :keyword:`!for` or :"
"keyword:`!async for` suivie par des clauses :keyword:`!for` ou :keyword:`!"
"async for` additionnelles facultatives et, possiblement, des expressions :"
"keyword:`await`. Si la compréhension contient soit des clauses :keyword:`!"
"async for`, soit des expressions :keyword:`!await`, elle est appelée :dfn:"
"`compréhension asynchrone`. Une compréhension asynchrone peut suspendre "
"l'exécution de la fonction coroutine dans laquelle elle apparaît. Voir aussi "
"la :pep:`530`."

#: reference/expressions.rst:227
msgid "Asynchronous comprehensions were introduced."
msgstr "Les compréhensions asynchrones ont été introduites."

#: reference/expressions.rst:403
msgid "``yield`` and ``yield from`` prohibited in the implicitly nested scope."
msgstr ""
"``yield`` et ``yield from`` sont interdites dans la portée implicite "
"imbriquée."

#: reference/expressions.rst:237
msgid "List displays"
msgstr "Agencements de listes"

#: reference/expressions.rst:247
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""
"Un agencement de liste est une suite (possiblement vide) d'expressions à "
"l'intérieur de crochets :"

#: reference/expressions.rst:253
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Un agencement de liste produit un nouvel objet liste, dont le contenu est "
"spécifié soit par une liste d'expression soit par une compréhension. Quand "
"une liste d'expressions (dont les éléments sont séparés par des virgules) "
"est fournie, ces éléments sont évalués de la gauche vers la droite et placés "
"dans l'objet liste, dans cet ordre. Quand c'est une compréhension qui est "
"fournie, la liste est construite à partir des éléments produits par la "
"compréhension."

#: reference/expressions.rst:263
msgid "Set displays"
msgstr "Agencements d'ensembles"

#: reference/expressions.rst:272
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""
"Un agencement d'ensemble (type *set*) est délimité par des accolades et se "
"distingue de l'agencement d'un dictionnaire par le fait qu'il n'y a pas de "
"« deux points » ``:`` pour séparer les clés et les valeurs :"

#: reference/expressions.rst:278
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Un agencement d'ensemble produit un nouvel objet ensemble muable, le contenu "
"étant spécifié soit par une séquence d'expression, soit par une "
"compréhension. Quand une liste (dont les éléments sont séparés par des "
"virgules) est fournie, ses éléments sont évalués de la gauche vers la droite "
"et ajoutés à l'objet ensemble. Quand une compréhension est fournie, "
"l'ensemble est construit à partir des éléments produits par la compréhension."

#: reference/expressions.rst:284
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""
"Un ensemble vide ne peut pas être construit par ``{}`` ; cette écriture "
"construit un dictionnaire vide."

#: reference/expressions.rst:291
msgid "Dictionary displays"
msgstr "Agencements de dictionnaires"

#: reference/expressions.rst:302
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr ""
"Un agencement de dictionnaire est une série (possiblement vide) de couples "
"clés-valeurs entourée par des accolades :"

#: reference/expressions.rst:311
msgid "A dictionary display yields a new dictionary object."
msgstr "Un agencement de dictionnaire produit un nouvel objet dictionnaire."

#: reference/expressions.rst:313
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""
"Si une séquence (dont les éléments sont séparés par des virgules) de couples "
"clés-valeurs est fournie, les couples sont évalués de la gauche vers la "
"droite pour définir les entrées du dictionnaire : chaque objet clé est "
"utilisé comme clé dans le dictionnaire pour stocker la donnée "
"correspondante. Cela signifie que vous pouvez spécifier la même clé "
"plusieurs fois dans la liste des couples clés-valeurs et, dans ce cas, la "
"valeur finalement stockée dans le dictionnaire est la dernière donnée."

#: reference/expressions.rst:323
msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand "
"must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier key/datum "
"pairs and earlier dictionary unpackings."
msgstr ""
"Une double astérisque ``**`` demande de :dfn:`dépaqueter le dictionnaire`. "
"L'opérande doit être un :term:`tableau de correspondances <mapping>`. Chaque "
"élément du tableau de correspondances est ajouté au nouveau dictionnaire. "
"Les valeurs les plus récentes remplacent les valeurs déjà définies par des "
"couples clés-valeurs antérieurs ou par d'autres dépaquetages de "
"dictionnaires antérieurs."

#: reference/expressions.rst:328
msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr ""
"le dépaquetage peut se faire vers un agencement de dictionnaire, proposé à "
"l'origine par la :pep:`448`."

#: reference/expressions.rst:331
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""
"Une compréhension de dictionnaire, au contraire des compréhensions de listes "
"ou d'ensembles, requiert deux expressions séparées par une virgule et "
"suivies par les clauses usuelles \"for\" et \"if\". Quand la compréhension "
"est exécutée, les éléments clés-valeurs sont insérés dans le nouveau "
"dictionnaire dans l'ordre dans lequel ils sont produits."

#: reference/expressions.rst:339
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"Les restrictions relatives aux types des clés sont données dans la section :"
"ref:`types` (pour résumer, le type de la clé doit être :term:`hachable "
"<hashable>`, ce qui exclut tous les objets muables). Les collisions entre "
"les clés dupliquées ne sont pas détectées ; la dernière valeur (celle qui "
"apparaît le plus à droite dans l'agencement) stockée prévaut pour une clé "
"donnée."

#: reference/expressions.rst:345
msgid ""
"Prior to Python 3.8, in dict comprehensions, the evaluation order of key and "
"value was not well-defined.  In CPython, the value was evaluated before the "
"key.  Starting with 3.8, the key is evaluated before the value, as proposed "
"by :pep:`572`."
msgstr ""
"Avant Python 3.8, dans les compréhensions de dictionnaires, l'ordre "
"d'évaluation entre les clés et les valeurs n'était pas bien défini. Dans "
"CPython, la valeur était évaluée avant la clé. À partir de la version 3.8, "
"la clé est évaluée avant la valeur, comme proposé par la :pep:`572`."

#: reference/expressions.rst:355
msgid "Generator expressions"
msgstr "Expressions génératrices"

#: reference/expressions.rst:362
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""
"Une expression génératrice est une notation concise pour un générateur, "
"entourée de parenthèses :"

#: reference/expressions.rst:367
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""
"Une expression génératrice produit un nouvel objet générateur. Sa syntaxe "
"est la même que celle des compréhensions, sauf qu'elle est entourée de "
"parenthèses au lieu de crochets ou d'accolades."

#: reference/expressions.rst:371
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`~generator.__next__` method is called for the generator object (in the "
"same fashion as normal generators).  However, the iterable expression in the "
"leftmost :keyword:`!for` clause is immediately evaluated, so that an error "
"produced by it will be emitted at the point where the generator expression "
"is defined, rather than at the point where the first value is retrieved. "
"Subsequent :keyword:`!for` clauses and any filter condition in the leftmost :"
"keyword:`!for` clause cannot be evaluated in the enclosing scope as they may "
"depend on the values obtained from the leftmost iterable. For example: "
"``(x*y for x in range(10) for y in range(x, x+10))``."
msgstr ""
"Les variables utilisées dans une expression génératrice sont évaluées "
"paresseusement, au moment où la méthode :meth:`~generator.__next__` de "
"l'objet générateur est appelée (de la même manière que pour les générateurs "
"classiques). Cependant, l'expression de l'itérable dans la clause :keyword:`!"
"for` la plus à gauche est immédiatement évaluée, de manière à ce qu'une "
"erreur dans cette partie soit signalée à l'endroit où l'expression "
"génératrice est définie plutôt qu'à l'endroit où la première valeur est "
"récupérée. Les clauses :keyword:`!for` suivantes ne peuvent pas être "
"évaluées dans la portée implicite imbriquée car elles peuvent dépendre de "
"valeurs obtenues à partir de boucles :keyword:`!for` plus à gauche. Par "
"exemple, ``(x*y for x in range(10) for y in range(x, x+10))``."

#: reference/expressions.rst:382
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr ""
"Les parenthèses peuvent être omises pour les appels qui ne possèdent qu'un "
"seul argument. Voir la section :ref:`calls` pour les détails."

#: reference/expressions.rst:385
msgid ""
"To avoid interfering with the expected operation of the generator expression "
"itself, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly defined generator."
msgstr ""
"Pour éviter d'interférer avec l'opération attendue de l'expression "
"génératrice elle-même, les expressions ``yield`` et ``yield from`` sont "
"interdites dans les générateurs définis de manière implicite."

#: reference/expressions.rst:389
msgid ""
"If a generator expression contains either :keyword:`!async for` clauses or :"
"keyword:`await` expressions it is called an :dfn:`asynchronous generator "
"expression`.  An asynchronous generator expression returns a new "
"asynchronous generator object, which is an asynchronous iterator (see :ref:"
"`async-iterators`)."
msgstr ""
"Si une expression génératrice contient  une ou des expressions :keyword:`!"
"async for` ou :keyword:`await`, elle est appelée :dfn:`expression "
"génératrice asynchrone <asynchronous generator expression>`. Une expression "
"génératrice asynchrone produit un nouvel objet générateur asynchrone qui est "
"un itérateur asynchrone (voir :ref:`async-iterators`)."

#: reference/expressions.rst:395
msgid "Asynchronous generator expressions were introduced."
msgstr "les expressions génératrices asynchrones ont été introduites."

#: reference/expressions.rst:398
msgid ""
"Prior to Python 3.7, asynchronous generator expressions could only appear "
"in :keyword:`async def` coroutines.  Starting with 3.7, any function can use "
"asynchronous generator expressions."
msgstr ""
"Avant Python 3.7, les expressions génératrices asynchrones ne pouvaient "
"apparaître que dans les coroutines :keyword:`async def`. À partir de la "
"version 3.7, toute fonction peut utiliser des expressions génératrices "
"asynchrones."

#: reference/expressions.rst:410
msgid "Yield expressions"
msgstr "Expressions ``yield``"

#: reference/expressions.rst:422
msgid ""
"The yield expression is used when defining a :term:`generator` function or "
"an :term:`asynchronous generator` function and thus can only be used in the "
"body of a function definition.  Using a yield expression in a function's "
"body causes that function to be a generator function, and using it in an :"
"keyword:`async def` function's body causes that coroutine function to be an "
"asynchronous generator function. For example::"
msgstr ""
"Une expression ``yield`` est utilisée pour définir une :term:`fonction "
"génératrice <generator>` ou une :term:`fonction génératrice asynchrone "
"<asynchronous generator>` et ne peut donc être utilisée que dans le corps de "
"la définition d'une fonction. L'utilisation d'une expression ``yield`` dans "
"le corps d'une fonction entraîne que cette fonction devient une fonction "
"génératrice et son utilisation dans le corps d'une fonction :keyword:`async "
"def` entraine que cette fonction coroutine devient une fonction génératrice "
"asynchrone. Par exemple ::"

#: reference/expressions.rst:435
msgid ""
"Due to their side effects on the containing scope, ``yield`` expressions are "
"not permitted as part of the implicitly defined scopes used to implement "
"comprehensions and generator expressions."
msgstr ""
"En raison des effets de bords sur la portée contenant, les expressions "
"``yield`` ne sont pas autorisées dans la portée implicite utilisée dans "
"l'implémentation des compréhensions et des expressions génératrices."

#: reference/expressions.rst:439
msgid ""
"Yield expressions prohibited in the implicitly nested scopes used to "
"implement comprehensions and generator expressions."
msgstr ""
"Les expressions ``yield`` sont interdites dans la portée implicite imbriquée "
"utilisée dans l'implémentation des compréhensions et des expressions "
"génératrices."

#: reference/expressions.rst:443
msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-generator-"
"functions`."
msgstr ""
"Les fonctions génératrices sont décrites plus loin alors que les fonctions "
"générateurs asynchrones sont décrites séparément dans la section :ref:"
"`asynchronous-generator-functions`."

#: reference/expressions.rst:447
#, fuzzy
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function.  The execution starts when one of the generator's methods is "
"called. At that time, the execution proceeds to the first yield expression, "
"where it is suspended again, returning the value of :token:`~python-grammar:"
"expression_list` to the generator's caller, or ``None`` if :token:`~python-"
"grammar:expression_list` is omitted. By suspended, we mean that all local "
"state is retained, including the current bindings of local variables, the "
"instruction pointer, the internal evaluation stack, and the state of any "
"exception handling. When the execution is resumed by calling one of the "
"generator's methods, the function can proceed exactly as if the yield "
"expression were just another external call.  The value of the yield "
"expression after resuming depends on the method which resumed the "
"execution.  If :meth:`~generator.__next__` is used (typically via either a :"
"keyword:`for` or the :func:`next` builtin) then the result is :const:"
"`None`.  Otherwise, if :meth:`~generator.send` is used, then the result will "
"be the value passed in to that method."
msgstr ""
"Lorsqu'une fonction génératrice est appelée, elle renvoie un itérateur que "
"l'on appelle générateur. Ce générateur contrôle l'exécution de la fonction "
"génératrice. L'exécution commence lorsque l'une des méthodes du générateur "
"est appelée. À ce moment, l'exécution se déroule jusqu'à la première "
"expression ``yield``, où elle se suspend, renvoyant la valeur de :token:"
"`expression_list` à l'appelant du générateur. Cette suspension conserve tous "
"les états locaux, y compris les liaisons en cours des variables locales, le "
"pointeur d'instruction, la pile d'évaluation interne et l'état de tous les "
"gestionnaires d'exceptions.  Lorsque l'exécution reprend en appelant l'une "
"des méthodes du générateur, la fonction s'exécute exactement comme si "
"l'expression ``yield`` n'avait été qu'un simple appel externe. La valeur de "
"l'expression ``yield`` après reprise dépend de la méthode qui a permis la "
"reprise de l'exécution. Si c'est :meth:`~generator.__next__` qui a été "
"utilisée (typiquement *via* un :keyword:`for` ou la fonction native :func:"
"`next`) alors le résultat est :const:`None`. Sinon, si c'est :meth:"
"`~generator.send` qui a été utilisée, alors le résultat est la valeur "
"transmise à cette méthode."

#: reference/expressions.rst:467
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""
"Tout ceci rend les fonctions génératrices très similaires aux coroutines : "
"elles produisent plusieurs objets *via* des expressions ``yield``, elles "
"possèdent plus qu'un seul point d'entrée et leur exécution peut être "
"suspendue. La seule différence est qu'une fonction génératrice ne peut pas "
"contrôler où l'exécution doit se poursuivre après une instruction "
"``yield`` ; ce contrôle est toujours du ressort de l'appelant au générateur."

#: reference/expressions.rst:473
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's :"
"meth:`~generator.close` method will be called, allowing any pending :keyword:"
"`finally` clauses to execute."
msgstr ""
"Les expressions ``yield`` sont autorisées partout dans un bloc :keyword:"
"`try`. Si l'exécution du générateur ne reprend pas avant qu'il ne soit "
"finalisé (parce que son compteur de référence est tombé à zéro ou parce "
"qu'il est nettoyé par le ramasse-miettes), la méthode :meth:`~generator."
"close` du générateur-itérateur est appelée, ce qui permet l'exécution de "
"toutes les clauses :keyword:`finally` en attente."

#: reference/expressions.rst:482
msgid ""
"When ``yield from <expr>`` is used, the supplied expression must be an "
"iterable. The values produced by iterating that iterable are passed directly "
"to the caller of the current generator's methods. Any values passed in with :"
"meth:`~generator.send` and any exceptions passed in with :meth:`~generator."
"throw` are passed to the underlying iterator if it has the appropriate "
"methods.  If this is not the case, then :meth:`~generator.send` will raise :"
"exc:`AttributeError` or :exc:`TypeError`, while :meth:`~generator.throw` "
"will just raise the passed in exception immediately."
msgstr ""
"L'expression passée à ``yield from <expr>`` doit être un itérateur. Toutes "
"les valeurs produites par cet itérateur sont directement passées à "
"l'appelant des méthodes du générateur courant. Toute valeur passée par :meth:"
"`~generator.send` ou toute exception passée par :meth:`~generator.throw` est "
"transmise à l'itérateur sous-jacent s'il possède les méthodes appropriées. "
"Si ce n'est pas le cas, alors :meth:`~generator.send` lève une :exc:"
"`AttributeError` ou une :exc:`TypeError`, alors que :meth:`~generator.throw` "
"ne fait que propager l'exception immédiatement."

#: reference/expressions.rst:491
msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising :exc:"
"`StopIteration`, or automatically when the subiterator is a generator (by "
"returning a value from the subgenerator)."
msgstr ""
"Quand l'itérateur sous-jacent a terminé, l'attribut :attr:`~StopIteration."
"value` de l'instance :exc:`StopIteration` qui a été levée devient la valeur "
"produite par l'expression ``yield``. Elle peut être définie explicitement "
"quand vous levez :exc:`StopIteration` ou automatiquement que le sous-"
"itérateur est un générateur (en renvoyant une valeur par le sous-générateur)."

#: reference/expressions.rst:497
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr ""
"``yield from <expr>`` a été ajoutée pour déléguer le contrôle du flot "
"d'exécution à un sous-itérateur."

#: reference/expressions.rst:500
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr ""
"Les parenthèses peuvent être omises quand l'expression ``yield`` est la "
"seule expression à droite de l'instruction de l'instruction d'assignation."

#: reference/expressions.rst:506
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` : générateurs simples"

#: reference/expressions.rst:506
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""
"La proposition d'ajouter à Python des générateurs et l'instruction :keyword:"
"`yield`."

#: reference/expressions.rst:510
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` -- Coroutines *via* des générateurs améliorés"

#: reference/expressions.rst:509
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""
"Proposition d'améliorer l'API et la syntaxe des générateurs, de manière à "
"pouvoir les utiliser comme de simples coroutines."

#: reference/expressions.rst:514
msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` -- Syntaxe pour déléguer à un sous-générateur"

#: reference/expressions.rst:513
msgid ""
"The proposal to introduce the :token:`~python-grammar:yield_from` syntax, "
"making delegation to subgenerators easy."
msgstr ""
"Proposition d'introduire la syntaxe :token:`~python-grammar:yield_from`, de "
"manière à déléguer facilement l'exécution à un sous-générateur."

#: reference/expressions.rst:517
msgid ":pep:`525` - Asynchronous Generators"
msgstr ":pep:`525` : Générateurs asynchrones"

#: reference/expressions.rst:517
msgid ""
"The proposal that expanded on :pep:`492` by adding generator capabilities to "
"coroutine functions."
msgstr ""
"La proposition qui a amélioré la :pep:`492` en ajoutant des capacités de "
"générateur pour les coroutines."

#: reference/expressions.rst:524
msgid "Generator-iterator methods"
msgstr "Méthodes des générateurs-itérateurs"

#: reference/expressions.rst:526
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""
"Cette sous-section décrit les méthodes des générateurs-itérateurs. Elles "
"peuvent être utilisées pour contrôler l'exécution des fonctions générateurs."

#: reference/expressions.rst:529
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""
"Notez que l'appel à une méthode ci-dessous d'un générateur alors que le "
"générateur est déjà en cours d'exécution lève une exception :exc:"
"`ValueError`."

#: reference/expressions.rst:537
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a :"
"meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the :"
"token:`~python-grammar:expression_list` is returned to :meth:`__next__`'s "
"caller.  If the generator exits without yielding another value, a :exc:"
"`StopIteration` exception is raised."
msgstr ""
"Démarre l'exécution d'une fonction génératrice ou la reprend à la dernière "
"expression ``yield`` exécutée. Quand une fonction génératrice est reprise "
"par une méthode :meth:`~generator.__next__`, l'expression ``yield`` en cours "
"s'évalue toujours à :const:`None`. L'exécution continue ensuite jusqu'à "
"l'expression ``yield`` suivante, où le générateur est à nouveau suspendu et "
"la valeur de :token:`~python-grammar:expression_list` est renvoyée à la "
"méthode :meth:`__next__` de l'appelant. Si le générateur termine sans donner "
"une autre valeur, une exception :exc:`StopIteration` est levée."

#: reference/expressions.rst:546
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr ""
"Cette méthode est normalement appelée implicitement, par exemple par une "
"boucle :keyword:`for` ou par la fonction native :func:`next`."

#: reference/expressions.rst:552
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"Reprend l'exécution et « envoie » une valeur à la fonction générateur. "
"L'argument *value* devient le résultat de l'expression ``yield`` courante. "
"La méthode :meth:`send` renvoie la valeur suivante produite par le "
"générateur ou lève :exc:`StopIteration` si le générateur termine sans "
"produire de nouvelle valeur. Quand :meth:`send` est utilisée pour démarrer "
"le générateur, elle doit avoir :const:`None` comme argument, car il n'y a "
"aucune expression ``yield`` qui peut recevoir la valeur."

#: reference/expressions.rst:564
msgid ""
"Raises an exception at the point where the generator was paused, and returns "
"the next value yielded by the generator function.  If the generator exits "
"without yielding another value, a :exc:`StopIteration` exception is raised.  "
"If the generator function does not catch the passed-in exception, or raises "
"a different exception, then that exception propagates to the caller."
msgstr ""
"Lève une exception à l'endroit où le générateur est en pause et renvoie la "
"valeur suivante produite par la fonction génératrice. Si le générateur "
"termine sans produire de nouvelle valeur, une exception :exc:`StopIteration` "
"est levée. Si la fonction génératrice ne gère pas l'exception passée ou lève "
"une autre exception, alors cette exception est propagée vers l'appelant."

#: reference/expressions.rst:570
msgid ""
"In typical use, this is called with a single exception instance similar to "
"the way the :keyword:`raise` keyword is used."
msgstr ""
"Dans son utilisation typique, elle est appelée avec une seule instance "
"d'exception, de façon similaire à l'utilisation du mot-clé :keyword:`raise`."

#: reference/expressions.rst:573
msgid ""
"For backwards compatibility, however, the second signature is supported, "
"following a convention from older versions of Python. The *type* argument "
"should be an exception class, and *value* should be an exception instance. "
"If the *value* is not provided, the *type* constructor is called to get an "
"instance. If *traceback* is provided, it is set on the exception, otherwise "
"any existing :attr:`~BaseException.__traceback__` attribute stored in "
"*value* may be cleared."
msgstr ""

#: reference/expressions.rst:587
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then exits gracefully, is already closed, "
"or raises :exc:`GeneratorExit` (by not catching the exception), close "
"returns to its caller.  If the generator yields a value, a :exc:"
"`RuntimeError` is raised.  If the generator raises any other exception, it "
"is propagated to the caller.  :meth:`close` does nothing if the generator "
"has already exited due to an exception or normal exit."
msgstr ""
"Lève une :exc:`GeneratorExit` à l'endroit où la fonction génératrice a été "
"mise en pause. Si la fonction génératrice termine, est déjà fermée ou lève :"
"exc:`GeneratorExit` (parce qu'elle ne gère pas l'exception), *close* revient "
"vers l'appelant. Si le générateur produit une valeur, une  :exc:"
"`RuntimeError` est levée. Si le générateur lève une autre exception, elle "
"est propagée à l'appelant. La méthode :meth:`close` ne fait rien si le "
"générateur a déjà terminé en raison d'une exception ou d'une fin normale."

#: reference/expressions.rst:598
msgid "Examples"
msgstr "Exemples"

#: reference/expressions.rst:600
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""
"Voici un exemple simple qui montre le comportement des générateurs et des "
"fonctions génératrices ::"

#: reference/expressions.rst:627
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""
"Pour des exemples d'utilisation de ``yield from``, lisez la :ref:`pep-380` "
"dans « Les nouveautés de Python »."

#: reference/expressions.rst:633
msgid "Asynchronous generator functions"
msgstr "Fonctions génératrices asynchrones"

#: reference/expressions.rst:635
msgid ""
"The presence of a yield expression in a function or method defined using :"
"keyword:`async def` further defines the function as an :term:`asynchronous "
"generator` function."
msgstr ""
"La présence d'une expression *yield* dans une fonction ou une méthode "
"définie en utilisant :keyword:`async def` transforme cette fonction en "
"fonction :term:`générateur asynchrone <asynchronous generator>`."

#: reference/expressions.rst:639
msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That object "
"then controls the execution of the generator function. An asynchronous "
"generator object is typically used in an :keyword:`async for` statement in a "
"coroutine function analogously to how a generator object would be used in a :"
"keyword:`for` statement."
msgstr ""
"Quand une fonction génératrice asynchrone est appelée, elle renvoie un "
"itérateur asynchrone, autrement appelé objet générateur asynchrone. Cet "
"objet contrôle l'exécution de la fonction génératrice. Un objet générateur "
"asynchrone est typiquement utilisé dans une instruction :keyword:`async for` "
"à l'intérieur d'une fonction coroutine de la même manière qu'un objet "
"générateur serait utilisé dans une instruction :keyword:`for`."

#: reference/expressions.rst:646
msgid ""
"Calling one of the asynchronous generator's methods returns an :term:"
"`awaitable` object, and the execution starts when this object is awaited on. "
"At that time, the execution proceeds to the first yield expression, where it "
"is suspended again, returning the value of :token:`~python-grammar:"
"expression_list` to the awaiting coroutine. As with a generator, suspension "
"means that all local state is retained, including the current bindings of "
"local variables, the instruction pointer, the internal evaluation stack, and "
"the state of any exception handling. When the execution is resumed by "
"awaiting on the next object returned by the asynchronous generator's "
"methods, the function can proceed exactly as if the yield expression were "
"just another external call. The value of the yield expression after resuming "
"depends on the method which resumed the execution.  If :meth:`~agen."
"__anext__` is used then the result is :const:`None`. Otherwise, if :meth:"
"`~agen.asend` is used, then the result will be the value passed in to that "
"method."
msgstr ""
"L'appel d'une méthode du générateur asynchrone renvoie un objet :term:"
"`awaitable` et l'exécution commence au moment où l'on atteint une "
"instruction ``await`` le concernant. À ce moment, l'exécution se déroule "
"jusqu'à la première expression ``yield``, où elle est suspendue et renvoie "
"la valeur de :token:`~python-grammar:expression_list` à la coroutine en "
"attente. Comme pour un générateur, la suspension signifie que tous les états "
"locaux sont conservés, y compris les liaisons des variables locales, le "
"pointeur d'instruction, la pile d'évaluation interne et l'état de tous les "
"gestionnaires d'exceptions. Lorsque l'exécution reprend parce que l'appelant "
"a atteint une instruction ``await`` sur l'objet suivant retourné par les "
"méthodes du générateur asynchrone, la fonction s'exécute exactement comme si "
"l'expression ``yield`` n'avait été qu'un simple appel externe. La valeur de "
"l'expression ``yield`` au moment de la reprise dépend de la méthode qui a "
"relancé l'exécution. Si c'est :meth:`~agen.__anext__` qui a été utilisée, "
"alors le résultat est :const:`None`. Sinon, si c'est :meth:`~agen.asend` qui "
"a été utilisée, alors le résultat est la valeur transmise à cette méthode."

#: reference/expressions.rst:661
msgid ""
"If an asynchronous generator happens to exit early by :keyword:`break`, the "
"caller task being cancelled, or other exceptions, the generator's async "
"cleanup code will run and possibly raise exceptions or access context "
"variables in an unexpected context--perhaps after the lifetime of tasks it "
"depends, or during the event loop shutdown when the async-generator garbage "
"collection hook is called. To prevent this, the caller must explicitly close "
"the async generator by calling :meth:`~agen.aclose` method to finalize the "
"generator and ultimately detach it from the event loop."
msgstr ""
"Si un générateur asynchrone se termine précipitamment en raison d'un :"
"keyword:`break`, de l'annulation de la tâche de l'appelant ou d'une "
"exception, le code de nettoyage du générateur asynchrone est exécuté et lève "
"possiblement des exceptions, accède à des variables de contexte dans un "
"contexte inattendu — peut-être parce que la tâche de laquelle il dépend est "
"finie, ou pendant la fermeture de la boucle d'événements quand le point "
"d'entrée du ramasse-miettes a déjà été appelé. Afin d'éviter cette "
"situation, l'appelant doit explicitement fermer le générateur asynchrone en "
"appelant la méthode :meth:`~agen.aclose` pour « finaliser » le générateur et "
"le détacher de la boucle d'événements."

#: reference/expressions.rst:671
msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`!try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the responsibility "
"of the event loop or scheduler running the asynchronous generator to call "
"the asynchronous generator-iterator's :meth:`~agen.aclose` method and run "
"the resulting coroutine object, thus allowing any pending :keyword:`!"
"finally` clauses to execute."
msgstr ""
"Dans une fonction génératrice asynchrone, les expressions ``yield`` sont "
"autorisées n'importe où dans une construction :keyword:`try`. Cependant, si "
"l'exécution d'un générateur asynchrone n'a pas repris avant que le "
"générateur ne soit finalisé (parce que son compteur de référence a atteint "
"zéro ou parce qu'il est nettoyé par le ramasse-miettes), alors une "
"expression ``yield`` dans une construction :keyword:`!try` pourrait ne pas "
"atteindre la clause :keyword:`finally` en attente. Dans ce cas, c'est la "
"responsabilité de la boucle d'événements ou du programmateur exécutant le "
"générateur asynchrone d'appeler la méthode :meth:`~agen.aclose` du "
"générateur asynchrone et d'exécuter l'objet coroutine résultant, permettant "
"ainsi à toute clause :keyword:`!finally` en attente d'être exécutée."

#: reference/expressions.rst:682
#, fuzzy
msgid ""
"To take care of finalization upon event loop termination, an event loop "
"should define a *finalizer* function which takes an asynchronous generator-"
"iterator and presumably calls :meth:`~agen.aclose` and executes the "
"coroutine. This  *finalizer* may be registered by calling :func:`sys."
"set_asyncgen_hooks`. When first iterated over, an asynchronous generator-"
"iterator will store the registered *finalizer* to be called upon "
"finalization. For a reference example of a *finalizer* method see the "
"implementation of ``asyncio.Loop.shutdown_asyncgens`` in :source:`Lib/"
"asyncio/base_events.py`."
msgstr ""
"Pour effectuer correctement la finalisation, une boucle d'événements doit "
"définir une fonction *finalizer* qui prend un générateur-itérateur "
"asynchrone, appelle sans doute :meth:`~agen.aclose` et exécute la coroutine. "
"Ce *finalizer* peut s'enregistrer en appelant :func:`sys."
"set_asyncgen_hooks`. Lors de la première itération, un générateur-itérateur "
"asynchrone stocke le *finalizer* enregistré à appeler lors de la "
"finalisation. Pour un exemple de référence relatif à une méthode de "
"*finalizer*, regardez l'implémentation de ``asyncio.Loop."
"shutdown_asyncgens`` dans :source:`Lib/asyncio/base_events.py`."

#: reference/expressions.rst:691
msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr ""
"L'expression ``yield from <expr>`` produit une erreur de syntaxe quand elle "
"est utilisée dans une fonction génératrice asynchrone."

#: reference/expressions.rst:698
msgid "Asynchronous generator-iterator methods"
msgstr "Méthodes des générateurs-itérateurs asynchrones"

#: reference/expressions.rst:700
msgid ""
"This subsection describes the methods of an asynchronous generator iterator, "
"which are used to control the execution of a generator function."
msgstr ""
"Cette sous-section décrit les méthodes des générateurs-itérateurs "
"asynchrones. Elles sont utilisées pour contrôler l’exécution des fonctions "
"génératrices."

#: reference/expressions.rst:708
msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with an :meth:`~agen.__anext__` "
"method, the current yield expression always evaluates to :const:`None` in "
"the returned awaitable, which when run will continue to the next yield "
"expression. The value of the :token:`~python-grammar:expression_list` of the "
"yield expression is the value of the :exc:`StopIteration` exception raised "
"by the completing coroutine.  If the asynchronous generator exits without "
"yielding another value, the awaitable instead raises a :exc:"
"`StopAsyncIteration` exception, signalling that the asynchronous iteration "
"has completed."
msgstr ""
"Renvoie un *awaitable* qui, quand il a la main, démarre l'exécution du "
"générateur asynchrone ou reprend son exécution à l'endroit de la dernière "
"expression ``yield`` exécutée. Quand une fonction génératrice asynchrone est "
"reprise par une méthode :meth:`~agen.__anext__`, l’expression ``yield`` en "
"cours s’évalue toujours à :const:`None` dans le *awaitable* renvoyé, et elle "
"continue son exécution jusqu’à l’expression ``yield`` suivante. La valeur "
"de :token:`~python-grammar:expression_list` de l'expression ``yield`` est la "
"valeur de l'exception :exc:`StopIteration` levée par la coroutine qui "
"termine. Si le générateur asynchrone termine sans produire d'autre valeur, "
"le *awaitable* lève une exception :exc:`StopAsyncIteration` qui signale que "
"l'itération asynchrone est terminée."

#: reference/expressions.rst:720
msgid ""
"This method is normally called implicitly by a :keyword:`async for` loop."
msgstr ""
"Cette méthode est normalement appelée implicitement par une boucle :keyword:"
"`async for`."

#: reference/expressions.rst:725
msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send()` method for a "
"generator, this \"sends\" a value into the asynchronous generator function, "
"and the *value* argument becomes the result of the current yield expression. "
"The awaitable returned by the :meth:`asend` method will return the next "
"value yielded by the generator as the value of the raised :exc:"
"`StopIteration`, or raises :exc:`StopAsyncIteration` if the asynchronous "
"generator exits without yielding another value.  When :meth:`asend` is "
"called to start the asynchronous generator, it must be called with :const:"
"`None` as the argument, because there is no yield expression that could "
"receive the value."
msgstr ""
"Renvoie un *awaitable* qui, lorsqu'il a la main, reprend l'exécution du "
"générateur asynchrone. Comme pour la méthode :meth:`~generator.send()` d'un "
"générateur, elle « envoie » une valeur *value* à la fonction générateur "
"asynchrone et cet argument devient le résultat de l'expression ``yield`` "
"courante. Le *awaitable* renvoyé par la méthode :meth:`asend` renvoie la "
"valeur suivante produite par le générateur comme valeur de l'exception :exc:"
"`StopIteration` levée ou lève :exc:`StopAsyncIteration` si le générateur "
"asynchrone termine sans produire de nouvelle valeur. Quand :meth:`asend` est "
"appelée pour démarrer le générateur asynchrone, l'argument doit être :const:"
"`None` car il n'y a pas d'expression ``yield`` pour recevoir la valeur."

#: reference/expressions.rst:740
msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the point "
"where the asynchronous generator was paused, and returns the next value "
"yielded by the generator function as the value of the raised :exc:"
"`StopIteration` exception.  If the asynchronous generator exits without "
"yielding another value, a :exc:`StopAsyncIteration` exception is raised by "
"the awaitable. If the generator function does not catch the passed-in "
"exception, or raises a different exception, then when the awaitable is run "
"that exception propagates to the caller of the awaitable."
msgstr ""
"Renvoie un *awaitable* qui lève une exception du type ``type`` à l'endroit "
"où le générateur asynchrone a été mis en pause et renvoie la valeur suivante "
"produite par la fonction génératrice comme valeur de l'exception :exc:"
"`StopIteration` qui a été levée. Si le générateur asynchrone termine sans "
"produire de nouvelle valeur, une exception :exc:`StopAsyncIteration` est "
"levée par le *awaitable*. Si la fonction génératrice ne traite pas "
"l'exception reçue ou lève une autre exception alors, quand le *awaitable* "
"est lancé, cette exception est propagée vers l'appelant du *awaitable*."

#: reference/expressions.rst:755
msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into "
"the asynchronous generator function at the point where it was paused. If the "
"asynchronous generator function then exits gracefully, is already closed, or "
"raises :exc:`GeneratorExit` (by not catching the exception), then the "
"returned awaitable will raise a :exc:`StopIteration` exception. Any further "
"awaitables returned by subsequent calls to the asynchronous generator will "
"raise a :exc:`StopAsyncIteration` exception.  If the asynchronous generator "
"yields a value, a :exc:`RuntimeError` is raised by the awaitable.  If the "
"asynchronous generator raises any other exception, it is propagated to the "
"caller of the awaitable.  If the asynchronous generator has already exited "
"due to an exception or normal exit, then further calls to :meth:`aclose` "
"will return an awaitable that does nothing."
msgstr ""
"Renvoie un *awaitable* qui, quand il s'exécute, lève une exception :exc:"
"`GeneratorExit` dans la fonction génératrice asynchrone à l'endroit où le "
"générateur était en pause. Si la fonction génératrice asynchrone termine "
"normalement, est déjà fermée ou lève :exc:`GeneratorExit` (parce qu'elle ne "
"gère pas l'exception), alors le *awaitable* renvoyé lève une exception :exc:"
"`StopIteration`. Tout nouveau *awaitable* produit par un appel postérieur au "
"générateur asynchrone lève une exception :exc:`StopAsyncIteration`. Si le "
"générateur asynchrone produit une valeur, une :exc:`RuntimeError` est levée "
"par le *awaitable*. Si le générateur asynchrone lève une autre exception, "
"elle est propagée à l'appelant du *awaitable*. Si le générateur asynchrone a "
"déjà terminé (soit par une exception, soit normalement), alors tout nouvel "
"appel à :meth:`aclose` renvoie un *awaitable* qui ne fait rien."

#: reference/expressions.rst:771
msgid "Primaries"
msgstr "Primaires"

#: reference/expressions.rst:775
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""
"Les primaires (*primary* dans la grammaire formelle ci-dessous) représentent "
"les opérations qui se lient au plus proche dans le langage. Leur syntaxe "
"est :"

#: reference/expressions.rst:785
msgid "Attribute references"
msgstr "Références à des attributs"

#: reference/expressions.rst:791
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""
"Une référence à un attribut (*attributeref* dans la grammaire formelle ci-"
"dessous) est une primaire suivie par un point et un nom :"

#: reference/expressions.rst:801
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier.  This production can be customized "
"by overriding the :meth:`__getattr__` method.  If this attribute is not "
"available, the exception :exc:`AttributeError` is raised.  Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple "
"evaluations of the same attribute reference may yield different objects."
msgstr ""
"La primaire doit s'évaluer à un objet d'un type qui gère les références aux "
"attributs, ce qui est le cas de la plupart des objets. Cet objet doit alors "
"produire l'attribut dont le nom est « identifier ». Cette production peut "
"être personnalisée en surchargeant la méthode :meth:`__getattr__`. Si "
"l'attribut n'est pas disponible, une exception :exc:`AttributeError` est "
"levée. Sinon, le type et la valeur de l'objet produit sont déterminés par "
"l'objet. Plusieurs évaluations successives d'une référence à un même "
"attribut peuvent produire différents objets."

#: reference/expressions.rst:813
msgid "Subscriptions"
msgstr "Sélections"

#: reference/expressions.rst:828
msgid ""
"The subscription of an instance of a :ref:`container class <sequence-types>` "
"will generally select an element from the container. The subscription of a :"
"term:`generic class <generic type>` will generally return a :ref:"
"`GenericAlias <types-genericalias>` object."
msgstr ""
"L'indiçage d'une instance de :ref:`classe containeur <sequence-types>` "
"sélectionne généralement un élément du conteneur. L'indiçage d'une :term:"
"`classe générique <generic type>` renvoie généralement un objet :ref:"
"`GenericAlias <types-genericalias>`."

#: reference/expressions.rst:836
msgid ""
"When an object is subscripted, the interpreter will evaluate the primary and "
"the expression list."
msgstr ""
"Lorsqu'on accède à l'indice d'un objet, l'interpréteur évalue la primaire et "
"la liste d'expressions."

#: reference/expressions.rst:839
msgid ""
"The primary must evaluate to an object that supports subscription. An object "
"may support subscription through defining one or both of :meth:`~object."
"__getitem__` and :meth:`~object.__class_getitem__`. When the primary is "
"subscripted, the evaluated result of the expression list will be passed to "
"one of these methods. For more details on when ``__class_getitem__`` is "
"called instead of ``__getitem__``, see :ref:`classgetitem-versus-getitem`."
msgstr ""
"L'évaluation de la primaire doit produire un objet qui gère l'indiçage. Un "
"objet est susceptible de gérer l'indiçage s'il définit la ou les deux "
"méthodes :meth:`~object.__getitem__` et :meth:`~object.__class_getitem__`. "
"Quand on spécifie un indice du primaire, le résultat de l'évaluation de la "
"liste d'expression est passé à l'une de ces méthodes. Pour plus de détails "
"sur le choix de ``__class_getitem__`` ou ``__getitem__`` pour l'appel, "
"lisez :ref:`classgetitem-versus-getitem`."

#: reference/expressions.rst:846
msgid ""
"If the expression list contains at least one comma, it will evaluate to a :"
"class:`tuple` containing the items of the expression list. Otherwise, the "
"expression list will evaluate to the value of the list's sole member."
msgstr ""
"Si la liste d'expressions contient au moins une virgule, elle est considérée "
"comme un :class:`n-uplet <tuple>` contenant les éléments de la liste "
"d'expressions. Sinon, la liste d'expressions est évaluée à la valeur du seul "
"membre de la liste."

#: reference/expressions.rst:850
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription via :meth:`~object.__getitem__`:"
msgstr ""
"Pour les objets natifs, deux types d'objets gèrent la sélection *via* :meth:"
"`~object.__getitem__` :"

#: reference/expressions.rst:853
msgid ""
"Mappings. If the primary is a :term:`mapping`, the expression list must "
"evaluate to an object whose value is one of the keys of the mapping, and the "
"subscription selects the value in the mapping that corresponds to that key. "
"An example of a builtin mapping class is the :class:`dict` class."
msgstr ""
"Si la primaire est un :term:`tableau de correspondances <mapping>`, la liste "
"d'expressions (*expression_list* dans la grammaire formelle ci-dessous) doit "
"pouvoir être évaluée comme un objet dont la valeur est une des clés du "
"tableau de correspondances et la sélection désigne la valeur qui correspond "
"à cette clé. Un exemple de classe implémentant le concept de tableau de "
"correspondances est la classe :class:`dict`."

#: reference/expressions.rst:857
msgid ""
"Sequences. If the primary is a :term:`sequence`, the expression list must "
"evaluate to an :class:`int` or a :class:`slice` (as discussed in the "
"following section). Examples of builtin sequence classes include the :class:"
"`str`, :class:`list` and :class:`tuple` classes."
msgstr ""
"Si la primaire est une :term:`séquence <sequence>`, la liste d'expressions "
"(*expression_list* dans la grammaire) doit pouvoir être évaluée comme un :"
"class:`entier <int>` ou une :class:`tranche <slice>` (comme expliqué dans la "
"section suivante). Des exemples de classes natives implémentant le concept "
"de séquence sont les :class:`chaînes <str>`, :class:`listes <list>` et les :"
"class:`n-uplets <tuple>`."

#: reference/expressions.rst:862
msgid ""
"The formal syntax makes no special provision for negative indices in :term:"
"`sequences <sequence>`. However, built-in sequences all provide a :meth:"
"`~object.__getitem__` method that interprets negative indices by adding the "
"length of the sequence to the index so that, for example, ``x[-1]`` selects "
"the last item of ``x``. The resulting value must be a nonnegative integer "
"less than the number of items in the sequence, and the subscription selects "
"the item whose index is that value (counting from zero). Since the support "
"for negative indices and slicing occurs in the object's :meth:`__getitem__` "
"method, subclasses overriding this method will need to explicitly add that "
"support."
msgstr ""
"La syntaxe formelle ne traite pas des cas d'indices négatifs dans les :term:"
"`séquences <sequence>` ; cependant, toutes les séquences natives possèdent "
"une méthode :meth:`~object.__getitem__` qui interprète les indices négatifs "
"en ajoutant la longueur de la séquence à l'indice (de manière à ce que "
"``x[-1]`` sélectionne le dernier élément de ``x``). La valeur résultante "
"doit être un entier positif ou nul, inférieur au nombre d'éléments dans la "
"séquence ; la sélection désigne alors l'élément dont l'indice est cette "
"valeur (en comptant à partir de zéro). Comme la gestion des indices négatifs "
"et des tranches est faite par la méthode :meth:`__getitem__`, les sous-"
"classes qui surchargent cette méthode doivent aussi savoir les gérer, de "
"manière explicite."

#: reference/expressions.rst:876
msgid ""
"A :class:`string <str>` is a special kind of sequence whose items are "
"*characters*. A character is not a separate data type but a string of "
"exactly one character."
msgstr ""
"Une :class:`chaîne <str>` est une espèce particulière de séquence dont les "
"éléments sont des *caractères*. Un caractère n'est pas un type en tant que "
"tel, c'est une chaîne de longueur un."

#: reference/expressions.rst:884
msgid "Slicings"
msgstr "Tranches"

#: reference/expressions.rst:898
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"Une tranche (*slicing* dans la grammaire formelle ci-dessous) sélectionne un "
"intervalle d'éléments d'un objet séquence (par exemple une chaîne, un n-"
"uplet ou une liste, respectivement les types *string*, *tuple* et *list*). "
"Les tranches peuvent être utilisées comme des expressions ou des cibles dans "
"les assignations ou les instructions :keyword:`del`. La syntaxe est la "
"suivante :"

#: reference/expressions.rst:911
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""
"Il existe une ambigüité dans la syntaxe formelle ci-dessus : tout ce qui "
"ressemble à une liste d'expressions (*expression_list* vue avant) ressemble "
"aussi à une liste de tranches (*slice_list* dans la grammaire ci-dessus). En "
"conséquence, toute sélection (*subscription* dans la grammaire) peut être "
"interprétée comme une tranche. Plutôt que de compliquer encore la syntaxe, "
"l'ambigüité est levée en disant que, dans ce cas, l'interprétation en tant "
"que sélection (*subscription*) est prioritaire sur l'interprétation en tant "
"que tranche (c'est le cas si la liste de tranches (*slice_list*) ne contient "
"aucune tranche en tant que telle)."

#: reference/expressions.rst:923
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`__getitem__` method as normal subscription) with a key that "
"is constructed from the slice list, as follows.  If the slice list contains "
"at least one comma, the key is a tuple containing the conversion of the "
"slice items; otherwise, the conversion of the lone slice item is the key.  "
"The conversion of a slice item that is an expression is that expression.  "
"The conversion of a proper slice is a slice object (see section :ref:"
"`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice."
"step` attributes are the values of the expressions given as lower bound, "
"upper bound and stride, respectively, substituting ``None`` for missing "
"expressions."
msgstr ""
"La sémantique pour une tranche est définie comme suit. La primaire est "
"indicée (en utilisant la même méthode :meth:`__getitem__` que pour les "
"sélections normales) avec une clé qui est construite à partir de la liste de "
"tranches (*slice_list* dans la grammaire), de cette manière : si la liste de "
"tranches contient au moins une virgule (``,``), la clé est un *n*-uplet "
"contenant la conversion des éléments de la tranche ; sinon, la conversion du "
"seul élément de la tranche est la clé. La conversion d'un élément de tranche "
"qui est une expression est cette expression. La conversion d'une tranche en "
"tant que telle est un objet *slice* (voir la section :ref:`types`) dont les "
"attributs :attr:`~slice.start`, :attr:`~slice.stop` et :attr:`~slice.step` "
"sont les valeurs des expressions données pour la borne inférieure "
"(*lower_bound* dans la grammaire), la borne supérieure (*upper_bound* dans "
"la grammaire) et le pas (*stride* dans la grammaire), respectivement. En cas "
"d'expression manquante, la valeur par défaut est ``None``."

#: reference/expressions.rst:947
msgid "Calls"
msgstr "Appels"

#: reference/expressions.rst:949
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"Un appel (*call* dans la grammaire ci-dessous) appelle un objet appelable "
"(par exemple, une :term:`fonction <function>`) avec, possiblement, une liste "
"d'\\ :term:`arguments <argument>` :"

#: reference/expressions.rst:966
msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr ""
"Une virgule finale (optionnelle) peut être présente, après les arguments "
"positionnels et nommés, mais elle n'affecte pas la sémantique."

#: reference/expressions.rst:972
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""
"La primaire doit s'évaluer à un objet appelable (une fonction définie par "
"l'utilisateur, une fonction native, une méthode d'objet natif, un objet de "
"classe, une méthode d'instance de classe ou tout objet possédant une "
"méthode :meth:`__call__` est un appelable). Toutes les expressions des "
"arguments sont évaluées avant que l'appel ne soit exécuté. Référez-vous à la "
"section :ref:`function` pour la syntaxe des listes de :term:`paramètres "
"<parameter>` formels."

#: reference/expressions.rst:980
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr ""
"Si des arguments par mots-clés sont présents, ils sont d'abord convertis en "
"arguments positionnels, comme suit. Pour commencer, une liste de *slots* "
"vides est créée pour les paramètres formels. S'il y a N arguments "
"positionnels, ils sont placés dans les N premiers *slots*. Ensuite, pour "
"chaque argument par mot-clé, l'identifiant est utilisé pour déterminer le "
"*slot* correspondant (si l'identifiant est le même que le nom du premier "
"paramètre formel, le premier *slot* est utilisé, et ainsi de suite). Si le "
"*slot* est déjà rempli, une exception :exc:`TypeError` est levée. Sinon, la "
"valeur de l'argument est placée dans le *slot*, ce qui le remplit (même si "
"l'expression est ``None``, cela remplit le *slot*). Quand tous les arguments "
"ont été traités, les *slots* qui sont toujours vides sont remplis avec la "
"valeur par défaut correspondante dans la définition de la fonction (les "
"valeurs par défaut sont calculées, une seule fois, lorsque la fonction est "
"définie ; ainsi, un objet mutable tel qu'une liste ou un dictionnaire "
"utilisé en tant valeur par défaut sera partagé entre tous les appels qui ne "
"spécifient pas de valeur d argument pour ce *slot* ; on évite généralement "
"de faire ça). S'il reste des *slots* pour lesquels aucune valeur par défaut "
"n'est définie, une exception :exc:`TypeError` est levée. Sinon, la liste des "
"*slots* remplie est utilisée en tant que liste des arguments pour l'appel."

#: reference/expressions.rst:1000
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"Une implémentation peut fournir des fonctions natives dont les paramètres "
"positionnels n'ont pas de nom, même s'ils sont « nommés » pour les besoins "
"de la documentation. Ils ne peuvent donc pas être spécifiés par mot-clé. En "
"CPython, les fonctions implémentées en C qui utilisent :c:func:"
"`PyArg_ParseTuple` pour analyser leurs arguments en font partie."

#: reference/expressions.rst:1006
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""
"S'il y a plus d'arguments positionnels que de *slots* de paramètres formels, "
"une exception :exc:`TypeError` est levée, à moins qu'un paramètre formel "
"n'utilise la syntaxe ``*identifier`` ; dans ce cas, le paramètre formel "
"reçoit un *n*-uplet contenant les arguments positionnels en supplément (ou "
"un *n*-uplet vide s'il n'y avait pas d'argument positionnel en trop)."

#: reference/expressions.rst:1012
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"Si un argument par mot-clé ne correspond à aucun nom de paramètre formel, "
"une exception :exc:`TypeError` est levée, à moins qu'un paramètre formel "
"n'utilise la syntaxe ``**identifier`` ; dans ce cas, le paramètre formel "
"reçoit un dictionnaire contenant les arguments par mot-clé en trop (en "
"utilisant les mots-clés comme clés et les arguments comme valeurs pour ce "
"dictionnaire), ou un (nouveau) dictionnaire vide s'il n'y a pas d'argument "
"par mot-clé en trop."

#: reference/expressions.rst:1023
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an :term:`iterable`.  Elements from these iterables are "
"treated as if they were additional positional arguments.  For the call "
"``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+4 positional arguments *x1*, *x2*, "
"*y1*, ..., *yM*, *x3*, *x4*."
msgstr ""
"Si la syntaxe ``*expression`` apparaît dans l'appel de la fonction, "
"``expression`` doit pouvoir s'évaluer à un :term:`itérable <iterable>`. Les "
"éléments de ces itérables sont traités comme s'ils étaient des arguments "
"positionnels supplémentaires. Pour l'appel ``f(x1, x2, *y, x3, x4)``, si *y* "
"s'évalue comme une séquence *y1* … *yM*, c'est équivalent à un appel avec "
"M+4 arguments positionnels *x1*, *x2*, *y1* … *yM*, *x3*, *x4*."

#: reference/expressions.rst:1030
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* explicit keyword arguments, it is processed *before* the keyword "
"arguments (and any ``**expression`` arguments -- see below).  So::"
msgstr ""
"Une conséquence est que bien que la syntaxe ``*expression`` puisse "
"apparaître *après* les arguments par nommés explicites, ils sont traités "
"*avant* les arguments nommés (et avant tout argument ``**expression`` -- "
"voir ci-dessous). Ainsi ::"

#: reference/expressions.rst:1046
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr ""
"Il est inhabituel que les syntaxes d'arguments par mots-clés et "
"``*expression`` soient utilisés simultanément dans un même appel, ce qui "
"fait que la confusion reste hypothétique."

#: reference/expressions.rst:1052
#, fuzzy
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a :term:`mapping`, the contents of which are treated as "
"additional keyword arguments. If a parameter matching a key has already been "
"given a value (by an explicit keyword argument, or from another unpacking), "
"a :exc:`TypeError` exception is raised."
msgstr ""
"Si la syntaxe ``**expression`` apparaît dans un appel de fonction, "
"``expression`` doit pouvoir s'évaluer comme un :term:`tableau de "
"correspondances <mapping>`, dont le contenu est traité comme des arguments "
"par mots-clés supplémentaires. Si un mot-clé est déjà présent (en tant "
"qu'argument par mot-clé explicite, ou venant d'un autre dépaquetage), une "
"exception :exc:`TypeError` est levée."

#: reference/expressions.rst:1058
msgid ""
"When ``**expression`` is used, each key in this mapping must be a string. "
"Each value from the mapping is assigned to the first formal parameter "
"eligible for keyword assignment whose name is equal to the key. A key need "
"not be a Python identifier (e.g. ``\"max-temp °F\"`` is acceptable, although "
"it will not match any formal parameter that could be declared). If there is "
"no match to a formal parameter the key-value pair is collected by the ``**`` "
"parameter, if there is one, or if there is not, a :exc:`TypeError` exception "
"is raised."
msgstr ""

#: reference/expressions.rst:1068
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""
"Les paramètres formels qui utilisent la syntaxe ``*identifier`` ou "
"``**identifier`` ne peuvent pas être utilisés comme arguments positionnels "
"ou comme noms d'arguments par mots-clés."

#: reference/expressions.rst:1071
msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, positional "
"arguments may follow iterable unpackings (``*``), and keyword arguments may "
"follow dictionary unpackings (``**``). Originally proposed by :pep:`448`."
msgstr ""
"Les appels de fonction acceptent n'importe quel nombre de dépaquetages par "
"``*`` ou ``**``. Des arguments positionnels peuvent suivre les dépaquetages "
"d'itérables (``*``) et les arguments par mots-clés peuvent suivre les "
"dépaquetages de dictionnaires (``**``). Proposé pour la première fois par "
"la :pep:`448`."

#: reference/expressions.rst:1077
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""
"Un appel renvoie toujours une valeur, possiblement ``None``, à moins qu'il "
"ne lève une exception. La façon dont celle valeur est calculée dépend du "
"type de l'objet appelable."

#: reference/expressions.rst:1081
msgid "If it is---"
msgstr "Si c'est ---"

#: reference/expressions.rst:1094
msgid "a user-defined function:"
msgstr "une fonction définie par l'utilisateur :"

#: reference/expressions.rst:1090
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""
"le bloc de code de la fonction est exécuté, il reçoit la liste des "
"arguments. La première chose que le bloc de code fait est de lier les "
"paramètres formels aux arguments ; ceci est décrit dans la section :ref:"
"`function`. Quand le bloc de code exécute l'instruction :keyword:`return`, "
"cela spécifie la valeur de retour de l'appel de la fonction."

#: reference/expressions.rst:1108
msgid "a built-in function or method:"
msgstr "une fonction ou une méthode native :"

#: reference/expressions.rst:1107
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""
"le résultat dépend de l'interpréteur ; lisez :ref:`built-in-funcs` pour une "
"description des fonctions et méthodes natives."

#: reference/expressions.rst:1115
msgid "a class object:"
msgstr "un objet classe :"

#: reference/expressions.rst:1115
msgid "A new instance of that class is returned."
msgstr "une nouvelle instance de cette classe est renvoyée."

#: reference/expressions.rst:1125
msgid "a class instance method:"
msgstr "une méthode d'instance de classe :"

#: reference/expressions.rst:1123
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""
"la fonction correspondante définie par l'utilisateur est appelée, avec la "
"liste d'arguments qui est plus grande d'un élément que la liste des "
"arguments de l'appel : l'instance est placée en tête des arguments."

#: reference/expressions.rst:1134
msgid "a class instance:"
msgstr "une instance de classe :"

#: reference/expressions.rst:1132
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same "
"as if that method was called."
msgstr ""
"la classe doit définir une méthode :meth:`__call__` ; l'effet est le même "
"que si cette méthode était appelée."

#: reference/expressions.rst:1919
msgid "Await expression"
msgstr "Expression ``await``"

#: reference/expressions.rst:1142
msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` object. "
"Can only be used inside a :term:`coroutine function`."
msgstr ""
"Suspend l'exécution de la :term:`coroutine` sur un objet :term:`awaitable`. "
"Ne peut être utilisée qu'à l'intérieur d'une :term:`coroutine function`."

#: reference/expressions.rst:1154
msgid "The power operator"
msgstr "L'opérateur puissance"

#: reference/expressions.rst:1160
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"L'opérateur puissance est plus prioritaire que les opérateurs unaires sur sa "
"gauche ; il est moins prioritaire que les opérateurs unaires sur sa droite. "
"La syntaxe est :"

#: reference/expressions.rst:1166
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"Ainsi, dans une séquence sans parenthèse de puissance et d'opérateurs "
"unaires, les opérateurs sont évalués de droite à gauche (ceci ne contraint "
"pas l'ordre d'évaluation des opérandes) : ``-1**2`` donne ``-1``."

#: reference/expressions.rst:1170
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""
"L'opérateur puissance possède la même sémantique que la fonction native :"
"func:`pow` lorsqu'elle est appelée avec deux arguments : il produit son "
"argument de gauche élevé à la puissance de son argument de droite. Les "
"arguments numériques sont d'abord convertis vers un type commun et le "
"résultat est de ce type."

#: reference/expressions.rst:1175
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"Pour les opérandes entiers, le résultat est du même type à moins que le "
"deuxième argument ne soit négatif ; dans ce cas, tous les arguments sont "
"convertis en nombres à virgule flottante et le résultat est un nombre à "
"virgule flottante. Par exemple, ``10**2`` renvoie ``100`` mais ``10**-2`` "
"renvoie ``0.01``."

#: reference/expressions.rst:1180
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""
"Élever ``0.0`` à une puissance négative entraîne une :exc:"
"`ZeroDivisionError`. Élever un nombre négatif à une puissance fractionnaire "
"renvoie un nombre :class:`complexe <complex>` (dans les versions "
"antérieures, cela levait une :exc:`ValueError`)."

#: reference/expressions.rst:1184
msgid ""
"This operation can be customized using the special :meth:`__pow__` method."
msgstr ""
"La méthode spéciale qui permet de surcharger cet opérateur est :meth:"
"`__pow__`."

#: reference/expressions.rst:1189
msgid "Unary arithmetic and bitwise operations"
msgstr "Arithmétique unaire et opérations sur les bits"

#: reference/expressions.rst:1195
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""
"Toute l'arithmétique unaire et les opérations sur les bits ont la même "
"priorité :"

#: reference/expressions.rst:1206
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument; the operation can be overridden with the :meth:`__neg__` special "
"method."
msgstr ""
"L'opérateur unaire ``-`` (moins) produit l'opposé de son argument numérique "
"(la méthode spéciale qui le surcharge est :meth:`__neg__`) ;"

#: reference/expressions.rst:1214
msgid ""
"The unary ``+`` (plus) operator yields its numeric argument unchanged; the "
"operation can be overridden with the :meth:`__pos__` special method."
msgstr ""
"L'opérateur unaire ``+`` (plus) produit son argument numérique inchangé "
"(surcharge par la méthode :meth:`__pos__`) ;"

#: reference/expressions.rst:1221
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers or to custom objects that override the :"
"meth:`__invert__` special method."
msgstr ""
"L'opérateur unaire ``~`` (inversion) produit l'inversion bit à bit de son "
"argument entier. L'inversion bit à bit de ``x`` est définie comme ``-"
"(x+1)``. Elle ne s'applique qu'aux nombres entiers et aux objets allogènes "
"qui surchargent la méthode spéciale :meth:`__invert__`."

#: reference/expressions.rst:1230
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""
"Dans ces trois cas, si l'argument n'est pas du bon type, une exception :exc:"
"`TypeError` est levée."

#: reference/expressions.rst:1237
msgid "Binary arithmetic operations"
msgstr "Opérations arithmétiques binaires"

#: reference/expressions.rst:1241
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"Les opérations arithmétiques binaires suivent les conventions pour les "
"priorités. Notez que certaines de ces opérations s'appliquent aussi à des "
"types non numériques. À part l'opérateur puissance, il n'y a que deux "
"niveaux, le premier pour les opérateurs multiplicatifs et le second pour les "
"opérateurs additifs :"

#: reference/expressions.rst:1256
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""
"L'opérateur ``*`` (multiplication) produit le produit de ses arguments. Les "
"deux arguments doivent être des nombres ou alors le premier argument doit "
"être un entier et l'autre doit être une séquence. Dans le premier cas, les "
"nombres sont convertis dans un type commun puis sont multipliés entre eux. "
"Dans le dernier cas, la séquence est répétée ; une répétition négative "
"produit une séquence vide."

#: reference/expressions.rst:1262
msgid ""
"This operation can be customized using the special :meth:`__mul__` and :meth:"
"`__rmul__` methods."
msgstr ""
"Les méthodes spéciales qui permettent de surcharger cet opérateur sont :meth:"
"`__mul__` et :meth:`__rmul__`."

#: reference/expressions.rst:1269
msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication.  "
"No builtin Python types implement this operator."
msgstr ""
"L'opérateur ``@`` (prononcé *at* en anglais) a vocation à multiplier des "
"matrices. Aucun type Python natif n'implémente cet opérateur."

#: reference/expressions.rst:1280
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""
"Les opérateurs ``/`` (division) et ``//`` (division entière ou *floor "
"division* en anglais) produisent le quotient de leurs arguments. Les "
"arguments numériques sont d'abord convertis vers un type commun. La division "
"d'entiers produit un nombre à virgule flottante alors que la division "
"entière d'entiers produit un entier ; le résultat est celui de la division "
"mathématique suivie de la fonction ``floor`` appliquée au résultat. Une "
"division par zéro lève une exception :exc:`ZeroDivisionError`."

#: reference/expressions.rst:1287
msgid ""
"This operation can be customized using the special :meth:`__truediv__` and :"
"meth:`__floordiv__` methods."
msgstr ""
"Les méthodes spéciales qui permettent de surcharger ces opérations sont :"
"meth:`__truediv__` et :meth:`__floordiv__`."

#: reference/expressions.rst:1294
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"L'opérateur ``%`` (modulo) produit le reste de la division entière du "
"premier argument par le second. Les arguments numériques sont d'abord "
"convertis vers un type commun. Un zéro en second argument lève une "
"exception :exc:`ZeroDivisionError`. Les arguments peuvent être des nombres à "
"virgule flottante, par exemple ``3.14%0.7`` vaut ``0.34`` (puisque ``3.14`` "
"égale ``4*0.7+0.34``). L'opérateur modulo produit toujours un résultat du "
"même signe que le second opérande (ou zéro) ; la valeur absolue du résultat "
"est strictement inférieure à la valeur absolue du second opérande [#]_."

#: reference/expressions.rst:1303
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""
"Les opérateurs division entière et modulo sont liés par la relation "
"suivante : ``x == (x//y)*y + (x%y)``. La division entière et le module sont "
"aussi liés à la fonction native  :func:`divmod` : ``divmod(x, y) == (x//y, "
"x%y)`` [#]_."

#: reference/expressions.rst:1308
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""
"En plus de calculer le modulo sur les nombres, l'opérateur ``%`` est aussi "
"surchargé par les objets chaînes de caractères pour effectuer le formatage "
"de chaîne « à l'ancienne ». La syntaxe pour le formatage de chaînes est "
"décrit dans la référence de la bibliothèque Python, dans la section  :ref:"
"`old-string-formatting`."

#: reference/expressions.rst:1313
msgid ""
"The *modulo* operation can be customized using the special :meth:`__mod__` "
"method."
msgstr ""
"La méthode spéciale qui permet de surcharger cette opération est :meth:"
"`__mod__`."

#: reference/expressions.rst:1315
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""
"L'opérateur de division entière, l'opérateur modulo et la fonction  :func:"
"`divmod` ne sont pas définis pour les nombres complexes. À la place, vous "
"pouvez, si cela a du sens pour ce que vous voulez faire, les convertir vers "
"des nombres à virgule flottante en utilisant la fonction :func:`abs`."

#: reference/expressions.rst:1324
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common type and "
"then added together. In the latter case, the sequences are concatenated."
msgstr ""
"L'opérateur ``+`` (addition) produit la somme de ses arguments. Les "
"arguments doivent être tous les deux des nombres ou des séquences du même "
"type. Dans le premier cas, les nombres sont convertis vers un type commun "
"puis sont additionnés entre eux. Dans le dernier cas, les séquences sont "
"concaténées."

#: reference/expressions.rst:1329
msgid ""
"This operation can be customized using the special :meth:`__add__` and :meth:"
"`__radd__` methods."
msgstr ""
"Les méthodes spéciales qui permettent de surcharger cette opération sont :"
"meth:`__add__` et :meth:`__radd__`."

#: reference/expressions.rst:1337
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""
"L'opérateur ``-`` (soustraction) produit la différence entre ses arguments. "
"Les arguments numériques sont d'abord convertis vers un type commun."

#: reference/expressions.rst:1340
msgid ""
"This operation can be customized using the special :meth:`__sub__` method."
msgstr ""
"La méthode spéciale qui permet de surcharger cette opération est :meth:"
"`__sub__`."

#: reference/expressions.rst:1346
msgid "Shifting operations"
msgstr "Opérations de décalage"

#: reference/expressions.rst:1353
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""
"Les opérations de décalage sont moins prioritaires que les opérations "
"arithmétiques :"

#: reference/expressions.rst:1358
msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr ""
"Ces opérateurs prennent des entiers comme arguments. Ils décalent le premier "
"argument vers la gauche ou vers la droite du nombre de bits donné par le "
"deuxième argument."

#: reference/expressions.rst:1361
msgid ""
"This operation can be customized using the special :meth:`__lshift__` and :"
"meth:`__rshift__` methods."
msgstr ""
"Les méthodes spéciales qui permettent de surcharger ces opérations sont :"
"meth:`__lshift__` et :meth:`__rshift__`."

#: reference/expressions.rst:1366
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""
"Un décalage à droite de *n* bits est défini comme la division entière par "
"``pow(2,n)``. Un décalage à gauche de *n* bits est défini comme la "
"multiplication par ``pow(2,n)``."

#: reference/expressions.rst:1373
msgid "Binary bitwise operations"
msgstr "Opérations binaires bit à bit"

#: reference/expressions.rst:1377
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""
"Chacune des trois opérations binaires bit à bit possède une priorité "
"différente :"

#: reference/expressions.rst:1388
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers or one of them must be a custom object overriding :meth:`__and__` "
"or :meth:`__rand__` special methods."
msgstr ""
"L'opérateur ``&`` produit le ET logique de ses arguments. Ils doivent être "
"des entiers, sauf si celui de gauche surcharge la méthode spéciale :meth:"
"`__and__`, ou celui de droite la méthode :meth:`__rand__`."

#: reference/expressions.rst:1397
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers or one of them must be a custom object overriding :"
"meth:`__xor__` or :meth:`__rxor__` special methods."
msgstr ""
"L'opérateur ``^`` produit le OU EXCLUSIF (XOR) logique de ses arguments. Ils "
"doivent être des entiers, sauf à surcharger :meth:`__xor__` ou :meth:"
"`__rxor__`."

#: reference/expressions.rst:1406
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers or one of them must be a custom object overriding :meth:"
"`__or__` or :meth:`__ror__` special methods."
msgstr ""
"L'opérateur ``|`` produit le OU logique de ses arguments. Ils doivent être "
"des entiers, sauf à surcharger :meth:`__or__` ou :meth:`__ror__`."

#: reference/expressions.rst:1414
msgid "Comparisons"
msgstr "Comparaisons"

#: reference/expressions.rst:1426
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"Au contraire du C, toutes les opérations de comparaison en Python possèdent "
"la même priorité, qui est plus faible que celle des opérations "
"arithmétiques, décalages ou binaires bit à bit. Toujours contrairement au C, "
"les expressions telles que ``a < b < c`` sont interprétées comme elles le "
"seraient conventionnellement en mathématiques :"

#: reference/expressions.rst:1436
msgid ""
"Comparisons yield boolean values: ``True`` or ``False``. Custom :dfn:`rich "
"comparison methods` may return non-boolean values. In this case Python will "
"call :func:`bool` on such value in boolean contexts."
msgstr ""
"Les comparaisons donnent des valeurs booléennes (``True`` ou ``False``). "
"Cependant, les :dfn:`méthodes de comparaison riche` définies par "
"l'utilisateur peuvent renvoyer des non-booléens. Dans ce cas, le résultat de "
"la comparaison est converti en booléen avec :func:`bool` dans les contextes "
"qui attendent un booléen."

#: reference/expressions.rst:1442
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"Les comparaisons peuvent être enchaînées arbitrairement, par exemple ``x < y "
"<= z`` est équivalent à ``x < y and y <= z``, sauf que ``y`` est évalué "
"seulement une fois (mais dans les deux cas, ``z`` n'est pas évalué du tout "
"si ``x < y`` s'avère être faux)."

#: reference/expressions.rst:1446
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""
"Formellement, si *a*, *b*, *c* … *y*, *z* sont des expressions et *op1*, "
"*op2* … *opN* sont des opérateurs de comparaison, alors ``a op1 b op2 c … y "
"opN z`` est équivalent à ``a op1 b and b op2 c and … y opN z``, sauf que "
"chaque expression est évaluée au maximum une fois."

#: reference/expressions.rst:1451
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""
"Notez que ``a op1 b op2 c`` n'implique aucune comparaison entre *a* et *c*. "
"Ainsi, par exemple, ``x < y > z`` est parfaitement légal (mais peut-être pas "
"très élégant)."

#: reference/expressions.rst:1456
msgid "Value comparisons"
msgstr "Comparaisons de valeurs"

#: reference/expressions.rst:1458
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""
"Les opérateurs ``<``, ``>``, ``==``, ``>=``, ``<=`` et  ``!=`` comparent les "
"valeurs de deux objets. Les objets n'ont pas besoin d'être du même type."

#: reference/expressions.rst:1461
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type "
"and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
"Le chapitre :ref:`objects` indique que les objets ont une valeur (en plus "
"d'un type et d'un identifiant). La valeur d'un objet est une notion plutôt "
"abstraite en Python : par exemple, il n'existe pas de méthode canonique pour "
"accéder à la valeur d'un objet. De la même manière, il n'y a aucune "
"obligation concernant la construction de la valeur d'un objet, par exemple "
"qu'elle prenne en compte toutes les données de ses attributs. Les opérateurs "
"de comparaison implémentent une notion particulière de ce qu'est la valeur "
"d'un objet. Vous pouvez vous le représenter comme une définition indirecte "
"de la valeur d'un objet, *via* l'implémentation de leur comparaison."

#: reference/expressions.rst:1470
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they "
"inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`__lt__`, described in :ref:`customization`."
msgstr ""
"Comme tous les types sont des sous-types (directs ou indirects) de la "
"classe :class:`object`, ils héritent du comportement de comparaison par "
"défaut de :class:`object`.  Les types peuvent personnaliser le comportement "
"des comparaisons en implémentant des :dfn:`méthodes de comparaisons riches`, "
"comme :meth:`__lt__`, décrites dans :ref:`customization`."

#: reference/expressions.rst:1476
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on "
"the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"Le comportement par défaut pour le test d'égalité (``==`` et ``!=``) se base "
"sur les identifiants des objets. Ainsi, un test d'égalité entre deux "
"instances qui ont le même identifiant est vrai, un test d'égalité entre deux "
"instances qui ont des identifiants différents est faux. La raison de ce "
"choix est que Python souhaite que tous les objets soient réflexifs, c'est-à-"
"dire que ``x is y`` implique ``x == y``."

#: reference/expressions.rst:1483
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default "
"behavior is the lack of a similar invariant as for equality."
msgstr ""
"La relation d'ordre (``<``, ``>``, ``<=`` et ``>=``) n'est pas fournie par "
"défaut ; une tentative se solde par une :exc:`TypeError`. La raison de ce "
"choix est qu'il n'existe pas d'invariant similaire à celui de l'égalité."

#: reference/expressions.rst:1487
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"Le comportement du test d'égalité par défaut, à savoir que les instances "
"avec des identités différentes ne sont jamais égales, peut être en "
"contradiction avec les types qui définissent la « valeur » d'un objet et se "
"basent sur cette « valeur » pour l'égalité. De tels types doivent "
"personnaliser leurs tests de comparaison et, en fait, c'est ce qu'ont fait "
"un certain nombre de types natifs."

#: reference/expressions.rst:1493
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr ""
"La liste suivante décrit le comportement des tests d'égalité pour les types "
"natifs les plus importants."

#: reference/expressions.rst:1496
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex "
"numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss "
"of precision."
msgstr ""
"Beaucoup de types numériques natifs (:ref:`typesnumeric`) et de types de la "
"bibliothèque standard :class:`fractions.Fraction` ainsi que :class:`decimal."
"decimal` peuvent être comparés, au sein de leur propre classe ou avec "
"d'autres objets de classes différentes. Une exception notable concerne les "
"nombres complexes qui ne gèrent pas la relation d'ordre. Dans les limites "
"des types concernés, la comparaison mathématique équivaut à la comparaison "
"algorithmique, sans perte de précision."

#: reference/expressions.rst:1503
msgid ""
"The not-a-number values ``float('NaN')`` and ``decimal.Decimal('NaN')`` are "
"special.  Any ordered comparison of a number to a not-a-number value is "
"false. A counter-intuitive implication is that not-a-number values are not "
"equal to themselves.  For example, if ``x = float('NaN')``, ``3 < x``, ``x < "
"3`` and ``x == x`` are all false, while ``x != x`` is true.  This behavior "
"is compliant with IEEE 754."
msgstr ""
"Les valeurs non numériques ``float('NaN')`` et ``decimal.Decimal('NaN')`` "
"sont spéciales : toute comparaison entre un nombre et une valeur non "
"numérique est fausse. Une implication contre-intuitive à cela est que les "
"valeurs non numériques ne sont pas égales à elles-mêmes. Par exemple, avec "
"``x = float('NaN')``, les expressions ``3 < x``, ``x < 3`` et ``x == x`` "
"sont toutes fausses, mais l’expression ``x != x`` est vraie. Ce comportement "
"est en accord avec IEEE 754."

#: reference/expressions.rst:1510
msgid ""
"``None`` and ``NotImplemented`` are singletons.  :PEP:`8` advises that "
"comparisons for singletons should always be done with ``is`` or ``is not``, "
"never the equality operators."
msgstr ""
"``None`` et ``NotImplemented`` sont des singletons. :PEP:`8` conseille de "
"toujours comparer les singletons en utilisant soit ``is`` soit ``is not``, "
"jamais les autres opérateurs."

#: reference/expressions.rst:1514
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr ""
"Les séquences binaires (instances du type :class:`bytes` ou :class:"
"`bytearray`) peuvent être comparées au sein de la classe et entre classes. "
"La comparaison est lexicographique, en utilisant la valeur numérique des "
"éléments."

#: reference/expressions.rst:1518
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function :func:"
"`ord`) of their characters. [#]_"
msgstr ""
"Les chaînes de caractères (instances de :class:`str`) respectent l'ordre "
"lexicographique en utilisant la valeur Unicode (le résultat de la fonction "
"native :func:`ord`) des caractères [#]_."

#: reference/expressions.rst:1522
msgid "Strings and binary sequences cannot be directly compared."
msgstr ""
"Les chaînes de caractères et les séquences binaires ne peuvent pas être "
"comparées directement."

#: reference/expressions.rst:1524
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in inequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""
"Les séquences (instances de :class:`tuple`, :class:`list` ou :class:`range`) "
"peuvent être comparées uniquement entre instances de même type, en sachant "
"que les intervalles (*range*) ne gèrent pas la relation d'ordre. Le test "
"d'égalité entre ces types renvoie faux et une comparaison entre instances de "
"types différents lève une  :exc:`TypeError`."

#: reference/expressions.rst:1530
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements.  The built-in containers typically assume identical objects are "
"equal to themselves.  That lets them bypass equality tests for identical "
"objects to improve performance and to maintain their internal invariants."
msgstr ""
"Les séquences se comparent lexicographiquement en comparant les éléments "
"correspondants. Les conteneurs natifs supposent généralement que les objets "
"identiques sont égaux à eux-mêmes. Cela leur permet d'économiser les tests "
"d’égalité pour des objets identiques afin d’améliorer les performances et de "
"conserver leurs invariants internes."

#: reference/expressions.rst:1535
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr ""
"L'ordre lexicographique pour les collections natives fonctionne comme suit :"

#: reference/expressions.rst:1537
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"Deux collections sont égales si elles sont du même type, ont la même "
"longueur et si les éléments correspondants de chaque paire sont égaux. Par "
"exemple, ``[1,2] == (1,2)`` est faux car les types sont différents."

#: reference/expressions.rst:1542
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""
"Les collections qui gèrent la relation d'ordre sont ordonnées comme leur "
"premier élément différent (par exemple, ``[1,2,x] <= [1,2,y]`` a la même "
"valeur que ``x <= y``). Si un élément n'a pas de correspondant, la "
"collection la plus courte est la plus petite (par exemple, ``[1,2] < "
"[1,2,3]`` est vrai)."

#: reference/expressions.rst:1548
#, fuzzy
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have "
"equal ``(key, value)`` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr ""
"Les tableaux de correspondances (instances de :class:`dict`) sont égales si "
"et seulement si toutes leurs paires ``(clé, valeur)`` sont égales.  "
"L'égalité des clés et des valeurs met en œuvre la réflexivité."

#: reference/expressions.rst:1552
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr ""
"Les comparaisons (``<``, ``>``, ``<=`` et ``>=``) lèvent :exc:`TypeError`."

#: reference/expressions.rst:1554
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""
"Les ensembles (instances de :class:`set` ou :class:`frozenset`) peuvent être "
"comparés au sein de leur propre type et entre types différents."

#: reference/expressions.rst:1557
msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, :"
"func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""
"Les opérateurs d'inclusion et de sur-ensemble sont définis. Ces relations ne "
"sont pas des relations d'ordre total (par exemple, les deux ensembles ``{1,2}"
"`` et ``{2,3}`` ne sont pas égaux, l'un n'est pas inclus dans l'autre, l'un "
"n'est pas un sur-ensemble de l'autre). Ainsi, les ensembles ne sont pas des "
"arguments appropriés pour les fonctions qui dépendent d'un ordre total (par "
"exemple, les fonctions :func:`min`, :func:`max` et :func:`sorted` produisent "
"des résultats indéfinis si on leur donne des listes d'ensembles en entrée)."

#: reference/expressions.rst:1565
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr "La comparaison des ensembles met en œuvre la réflexivité des éléments."

#: reference/expressions.rst:1567
msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr ""
"La plupart des autres types natifs n'implémentent pas de méthodes de "
"comparaisons, ils héritent donc du comportement par défaut."

#: reference/expressions.rst:1570
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr ""
"Les classes allogènes qui particularisent les opérations de comparaison "
"doivent, si possible, respecter quelques règles pour la cohérence :"

#: reference/expressions.rst:1573
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr ""
"Le test d'égalité doit être réflexif. En d'autres termes, des objets "
"identiques doivent être égaux :"

#: reference/expressions.rst:1576
msgid "``x is y`` implies ``x == y``"
msgstr "``x is y`` implique ``x == y``"

#: reference/expressions.rst:1578
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr ""
"La comparaison doit être symétrique. En d'autres termes, les expressions "
"suivantes doivent donner le même résultat :"

#: reference/expressions.rst:1581
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` et ``y == x``"

#: reference/expressions.rst:1583
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` et ``y != x``"

#: reference/expressions.rst:1585
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` et ``y > x``"

#: reference/expressions.rst:1587
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` et ``y >= x``"

#: reference/expressions.rst:1589
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""
"La comparaison doit être transitive. Les exemples suivants (liste non "
"exhaustive) illustrent ce concept :"

#: reference/expressions.rst:1592
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y and y > z`` implique ``x > z``"

#: reference/expressions.rst:1594
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y and y <= z`` implique ``x < z``"

#: reference/expressions.rst:1596
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr ""
"Si vous inversez la comparaison, cela doit en produire la négation "
"booléenne. En d'autres termes, les expressions suivantes doivent produire le "
"même résultat :"

#: reference/expressions.rst:1599
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` et ``not x != y``"

#: reference/expressions.rst:1601
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` et ``not x >= y`` (pour une relation d'ordre total)"

#: reference/expressions.rst:1603
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` et ``not x <= y`` (pour une relation d'ordre total)"

#: reference/expressions.rst:1605
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the :func:`~functools."
"total_ordering` decorator."
msgstr ""
"Ces deux dernières expressions s'appliquent pour les collections totalement "
"ordonnées (par exemple, les séquences mais pas les ensembles ou les tableaux "
"de correspondances). Regardez aussi le décorateur :func:`~functools."
"total_ordering`."

#: reference/expressions.rst:1609
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are "
"equal should either have the same hash value, or be marked as unhashable."
msgstr ""
"Le résultat de :func:`hash` doit être cohérent avec l'égalité. Les objets "
"qui sont égaux doivent avoir la même empreinte ou être marqués comme non-"
"hachables."

#: reference/expressions.rst:1613
msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr ""
"Python ne vérifie pas ces règles de cohérence. En fait, l'utilisation de "
"valeurs non numériques est un exemple de non-respect de ces règles."

#: reference/expressions.rst:1622
msgid "Membership test operations"
msgstr "Opérations de tests d’appartenance à un ensemble"

#: reference/expressions.rst:1624
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which :"
"keyword:`!in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"Les opérateurs :keyword:`in` et :keyword:`not in` testent l’appartenance. "
"``x in s`` s’évalue à ``True`` si *x* appartient à *s* et à ``False`` sinon. "
"``x not in s`` renvoie la négation de ``x in s``. Tous les types séquences "
"et ensembles natifs gèrent ces opérateurs, ainsi que les dictionnaires pour "
"lesquels :keyword:`!in` teste si dictionnaire possède une clé donnée. Pour "
"les types conteneurs tels que les listes, *n*-uplets (*tuple*), ensembles "
"(*set*), ensembles figés (*frozen set*), dictionnaires (*dict*) ou "
"*collections.deque*, l’expression ``x in y`` est équivalente à ``any(x is e "
"or x == e for e in y)``."

#: reference/expressions.rst:1632
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is "
"a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"Pour les chaînes de caractères et chaînes d'octets, ``x in y`` vaut ``True`` "
"si et seulement si *x* est une sous-chaîne de *y*. Un test équivalent est "
"``y.find(x) != -1``. Une chaîne vide est considérée comme une sous-chaîne de "
"toute autre chaîne, ainsi ``\"\" in \"abc\"`` renvoie ``True``."

#: reference/expressions.rst:1637
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` returns ``True`` if ``y.__contains__(x)`` returns a true value, and "
"``False`` otherwise."
msgstr ""
"Pour les classes allogènes qui définissent la méthode :meth:`__contains__`, "
"``x in y`` renvoie ``True`` si ``y.__contains__(x)`` renvoie vrai, et "
"``False`` sinon."

#: reference/expressions.rst:1641
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z``, for "
"which the expression ``x is z or x == z`` is true, is produced while "
"iterating over ``y``. If an exception is raised during the iteration, it is "
"as if :keyword:`in` raised that exception."
msgstr ""
"Pour les classes allogènes qui ne définissent pas :meth:`__contains__` mais "
"qui définissent :meth:`__iter__`, ``x in y`` vaut ``True`` s'il existe une "
"valeur ``z`` telle que l'expression ``x is z or x == z`` renvoie vrai lors "
"de l'itération sur ``y``. Si une exception est levée pendant l'itération, "
"c'est comme si :keyword:`in` avait levé cette exception."

#: reference/expressions.rst:1647
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`__getitem__`, ``x in y`` is ``True`` if and only if there is a non-negative "
"integer index *i* such that ``x is y[i] or x == y[i]``, and no lower integer "
"index raises the :exc:`IndexError` exception.  (If any other exception is "
"raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"Enfin, le protocole d'itération « à l'ancienne » est essayé : si la classe "
"définit :meth:`__getitem__`, ``x in y`` est ``True`` si et seulement si il "
"existe un entier positif ou nul *i*, représentant l'indice, tel que ``x is "
"y[i] or x == y[i]`` et qu'aucun indice inférieur ne lève d'exception :exc:"
"`IndexError` (si toute autre exception est levée, c'est comme si :keyword:"
"`in` avait levé cette exception)."

#: reference/expressions.rst:1659
msgid ""
"The operator :keyword:`not in` is defined to have the inverse truth value "
"of :keyword:`in`."
msgstr ""
"L'opérateur :keyword:`not in` est défini comme produisant le contraire de :"
"keyword:`in`."

#: reference/expressions.rst:1672
msgid "Identity comparisons"
msgstr "Comparaisons d'identifiants"

#: reference/expressions.rst:1674
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for an object's "
"identity: ``x is y`` is true if and only if *x* and *y* are the same "
"object.  An Object's identity is determined using the :meth:`id` function.  "
"``x is not y`` yields the inverse truth value. [#]_"
msgstr ""
"Les opérateurs :keyword:`is` et :keyword:`is not` testent l'égalité des "
"identifiants des objets : ``x is y`` est vrai si et seulement si *x* et *y* "
"sont le même objet. L'identifiant d'un objet est déterminé en utilisant la "
"fonction :meth:`id`. ``x is not y`` renvoie le résultat contraire de "
"l'égalité des identifiants [#]_."

#: reference/expressions.rst:1686
msgid "Boolean operations"
msgstr "Opérations booléennes"

#: reference/expressions.rst:1697
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""
"Dans le contexte des opérations booléennes et quand des expressions sont "
"utilisées par des instructions de contrôle du flux d'exécution, les valeurs "
"suivantes sont considérées comme fausses : ``False``, ``None``, zéro quel "
"que soit le type, la chaîne vide et tout conteneur vide (y compris les "
"chaînes, *n*-uplets, listes, dictionnaires, ensembles, ensembles figés). "
"Toutes les autres valeurs sont considérées comme vraies. Les objets "
"allogènes peuvent personnaliser leur table de vérité en implémentant une "
"méthode :meth:`__bool__`."

#: reference/expressions.rst:1706
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""
"L'opérateur :keyword:`not` produit ``True`` si son argument est faux, "
"``False`` sinon."

#: reference/expressions.rst:1711
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"L'expression ``x and y`` commence par évaluer *x* ; si *x* est faux, sa "
"valeur est renvoyée ; sinon, *y* est évalué et la valeur résultante est "
"renvoyée."

#: reference/expressions.rst:1716
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"L'expression ``x or y`` commence par évaluer *x* ; si *x* est vrai, sa "
"valeur est renvoyée ; sinon, *y* est évalué et la valeur résultante est "
"renvoyée."

#: reference/expressions.rst:1719
msgid ""
"Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its "
"argument (for example, ``not 'foo'`` produces ``False`` rather than ``''``.)"
msgstr ""
"Notez que ni :keyword:`and` ni :keyword:`or` ne restreignent la valeur et le "
"type qu'ils renvoient à ``False`` et ``True`` : ils renvoient le dernier "
"argument évalué. Ceci peut être utile, par exemple : si une chaîne ``s`` "
"doit être remplacée par une valeur par défaut si elle est vide, l'expression "
"``s or 'truc'`` produit la valeur voulue. Comme :keyword:`not` doit créer "
"une nouvelle valeur, il renvoie une valeur booléenne quel que soit le type "
"de son argument (par exemple, ``not 'truc'`` produit ``False`` plutôt que "
"``''``."

#: reference/expressions.rst:1735
msgid "Assignment expressions"
msgstr "Expressions d'affectation"

#: reference/expressions.rst:1740
msgid ""
"An assignment expression (sometimes also called a \"named expression\" or "
"\"walrus\") assigns an :token:`~python-grammar:expression` to an :token:"
"`~python-grammar:identifier`, while also returning the value of the :token:"
"`~python-grammar:expression`."
msgstr ""
"Une expression d'affectation (parfois aussi appelée « expression nommée » ou "
"« expression morse ») affecte l':token:`expression <~python-grammar:"
"expression>` à un :token:`identifiant<~python-grammar:identifier>` et "
"renvoie la valeur de l':token:`~python-grammar:expression`."

#: reference/expressions.rst:1745
msgid "One common use case is when handling matched regular expressions:"
msgstr ""
"Une utilisation classique concerne les correspondances d'expressions "
"rationnelles :"

#: reference/expressions.rst:1752
msgid "Or, when processing a file stream in chunks:"
msgstr "Ou lorsqu'on traite le contenu d'un fichier par morceaux :"

#: reference/expressions.rst:1759
msgid ""
"Assignment expressions must be surrounded by parentheses when used as sub-"
"expressions in slicing, conditional, lambda, keyword-argument, and "
"comprehension-if expressions and in ``assert`` and ``with`` statements. In "
"all other places where they can be used, parentheses are not required, "
"including in ``if`` and ``while`` statements."
msgstr ""

#: reference/expressions.rst:1766
msgid "See :pep:`572` for more details about assignment expressions."
msgstr ""
"Voir la :pep:`572` pour plus de détails sur les expressions d’affectation."

#: reference/expressions.rst:1773
msgid "Conditional expressions"
msgstr "Expressions conditionnelles"

#: reference/expressions.rst:1785
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""
"Les expressions conditionnelles (parfois appelées « opérateur ternaire ») "
"sont les moins prioritaires de toutes les opérations Python."

#: reference/expressions.rst:1788
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""
"L'expression ``x if C else y`` commence par évaluer la condition *C*. Si *C* "
"est vrai, alors *x* est évalué et sa valeur est renvoyée ; sinon, *y* est "
"évalué et sa valeur est renvoyée."

#: reference/expressions.rst:1792
msgid "See :pep:`308` for more details about conditional expressions."
msgstr ""
"Voir la :pep:`308` pour plus de détails sur les expressions conditionnelles."

#: reference/expressions.rst:1799
msgid "Lambdas"
msgstr "Expressions lambda"

#: reference/expressions.rst:1810
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` yields "
"a function object.  The unnamed object behaves like a function object "
"defined with:"
msgstr ""
"Les expressions lambda sont utilisées pour créer des fonctions anonymes. "
"L'expression ``lambda parameters: expression`` produit un objet fonction. "
"Cet objet anonyme se comporte comme un objet fonction défini par :"

#: reference/expressions.rst:1819
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""
"Voir la section :ref:`function` pour la syntaxe des listes de paramètres. "
"Notez que les fonctions créées par des expressions lambda ne peuvent pas "
"contenir d'instructions ou d'annotations."

#: reference/expressions.rst:1827
msgid "Expression lists"
msgstr "Listes d'expressions"

#: reference/expressions.rst:1841
msgid ""
"Except when part of a list or set display, an expression list containing at "
"least one comma yields a tuple.  The length of the tuple is the number of "
"expressions in the list.  The expressions are evaluated from left to right."
msgstr ""
"Sauf lorsqu'elle fait partie d'un agencement de liste ou d'ensemble, une "
"liste d'expressions qui contient au moins une virgule produit un *n*-uplet. "
"La longueur du *n*-uplet est le nombre d'expressions dans la liste. Les "
"expressions sont évaluées de la gauche vers la droite."

#: reference/expressions.rst:1850
msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be "
"an :term:`iterable`.  The iterable is expanded into a sequence of items, "
"which are included in the new tuple, list, or set, at the site of the "
"unpacking."
msgstr ""
"Un astérisque ``*`` indique :dfn:`dépaquetage d'itérable` (*iterable "
"unpacking* en anglais). Son opérande doit être un :term:`iterable`. "
"L'itérable est développé en une séquence d'éléments qui sont inclus dans un "
"nouvel objet *n*-uplet, liste ou ensemble à l'emplacement du dépaquetage."

#: reference/expressions.rst:1855
msgid ""
"Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr ""
"dépaquetage d'itérables dans les listes d'expressions, proposé à l'origine "
"par la :pep:`448`."

#: reference/expressions.rst:1860
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value "
"of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""
"La virgule finale est nécessaire pour créer un singleton (c'est-à-dire un n-"
"uplet composé d'un seul élément) : elle est optionnelle dans tous les autres "
"cas. Une expression seule sans virgule finale ne crée pas un *n*-uplet mais "
"produit la valeur de cette expression (pour créer un *n*-uplet vide, "
"utilisez une paire de parenthèses vide : ``()``)."

#: reference/expressions.rst:1870
msgid "Evaluation order"
msgstr "Ordre d'évaluation"

#: reference/expressions.rst:1874
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""
"Python évalue les expressions de la gauche vers la droite. Remarquez que "
"lors de l'évaluation d'une assignation, la partie droite de l'assignation "
"est évaluée avant la partie gauche."

#: reference/expressions.rst:1877
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""
"Dans les lignes qui suivent, les expressions sont évaluées suivant l'ordre "
"arithmétique de leurs suffixes ::"

#: reference/expressions.rst:1891
msgid "Operator precedence"
msgstr "Priorités des opérateurs"

#: reference/expressions.rst:1896
msgid ""
"The following table summarizes the operator precedence in Python, from "
"highest precedence (most binding) to lowest precedence (least binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation, which groups from right to left)."
msgstr ""
"Le tableau suivant résume les priorités des opérateurs en Python, du plus "
"prioritaire (portée la plus courte) au moins prioritaire (portée la plus "
"grande). Les opérateurs qui sont dans la même case ont la même priorité. À "
"moins que la syntaxe ne soit explicitement indiquée, les opérateurs sont "
"binaires. Les opérateurs dans la même case regroupent de la gauche vers la "
"droite (sauf pour la puissance qui regroupe de la droite vers la gauche)."

#: reference/expressions.rst:1902
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr ""
"Notez que les comparaisons, les tests d'appartenance et les tests "
"d'identifiants possèdent tous la même priorité et s'enchaînent de la gauche "
"vers la droite comme décrit dans la section :ref:`comparisons`."

#: reference/expressions.rst:1908
msgid "Operator"
msgstr "Opérateur"

#: reference/expressions.rst:1908
msgid "Description"
msgstr "Description"

#: reference/expressions.rst:1910
msgid "``(expressions...)``,"
msgstr "``(expressions…)``,"

#: reference/expressions.rst:1912
msgid "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"
msgstr "``[expressions…]``, ``{key: value…}``, ``{expressions…}``"

#: reference/expressions.rst:1910
msgid ""
"Binding or parenthesized expression, list display, dictionary display, set "
"display"
msgstr ""
"Expression de liaison ou parenthèse, affichage de liste, affichage de "
"dictionnaire, affichage de *set*"

#: reference/expressions.rst:1916
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[indice]``, ``x[indice:indice]``, ``x(arguments…)``, ``x.attribut``"

#: reference/expressions.rst:1916
msgid "Subscription, slicing, call, attribute reference"
msgstr "indiçage, tranches, appel, référence à un attribut"

#: reference/expressions.rst:1919
msgid ":keyword:`await x <await>`"
msgstr ":keyword:`await x <await>`"

#: reference/expressions.rst:1921
msgid "``**``"
msgstr "``**``"

#: reference/expressions.rst:1921
msgid "Exponentiation [#]_"
msgstr "Puissance [#]_"

#: reference/expressions.rst:1923
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: reference/expressions.rst:1923
msgid "Positive, negative, bitwise NOT"
msgstr "NOT (positif, négatif, bit à bit)"

#: reference/expressions.rst:1925
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

#: reference/expressions.rst:1925
msgid ""
"Multiplication, matrix multiplication, division, floor division, remainder "
"[#]_"
msgstr ""
"Multiplication, multiplication de matrices, division, division entière, "
"reste [#]_"

#: reference/expressions.rst:1929
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: reference/expressions.rst:1929
msgid "Addition and subtraction"
msgstr "Addition et soustraction"

#: reference/expressions.rst:1931
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: reference/expressions.rst:1931
msgid "Shifts"
msgstr "décalages"

#: reference/expressions.rst:1933
msgid "``&``"
msgstr "``&``"

#: reference/expressions.rst:1933
msgid "Bitwise AND"
msgstr "AND (bit à bit)"

#: reference/expressions.rst:1935
msgid "``^``"
msgstr "``^``"

#: reference/expressions.rst:1935
msgid "Bitwise XOR"
msgstr "XOR (bit à bit)"

#: reference/expressions.rst:1937
msgid "``|``"
msgstr "``|``"

#: reference/expressions.rst:1937
msgid "Bitwise OR"
msgstr "OR (bit à bit)"

#: reference/expressions.rst:1939
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"

#: reference/expressions.rst:1939
msgid "Comparisons, including membership tests and identity tests"
msgstr ""
"Comparaisons, y compris les tests d'appartenance et les tests d'identifiants"

#: reference/expressions.rst:1943
msgid ":keyword:`not x <not>`"
msgstr ":keyword:`not x <not>`"

#: reference/expressions.rst:1943
msgid "Boolean NOT"
msgstr "NOT (booléen)"

#: reference/expressions.rst:1945
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: reference/expressions.rst:1945
msgid "Boolean AND"
msgstr "AND (booléen)"

#: reference/expressions.rst:1947
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: reference/expressions.rst:1947
msgid "Boolean OR"
msgstr "OR (booléen)"

#: reference/expressions.rst:1949
msgid ":keyword:`if <if_expr>` -- :keyword:`!else`"
msgstr ":keyword:`if <if_expr>` -- :keyword:`!else`"

#: reference/expressions.rst:1949
msgid "Conditional expression"
msgstr "Expressions conditionnelles"

#: reference/expressions.rst:1951
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: reference/expressions.rst:1951
msgid "Lambda expression"
msgstr "Expression lambda"

#: reference/expressions.rst:1953
msgid "``:=``"
msgstr "``:=``"

#: reference/expressions.rst:1953
msgid "Assignment expression"
msgstr "Expression d'affectation"

#: reference/expressions.rst:1958
msgid "Footnotes"
msgstr "Notes"

#: reference/expressions.rst:1959
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"Bien que ``abs(x%y) < abs(y)`` soit vrai mathématiquement, ce n'est pas "
"toujours vrai pour les nombres à virgule flottante en raison des arrondis. "
"Par exemple, en supposant que Python tourne sur une plateforme où les "
"*float* sont des nombres à double précision IEEE 754, afin que ``-1e-100 % "
"1e100`` soit du même signe que ``1e100``, le résultat calculé est ``-1e-100 "
"+ 1e100``, qui vaut exactement ``1e100`` dans ce standard. Or, la fonction :"
"func:`math.fmod` renvoie un résultat dont le signe est le signe du premier "
"argument, c'est-à-dire ``-1e-100`` dans ce cas. La meilleure approche dépend "
"de l'application."

#: reference/expressions.rst:1968
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""
"Si x est très proche d'un multiple entier de y, il est possible que ``x/y`` "
"soit supérieur de un par rapport à ``(x-x%y)//y`` en raison des arrondis. "
"Dans de tels cas, Python renvoie le second résultat afin d'avoir ``divmod(x,"
"y)[0] * y + x % y`` le plus proche de ``x``."

#: reference/expressions.rst:1973
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most "
"abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented "
"using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"Le standard Unicode distingue les :dfn:`points codes` (*code points* en "
"anglais, par exemple *U+0041*) et les :dfn:`caractères abstraits` (*abstract "
"characters* en anglais, par exemple « LATIN CAPITAL LETTER A »). Bien que la "
"plupart des caractères abstraits de l'Unicode ne sont représentés que par un "
"seul point code, il y a un certain nombre de caractères abstraits qui "
"peuvent être représentés par une séquence de plus qu'un point code. Par "
"exemple, le caractère abstrait « LATIN CAPITAL LETTER C WITH CEDILLA » peut "
"être représenté comme un unique :dfn:`caractère précomposé` au point code "
"*U+00C7*, ou en tant que séquence d'un :dfn:`caractère de base` à la "
"position *U+0043* (LATIN CAPITAL LETTER C) du code, suivi par un :dfn:"
"`caractère combiné` à la position *U+0327* (*COMBINING CEDILLA*) du code."

#: reference/expressions.rst:1984
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"`` is ``False``, even though both strings represent the "
"same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""
"Les opérateurs de comparaison des chaînes opèrent au niveau des points codes "
"Unicode. Cela peut être déroutant pour des humains. Par exemple, "
"``\"\\u00C7\" == \"\\u0043\\u0327\"`` renvoie ``False``, bien que les deux "
"chaînes représentent le même caractère abstrait \"LATIN CAPITAL LETTER C "
"WITH CEDILLA\"."

#: reference/expressions.rst:1989
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""
"Pour comparer des chaînes au niveau des caractères abstraits (afin d'avoir "
"quelque chose d'intuitif pour les humains), utilisez :func:`unicodedata."
"normalize`."

#: reference/expressions.rst:1992
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"En raison du ramasse-miettes automatique et de la nature dynamique des "
"descripteurs, vous pouvez être confronté à un comportement semblant bizarre "
"lors de certaines utilisations de l'opérateur :keyword:`is`, par exemple si "
"cela implique des comparaisons entre des méthodes d'instances ou des "
"constantes. Allez vérifier dans la documentation pour plus d'informations."

#: reference/expressions.rst:1997
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"L'opérateur puissance ``**`` est moins prioritaire qu'un opérateur unaire "
"arithmétique ou bit à bit sur sa droite. Ainsi, ``2**-1`` vaut ``0.5``."

#: reference/expressions.rst:2000
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""
"L'opérateur ``%`` est aussi utilisé pour formater les chaînes de "
"caractères ; il y possède la même priorité."

#~ msgid ""
#~ "Subscription of a sequence (string, tuple or list) or mapping "
#~ "(dictionary) object usually selects an item from the collection:"
#~ msgstr ""
#~ "Une sélection (*subscription* dans la grammaire formelle ci-dessous) dans "
#~ "un objet séquence (chaîne, *n*-uplet ou liste) ou tableau associatif "
#~ "(dictionnaire) désigne un élément dans cette séquence :"

#~ msgid ""
#~ "The primary must evaluate to an object that supports subscription (lists "
#~ "or dictionaries for example).  User-defined objects can support "
#~ "subscription by defining a :meth:`__getitem__` method."
#~ msgstr ""
#~ "La primaire doit s'appliquer à un objet qui gère les sélections (une "
#~ "liste ou un dictionnaire par exemple). Les objets définis par "
#~ "l'utilisateur peuvent gérer les sélections en définissant une méthode :"
#~ "meth:`__getitem__`."

#~ msgid ""
#~ "Subscription of certain :term:`classes <class>` or :term:`types <type>` "
#~ "creates a :ref:`generic alias <types-genericalias>`. In this case, user-"
#~ "defined classes can support subscription by providing a :meth:"
#~ "`__class_getitem__` classmethod."
#~ msgstr ""
#~ "La sélection dans certains :term:`classes <class>` ou :term:`types "
#~ "<type>` crée un :ref:`alias générique <types-genericalias>`. Dans ce cas, "
#~ "les classes définies par l'utilisateur peuvent gérer la sélection en "
#~ "fournissant une méthode de classe :meth:`__class_getitem__`."

#~ msgid "Comparisons yield boolean values: ``True`` or ``False``."
#~ msgstr ""
#~ "Les comparaisons produisent des valeurs booléennes : ``True`` ou "
#~ "``False``."
