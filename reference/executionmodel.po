# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-23 16:48+0200\n"
"PO-Revision-Date: 2019-05-23 21:53+0200\n"
"Last-Translator: Jules Lasne <jules.lasne@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.1\n"

#: ../Doc/reference/executionmodel.rst:6
msgid "Execution model"
msgstr "Modèle d'exécution"

#: ../Doc/reference/executionmodel.rst:15
msgid "Structure of a program"
msgstr "Structure d'un programme"

#: ../Doc/reference/executionmodel.rst:19
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks: "
"a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the :option:`-c` option) is a code block.  The string "
"argument passed to the built-in functions :func:`eval` and :func:`exec` is a "
"code block."
msgstr ""
"Un programme Python est construit à partir de blocs de code. Un :dfn:`block` "
"est un morceau de texte de programme Python qui est exécuté en tant "
"qu'unité. Les éléments suivants sont des blocs : un module, un corps de "
"fonction et une définition de classe. Chaque commande écrite dans "
"l'interpréteur interactif de Python est un bloc. Un fichier de script (un "
"fichier donné en entrée standard à l'interpréteur ou spécifié en tant "
"qu'argument de ligne de commande à l'interpréteur) est un bloc de code. Une "
"commande de script (une commande spécifiée sur la ligne de commande de "
"l'interpréteur avec l'option :option:`-c`) est un bloc de code. La chaîne "
"passée en argument aux fonctions natives :func:`eval` et :func:`exec` est un "
"bloc de code."

#: ../Doc/reference/executionmodel.rst:31
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr ""
"Un bloc de code est exécuté dans un :dfn:`cadre d'exécution`. Un cadre "
"contient des informations administratives (utilisées pour le débogage) et "
"détermine où et comment l'exécution se poursuit après la fin de l'exécution "
"du bloc de code."

#: ../Doc/reference/executionmodel.rst:38
msgid "Naming and binding"
msgstr "Noms et liaisons"

#: ../Doc/reference/executionmodel.rst:47
msgid "Binding of names"
msgstr "Liaisons des noms"

#: ../Doc/reference/executionmodel.rst:53
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ""
"Les :dfn:`noms` sont des références aux objets. Ils sont créés lors des "
"opérations de liaisons de noms (*name binding* en anglais)."

#: ../Doc/reference/executionmodel.rst:57
msgid ""
"The following constructs bind names: formal parameters to functions, :"
"keyword:`import` statements, class and function definitions (these bind the "
"class or function name in the defining block), and targets that are "
"identifiers if occurring in an assignment, :keyword:`for` loop header, or "
"after :keyword:`!as` in a :keyword:`with` statement or :keyword:`except` "
"clause. The :keyword:`!import` statement of the form ``from ... import *`` "
"binds all names defined in the imported module, except those beginning with "
"an underscore.  This form may only be used at the module level."
msgstr ""
"Les constructions suivantes conduisent à des opérations de liaison à des "
"noms : les paramètres formels d'une fonction, les instructions :keyword:"
"`import`, les définitions de fonctions et de classes (le nom de la classe ou "
"de la fonction est lié au bloc qui la définit) et les cibles qui sont des "
"identifiants dans les assignations, les entêtes de boucles :keyword:`for` ou "
"après :keyword:`!as` dans une instruction :keyword:`with` ou une clause :"
"keyword:`except`. L'instruction :keyword:`!import` sous la forme ``from ... "
"import *`` lie tous les noms définis dans le module importé, sauf ceux qui "
"commencent par un tiret bas (`'_'`). Cette forme ne doit être utilisée qu'au "
"niveau du module."

#: ../Doc/reference/executionmodel.rst:67
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ""
"Une cible qui apparaît dans une instruction :keyword:`del` est aussi "
"considérée comme une liaison à un nom dans ce cadre (bien que la sémantique "
"véritable soit de délier le nom)."

#: ../Doc/reference/executionmodel.rst:70
msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""
"Chaque assignation ou instruction *import* a lieu dans un bloc défini par "
"une définition de classe ou de fonction ou au niveau du module (le bloc de "
"code de plus haut niveau)."

#: ../Doc/reference/executionmodel.rst:75
msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at "
"the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but "
"not defined there, it is a :dfn:`free variable`."
msgstr ""
"Si un nom est lié dans un bloc, c'est une variable locale de ce bloc, à "
"moins qu'il ne soit déclaré :keyword:`nonlocal` ou :keyword:`global`. Si un "
"nom est lié au niveau du module, c'est une variable globale (les variables "
"du bloc de code de niveau module sont locales et globales). Si une variable "
"est utilisée dans un bloc de code alors qu'elle n'y est pas définie, c'est "
"une :dfn:`variable libre`."

#: ../Doc/reference/executionmodel.rst:81
msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr ""
"Chaque occurrence d'un nom dans un programme fait référence à la :dfn:"
"`liaison` de ce nom établie par les règles de résolution des noms suivantes."

#: ../Doc/reference/executionmodel.rst:87
msgid "Resolution of names"
msgstr "Résolution des noms"

#: ../Doc/reference/executionmodel.rst:91
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""
"La :dfn:`portée` définit la visibilité d'un nom dans un bloc. Si une "
"variable locale est définie dans un bloc, sa portée comprend ce bloc. Si la "
"définition intervient dans le bloc d'une fonction, la portée s'étend à tous "
"les blocs contenus dans celui qui comprend la définition, à moins qu'un bloc "
"intérieur ne définisse une autre liaison pour ce nom."

#: ../Doc/reference/executionmodel.rst:99
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""
"Quand un nom est utilisé dans un bloc de code, la résolution utilise la "
"portée la plus petite. L'ensemble de toutes les portées visibles dans un "
"bloc de code s'appelle :dfn:`l'environnement` du bloc."

#: ../Doc/reference/executionmodel.rst:107
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. :exc:"
"`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"Quand un nom n'est trouvé nulle part, une exception :exc:`NameError` est "
"levée. Si la portée courante est celle d'une fonction et que le nom fait "
"référence à une variable locale qui n'a pas encore été liée au moment où le "
"nom est utilisé, une exception :exc:`UnboundLocalError` est levée. :exc:"
"`UnboundLocalError` est une sous-classe de :exc:`NameError`."

#: ../Doc/reference/executionmodel.rst:113
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations."
msgstr ""
"Si une opération de liaison intervient dans un bloc de code, toutes les "
"utilisations du nom dans le bloc sont considérées comme des références au "
"bloc courant. Ceci peut conduire à des erreurs quand un nom est utilisé à "
"l'intérieur d'un bloc avant d'être lié. La règle est subtile. Python "
"n'attend pas de déclaration de variables et autorise les opérations de "
"liaison n'importe où dans un bloc de code. Les variables locales d'un bloc "
"de code peuvent être déterminées en parcourant tout le texte du bloc à la "
"recherche des opérations de liaisons."

#: ../Doc/reference/executionmodel.rst:120
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"name specified in the statement refer to the binding of that name in the top-"
"level namespace.  Names are resolved in the top-level namespace by searching "
"the global namespace, i.e. the namespace of the module containing the code "
"block, and the builtins namespace, the namespace of the module :mod:"
"`builtins`.  The global namespace is searched first.  If the name is not "
"found there, the builtins namespace is searched.  The :keyword:`!global` "
"statement must precede all uses of the name."
msgstr ""
"Si l'instruction :keyword:`global` apparaît dans un bloc, toutes les "
"utilisations du nom spécifié dans l'instruction font référence à la liaison "
"de ce nom dans l'espace de nommage de plus haut niveau. Les noms sont "
"résolus dans cet espace de nommage de plus haut niveau en recherchant "
"l'espace des noms globaux, c'est-à-dire l'espace de nommage du module "
"contenant le bloc de code ainsi que dans l'espace de nommage natif, celui du "
"module :mod:`builtins`. La recherche commence dans l'espace de nommage "
"globaux. Si le nom n'y est pas trouvé, la recherche se poursuit dans "
"l'espace de nommage natif. L'instruction :keyword:`!global` doit précéder "
"toute utilisation du nom considéré."

#: ../Doc/reference/executionmodel.rst:129
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
"L'instruction :keyword:`global` a la même porte qu'une opération de liaison "
"du même bloc. Si la portée englobante la plus petite pour une variable libre "
"contient une instruction *global*, la variable libre est considérée globale."

#: ../Doc/reference/executionmodel.rst:135
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. :exc:"
"`SyntaxError` is raised at compile time if the given name does not exist in "
"any enclosing function scope."
msgstr ""
"L'instruction :keyword:`nonlocal` fait que les noms correspondants font "
"référence aux variables liées précédemment dans la portée de fonction "
"englobante la plus petite possible. :exc:`SyntaxError` est levée à la "
"compilation si le nom donné n'existe dans aucune portée de fonction "
"englobante."

#: ../Doc/reference/executionmodel.rst:142
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""
"L'espace de nommage pour un module est créé automatiquement la première fois "
"que le module est importé. Le module principal d'un script s'appelle "
"toujours :mod:`__main__`."

#: ../Doc/reference/executionmodel.rst:145
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names "
"defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods -- this includes comprehensions and generator "
"expressions since they are implemented using a function scope.  This means "
"that the following will fail::"
msgstr ""
"Les blocs de définition de classe et les arguments de :func:`exec` ainsi "
"que :func:`eval` sont traités de manière spéciale dans le cadre de la "
"résolution des noms. Une définition de classe est une instruction exécutable "
"qui peut utiliser et définir des noms. Toutes ces références suivent les "
"règles normales de la résolution des noms à l'exception des variables "
"locales non liées qui sont recherchées dans l'espace des noms globaux. "
"L'espace de nommage de la définition de classe devient le dictionnaire des "
"attributs de la classe. La portée des noms définis dans un bloc de classe "
"est limitée au bloc de la classe ; elle ne s'étend pas aux blocs de code des "
"méthodes — y compris les compréhensions et les expressions générateurs "
"puisque celles-ci sont implémentées en utilisant une portée de fonction. "
"Ainsi, les instructions suivantes échouent ::"

#: ../Doc/reference/executionmodel.rst:163
msgid "Builtins and restricted execution"
msgstr "Noms natifs et restrictions d'exécution"

#: ../Doc/reference/executionmodel.rst:169
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""
"L'utilisateur ne doit pas toucher à ``__builtins__`` ; c'est et cela doit "
"rester réservé aux besoins de l'implémentation. Les utilisateurs qui "
"souhaitent surcharger des valeurs dans l'espace de nommage natif doivent :"
"keyword:`importer <import>` le module :mod:`builtins` et modifier ses "
"attributs judicieusement."

#: ../Doc/reference/executionmodel.rst:174
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any "
"other module, ``__builtins__`` is an alias for the dictionary of the :mod:"
"`builtins` module itself."
msgstr ""
"L'espace de nommage natif associé à l'exécution d'un bloc de code est "
"effectivement trouvé en cherchant le nom ``__builtins__`` dans l'espace de "
"nommage globaux ; ce doit être un dictionnaire ou un module (dans ce dernier "
"cas, le dictionnaire du module est utilisé). Par défaut, lorsque l'on se "
"trouve dans le module :mod:`__main__`, ``__builtins__`` est le module natif :"
"mod:`builtins` ; lorsque l'on se trouve dans tout autre module, "
"``__builtins__`` est un pseudonyme du dictionnaire du module :mod:`builtins` "
"lui-même."

#: ../Doc/reference/executionmodel.rst:186
msgid "Interaction with dynamic features"
msgstr "Interaction avec les fonctionnalités dynamiques"

#: ../Doc/reference/executionmodel.rst:188
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr ""
"La résolution des noms de variables libres intervient à l'exécution, pas à "
"la compilation. Cela signifie que le code suivant affiche 42 ::"

#: ../Doc/reference/executionmodel.rst:199
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The :func:"
"`exec` and :func:`eval` functions have optional arguments to override the "
"global and local namespace.  If only one namespace is specified, it is used "
"for both."
msgstr ""
"Les fonctions :func:`eval` et :func:`exec` n'ont pas accès à l'environnement "
"complet pour résoudre les noms. Les noms doivent être résolus dans les "
"espaces de nommage locaux et globaux de l'appelant. Les variables libres ne "
"sont pas résolues dans l'espace de nommage englobant le plus proche mais "
"dans l'espace de nommage globaux [#]_. Les fonctions :func:`eval` et :func:"
"`exec` possèdent des arguments optionnels pour surcharger les espaces de "
"nommage globaux et locaux. Si seulement un espace de nommage est spécifié, "
"il est utilisé pour les deux."

#: ../Doc/reference/executionmodel.rst:210
msgid "Exceptions"
msgstr "Exceptions"

#: ../Doc/reference/executionmodel.rst:221
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""
"Les exceptions sont un moyen de sortir du flot normal d'exécution d'un bloc "
"de code de manière à gérer des erreurs ou des conditions exceptionnelles. "
"Une exception est *levée* au moment où l'erreur est détectée ; elle doit "
"être *gérée* par le bloc de code qui l'entoure ou par tout bloc de code qui "
"a, directement ou indirectement, invoqué le bloc de code où l'erreur s'est "
"produite."

#: ../Doc/reference/executionmodel.rst:227
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""
"L'interpréteur Python lève une exception quand il détecte une erreur à "
"l'exécution (telle qu'une division par zéro). Un programme Python peut aussi "
"lever explicitement une exception avec l'instruction :keyword:`raise`. Les "
"gestionnaires d'exception sont spécifiés avec l'instruction :keyword:`try` "
"… :keyword:`except`. La clause :keyword:`finally` d'une telle instruction "
"peut être utilisée pour spécifier un code de nettoyage qui ne gère pas "
"l'exception mais qui est exécuté quoi qu'il arrive (exception ou pas)."

#: ../Doc/reference/executionmodel.rst:237
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""
"Python utilise le modèle par *terminaison* de gestion des erreurs : un "
"gestionnaire d'exception peut trouver ce qui est arrivé et continuer "
"l'exécution à un niveau plus élevé, mais il ne peut pas réparer l'origine de "
"l'erreur et ré-essayer l'opération qui a échoué (sauf à entrer à nouveau "
"dans le code en question par le haut)."

#: ../Doc/reference/executionmodel.rst:244
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is :exc:"
"`SystemExit`."
msgstr ""
"Quand une exception n'est pas du tout gérée, l'interpréteur termine "
"l'exécution du programme ou retourne à la boucle interactive. Dans ces cas, "
"il affiche une trace de la pile d'appels, sauf si l'exception est :exc:"
"`SystemExit`."

#: ../Doc/reference/executionmodel.rst:248
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a base class thereof.  The instance can be received "
"by the handler and can carry additional information about the exceptional "
"condition."
msgstr ""
"Les exceptions sont identifiées par des instances de classe. La clause :"
"keyword:`except` sélectionnée dépend de la classe de l'instance : elle doit "
"faire référence à la classe de l'instance ou à une de ses classes ancêtres. "
"L'instance peut être transmise au gestionnaire et peut apporter des "
"informations complémentaires sur les conditions de l'exception."

#: ../Doc/reference/executionmodel.rst:255
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"Les messages d'exception ne font pas partie de l'API Python. Leur contenu "
"peut changer d'une version de Python à une autre sans avertissement et le "
"code ne doit pas reposer sur ceux-ci s'il doit fonctionner sur plusieurs "
"versions de l'interpréteur."

#: ../Doc/reference/executionmodel.rst:259
msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"Reportez-vous aussi aux descriptions de l'instruction :keyword:`try` dans la "
"section :ref:`try` et de l'instruction :keyword:`raise` dans la section :ref:"
"`raise`."

#: ../Doc/reference/executionmodel.rst:264
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/reference/executionmodel.rst:265
msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr ""
"En effet, le code qui est exécuté par ces opérations n'est pas connu au "
"moment où le module est compilé."
