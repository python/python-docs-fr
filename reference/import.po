# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-11-15 18:54+0100\n"
"PO-Revision-Date: 2020-04-27 22:26+0200\n"
"Last-Translator: Jules Lasne <jules.lasne@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.3\n"

#: ../Doc/reference/import.rst:6
msgid "The import system"
msgstr "Le système d'importation"

#: ../Doc/reference/import.rst:10
msgid ""
"Python code in one :term:`module` gains access to the code in another module "
"by the process of :term:`importing` it.  The :keyword:`import` statement is "
"the most common way of invoking the import machinery, but it is not the only "
"way.  Functions such as :func:`importlib.import_module` and built-in :func:"
"`__import__` can also be used to invoke the import machinery."
msgstr ""
"Le code Python d'un :term:`module` peut accéder à du code d'un autre module "
"par un mécanisme qui consiste à :term:`importer` cet autre module. "
"L'instruction :keyword:`import` est la façon la plus courante faire appel à "
"ce système d'importation, mais ce n'est pas la seule. Les fonctions telles "
"que :func:`importlib.import_module` et :func:`__import__` peuvent aussi être "
"utilisées pour mettre en œuvre le mécanisme d'importation."

#: ../Doc/reference/import.rst:16
msgid ""
"The :keyword:`import` statement combines two operations; it searches for the "
"named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`!import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`!import` statement.  See the :"
"keyword:`!import` statement for the exact details of that name binding "
"operation."
msgstr ""
"L'instruction :keyword:`import` effectue deux opérations ; elle cherche le "
"module dont le nom a été donné puis elle lie le résultat de cette recherche "
"à un nom dans la portée locale. L'opération de recherche de l'instruction :"
"keyword:`!import` consiste à appeler la fonction :func:`__import__` avec les "
"arguments adéquats. La valeur renvoyée par :func:`__import__` est utilisée "
"pour effectuer l'opération de liaison avec le nom fourni à l'instruction :"
"keyword:`!import`. Reportez-vous à l'instruction :keyword:`!import` pour les "
"détails exacts de l'opération de liaison avec le nom."

#: ../Doc/reference/import.rst:25
msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur, "
"such as the importing of parent packages, and the updating of various caches "
"(including :data:`sys.modules`), only the :keyword:`import` statement "
"performs a name binding operation."
msgstr ""
"Un appel direct à :func:`__import__` effectue seulement la recherche du "
"module et, s'il est trouvé, l'opération de création du module. Bien que des "
"effets collatéraux puissent se produire, tels que l'importation de paquets "
"parents et la mise à jour de divers caches (y compris :data:`sys.modules`), "
"il n'y a que l'instruction :keyword:`import` qui déclenche l'opération de "
"liaison avec le nom."

#: ../Doc/reference/import.rst:31
msgid ""
"When an :keyword:`import` statement is executed, the standard builtin :func:"
"`__import__` function is called. Other mechanisms for invoking the import "
"system (such as :func:`importlib.import_module`) may choose to bypass :func:"
"`__import__` and use their own solutions to implement import semantics."
msgstr ""
"Quand une instruction :keyword:`import` est exécutée, la fonction native :"
"func:`__import__` est appelée. D'autres mécanismes d'appel au système "
"d'importation (tels que :func:`importlib.import_module`) peuvent choisir "
"d'ignorer :func:`__import__` et utiliser leurs propres solutions pour "
"implémenter la sémantique d'importation."

#: ../Doc/reference/import.rst:36
msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, a :exc:`ModuleNotFoundError` is raised.  Python "
"implements various strategies to search for the named module when the import "
"machinery is invoked.  These strategies can be modified and extended by "
"using various hooks described in the sections below."
msgstr ""
"Quand un module est importé pour la première fois, Python recherche le "
"module et, s'il est trouvé, créé un objet module [#fnmo]_ en l'initialisant. "
"Si le module n'est pas trouvé, une :exc:`ModuleNotFoundError` est levée. "
"Python implémente plusieurs stratégies pour rechercher le module d'un nom "
"donné quand le mécanisme d'import est invoqué. Ces stratégies peuvent être "
"modifiées et étendues par divers moyens décrits dans les sections suivantes."

#: ../Doc/reference/import.rst:43
msgid ""
"The import system has been updated to fully implement the second phase of :"
"pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""
"Le système d'importation a été mis à jour pour implémenter complètement la "
"deuxième partie de la :pep:`302`. Il n'existe plus de mécanisme implicite "
"d'importation (le système d'importation complet est exposé *via* :data:`sys."
"meta_path`). En complément, la gestion du paquet des noms natifs a été "
"implémenté (voir la :pep:`420`)."

#: ../Doc/reference/import.rst:51
msgid ":mod:`importlib`"
msgstr ":mod:`importlib`"

#: ../Doc/reference/import.rst:53
msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""
"Le module :mod:`importlib` fournit une API riche pour interagir avec le "
"système d'import. Par exemple, :func:`importlib.import_module` fournit une "
"API (que nous vous recommandons) plus simple que la fonction native :func:"
"`__import__` pour mettre en œuvre le mécanisme d'import. Reportez-vous à la "
"documentation de la bibliothèque :mod:`importlib` pour obtenir davantage de "
"détails."

#: ../Doc/reference/import.rst:62
msgid "Packages"
msgstr "Les paquets"

#: ../Doc/reference/import.rst:67
msgid ""
"Python has only one type of module object, and all modules are of this type, "
"regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a "
"concept of :term:`packages <package>`."
msgstr ""
"Python ne connait qu'un seul type d'objet module et tous les modules sont "
"donc de ce type, que le module soit implémenté en Python, en C ou quoi que "
"ce soit d'autre. Pour aider à l'organisation des modules et fournir une "
"hiérarchie des noms, Python développe le concept de :term:`paquets "
"<package>`."

#: ../Doc/reference/import.rst:72
msgid ""
"You can think of packages as the directories on a file system and modules as "
"files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized "
"hierarchically, and packages may themselves contain subpackages, as well as "
"regular modules."
msgstr ""
"Vous pouvez vous représenter les paquets comme des répertoires dans le "
"système de fichiers et les modules comme des fichiers dans ces répertoires. "
"Mais ne prenez pas trop cette analogie au pied de la lettre car les paquets "
"et les modules ne proviennent pas obligatoirement du système de fichiers. "
"Dans le cadre de cette documentation, nous utilisons cette analogie bien "
"pratique des répertoires et des fichiers. Comme les répertoires du système "
"de fichiers, les paquets sont organisés de manière hiérarchique et les "
"paquets peuvent eux-mêmes contenir des sous-paquets ou des modules."

#: ../Doc/reference/import.rst:80
msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""
"Il est important de garder à l'esprit que tous les paquets sont des modules "
"mais que tous les modules ne sont pas des paquets. Formulé autrement, les "
"paquets sont juste un certain type de modules. Spécifiquement, tout module "
"qui contient un attribut ``__path__`` est réputé être un paquet."

#: ../Doc/reference/import.rst:85
msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by dots, akin to Python's standard attribute access syntax.  "
"Thus you might have a module called :mod:`sys` and a package called :mod:"
"`email`, which in turn has a subpackage called :mod:`email.mime` and a "
"module within that subpackage called :mod:`email.mime.text`."
msgstr ""
"Tous les modules ont un nom. Les noms des sous-paquets sont séparés du nom "
"du paquet parent par des points (`.`), à l'instar de la syntaxe standard "
"d'accès aux attributs en Python. Ainsi, vous pouvez avoir un module nommé :"
"mod:`sys` et un paquet nommé :mod:`email`, qui à son tour possède un sous-"
"paquet nommé :mod:`email.mime` avec un module dans ce sous-paquet nommé :mod:"
"`email.mime.text`."

#: ../Doc/reference/import.rst:93
msgid "Regular packages"
msgstr "Paquets classiques"

#: ../Doc/reference/import.rst:98
msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier. "
"A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this ``__init__."
"py`` file is implicitly executed, and the objects it defines are bound to "
"names in the package's namespace.  The ``__init__.py`` file can contain the "
"same Python code that any other module can contain, and Python will add some "
"additional attributes to the module when it is imported."
msgstr ""
"Python définit deux types de paquets, les :term:`paquets classiques <regular "
"package>` et les :term:`paquets espaces de nommage <namespace package>`. Les "
"paquets classiques sont les paquets traditionnels tels qu'ils existaient "
"dans Python 3.2 et antérieurs. Un paquet classique est typiquement "
"implémenté sous la forme d'un répertoire contenant un fichier ``__init__."
"py``. Quand un paquet classique est importé, ce fichier ``__init__.py`` est "
"implicitement exécuté."

#: ../Doc/reference/import.rst:108
msgid ""
"For example, the following file system layout defines a top level ``parent`` "
"package with three subpackages::"
msgstr ""
"Par exemple, l'arborescence suivante définit un paquet ``parent`` au niveau "
"le plus haut avec trois sous-paquets ::"

#: ../Doc/reference/import.rst:120
msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and ``parent/three/"
"__init__.py`` respectively."
msgstr ""
"Importer ``parent.one`` exécute implicitement ``parent/__init__.py`` et "
"``parent/one/__init__.py``. Les importations postérieures de ``parent.two`` "
"ou ``parent.three`` respectivement exécutent ``parent/two/__init__.py`` ou "
"``parent/three/__init__.py`` respectivement."

#: ../Doc/reference/import.rst:127
msgid "Namespace packages"
msgstr "Paquets espaces de nommage"

#: ../Doc/reference/import.rst:133
msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions "
"may reside in different locations on the file system.  Portions may also be "
"found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""
"Un paquet-espace de nommage est la combinaison de plusieurs :term:`portions "
"<portion>` où chaque portion fournit un sous-paquet au paquet parent. Les "
"portions peuvent être situées à différents endroits du système de fichiers. "
"Les portions peuvent aussi être stockées dans des fichiers zip, sur le "
"réseau ou à tout autre endroit dans lequel Python cherche pendant "
"l'importation. Les paquets-espaces de nommage peuvent correspondre "
"directement à des objets du système de fichiers, ou pas ; ils peuvent être "
"des modules virtuels qui n'ont aucune représentation concrète."

#: ../Doc/reference/import.rst:141
msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""
"Les paquets-espaces de nommage n'utilisent pas une liste ordinaire pour leur "
"attribut ``__path__``. Ils utilisent en lieu et place un type itérable "
"personnalisé qui effectue automatiquement une nouvelle recherche de portions "
"de paquets à la tentative suivante d'importation dans le paquet si le chemin "
"de leur paquet parent (ou :data:`sys.path` pour les paquets de plus haut "
"niveau) change."

#: ../Doc/reference/import.rst:147
msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will "
"create a namespace package for the top-level ``parent`` package whenever it "
"or one of its subpackages is imported."
msgstr ""
"Pour les paquets-espaces de nommage, il n'existe pas de fichier ``parent/"
"__init__.py``. En fait, il peut y avoir plusieurs répertoires ``parent`` "
"trouvés pendant le processus d'importation, où chacun est apporté par une "
"portion différente. Ainsi, ``parent/one`` n'est pas forcément physiquement à "
"côté de ``parent/two``. Dans ce cas, Python crée un paquet-espace de nommage "
"pour le paquet de plus haut niveau ``parent`` dès que lui ou l'un de ses "
"sous-paquet est importé."

#: ../Doc/reference/import.rst:154
msgid "See also :pep:`420` for the namespace package specification."
msgstr ""
"Voir aussi la :pep:`420` pour les spécifications des paquets-espaces de "
"nommage."

#: ../Doc/reference/import.rst:158
msgid "Searching"
msgstr "Recherche"

#: ../Doc/reference/import.rst:160
msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""
"Pour commencer la recherche, Python a besoin du :term:`nom qualifié "
"<qualified name>` du module (ou du paquet, mais ici cela ne fait pas de "
"différence) que vous souhaitez importer. Le nom peut être donné en argument "
"à l'instruction :keyword:`import` ou comme paramètre aux fonctions :func:"
"`importlib.import_module` ou :func:`__import__`."

#: ../Doc/reference/import.rst:166
msgid ""
"This name will be used in various phases of the import search, and it may be "
"the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python "
"first tries to import ``foo``, then ``foo.bar``, and finally ``foo.bar."
"baz``. If any of the intermediate imports fail, a :exc:`ModuleNotFoundError` "
"is raised."
msgstr ""
"Le nom est utilisé dans plusieurs phases de la recherche et peut être un "
"chemin séparé par des points pour un sous-module, par exemple ``truc.machin."
"bidule``. Dans ce cas, Python essaie d'abord d'importer ``truc`` puis ``truc."
"machin`` et enfin ``truc.machin.bidule``. Si n'importe laquelle des "
"importations intermédiaires échoue, une :exc:`ModuleNotFoundError` est levée."

#: ../Doc/reference/import.rst:173
msgid "The module cache"
msgstr "Cache des modules"

#: ../Doc/reference/import.rst:178
msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported, "
"including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``, "
"and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""
"Le premier endroit vérifié pendant la recherche d'une importation est :data:"
"`sys.modules`. Ce tableau de correspondances est utilisé comme cache de tous "
"les modules déjà importés, y compris les chemins intermédiaires. Ainsi, si "
"``truc.machin.bidule`` a déjà été importé, :data:`sys.modules` contient les "
"entrées correspondantes à ``truc``, ``truc.machin`` et ``truc.machin."
"bidule``. À chaque chemin correspond une clé."

#: ../Doc/reference/import.rst:185
msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then a :exc:"
"`ModuleNotFoundError` is raised.  If the module name is missing, Python will "
"continue searching for the module."
msgstr ""
"Pendant l'importation, le nom de module est cherché dans :data:`sys.modules` "
"et, s'il est trouvé, la valeur associée est le module recherché et le "
"processus est fini. Cependant, si la valeur est ``None``, alors une :exc:"
"`ModuleNotFoundError` est levée. Si le nom du module n'est pas trouvé, "
"Python continue la recherche du module."

#: ../Doc/reference/import.rst:191
msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned "
"to ``None``, forcing the next import of the module to result in a :exc:"
"`ModuleNotFoundError`."
msgstr ""
":data:`sys.modules` est accessible en lecture-écriture. Supprimer une clé "
"peut ne pas détruire le module associé (car d'autres modules contiennent "
"possiblement des références vers ce module), mais cela invalide l'entrée du "
"cache pour ce nom de module. Python cherche alors un nouveau module pour ce "
"nom. La clé peut aussi être assignée à ``None`` de manière à forcer une :exc:"
"`ModuleNotFoundError` lors de la prochaine importation du module."

#: ../Doc/reference/import.rst:198
msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module, "
"the two module objects will *not* be the same. By contrast, :func:`importlib."
"reload` will reuse the *same* module object, and simply reinitialise the "
"module contents by rerunning the module's code."
msgstr ""
"Attention cependant : s'il reste une référence à l'objet module et que vous "
"invalidez l'entrée dans le cache de :data:`sys.modules` puis ré-importez le "
"module, les deux objets modules ne seront pas les mêmes. À l'inverse, :func:"
"`importlib.reload` ré-utilise le *même* objet module et ré-initialise "
"simplement le contenu du module en ré-exécutant le code du module."

#: ../Doc/reference/import.rst:206
msgid "Finders and loaders"
msgstr "Chercheurs et chargeurs"

#: ../Doc/reference/import.rst:213
msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and :term:"
"`loaders <loader>`. A finder's job is to determine whether it can find the "
"named module using whatever strategy it knows about. Objects that implement "
"both of these interfaces are referred to as :term:`importers <importer>` - "
"they return themselves when they find that they can load the requested "
"module."
msgstr ""
"Si le module n'est pas trouvé dans :data:`sys.modules`, alors Python utilise "
"son protocole d'importation pour chercher et charger le module. Ce protocole "
"se compose de deux objets conceptuels : les :term:`chercheurs <finder>` et "
"les :term:`chargeurs <loader>`. Le travail du chercheur consiste à trouver, "
"à l'aide de différentes stratégies, le module dont le nom a été fourni. Les "
"objets qui implémentent ces deux interfaces sont connus sous le vocable \":"
"term:`importateurs <importer>`\" (ils renvoient une référence vers eux-mêmes "
"quand ils trouvent un module qui répond aux attentes)."

#: ../Doc/reference/import.rst:221
msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""
"Python inclut plusieurs chercheurs et importateurs par défaut. Le premier "
"sait comment trouver les modules natifs et le deuxième sait comment trouver "
"les modules gelés. Un troisième chercheur recherche les modules dans :term:"
"`import path`. :term:`import path` est une énumération sous forme de liste "
"de chemins ou de fichiers zip. Il peut être étendu pour rechercher aussi "
"dans toute ressource qui dispose d'un identifiant pour la localiser, une URL "
"par exemple."

#: ../Doc/reference/import.rst:228
msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr ""
"Le mécanisme d'importation est extensible, vous pouvez donc ajouter de "
"nouveaux chercheurs pour étendre le domaine de recherche des modules."

#: ../Doc/reference/import.rst:231
msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""
"Les chercheurs ne chargent pas les modules. S'il trouve le module demandé, "
"un chercheur renvoie un :dfn:`spécificateur de module`, qui contient toutes "
"les informations nécessaires pour importer le module ; celui-ci sera alors "
"utilisé par le mécanisme d'importation pour charger le module."

#: ../Doc/reference/import.rst:235
msgid ""
"The following sections describe the protocol for finders and loaders in more "
"detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr ""
"Les sections suivantes décrivent plus en détail le protocole utilisé par les "
"chercheurs et les chargeurs, y compris la manière de les créer et les "
"enregistrer pour étendre le mécanisme d'importation."

#: ../Doc/reference/import.rst:239
msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""
"Dans les versions précédentes de Python, les chercheurs renvoyaient "
"directement les :term:`chargeurs <loader>`. Dorénavant, ils renvoient des "
"spécificateurs de modules qui *contiennent* les chargeurs. Les chargeurs "
"sont encore utilisés lors de l'importation mais ont moins de responsabilités."

#: ../Doc/reference/import.rst:245
msgid "Import hooks"
msgstr "Points d'entrées automatiques pour l'importation"

#: ../Doc/reference/import.rst:255
msgid ""
"The import machinery is designed to be extensible; the primary mechanism for "
"this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr ""
"Le mécanisme d'importation est conçu pour être extensible ; vous pouvez y "
"insérer des *points d'entrée automatique* (*hooks* en anglais). Il existe "
"deux types de points d'entrée automatique pour l'importation : les *méta-"
"points d'entrée* et les *points d'entrée sur le chemin des importations*."

#: ../Doc/reference/import.rst:259
msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""
"Les méta-points d'entrée sont appelés au début du processus d'importation, "
"juste après la vérification dans le cache :data:`sys.modules` mais avant "
"tout le reste. Ceci permet aux méta-points d'entrée de surcharger le "
"traitement effectué sur :data:`sys.path`, les modules gelés ou même les "
"modules natifs. L'enregistrement des méta-points d'entrée se fait en "
"ajoutant de nouveaux objets chercheurs à :data:`sys.meta_path`, comme décrit "
"ci-dessous."

#: ../Doc/reference/import.rst:265
msgid ""
"Import path hooks are called as part of :data:`sys.path` (or ``package."
"__path__``) processing, at the point where their associated path item is "
"encountered.  Import path hooks are registered by adding new callables to :"
"data:`sys.path_hooks` as described below."
msgstr ""
"Les points d'entrée sur le chemin des importations sont appelés pendant le "
"traitement de :data:`sys.path` (ou ``package.__path__``), au moment où le "
"chemin qui leur correspond est atteint. Les points d'entrée sur le chemin "
"des importations sont enregistrés en ajoutant de nouveaux appelables à :data:"
"`sys.path_hooks`, comme décrit ci-dessous."

#: ../Doc/reference/import.rst:272
msgid "The meta path"
msgstr "Méta-chemins"

#: ../Doc/reference/import.rst:278
msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called :"
"meth:`~importlib.abc.MetaPathFinder.find_spec()` which takes three "
"arguments: a name, an import path, and (optionally) a target module.  The "
"meta path finder can use any strategy it wants to determine whether it can "
"handle the named module or not."
msgstr ""
"Quand le module demandé n'est pas trouvé dans :data:`sys.modules`, Python "
"recherche alors dans :data:`sys.meta_path` qui contient une liste d'objets "
"chercheurs dans des méta-chemins. Ces chercheurs sont interrogés dans "
"l'ordre pour voir s'ils savent prendre en charge le module passé en "
"paramètre. Les chercheurs dans les méta-chemins implémentent une méthode :"
"meth:`~importlib.abc.MetaPathFinder.find_spec()` qui prend trois arguments : "
"un nom, un chemin d'import et (optionnellement) un module cible. Un "
"chercheur dans les méta-chemins peut utiliser n'importe quelle stratégie "
"pour déterminer s'il est apte à prendre en charge le module."

#: ../Doc/reference/import.rst:287
msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  "
"If :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then a :exc:`ModuleNotFoundError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""
"Si un chercheur dans les méta-chemins sait prendre en charge le module "
"donné, il renvoie un objet spécificateur. S'il ne sait pas, il renvoie "
"``None``. Si le traitement de :data:`sys.meta_path` arrive à la fin de la "
"liste sans qu'aucun chercheur n'a renvoyé un objet spécificateur, alors une :"
"exc:`ModuleNotFoundError` est levée. Toute autre exception levée est "
"simplement propagée à l'appelant, mettant fin au processus d'importation."

#: ../Doc/reference/import.rst:293
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec()` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, a :exc:`ModuleNotFoundError` is raised.  The third argument is an "
"existing module object that will be the target of loading later. The import "
"system passes in a target module only during reload."
msgstr ""
"La méthode :meth:`~importlib.abc.MetaPathFinder.find_spec()` des chercheurs "
"dans les méta-chemins est appelée avec deux ou trois arguments. Le premier "
"est le nom complètement qualifié du module à importer, par exemple ``truc."
"machin.bidule``. Le deuxième argument est l'ensemble des chemins dans "
"lesquels chercher. Pour les modules de plus haut niveau, le deuxième "
"argument est ``None`` mais pour les sous-modules ou les paquets, le deuxième "
"argument est la valeur de l'attribut ``__path__`` du paquet parent. Si "
"l'attribut ``__path__`` approprié n'est pas accessible, une :exc:"
"`ModuleNotFoundError` est levée. Le troisième argument est un objet module "
"existant qui va être la cible du chargement (plus tard). Le système "
"d'importation ne passe le module cible en paramètre que lors d'un "
"rechargement."

#: ../Doc/reference/import.rst:304
msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)``. Once ``foo.bar`` has been imported, the final traversal "
"will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."
msgstr ""
"Le méta-chemin peut être parcouru plusieurs fois pour une seule requête "
"d'importation. Par exemple, si nous supposons qu'aucun des modules concernés "
"n'a déjà été mis en cache, importer ``truc.machin.bidule`` effectue une "
"première importation au niveau le plus haut, en appelant ``c_m_c."
"find_spec(\"truc\", None, None)`` pour chaque chercheur dans les méta-"
"chemins (``c_m_c``). Après que ``truc`` a été importé, ``truc.machin`` est "
"importé en parcourant le méta-chemin une deuxième fois, appelant ``c_m_c."
"find_spec(\"truc.machin\", truc.__path__, None)``. Une fois ``truc.machin`` "
"importé, le parcours final appelle ``c_m_c.find_spec(\"truc.machin.bidule\", "
"truc.machin.__path__, None)``."

#: ../Doc/reference/import.rst:314
msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr ""
"Quelques chercheurs dans les méta-chemins ne gèrent que les importations de "
"plus haut niveau. Ces importateurs renvoient toujours ``None`` si on leur "
"passe un deuxième argument autre que ``None``."

#: ../Doc/reference/import.rst:318
msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that "
"knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""
"Le :data:`sys.meta_path` de Python comprend trois chercheurs par défaut : un "
"qui sait importer les modules natifs, un qui sait importer les modules gelés "
"et un qui sait importer les modules depuis un :term:`chemin des importations "
"<import path>` (c'est le :term:`chercheur dans path <path based finder>`)."

#: ../Doc/reference/import.rst:323
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`~importlib.abc.MetaPathFinder.find_module`, which is "
"now deprecated.  While it will continue to work without change, the import "
"machinery will try it only if the finder does not implement ``find_spec()``."
msgstr ""
"La méthode :meth:`~importlib.abc.MetaPathFinder.find_spec` des chercheurs "
"dans les méta-chemins a remplacé :meth:`~importlib.abc.MetaPathFinder."
"find_module`, devenue obsolète. Bien qu'elle continue de fonctionner comme "
"avant, le mécanisme d'importation essaie ``find_module()`` uniquement si le "
"chercheur n'implémente pas ``find_spec()``."

#: ../Doc/reference/import.rst:332
msgid "Loading"
msgstr "Chargement"

#: ../Doc/reference/import.rst:334
msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr ""
"Quand un spécificateur de module est trouvé, le mécanisme d'importation "
"l'utilise (et le chargeur qu'il contient) pour charger le module. Voici à "
"peu près ce qui se passe au sein de l'importation pendant la phase de "
"chargement ::"

#: ../Doc/reference/import.rst:368
msgid "Note the following details:"
msgstr "Notez les détails suivants :"

#: ../Doc/reference/import.rst:370
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, import will have already returned it."
msgstr ""
"S'il existe un objet module dans :data:`sys.modules` avec le même nom, "
"import l'aurait déjà renvoyé."

#: ../Doc/reference/import.rst:373
msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""
"Le module existe dans :data:`sys.modules` avant que le chargeur exécute le "
"code du module. C'est crucial car le code du module peut (directement ou "
"indirectement) s'importer lui-même ; l'ajouter à :data:`sys.modules` avant "
"évite les récursions infinies dans le pire cas et le chargement multiple "
"dans le meilleur des cas."

#: ../Doc/reference/import.rst:379
msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the :data:`sys."
"modules` cache, and any module that was successfully loaded as a side-"
"effect, must remain in the cache.  This contrasts with reloading where even "
"the failing module is left in :data:`sys.modules`."
msgstr ""
"Si le chargement échoue, le module en cause (et seulement ce module) est "
"enlevé de :data:`sys.modules`. Tout module déjà dans le cache de :data:`sys."
"modules` et tout module qui a été chargé avec succès par effet de bord doit "
"rester dans le cache. C'est différent dans le cas d'un rechargement où même "
"le module qui a échoué est conservé dans :data:`sys.modules`."

#: ../Doc/reference/import.rst:385
msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""
"Après que le module est créé mais avant son exécution, le mécanisme "
"d'importation définit les attributs relatifs à l'importation "
"(``_init_module_attrs`` dans l'exemple de pseudo-code ci-dessus), comme "
"indiqué brièvement dans une :ref:`section <import-mod-attrs>` que nous "
"abordons ensuite."

#: ../Doc/reference/import.rst:390
msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr ""
"L'exécution du module est le moment clé du chargement dans lequel l'espace "
"de nommage du module est peuplé. L'exécution est entièrement déléguée au "
"chargeur qui doit décider ce qui est peuplé et comment."

#: ../Doc/reference/import.rst:394
msgid ""
"The module created during loading and passed to exec_module() may not be the "
"one returned at the end of import [#fnlo]_."
msgstr ""
"Le modulé créé pendant le chargement et passé à ``exec_module()`` peut ne "
"pas être celui qui est renvoyé à la fin de l'importation [#fnlo]_."

#: ../Doc/reference/import.rst:397
msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the :meth:`importlib.abc.Loader."
"load_module` method."
msgstr ""
"Le système d'importation a pris en charge les responsabilités des chargeurs. "
"Celles-ci étaient auparavant effectuées par la méthode :meth:`importlib.abc."
"Loader.load_module`."

#: ../Doc/reference/import.rst:403
msgid "Loaders"
msgstr "Chargeurs"

#: ../Doc/reference/import.rst:405
msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""
"Les chargeurs de modules fournissent la fonction critique du chargement : "
"l'exécution du module. Le mécanisme d'importation appelle la méthode :meth:"
"`importlib.abc.Loader.exec_module` avec un unique argument, l'objet module à "
"exécuter. Toute valeur renvoyée par :meth:`~importlib.abc.Loader."
"exec_module` est ignorée."

#: ../Doc/reference/import.rst:410
msgid "Loaders must satisfy the following requirements:"
msgstr "Les chargeurs doivent satisfaire les conditions suivantes :"

#: ../Doc/reference/import.rst:412
msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""
"Si le module est un module Python (par opposition aux modules natifs ou aux "
"extensions chargées dynamiquement), le chargeur doit exécuter le code du "
"module dans l'espace des noms globaux du module (``module.__dict__``)."

#: ../Doc/reference/import.rst:416
msgid ""
"If the loader cannot execute the module, it should raise an :exc:"
"`ImportError`, although any other exception raised during :meth:`~importlib."
"abc.Loader.exec_module` will be propagated."
msgstr ""
"Si le chargeur ne peut pas exécuter le module, il doit lever une :exc:"
"`ImportError`, alors que toute autre exception levée durant :meth:"
"`~importlib.abc.Loader.exec_module` est propagée."

#: ../Doc/reference/import.rst:420
msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return "
"a spec with the loader set to ``self``."
msgstr ""
"Souvent, le chercheur et le chargeur sont le même objet ; dans ce cas, la "
"méthode :meth:`~importlib.abc.MetaPathFinder.find_spec` doit juste renvoyer "
"un spécificateur avec le chargeur défini à ``self``."

#: ../Doc/reference/import.rst:424
msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the method returns ``None``, the import machinery "
"will create the new module itself."
msgstr ""
"Les chargeurs de modules peuvent choisir de créer l'objet module pendant le "
"chargement en implémentant une méthode :meth:`~importlib.abc.Loader."
"create_module`. Elle prend un argument, l'objet spécificateur du module et "
"renvoie le nouvel objet du module à utiliser pendant le chargement. Notez "
"que ``create_module()`` n'a besoin de définir aucun attribut sur l'objet "
"module. Si cette méthode renvoie ``None``, le mécanisme d'importation crée "
"le nouveau module lui-même."

#: ../Doc/reference/import.rst:431
msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr "La méthode  :meth:`~importlib.abc.Loader.create_module` des chargeurs."

#: ../Doc/reference/import.rst:434
msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by :meth:"
"`~importlib.abc.Loader.exec_module` and the import machinery assumed all the "
"boilerplate responsibilities of loading."
msgstr ""
"La méthode :meth:`~importlib.abc.Loader.load_module` a été remplacée par :"
"meth:`~importlib.abc.Loader.exec_module` et le mécanisme d'import assume "
"toutes les responsabilités du chargement."

#: ../Doc/reference/import.rst:439
msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""
"Par compatibilité avec les chargeurs existants, le mécanisme d'importation "
"utilise la méthode ``load_module()`` des chargeurs si elle existe et si le "
"chargeur n'implémente pas ``exec_module()``. Cependant, ``load_module()`` "
"est déclarée obsolète et les chargeurs doivent implémenter ``exec_module()`` "
"à la place."

#: ../Doc/reference/import.rst:444
msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr ""
"La méthode ``load_module()`` *doit* implémenter toutes les fonctionnalités "
"de chargement décrites ci-dessus en plus de l'exécution du module. Toutes "
"les contraintes s'appliquent aussi, avec quelques précisions "
"supplémentaires :"

#: ../Doc/reference/import.rst:448
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, the loader must use that existing module. (Otherwise, :func:"
"`importlib.reload` will not work correctly.)  If the named module does not "
"exist in :data:`sys.modules`, the loader must create a new module object and "
"add it to :data:`sys.modules`."
msgstr ""
"S'il y a un objet module existant avec le même nom dans :data:`sys.modules`, "
"le chargeur doit utiliser le module existant (sinon, :func:`importlib."
"reload` ne fonctionnera pas correctement). Si le module considéré n'est pas "
"trouvé dans :data:`sys.modules`, le chargeur doit créer un nouvel objet "
"module et l'ajouter à :data:`sys.modules`."

#: ../Doc/reference/import.rst:454
msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr ""
"Le module *doit* exister dans :data:`sys.modules` avant que le chargeur "
"n'exécute le code du module, afin d'éviter les récursions infinies ou le "
"chargement multiple."

#: ../Doc/reference/import.rst:458
msgid ""
"If loading fails, the loader must remove any modules it has inserted into :"
"data:`sys.modules`, but it must remove **only** the failing module(s), and "
"only if the loader itself has loaded the module(s) explicitly."
msgstr ""
"Si le chargement échoue, le chargeur ne doit enlever de :data:`sys.modules` "
"**que** le (ou les) module ayant échoué et seulement si le chargeur lui-même "
"a chargé le module explicitement."

#: ../Doc/reference/import.rst:463
msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"Un avertissement :exc:`DeprecationWarning` est levé quand ``exec_module()`` "
"est définie mais ``create_module()`` ne l'est pas."

#: ../Doc/reference/import.rst:467
msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"Une exception :exc:`ImportError` est levée quand ``exec_module()`` est "
"définie mais ``create_module()`` ne l'est pas."

#: ../Doc/reference/import.rst:472
msgid "Submodules"
msgstr "Sous-modules"

#: ../Doc/reference/import.rst:474
msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the "
"``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""
"Quand un sous-module est chargé, quel que soit le mécanisme (par exemple "
"avec les instructions ``import``, ``import-from`` ou avec la fonction native "
"``__import__()``), une liaison est créée dans l'espace de nommage du module "
"parent vers l'objet sous-module. Par exemple, si le paquet ``spam`` possède "
"un sous-module ``foo``, après l'importation de ``spam.foo``, ``spam`` "
"possède un attribut ``foo`` qui est lié au sous-module. Supposons que nous "
"ayons l'arborescence suivante ::"

#: ../Doc/reference/import.rst:486
msgid "and ``spam/__init__.py`` has the following lines in it::"
msgstr "et que le contenu de ``spam/__init__.py`` soit ::"

#: ../Doc/reference/import.rst:491
msgid ""
"then executing the following puts a name binding to ``foo`` and ``bar`` in "
"the ``spam`` module::"
msgstr ""
"alors exécuter les lignes suivantes crée des liens vers ``foo`` et ``bar`` "
"dans le module ``spam`` ::"

#: ../Doc/reference/import.rst:500
msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and ``sys.modules['spam."
"foo']`` (as you would after the above import), the latter must appear as the "
"``foo`` attribute of the former."
msgstr ""
"Connaissant la façon habituelle dont Python effectue les liens, cela peut "
"sembler surprenant. Mais c'est en fait une fonctionnalité fondamentale du "
"système d'importation. Si vous avez quelque part ``sys.modules['spam']`` et "
"``sys.modules['spam.foo']`` (comme dans c'est le cas ci-dessus après "
"l'importation), alors le dernier doit apparaître comme l'attribut ``foo`` du "
"premier."

#: ../Doc/reference/import.rst:507
msgid "Module spec"
msgstr "Spécificateurs de modules"

#: ../Doc/reference/import.rst:509
msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all "
"modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""
"Le mécanisme d'importation utilise diverses informations de chaque module "
"pendant l'importation, spécialement avant le chargement. La plupart de ces "
"informations sont communes à tous les modules. Le but d'un spécificateur de "
"module est d'encapsuler ces informations relatives à l'importation au sein "
"de chaque module."

#: ../Doc/reference/import.rst:514
msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""
"Utiliser un spécificateur pendant l'importation permet de transférer l'état "
"entre les composants du système d'importation, par exemple entre le "
"chercheur qui crée le spécificateur de module et le chargeur qui l'exécute. "
"Surtout, cela permet au mécanisme d'importation d'effectuer toutes les "
"opérations classiques de chargement, alors que c'était le chargeur qui en "
"avait la responsabilité quand il n'y avait pas de spécificateur."

#: ../Doc/reference/import.rst:520
msgid ""
"The module's spec is exposed as the ``__spec__`` attribute on a module "
"object. See :class:`~importlib.machinery.ModuleSpec` for details on the "
"contents of the module spec."
msgstr ""
"Le spécificateur de module est accessible par l'attribut ``__spec__`` de "
"l'objet module. Lisez :class:`~importlib.machinery.ModuleSpec` pour "
"davantage d'informations sur le contenu du spécificateur de module."

#: ../Doc/reference/import.rst:529
msgid "Import-related module attributes"
msgstr "Attributs des modules importés"

#: ../Doc/reference/import.rst:531
msgid ""
"The import machinery fills in these attributes on each module object during "
"loading, based on the module's spec, before the loader executes the module."
msgstr ""
"Le mécanisme d'importation renseigne ces attributs pour chaque objet module "
"pendant le chargement, sur la base du spécificateur de module et avant que "
"le chargeur n'exécute le module."

#: ../Doc/reference/import.rst:537
msgid ""
"The ``__name__`` attribute must be set to the fully-qualified name of the "
"module.  This name is used to uniquely identify the module in the import "
"system."
msgstr ""
"L'attribut ``__name__`` doit contenir le nom complètement qualifié du "
"module. Ce nom est utilisé pour identifier de manière non équivoque le "
"module dans le mécanisme d'importation."

#: ../Doc/reference/import.rst:543
msgid ""
"The ``__loader__`` attribute must be set to the loader object that the "
"import machinery used when loading the module.  This is mostly for "
"introspection, but can be used for additional loader-specific functionality, "
"for example getting data associated with a loader."
msgstr ""
"L'attribut ``__loader__`` doit pointer vers l'objet chargeur que le "
"mécanisme d'importation a utilisé pour charger le module. L'utilisation "
"principale concerne l'introspection, mais il peut être utilisé pour d'autres "
"fonctionnalités relatives au chargement. Par exemple, obtenir des données "
"par l'intermédiaire du chargeur."

#: ../Doc/reference/import.rst:550
msgid ""
"The module's ``__package__`` attribute must be set.  Its value must be a "
"string, but it can be the same value as its ``__name__``.  When the module "
"is a package, its ``__package__`` value should be set to its ``__name__``.  "
"When the module is not a package, ``__package__`` should be set to the empty "
"string for top-level modules, or for submodules, to the parent package's "
"name.  See :pep:`366` for further details."
msgstr ""
"L'attribut ``__package__`` du module doit être défini. Sa valeur doit être "
"une chaîne de caractères, qui peut être la même que son attribut "
"``__name__``. Quand le module est un paquet, la valeur de ``__package__`` "
"doit être définie à la même valeur que son ``__name__``. Quand le module "
"n'est pas un paquet, ``__package__`` doit être la chaîne vide pour les "
"modules de niveau le plus haut, et le nom du paquet parent pour les sous-"
"modules. Voir la :pep:`366` pour plus de détails."

#: ../Doc/reference/import.rst:558
msgid ""
"This attribute is used instead of ``__name__`` to calculate explicit "
"relative imports for main modules, as defined in :pep:`366`. It is expected "
"to have the same value as ``__spec__.parent``."
msgstr ""
"Cet attribut est utilisé à la place de ``__name__`` pour calculer les "
"importations relatives explicites des modules principaux, comme défini dans "
"la :pep:`366`. Il devrait avoir la même valeur que ``__spec__.parent``."

#: ../Doc/reference/import.rst:562
msgid ""
"The value of ``__package__`` is expected to be the same as ``__spec__."
"parent``."
msgstr ""
"La valeur de ``__package__`` devrait être la même que celle de ``__spec__."
"parent``."

#: ../Doc/reference/import.rst:568
msgid ""
"The ``__spec__`` attribute must be set to the module spec that was used when "
"importing the module. Setting ``__spec__`` appropriately applies equally to :"
"ref:`modules initialized during interpreter startup <programs>`.  The one "
"exception is ``__main__``, where ``__spec__`` is :ref:`set to None in some "
"cases <main_spec>`."
msgstr ""
"L'attribut ``__spec__`` doit contenir un lien vers le spécificateur de "
"module qui a été utilisé lors de l'importation du module. Définir "
"``__spec__`` correctement s'applique aussi pour :ref:`l'initialisation des "
"modules au démarrage de l'interpréteur <programs>`. La seule exception "
"concerne ``__main__`` où la valeur de ``__spec__`` est :ref:`None dans "
"certains cas <main_spec>`."

#: ../Doc/reference/import.rst:574
msgid ""
"When ``__package__`` is not defined, ``__spec__.parent`` is used as a "
"fallback."
msgstr ""
"Quand ``__package__`` n'est pas défini, ``__spec__.parent`` est utilisé par "
"défaut."

#: ../Doc/reference/import.rst:579
msgid ""
"``__spec__.parent`` is used as a fallback when ``__package__`` is not "
"defined."
msgstr ""
"``__spec__.parent`` est utilisé par défaut quand ``__package__`` n'est pas "
"défini."

#: ../Doc/reference/import.rst:585
msgid ""
"If the module is a package (either regular or namespace), the module "
"object's ``__path__`` attribute must be set.  The value must be iterable, "
"but may be empty if ``__path__`` has no further significance. If "
"``__path__`` is not empty, it must produce strings when iterated over. More "
"details on the semantics of ``__path__`` are given :ref:`below <package-path-"
"rules>`."
msgstr ""
"Si le module est un paquet (classique ou espace de nommage), l'attribut "
"``__path__`` de l'objet module doit être défini. La valeur doit être un "
"itérable mais peut être vide si ``__path__`` n'a pas de sens dans le "
"contexte. Si ``__path__`` n'est pas vide, il doit produire des chaînes "
"lorsque l'on itère dessus. Vous trouvez plus de détails sur la sémantique de "
"``__path__`` :ref:`plus loin ci-dessous <package-path-rules>`."

#: ../Doc/reference/import.rst:592
msgid "Non-package modules should not have a ``__path__`` attribute."
msgstr ""
"Les modules qui ne sont pas des paquets ne doivent pas avoir d'attribut "
"``__path__``."

#: ../Doc/reference/import.rst:597
msgid ""
"``__file__`` is optional. If set, this attribute's value must be a string.  "
"The import system may opt to leave ``__file__`` unset if it has no semantic "
"meaning (e.g. a module loaded from a database)."
msgstr ""
"``__file__`` est optionnel. S'il est défini, la valeur de cet attribut doit "
"être une chaîne. Le système d'importation peut décider de laisser "
"``__file__`` indéfini si cela ne fait pas sens de le définir (par exemple, "
"lorsqu'on charge un module depuis une base de données)."

#: ../Doc/reference/import.rst:601
msgid ""
"If ``__file__`` is set, it may also be appropriate to set the ``__cached__`` "
"attribute which is the path to any compiled version of the code (e.g. byte-"
"compiled file). The file does not need to exist to set this attribute; the "
"path can simply point to where the compiled file would exist (see :pep:"
"`3147`)."
msgstr ""
"Si ``__file__`` est défini, il peut être judicieux de définir l'attribut "
"``__cached__`` dont la valeur est le chemin vers une version compilée du "
"code (par exemple, le fichier *bytecode*). Le fichier n'a pas besoin "
"d'exister pour définir cet attribut : le chemin peut simplement pointer vers "
"l'endroit où le fichier compilé aurait été placé (voir la :pep:`3147`)."

#: ../Doc/reference/import.rst:607
msgid ""
"It is also appropriate to set ``__cached__`` when ``__file__`` is not set.  "
"However, that scenario is quite atypical.  Ultimately, the loader is what "
"makes use of ``__file__`` and/or ``__cached__``.  So if a loader can load "
"from a cached module but otherwise does not load from a file, that atypical "
"scenario may be appropriate."
msgstr ""
"Vous pouvez aussi définir ``__cached__`` quand ``__file__`` n'est pas "
"défini. Cependant, ce scénario semble rare. Au final, c'est le chargeur qui "
"utilise les valeurs de ``__file__`` ou ``__cached__``. Donc, si le chargeur "
"peut charger depuis un module mis en cache mais ne peut pas charger depuis "
"un fichier, ce scénario a du sens."

#: ../Doc/reference/import.rst:616
msgid "module.__path__"
msgstr "module.__path__"

#: ../Doc/reference/import.rst:618
msgid ""
"By definition, if a module has a ``__path__`` attribute, it is a package."
msgstr ""
"Par définition, si un module possède un attribut ``__path__``, c'est un "
"paquet."

#: ../Doc/reference/import.rst:620
msgid ""
"A package's ``__path__`` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as :"
"data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, ``__path__`` is typically much more constrained "
"than :data:`sys.path`."
msgstr ""
"L'attribut ``__path__`` d'un paquet est utilisé pendant l'importation des "
"sous-paquets. Dans le mécanisme d'importation, son fonctionnement ressemble "
"beaucoup à :data:`sys.path`, c'est-à-dire qu'il fournit une liste "
"d'emplacements où rechercher les modules pendant l'importation. Cependant, "
"``__path__`` est beaucoup plus contraint que :data:`sys.path`."

#: ../Doc/reference/import.rst:626
msgid ""
"``__path__`` must be an iterable of strings, but it may be empty. The same "
"rules used for :data:`sys.path` also apply to a package's ``__path__``, and :"
"data:`sys.path_hooks` (described below) are consulted when traversing a "
"package's ``__path__``."
msgstr ""
"``__path__`` doit être un itérable de chaînes de caractères, mais il peut "
"être vide. Les mêmes règles que pour :data:`sys.path` s'appliquent au "
"``__path__`` d'un paquet et :data:`sys.path_hooks` (dont la description est "
"donnée plus bas) est consulté pendant le parcours de ``__path__`` du paquet."

#: ../Doc/reference/import.rst:631
msgid ""
"A package's ``__init__.py`` file may set or alter the package's ``__path__`` "
"attribute, and this was typically the way namespace packages were "
"implemented prior to :pep:`420`.  With the adoption of :pep:`420`, namespace "
"packages no longer need to supply ``__init__.py`` files containing only "
"``__path__`` manipulation code; the import machinery automatically sets "
"``__path__`` correctly for the namespace package."
msgstr ""
"Le fichier ``__init__.py`` d'un paquet peut définir ou modifier l'attribut "
"``__path__`` d'un paquet, et c'est ainsi qu'étaient implémentés les paquets-"
"espaces de nommage avant la :pep:`420`. Depuis l'adoption de la :pep:`420`, "
"les paquets-espaces de nommage n'ont plus besoin d'avoir des fichiers "
"``__init__.py`` qui ne font que de la manipulation de ``__path__`` ; le "
"mécanisme d'importation définit automatiquement ``__path__`` correctement "
"pour un paquet-espace de nommage."

#: ../Doc/reference/import.rst:639
msgid "Module reprs"
msgstr "Représentation textuelle d'un module"

#: ../Doc/reference/import.rst:641
msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""
"Par défaut, tous les modules ont une représentation textuelle utilisable. "
"Cependant, en utilisant les attributs définis ci-dessus et dans le "
"spécificateur de module, vous pouvez explicitement mieux contrôler "
"l'affichage des objets modules."

#: ../Doc/reference/import.rst:645
msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, ``module."
"__file__``, and ``module.__loader__`` as input into the repr, with defaults "
"for whatever information is missing."
msgstr ""
"Si le module possède un spécificateur (``__spec__``), le mécanisme "
"d'importation essaie de générer une représentation avec celui-ci. S'il "
"échoue ou s'il n'y a pas de spécificateur, le système d'importation "
"construit une représentation par défaut en utilisant toute information "
"disponible sur le module. Il tente d'utiliser ``module.__name__``, ``module."
"__file__`` et ``module.__loader__`` comme entrées pour la représentation, "
"avec des valeurs par défaut lorsque l'information est manquante."

#: ../Doc/reference/import.rst:652
msgid "Here are the exact rules used:"
msgstr "Les règles exactes utilisées sont :"

#: ../Doc/reference/import.rst:654
msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""
"Si le module possède un attribut ``__spec__``, la valeur est utilisée pour "
"générer la représentation. Les attributs *name*, *loader*, *origin* et "
"*has_location* sont consultés."

#: ../Doc/reference/import.rst:658
msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr ""
"Si le module possède un attribut ``__file__``, il est utilisé pour "
"construire la représentation du module."

#: ../Doc/reference/import.rst:661
msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not "
"``None``, then the loader's repr is used as part of the module's repr."
msgstr ""
"Si le module ne possède pas d'attribut ``__file__`` mais possède un "
"``__loader__`` qui n'est pas ``None``, alors la représentation du chargeur "
"est utilisée pour construire la représentation du module."

#: ../Doc/reference/import.rst:664
msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr ""
"Sinon, il utilise juste le ``__name__`` du module dans la représentation."

#: ../Doc/reference/import.rst:666
msgid ""
"Use of :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` has "
"been deprecated and the module spec is now used by the import machinery to "
"generate a module repr."
msgstr ""
"L'utilisation de :meth:`loader.module_repr() <importlib.abc.Loader."
"module_repr>` est devenue obsolète et le spécificateur de module est utilisé "
"dorénavant par le mécanisme d'importation pour générer la représentation "
"textuelle du module."

#: ../Doc/reference/import.rst:671
msgid ""
"For backward compatibility with Python 3.3, the module repr will be "
"generated by calling the loader's :meth:`~importlib.abc.Loader.module_repr` "
"method, if defined, before trying either approach described above.  However, "
"the method is deprecated."
msgstr ""
"Par compatibilité descendante avec Python 3.3, la représentation textuelle "
"du module est générée en appelant la méthode :meth:`~importlib.abc.Loader."
"module_repr` du chargeur, si elle est définie, avant même d'essayer "
"l'approche décrite ci-dessus. Cependant, cette méthode est obsolète."

#: ../Doc/reference/import.rst:679
msgid "Cached bytecode invalidation"
msgstr "Invalidation de *bytecode* mis en cache"

#: ../Doc/reference/import.rst:681
msgid ""
"Before Python loads cached bytecode from ``.pyc`` file, it checks whether "
"the cache is up-to-date with the source ``.py`` file. By default, Python "
"does this by storing the source's last-modified timestamp and size in the "
"cache file when writing it. At runtime, the import system then validates the "
"cache file by checking the stored metadata in the cache file against the "
"source's metadata."
msgstr ""
"Avant que Python ne charge du *bytecode* en cache à partir d'un fichier ``."
"pyc``, il vérifie si ce cache est bien à jour par rapport au fichier source "
"``.py``. Python effectue cette vérification en stockant l'horodatage de la "
"dernière modification de la source ainsi que sa taille dans le fichier cache "
"au moment où il l'écrit. À l'exécution, le système d'importation valide le "
"fichier cache en comparant les métadonnées que le cache contient avec les "
"métadonnées de la source."

#: ../Doc/reference/import.rst:688
msgid ""
"Python also supports \"hash-based\" cache files, which store a hash of the "
"source file's contents rather than its metadata. There are two variants of "
"hash-based ``.pyc`` files: checked and unchecked. For checked hash-based ``."
"pyc`` files, Python validates the cache file by hashing the source file and "
"comparing the resulting hash with the hash in the cache file. If a checked "
"hash-based cache file is found to be invalid, Python regenerates it and "
"writes a new checked hash-based cache file. For unchecked hash-based ``."
"pyc`` files, Python simply assumes the cache file is valid if it exists. "
"Hash-based ``.pyc`` files validation behavior may be overridden with the :"
"option:`--check-hash-based-pycs` flag."
msgstr ""
"Python gère également les fichiers caches \"avec empreintes\", qui stockent "
"une empreinte (*hash* en anglais) du contenu de la source plutôt que des "
"métadonnées. Il existe deux variations des fichiers ``.pyc`` avec "
"empreintes : vérifiés et non-vérifiés. Pour les fichiers ``.pyc`` avec "
"empreinte vérifiés, Python valide le fichier cache en calculant l'empreinte "
"du fichier source et compare les empreintes. Si l'empreinte stockée dans le "
"fichier cache est invalide, Python la recalcule et écrit un nouveau fichier "
"cache avec empreinte. Pour les fichiers ``.pyc`` avec empreinte non "
"vérifiés, Python considère simplement que le fichier cache est valide s'il "
"existe. La validation (ou non) des fichiers ``.pyc`` avec empreinte peut "
"être définie avec l'option :option:`--check-hash-based-pycs`."

#: ../Doc/reference/import.rst:699
msgid ""
"Added hash-based ``.pyc`` files. Previously, Python only supported timestamp-"
"based invalidation of bytecode caches."
msgstr ""
"Ajout des fichiers ``.pyc`` avec empreinte. Auparavant, Python gérait les "
"caches de *bytecode* sur la base de l'horodatage."

#: ../Doc/reference/import.rst:705
msgid "The Path Based Finder"
msgstr "Le chercheur dans *path*"

#: ../Doc/reference/import.rst:710
msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` (:class:"
"`~importlib.machinery.PathFinder`), searches an :term:`import path`, which "
"contains a list of :term:`path entries <path entry>`.  Each path entry names "
"a location to search for modules."
msgstr ""
"Comme indiqué précédemment, Python est livré par défaut avec plusieurs "
"chercheurs dans les méta-chemins. L'un deux, appelé :term:`chercheur dans "
"path <path based finder>` (:class:`~importlib.machinery.PathFinder`), "
"recherche dans le :term:`chemin des importations <import path>` qui contient "
"une liste :term:`d'entrées dans path <path entry>`. Chaque entrée désigne un "
"emplacement où rechercher des modules."

#: ../Doc/reference/import.rst:716
msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr ""
"Le chercheur dans *path* en tant que tel ne sait pas comment importer quoi "
"que ce soit. Il ne fait que parcourir chaque entrée de *path* et associe à "
"chacune d'elle un \"chercheur d'entrée dans *path*\" qui sait comment gérer "
"le type particulier de chemin considéré."

#: ../Doc/reference/import.rst:720
msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and "
"shared libraries (e.g. ``.so`` files). When supported by the :mod:"
"`zipimport` module in the standard library, the default path entry finders "
"also handle loading all of these file types (other than shared libraries) "
"from zipfiles."
msgstr ""
"L'ensemble par défaut des \"chercheurs d'entrée dans *path*\" implémente "
"toute la sémantique pour trouver des modules dans le système de fichiers, "
"gérer des fichiers spéciaux tels que le code source Python (fichiers ``."
"py``), le *bytecode* Python (fichiers ``.pyc``) et les bibliothèques "
"partagées (par exemple les fichiers ``.so``). Quand le module :mod:"
"`zipimport` de la bibliothèque standard le permet, les \"chercheurs d'entrée "
"dans *path*\" par défaut savent aussi gérer tous ces types de fichiers "
"(autres que les bibliothèques partagées) encapsulés dans des fichiers zip."

#: ../Doc/reference/import.rst:727
msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr ""
"Les chemins ne sont pas limités au système de fichiers. Ils peuvent faire "
"référence à des URL, des requêtes dans des bases de données ou tout autre "
"emplacement qui peut être spécifié dans une chaîne de caractères."

#: ../Doc/reference/import.rst:731
msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example, "
"if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module "
"from the web."
msgstr ""
"Le chercheur dans *path* fournit aussi des points d'entrées (ou *hooks*) et "
"des protocoles de manière à pouvoir étendre et personnaliser les types de "
"chemins dans lesquels chercher. Par exemple, si vous voulez pouvoir chercher "
"dans des URL réseau, vous pouvez écrire une fonction « point d'entrée » qui "
"implémente la sémantique HTTP pour chercher des modules sur la toile. Ce "
"point d'entrée (qui doit être un appelable) doit renvoyer un :term:"
"`chercheur d'entrée dans path <path entry finder>` qui gère le protocole "
"décrit plus bas et qui sera utilisé pour obtenir un chargeur de module sur "
"la toile."

#: ../Doc/reference/import.rst:739
msgid ""
"A word of warning: this section and the previous both use the term *finder*, "
"distinguishing between them by using the terms :term:`meta path finder` and :"
"term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""
"Avertissement : cette section et la précédente utilisent toutes les deux le "
"terme *chercheur*, dans un cas :term:`chercheur dans les méta-chemins <meta "
"path finder>` et dans l'autre :term:`chercheur d'entrée dans path <path "
"entry finder>`. Ces deux types de chercheurs sont très similaires, gèrent "
"des protocoles similaires et fonctionnent de manière semblable pendant le "
"processus d'importation, mais il est important de garder à l'esprit qu'ils "
"sont subtilement différents. En particulier, les chercheurs dans les méta-"
"chemins opèrent au début du processus d'importation, comme clé de parcours "
"de :data:`sys.meta_path`."

#: ../Doc/reference/import.rst:747
msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""
"Au contraire, les \"chercheurs d'entrée dans *path*\" sont, dans un sens, un "
"détail d'implémentation du chercheur dans *path* et, en fait, si le "
"chercheur dans *path* était enlevé de :data:`sys.meta_path`, aucune des "
"sémantiques des \"chercheurs d'entrée dans *path*\" ne serait invoquée."

#: ../Doc/reference/import.rst:754
msgid "Path entry finders"
msgstr "Chercheurs d'entrée dans *path*"

#: ../Doc/reference/import.rst:762
msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""
"Le :term:`chercheur dans path <path based finder>` (*path based finder* en "
"anglais) est responsable de trouver et charger les modules et les paquets "
"Python dont l'emplacement est spécifié par une chaîne dite :term:`d'entrée "
"dans path <path entry>`. La plupart de ces entrées désignent des "
"emplacements sur le système de fichiers, mais il n'y a aucune raison de les "
"limiter à ça."

#: ../Doc/reference/import.rst:767
msgid ""
"As a meta path finder, the :term:`path based finder` implements the :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` protocol previously described, "
"however it exposes additional hooks that can be used to customize how "
"modules are found and loaded from the :term:`import path`."
msgstr ""
"En tant que chercheur dans les méta-chemins, un :term:`chercheur dans path "
"<path based finder>` implémente le protocole :meth:`~importlib.abc."
"MetaPathFinder.find_spec` décrit précédemment. Cependant, il autorise des "
"points d'entrée (*hooks* en anglais) supplémentaires qui peuvent être "
"utilisés pour personnaliser la façon dont les modules sont trouvés et "
"chargés depuis le :term:`chemin des importations <import path>`."

#: ../Doc/reference/import.rst:772
msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys."
"path`, :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""
"Trois variables sont utilisées par le :term:`chercheur dans path <path based "
"finder>` : :data:`sys.path`, :data:`sys.path_hooks` et :data:`sys."
"path_importer_cache`. L'attribut ``__path__`` des objets paquets est aussi "
"utilisé. Il permet de personnaliser encore davantage le mécanisme "
"d'importation."

#: ../Doc/reference/import.rst:777
msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :data:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the :mod:"
"`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings and bytes should be present on :data:`sys."
"path`; all other data types are ignored.  The encoding of bytes entries is "
"determined by the individual :term:`path entry finders <path entry finder>`."
msgstr ""
":data:`sys.path` contient une liste de chaînes de caractères indiquant des "
"emplacements où chercher des modules ou des paquets. Elle est initialisée à "
"partir de la variable d'environnement :data:`PYTHONPATH` et de plusieurs "
"autres valeurs par défaut qui dépendent de l'installation et de "
"l'implémentation. Les entrées de :data:`sys.path` désignent des répertoires "
"du système de fichiers, des fichiers zip et possiblement d'autres \"endroits"
"\" (lisez le module :mod:`site`) tels que des URL ou des requêtes dans des "
"bases de données où Python doit rechercher des modules. :data:`sys.path` ne "
"doit contenir que des chaînes de caractères ou d'octets ; tous les autres "
"types sont ignorés. L'encodage des entrées de chaînes d'octets est déterminé "
"par chaque :term:`chercheur d'entrée dans path <path entry finder>`."

#: ../Doc/reference/import.rst:788
msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to :meth:`~importlib."
"machinery.PathFinder.find_spec` is given, it will be a list of string paths "
"to traverse - typically a package's ``__path__`` attribute for an import "
"within that package.  If the ``path`` argument is ``None``, this indicates a "
"top level import and :data:`sys.path` is used."
msgstr ""
"Le :term:`chercheur dans path <path based finder>` est un :term:`chercheur "
"dans les méta-chemins <meta path finder>`, donc le mécanisme d'importation "
"commence la recherche dans le :term:`chemin des importations <import path>` "
"par un appel à la méthode :meth:`~importlib.machinery.PathFinder.find_spec` "
"du chercheur dans *path*, comme décrit précédemment. Quand l'argument *path* "
"de :meth:`~importlib.machinery.PathFinder.find_spec` est donné, c'est une "
"liste de chemins à parcourir, typiquement un attribut ``__path__`` pour une "
"importation à l'intérieur d'un paquet. Si l'argument *path* est ``None``, "
"cela indique une importation de niveau le plus haut et :data:`sys.path` est "
"utilisée."

#: ../Doc/reference/import.rst:797
msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` (:class:"
"`~importlib.abc.PathEntryFinder`) for the path entry.  Because this can be "
"an expensive operation (e.g. there may be `stat()` call overheads for this "
"search), the path based finder maintains a cache mapping path entries to "
"path entry finders.  This cache is maintained in :data:`sys."
"path_importer_cache` (despite the name, this cache actually stores finder "
"objects rather than being limited to :term:`importer` objects). In this way, "
"the expensive search for a particular :term:`path entry` location's :term:"
"`path entry finder` need only be done once.  User code is free to remove "
"cache entries from :data:`sys.path_importer_cache` forcing the path based "
"finder to perform the path entry search again [#fnpic]_."
msgstr ""
"Le chercheur dans *path* itère sur chaque entrée dans le *path* et, pour "
"chacune, regarde s'il trouve un :term:`chercheur d'entrée dans path <path "
"entry finder>` (:class:`~importlib.abc.PathEntryFinder`) approprié à cette "
"entrée. Comme cette opération est coûteuse (elle peut faire appel à "
"plusieurs `stat()` pour cela), le chercheur dans *path* maintient un cache "
"de correspondance entre les entrées et les \"chercheurs d'entrée dans *path*"
"\". Ce cache est géré par :data:`sys.path_importer_cache` (en dépit de son "
"nom, ce cache stocke les objets chercheurs plutôt que les simples objets :"
"term:`importateurs <importer>`). Ainsi, la recherche coûteuse pour une :term:"
"`entrée de path <path entry>` spécifique n'a besoin d'être effectuée qu'une "
"seule fois par le :term:`chercheur d'entrée dans path <path entry finder>`. "
"Le code de l'utilisateur peut très bien supprimer les entrées du cache :data:"
"`sys.path_importer_cache`, forçant ainsi le chercheur dans *path* à "
"effectuer une nouvelle fois la recherche sur chaque entrée [#fnpic]_."

#: ../Doc/reference/import.rst:810
msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the :term:"
"`path entry hooks <path entry hook>` in this list is called with a single "
"argument, the path entry to be searched.  This callable may either return a :"
"term:`path entry finder` that can handle the path entry, or it may raise :"
"exc:`ImportError`.  An :exc:`ImportError` is used by the path based finder "
"to signal that the hook cannot find a :term:`path entry finder` for that :"
"term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""
"Si une entrée n'est pas présente dans le cache, le chercheur dans *path* "
"itère sur chaque *callable* de :data:`sys.path_hooks`. Chaque :term:`point "
"d'entrée sur une entrée de path <path entry hook>` de cette liste est appelé "
"avec un unique argument, l'entrée dans laquelle chercher. L'appelable peut "
"soit renvoyer un :term:`chercheur d'entrée dans path <path entry finder>` "
"apte à prendre en charge l'entrée ou lever une :exc:`ImportError`. Une :exc:"
"`ImportError` est utilisée par le chercheur dans *path* pour signaler que le "
"point d'entrée n'a pas trouvé de :term:`chercheur d'entrée dans path <path "
"entry finder>` pour cette :term:`entrée <path entry>`. L'exception est "
"ignorée et l'itération sur le :term:`chemin des importations <import path>` "
"se poursuit. Le point d'entrée doit attendre qu'on lui passe soit une chaîne "
"de caractères soit une chaîne d'octets ; l'encodage des chaînes d'octets est "
"à la main du point d'entrée (par exemple, ce peut être l'encodage du système "
"de fichiers, de l'UTF-8 ou autre chose) et, si le point d'entrée n'arrive "
"pas à décoder l'argument, il doit lever une :exc:`ImportError`."

#: ../Doc/reference/import.rst:824
msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's :meth:`~importlib.machinery."
"PathFinder.find_spec` method will store ``None`` in :data:`sys."
"path_importer_cache` (to indicate that there is no finder for this path "
"entry) and return ``None``, indicating that this :term:`meta path finder` "
"could not find the module."
msgstr ""
"Si l'itération sur :data:`sys.path_hooks` se termine sans qu'aucun :term:"
"`chercheur d'entrée dans path <path entry finder>` ne soit renvoyé, alors la "
"méthode :meth:`~importlib.machinery.PathFinder.find_spec` du chercheur dans "
"*path* stocke ``None`` dans le :data:`sys.path_importer_cache` (pour "
"indiquer qu'il n'y a pas de chercheur pour cette entrée) et renvoie "
"``None``, indiquant que ce :term:`chercheur dans les méta-chemins <meta path "
"finder>` n'a pas trouvé le module."

#: ../Doc/reference/import.rst:831
msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry "
"hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""
"Si un :term:`chercheur d'entrée dans path <path entry finder>` *est* renvoyé "
"par un des :term:`points d'entrée <path entry hook>` de :data:`sys."
"path_hooks`, alors le protocole suivant est utilisé pour demander un "
"spécificateur de module au chercheur, spécificateur qui sera utilisé pour "
"charger le module."

#: ../Doc/reference/import.rst:836
msgid ""
"The current working directory -- denoted by an empty string -- is handled "
"slightly differently from other entries on :data:`sys.path`. First, if the "
"current working directory is found to not exist, no value is stored in :data:"
"`sys.path_importer_cache`. Second, the value for the current working "
"directory is looked up fresh for each module lookup. Third, the path used "
"for :data:`sys.path_importer_cache` and returned by :meth:`importlib."
"machinery.PathFinder.find_spec` will be the actual current working directory "
"and not the empty string."
msgstr ""
"Le répertoire de travail courant — noté sous la forme d'une chaîne de "
"caractères vide — est géré d'une manière légèrement différente des autres "
"entrées de :data:`sys.path`. D'abord, si le répertoire de travail courant "
"s'avère ne pas exister, aucune valeur n'est stockée dans :data:`sys."
"path_importer_cache`. Ensuite, la valeur pour le répertoire de travail "
"courant est vérifiée à chaque recherche de module. Enfin, le chemin utilisé "
"pour :data:`sys.path_importer_cache` et renvoyée par :meth:`importlib."
"machinery.PathFinder.find_spec` est le nom réel du répertoire de travail "
"courant et non pas la chaîne vide."

#: ../Doc/reference/import.rst:846
msgid "Path entry finder protocol"
msgstr "Protocole des chercheurs d'entrée dans *path*"

#: ../Doc/reference/import.rst:848
msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement "
"the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""
"Afin de gérer les importations de modules, l'initialisation des paquets et "
"d'être capables de contribuer aux portions des paquets-espaces de nommage, "
"les chercheurs d'entrée dans *path* doivent implémenter la méthode :meth:"
"`~importlib.abc.PathEntryFinder.find_spec`."

#: ../Doc/reference/import.rst:852
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two arguments: the "
"fully qualified name of the module being imported, and the (optional) target "
"module.  ``find_spec()`` returns a fully populated spec for the module. This "
"spec will always have \"loader\" set (with one exception)."
msgstr ""
"La méthode :meth:`~importlib.abc.PathEntryFinder.find_spec` prend deux "
"arguments : le nom complètement qualifié du module en cours d'importation et "
"(optionnellement) le module cible. ``find_spec()`` renvoie un spécificateur "
"de module pleinement peuplé. Ce spécificateur doit avoir son chargeur "
"(attribut `loader`) défini, à une exception près."

#: ../Doc/reference/import.rst:857
msgid ""
"To indicate to the import machinery that the spec represents a namespace :"
"term:`portion`. the path entry finder sets \"loader\" on the spec to "
"``None`` and \"submodule_search_locations\" to a list containing the portion."
msgstr ""
"Pour indiquer au mécanisme d'importation que le spécificateur représente "
"une :term:`portion <portion>` d'un espace de nommage, le chercheur d'entrée "
"dans *path* définit le chargeur du spécificateur à ``None`` et l'attribut "
"*submodule_search_locations* à une liste contenant la portion."

#: ../Doc/reference/import.rst:862
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced :meth:`~importlib."
"abc.PathEntryFinder.find_loader` and :meth:`~importlib.abc.PathEntryFinder."
"find_module`, both of which are now deprecated, but will be used if "
"``find_spec()`` is not defined."
msgstr ""
"La méthode :meth:`~importlib.abc.PathEntryFinder.find_spec` remplace :meth:"
"`~importlib.abc.PathEntryFinder.find_loader` et :meth:`~importlib.abc."
"PathEntryFinder.find_module`, ces deux méthodes étant dorénavant obsolètes "
"mais restant utilisées si ``find_spec()`` n'est pas définie."

#: ../Doc/reference/import.rst:868
msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of "
"backward compatibility.  However, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""
"Les vieux chercheurs d'entrée dans *path* peuvent implémenter une des deux "
"méthodes obsolètes à la place de ``find_spec()``. Ces méthodes sont toujours "
"prises en compte dans le cadre de la compatibilité descendante. Cependant, "
"si ``find_spec()`` est implémentée par le chercheur d'entrée dans *path*, "
"les méthodes historiques sont ignorées."

#: ../Doc/reference/import.rst:873
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` takes one argument, the "
"fully qualified name of the module being imported.  ``find_loader()`` "
"returns a 2-tuple where the first item is the loader and the second item is "
"a namespace :term:`portion`.  When the first item (i.e. the loader) is "
"``None``, this means that while the path entry finder does not have a loader "
"for the named module, it knows that the path entry contributes to a "
"namespace portion for the named module.  This will almost always be the case "
"where Python is asked to import a namespace package that has no physical "
"presence on the file system.  When a path entry finder returns ``None`` for "
"the loader, the second item of the 2-tuple return value must be a sequence, "
"although it can be empty."
msgstr ""
"La méthode :meth:`~importlib.abc.PathEntryFinder.find_loader` prend un "
"argument, le nom complètement qualifié du module en cours d'importation. "
"``find_loader()`` renvoie un couple dont le premier élément est le chargeur "
"et le second est une :term:`portion <portion>` d'espace de nommage. Quand le "
"premier élément (c'est-à-dire le chargeur) est ``None``, cela signifie que, "
"bien que le chercheur d'entrée dans *path* n'a pas de chargeur pour le "
"module considéré, il sait que cette entrée contribue à une portion d'espace "
"de nommage pour le module considéré. C'est presque toujours le cas quand "
"vous demandez à Python d'importer un paquet-espace de nommage qui n'est pas "
"présent physiquement sur le système de fichiers. Quand un chercheur d'entrée "
"dans *path* renvoie ``None`` pour le chargeur, la valeur du second élément "
"du couple renvoyé doit être une séquence, éventuellement vide."

#: ../Doc/reference/import.rst:885
msgid ""
"If ``find_loader()`` returns a non-``None`` loader value, the portion is "
"ignored and the loader is returned from the path based finder, terminating "
"the search through the path entries."
msgstr ""
"Si ``find_loader()`` renvoie une valeur de chargeur qui n'est pas ``None``, "
"la portion est ignorée et le chargeur est renvoyé par le chercheur dans "
"*path*, mettant un terme à la recherche dans les chemins."

#: ../Doc/reference/import.rst:889
msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""
"À fin de compatibilité descendante avec d'autres implémentations du "
"protocole d'importation, beaucoup de chercheurs d'entrée dans *path* gèrent "
"aussi la méthode traditionnelle ``find_module()`` que l'on trouve dans les "
"chercheurs dans les méta-chemins. Cependant, les méthodes ``find_module()`` "
"des chercheurs d'entrée dans *path* ne sont jamais appelées avec un argument "
"*path* (il est convenu qu'elles enregistrent les informations relatives au "
"chemin approprié au moment de leur appel initial au point d'entrée)."

#: ../Doc/reference/import.rst:896
msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does "
"not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""
"La méthode ``find_module()`` des chercheurs d'entrée dans *path* est "
"obsolète car elle n'autorise pas le chercheur d'entrée dans *path* à "
"contribuer aux portions d'espaces de nommage des paquets-espaces de nommage. "
"Si à la fois ``find_loader()`` et ``find_module()`` sont définies pour un "
"chercheur d'entrée dans *path*, le système d'importation utilise toujours "
"``find_loader()`` plutôt que ``find_module()``."

#: ../Doc/reference/import.rst:904
msgid "Replacing the standard import system"
msgstr "Remplacement du système d'importation standard"

#: ../Doc/reference/import.rst:906
msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""
"La manière la plus fiable de remplacer tout le système d'importation est de "
"supprimer le contenu par défaut de :data:`sys.meta_path` et de le remplacer "
"complètement par un chercheur dans les méta-chemins sur mesure."

#: ../Doc/reference/import.rst:910
msgid ""
"If it is acceptable to only alter the behaviour of import statements without "
"affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""
"S'il convient juste de modifier le comportement de l'instruction import sans "
"affecter les autres API qui utilisent le système d'importation, alors "
"remplacer la fonction native :func:`__import__` peut être suffisant. Cette "
"technique peut aussi être employée au niveau d'un module pour n'altérer le "
"comportement des importations qu'à l'intérieur de ce module."

#: ../Doc/reference/import.rst:916
msgid ""
"To selectively prevent the import of some modules from a hook early on the "
"meta path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ModuleNotFoundError` directly from :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` instead of returning ``None``. The "
"latter indicates that the meta path search should continue, while raising an "
"exception terminates it immediately."
msgstr ""
"Pour empêcher sélectivement l'importation de certains modules par un point "
"d'entrée placé en tête dans le méta-chemin (plutôt que de désactiver "
"complètement le système d'importation), il suffit de lever une :exc:"
"`ModuleNotFoundError` directement depuis :meth:`~importlib.abc."
"MetaPathFinder.find_spec` au lieu de renvoyer ``None``. En effet, ce dernier "
"indique que la recherche dans le méta-chemin peut continuer alors que la "
"levée de l'exception termine immédiatement la recherche."

#: ../Doc/reference/import.rst:926
msgid "Package Relative Imports"
msgstr "Importations relatives au paquet"

#: ../Doc/reference/import.rst:928
msgid ""
"Relative imports use leading dots. A single leading dot indicates a relative "
"import, starting with the current package. Two or more leading dots indicate "
"a relative import to the parent(s) of the current package, one level per dot "
"after the first. For example, given the following package layout::"
msgstr ""
"Les importations relatives commencent par une suite de points. Un seul point "
"avant indique une importation relative, démarrant avec le paquet actuel. "
"Deux points ou plus avant indiquent une importation relative au parent du "
"paquet actuel, un niveau par point avant le premier. Par exemple, en ayant "
"le contenu suivant ::"

#: ../Doc/reference/import.rst:944
msgid ""
"In either ``subpackage1/moduleX.py`` or ``subpackage1/__init__.py``, the "
"following are valid relative imports::"
msgstr ""
"Dans ``subpackage1/moduleX.py`` ou ``subpackage1/__init__.py``, les "
"importations suivantes sont des importations relatives valides ::"

#: ../Doc/reference/import.rst:954
msgid ""
"Absolute imports may use either the ``import <>`` or ``from <> import <>`` "
"syntax, but relative imports may only use the second form; the reason for "
"this is that::"
msgstr ""
"Les importations absolues peuvent utiliser soit la syntaxe ``import <>``, "
"soit ``from <> import <>``, mais les importations relatives doivent "
"seulement utiliser la deuxième forme, la raison étant ::"

#: ../Doc/reference/import.rst:960
msgid ""
"should expose ``XXX.YYY.ZZZ`` as a usable expression, but .moduleY is not a "
"valid expression."
msgstr ""
"devrait exposer ``XXX.YYY.ZZZ`` comme une expression utilisable, mais ``."
"moduleY`` n’est pas une expression valide."

#: ../Doc/reference/import.rst:965
msgid "Special considerations for __main__"
msgstr "Cas particulier de ``__main__``"

#: ../Doc/reference/import.rst:967
msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and :mod:"
"`builtins`.  However, unlike those two, it doesn't strictly qualify as a "
"built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""
"Le module :mod:`__main__` est un cas particulier pour le système "
"d'importation de Python. Comme indiqué par :ref:`ailleurs <programs>`, le "
"module ``__main__`` est initialisé directement au démarrage de "
"l'interpréteur, un peu comme :mod:`sys` et :mod:`builtins`. Cependant, au "
"contraire des deux cités précédemment, ce n'est pas vraiment un module "
"natif. Effectivement, la manière dont est initialisé ``__main__`` dépend des "
"drapeaux et options avec lesquels l'interpréteur est lancé."

#: ../Doc/reference/import.rst:978
msgid "__main__.__spec__"
msgstr "``__main__.__spec__``"

#: ../Doc/reference/import.rst:980
msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr ""
"En fonction de la manière dont :mod:`__main__` est initialisé, ``__main__."
"__spec__`` est défini de manière conforme ou mis à ``None``."

#: ../Doc/reference/import.rst:983
msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also "
"populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""
"Quand Python est démarré avec l'option :option:`-m`, ``__spec__`` est défini "
"à la valeur du spécificateur du module ou paquet correspondant. Python "
"peuple aussi ``__spec__`` quand le module ``__main__`` est chargé en tant "
"que partie de l'exécution d'un répertoire, d'un fichier zip ou d'une entrée "
"de :data:`sys.path`."

#: ../Doc/reference/import.rst:988
msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` ``__main__."
"__spec__`` is set to ``None``, as the code used to populate the :mod:"
"`__main__` does not correspond directly with an importable module:"
msgstr ""
"Dans :ref:`les autres cas <using-on-interface-options>`, ``__main__."
"__spec__`` est mis à ``None``, car le code qui peuple :mod:`__main__` ne "
"trouve pas de correspondance directe avec un module que l'on importe :"

#: ../Doc/reference/import.rst:992
msgid "interactive prompt"
msgstr "invite de commande interactive"

#: ../Doc/reference/import.rst:993
msgid ":option:`-c` option"
msgstr "l'option :option:`-c`"

#: ../Doc/reference/import.rst:994
msgid "running from stdin"
msgstr "lecture depuis l'entrée standard"

#: ../Doc/reference/import.rst:995
msgid "running directly from a source or bytecode file"
msgstr "lecture depuis un fichier de code source ou de *bytecode*"

#: ../Doc/reference/import.rst:997
msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use "
"the :option:`-m` switch if valid module metadata is desired in :mod:"
"`__main__`."
msgstr ""
"Notez que ``__main__.__spec__`` vaut toujours ``None`` dans le dernier cas, "
"*même si* le fichier pourrait techniquement être importé directement en tant "
"que module. Utilisez l'option :option:`-m` si vous souhaitez disposer de "
"métadonnées valides du module dans :mod:`__main__`."

#: ../Doc/reference/import.rst:1002
msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""
"Notez aussi que même quand ``__main__`` correspond à un module importable et "
"que ``__main__.__spec__`` est défini en conséquence, ils seront toujours "
"considérés comme des modules *distincts*. Cela est dû au fait que le bloc "
"encadré par ``if __name__ == \"__main__\":`` ne s'exécute que quand le "
"module est utilisé pour peupler l'espace de nommage de ``__main__``, et pas "
"durant une importation normale."

#: ../Doc/reference/import.rst:1010
msgid "Open issues"
msgstr "Idées d'amélioration"

#: ../Doc/reference/import.rst:1012
msgid "XXX It would be really nice to have a diagram."
msgstr "XXX Ce serait vraiment bien de disposer d'un diagramme."

#: ../Doc/reference/import.rst:1014
msgid ""
"XXX * (import_machinery.rst) how about a section devoted just to the "
"attributes of modules and packages, perhaps expanding upon or supplanting "
"the related entries in the data model reference page?"
msgstr ""
"XXX * (``import_machinery.rst``) Pourquoi pas une section dédiée aux "
"attributs des modules et paquets, développant ou remplaçant les entrées "
"associées dans la page de référence du modèle de données ?"

#: ../Doc/reference/import.rst:1018
msgid ""
"XXX runpy, pkgutil, et al in the library manual should all get \"See Also\" "
"links at the top pointing to the new import system section."
msgstr ""
"XXX *runpy*, *pkgutil* et autres dans le manuel de la bibliothèque devraient "
"comporter un lien \"Lisez aussi\" en début de page pointant vers la section "
"du nouveau mécanisme d'import."

#: ../Doc/reference/import.rst:1021
msgid ""
"XXX Add more explanation regarding the different ways in which ``__main__`` "
"is initialized?"
msgstr ""
"XXX Ajouter des explications sur les différentes manières dont ``__main__`` "
"est initialisé ?"

#: ../Doc/reference/import.rst:1024
msgid ""
"XXX Add more info on ``__main__`` quirks/pitfalls (i.e. copy from :pep:"
"`395`)."
msgstr ""
"XXX Ajouter des informations sur les pièges et bizarreries de ``__main__`` "
"(c.-à-d. des extraits de la :pep:`395`)."

#: ../Doc/reference/import.rst:1029
msgid "References"
msgstr "Références"

#: ../Doc/reference/import.rst:1031
msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages <https://www.python.org/doc/essays/"
"packages/>`_ is still available to read, although some details have changed "
"since the writing of that document."
msgstr ""
"Le mécanisme d'importation a considérablement évolué depuis les débuts de "
"Python. La `spécification des paquets <https://www.python.org/doc/essays/"
"packages/>`_ originale est toujours disponible, bien que quelques détails "
"ont changé depuis l'écriture de ce document."

#: ../Doc/reference/import.rst:1036
msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ""
"La spécification originale de :data:`sys.meta_path` se trouve dans la :pep:"
"`302`. La :pep:`420` contient des extensions significatives."

#: ../Doc/reference/import.rst:1039
msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`find_loader` protocol as "
"an alternative to :meth:`find_module`."
msgstr ""
"La :pep:`420` a introduit les :term:`paquets-espaces de nommage <namespace "
"package>` pour Python 3.3. La :pep:`420` a aussi introduit le protocole :"
"meth:`recherche du chargeur <find_loader>` comme une alternative à :meth:"
"`find_module`."

#: ../Doc/reference/import.rst:1043
msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""
"La :pep:`366` décrit l'ajout de l'attribut ``__package__`` pour les "
"importations relatives explicites dans les modules principaux."

#: ../Doc/reference/import.rst:1046
msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""
"La :pep:`328` a introduit les importations absolues et les importations "
"relatives explicites. Elle a aussi proposé ``__name__`` pour la sémantique "
"que la :pep:`366` attribuait à ``__package__``."

#: ../Doc/reference/import.rst:1050
msgid ":pep:`338` defines executing modules as scripts."
msgstr ":pep:`338` définit l'exécution de modules en tant que scripts."

#: ../Doc/reference/import.rst:1052
msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the deprecation "
"of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""
":pep:`451` ajoute l'encapsulation dans les objets spécificateurs de l'état "
"des importations, module par module. Elle reporte aussi la majorité des "
"responsabilités des chargeurs vers le mécanisme d'import. Ces changements "
"permettent de supprimer plusieurs API dans le système d'importation et "
"d'ajouter de nouvelles méthodes aux chercheurs et chargeurs."

#: ../Doc/reference/import.rst:1059
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/reference/import.rst:1060
msgid "See :class:`types.ModuleType`."
msgstr "Voir :class:`types.ModuleType`."

#: ../Doc/reference/import.rst:1062
msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in :data:"
"`sys.modules`.  The indirect effect of this is that an imported module may "
"replace itself in :data:`sys.modules`.  This is implementation-specific "
"behavior that is not guaranteed to work in other Python implementations."
msgstr ""
"L'implémentation de *importlib* évite d'utiliser directement la valeur de "
"retour. À la place, elle récupère l'objet module en recherchant le nom du "
"module dans :data:`sys.modules`. L'effet indirect est que le module importé "
"peut remplacer le module de même nom dans :data:`sys.modules`. C'est un "
"comportement spécifique à l'implémentation dont le résultat n'est pas "
"garanti pour les autres implémentations de Python."

#: ../Doc/reference/import.rst:1069
msgid ""
"In legacy code, it is possible to find instances of :class:`imp."
"NullImporter` in the :data:`sys.path_importer_cache`.  It is recommended "
"that code be changed to use ``None`` instead.  See :ref:`portingpythoncode` "
"for more details."
msgstr ""
"Dans du code historique, il est possible de trouver des instances de :class:"
"`imp.NullImporter` dans :data:`sys.path_importer_cache`. Il est recommandé "
"de modifier ce code afin d'utiliser ``None`` à la place. Lisez :ref:"
"`portingpythoncode` pour plus de détails."

#~ msgid "-c switch"
#~ msgstr "option *-c* de la ligne de commande"
