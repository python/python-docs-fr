# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:42+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "Analyse lexicale"

#: ../Doc/reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Un programme Python est lu par un analyseur syntaxique (*parser* en "
"anglais). En entrée de cet analyseur syntaxique, nous trouvons des lexèmes "
"(*tokens* en anglais), produits par un analyseur lexical. Ce chapitre décrit "
"comment l'analyseur lexical découpe le fichier en lexèmes."

#: ../Doc/reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Python lit le texte du programme comme des suites de caractères Unicode ; "
"l'encodage du fichier source peut être spécifié par une déclaration "
"d'encodage et vaut par défaut UTF-8, voir la :pep:`3120` pour les détails. "
"Si le fichier source ne peut pas être décodé, une exception :exc:"
"`SyntaxError` (erreur de syntaxe) est levée."

#: ../Doc/reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "Structure des lignes"

#: ../Doc/reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Un programme en Python est divisé en *lignes logiques*."

#: ../Doc/reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "Lignes logiques"

#: ../Doc/reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"La fin d'une ligne logique est représentée par le lexème NEWLINE. Les "
"instructions ne peuvent pas traverser les limites des lignes logiques, sauf "
"quand NEWLINE est autorisé par la syntaxe (par exemple, entre les "
"instructions des instructions composées). Une ligne logique est constituée "
"d'une ou plusieurs *lignes physiques* en fonction des règles, explicites ou "
"implicites, de *continuation de ligne*."

#: ../Doc/reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "Lignes physiques"

#: ../Doc/reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files, any of the standard platform line termination "
"sequences can be used - the Unix form using ASCII LF (linefeed), the Windows "
"form using the ASCII sequence CR LF (return followed by linefeed), or the "
"old Macintosh form using the ASCII CR (return) character.  All of these "
"forms can be used equally, regardless of platform."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:56
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"Lorsque vous encapsulez Python, les chaînes de code source doivent être "
"passées à l'API Python en utilisant les conventions du C standard pour les "
"caractères de fin de ligne : le caractère ``\\n``, dont le code ASCII est LF."

#: ../Doc/reference/lexical_analysis.rst:64
msgid "Comments"
msgstr "Commentaires"

#: ../Doc/reference/lexical_analysis.rst:68
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax; they are not tokens."
msgstr ""
"Un commentaire commence par le caractère croisillon (``#``, *hash* en "
"anglais et qui ressemble au symbole musical dièse, c'est pourquoi il est "
"souvent improprement appelé caractère dièse) situé en dehors d'une chaine de "
"caractères littérale et se termine à la fin de la ligne physique. Un "
"commentaire signifie la fin de la ligne logique à moins qu'une règle de "
"continuation de ligne implicite ne s'applique. Les commentaires sont ignorés "
"au niveau syntaxique, ce ne sont pas des lexèmes."

#: ../Doc/reference/lexical_analysis.rst:77
msgid "Encoding declarations"
msgstr "Déclaration d'encodage"

#: ../Doc/reference/lexical_analysis.rst:81
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Si un commentaire placé sur la première ou deuxième ligne du script Python "
"correspond à l'expression rationnelle ``coding[=:]\\s*([-\\w.]+)``, ce "
"commentaire est analysé comme une déclaration d'encodage ; le premier groupe "
"de cette expression désigne l'encodage du fichier source. Cette déclaration "
"d'encodage doit être seule sur sa ligne et, si elle est sur la deuxième "
"ligne, la première ligne doit aussi être une ligne composée uniquement d'un "
"commentaire. Les formes recommandées pour l'expression de l'encodage sont ::"

#: ../Doc/reference/lexical_analysis.rst:90
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "qui est reconnue aussi par GNU Emacs et ::"

#: ../Doc/reference/lexical_analysis.rst:94
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "qui est reconnue par VIM de Bram Moolenaar."

#: ../Doc/reference/lexical_analysis.rst:96
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""
"Si aucune déclaration d'encodage n'est trouvée, l'encodage par défaut est "
"utilisé : UTF-8. En plus, si les premiers octets du fichier sont "
"l'indicateur d'ordre des octets UTF-8 (``b'\\xef\\xbb\\xbf'``, *BOM* en "
"anglais pour *byte order mark*), le fichier est considéré comme étant en "
"UTF-8 (cette convention est reconnue, entre autres, par :program:`notepad` "
"de Microsoft)."

#: ../Doc/reference/lexical_analysis.rst:101
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python. "
"The encoding is used for all lexical analysis, including string literals, "
"comments and identifiers."
msgstr ""
"Si un encodage est déclaré, le nom de l'encodage doit être reconnu par "
"Python. L'encodage est utilisé pour toute l'analyse lexicale, y compris les "
"chaînes de caractères, les commentaires et les identifiants."

#: ../Doc/reference/lexical_analysis.rst:111
msgid "Explicit line joining"
msgstr "Continuation de ligne explicite"

#: ../Doc/reference/lexical_analysis.rst:115
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Deux lignes physiques, ou plus, peuvent être jointes pour former une seule "
"ligne logique en utilisant la barre oblique inversée (``\\``) selon la règle "
"suivante : quand la ligne physique se termine par une barre oblique inversée "
"qui ne fait pas partie d'une chaine de caractères ou d'un commentaire, la "
"ligne immédiatement suivante lui est adjointe pour former une seule ligne "
"logique, en supprimant la barre oblique inversée et le caractère de fin de "
"ligne. Par exemple ::"

#: ../Doc/reference/lexical_analysis.rst:126
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"Une ligne que se termine par une barre oblique inversée ne peut pas avoir de "
"commentaire. La barre oblique inversée ne permet pas de continuer un "
"commentaire. La barre oblique inversée ne permet pas de continuer un lexème, "
"sauf s'il s'agit d'une chaîne de caractères (par exemple, les lexèmes autres "
"que les chaînes de caractères ne peuvent pas être répartis sur plusieurs "
"lignes en utilisant une barre oblique inversée). La barre oblique inversée "
"n'est pas autorisée ailleurs sur la ligne, en dehors d'une chaîne de "
"caractères."

#: ../Doc/reference/lexical_analysis.rst:136
msgid "Implicit line joining"
msgstr "Continuation de ligne implicite"

#: ../Doc/reference/lexical_analysis.rst:138
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Les expressions entre parenthèses, crochets ou accolades peuvent être "
"réparties sur plusieurs lignes sans utiliser de barre oblique inversée. Par "
"exemple ::"

#: ../Doc/reference/lexical_analysis.rst:146
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"Les lignes continuées implicitement peuvent avoir des commentaires. "
"L'indentation des lignes de continuation n'est pas importante. Une ligne "
"blanche est autorisée comme ligne de continuation. Il ne doit pas y avoir de "
"lexème NEWLINE entre des lignes implicitement continuées. Les lignes "
"continuées implicitement peuvent être utilisées dans des chaînes entre "
"triples guillemets (voir ci-dessous) ; dans ce cas, elles ne peuvent pas "
"avoir de commentaires."

#: ../Doc/reference/lexical_analysis.rst:156
msgid "Blank lines"
msgstr "Lignes vierges"

#: ../Doc/reference/lexical_analysis.rst:160
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"Une ligne logique qui ne contient que des espaces, tabulations, caractères "
"de saut de page (*formfeed* en anglais) ou commentaires est ignorée (c'est-à-"
"dire que le lexème NEWLINE n'est pas produit). Pendant l'édition interactive "
"d'instructions, la gestion des lignes vierges peut différer en fonction de "
"l'implémentation de la boucle REPL. Dans l'interpréteur standard, une ligne "
"complètement vierge (c'est-à-dire ne contenant strictement rien, même pas "
"une espace ou un commentaire) termine une instruction multi-lignes."

#: ../Doc/reference/lexical_analysis.rst:171
msgid "Indentation"
msgstr "Indentation"

#: ../Doc/reference/lexical_analysis.rst:175
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"Des espaces ou tabulations au début d’une ligne logique sont utilisées pour "
"connaître le niveau d’indentation de la ligne, qui est ensuite utilisé pour "
"déterminer comment les instructions sont groupées."

#: ../Doc/reference/lexical_analysis.rst:179
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"Les tabulations sont remplacées (de la gauche vers la droite) par une à huit "
"espaces de manière à ce que le nombre de caractères remplacés soit un "
"multiple de huit (nous avons ainsi la même règle que celle d'Unix). Le "
"nombre total d'espaces précédant le premier caractère non blanc détermine "
"alors le niveau d'indentation de la ligne. L'indentation ne peut pas être "
"répartie sur plusieurs lignes physiques à l'aide de barres obliques "
"inversées ; les espaces jusqu'à la première barre oblique inversée "
"déterminent l'indentation."

#: ../Doc/reference/lexical_analysis.rst:187
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"L'indentation est déclarée inconsistante et rejetée si, dans un même fichier "
"source, le mélange des tabulations et des espaces est tel que la "
"signification dépend du nombre d'espaces que représente une tabulation. Une "
"exception :exc:`TabError` est levée dans ce cas."

#: ../Doc/reference/lexical_analysis.rst:191
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Note de compatibilité entre les plateformes :** en raison de la nature des "
"éditeurs de texte sur les plateformes non Unix, il n'est pas judicieux "
"d'utiliser un mélange d'espaces et de tabulations pour l'indentation dans un "
"seul fichier source. Il convient également de noter que des plateformes "
"peuvent explicitement limiter le niveau d'indentation maximal."

#: ../Doc/reference/lexical_analysis.rst:196
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Un caractère de saut de page peut être présent au début de la ligne ; il est "
"ignoré pour les calculs d'indentation ci-dessus. Les caractères de saut de "
"page se trouvant ailleurs avec les espaces en tête de ligne ont un effet "
"indéfini (par exemple, ils peuvent remettre à zéro le nombre d'espaces)."

#: ../Doc/reference/lexical_analysis.rst:203
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""
"Les niveaux d'indentation de lignes consécutives sont utilisés pour générer "
"les lexèmes INDENT et DEDENT, en utilisant une pile, de cette façon :"

#: ../Doc/reference/lexical_analysis.rst:206
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"Avant que la première ligne du fichier ne soit lue, un \"zéro\" est posé sur "
"la pile ; il ne sera plus jamais enlevé. Les nombres empilés sont toujours "
"strictement croissants de bas en haut. Au début de chaque ligne logique, le "
"niveau d'indentation de la ligne est comparé au sommet de la pile. S'ils "
"sont égaux, il ne se passe rien. S'il est plus grand, il est empilé et un "
"lexème INDENT est produit. S'il est plus petit, il *doit* être l'un des "
"nombres présents dans la pile ; tous les nombres de la pile qui sont plus "
"grands sont retirés et, pour chaque nombre retiré, un lexème DEDENT est "
"produit. À la fin du fichier, un lexème DEDENT est produit pour chaque "
"nombre supérieur à zéro restant sur la pile."

#: ../Doc/reference/lexical_analysis.rst:217
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Voici un exemple de code Python correctement indenté (bien que très "
"confus) ::"

#: ../Doc/reference/lexical_analysis.rst:232
msgid "The following example shows various indentation errors::"
msgstr "L'exemple suivant montre plusieurs erreurs d'indentation ::"

#: ../Doc/reference/lexical_analysis.rst:242
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"En fait, les trois premières erreurs sont détectées par l'analyseur "
"syntaxique ; seule la dernière erreur est trouvée par l'analyseur lexical "
"(l'indentation de ``return r`` ne correspond à aucun niveau dans la pile)."

#: ../Doc/reference/lexical_analysis.rst:250
msgid "Whitespace between tokens"
msgstr "Espaces entre lexèmes"

#: ../Doc/reference/lexical_analysis.rst:252
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"Sauf au début d'une ligne logique ou dans les chaînes de caractères, les "
"caractères \"blancs\" espace, tabulation et saut de page peuvent être "
"utilisés de manière interchangeable pour séparer les lexèmes. Un blanc n'est "
"nécessaire entre deux lexèmes que si leur concaténation pourrait être "
"interprétée comme un lexème différent (par exemple, ab est un lexème, mais a "
"b comporte deux lexèmes)."

#: ../Doc/reference/lexical_analysis.rst:262
msgid "Other tokens"
msgstr "Autres lexèmes"

#: ../Doc/reference/lexical_analysis.rst:264
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"Outre NEWLINE, INDENT et DEDENT, il existe les catégories de lexèmes "
"suivantes : *identifiants*, *mots clés*, *littéraux*, *opérateurs* et "
"*délimiteurs*. Les blancs (autres que les fins de lignes, vus auparavant) ne "
"sont pas des lexèmes mais servent à délimiter les lexèmes. Quand une "
"ambiguïté existe, le lexème correspond à la plus grande chaîne possible qui "
"forme un lexème licite, en lisant de la gauche vers la droite."

#: ../Doc/reference/lexical_analysis.rst:274
msgid "Identifiers and keywords"
msgstr "Identifiants et mots-clés"

#: ../Doc/reference/lexical_analysis.rst:278
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""
"Les identifiants (aussi appelés *noms*) sont décrits par les définitions "
"lexicales suivantes."

#: ../Doc/reference/lexical_analysis.rst:281
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""
"La syntaxe des identifiants en Python est basée sur l'annexe UAX-31 du "
"standard Unicode avec les modifications définies ci-dessous ; consultez la :"
"pep:`3131` pour plus de détails."

#: ../Doc/reference/lexical_analysis.rst:285
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""
"Dans l'intervalle ASCII (U+0001..U+007F), les caractères licites pour les "
"identifiants sont les mêmes que pour Python 2.x : les lettres minuscules et "
"majuscules de ``A`` à ``Z``, le souligné (ou *underscore*) ``_`` et, sauf "
"pour le premier caractère, les chiffres de ``0`` à ``9``."

#: ../Doc/reference/lexical_analysis.rst:290
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""
"Python 3.0 introduit des caractères supplémentaires en dehors de "
"l'intervalle ASCII (voir la :pep:`3131`). Pour ces caractères, la "
"classification utilise la version de la \"base de données des caractères "
"Unicode\" telle qu'incluse dans le module :mod:`unicodedata`."

#: ../Doc/reference/lexical_analysis.rst:294
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""
"Les identifiants n'ont pas de limite de longueur. La casse est prise en "
"compte."

#: ../Doc/reference/lexical_analysis.rst:303
msgid "The Unicode category codes mentioned above stand for:"
msgstr "Les codes de catégories Unicode cités ci-dessus signifient :"

#: ../Doc/reference/lexical_analysis.rst:305
msgid "*Lu* - uppercase letters"
msgstr "*Lu* -- lettre majuscules"

#: ../Doc/reference/lexical_analysis.rst:306
msgid "*Ll* - lowercase letters"
msgstr "*Ll* -- lettres minuscules"

#: ../Doc/reference/lexical_analysis.rst:307
msgid "*Lt* - titlecase letters"
msgstr ""
"*Lt* -- lettres majuscules particulières (catégorie *titlecase* de l'Unicode)"

#: ../Doc/reference/lexical_analysis.rst:308
msgid "*Lm* - modifier letters"
msgstr "*Lm* -- lettres modificatives avec chasse"

#: ../Doc/reference/lexical_analysis.rst:309
msgid "*Lo* - other letters"
msgstr "*Lo* -- autres lettres"

#: ../Doc/reference/lexical_analysis.rst:310
msgid "*Nl* - letter numbers"
msgstr "*Nl* -- nombres lettres (par exemple, les nombres romains)"

#: ../Doc/reference/lexical_analysis.rst:311
msgid "*Mn* - nonspacing marks"
msgstr ""
"*Mn* -- symboles que l'on combine avec d'autres (accents ou autres) sans "
"générer d'espace (*nonspacing marks* en anglais)"

#: ../Doc/reference/lexical_analysis.rst:312
msgid "*Mc* - spacing combining marks"
msgstr ""
"*Mc* -- symboles que l'on combine avec d'autres en générant une espace "
"(*spacing combining marks* en anglais)"

#: ../Doc/reference/lexical_analysis.rst:313
msgid "*Nd* - decimal numbers"
msgstr "*Nd* -- chiffres (arabes et autres)"

#: ../Doc/reference/lexical_analysis.rst:314
msgid "*Pc* - connector punctuations"
msgstr "*Pc* -- connecteurs (tirets et autres lignes)"

#: ../Doc/reference/lexical_analysis.rst:315
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <http://www."
"unicode.org/Public/8.0.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:318
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* -- pareillement"

#: ../Doc/reference/lexical_analysis.rst:320
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""
"Tous les identifiants sont convertis dans la forme normale NFKC pendant "
"l'analyse syntaxique : la comparaison des identifiants se base sur leur "
"forme NFKC."

#: ../Doc/reference/lexical_analysis.rst:323
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at https://www.dcl.hpi.uni-potsdam.de/home/loewis/"
"table-3131.html."
msgstr ""
"Un fichier HTML, ne faisant pas référence, listant tous les caractères "
"valides pour Unicode 4.1 se trouve à https://www.dcl.hpi.uni-potsdam.de/home/"
"loewis/table-3131.html."

#: ../Doc/reference/lexical_analysis.rst:331
msgid "Keywords"
msgstr "Mots-clés"

#: ../Doc/reference/lexical_analysis.rst:337
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"Les identifiants suivants sont des mots réservés par le langage et ne "
"peuvent pas être utilisés en tant qu'identifiants normaux. Ils doivent être "
"écrits exactement comme ci-dessous :"

#: ../Doc/reference/lexical_analysis.rst:354
msgid "Reserved classes of identifiers"
msgstr "Classes réservées pour les identifiants"

#: ../Doc/reference/lexical_analysis.rst:356
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Certaines classes d'identifiants (outre les mots-clés) ont une signification "
"particulière.  Ces classes se reconnaissent par des caractères de "
"soulignement en tête et en queue d'identifiant :"

#: ../Doc/reference/lexical_analysis.rst:370
msgid "``_*``"
msgstr "``_*``"

#: ../Doc/reference/lexical_analysis.rst:361
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`builtins` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""
"L'identifiant spécial ``_`` n'est pas importé par ``from module import *``.  "
"Il est utilisé dans l'interpréteur interactif pour stocker le résultat de la "
"dernière évaluation ; il est stocké dans le module :mod:`builtins`.  Lorsque "
"vous n'êtes pas en mode interactif, ``_`` n'a pas de signification "
"particulière et n'est pas défini. Voir la section :ref:`import`."

#: ../Doc/reference/lexical_analysis.rst:368
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"Le nom ``_`` est souvent utilisé pour internationaliser l'affichage ; "
"reportez-vous à la documentation du module :mod:`gettext` pour plus "
"d'informations sur cette convention."

#: ../Doc/reference/lexical_analysis.rst:378
msgid "``__*__``"
msgstr "``__*__``"

#: ../Doc/reference/lexical_analysis.rst:373
msgid ""
"System-defined names. These names are defined by the interpreter and its "
"implementation (including the standard library).  Current system names are "
"discussed in the :ref:`specialnames` section and elsewhere.  More will "
"likely be defined in future versions of Python.  *Any* use of ``__*__`` "
"names, in any context, that does not follow explicitly documented use, is "
"subject to breakage without warning."
msgstr ""
"Noms définis par le système. Ces noms sont définis par l'interpréteur et son "
"implémentation (y compris la bibliothèque standard). Les noms actuels "
"définis par le système sont abordés dans la section :ref:`specialnames`, "
"mais aussi ailleurs. D'autres noms seront probablement définis dans les "
"futures versions de Python. Toute utilisation de noms de la forme ``__*__``, "
"dans n'importe quel contexte, qui n'est pas conforme à ce qu'indique "
"explicitement la documentation, est sujette à des mauvaises surprises sans "
"avertissement."

#: ../Doc/reference/lexical_analysis.rst:385
msgid "``__*``"
msgstr "``__*``"

#: ../Doc/reference/lexical_analysis.rst:381
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Noms privés pour une classe.  Les noms de cette forme, lorsqu'ils sont "
"utilisés dans le contexte d'une définition de classe, sont réécrits sous une "
"forme modifiée pour éviter les conflits de noms entre les attributs \"privés"
"\" des classes de base et les classes dérivées. Voir la section :ref:`atom-"
"identifiers`."

#: ../Doc/reference/lexical_analysis.rst:390
msgid "Literals"
msgstr "Littéraux"

#: ../Doc/reference/lexical_analysis.rst:394
msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"Les littéraux sont des notations pour indiquer des valeurs constantes de "
"certains types natifs."

#: ../Doc/reference/lexical_analysis.rst:400
msgid "String and Bytes literals"
msgstr "Littéraux de chaînes de caractères et de suites d'octets"

#: ../Doc/reference/lexical_analysis.rst:404
msgid "String literals are described by the following lexical definitions:"
msgstr ""
"Les chaînes de caractères littérales sont définies par les définitions "
"lexicales suivantes :"

#: ../Doc/reference/lexical_analysis.rst:428
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` or :token:"
"`bytesprefix` and the rest of the literal. The source character set is "
"defined by the encoding declaration; it is UTF-8 if no encoding declaration "
"is given in the source file; see section :ref:`encodings`."
msgstr ""
"Une restriction syntaxique non indiquée par ces règles est qu'aucun blanc "
"n'est autorisé entre le :token:`stringprefix` ou  :token:`bytesprefix` et le "
"reste du littéral. Le jeu de caractères source est défini par la déclaration "
"d'encodage ; il vaut UTF-8 si aucune déclaration d'encodage n'est donnée "
"dans le fichier source ; voir la section :ref:`encodings`."

#: ../Doc/reference/lexical_analysis.rst:436
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*).  The backslash (``\\``) character "
"is used to escape characters that otherwise have a special meaning, such as "
"newline, backslash itself, or the quote character."
msgstr ""
"Description en français : les deux types de littéraux peuvent être encadrés "
"par une paire de guillemets simples  (``'``) ou doubles (``\"``). Ils "
"peuvent aussi être encadrés par une paire de trois guillemets simples ou une "
"paire de trois guillemets doubles (on appelle alors généralement ces chaînes "
"*entre triples guillemets*). La barre oblique inversée peut être utilisée "
"pour échapper des caractères qui auraient sinon une signification spéciale, "
"tels que le retour à la ligne, la barre oblique inversée elle-même ou le "
"guillemet utilisé pour délimiter la chaîne."

#: ../Doc/reference/lexical_analysis.rst:443
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"Les littéraux de suites d'octets sont toujours préfixés par ``'b'`` ou "
"``'B'`` ; cela crée une instance de type :class:`bytes` au lieu du type :"
"class:`str`. Ils ne peuvent contenir que des caractères ASCII ; les octets "
"dont la valeur est supérieure ou égale à 128 doivent être exprimés à l'aide "
"d'échappements."

#: ../Doc/reference/lexical_analysis.rst:448
msgid ""
"As of Python 3.3 it is possible again to prefix string literals with a ``u`` "
"prefix to simplify maintenance of dual 2.x and 3.x codebases."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:451
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"Les chaînes et suites d'octets littérales peuvent être préfixées par la "
"lettre ``'r'`` ou ``'R'`` ; de telles chaînes sont appelées :dfn:`chaines "
"brutes` (*raw strings* en anglais) et traitent la barre oblique inversée "
"comme un caractère normal. En conséquence, les chaînes littérales ``'\\U'`` "
"et ``'\\u'`` ne sont pas considérées comme spéciales. Comme les littéraux "
"Unicode de Python 2.x se comportent différemment, la syntaxe ``'ur'`` n'est "
"pas reconnue en Python 3.x."

#: ../Doc/reference/lexical_analysis.rst:458
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""
"le préfixe ``'rb'`` a été ajouté comme synonyme de ``'br'`` pour les "
"littéraux de suites d'octets."

#: ../Doc/reference/lexical_analysis.rst:462
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"le support du préfixe historique pour les chaînes Unicode a été réintroduit "
"afin de simplifier la maintenance de code compatible Python 2.x et 3.x. Voir "
"la :pep:`414` pour davantage d'informations."

#: ../Doc/reference/lexical_analysis.rst:467
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"Dans les chaînes entre triples guillemets, les sauts de ligne et guillemets "
"peuvent ne pas être échappés (et sont donc pris en compte), mais trois "
"guillemets non échappés à la suite terminent le littéral (on entend par "
"guillemet le caractère utilisé pour commencer le littéral, c'est-à-dire  "
"``'`` ou ``\"``)."

#: ../Doc/reference/lexical_analysis.rst:473
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"À moins que le préfixe ``'r'`` ou ``'R'`` ne soit présent, les séquences "
"d'échappement dans les littéraux de chaînes et suites d'octets sont "
"interprétées comme elles le seraient par le C Standard. Les séquences "
"d'échappement  reconnues sont :"

#: ../Doc/reference/lexical_analysis.rst:478
#: ../Doc/reference/lexical_analysis.rst:511
msgid "Escape Sequence"
msgstr "Séquence d'échappement"

#: ../Doc/reference/lexical_analysis.rst:478
#: ../Doc/reference/lexical_analysis.rst:511
msgid "Meaning"
msgstr "Signification"

#: ../Doc/reference/lexical_analysis.rst:478
#: ../Doc/reference/lexical_analysis.rst:511
msgid "Notes"
msgstr "Notes"

#: ../Doc/reference/lexical_analysis.rst:480
msgid "``\\newline``"
msgstr "``\\newline``"

#: ../Doc/reference/lexical_analysis.rst:480
msgid "Backslash and newline ignored"
msgstr "barre oblique inversée et retour à la ligne ignorés"

#: ../Doc/reference/lexical_analysis.rst:482
msgid "``\\\\``"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:482
msgid "Backslash (``\\``)"
msgstr "barre oblique inversée (``\\``)"

#: ../Doc/reference/lexical_analysis.rst:484
msgid "``\\'``"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:484
msgid "Single quote (``'``)"
msgstr "guillemet simple  (``'``)"

#: ../Doc/reference/lexical_analysis.rst:486
msgid "``\\\"``"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:486
msgid "Double quote (``\"``)"
msgstr "guillemet double (``\"``)"

#: ../Doc/reference/lexical_analysis.rst:488
msgid "``\\a``"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:488
msgid "ASCII Bell (BEL)"
msgstr "cloche ASCII (BEL)"

#: ../Doc/reference/lexical_analysis.rst:490
msgid "``\\b``"
msgstr "``\\b``"

#: ../Doc/reference/lexical_analysis.rst:490
msgid "ASCII Backspace (BS)"
msgstr "retour arrière ASCII (BS)"

#: ../Doc/reference/lexical_analysis.rst:492
msgid "``\\f``"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:492
msgid "ASCII Formfeed (FF)"
msgstr "saut de page ASCII (FF)"

#: ../Doc/reference/lexical_analysis.rst:494
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/reference/lexical_analysis.rst:494
msgid "ASCII Linefeed (LF)"
msgstr "saut de ligne ASCII (LF)"

#: ../Doc/reference/lexical_analysis.rst:496
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/reference/lexical_analysis.rst:496
msgid "ASCII Carriage Return (CR)"
msgstr "retour à la ligne ASCII (CR)"

#: ../Doc/reference/lexical_analysis.rst:498
msgid "``\\t``"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:498
msgid "ASCII Horizontal Tab (TAB)"
msgstr "tabulation horizontale ASCII (TAB)"

#: ../Doc/reference/lexical_analysis.rst:500
msgid "``\\v``"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:500
msgid "ASCII Vertical Tab (VT)"
msgstr "tabulation verticale ASCII (VT)"

#: ../Doc/reference/lexical_analysis.rst:502
msgid "``\\ooo``"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:502
msgid "Character with octal value *ooo*"
msgstr "caractère dont le code est *ooo* en octal"

#: ../Doc/reference/lexical_analysis.rst:502
msgid "(1,3)"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:505
msgid "``\\xhh``"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:505
msgid "Character with hex value *hh*"
msgstr "caractère dont le code est *ooo* en hexadécimal"

#: ../Doc/reference/lexical_analysis.rst:505
msgid "(2,3)"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:508
msgid "Escape sequences only recognized in string literals are:"
msgstr ""
"Les séquences d'échappement reconnues seulement dans les chaînes littérales "
"sont :"

#: ../Doc/reference/lexical_analysis.rst:513
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../Doc/reference/lexical_analysis.rst:513
msgid "Character named *name* in the Unicode database"
msgstr "caractère dont le nom est *name* dans la base de données Unicode"

#: ../Doc/reference/lexical_analysis.rst:513
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/reference/lexical_analysis.rst:516
msgid "``\\uxxxx``"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:516
msgid "Character with 16-bit hex value *xxxx*"
msgstr "caractère dont le code est *xxxx* en hexadécimal"

#: ../Doc/reference/lexical_analysis.rst:516
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/reference/lexical_analysis.rst:519
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../Doc/reference/lexical_analysis.rst:519
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "caractère dont le code est *xxxxxxxx* en hexadécimal sur 32 bits"

#: ../Doc/reference/lexical_analysis.rst:519
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/reference/lexical_analysis.rst:523
msgid "Notes:"
msgstr "Notes :"

#: ../Doc/reference/lexical_analysis.rst:526
msgid "As in Standard C, up to three octal digits are accepted."
msgstr ""
"Comme dans le C Standard, jusqu'à trois chiffres en base huit sont acceptés."

#: ../Doc/reference/lexical_analysis.rst:529
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""
"Contrairement au C Standard, il est obligatoire de fournir deux chiffres "
"hexadécimaux."

#: ../Doc/reference/lexical_analysis.rst:532
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""
"Dans un littéral de suite d'octets, un échappement hexadécimal ou octal est "
"un octet dont la valeur est donnée. Dans une chaîne littérale, un "
"échappement est un caractère Unicode dont le code est donné."

#: ../Doc/reference/lexical_analysis.rst:537
msgid "Support for name aliases [#]_ has been added."
msgstr "Ajout du support pour les alias de noms [#]_."

#: ../Doc/reference/lexical_analysis.rst:541
msgid "Exactly four hex digits are required."
msgstr "Exactement quatre chiffres hexadécimaux sont requis."

#: ../Doc/reference/lexical_analysis.rst:544
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr ""
"N'importe quel caractère Unicode peut être encodé de cette façon. Exactement "
"huit chiffres hexadécimaux sont requis."

#: ../Doc/reference/lexical_analysis.rst:550
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"Contrairement au C standard, toutes les séquences d'échappement non "
"reconnues sont laissées inchangées dans la chaîne, c'est-à-dire que *la "
"barre oblique inversée est laissée dans le résultat* (ce comportement est "
"utile en cas de débogage : si une séquence d'échappement est mal tapée, la "
"sortie résultante est plus facilement reconnue comme source de l'erreur). "
"Notez bien également que les séquences d'échappement reconnues uniquement "
"dans les littéraux de chaînes de caractères ne sont pas reconnues pour les "
"littéraux de suites d'octets."

#: ../Doc/reference/lexical_analysis.rst:557
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"Même dans une chaîne littérale brute, les guillemets peuvent être échappés "
"avec une barre oblique inversée mais la barre oblique inversée reste dans le "
"résultat ; par exemple, ``r\"\\\"\"`` est une chaîne de caractères valide "
"composée de deux caractères : une barre oblique inversée et un guillemet "
"double ; ``r\"\\\"`` n'est pas une chaîne de caractères valide (même une "
"chaîne de caractères brute ne peut pas se terminer par un nombre impair de "
"barres obliques inversées). Plus précisément, *une chaîne littérale brute ne "
"peut pas se terminer par une seule barre oblique inversée* (puisque la barre "
"oblique inversée échappe le guillemet suivant). Notez également qu'une "
"simple barre oblique inversée suivie d'un saut de ligne est interprétée "
"comme deux caractères faisant partie du littéral et *non* comme une "
"continuation de ligne."

#: ../Doc/reference/lexical_analysis.rst:570
msgid "String literal concatenation"
msgstr "Concaténation de chaînes de caractères"

#: ../Doc/reference/lexical_analysis.rst:572
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""
"Plusieurs chaînes de caractères ou suites d'octets adjacentes (séparées par "
"des blancs), utilisant éventuellement des conventions de guillemets "
"différentes, sont autorisées. La signification est la même que leur "
"concaténation. Ainsi, ``\"hello\" 'world'`` est l'équivalent de ``"
"\"helloworld\"``. Cette fonctionnalité peut être utilisée pour réduire le "
"nombre de barres obliques inverses, pour diviser de longues chaînes de "
"caractères sur plusieurs lignes ou même pour ajouter des commentaires à des "
"portions de chaînes de caractères. Par exemple ::"

#: ../Doc/reference/lexical_analysis.rst:583
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings)."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:592
msgid "Numeric literals"
msgstr "Littéraux numériques"

#: ../Doc/reference/lexical_analysis.rst:598
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""
"Il existe trois types de littéraux numériques : les entiers, les nombres à "
"virgule flottante et les nombres imaginaires. Il n'y a pas de littéraux "
"complexes (les nombres complexes peuvent être construits en ajoutant un "
"nombre réel et un nombre imaginaire)."

#: ../Doc/reference/lexical_analysis.rst:602
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"Notez que les littéraux numériques ne comportent pas de signe ; une phrase "
"telle que ``-1`` est en fait une expression composée de l'opérateur unitaire "
"'``-``' et du littéral ``1``."

#: ../Doc/reference/lexical_analysis.rst:610
msgid "Integer literals"
msgstr "Entiers littéraux"

#: ../Doc/reference/lexical_analysis.rst:612
msgid "Integer literals are described by the following lexical definitions:"
msgstr ""
"Les entiers littéraux sont décrits par les définitions lexicales suivantes :"

#: ../Doc/reference/lexical_analysis.rst:626
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""
"Il n'y a pas de limite pour la longueur des entiers littéraux, sauf celle "
"relative à la capacité mémoire."

#: ../Doc/reference/lexical_analysis.rst:629
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""
"Notez que placer des zéros en tête de nombre pour un nombre décimal "
"différent de zéro n'est pas autorisé. Cela permet d'éviter l’ambigüité avec "
"les littéraux en base octale selon le style C que Python utilisait avant la "
"version 3.0."

#: ../Doc/reference/lexical_analysis.rst:633
msgid "Some examples of integer literals::"
msgstr "Quelques exemples d'entiers littéraux ::"

#: ../Doc/reference/lexical_analysis.rst:642
msgid "Floating point literals"
msgstr "Nombres à virgule flottante littéraux"

#: ../Doc/reference/lexical_analysis.rst:644
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""
"Les nombres à virgule flottante littéraux sont décrits par les définitions "
"lexicales suivantes :"

#: ../Doc/reference/lexical_analysis.rst:654
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent. Some examples of floating point literals::"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:661
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator ``-`` and the literal "
"``1``."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:669
msgid "Imaginary literals"
msgstr "Imaginaires littéraux"

#: ../Doc/reference/lexical_analysis.rst:671
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""
"Les nombres imaginaires sont décrits par les définitions lexicales "
"suivantes :"

#: ../Doc/reference/lexical_analysis.rst:676
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"Un littéral imaginaire produit un nombre complexe dont la partie réelle est "
"``0.0``. Les nombres complexes sont représentés comme une paire de nombres à "
"virgule flottante et possèdent les mêmes restrictions concernant les plages "
"autorisées. Pour créer un nombre complexe dont la partie réelle est non "
"nulle, ajoutez un nombre à virgule flottante à votre littéral imaginaire. "
"Par exemple ``(3+4j)``. Voici d'autres exemples de littéraux imaginaires ::"

#: ../Doc/reference/lexical_analysis.rst:688
msgid "Operators"
msgstr "Opérateurs"

#: ../Doc/reference/lexical_analysis.rst:692
msgid "The following tokens are operators:"
msgstr "Les lexèmes suivants sont des opérateurs :"

#: ../Doc/reference/lexical_analysis.rst:705
msgid "Delimiters"
msgstr "Délimiteurs"

#: ../Doc/reference/lexical_analysis.rst:709
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "Les lexèmes suivants servent de délimiteurs dans la grammaire :"

#: ../Doc/reference/lexical_analysis.rst:718
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""
"Le point peut aussi apparaître dans les littéraux de nombres à virgule "
"flottante et imaginaires. Une suite de trois points possède une "
"signification spéciale : c'est une ellipse littérale. La deuxième partie de "
"la liste, les opérateurs d'assignation augmentés, servent de délimiteurs "
"pour l'analyseur lexical mais sont aussi des opérateurs."

#: ../Doc/reference/lexical_analysis.rst:723
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""
"Les caractères ASCII suivants ont une signification spéciale en tant que "
"partie d'autres lexèmes ou ont une signification particulière pour  "
"l'analyseur lexical :"

#: ../Doc/reference/lexical_analysis.rst:730
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""
"Les caractères ASCII suivants ne sont pas utilisés en Python. S'ils "
"apparaissent en dehors de chaines littérales ou de commentaires, ils "
"produisent une erreur :"

#: ../Doc/reference/lexical_analysis.rst:739
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/reference/lexical_analysis.rst:740
msgid "http://www.unicode.org/Public/8.0.0/ucd/NameAliases.txt"
msgstr ""
