# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-09-04 11:33+0200\n"
"PO-Revision-Date: 2019-09-22 20:47+0200\n"
"Last-Translator: Jules Lasne <jules.lasne@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.3\n"

#: ../Doc/reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "Analyse lexicale"

#: ../Doc/reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Un programme Python est lu par un analyseur syntaxique (*parser* en "
"anglais). En entrée de cet analyseur syntaxique, nous trouvons des lexèmes "
"(*tokens* en anglais), produits par un analyseur lexical. Ce chapitre décrit "
"comment l'analyseur lexical découpe le fichier en lexèmes."

#: ../Doc/reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Python lit le texte du programme comme des suites de caractères Unicode ; "
"l'encodage du fichier source peut être spécifié par une déclaration "
"d'encodage et vaut par défaut UTF-8, voir la :pep:`3120` pour les détails. "
"Si le fichier source ne peut pas être décodé, une exception :exc:"
"`SyntaxError` (erreur de syntaxe) est levée."

#: ../Doc/reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "Structure des lignes"

#: ../Doc/reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Un programme en Python est divisé en *lignes logiques*."

#: ../Doc/reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "Lignes logiques"

#: ../Doc/reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"La fin d'une ligne logique est représentée par le lexème NEWLINE. Les "
"instructions ne peuvent pas traverser les limites des lignes logiques, sauf "
"quand NEWLINE est autorisé par la syntaxe (par exemple, entre les "
"instructions des instructions composées). Une ligne logique est constituée "
"d'une ou plusieurs *lignes physiques* en fonction des règles, explicites ou "
"implicites, de *continuation de ligne*."

#: ../Doc/reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "Lignes physiques"

#: ../Doc/reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed), "
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character.  "
"All of these forms can be used equally, regardless of platform. The end of "
"input also serves as an implicit terminator for the final physical line."
msgstr ""
"Une ligne physique est une suite de caractères terminée par une séquence de "
"fin de ligne. Dans les fichiers sources et les chaînes de caractères, "
"n'importe quelle séquence de fin de ligne des plateformes standards peut "
"être utilisée ; Unix utilise le caractère ASCII LF (pour *linefeed*, saut de "
"ligne en français), Windows utilise la séquence CR LF (*carriage return* "
"suivi de *linefeed*) et Macintosh utilisait le caractère ASCII CR. Toutes "
"ces séquences peuvent être utilisées, quelle que soit la plateforme. La fin "
"de l'entrée est aussi une fin de ligne physique implicite."

#: ../Doc/reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"Lorsque vous encapsulez Python, les chaînes de code source doivent être "
"passées à l'API Python en utilisant les conventions du C standard pour les "
"caractères de fin de ligne : le caractère ``\\n``, dont le code ASCII est LF."

#: ../Doc/reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "Commentaires"

#: ../Doc/reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"Un commentaire commence par le caractère croisillon (``#``, *hash* en "
"anglais et qui ressemble au symbole musical dièse, c'est pourquoi il est "
"souvent improprement appelé caractère dièse) situé en dehors d'une chaine de "
"caractères littérale et se termine à la fin de la ligne physique. Un "
"commentaire signifie la fin de la ligne logique à moins qu'une règle de "
"continuation de ligne implicite ne s'applique. Les commentaires sont ignorés "
"au niveau syntaxique, ce ne sont pas des lexèmes."

#: ../Doc/reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr "Déclaration d'encodage"

#: ../Doc/reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Si un commentaire placé sur la première ou deuxième ligne du script Python "
"correspond à l'expression rationnelle ``coding[=:]\\s*([-\\w.]+)``, ce "
"commentaire est analysé comme une déclaration d'encodage ; le premier groupe "
"de cette expression désigne l'encodage du fichier source. Cette déclaration "
"d'encodage doit être seule sur sa ligne et, si elle est sur la deuxième "
"ligne, la première ligne doit aussi être une ligne composée uniquement d'un "
"commentaire. Les formes recommandées pour l'expression de l'encodage sont ::"

#: ../Doc/reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "qui est reconnue aussi par GNU Emacs et ::"

#: ../Doc/reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "qui est reconnue par VIM de Bram Moolenaar."

#: ../Doc/reference/lexical_analysis.rst:99
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""
"Si aucune déclaration d'encodage n'est trouvée, l'encodage par défaut est "
"utilisé : UTF-8. En plus, si les premiers octets du fichier sont "
"l'indicateur d'ordre des octets UTF-8 (``b'\\xef\\xbb\\xbf'``, *BOM* en "
"anglais pour *byte order mark*), le fichier est considéré comme étant en "
"UTF-8 (cette convention est reconnue, entre autres, par :program:`notepad` "
"de Microsoft)."

#: ../Doc/reference/lexical_analysis.rst:104
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python. "
"The encoding is used for all lexical analysis, including string literals, "
"comments and identifiers."
msgstr ""
"Si un encodage est déclaré, le nom de l'encodage doit être reconnu par "
"Python. L'encodage est utilisé pour toute l'analyse lexicale, y compris les "
"chaînes de caractères, les commentaires et les identifiants."

#: ../Doc/reference/lexical_analysis.rst:114
msgid "Explicit line joining"
msgstr "Continuation de ligne explicite"

#: ../Doc/reference/lexical_analysis.rst:118
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Deux lignes physiques, ou plus, peuvent être jointes pour former une seule "
"ligne logique en utilisant la barre oblique inversée (``\\``) selon la règle "
"suivante : quand la ligne physique se termine par une barre oblique inversée "
"qui ne fait pas partie d'une chaine de caractères ou d'un commentaire, la "
"ligne immédiatement suivante lui est adjointe pour former une seule ligne "
"logique, en supprimant la barre oblique inversée et le caractère de fin de "
"ligne. Par exemple ::"

#: ../Doc/reference/lexical_analysis.rst:129
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"Une ligne que se termine par une barre oblique inversée ne peut pas avoir de "
"commentaire. La barre oblique inversée ne permet pas de continuer un "
"commentaire. La barre oblique inversée ne permet pas de continuer un lexème, "
"sauf s'il s'agit d'une chaîne de caractères (par exemple, les lexèmes autres "
"que les chaînes de caractères ne peuvent pas être répartis sur plusieurs "
"lignes en utilisant une barre oblique inversée). La barre oblique inversée "
"n'est pas autorisée ailleurs sur la ligne, en dehors d'une chaîne de "
"caractères."

#: ../Doc/reference/lexical_analysis.rst:139
msgid "Implicit line joining"
msgstr "Continuation de ligne implicite"

#: ../Doc/reference/lexical_analysis.rst:141
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Les expressions entre parenthèses, crochets ou accolades peuvent être "
"réparties sur plusieurs lignes sans utiliser de barre oblique inversée. Par "
"exemple ::"

#: ../Doc/reference/lexical_analysis.rst:149
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"Les lignes continuées implicitement peuvent avoir des commentaires. "
"L'indentation des lignes de continuation n'est pas importante. Une ligne "
"blanche est autorisée comme ligne de continuation. Il ne doit pas y avoir de "
"lexème NEWLINE entre des lignes implicitement continuées. Les lignes "
"continuées implicitement peuvent être utilisées dans des chaînes entre "
"triples guillemets (voir ci-dessous) ; dans ce cas, elles ne peuvent pas "
"avoir de commentaires."

#: ../Doc/reference/lexical_analysis.rst:159
msgid "Blank lines"
msgstr "Lignes vierges"

#: ../Doc/reference/lexical_analysis.rst:163
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"Une ligne logique qui ne contient que des espaces, tabulations, caractères "
"de saut de page (*formfeed* en anglais) ou commentaires est ignorée (c'est-à-"
"dire que le lexème NEWLINE n'est pas produit). Pendant l'édition interactive "
"d'instructions, la gestion des lignes vierges peut différer en fonction de "
"l'implémentation de la boucle REPL. Dans l'interpréteur standard, une ligne "
"complètement vierge (c'est-à-dire ne contenant strictement rien, même pas "
"une espace ou un commentaire) termine une instruction multi-lignes."

#: ../Doc/reference/lexical_analysis.rst:174
msgid "Indentation"
msgstr "Indentation"

#: ../Doc/reference/lexical_analysis.rst:178
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"Des espaces ou tabulations au début d’une ligne logique sont utilisées pour "
"connaître le niveau d’indentation de la ligne, qui est ensuite utilisé pour "
"déterminer comment les instructions sont groupées."

#: ../Doc/reference/lexical_analysis.rst:182
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"Les tabulations sont remplacées (de la gauche vers la droite) par une à huit "
"espaces de manière à ce que le nombre de caractères remplacés soit un "
"multiple de huit (nous avons ainsi la même règle que celle d'Unix). Le "
"nombre total d'espaces précédant le premier caractère non blanc détermine "
"alors le niveau d'indentation de la ligne. L'indentation ne peut pas être "
"répartie sur plusieurs lignes physiques à l'aide de barres obliques "
"inversées ; les espaces jusqu'à la première barre oblique inversée "
"déterminent l'indentation."

#: ../Doc/reference/lexical_analysis.rst:190
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"L'indentation est déclarée inconsistante et rejetée si, dans un même fichier "
"source, le mélange des tabulations et des espaces est tel que la "
"signification dépend du nombre d'espaces que représente une tabulation. Une "
"exception :exc:`TabError` est levée dans ce cas."

#: ../Doc/reference/lexical_analysis.rst:194
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Note de compatibilité entre les plateformes :** en raison de la nature des "
"éditeurs de texte sur les plateformes non Unix, il n'est pas judicieux "
"d'utiliser un mélange d'espaces et de tabulations pour l'indentation dans un "
"seul fichier source. Il convient également de noter que des plateformes "
"peuvent explicitement limiter le niveau d'indentation maximal."

#: ../Doc/reference/lexical_analysis.rst:199
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Un caractère de saut de page peut être présent au début de la ligne ; il est "
"ignoré pour les calculs d'indentation ci-dessus. Les caractères de saut de "
"page se trouvant ailleurs avec les espaces en tête de ligne ont un effet "
"indéfini (par exemple, ils peuvent remettre à zéro le nombre d'espaces)."

#: ../Doc/reference/lexical_analysis.rst:206
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""
"Les niveaux d'indentation de lignes consécutives sont utilisés pour générer "
"les lexèmes INDENT et DEDENT, en utilisant une pile, de cette façon :"

#: ../Doc/reference/lexical_analysis.rst:209
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"Avant que la première ligne du fichier ne soit lue, un « zéro » est posé sur "
"la pile ; il ne sera plus jamais enlevé. Les nombres empilés sont toujours "
"strictement croissants de bas en haut. Au début de chaque ligne logique, le "
"niveau d'indentation de la ligne est comparé au sommet de la pile. S'ils "
"sont égaux, il ne se passe rien. S'il est plus grand, il est empilé et un "
"lexème INDENT est produit. S'il est plus petit, il *doit* être l'un des "
"nombres présents dans la pile ; tous les nombres de la pile qui sont plus "
"grands sont retirés et, pour chaque nombre retiré, un lexème DEDENT est "
"produit. À la fin du fichier, un lexème DEDENT est produit pour chaque "
"nombre supérieur à zéro restant sur la pile."

#: ../Doc/reference/lexical_analysis.rst:220
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Voici un exemple de code Python correctement indenté (bien que très "
"confus) ::"

#: ../Doc/reference/lexical_analysis.rst:235
msgid "The following example shows various indentation errors::"
msgstr "L'exemple suivant montre plusieurs erreurs d'indentation ::"

#: ../Doc/reference/lexical_analysis.rst:245
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"En fait, les trois premières erreurs sont détectées par l'analyseur "
"syntaxique ; seule la dernière erreur est trouvée par l'analyseur lexical "
"(l'indentation de ``return r`` ne correspond à aucun niveau dans la pile)."

#: ../Doc/reference/lexical_analysis.rst:253
msgid "Whitespace between tokens"
msgstr "Espaces entre lexèmes"

#: ../Doc/reference/lexical_analysis.rst:255
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"Sauf au début d'une ligne logique ou dans les chaînes de caractères, les "
"caractères « blancs » espace, tabulation et saut de page peuvent être "
"utilisés de manière interchangeable pour séparer les lexèmes. Un blanc n'est "
"nécessaire entre deux lexèmes que si leur concaténation pourrait être "
"interprétée comme un lexème différent (par exemple, ab est un lexème, mais a "
"b comporte deux lexèmes)."

#: ../Doc/reference/lexical_analysis.rst:265
msgid "Other tokens"
msgstr "Autres lexèmes"

#: ../Doc/reference/lexical_analysis.rst:267
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"Outre NEWLINE, INDENT et DEDENT, il existe les catégories de lexèmes "
"suivantes : *identifiants*, *mots clés*, *littéraux*, *opérateurs* et "
"*délimiteurs*. Les blancs (autres que les fins de lignes, vus auparavant) ne "
"sont pas des lexèmes mais servent à délimiter les lexèmes. Quand une "
"ambiguïté existe, le lexème correspond à la plus grande chaîne possible qui "
"forme un lexème licite, en lisant de la gauche vers la droite."

#: ../Doc/reference/lexical_analysis.rst:277
msgid "Identifiers and keywords"
msgstr "Identifiants et mots-clés"

#: ../Doc/reference/lexical_analysis.rst:281
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""
"Les identifiants (aussi appelés *noms*) sont décrits par les définitions "
"lexicales suivantes."

#: ../Doc/reference/lexical_analysis.rst:284
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""
"La syntaxe des identifiants en Python est basée sur l'annexe UAX-31 du "
"standard Unicode avec les modifications définies ci-dessous ; consultez la :"
"pep:`3131` pour plus de détails."

#: ../Doc/reference/lexical_analysis.rst:288
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""
"Dans l'intervalle ASCII (*U+0001..U+007F*), les caractères licites pour les "
"identifiants sont les mêmes que pour Python 2.x : les lettres minuscules et "
"majuscules de ``A`` à ``Z``, le souligné (ou *underscore*) ``_`` et, sauf "
"pour le premier caractère, les chiffres de ``0`` à ``9``."

#: ../Doc/reference/lexical_analysis.rst:293
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""
"Python 3.0 introduit des caractères supplémentaires en dehors de "
"l'intervalle ASCII (voir la :pep:`3131`). Pour ces caractères, la "
"classification utilise la version de la « base de données des caractères "
"Unicode » telle qu'incluse dans le module :mod:`unicodedata`."

#: ../Doc/reference/lexical_analysis.rst:297
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""
"Les identifiants n'ont pas de limite de longueur. La casse est prise en "
"compte."

#: ../Doc/reference/lexical_analysis.rst:306
msgid "The Unicode category codes mentioned above stand for:"
msgstr "Les codes de catégories Unicode cités ci-dessus signifient :"

#: ../Doc/reference/lexical_analysis.rst:308
msgid "*Lu* - uppercase letters"
msgstr "*Lu* — lettres majuscules"

#: ../Doc/reference/lexical_analysis.rst:309
msgid "*Ll* - lowercase letters"
msgstr "*Ll* — lettres minuscules"

#: ../Doc/reference/lexical_analysis.rst:310
msgid "*Lt* - titlecase letters"
msgstr ""
"*Lt* — lettres majuscules particulières (catégorie *titlecase* de l'Unicode)"

#: ../Doc/reference/lexical_analysis.rst:311
msgid "*Lm* - modifier letters"
msgstr "*Lm* — lettres modificatives avec chasse"

#: ../Doc/reference/lexical_analysis.rst:312
msgid "*Lo* - other letters"
msgstr "*Lo* — autres lettres"

#: ../Doc/reference/lexical_analysis.rst:313
msgid "*Nl* - letter numbers"
msgstr "*Nl* — nombres lettres (par exemple, les nombres romains)"

#: ../Doc/reference/lexical_analysis.rst:314
msgid "*Mn* - nonspacing marks"
msgstr ""
"*Mn* — symboles que l'on combine avec d'autres (accents ou autres) sans "
"générer d'espace (*nonspacing marks* en anglais)"

#: ../Doc/reference/lexical_analysis.rst:315
msgid "*Mc* - spacing combining marks"
msgstr ""
"*Mc* — symboles que l'on combine avec d'autres en générant une espace "
"(*spacing combining marks* en anglais)"

#: ../Doc/reference/lexical_analysis.rst:316
msgid "*Nd* - decimal numbers"
msgstr "*Nd* — chiffres (arabes et autres)"

#: ../Doc/reference/lexical_analysis.rst:317
msgid "*Pc* - connector punctuations"
msgstr "*Pc* — connecteurs (tirets et autres lignes)"

#: ../Doc/reference/lexical_analysis.rst:318
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <http://www."
"unicode.org/Public/12.1.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""
"*Other_ID_Start* — liste explicite des caractères de `PropList.txt <http://"
"www.unicode.org/Public/12.1.0/ucd/PropList.txt>`_ pour la compatibilité "
"descendante"

#: ../Doc/reference/lexical_analysis.rst:321
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* — pareillement"

#: ../Doc/reference/lexical_analysis.rst:323
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""
"Tous les identifiants sont convertis dans la forme normale NFKC pendant "
"l'analyse syntaxique : la comparaison des identifiants se base sur leur "
"forme NFKC."

#: ../Doc/reference/lexical_analysis.rst:326
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at https://www.dcl.hpi.uni-potsdam.de/home/loewis/"
"table-3131.html."
msgstr ""
"Un fichier HTML, ne faisant pas référence, listant tous les caractères "
"valides pour Unicode 4.1 se trouve à https://www.dcl.hpi.uni-potsdam.de/home/"
"loewis/table-3131.html."

#: ../Doc/reference/lexical_analysis.rst:334
msgid "Keywords"
msgstr "Mots-clés"

#: ../Doc/reference/lexical_analysis.rst:340
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"Les identifiants suivants sont des mots réservés par le langage et ne "
"peuvent pas être utilisés en tant qu'identifiants normaux. Ils doivent être "
"écrits exactement comme ci-dessous :"

#: ../Doc/reference/lexical_analysis.rst:360
msgid "Reserved classes of identifiers"
msgstr "Classes réservées pour les identifiants"

#: ../Doc/reference/lexical_analysis.rst:362
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Certaines classes d'identifiants (outre les mots-clés) ont une signification "
"particulière. Ces classes se reconnaissent par des caractères de "
"soulignement en tête et en queue d'identifiant :"

#: ../Doc/reference/lexical_analysis.rst:376
msgid "``_*``"
msgstr "``_*``"

#: ../Doc/reference/lexical_analysis.rst:367
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`builtins` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""
"L'identifiant spécial ``_`` n'est pas importé par ``from module import *``. "
"Il est utilisé dans l'interpréteur interactif pour stocker le résultat de la "
"dernière évaluation ; il est stocké dans le module :mod:`builtins`. Lorsque "
"vous n'êtes pas en mode interactif, ``_`` n'a pas de signification "
"particulière et n'est pas défini. Voir la section :ref:`import`."

#: ../Doc/reference/lexical_analysis.rst:374
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"Le nom ``_`` est souvent utilisé pour internationaliser l'affichage ; "
"reportez-vous à la documentation du module :mod:`gettext` pour plus "
"d'informations sur cette convention."

#: ../Doc/reference/lexical_analysis.rst:384
msgid "``__*__``"
msgstr "``__*__``"

#: ../Doc/reference/lexical_analysis.rst:379
msgid ""
"System-defined names. These names are defined by the interpreter and its "
"implementation (including the standard library).  Current system names are "
"discussed in the :ref:`specialnames` section and elsewhere.  More will "
"likely be defined in future versions of Python.  *Any* use of ``__*__`` "
"names, in any context, that does not follow explicitly documented use, is "
"subject to breakage without warning."
msgstr ""
"Noms définis par le système. Ces noms sont définis par l'interpréteur et son "
"implémentation (y compris la bibliothèque standard). Les noms actuels "
"définis par le système sont abordés dans la section :ref:`specialnames`, "
"mais aussi ailleurs. D'autres noms seront probablement définis dans les "
"futures versions de Python. Toute utilisation de noms de la forme ``__*__``, "
"dans n'importe quel contexte, qui n'est pas conforme à ce qu'indique "
"explicitement la documentation, est sujette à des mauvaises surprises sans "
"avertissement."

#: ../Doc/reference/lexical_analysis.rst:391
msgid "``__*``"
msgstr "``__*``"

#: ../Doc/reference/lexical_analysis.rst:387
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Noms privés pour une classe. Les noms de cette forme, lorsqu'ils sont "
"utilisés dans le contexte d'une définition de classe, sont réécrits sous une "
"forme modifiée pour éviter les conflits de noms entre les attributs "
"« privés » des classes de base et les classes dérivées. Voir la section :ref:"
"`atom-identifiers`."

#: ../Doc/reference/lexical_analysis.rst:396
msgid "Literals"
msgstr "Littéraux"

#: ../Doc/reference/lexical_analysis.rst:400
msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"Les littéraux sont des notations pour indiquer des valeurs constantes de "
"certains types natifs."

#: ../Doc/reference/lexical_analysis.rst:411
msgid "String and Bytes literals"
msgstr "Littéraux de chaînes de caractères et de suites d'octets"

#: ../Doc/reference/lexical_analysis.rst:413
msgid "String literals are described by the following lexical definitions:"
msgstr ""
"Les chaînes de caractères littérales sont définies par les définitions "
"lexicales suivantes :"

#: ../Doc/reference/lexical_analysis.rst:438
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` or :token:"
"`bytesprefix` and the rest of the literal. The source character set is "
"defined by the encoding declaration; it is UTF-8 if no encoding declaration "
"is given in the source file; see section :ref:`encodings`."
msgstr ""
"Une restriction syntaxique non indiquée par ces règles est qu'aucun blanc "
"n'est autorisé entre le :token:`stringprefix` ou :token:`bytesprefix` et le "
"reste du littéral. Le jeu de caractères source est défini par la déclaration "
"d'encodage ; il vaut UTF-8 si aucune déclaration d'encodage n'est donnée "
"dans le fichier source ; voir la section :ref:`encodings`."

#: ../Doc/reference/lexical_analysis.rst:448
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*).  The backslash (``\\``) character "
"is used to escape characters that otherwise have a special meaning, such as "
"newline, backslash itself, or the quote character."
msgstr ""
"Description en français : les deux types de littéraux peuvent être encadrés "
"par une paire de guillemets simples (``'``) ou doubles (``\"``). Ils peuvent "
"aussi être encadrés par une paire de trois guillemets simples ou une paire "
"de trois guillemets doubles (on appelle alors généralement ces chaînes "
"*entre triples guillemets*). La barre oblique inversée peut être utilisée "
"pour échapper des caractères qui auraient sinon une signification spéciale, "
"tels que le retour à la ligne, la barre oblique inversée elle-même ou le "
"guillemet utilisé pour délimiter la chaîne."

#: ../Doc/reference/lexical_analysis.rst:459
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"Les littéraux de suites d'octets sont toujours préfixés par ``'b'`` ou "
"``'B'`` ; cela crée une instance de type :class:`bytes` au lieu du type :"
"class:`str`. Ils ne peuvent contenir que des caractères ASCII ; les octets "
"dont la valeur est supérieure ou égale à 128 doivent être exprimés à l'aide "
"d'échappements."

#: ../Doc/reference/lexical_analysis.rst:468
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"Les chaînes et suites d'octets littérales peuvent être préfixées par la "
"lettre ``'r'`` ou ``'R'`` ; de telles chaînes sont appelées :dfn:`chaines "
"brutes` (*raw strings* en anglais) et traitent la barre oblique inversée "
"comme un caractère normal. En conséquence, les chaînes littérales ``'\\U'`` "
"et ``'\\u'`` ne sont pas considérées comme spéciales. Comme les littéraux "
"Unicode de Python 2.x se comportent différemment, la syntaxe ``'ur'`` n'est "
"pas reconnue en Python 3.x."

#: ../Doc/reference/lexical_analysis.rst:475
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""
"le préfixe ``'rb'`` a été ajouté comme synonyme de ``'br'`` pour les "
"littéraux de suites d'octets."

#: ../Doc/reference/lexical_analysis.rst:479
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"le support du préfixe historique pour les chaînes Unicode a été réintroduit "
"afin de simplifier la maintenance de code compatible Python 2.x et 3.x. Voir "
"la :pep:`414` pour davantage d'informations."

#: ../Doc/reference/lexical_analysis.rst:488
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""
"Une chaîne littérale qui contient ``'f'`` ou ``'F'`` dans le préfixe est "
"une :dfn:`chaîne de caractères littérale formatée` ; lisez :ref:`f-strings`. "
"Le ``'f'`` peut être combiné avec ``'r'`` mais pas avec ``'b'`` ou ``'u'``, "
"donc les chaînes de caractères formatées sont possibles mais les littéraux "
"de suites d'octets ne peuvent pas l'être."

#: ../Doc/reference/lexical_analysis.rst:493
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"Dans les chaînes entre triples guillemets, les sauts de ligne et guillemets "
"peuvent ne pas être échappés (et sont donc pris en compte), mais trois "
"guillemets non échappés à la suite terminent le littéral (on entend par "
"guillemet le caractère utilisé pour commencer le littéral, c'est-à-dire "
"``'`` ou ``\"``)."

#: ../Doc/reference/lexical_analysis.rst:512
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"À moins que le préfixe ``'r'`` ou ``'R'`` ne soit présent, les séquences "
"d'échappement dans les littéraux de chaînes et suites d'octets sont "
"interprétées comme elles le seraient par le C Standard. Les séquences "
"d'échappement reconnues sont :"

#: ../Doc/reference/lexical_analysis.rst:517
#: ../Doc/reference/lexical_analysis.rst:550
msgid "Escape Sequence"
msgstr "Séquence d'échappement"

#: ../Doc/reference/lexical_analysis.rst:517
#: ../Doc/reference/lexical_analysis.rst:550
msgid "Meaning"
msgstr "Signification"

#: ../Doc/reference/lexical_analysis.rst:517
#: ../Doc/reference/lexical_analysis.rst:550
msgid "Notes"
msgstr "Notes"

#: ../Doc/reference/lexical_analysis.rst:519
msgid "``\\newline``"
msgstr "``\\newline``"

#: ../Doc/reference/lexical_analysis.rst:519
msgid "Backslash and newline ignored"
msgstr "barre oblique inversée et retour à la ligne ignorés"

#: ../Doc/reference/lexical_analysis.rst:521
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../Doc/reference/lexical_analysis.rst:521
msgid "Backslash (``\\``)"
msgstr "barre oblique inversée (``\\``)"

#: ../Doc/reference/lexical_analysis.rst:523
msgid "``\\'``"
msgstr "``\\'``"

#: ../Doc/reference/lexical_analysis.rst:523
msgid "Single quote (``'``)"
msgstr "guillemet simple (``'``)"

#: ../Doc/reference/lexical_analysis.rst:525
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../Doc/reference/lexical_analysis.rst:525
msgid "Double quote (``\"``)"
msgstr "guillemet double (``\"``)"

#: ../Doc/reference/lexical_analysis.rst:527
msgid "``\\a``"
msgstr "``\\a``"

#: ../Doc/reference/lexical_analysis.rst:527
msgid "ASCII Bell (BEL)"
msgstr "cloche ASCII (BEL)"

#: ../Doc/reference/lexical_analysis.rst:529
msgid "``\\b``"
msgstr "``\\b``"

#: ../Doc/reference/lexical_analysis.rst:529
msgid "ASCII Backspace (BS)"
msgstr "retour arrière ASCII (BS)"

#: ../Doc/reference/lexical_analysis.rst:531
msgid "``\\f``"
msgstr "``\\f``"

#: ../Doc/reference/lexical_analysis.rst:531
msgid "ASCII Formfeed (FF)"
msgstr "saut de page ASCII (FF)"

#: ../Doc/reference/lexical_analysis.rst:533
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/reference/lexical_analysis.rst:533
msgid "ASCII Linefeed (LF)"
msgstr "saut de ligne ASCII (LF)"

#: ../Doc/reference/lexical_analysis.rst:535
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/reference/lexical_analysis.rst:535
msgid "ASCII Carriage Return (CR)"
msgstr "retour à la ligne ASCII (CR)"

#: ../Doc/reference/lexical_analysis.rst:537
msgid "``\\t``"
msgstr "``\\t``"

#: ../Doc/reference/lexical_analysis.rst:537
msgid "ASCII Horizontal Tab (TAB)"
msgstr "tabulation horizontale ASCII (TAB)"

#: ../Doc/reference/lexical_analysis.rst:539
msgid "``\\v``"
msgstr "``\\v``"

#: ../Doc/reference/lexical_analysis.rst:539
msgid "ASCII Vertical Tab (VT)"
msgstr "tabulation verticale ASCII (VT)"

#: ../Doc/reference/lexical_analysis.rst:541
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: ../Doc/reference/lexical_analysis.rst:541
msgid "Character with octal value *ooo*"
msgstr "caractère dont le code est *ooo* en octal"

#: ../Doc/reference/lexical_analysis.rst:541
msgid "(1,3)"
msgstr "(1,3)"

#: ../Doc/reference/lexical_analysis.rst:544
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../Doc/reference/lexical_analysis.rst:544
msgid "Character with hex value *hh*"
msgstr "caractère dont le code est *ooo* en hexadécimal"

#: ../Doc/reference/lexical_analysis.rst:544
msgid "(2,3)"
msgstr "(2,3)"

#: ../Doc/reference/lexical_analysis.rst:547
msgid "Escape sequences only recognized in string literals are:"
msgstr ""
"Les séquences d'échappement reconnues seulement dans les chaînes littérales "
"sont :"

#: ../Doc/reference/lexical_analysis.rst:552
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../Doc/reference/lexical_analysis.rst:552
msgid "Character named *name* in the Unicode database"
msgstr "caractère dont le nom est *name* dans la base de données Unicode"

#: ../Doc/reference/lexical_analysis.rst:552
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/reference/lexical_analysis.rst:555
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../Doc/reference/lexical_analysis.rst:555
msgid "Character with 16-bit hex value *xxxx*"
msgstr "caractère dont le code est *xxxx* en hexadécimal"

#: ../Doc/reference/lexical_analysis.rst:555
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/reference/lexical_analysis.rst:558
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../Doc/reference/lexical_analysis.rst:558
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "caractère dont le code est *xxxxxxxx* en hexadécimal sur 32 bits"

#: ../Doc/reference/lexical_analysis.rst:558
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/reference/lexical_analysis.rst:562
msgid "Notes:"
msgstr "Notes :"

#: ../Doc/reference/lexical_analysis.rst:565
msgid "As in Standard C, up to three octal digits are accepted."
msgstr ""
"Comme dans le C Standard, jusqu'à trois chiffres en base huit sont acceptés."

#: ../Doc/reference/lexical_analysis.rst:568
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""
"Contrairement au C Standard, il est obligatoire de fournir deux chiffres "
"hexadécimaux."

#: ../Doc/reference/lexical_analysis.rst:571
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""
"Dans un littéral de suite d'octets, un échappement hexadécimal ou octal est "
"un octet dont la valeur est donnée. Dans une chaîne littérale, un "
"échappement est un caractère Unicode dont le code est donné."

#: ../Doc/reference/lexical_analysis.rst:576
msgid "Support for name aliases [#]_ has been added."
msgstr "Ajout du support pour les alias de noms [#]_."

#: ../Doc/reference/lexical_analysis.rst:580
msgid "Exactly four hex digits are required."
msgstr "Exactement quatre chiffres hexadécimaux sont requis."

#: ../Doc/reference/lexical_analysis.rst:583
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr ""
"N'importe quel caractère Unicode peut être encodé de cette façon. Exactement "
"huit chiffres hexadécimaux sont requis."

#: ../Doc/reference/lexical_analysis.rst:589
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"Contrairement au C standard, toutes les séquences d'échappement non "
"reconnues sont laissées inchangées dans la chaîne, c'est-à-dire que *la "
"barre oblique inversée est laissée dans le résultat* (ce comportement est "
"utile en cas de débogage : si une séquence d'échappement est mal tapée, la "
"sortie résultante est plus facilement reconnue comme source de l'erreur). "
"Notez bien également que les séquences d'échappement reconnues uniquement "
"dans les littéraux de chaînes de caractères ne sont pas reconnues pour les "
"littéraux de suites d'octets."

#: ../Doc/reference/lexical_analysis.rst:596
msgid ""
"Unrecognized escape sequences produce a :exc:`DeprecationWarning`.  In a "
"future Python version they will be a :exc:`SyntaxWarning` and eventually a :"
"exc:`SyntaxError`."
msgstr ""
"Les séquences d'échappement non reconnues produisent une :exc:"
"`DeprecationWarning`. Dans les futures versions de Python, elles génèreront "
"une :exc:`SyntaxWarning` et éventuellement une :exc:`SyntaxError`."

#: ../Doc/reference/lexical_analysis.rst:601
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"Même dans une chaîne littérale brute, les guillemets peuvent être échappés "
"avec une barre oblique inversée mais la barre oblique inversée reste dans le "
"résultat ; par exemple, ``r\"\\\"\"`` est une chaîne de caractères valide "
"composée de deux caractères : une barre oblique inversée et un guillemet "
"double ; ``r\"\\\"`` n'est pas une chaîne de caractères valide (même une "
"chaîne de caractères brute ne peut pas se terminer par un nombre impair de "
"barres obliques inversées). Plus précisément, *une chaîne littérale brute ne "
"peut pas se terminer par une seule barre oblique inversée* (puisque la barre "
"oblique inversée échappe le guillemet suivant). Notez également qu'une "
"simple barre oblique inversée suivie d'un saut de ligne est interprétée "
"comme deux caractères faisant partie du littéral et *non* comme une "
"continuation de ligne."

#: ../Doc/reference/lexical_analysis.rst:614
msgid "String literal concatenation"
msgstr "Concaténation de chaînes de caractères"

#: ../Doc/reference/lexical_analysis.rst:616
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""
"Plusieurs chaînes de caractères ou suites d'octets adjacentes (séparées par "
"des blancs), utilisant éventuellement des conventions de guillemets "
"différentes, sont autorisées. La signification est la même que leur "
"concaténation. Ainsi, ``\"hello\" 'world'`` est l'équivalent de ``"
"\"helloworld\"``. Cette fonctionnalité peut être utilisée pour réduire le "
"nombre de barres obliques inverses, pour diviser de longues chaînes de "
"caractères sur plusieurs lignes ou même pour ajouter des commentaires à des "
"portions de chaînes de caractères. Par exemple ::"

#: ../Doc/reference/lexical_analysis.rst:627
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""
"Notez que cette fonctionnalité agit au niveau syntaxique mais est "
"implémentée au moment de la compilation. Pour concaténer les expressions des "
"chaînes de caractères au moment de l'exécution, vous devez utiliser "
"l'opérateur ``+``. Notez également que la concaténation littérale peut "
"utiliser un style différent de guillemets pour chaque composant (et même "
"mélanger des chaînes de caractères brutes et des chaînes de caractères entre "
"triples guillemets). Enfin, les chaînes de caractères formatées peuvent être "
"concaténées avec des chaînes de caractères ordinaires."

#: ../Doc/reference/lexical_analysis.rst:646
msgid "Formatted string literals"
msgstr "Chaînes de caractères formatées littérales"

#: ../Doc/reference/lexical_analysis.rst:650
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
"Une :dfn:`chaine de caractères formatée littérale` ou :dfn:`f-string` est "
"une chaine de caractères littérale préfixée par ``'f'`` ou ``'F'``. Ces "
"chaines peuvent contenir des champs à remplacer, c'est-à-dire des "
"expressions délimitées par des accolades ``{}``. Alors que les autres "
"littéraux de chaines ont des valeurs constantes, les chaines formatées sont "
"de vraies expressions évaluées à l'exécution."

#: ../Doc/reference/lexical_analysis.rst:656
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a "
"literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr ""
"Les séquences d'échappement sont décodées comme à l'intérieur des chaînes de "
"caractères ordinaires (sauf lorsqu'une chaîne de caractères est également "
"marquée comme une chaîne brute). Après décodage, la grammaire s'appliquant "
"au contenu de la chaîne de caractères est :"

#: ../Doc/reference/lexical_analysis.rst:670
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression.  After the "
"expression, there may be a conversion field, introduced by an exclamation "
"point ``'!'``.  A format specifier may also be appended, introduced by a "
"colon ``':'``.  A replacement field ends with a closing curly bracket "
"``'}'``."
msgstr ""
"Les portions qui sont en dehors des accolades sont traitées comme les "
"littéraux, sauf les doubles accolades ``'{{'`` ou ``'}}'`` qui sont "
"remplacées par la simple accolade correspondante. Une simple accolade "
"ouvrante ``'{'`` marque le début du champ à remplacer, qui commence par une "
"expression Python. Après l'expression, il peut y avoir un champ de "
"conversion, introduit par un point d'exclamation ``'!'``. Une spécification "
"de format peut aussi être ajoutée, introduite par le caractère deux-points "
"``':'``. Le champ à remplacer se termine par une accolade fermante ``'}'``."

#: ../Doc/reference/lexical_analysis.rst:679
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Replacement "
"expressions can contain line breaks (e.g. in triple-quoted strings), but "
"they cannot contain comments.  Each expression is evaluated in the context "
"where the formatted string literal appears, in order from left to right."
msgstr ""
"Les expressions dans les chaînes de caractères formatées littérales sont "
"traitées comme des expressions Python normales entourées de parenthèses, à "
"quelques exceptions près. Une expression vide n'est pas autorisée et les "
"expressions :keyword:`lambda` comme les assignations ``:=`` doivent être "
"explicitement entourées de parenthèses. Les expressions de remplacement "
"peuvent contenir des sauts de ligne (par exemple dans les chaînes de "
"caractères entre triples guillemets) mais elles ne peuvent pas contenir de "
"commentaire. Chaque expression est évaluée dans le contexte où la chaîne de "
"caractères formatée apparaît, de gauche à droite."

#: ../Doc/reference/lexical_analysis.rst:688
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"Si une conversion est spécifiée, le résultat de l'évaluation de l'expression "
"est converti avant d'être formaté. La conversion ``'!s'`` appelle :func:"
"`str` sur le résultat, ``'!r'`` appelle :func:`repr` et ``'!a'`` appelle :"
"func:`ascii`."

#: ../Doc/reference/lexical_analysis.rst:692
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`__format__` method of the expression or "
"conversion result.  An empty string is passed when the format specifier is "
"omitted.  The formatted result is then included in the final value of the "
"whole string."
msgstr ""
"Le résultat est ensuite formaté en utilisant le protocole de :func:`format`. "
"La spécification du format est passée à la méthode :meth:`__format__` de "
"l'expression ou du résultat de la conversion. Une chaîne vide est passée "
"lorsque la spécification de format est omise. Le résultat formaté est alors "
"inclus dans la valeur finale de la chaîne complète."

#: ../Doc/reference/lexical_analysis.rst:698
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply-nested replacement "
"fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the string .format() method."
msgstr ""
"Les spécifications de format peuvent inclure des champs de remplacement "
"imbriqués. Ces champs imbriqués peuvent inclure leurs propres champs de "
"conversion et :ref:`spécifications de format <formatspec>` mais "
"l'imbrication ne doit pas aller plus profond. Le :ref:`mini-langage de "
"spécification de format  <formatspec>` est le même que celui utilisé par la "
"méthode ``.format()`` du type ``str``."

#: ../Doc/reference/lexical_analysis.rst:704
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot "
"be split across literals."
msgstr ""
"Les chaînes formatées littérales peuvent être concaténées mais les champs à "
"remplacer ne peuvent pas être divisés entre les littéraux."

#: ../Doc/reference/lexical_analysis.rst:707
msgid "Some examples of formatted string literals::"
msgstr "Quelques exemples de chaines formatées littérales ::"

#: ../Doc/reference/lexical_analysis.rst:726
msgid ""
"A consequence of sharing the same syntax as regular string literals is that "
"characters in the replacement fields must not conflict with the quoting used "
"in the outer formatted string literal::"
msgstr ""
"Une conséquence de partager la même syntaxe avec les chaînes littérales "
"normales est que les caractères dans les champs à remplacer ne doivent pas "
"entrer en conflit avec le guillemet utilisé pour encadrer la chaine formatée "
"littérale ::"

#: ../Doc/reference/lexical_analysis.rst:733
msgid ""
"Backslashes are not allowed in format expressions and will raise an error::"
msgstr ""
"La barre oblique inversée (ou antislash) n'est pas autorisée dans les "
"expressions des champs à remplacer et son utilisation génère une erreur ::"

#: ../Doc/reference/lexical_analysis.rst:738
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr ""
"Pour inclure une valeur où l'échappement par barre oblique inversée est "
"nécessaire, vous devez créer une variable temporaire."

#: ../Doc/reference/lexical_analysis.rst:745
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr ""
"Une chaine formatée littérale ne peut pas être utilisée en tant que "
"*docstring*, même si elle ne comporte pas d'expression."

#: ../Doc/reference/lexical_analysis.rst:756
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr ""
"Consultez aussi la :pep:`498` qui propose l'ajout des chaines formatées "
"littérales et :meth:`str.format` qui utilise un mécanisme similaire pour "
"formater les chaînes de caractères."

#: ../Doc/reference/lexical_analysis.rst:763
msgid "Numeric literals"
msgstr "Littéraux numériques"

#: ../Doc/reference/lexical_analysis.rst:769
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""
"Il existe trois types de littéraux numériques : les entiers, les nombres à "
"virgule flottante et les nombres imaginaires. Il n'y a pas de littéraux "
"complexes (les nombres complexes peuvent être construits en ajoutant un "
"nombre réel et un nombre imaginaire)."

#: ../Doc/reference/lexical_analysis.rst:773
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"Notez que les littéraux numériques ne comportent pas de signe ; une phrase "
"telle que ``-1`` est en fait une expression composée de l'opérateur unitaire "
"``-`` et du littéral ``1``."

#: ../Doc/reference/lexical_analysis.rst:787
msgid "Integer literals"
msgstr "Entiers littéraux"

#: ../Doc/reference/lexical_analysis.rst:789
msgid "Integer literals are described by the following lexical definitions:"
msgstr ""
"Les entiers littéraux sont décrits par les définitions lexicales suivantes :"

#: ../Doc/reference/lexical_analysis.rst:803
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""
"Il n'y a pas de limite pour la longueur des entiers littéraux, sauf celle "
"relative à la capacité mémoire."

#: ../Doc/reference/lexical_analysis.rst:806
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr ""
"Les tirets bas sont ignorés pour déterminer la valeur numérique du littéral. "
"Ils peuvent être utilisés pour grouper les chiffres afin de faciliter la "
"lecture. Un souligné peut être placé entre des chiffres ou après la "
"spécification de la base telle que ``0x``."

#: ../Doc/reference/lexical_analysis.rst:810
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""
"Notez que placer des zéros en tête de nombre pour un nombre décimal "
"différent de zéro n'est pas autorisé. Cela permet d'éviter l’ambigüité avec "
"les littéraux en base octale selon le style C que Python utilisait avant la "
"version 3.0."

#: ../Doc/reference/lexical_analysis.rst:814
msgid "Some examples of integer literals::"
msgstr "Quelques exemples d'entiers littéraux ::"

#: ../Doc/reference/lexical_analysis.rst:820
#: ../Doc/reference/lexical_analysis.rst:852
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "Les tirets bas ne sont pas autorisés pour grouper les littéraux."

#: ../Doc/reference/lexical_analysis.rst:831
msgid "Floating point literals"
msgstr "Nombres à virgule flottante littéraux"

#: ../Doc/reference/lexical_analysis.rst:833
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""
"Les nombres à virgule flottante littéraux sont décrits par les définitions "
"lexicales suivantes :"

#: ../Doc/reference/lexical_analysis.rst:843
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""
"Notez que la partie entière et l'exposant sont toujours interprétés comme "
"étant en base 10. Par exemple, ``077e010`` est licite et désigne le même "
"nombre que ``77e10``. La plage autorisée pour les littéraux de nombres à "
"virgule flottante dépend de l'implémentation. Comme pour les entiers "
"littéraux, les soulignés permettent de grouper des chiffres."

#: ../Doc/reference/lexical_analysis.rst:848
msgid "Some examples of floating point literals::"
msgstr "Quelques exemples de nombres à virgule flottante littéraux ::"

#: ../Doc/reference/lexical_analysis.rst:861
msgid "Imaginary literals"
msgstr "Imaginaires littéraux"

#: ../Doc/reference/lexical_analysis.rst:863
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""
"Les nombres imaginaires sont décrits par les définitions lexicales "
"suivantes :"

#: ../Doc/reference/lexical_analysis.rst:868
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"Un littéral imaginaire produit un nombre complexe dont la partie réelle est "
"``0.0``. Les nombres complexes sont représentés comme une paire de nombres à "
"virgule flottante et possèdent les mêmes restrictions concernant les plages "
"autorisées. Pour créer un nombre complexe dont la partie réelle est non "
"nulle, ajoutez un nombre à virgule flottante à votre littéral imaginaire. "
"Par exemple ``(3+4j)``. Voici d'autres exemples de littéraux imaginaires ::"

#: ../Doc/reference/lexical_analysis.rst:880
msgid "Operators"
msgstr "Opérateurs"

#: ../Doc/reference/lexical_analysis.rst:884
msgid "The following tokens are operators:"
msgstr "Les lexèmes suivants sont des opérateurs :"

#: ../Doc/reference/lexical_analysis.rst:897
msgid "Delimiters"
msgstr "Délimiteurs"

#: ../Doc/reference/lexical_analysis.rst:901
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "Les lexèmes suivants servent de délimiteurs dans la grammaire :"

#: ../Doc/reference/lexical_analysis.rst:910
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""
"Le point peut aussi apparaître dans les littéraux de nombres à virgule "
"flottante et imaginaires. Une suite de trois points possède une "
"signification spéciale : c'est une ellipse littérale. La deuxième partie de "
"la liste, les opérateurs d'assignation augmentés, servent de délimiteurs "
"pour l'analyseur lexical mais sont aussi des opérateurs."

#: ../Doc/reference/lexical_analysis.rst:915
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""
"Les caractères ASCII suivants ont une signification spéciale en tant que "
"partie d'autres lexèmes ou ont une signification particulière pour "
"l'analyseur lexical :"

#: ../Doc/reference/lexical_analysis.rst:922
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""
"Les caractères ASCII suivants ne sont pas utilisés en Python. S'ils "
"apparaissent en dehors de chaines littérales ou de commentaires, ils "
"produisent une erreur :"

#: ../Doc/reference/lexical_analysis.rst:931
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/reference/lexical_analysis.rst:932
msgid "http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr "http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
