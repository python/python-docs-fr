# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 22:40+0100\n"
"PO-Revision-Date: 2022-11-21 22:32+0100\n"
"Last-Translator: Samuel Giffard <samuel@giffard.co>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.2\n"

#: reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "Analyse lexicale"

#: reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Un programme Python est lu par un analyseur syntaxique (*parser* en "
"anglais). En entrée de cet analyseur syntaxique, nous trouvons des lexèmes "
"(*tokens* en anglais), produits par un analyseur lexical. Ce chapitre décrit "
"comment l'analyseur lexical découpe le fichier en lexèmes."

#: reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Python lit le texte du programme comme des suites de caractères Unicode ; "
"l'encodage du fichier source peut être spécifié par une déclaration "
"d'encodage et vaut par défaut UTF-8, voir la :pep:`3120` pour les détails. "
"Si le fichier source ne peut pas être décodé, une exception :exc:"
"`SyntaxError` (erreur de syntaxe) est levée."

#: reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "Structure des lignes"

#: reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Un programme en Python est divisé en *lignes logiques*."

#: reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "Lignes logiques"

#: reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"La fin d'une ligne logique est représentée par le lexème NEWLINE. Les "
"instructions ne peuvent pas traverser les limites des lignes logiques, sauf "
"quand NEWLINE est autorisé par la syntaxe (par exemple, entre les "
"instructions des instructions composées). Une ligne logique est constituée "
"d'une ou plusieurs *lignes physiques* en fonction des règles, explicites ou "
"implicites, de *continuation de ligne*."

#: reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "Lignes physiques"

#: reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed), "
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character.  "
"All of these forms can be used equally, regardless of platform. The end of "
"input also serves as an implicit terminator for the final physical line."
msgstr ""
"Une ligne physique est une suite de caractères terminée par une séquence de "
"fin de ligne. Dans les fichiers sources et les chaînes de caractères, "
"n'importe quelle séquence de fin de ligne des plateformes standards peut "
"être utilisée ; Unix utilise le caractère ASCII LF (pour *linefeed*, saut de "
"ligne en français), Windows utilise la séquence CR LF (*carriage return* "
"suivi de *linefeed*) et Macintosh utilisait le caractère ASCII CR. Toutes "
"ces séquences peuvent être utilisées, quelle que soit la plateforme. La fin "
"de l'entrée est aussi une fin de ligne physique implicite."

#: reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"Lorsque vous encapsulez Python, les chaînes de code source doivent être "
"passées à l'API Python en utilisant les conventions du C standard pour les "
"caractères de fin de ligne : le caractère ``\\n``, dont le code ASCII est LF."

#: reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "Commentaires"

#: reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"Un commentaire commence par le caractère croisillon (``#``, *hash* en "
"anglais et qui ressemble au symbole musical dièse, c'est pourquoi il est "
"souvent improprement appelé caractère dièse) situé en dehors d'une chaine de "
"caractères littérale et se termine à la fin de la ligne physique. Un "
"commentaire signifie la fin de la ligne logique à moins qu'une règle de "
"continuation de ligne implicite ne s'applique. Les commentaires sont ignorés "
"au niveau syntaxique, ce ne sont pas des lexèmes."

#: reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr "Déclaration d'encodage"

#: reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Si un commentaire placé sur la première ou deuxième ligne du script Python "
"correspond à l'expression rationnelle ``coding[=:]\\s*([-\\w.]+)``, ce "
"commentaire est analysé comme une déclaration d'encodage ; le premier groupe "
"de cette expression désigne l'encodage du fichier source. Cette déclaration "
"d'encodage doit être seule sur sa ligne et, si elle est sur la deuxième "
"ligne, la première ligne doit aussi être une ligne composée uniquement d'un "
"commentaire. Les formes recommandées pour l'expression de l'encodage sont ::"

#: reference/lexical_analysis.rst:91
msgid "# -*- coding: <encoding-name> -*-"
msgstr ""

#: reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "qui est reconnue aussi par GNU Emacs et ::"

#: reference/lexical_analysis.rst:95
msgid "# vim:fileencoding=<encoding-name>"
msgstr ""

#: reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "qui est reconnue par VIM de Bram Moolenaar."

#: reference/lexical_analysis.rst:99
#, fuzzy
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  If the "
"implicit or explicit encoding of a file is UTF-8, an initial UTF-8 byte-"
"order mark (b'\\xef\\xbb\\xbf') is ignored rather than being a syntax error."
msgstr ""
"Si aucune déclaration d'encodage n'est trouvée, l'encodage par défaut est "
"utilisé : UTF-8. En plus, si les premiers octets du fichier sont "
"l'indicateur d'ordre des octets UTF-8 (``b'\\xef\\xbb\\xbf'``, *BOM* en "
"anglais pour *byte order mark*), le fichier est considéré comme étant en "
"UTF-8 (cette convention est reconnue, entre autres, par :program:`notepad` "
"de Microsoft)."

#: reference/lexical_analysis.rst:103
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python "
"(see :ref:`standard-encodings`). The encoding is used for all lexical "
"analysis, including string literals, comments and identifiers."
msgstr ""
"Si un encodage est déclaré, le nom de l'encodage doit être reconnu par "
"Python (voir :ref:`standard-encodings`). L'encodage est utilisé pour toute "
"l'analyse lexicale, y compris les chaînes de caractères, les commentaires et "
"les identifiants."

#: reference/lexical_analysis.rst:112
msgid "Explicit line joining"
msgstr "Continuation de ligne explicite"

#: reference/lexical_analysis.rst:116
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Deux lignes physiques, ou plus, peuvent être jointes pour former une seule "
"ligne logique en utilisant la barre oblique inversée (``\\``) selon la règle "
"suivante : quand la ligne physique se termine par une barre oblique inversée "
"qui ne fait pas partie d'une chaine de caractères ou d'un commentaire, la "
"ligne immédiatement suivante lui est adjointe pour former une seule ligne "
"logique, en supprimant la barre oblique inversée et le caractère de fin de "
"ligne. Par exemple ::"

#: reference/lexical_analysis.rst:122
msgid ""
"if 1900 < year < 2100 and 1 <= month <= 12 \\\n"
"   and 1 <= day <= 31 and 0 <= hour < 24 \\\n"
"   and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date\n"
"        return 1"
msgstr ""

#: reference/lexical_analysis.rst:127
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"Une ligne que se termine par une barre oblique inversée ne peut pas avoir de "
"commentaire. La barre oblique inversée ne permet pas de continuer un "
"commentaire. La barre oblique inversée ne permet pas de continuer un lexème, "
"sauf s'il s'agit d'une chaîne de caractères (par exemple, les lexèmes autres "
"que les chaînes de caractères ne peuvent pas être répartis sur plusieurs "
"lignes en utilisant une barre oblique inversée). La barre oblique inversée "
"n'est pas autorisée ailleurs sur la ligne, en dehors d'une chaîne de "
"caractères."

#: reference/lexical_analysis.rst:137
msgid "Implicit line joining"
msgstr "Continuation de ligne implicite"

#: reference/lexical_analysis.rst:139
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Les expressions entre parenthèses, crochets ou accolades peuvent être "
"réparties sur plusieurs lignes sans utiliser de barre oblique inversée. Par "
"exemple ::"

#: reference/lexical_analysis.rst:142
msgid ""
"month_names = ['Januari', 'Februari', 'Maart',      # These are the\n"
"               'April',   'Mei',      'Juni',       # Dutch names\n"
"               'Juli',    'Augustus', 'September',  # for the months\n"
"               'Oktober', 'November', 'December']   # of the year"
msgstr ""

#: reference/lexical_analysis.rst:147
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"Les lignes continuées implicitement peuvent avoir des commentaires. "
"L'indentation des lignes de continuation n'est pas importante. Une ligne "
"blanche est autorisée comme ligne de continuation. Il ne doit pas y avoir de "
"lexème NEWLINE entre des lignes implicitement continuées. Les lignes "
"continuées implicitement peuvent être utilisées dans des chaînes entre "
"triples guillemets (voir ci-dessous) ; dans ce cas, elles ne peuvent pas "
"avoir de commentaires."

#: reference/lexical_analysis.rst:157
msgid "Blank lines"
msgstr "Lignes vierges"

#: reference/lexical_analysis.rst:161
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"Une ligne logique qui ne contient que des espaces, tabulations, caractères "
"de saut de page (*formfeed* en anglais) ou commentaires est ignorée (c'est-à-"
"dire que le lexème NEWLINE n'est pas produit). Pendant l'édition interactive "
"d'instructions, la gestion des lignes vierges peut différer en fonction de "
"l'implémentation de la boucle REPL. Dans l'interpréteur standard, une ligne "
"complètement vierge (c'est-à-dire ne contenant strictement rien, même pas "
"une espace ou un commentaire) termine une instruction multi-lignes."

#: reference/lexical_analysis.rst:172
msgid "Indentation"
msgstr "Indentation"

#: reference/lexical_analysis.rst:176
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"Des espaces ou tabulations au début d’une ligne logique sont utilisées pour "
"connaître le niveau d’indentation de la ligne, qui est ensuite utilisé pour "
"déterminer comment les instructions sont groupées."

#: reference/lexical_analysis.rst:180
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"Les tabulations sont remplacées (de la gauche vers la droite) par une à huit "
"espaces de manière à ce que le nombre de caractères remplacés soit un "
"multiple de huit (nous avons ainsi la même règle que celle d'Unix). Le "
"nombre total d'espaces précédant le premier caractère non blanc détermine "
"alors le niveau d'indentation de la ligne. L'indentation ne peut pas être "
"répartie sur plusieurs lignes physiques à l'aide de barres obliques "
"inversées ; les espaces jusqu'à la première barre oblique inversée "
"déterminent l'indentation."

#: reference/lexical_analysis.rst:188
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"L'indentation est déclarée inconsistante et rejetée si, dans un même fichier "
"source, le mélange des tabulations et des espaces est tel que la "
"signification dépend du nombre d'espaces que représente une tabulation. Une "
"exception :exc:`TabError` est levée dans ce cas."

#: reference/lexical_analysis.rst:192
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Note de compatibilité entre les plateformes :** en raison de la nature des "
"éditeurs de texte sur les plateformes non Unix, il n'est pas judicieux "
"d'utiliser un mélange d'espaces et de tabulations pour l'indentation dans un "
"seul fichier source. Il convient également de noter que des plateformes "
"peuvent explicitement limiter le niveau d'indentation maximal."

#: reference/lexical_analysis.rst:197
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Un caractère de saut de page peut être présent au début de la ligne ; il est "
"ignoré pour les calculs d'indentation ci-dessus. Les caractères de saut de "
"page se trouvant ailleurs avec les espaces en tête de ligne ont un effet "
"indéfini (par exemple, ils peuvent remettre à zéro le nombre d'espaces)."

#: reference/lexical_analysis.rst:204
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""
"Les niveaux d'indentation de lignes consécutives sont utilisés pour générer "
"les lexèmes INDENT et DEDENT, en utilisant une pile, de cette façon :"

#: reference/lexical_analysis.rst:207
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"Avant que la première ligne du fichier ne soit lue, un « zéro » est posé sur "
"la pile ; il ne sera plus jamais enlevé. Les nombres empilés sont toujours "
"strictement croissants de bas en haut. Au début de chaque ligne logique, le "
"niveau d'indentation de la ligne est comparé au sommet de la pile. S'ils "
"sont égaux, il ne se passe rien. S'il est plus grand, il est empilé et un "
"lexème INDENT est produit. S'il est plus petit, il *doit* être l'un des "
"nombres présents dans la pile ; tous les nombres de la pile qui sont plus "
"grands sont retirés et, pour chaque nombre retiré, un lexème DEDENT est "
"produit. À la fin du fichier, un lexème DEDENT est produit pour chaque "
"nombre supérieur à zéro restant sur la pile."

#: reference/lexical_analysis.rst:218
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Voici un exemple de code Python correctement indenté (bien que très "
"confus) ::"

#: reference/lexical_analysis.rst:221
msgid ""
"def perm(l):\n"
"        # Compute the list of all permutations of l\n"
"    if len(l) <= 1:\n"
"                  return [l]\n"
"    r = []\n"
"    for i in range(len(l)):\n"
"             s = l[:i] + l[i+1:]\n"
"             p = perm(s)\n"
"             for x in p:\n"
"              r.append(l[i:i+1] + x)\n"
"    return r"
msgstr ""

#: reference/lexical_analysis.rst:233
msgid "The following example shows various indentation errors::"
msgstr "L'exemple suivant montre plusieurs erreurs d'indentation ::"

#: reference/lexical_analysis.rst:235
msgid ""
" def perm(l):                       # error: first line indented\n"
"for i in range(len(l)):             # error: not indented\n"
"    s = l[:i] + l[i+1:]\n"
"        p = perm(l[:i] + l[i+1:])   # error: unexpected indent\n"
"        for x in p:\n"
"                r.append(l[i:i+1] + x)\n"
"            return r                # error: inconsistent dedent"
msgstr ""

#: reference/lexical_analysis.rst:243
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"En fait, les trois premières erreurs sont détectées par l'analyseur "
"syntaxique ; seule la dernière erreur est trouvée par l'analyseur lexical "
"(l'indentation de ``return r`` ne correspond à aucun niveau dans la pile)."

#: reference/lexical_analysis.rst:251
msgid "Whitespace between tokens"
msgstr "Espaces entre lexèmes"

#: reference/lexical_analysis.rst:253
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"Sauf au début d'une ligne logique ou dans les chaînes de caractères, les "
"caractères « blancs » espace, tabulation et saut de page peuvent être "
"utilisés de manière interchangeable pour séparer les lexèmes. Un blanc n'est "
"nécessaire entre deux lexèmes que si leur concaténation pourrait être "
"interprétée comme un lexème différent (par exemple, ab est un lexème, mais a "
"b comporte deux lexèmes)."

#: reference/lexical_analysis.rst:263
msgid "Other tokens"
msgstr "Autres lexèmes"

#: reference/lexical_analysis.rst:265
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"Outre NEWLINE, INDENT et DEDENT, il existe les catégories de lexèmes "
"suivantes : *identifiants*, *mots clés*, *littéraux*, *opérateurs* et "
"*délimiteurs*. Les blancs (autres que les fins de lignes, vus auparavant) ne "
"sont pas des lexèmes mais servent à délimiter les lexèmes. Quand une "
"ambiguïté existe, le lexème correspond à la plus grande chaîne possible qui "
"forme un lexème licite, en lisant de la gauche vers la droite."

#: reference/lexical_analysis.rst:275
msgid "Identifiers and keywords"
msgstr "Identifiants et mots-clés"

#: reference/lexical_analysis.rst:279
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""
"Les identifiants (aussi appelés *noms*) sont décrits par les définitions "
"lexicales suivantes."

#: reference/lexical_analysis.rst:282
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""
"La syntaxe des identifiants en Python est basée sur l'annexe UAX-31 du "
"standard Unicode avec les modifications définies ci-dessous ; consultez la :"
"pep:`3131` pour plus de détails."

#: reference/lexical_analysis.rst:286
#, fuzzy
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers include the uppercase and lowercase letters ``A`` through ``Z``, "
"the underscore ``_`` and, except for the first character, the digits ``0`` "
"through ``9``. Python 3.0 introduced additional characters from outside the "
"ASCII range (see :pep:`3131`).  For these characters, the classification "
"uses the version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""
"Python 3.0 introduit des caractères supplémentaires en dehors de "
"l'intervalle ASCII (voir la :pep:`3131`). Pour ces caractères, la "
"classification utilise la version de la « base de données des caractères "
"Unicode » telle qu'incluse dans le module :mod:`unicodedata`."

#: reference/lexical_analysis.rst:294
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""
"Les identifiants n'ont pas de limite de longueur. La casse est prise en "
"compte."

#: reference/lexical_analysis.rst:303
msgid "The Unicode category codes mentioned above stand for:"
msgstr "Les codes de catégories Unicode cités ci-dessus signifient :"

#: reference/lexical_analysis.rst:305
msgid "*Lu* - uppercase letters"
msgstr "*Lu* — lettres majuscules"

#: reference/lexical_analysis.rst:306
msgid "*Ll* - lowercase letters"
msgstr "*Ll* — lettres minuscules"

#: reference/lexical_analysis.rst:307
msgid "*Lt* - titlecase letters"
msgstr ""
"*Lt* — lettres majuscules particulières (catégorie *titlecase* de l'Unicode)"

#: reference/lexical_analysis.rst:308
msgid "*Lm* - modifier letters"
msgstr "*Lm* — lettres modificatives avec chasse"

#: reference/lexical_analysis.rst:309
msgid "*Lo* - other letters"
msgstr "*Lo* — autres lettres"

#: reference/lexical_analysis.rst:310
msgid "*Nl* - letter numbers"
msgstr "*Nl* — nombres lettres (par exemple, les nombres romains)"

#: reference/lexical_analysis.rst:311
msgid "*Mn* - nonspacing marks"
msgstr ""
"*Mn* — symboles que l'on combine avec d'autres (accents ou autres) sans "
"générer d'espace (*nonspacing marks* en anglais)"

#: reference/lexical_analysis.rst:312
msgid "*Mc* - spacing combining marks"
msgstr ""
"*Mc* — symboles que l'on combine avec d'autres en générant une espace "
"(*spacing combining marks* en anglais)"

#: reference/lexical_analysis.rst:313
msgid "*Nd* - decimal numbers"
msgstr "*Nd* — chiffres (arabes et autres)"

#: reference/lexical_analysis.rst:314
msgid "*Pc* - connector punctuations"
msgstr "*Pc* — connecteurs (tirets et autres lignes)"

#: reference/lexical_analysis.rst:315
#, fuzzy
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <https://www."
"unicode.org/Public/15.1.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""
"*Other_ID_Start* — liste explicite des caractères de `PropList.txt <https://"
"www.unicode.org/Public/14.0.0/ucd/PropList.txt>`_ pour la rétrocompatibilité"

#: reference/lexical_analysis.rst:318
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* — pareillement"

#: reference/lexical_analysis.rst:320
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""
"Tous les identifiants sont convertis dans la forme normale NFKC pendant "
"l'analyse syntaxique : la comparaison des identifiants se base sur leur "
"forme NFKC."

#: reference/lexical_analysis.rst:323
#, fuzzy
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 15.1.0 can be found at https://www.unicode.org/Public/15.1.0/ucd/"
"DerivedCoreProperties.txt"
msgstr ""
"Un fichier HTML, ne faisant pas référence, listant tous les caractères "
"valides pour Unicode 14.0.0 se trouve à https://www.unicode.org/"
"Public/14.0.0/ucd/DerivedCoreProperties.txt."

#: reference/lexical_analysis.rst:331
msgid "Keywords"
msgstr "Mots-clés"

#: reference/lexical_analysis.rst:337
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"Les identifiants suivants sont des mots réservés par le langage et ne "
"peuvent pas être utilisés en tant qu'identifiants normaux. Ils doivent être "
"écrits exactement comme ci-dessous :"

#: reference/lexical_analysis.rst:341
msgid ""
"False      await      else       import     pass\n"
"None       break      except     in         raise\n"
"True       class      finally    is         return\n"
"and        continue   for        lambda     try\n"
"as         def        from       nonlocal   while\n"
"assert     del        global     not        with\n"
"async      elif       if         or         yield"
msgstr ""

#: reference/lexical_analysis.rst:355
msgid "Soft Keywords"
msgstr "Mots-clés ad hoc"

#: reference/lexical_analysis.rst:361
#, fuzzy
msgid ""
"Some identifiers are only reserved under specific contexts. These are known "
"as *soft keywords*.  The identifiers ``match``, ``case``, ``type`` and ``_`` "
"can syntactically act as keywords in certain contexts, but this distinction "
"is done at the parser level, not when tokenizing."
msgstr ""
"Certains identifiants ne sont réservés que dans des contextes particuliers. "
"Ils sont appelés *mots-clés ad hoc*. Les identifiants ``match``, ``case`` et "
"``_`` peuvent être interprétés en tant que mots-clés dans le contexte "
"d'instructions de filtrage par motifs, mais cette distinction est effectuée "
"au niveau de l'analyseur syntaxique (*parser* en anglais), pas lors de "
"l'analyse lexicale (*tokenization* en anglais)."

#: reference/lexical_analysis.rst:366
#, fuzzy
msgid ""
"As soft keywords, their use in the grammar is possible while still "
"preserving compatibility with existing code that uses these names as "
"identifier names."
msgstr ""
"En tant que mots-clés ad hoc, leur utilisation dans le filtrage par motifs "
"est possible tout en conservant la compatibilité avec du code existant qui "
"utilise ``match``, ``case`` et ``_`` comme identifiants."

#: reference/lexical_analysis.rst:370
msgid ""
"``match``, ``case``, and ``_`` are used in the :keyword:`match` statement. "
"``type`` is used in the :keyword:`type` statement."
msgstr ""

#: reference/lexical_analysis.rst:373
msgid "``type`` is now a soft keyword."
msgstr ""

#: reference/lexical_analysis.rst:382
msgid "Reserved classes of identifiers"
msgstr "Classes réservées pour les identifiants"

#: reference/lexical_analysis.rst:384
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Certaines classes d'identifiants (outre les mots-clés) ont une signification "
"particulière. Ces classes se reconnaissent par des caractères de "
"soulignement en tête et en queue d'identifiant :"

#: reference/lexical_analysis.rst:388
msgid "``_*``"
msgstr "``_*``"

#: reference/lexical_analysis.rst:389
msgid "Not imported by ``from module import *``."
msgstr "N'est pas importé par ``from module import *``."

#: reference/lexical_analysis.rst:391
msgid "``_``"
msgstr "``_``"

#: reference/lexical_analysis.rst:392
msgid ""
"In a ``case`` pattern within a :keyword:`match` statement, ``_`` is a :ref:"
"`soft keyword <soft-keywords>` that denotes a :ref:`wildcard <wildcard-"
"patterns>`."
msgstr ""
"Dans un motif ``case`` d'une instruction :keyword:`match`, ``_`` est un :ref:"
"`mot-clé ad hoc <soft-keywords>` qui décrit un motif :ref:`attrape-tout "
"<wildcard-patterns>`."

#: reference/lexical_analysis.rst:396
msgid ""
"Separately, the interactive interpreter makes the result of the last "
"evaluation available in the variable ``_``. (It is stored in the :mod:"
"`builtins` module, alongside built-in functions like ``print``.)"
msgstr ""
"De son côté, l'interpréteur interactif place le résultat de la dernière "
"évaluation dans la variable ``-`` (son emplacement se situe dans le module :"
"mod:`builtins`, avec les fonctions natives telles que ``print``)."

#: reference/lexical_analysis.rst:401
msgid ""
"Elsewhere, ``_`` is a regular identifier. It is often used to name "
"\"special\" items, but it is not special to Python itself."
msgstr ""
"Ailleurs, ``_`` est un identifiant comme un autre. Il est souvent utilisé "
"pour désigner des éléments « spéciaux », mais il n'est pas spécial pour "
"Python en tant que tel."

#: reference/lexical_analysis.rst:406
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"Le nom ``_`` est souvent utilisé pour internationaliser l'affichage ; "
"reportez-vous à la documentation du module :mod:`gettext` pour plus "
"d'informations sur cette convention."

#: reference/lexical_analysis.rst:410
msgid "It is also commonly used for unused variables."
msgstr ""
"Il est aussi communément utilisé pour signifier que la variable n'est pas "
"utilisée."

#: reference/lexical_analysis.rst:412
msgid "``__*__``"
msgstr "``__*__``"

#: reference/lexical_analysis.rst:413
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"Noms définis par le système, appelés noms « *dunder* » (pour *Double "
"Underscores*) de manière informelle. Ces noms sont définis par "
"l'interpréteur et son implémentation (y compris la bibliothèque standard). "
"Les noms actuels définis par le système sont abordés dans la section :ref:"
"`specialnames`, mais aussi ailleurs. D'autres noms seront probablement "
"définis dans les futures versions de Python. Toute utilisation de noms de la "
"forme ``__*__``, dans n'importe quel contexte, qui n'est pas conforme à ce "
"qu'indique explicitement la documentation, est sujette à des mauvaises "
"surprises sans avertissement."

#: reference/lexical_analysis.rst:420
msgid "``__*``"
msgstr "``__*``"

#: reference/lexical_analysis.rst:421
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Noms privés pour une classe. Les noms de cette forme, lorsqu'ils sont "
"utilisés dans le contexte d'une définition de classe, sont réécrits sous une "
"forme modifiée pour éviter les conflits de noms entre les attributs "
"« privés » des classes de base et les classes dérivées. Voir la section :ref:"
"`atom-identifiers`."

#: reference/lexical_analysis.rst:430
msgid "Literals"
msgstr "Littéraux"

#: reference/lexical_analysis.rst:434
msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"Les littéraux sont des notations pour indiquer des valeurs constantes de "
"certains types natifs."

#: reference/lexical_analysis.rst:445
msgid "String and Bytes literals"
msgstr "Littéraux de chaînes de caractères et de suites d'octets"

#: reference/lexical_analysis.rst:447
msgid "String literals are described by the following lexical definitions:"
msgstr ""
"Les chaînes de caractères littérales sont définies par les définitions "
"lexicales suivantes :"

#: reference/lexical_analysis.rst:472
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`~python-grammar:stringprefix` "
"or :token:`~python-grammar:bytesprefix` and the rest of the literal. The "
"source character set is defined by the encoding declaration; it is UTF-8 if "
"no encoding declaration is given in the source file; see section :ref:"
"`encodings`."
msgstr ""
"Une restriction syntaxique non indiquée par ces règles est qu'aucun blanc "
"n'est autorisé entre le :token:`~python-grammar:stringprefix` ou :token:"
"`~python-grammar:bytesprefix` et le reste du littéral. Le jeu de caractères "
"source est défini par la déclaration d'encodage ; il vaut UTF-8 si aucune "
"déclaration d'encodage n'est donnée dans le fichier source ; voir la "
"section :ref:`encodings`."

#: reference/lexical_analysis.rst:482
#, fuzzy
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*). The backslash (``\\``) character is "
"used to give special meaning to otherwise ordinary characters like ``n``, "
"which means 'newline' when escaped (``\\n``). It can also be used to escape "
"characters that otherwise have a special meaning, such as newline, backslash "
"itself, or the quote character. See :ref:`escape sequences <escape-"
"sequences>` below for examples."
msgstr ""
"Description en français : les deux types de littéraux peuvent être encadrés "
"par une paire de guillemets simples (``'``) ou doubles (``\"``). Ils peuvent "
"aussi être encadrés par une paire de trois guillemets simples ou une paire "
"de trois guillemets doubles (on appelle alors généralement ces chaînes "
"*entre triples guillemets*). La barre oblique inversée peut être utilisée "
"pour échapper des caractères qui auraient sinon une signification spéciale, "
"tels que le retour à la ligne, la barre oblique inversée elle-même ou le "
"guillemet utilisé pour délimiter la chaîne."

#: reference/lexical_analysis.rst:495
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"Les littéraux de suites d'octets sont toujours préfixés par ``'b'`` ou "
"``'B'`` ; cela crée une instance de type :class:`bytes` au lieu du type :"
"class:`str`. Ils ne peuvent contenir que des caractères ASCII ; les octets "
"dont la valeur est supérieure ou égale à 128 doivent être exprimés à l'aide "
"d'échappements."

#: reference/lexical_analysis.rst:504
#, fuzzy
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such constructs are called :dfn:`raw string literals` "
"and :dfn:`raw bytes literals` respectively and treat backslashes as literal "
"characters.  As a result, in raw string literals, ``'\\U'`` and ``'\\u'`` "
"escapes are not treated specially."
msgstr ""
"Les chaînes et suites d'octets littérales peuvent être préfixées par la "
"lettre ``'r'`` ou ``'R'`` ; de telles chaînes sont appelées :dfn:`chaines "
"brutes` (*raw strings* en anglais) et traitent la barre oblique inversée "
"comme un caractère normal. En conséquence, les chaînes littérales ``'\\U'`` "
"et ``'\\u'`` ne sont pas considérées comme spéciales. Comme les littéraux "
"Unicode de Python 2.x se comportent différemment, la syntaxe ``'ur'`` n'est "
"pas reconnue en Python 3.x."

#: reference/lexical_analysis.rst:510
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""
"le préfixe ``'rb'`` a été ajouté comme synonyme de ``'br'`` pour les "
"littéraux de suites d'octets."

#: reference/lexical_analysis.rst:514
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"la gestion du préfixe historique pour les chaînes Unicode (``u'chaine'``) a "
"été réintroduite afin de simplifier la maintenance de code compatible Python "
"2.x et 3.x. Voir la :pep:`414` pour davantage d'informations."

#: reference/lexical_analysis.rst:522
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""
"Une chaîne littérale qui contient ``'f'`` ou ``'F'`` dans le préfixe est "
"une :dfn:`chaîne de caractères littérale formatée` ; lisez :ref:`f-strings`. "
"Le ``'f'`` peut être combiné avec ``'r'`` mais pas avec ``'b'`` ou ``'u'``, "
"donc les chaînes de caractères formatées sont possibles mais les littéraux "
"de suites d'octets ne peuvent pas l'être."

#: reference/lexical_analysis.rst:527
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"Dans les chaînes entre triples guillemets, les sauts de ligne et guillemets "
"peuvent ne pas être échappés (et sont donc pris en compte), mais trois "
"guillemets non échappés à la suite terminent le littéral (on entend par "
"guillemet le caractère utilisé pour commencer le littéral, c'est-à-dire "
"``'`` ou ``\"``)."

#: reference/lexical_analysis.rst:550
#, fuzzy
msgid "Escape sequences"
msgstr "Séquence d'échappement"

#: reference/lexical_analysis.rst:552
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"À moins que le préfixe ``'r'`` ou ``'R'`` ne soit présent, les séquences "
"d'échappement dans les littéraux de chaînes et suites d'octets sont "
"interprétées comme elles le seraient par le C Standard. Les séquences "
"d'échappement reconnues sont :"

#: reference/lexical_analysis.rst:557 reference/lexical_analysis.rst:590
msgid "Escape Sequence"
msgstr "Séquence d'échappement"

#: reference/lexical_analysis.rst:557 reference/lexical_analysis.rst:590
msgid "Meaning"
msgstr "Signification"

#: reference/lexical_analysis.rst:557 reference/lexical_analysis.rst:590
msgid "Notes"
msgstr "Notes"

#: reference/lexical_analysis.rst:559
#, fuzzy
msgid "``\\``\\ <newline>"
msgstr "``\\newline``"

#: reference/lexical_analysis.rst:559
msgid "Backslash and newline ignored"
msgstr "barre oblique inversée et retour à la ligne ignorés"

#: reference/lexical_analysis.rst:559
msgid "\\(1)"
msgstr ""

#: reference/lexical_analysis.rst:561
msgid "``\\\\``"
msgstr "``\\\\``"

#: reference/lexical_analysis.rst:561
msgid "Backslash (``\\``)"
msgstr "barre oblique inversée (``\\``)"

#: reference/lexical_analysis.rst:563
msgid "``\\'``"
msgstr "``\\'``"

#: reference/lexical_analysis.rst:563
msgid "Single quote (``'``)"
msgstr "guillemet simple (``'``)"

#: reference/lexical_analysis.rst:565
msgid "``\\\"``"
msgstr "``\\\"``"

#: reference/lexical_analysis.rst:565
msgid "Double quote (``\"``)"
msgstr "guillemet double (``\"``)"

#: reference/lexical_analysis.rst:567
msgid "``\\a``"
msgstr "``\\a``"

#: reference/lexical_analysis.rst:567
msgid "ASCII Bell (BEL)"
msgstr "cloche ASCII (BEL)"

#: reference/lexical_analysis.rst:569
msgid "``\\b``"
msgstr "``\\b``"

#: reference/lexical_analysis.rst:569
msgid "ASCII Backspace (BS)"
msgstr "retour arrière ASCII (BS)"

#: reference/lexical_analysis.rst:571
msgid "``\\f``"
msgstr "``\\f``"

#: reference/lexical_analysis.rst:571
msgid "ASCII Formfeed (FF)"
msgstr "saut de page ASCII (FF)"

#: reference/lexical_analysis.rst:573
msgid "``\\n``"
msgstr "``\\n``"

#: reference/lexical_analysis.rst:573
msgid "ASCII Linefeed (LF)"
msgstr "saut de ligne ASCII (LF)"

#: reference/lexical_analysis.rst:575
msgid "``\\r``"
msgstr "``\\r``"

#: reference/lexical_analysis.rst:575
msgid "ASCII Carriage Return (CR)"
msgstr "retour à la ligne ASCII (CR)"

#: reference/lexical_analysis.rst:577
msgid "``\\t``"
msgstr "``\\t``"

#: reference/lexical_analysis.rst:577
msgid "ASCII Horizontal Tab (TAB)"
msgstr "tabulation horizontale ASCII (TAB)"

#: reference/lexical_analysis.rst:579
msgid "``\\v``"
msgstr "``\\v``"

#: reference/lexical_analysis.rst:579
msgid "ASCII Vertical Tab (VT)"
msgstr "tabulation verticale ASCII (VT)"

#: reference/lexical_analysis.rst:581
msgid ":samp:`\\\\\\\\{ooo}`"
msgstr ""

#: reference/lexical_analysis.rst:581
msgid "Character with octal value *ooo*"
msgstr "caractère dont le code est *ooo* en octal"

#: reference/lexical_analysis.rst:581
msgid "(2,4)"
msgstr ""

#: reference/lexical_analysis.rst:584
msgid ":samp:`\\\\x{hh}`"
msgstr ""

#: reference/lexical_analysis.rst:584
msgid "Character with hex value *hh*"
msgstr "caractère dont le code est *ooo* en hexadécimal"

#: reference/lexical_analysis.rst:584
msgid "(3,4)"
msgstr ""

#: reference/lexical_analysis.rst:587
msgid "Escape sequences only recognized in string literals are:"
msgstr ""
"Les séquences d'échappement reconnues seulement dans les chaînes littérales "
"sont :"

#: reference/lexical_analysis.rst:592
msgid ":samp:`\\\\N\\\\{{name}\\\\}`"
msgstr ""

#: reference/lexical_analysis.rst:592
msgid "Character named *name* in the Unicode database"
msgstr "caractère dont le nom est *name* dans la base de données Unicode"

#: reference/lexical_analysis.rst:592
msgid "\\(5)"
msgstr "\\(5)"

#: reference/lexical_analysis.rst:595
msgid ":samp:`\\\\u{xxxx}`"
msgstr ""

#: reference/lexical_analysis.rst:595
msgid "Character with 16-bit hex value *xxxx*"
msgstr "caractère dont le code est *xxxx* en hexadécimal"

#: reference/lexical_analysis.rst:595
msgid "\\(6)"
msgstr "\\(6)"

#: reference/lexical_analysis.rst:598
#, fuzzy
msgid ":samp:`\\\\U{xxxxxxxx}`"
msgstr "``\\Uxxxxxxxx``"

#: reference/lexical_analysis.rst:598
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "caractère dont le code est *xxxxxxxx* en hexadécimal sur 32 bits"

#: reference/lexical_analysis.rst:598
msgid "\\(7)"
msgstr ""

#: reference/lexical_analysis.rst:602
msgid "Notes:"
msgstr "Notes :"

#: reference/lexical_analysis.rst:605
msgid "A backslash can be added at the end of a line to ignore the newline::"
msgstr ""

#: reference/lexical_analysis.rst:607
msgid ""
">>> 'This string will not include \\\n"
"... backslashes or newline characters.'\n"
"'This string will not include backslashes or newline characters.'"
msgstr ""

#: reference/lexical_analysis.rst:611
msgid ""
"The same result can be achieved using :ref:`triple-quoted strings "
"<strings>`, or parentheses and :ref:`string literal concatenation <string-"
"concatenation>`."
msgstr ""

#: reference/lexical_analysis.rst:616
msgid "As in Standard C, up to three octal digits are accepted."
msgstr ""
"Comme dans le C Standard, jusqu'à trois chiffres en base huit sont acceptés."

#: reference/lexical_analysis.rst:618
#, fuzzy
msgid ""
"Octal escapes with value larger than ``0o377`` produce a :exc:"
"`DeprecationWarning`."
msgstr ""
"Les séquences d'échappement pour les valeurs octales plus grandes que "
"``0o377`` produisent une :exc:`DeprecationWarning`. Dans les versions "
"suivantes de Python, elles génèreront une :exc:`SyntaxWarning` et "
"éventuellement une :exc:`SyntaxError`."

#: reference/lexical_analysis.rst:622
#, fuzzy
msgid ""
"Octal escapes with value larger than ``0o377`` produce a :exc:"
"`SyntaxWarning`. In a future Python version they will be eventually a :exc:"
"`SyntaxError`."
msgstr ""
"Les séquences d'échappement pour les valeurs octales plus grandes que "
"``0o377`` produisent une :exc:`DeprecationWarning`. Dans les versions "
"suivantes de Python, elles génèreront une :exc:`SyntaxWarning` et "
"éventuellement une :exc:`SyntaxError`."

#: reference/lexical_analysis.rst:628
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""
"Contrairement au C Standard, il est obligatoire de fournir deux chiffres "
"hexadécimaux."

#: reference/lexical_analysis.rst:631
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""
"Dans un littéral de suite d'octets, un échappement hexadécimal ou octal est "
"un octet dont la valeur est donnée. Dans une chaîne littérale, un "
"échappement est un caractère Unicode dont le code est donné."

#: reference/lexical_analysis.rst:636
msgid "Support for name aliases [#]_ has been added."
msgstr "Ajout du support pour les alias de noms [#]_."

#: reference/lexical_analysis.rst:640
msgid "Exactly four hex digits are required."
msgstr "Exactement quatre chiffres hexadécimaux sont requis."

#: reference/lexical_analysis.rst:643
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr ""
"N'importe quel caractère Unicode peut être encodé de cette façon. Exactement "
"huit chiffres hexadécimaux sont requis."

#: reference/lexical_analysis.rst:649
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"Contrairement au C standard, toutes les séquences d'échappement non "
"reconnues sont laissées inchangées dans la chaîne, c'est-à-dire que *la "
"barre oblique inversée est laissée dans le résultat* (ce comportement est "
"utile en cas de débogage : si une séquence d'échappement est mal tapée, la "
"sortie résultante est plus facilement reconnue comme source de l'erreur). "
"Notez bien également que les séquences d'échappement reconnues uniquement "
"dans les littéraux de chaînes de caractères ne sont pas reconnues pour les "
"littéraux de suites d'octets."

#: reference/lexical_analysis.rst:656
msgid "Unrecognized escape sequences produce a :exc:`DeprecationWarning`."
msgstr ""

#: reference/lexical_analysis.rst:659
#, fuzzy
msgid ""
"Unrecognized escape sequences produce a :exc:`SyntaxWarning`. In a future "
"Python version they will be eventually a :exc:`SyntaxError`."
msgstr ""
"Les séquences d'échappement non reconnues produisent une :exc:"
"`DeprecationWarning`. Dans les versions suivantes de Python, elles génèrent "
"une :exc:`SyntaxWarning` et éventuellement une :exc:`SyntaxError`."

#: reference/lexical_analysis.rst:663
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"Même dans une chaîne littérale brute, les guillemets peuvent être échappés "
"avec une barre oblique inversée mais la barre oblique inversée reste dans le "
"résultat ; par exemple, ``r\"\\\"\"`` est une chaîne de caractères valide "
"composée de deux caractères : une barre oblique inversée et un guillemet "
"double ; ``r\"\\\"`` n'est pas une chaîne de caractères valide (même une "
"chaîne de caractères brute ne peut pas se terminer par un nombre impair de "
"barres obliques inversées). Plus précisément, *une chaîne littérale brute ne "
"peut pas se terminer par une seule barre oblique inversée* (puisque la barre "
"oblique inversée échappe le guillemet suivant). Notez également qu'une "
"simple barre oblique inversée suivie d'un saut de ligne est interprétée "
"comme deux caractères faisant partie du littéral et *non* comme une "
"continuation de ligne."

#: reference/lexical_analysis.rst:676
msgid "String literal concatenation"
msgstr "Concaténation de chaînes de caractères"

#: reference/lexical_analysis.rst:678
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""
"Plusieurs chaînes de caractères ou suites d'octets adjacentes (séparées par "
"des blancs), utilisant éventuellement des conventions de guillemets "
"différentes, sont autorisées. La signification est la même que leur "
"concaténation. Ainsi, ``\"hello\" 'world'`` est l'équivalent de "
"``\"helloworld\"``. Cette fonctionnalité peut être utilisée pour réduire le "
"nombre de barres obliques inverses, pour diviser de longues chaînes de "
"caractères sur plusieurs lignes ou même pour ajouter des commentaires à des "
"portions de chaînes de caractères. Par exemple ::"

#: reference/lexical_analysis.rst:685
msgid ""
"re.compile(\"[A-Za-z_]\"       # letter or underscore\n"
"           \"[A-Za-z0-9_]*\"   # letter, digit or underscore\n"
"          )"
msgstr ""

#: reference/lexical_analysis.rst:689
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""
"Notez que cette fonctionnalité agit au niveau syntaxique mais est "
"implémentée au moment de la compilation. Pour concaténer les expressions des "
"chaînes de caractères au moment de l'exécution, vous devez utiliser "
"l'opérateur ``+``. Notez également que la concaténation littérale peut "
"utiliser un style différent de guillemets pour chaque composant (et même "
"mélanger des chaînes de caractères brutes et des chaînes de caractères entre "
"triples guillemets). Enfin, les chaînes de caractères formatées peuvent être "
"concaténées avec des chaînes de caractères ordinaires."

#: reference/lexical_analysis.rst:712
msgid "f-strings"
msgstr ""

#: reference/lexical_analysis.rst:716
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
"Une :dfn:`chaine de caractères littérale formatée` ou :dfn:`f-string` est "
"une chaine de caractères littérale préfixée par ``'f'`` ou ``'F'``. Ces "
"chaines peuvent contenir des champs à remplacer, c'est-à-dire des "
"expressions délimitées par des accolades ``{}``. Alors que les autres "
"littéraux de chaines ont des valeurs constantes, les chaines formatées sont "
"de vraies expressions évaluées à l'exécution."

#: reference/lexical_analysis.rst:722
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a "
"literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr ""
"Les séquences d'échappement sont décodées comme à l'intérieur des chaînes de "
"caractères ordinaires (sauf lorsqu'une chaîne de caractères est également "
"marquée comme une chaîne brute). Après décodage, la grammaire s'appliquant "
"au contenu de la chaîne de caractères est :"

#: reference/lexical_analysis.rst:736
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression. To display "
"both the expression text and its value after evaluation, (useful in "
"debugging), an equal sign ``'='`` may be added after the expression. A "
"conversion field, introduced by an exclamation point ``'!'`` may follow.  A "
"format specifier may also be appended, introduced by a colon ``':'``. A "
"replacement field ends with a closing curly bracket ``'}'``."
msgstr ""
"Les portions qui sont en dehors des accolades sont traitées comme les "
"littéraux, sauf les doubles accolades ``'{{'`` ou ``'}}'`` qui sont "
"remplacées par la simple accolade correspondante. Une simple accolade "
"ouvrante ``'{'`` marque le début du champ à remplacer, qui commence par une "
"expression Python. Pour afficher à la fois le texte de l'expression et sa "
"valeur une fois évaluée (utile lors du débogage), un signe égal ``'='`` peut "
"être ajouté après l'expression. Ensuite, il peut y avoir un champ de "
"conversion, introduit par un point d'exclamation ``'!'``. Une spécification "
"de format peut aussi être rajoutée, introduite par le caractère deux-points "
"``':'``. Le champ à remplacer se termine par une accolade fermante ``'}'``."

#: reference/lexical_analysis.rst:746
#, fuzzy
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Each "
"expression is evaluated in the context where the formatted string literal "
"appears, in order from left to right.  Replacement expressions can contain "
"newlines in both single-quoted and triple-quoted f-strings and they can "
"contain comments.  Everything that comes after a ``#`` inside a replacement "
"field is a comment (even closing braces and quotes). In that case, "
"replacement fields must be closed in a different line."
msgstr ""
"Les expressions dans les chaînes de caractères formatées littérales sont "
"traitées comme des expressions Python normales entourées de parenthèses, à "
"quelques exceptions près. Une expression vide n'est pas autorisée et les "
"expressions :keyword:`lambda` comme les affectations ``:=`` doivent être "
"explicitement entourées de parenthèses. Les expressions de remplacement "
"peuvent contenir des sauts de ligne (par exemple dans les chaînes de "
"caractères entre triples guillemets) mais elles ne peuvent pas contenir de "
"commentaire. Chaque expression est évaluée dans le contexte où la chaîne de "
"caractères formatée apparaît, de gauche à droite."

#: reference/lexical_analysis.rst:757
msgid ""
">>> f\"abc{a # This is a comment }\"\n"
"... + 3}\"\n"
"'abc5'"
msgstr ""

#: reference/lexical_analysis.rst:763
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in "
"formatted string literals due to a problem with the implementation."
msgstr ""
"Avant Python 3.7, il était illégal d’utiliser :keyword:`await` ainsi que les "
"compréhensions utilisant :keyword:`async for` dans les expressions au sein "
"des chaînes de caractères formatées littérales à cause d’un problème dans "
"l’implémentation."

#: reference/lexical_analysis.rst:768
msgid ""
"Prior to Python 3.12, comments were not allowed inside f-string replacement "
"fields."
msgstr ""

#: reference/lexical_analysis.rst:772
msgid ""
"When the equal sign ``'='`` is provided, the output will have the expression "
"text, the ``'='`` and the evaluated value. Spaces after the opening brace "
"``'{'``, within the expression and after the ``'='`` are all retained in the "
"output. By default, the ``'='`` causes the :func:`repr` of the expression to "
"be provided, unless there is a format specified. When a format is specified "
"it defaults to the :func:`str` of the expression unless a conversion ``'!"
"r'`` is declared."
msgstr ""
"Lorsqu'un signe égal ``'='`` est présent, la sortie comprend le texte de "
"l'expression, le signe ``'='`` et la valeur calculée. Les espaces après "
"l'accolade ouvrante ``'{'``, dans l'expression et après le signe ``'='`` "
"sont conservées à l'affichage. Par défaut, le signe ``'='`` utilise la :func:"
"`repr` de l'expression, sauf si un format est indiqué. Quand le format est "
"indiqué, c'est :func:`str` de l'expression qui est utilisée à moins qu'une "
"conversion ``!r`` ne soit déclarée."

#: reference/lexical_analysis.rst:780
msgid "The equal sign ``'='``."
msgstr "le signe égal ``'='``."

#: reference/lexical_analysis.rst:783
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"Si une conversion est spécifiée, le résultat de l'évaluation de l'expression "
"est converti avant d'être formaté. La conversion ``'!s'`` appelle :func:"
"`str` sur le résultat, ``'!r'`` appelle :func:`repr` et ``'!a'`` appelle :"
"func:`ascii`."

#: reference/lexical_analysis.rst:787
#, fuzzy
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`~object.__format__` method of the "
"expression or conversion result.  An empty string is passed when the format "
"specifier is omitted.  The formatted result is then included in the final "
"value of the whole string."
msgstr ""
"Le résultat est ensuite formaté en utilisant le protocole de :func:`format`. "
"La spécification du format est passée à la méthode :meth:`__format__` de "
"l'expression ou du résultat de la conversion. Une chaîne vide est passée "
"lorsque la spécification de format est omise. Le résultat formaté est alors "
"inclus dans la valeur finale de la chaîne complète."

#: reference/lexical_analysis.rst:793
#, fuzzy
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply nested replacement "
"fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the :meth:`str.format` method."
msgstr ""
"Les spécifications de format peuvent inclure des champs de remplacement "
"imbriqués. Ces champs imbriqués peuvent inclure leurs propres champs de "
"conversion et :ref:`spécifications de format <formatspec>` mais "
"l'imbrication ne doit pas aller plus profond. Le :ref:`mini-langage de "
"spécification de format  <formatspec>` est le même que celui utilisé par la "
"méthode :meth:`str.format`."

#: reference/lexical_analysis.rst:799
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot "
"be split across literals."
msgstr ""
"Les chaînes formatées littérales peuvent être concaténées mais les champs à "
"remplacer ne peuvent pas être divisés entre les littéraux."

#: reference/lexical_analysis.rst:802
msgid "Some examples of formatted string literals::"
msgstr "Quelques exemples de chaines formatées littérales ::"

#: reference/lexical_analysis.rst:804
msgid ""
">>> name = \"Fred\"\n"
">>> f\"He said his name is {name!r}.\"\n"
"\"He said his name is 'Fred'.\"\n"
">>> f\"He said his name is {repr(name)}.\"  # repr() is equivalent to !r\n"
"\"He said his name is 'Fred'.\"\n"
">>> width = 10\n"
">>> precision = 4\n"
">>> value = decimal.Decimal(\"12.34567\")\n"
">>> f\"result: {value:{width}.{precision}}\"  # nested fields\n"
"'result:      12.35'\n"
">>> today = datetime(year=2017, month=1, day=27)\n"
">>> f\"{today:%B %d, %Y}\"  # using date format specifier\n"
"'January 27, 2017'\n"
">>> f\"{today=:%B %d, %Y}\" # using date format specifier and debugging\n"
"'today=January 27, 2017'\n"
">>> number = 1024\n"
">>> f\"{number:#0x}\"  # using integer format specifier\n"
"'0x400'\n"
">>> foo = \"bar\"\n"
">>> f\"{ foo = }\" # preserves whitespace\n"
"\" foo = 'bar'\"\n"
">>> line = \"The mill's closed\"\n"
">>> f\"{line = }\"\n"
"'line = \"The mill\\'s closed\"'\n"
">>> f\"{line = :20}\"\n"
"\"line = The mill's closed   \"\n"
">>> f\"{line = !r:20}\"\n"
"'line = \"The mill\\'s closed\" '"
msgstr ""

#: reference/lexical_analysis.rst:834
msgid ""
"Reusing the outer f-string quoting type inside a replacement field is "
"permitted::"
msgstr ""

#: reference/lexical_analysis.rst:837
msgid ""
">>> a = dict(x=2)\n"
">>> f\"abc {a[\"x\"]} def\"\n"
"'abc 2 def'"
msgstr ""

#: reference/lexical_analysis.rst:841
msgid ""
"Prior to Python 3.12, reuse of the same quoting type of the outer f-string "
"inside a replacement field was not possible."
msgstr ""

#: reference/lexical_analysis.rst:845
msgid ""
"Backslashes are also allowed in replacement fields and are evaluated the "
"same way as in any other context::"
msgstr ""

#: reference/lexical_analysis.rst:848
msgid ""
">>> a = [\"a\", \"b\", \"c\"]\n"
">>> print(f\"List a contains:\\n{\"\\n\".join(a)}\")\n"
"List a contains:\n"
"a\n"
"b\n"
"c"
msgstr ""

#: reference/lexical_analysis.rst:855
msgid ""
"Prior to Python 3.12, backslashes were not permitted inside an f-string "
"replacement field."
msgstr ""

#: reference/lexical_analysis.rst:859
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr ""
"Une chaine formatée littérale ne peut pas être utilisée en tant que "
"*docstring*, même si elle ne comporte pas d'expression."

#: reference/lexical_analysis.rst:864
msgid ""
">>> def foo():\n"
"...     f\"Not a docstring\"\n"
"...\n"
">>> foo.__doc__ is None\n"
"True"
msgstr ""

#: reference/lexical_analysis.rst:870
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr ""
"Consultez aussi la :pep:`498` qui propose l'ajout des chaines formatées "
"littérales et :meth:`str.format` qui utilise un mécanisme similaire pour "
"formater les chaînes de caractères."

#: reference/lexical_analysis.rst:877
msgid "Numeric literals"
msgstr "Littéraux numériques"

#: reference/lexical_analysis.rst:883
#, fuzzy
msgid ""
"There are three types of numeric literals: integers, floating-point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""
"Il existe trois types de littéraux numériques : les entiers, les nombres à "
"virgule flottante et les nombres imaginaires. Il n'y a pas de littéraux "
"complexes (les nombres complexes peuvent être construits en ajoutant un "
"nombre réel et un nombre imaginaire)."

#: reference/lexical_analysis.rst:887
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"Notez que les littéraux numériques ne comportent pas de signe ; une phrase "
"telle que ``-1`` est en fait une expression composée de l'opérateur unitaire "
"``-`` et du littéral ``1``."

#: reference/lexical_analysis.rst:901
msgid "Integer literals"
msgstr "Entiers littéraux"

#: reference/lexical_analysis.rst:903
msgid "Integer literals are described by the following lexical definitions:"
msgstr ""
"Les entiers littéraux sont décrits par les définitions lexicales suivantes :"

#: reference/lexical_analysis.rst:917
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""
"Il n'y a pas de limite pour la longueur des entiers littéraux, sauf celle "
"relative à la capacité mémoire."

#: reference/lexical_analysis.rst:920
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr ""
"Les tirets bas sont ignorés pour déterminer la valeur numérique du littéral. "
"Ils peuvent être utilisés pour grouper les chiffres afin de faciliter la "
"lecture. Un souligné peut être placé entre des chiffres ou après la "
"spécification de la base telle que ``0x``."

#: reference/lexical_analysis.rst:924
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""
"Notez que placer des zéros en tête de nombre pour un nombre décimal "
"différent de zéro n'est pas autorisé. Cela permet d'éviter l’ambigüité avec "
"les littéraux en base octale selon le style C que Python utilisait avant la "
"version 3.0."

#: reference/lexical_analysis.rst:928
msgid "Some examples of integer literals::"
msgstr "Quelques exemples d'entiers littéraux ::"

#: reference/lexical_analysis.rst:930
msgid ""
"7     2147483647                        0o177    0b100110111\n"
"3     79228162514264337593543950336     0o377    0xdeadbeef\n"
"      100_000_000_000                   0b_1110_0101"
msgstr ""

#: reference/lexical_analysis.rst:934 reference/lexical_analysis.rst:966
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "Les tirets bas ne sont pas autorisés pour grouper les littéraux."

#: reference/lexical_analysis.rst:945
#, fuzzy
msgid "Floating-point literals"
msgstr "Nombres à virgule flottante littéraux"

#: reference/lexical_analysis.rst:947
#, fuzzy
msgid ""
"Floating-point literals are described by the following lexical definitions:"
msgstr ""
"Les nombres à virgule flottante littéraux sont décrits par les définitions "
"lexicales suivantes :"

#: reference/lexical_analysis.rst:957
#, fuzzy
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating-point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""
"Notez que la partie entière et l'exposant sont toujours interprétés comme "
"étant en base 10. Par exemple, ``077e010`` est licite et désigne le même "
"nombre que ``77e10``. La plage autorisée pour les littéraux de nombres à "
"virgule flottante dépend de l'implémentation. Comme pour les entiers "
"littéraux, les soulignés permettent de grouper des chiffres."

#: reference/lexical_analysis.rst:962
#, fuzzy
msgid "Some examples of floating-point literals::"
msgstr "Quelques exemples de nombres à virgule flottante littéraux ::"

#: reference/lexical_analysis.rst:964
msgid "3.14    10.    .001    1e100    3.14e-10    0e0    3.14_15_93"
msgstr ""

#: reference/lexical_analysis.rst:975
msgid "Imaginary literals"
msgstr "Imaginaires littéraux"

#: reference/lexical_analysis.rst:977
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""
"Les nombres imaginaires sont décrits par les définitions lexicales "
"suivantes :"

#: reference/lexical_analysis.rst:982
#, fuzzy
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating-point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating-point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"Un littéral imaginaire produit un nombre complexe dont la partie réelle est "
"``0.0``. Les nombres complexes sont représentés comme une paire de nombres à "
"virgule flottante et possèdent les mêmes restrictions concernant les plages "
"autorisées. Pour créer un nombre complexe dont la partie réelle est non "
"nulle, ajoutez un nombre à virgule flottante à votre littéral imaginaire. "
"Par exemple ``(3+4j)``. Voici d'autres exemples de littéraux imaginaires ::"

#: reference/lexical_analysis.rst:988
msgid "3.14j   10.j    10j     .001j   1e100j   3.14e-10j   3.14_15_93j"
msgstr ""

#: reference/lexical_analysis.rst:994
msgid "Operators"
msgstr "Opérateurs"

#: reference/lexical_analysis.rst:998
msgid "The following tokens are operators:"
msgstr "Les lexèmes suivants sont des opérateurs :"

#: reference/lexical_analysis.rst:1000
msgid ""
"+       -       *       **      /       //      %      @\n"
"<<      >>      &       |       ^       ~       :=\n"
"<       >       <=      >=      ==      !="
msgstr ""

#: reference/lexical_analysis.rst:1011
msgid "Delimiters"
msgstr "Délimiteurs"

#: reference/lexical_analysis.rst:1015
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "Les lexèmes suivants servent de délimiteurs dans la grammaire :"

#: reference/lexical_analysis.rst:1017
msgid ""
"(       )       [       ]       {       }\n"
",       :       !       .       ;       @       =\n"
"->      +=      -=      *=      /=      //=     %=\n"
"@=      &=      |=      ^=      >>=     <<=     **="
msgstr ""

#: reference/lexical_analysis.rst:1024
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""
"Le point peut aussi apparaître dans les littéraux de nombres à virgule "
"flottante et imaginaires. Une suite de trois points possède une "
"signification spéciale : c'est une ellipse littérale. La deuxième partie de "
"la liste, les opérateurs d'affectation augmentés, servent de délimiteurs "
"pour l'analyseur lexical mais sont aussi des opérateurs."

#: reference/lexical_analysis.rst:1029
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""
"Les caractères ASCII suivants ont une signification spéciale en tant que "
"partie d'autres lexèmes ou ont une signification particulière pour "
"l'analyseur lexical :"

#: reference/lexical_analysis.rst:1032
msgid "'       \"       #       \\"
msgstr ""

#: reference/lexical_analysis.rst:1036
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""
"Les caractères ASCII suivants ne sont pas utilisés en Python. S'ils "
"apparaissent en dehors de chaines littérales ou de commentaires, ils "
"produisent une erreur :"

#: reference/lexical_analysis.rst:1039
msgid "$       ?       `"
msgstr ""

#: reference/lexical_analysis.rst:1045
msgid "Footnotes"
msgstr "Notes"

#: reference/lexical_analysis.rst:1046
#, fuzzy
msgid "https://www.unicode.org/Public/15.1.0/ucd/NameAliases.txt"
msgstr "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"

#: reference/lexical_analysis.rst:8
#, fuzzy
msgid "lexical analysis"
msgstr "Analyse lexicale"

#: reference/lexical_analysis.rst:8
msgid "parser"
msgstr ""

#: reference/lexical_analysis.rst:8
msgid "token"
msgstr ""

#: reference/lexical_analysis.rst:25
#, fuzzy
msgid "line structure"
msgstr "Structure des lignes"

#: reference/lexical_analysis.rst:35
#, fuzzy
msgid "logical line"
msgstr "Lignes logiques"

#: reference/lexical_analysis.rst:35 reference/lexical_analysis.rst:114
#: reference/lexical_analysis.rst:531
#, fuzzy
msgid "physical line"
msgstr "Lignes physiques"

#: reference/lexical_analysis.rst:35 reference/lexical_analysis.rst:114
#, fuzzy
msgid "line joining"
msgstr "Continuation de ligne explicite"

#: reference/lexical_analysis.rst:35
msgid "NEWLINE token"
msgstr ""

#: reference/lexical_analysis.rst:67
#, fuzzy
msgid "comment"
msgstr "Commentaires"

#: reference/lexical_analysis.rst:67
msgid "hash character"
msgstr ""

#: reference/lexical_analysis.rst:67 reference/lexical_analysis.rst:81
msgid "# (hash)"
msgstr ""

#: reference/lexical_analysis.rst:81
msgid "source character set"
msgstr ""

#: reference/lexical_analysis.rst:81
#, fuzzy
msgid "encoding declarations (source file)"
msgstr "Déclaration d'encodage"

#: reference/lexical_analysis.rst:81
#, fuzzy
msgid "source encoding declaration"
msgstr "Déclaration d'encodage"

#: reference/lexical_analysis.rst:114
#, fuzzy
msgid "line continuation"
msgstr "Indentation"

#: reference/lexical_analysis.rst:114
msgid "backslash character"
msgstr ""

#: reference/lexical_analysis.rst:159
#, fuzzy
msgid "blank line"
msgstr "Lignes vierges"

#: reference/lexical_analysis.rst:174
#, fuzzy
msgid "indentation"
msgstr "Indentation"

#: reference/lexical_analysis.rst:174
msgid "leading whitespace"
msgstr ""

#: reference/lexical_analysis.rst:174
msgid "space"
msgstr ""

#: reference/lexical_analysis.rst:174
msgid "tab"
msgstr ""

#: reference/lexical_analysis.rst:174
msgid "grouping"
msgstr ""

#: reference/lexical_analysis.rst:174
msgid "statement grouping"
msgstr ""

#: reference/lexical_analysis.rst:202
msgid "INDENT token"
msgstr ""

#: reference/lexical_analysis.rst:202
msgid "DEDENT token"
msgstr ""

#: reference/lexical_analysis.rst:277
msgid "identifier"
msgstr ""

#: reference/lexical_analysis.rst:277
msgid "name"
msgstr ""

#: reference/lexical_analysis.rst:333 reference/lexical_analysis.rst:357
#, fuzzy
msgid "keyword"
msgstr "Mots-clés"

#: reference/lexical_analysis.rst:333
msgid "reserved word"
msgstr ""

#: reference/lexical_analysis.rst:357
#, fuzzy
msgid "soft keyword"
msgstr "Mots-clés ad hoc"

#: reference/lexical_analysis.rst:376
msgid "_, identifiers"
msgstr ""

#: reference/lexical_analysis.rst:376
msgid "__, identifiers"
msgstr ""

#: reference/lexical_analysis.rst:432
#, fuzzy
msgid "literal"
msgstr "Littéraux"

#: reference/lexical_analysis.rst:432
msgid "constant"
msgstr ""

#: reference/lexical_analysis.rst:437 reference/lexical_analysis.rst:478
#, fuzzy
msgid "string literal"
msgstr "Chaînes de caractères littérales formatées"

#: reference/lexical_analysis.rst:437 reference/lexical_analysis.rst:491
#, fuzzy
msgid "bytes literal"
msgstr "Entiers littéraux"

#: reference/lexical_analysis.rst:437
msgid "ASCII"
msgstr ""

#: reference/lexical_analysis.rst:437
#, fuzzy
msgid "' (single quote)"
msgstr "guillemet simple (``'``)"

#: reference/lexical_analysis.rst:437
#, fuzzy
msgid "\" (double quote)"
msgstr "guillemet double (``\"``)"

#: reference/lexical_analysis.rst:437
msgid "u'"
msgstr ""

#: reference/lexical_analysis.rst:437
msgid "u\""
msgstr ""

#: reference/lexical_analysis.rst:478
msgid "triple-quoted string"
msgstr ""

#: reference/lexical_analysis.rst:478
msgid "Unicode Consortium"
msgstr ""

#: reference/lexical_analysis.rst:478
msgid "raw string"
msgstr ""

#: reference/lexical_analysis.rst:478
msgid "\"\"\""
msgstr ""

#: reference/lexical_analysis.rst:478
msgid "'''"
msgstr ""

#: reference/lexical_analysis.rst:491
msgid "b'"
msgstr ""

#: reference/lexical_analysis.rst:491
msgid "b\""
msgstr ""

#: reference/lexical_analysis.rst:500
msgid "r'"
msgstr ""

#: reference/lexical_analysis.rst:500
#, fuzzy
msgid "raw string literal"
msgstr "Chaînes de caractères littérales formatées"

#: reference/lexical_analysis.rst:500
msgid "r\""
msgstr ""

#: reference/lexical_analysis.rst:518
msgid "f'"
msgstr ""

#: reference/lexical_analysis.rst:518 reference/lexical_analysis.rst:696
#, fuzzy
msgid "formatted string literal"
msgstr "Chaînes de caractères littérales formatées"

#: reference/lexical_analysis.rst:518
msgid "f\""
msgstr ""

#: reference/lexical_analysis.rst:531
#, fuzzy
msgid "escape sequence"
msgstr "Séquence d'échappement"

#: reference/lexical_analysis.rst:531
msgid "Standard C"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "C"
msgstr ""

#: reference/lexical_analysis.rst:531
#, fuzzy
msgid "\\ (backslash)"
msgstr "barre oblique inversée (``\\``)"

#: reference/lexical_analysis.rst:531
msgid "\\\\"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\a"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\b"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\f"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\n"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\r"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\t"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\v"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\x"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\N"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\u"
msgstr ""

#: reference/lexical_analysis.rst:531
msgid "\\U"
msgstr ""

#: reference/lexical_analysis.rst:647
#, fuzzy
msgid "unrecognized escape sequence"
msgstr "Séquence d'échappement"

#: reference/lexical_analysis.rst:696
#, fuzzy
msgid "interpolated string literal"
msgstr "Chaînes de caractères littérales formatées"

#: reference/lexical_analysis.rst:696
msgid "string"
msgstr ""

#: reference/lexical_analysis.rst:696
#, fuzzy
msgid "formatted literal"
msgstr "Chaînes de caractères littérales formatées"

#: reference/lexical_analysis.rst:696
#, fuzzy
msgid "interpolated literal"
msgstr "Entiers littéraux"

#: reference/lexical_analysis.rst:696
msgid "f-string"
msgstr ""

#: reference/lexical_analysis.rst:696
msgid "fstring"
msgstr ""

#: reference/lexical_analysis.rst:696
msgid "{} (curly brackets)"
msgstr ""

#: reference/lexical_analysis.rst:696
#, fuzzy
msgid "in formatted string literal"
msgstr "Chaînes de caractères littérales formatées"

#: reference/lexical_analysis.rst:696
msgid "! (exclamation)"
msgstr ""

#: reference/lexical_analysis.rst:696
msgid ": (colon)"
msgstr ""

#: reference/lexical_analysis.rst:696
msgid "= (equals)"
msgstr ""

#: reference/lexical_analysis.rst:696
msgid "for help in debugging using string literals"
msgstr ""

#: reference/lexical_analysis.rst:879
msgid "number"
msgstr ""

#: reference/lexical_analysis.rst:879
#, fuzzy
msgid "numeric literal"
msgstr "Littéraux numériques"

#: reference/lexical_analysis.rst:879 reference/lexical_analysis.rst:892
#, fuzzy
msgid "integer literal"
msgstr "Entiers littéraux"

#: reference/lexical_analysis.rst:879
#, fuzzy
msgid "floating-point literal"
msgstr "Nombres à virgule flottante littéraux"

#: reference/lexical_analysis.rst:879
msgid "hexadecimal literal"
msgstr ""

#: reference/lexical_analysis.rst:879
#, fuzzy
msgid "octal literal"
msgstr "Littéraux numériques"

#: reference/lexical_analysis.rst:879
#, fuzzy
msgid "binary literal"
msgstr "Imaginaires littéraux"

#: reference/lexical_analysis.rst:879
#, fuzzy
msgid "decimal literal"
msgstr "Littéraux numériques"

#: reference/lexical_analysis.rst:879
#, fuzzy
msgid "imaginary literal"
msgstr "Imaginaires littéraux"

#: reference/lexical_analysis.rst:879
#, fuzzy
msgid "complex literal"
msgstr "Littéraux numériques"

#: reference/lexical_analysis.rst:892
msgid "0b"
msgstr ""

#: reference/lexical_analysis.rst:892
msgid "0o"
msgstr ""

#: reference/lexical_analysis.rst:892
msgid "0x"
msgstr ""

#: reference/lexical_analysis.rst:892 reference/lexical_analysis.rst:938
msgid "_ (underscore)"
msgstr ""

#: reference/lexical_analysis.rst:892 reference/lexical_analysis.rst:938
#: reference/lexical_analysis.rst:970
#, fuzzy
msgid "in numeric literal"
msgstr "Littéraux numériques"

#: reference/lexical_analysis.rst:938
msgid ". (dot)"
msgstr ""

#: reference/lexical_analysis.rst:938
msgid "e"
msgstr ""

#: reference/lexical_analysis.rst:970
msgid "j"
msgstr ""

#: reference/lexical_analysis.rst:996
#, fuzzy
msgid "operators"
msgstr "Opérateurs"

#: reference/lexical_analysis.rst:1013
#, fuzzy
msgid "delimiters"
msgstr "Délimiteurs"

#~ msgid ""
#~ "Within the ASCII range (U+0001..U+007F), the valid characters for "
#~ "identifiers are the same as in Python 2.x: the uppercase and lowercase "
#~ "letters ``A`` through ``Z``, the underscore ``_`` and, except for the "
#~ "first character, the digits ``0`` through ``9``."
#~ msgstr ""
#~ "Dans l'intervalle ASCII (*U+0001..U+007F*), les caractères licites pour "
#~ "les identifiants sont les mêmes que pour Python 2.x : les lettres "
#~ "minuscules et majuscules de ``A`` à ``Z``, le souligné (ou *underscore*) "
#~ "``_`` et, sauf pour le premier caractère, les chiffres de ``0`` à ``9``."

#~ msgid "``\\ooo``"
#~ msgstr "``\\ooo``"

#~ msgid "``\\xhh``"
#~ msgstr "``\\xhh``"

#~ msgid "``\\N{name}``"
#~ msgstr "``\\N{name}``"

#~ msgid "``\\uxxxx``"
#~ msgstr "``\\uxxxx``"

#~ msgid "Formatted string literals"
#~ msgstr "Chaînes de caractères littérales formatées"

#~ msgid ""
#~ "A consequence of sharing the same syntax as regular string literals is "
#~ "that characters in the replacement fields must not conflict with the "
#~ "quoting used in the outer formatted string literal::"
#~ msgstr ""
#~ "Une conséquence de partager la même syntaxe avec les chaînes littérales "
#~ "normales est que les caractères dans les champs à remplacer ne doivent "
#~ "pas entrer en conflit avec le guillemet utilisé pour encadrer la chaine "
#~ "formatée littérale ::"

#~ msgid ""
#~ "Backslashes are not allowed in format expressions and will raise an "
#~ "error::"
#~ msgstr ""
#~ "La barre oblique inversée (ou antislash) n'est pas autorisée dans les "
#~ "expressions des champs à remplacer et son utilisation génère une erreur ::"

#~ msgid ""
#~ "To include a value in which a backslash escape is required, create a "
#~ "temporary variable."
#~ msgstr ""
#~ "Pour inclure une valeur où l'échappement par barre oblique inversée est "
#~ "nécessaire, vous devez créer une variable temporaire."

#~ msgid "(1,3)"
#~ msgstr "(1,3)"

#~ msgid "(2,3)"
#~ msgstr "(2,3)"

#~ msgid "\\(4)"
#~ msgstr "\\(4)"

#~ msgid ""
#~ "Not imported by ``from module import *``.  The special identifier ``_`` "
#~ "is used in the interactive interpreter to store the result of the last "
#~ "evaluation; it is stored in the :mod:`builtins` module.  When not in "
#~ "interactive mode, ``_`` has no special meaning and is not defined. See "
#~ "section :ref:`import`."
#~ msgstr ""
#~ "L'identifiant spécial ``_`` n'est pas importé par ``from module import "
#~ "*``. Il est utilisé dans l'interpréteur interactif pour stocker le "
#~ "résultat de la dernière évaluation ; il est stocké dans le module :mod:"
#~ "`builtins`. Lorsque vous n'êtes pas en mode interactif, ``_`` n'a pas de "
#~ "signification particulière et n'est pas défini. Voir la section :ref:"
#~ "`import`."
