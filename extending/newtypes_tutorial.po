# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-07-22 15:34+0200\n"
"PO-Revision-Date: 2023-07-27 23:20+0200\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: extending/newtypes_tutorial.rst:7
msgid "Defining Extension Types: Tutorial"
msgstr "Tutoriel : définir des types dans des extensions"

#: extending/newtypes_tutorial.rst:14
msgid ""
"Python allows the writer of a C extension module to define new types that "
"can be manipulated from Python code, much like the built-in :class:`str` "
"and :class:`list` types.  The code for all extension types follows a "
"pattern, but there are some details that you need to understand before you "
"can get started.  This document is a gentle introduction to the topic."
msgstr ""
"Python permet à l'auteur d'un module d'extension C de définir de nouveaux "
"types qui peuvent être manipulés depuis du code Python, à la manière des "
"types natifs :class:`str` et :class:`list`. Les implémentations de tous les "
"types d'extension ont des similarités, mais quelques subtilités doivent être "
"abordées avant de commencer."

#: extending/newtypes_tutorial.rst:24
msgid "The Basics"
msgstr "Les bases"

#: extending/newtypes_tutorial.rst:26
msgid ""
"The :term:`CPython` runtime sees all Python objects as variables of type :c:"
"expr:`PyObject*`, which serves as a \"base type\" for all Python objects. "
"The :c:type:`PyObject` structure itself only contains the object's :term:"
"`reference count` and a pointer to the object's \"type object\". This is "
"where the action is; the type object determines which (C) functions get "
"called by the interpreter when, for instance, an attribute gets looked up on "
"an object, a method called, or it is multiplied by another object.  These C "
"functions are called \"type methods\"."
msgstr ""
":term:`CPython` considère que tous les objets Python sont des variables de "
"type :c:expr:`PyObject*`, qui sert de type de base pour tous les objets "
"Python. La structure de :c:type:`PyObject` ne contient que le :term:"
"`compteur de références <reference count>` et un pointeur vers un objet de "
"type « type de l'objet ». C'est ici que tout se joue : l'objet type "
"détermine quelle fonction C doit être appelée par l'interpréteur quand, par "
"exemple, un attribut est recherché sur un objet, quand une méthode est "
"appelée, ou quand l'objet est multiplié par un autre objet. Ces fonctions C "
"sont appelées des « méthodes de type »."

#: extending/newtypes_tutorial.rst:35
msgid ""
"So, if you want to define a new extension type, you need to create a new "
"type object."
msgstr ""
"Donc, pour définir un nouveau type dans une extension, vous devez créer un "
"nouvel objet type."

#: extending/newtypes_tutorial.rst:38
msgid ""
"This sort of thing can only be explained by example, so here's a minimal, "
"but complete, module that defines a new type named :class:`Custom` inside a "
"C extension module :mod:`custom`:"
msgstr ""
"Ce genre de chose ne s'explique correctement qu'avec des exemples, voici "
"donc un module minimaliste mais suffisant qui définit un nouveau type nommé :"
"class:`Custom` dans le module d'extension :mod:`custom` :"

# suit un :
#: extending/newtypes_tutorial.rst:43
msgid ""
"What we're showing here is the traditional way of defining *static* "
"extension types.  It should be adequate for most uses.  The C API also "
"allows defining heap-allocated extension types using the :c:func:"
"`PyType_FromSpec` function, which isn't covered in this tutorial."
msgstr ""
"ce qui est montré ici est la manière traditionnelle de définir des types "
"d'extension *statiques*, et cela convient dans la majorité des cas. L'API C "
"permet aussi de définir des types alloués sur le tas, via la fonction :c:"
"func:`PyType_FromSpec`, mais ce n'est pas couvert par ce tutoriel."

#: extending/newtypes_tutorial.rst:50
msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the previous chapter.  This file defines three things:"
msgstr ""
"C'est un peu long, mais vous devez déjà reconnaître quelques morceaux "
"expliqués au chapitre précédent. Ce fichier définit trois choses :"

#: extending/newtypes_tutorial.rst:53
msgid ""
"What a :class:`Custom` **object** contains: this is the ``CustomObject`` "
"struct, which is allocated once for each :class:`Custom` instance."
msgstr ""
"Ce qu'un **objet** :class:`Custom` contient : c'est la structure "
"``CustomObject``, qui est allouée une fois pour chaque instance de :class:"
"`Custom`."

#: extending/newtypes_tutorial.rst:55
msgid ""
"How the :class:`Custom` **type** behaves: this is the ``CustomType`` struct, "
"which defines a set of flags and function pointers that the interpreter "
"inspects when specific operations are requested."
msgstr ""
"Comment le **type** :class:`Custom` se comporte : c'est la structure "
"``CustomType``, qui définit l'ensemble des options et pointeurs de fonction "
"utilisés par l'interpréteur."

#: extending/newtypes_tutorial.rst:58
msgid ""
"How to initialize the :mod:`custom` module: this is the ``PyInit_custom`` "
"function and the associated ``custommodule`` struct."
msgstr ""
"Comment initialiser le module :mod:`custom` : c'est la fonction "
"``PyInit_custom`` et la structure associée ``custommodule``."

#: extending/newtypes_tutorial.rst:61
msgid "The first bit is::"
msgstr "Commençons par ::"

#: extending/newtypes_tutorial.rst:67
msgid ""
"This is what a Custom object will contain.  ``PyObject_HEAD`` is mandatory "
"at the start of each object struct and defines a field called ``ob_base`` of "
"type :c:type:`PyObject`, containing a pointer to a type object and a "
"reference count (these can be accessed using the macros :c:macro:`Py_TYPE` "
"and :c:macro:`Py_REFCNT` respectively).  The reason for the macro is to "
"abstract away the layout and to enable additional fields in :ref:`debug "
"builds <debug-build>`."
msgstr ""
"C'est ce qu'un objet ``Custom`` contient. ``PyObject_HEAD`` est "
"obligatoirement au début de chaque structure d'objet et définit un champ "
"appelé ``ob_base`` de type :c:type:`PyObject`, contenant un pointeur vers un "
"objet type et un compteur de références (on peut y accéder en utilisant les "
"macros :c:macro:`Py_TYPE` et :c:macro:`Py_REFCNT`, respectivement). La "
"raison d'être de ces macros est d'abstraire l'agencement de la structure, et "
"ainsi de permettre l'ajout de champs en :ref:`mode débogage <debug-build>`."

# suit un :
#: extending/newtypes_tutorial.rst:76
msgid ""
"There is no semicolon above after the :c:macro:`PyObject_HEAD` macro. Be "
"wary of adding one by accident: some compilers will complain."
msgstr ""
"il n'y a pas de point-virgule après la macro :c:macro:`PyObject_HEAD`. "
"Attention à ne pas l'ajouter par accident : certains compilateurs pourraient "
"s'en plaindre."

#: extending/newtypes_tutorial.rst:79
msgid ""
"Of course, objects generally store additional data besides the standard "
"``PyObject_HEAD`` boilerplate; for example, here is the definition for "
"standard Python floats::"
msgstr ""
"Bien sûr, les objets ajoutent généralement des données supplémentaires après "
"l'entête standard ``PyObject_HEAD``. Par exemple voici la définition du type "
"standard Python ``float`` ::"

#: extending/newtypes_tutorial.rst:88
msgid "The second bit is the definition of the type object. ::"
msgstr "La deuxième partie est la définition de l'objet type ::"

# suit un :
#: extending/newtypes_tutorial.rst:101
msgid ""
"We recommend using C99-style designated initializers as above, to avoid "
"listing all the :c:type:`PyTypeObject` fields that you don't care about and "
"also to avoid caring about the fields' declaration order."
msgstr ""
"nous recommandons d'utiliser la syntaxe d'initialisation nommée (C99) pour "
"remplir la structure, comme ci-dessus, afin d'éviter d'avoir à lister les "
"champs de :c:type:`PyTypeObject` dont vous n'avez pas besoin, et de ne pas "
"vous soucier de leur ordre."

#: extending/newtypes_tutorial.rst:105
msgid ""
"The actual definition of :c:type:`PyTypeObject` in :file:`object.h` has many "
"more :ref:`fields <type-structs>` than the definition above.  The remaining "
"fields will be filled with zeros by the C compiler, and it's common practice "
"to not specify them explicitly unless you need them."
msgstr ""
"La définition de :c:type:`PyTypeObject` dans :file:`object.h` contient en "
"fait bien plus de :ref:`champs <type-structs>` que la définition ci-dessus. "
"Les champs restants sont mis à zéro par le compilateur C, et c'est une "
"pratique répandue de ne pas spécifier les champs dont vous n'avez pas besoin."

#: extending/newtypes_tutorial.rst:110
msgid "We're going to pick it apart, one field at a time::"
msgstr "Regardons les champs de cette structure, un par un ::"

#: extending/newtypes_tutorial.rst:114
msgid ""
"This line is mandatory boilerplate to initialize the ``ob_base`` field "
"mentioned above. ::"
msgstr ""
"Cette ligne, obligatoire, initialise le champ ``ob_base`` mentionné "
"précédemment. ::"

#: extending/newtypes_tutorial.rst:119
msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example:"
msgstr ""
"C'est le nom de notre type. Il apparaît dans la représentation textuelle par "
"défaut de nos objets, ainsi que dans quelques messages d'erreur, par "
"exemple :"

#: extending/newtypes_tutorial.rst:129
msgid ""
"Note that the name is a dotted name that includes both the module name and "
"the name of the type within the module. The module in this case is :mod:"
"`custom` and the type is :class:`Custom`, so we set the type name to :class:"
"`custom.Custom`. Using the real dotted import path is important to make your "
"type compatible with the :mod:`pydoc` and :mod:`pickle` modules. ::"
msgstr ""
"Notez que le nom comporte un point : il inclut le nom du module et le nom du "
"type. Dans ce cas le module  est :mod:`custom` et le type est :class:"
"`Custom`, donc nous donnons comme nom :class:`custom.Custom`. Nommer "
"correctement son type, avec le point, est important pour le rendre "
"compatible avec :mod:`pydoc` et :mod:`pickle`. ::"

#: extending/newtypes_tutorial.rst:138
msgid ""
"This is so that Python knows how much memory to allocate when creating new :"
"class:`Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is only "
"used for variable-sized objects and should otherwise be zero."
msgstr ""
"C'est pour que Python sache combien de mémoire allouer à la création d'une "
"nouvelle instance de :class:`Custom`. :c:member:`~PyTypeObject.tp_itemsize` "
"n'est utilisé que pour les objets de taille variable, sinon il doit rester à "
"zéro."

# suit un :
#: extending/newtypes_tutorial.rst:144
msgid ""
"If you want your type to be subclassable from Python, and your type has the "
"same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have "
"problems with multiple inheritance.  A Python subclass of your type will "
"have to list your type first in its :attr:`~class.__bases__`, or else it "
"will not be able to call your type's :meth:`__new__` method without getting "
"an error.  You can avoid this problem by ensuring that your type has a "
"larger value for :c:member:`~PyTypeObject.tp_basicsize` than its base type "
"does.  Most of the time, this will be true anyway, because either your base "
"type will be :class:`object`, or else you will be adding data members to "
"your base type, and therefore increasing its size."
msgstr ""
"si vous voulez qu'une classe en Python puisse hériter de votre type, et que "
"votre type a le même :c:member:`~PyTypeObject.tp_basicsize` que son parent, "
"vous rencontrerez des problèmes avec l'héritage multiple. Une sous-classe "
"Python de votre type devra lister votre type en premier dans son :attr:"
"`~class.__bases__`, sans quoi elle ne sera pas capable d'appeler la méthode :"
"meth:`__new__` de votre type sans erreur. Vous pouvez éviter ce problème en "
"vous assurant que votre type a un :c:member:`~PyTypeObject.tp_basicsize` "
"plus grand que son parent. La plupart du temps ce sera vrai (soit son parent "
"sera :class:`object`, soit vous ajouterez des attributs à votre type, "
"augmentant ainsi sa taille)."

#: extending/newtypes_tutorial.rst:154
msgid "We set the class flags to :c:macro:`Py_TPFLAGS_DEFAULT`. ::"
msgstr ""
"Nous définissons les drapeaux de la classe à :c:macro:`Py_TPFLAGS_DEFAULT` ::"

#: extending/newtypes_tutorial.rst:158
msgid ""
"All types should include this constant in their flags.  It enables all of "
"the members defined until at least Python 3.3.  If you need further members, "
"you will need to OR the corresponding flags."
msgstr ""
"Chaque type doit inclure cette constante dans ses options : elle active tous "
"les membres définis jusqu'à au moins Python 3.3. Si vous avez besoin de plus "
"de membres, vous pouvez la combiner à d'autres constantes avec un *OU* "
"binaire."

#: extending/newtypes_tutorial.rst:162
msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::"
msgstr ""
"Nous fournissons une *docstring* pour ce type via le membre :c:member:"
"`~PyTypeObject.tp_doc`. ::"

#: extending/newtypes_tutorial.rst:166
msgid ""
"To enable object creation, we have to provide a :c:member:`~PyTypeObject."
"tp_new` handler.  This is the equivalent of the Python method :meth:"
"`__new__`, but has to be specified explicitly.  In this case, we can just "
"use the default implementation provided by the API function :c:func:"
"`PyType_GenericNew`. ::"
msgstr ""
"Pour permettre la création d'une instance, nous devons fournir un *handler* :"
"c:member:`~PyTypeObject.tp_new`, qui est l'équivalent de la méthode Python :"
"meth:`__new__`, mais elle a besoin d'être spécifiée explicitement. Dans ce "
"cas, on se contente de l'implémentation par défaut fournie par la fonction :"
"c:func:`PyType_GenericNew` de l'API. ::"

#: extending/newtypes_tutorial.rst:173
msgid ""
"Everything else in the file should be familiar, except for some code in :c:"
"func:`PyInit_custom`::"
msgstr ""
"Le reste du fichier doit vous être familier, en dehors du code de :c:func:"
"`PyInit_custom` ::"

#: extending/newtypes_tutorial.rst:179
msgid ""
"This initializes the :class:`Custom` type, filling in a number of members to "
"the appropriate default values, including :attr:`ob_type` that we initially "
"set to ``NULL``. ::"
msgstr ""
"Il initialise le type :class:`Custom`, en assignant quelques membres à leurs "
"valeurs par défaut, tel que :attr:`ob_type` qui valait initialement "
"``NULL``. ::"

#: extending/newtypes_tutorial.rst:190
msgid ""
"This adds the type to the module dictionary.  This allows us to create :"
"class:`Custom` instances by calling the :class:`Custom` class:"
msgstr ""
"Ici on ajoute le type au dictionnaire du module. Cela permet de créer une "
"instance de :class:`Custom` en appelant la classe :class:`Custom` :"

#: extending/newtypes_tutorial.rst:198
msgid ""
"That's it!  All that remains is to build it; put the above code in a file "
"called :file:`custom.c` and:"
msgstr ""
"C'est tout ! Il ne reste plus qu'à compiler, placez le code ci-dessus dans "
"un fichier :file:`custom.c` et :"

#: extending/newtypes_tutorial.rst:207
msgid "in a file called :file:`setup.py`; then typing"
msgstr "dans un fichier appelé :file:`setup.py` ; puis en tapant"

#: extending/newtypes_tutorial.rst:213
msgid ""
"at a shell should produce a file :file:`custom.so` in a subdirectory; move "
"to that directory and fire up Python --- you should be able to ``import "
"custom`` and play around with Custom objects."
msgstr ""
"à un shell doit produire un fichier :file:`custom.so` dans un sous-"
"répertoire ; déplacez-vous dans ce répertoire et lancez Python — vous "
"devriez pouvoir faire ``import custom`` et jouer avec des objets "
"personnalisés."

#: extending/newtypes_tutorial.rst:217
msgid "That wasn't so hard, was it?"
msgstr "Ce n'était pas si difficile, n'est-ce pas ?"

#: extending/newtypes_tutorial.rst:219
msgid ""
"Of course, the current Custom type is pretty uninteresting. It has no data "
"and doesn't do anything. It can't even be subclassed."
msgstr ""
"Bien sûr, le type personnalisé actuel est assez inintéressant. Il n'a pas de "
"données et ne fait rien. Il ne peut même pas être sous-classé."

#: extending/newtypes_tutorial.rst:223
msgid ""
"While this documentation showcases the standard :mod:`distutils` module for "
"building C extensions, it is recommended in real-world use cases to use the "
"newer and better-maintained ``setuptools`` library.  Documentation on how to "
"do this is out of scope for this document and can be found in the `Python "
"Packaging User's Guide <https://packaging.python.org/tutorials/distributing-"
"packages/>`_."
msgstr ""
"Bien que cette documentation présente le module standard :mod:`distutils` "
"pour la construction d'extensions C, il est recommandé dans les cas "
"d'utilisation réels d'utiliser la bibliothèque ``setuptools`` plus récente "
"et mieux entretenue. La documentation sur la façon de procéder est hors de "
"portée de ce document et peut être trouvée dans le `Python Packaging User's "
"Guide <https://packaging.python.org/tutorials/distributing-packages/>`_."

# suit un :
#: extending/newtypes_tutorial.rst:231
msgid "Adding data and methods to the Basic example"
msgstr "ajout de données et de méthodes à l'exemple basique"

#: extending/newtypes_tutorial.rst:233
msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, :mod:"
"`custom2` that adds these capabilities:"
msgstr ""
"Étendons l'exemple de base pour ajouter des données et des méthodes. Rendons "
"également le type utilisable comme classe de base. Nous allons créer un "
"nouveau module, :mod:`custom2` qui ajoute ces fonctionnalités :"

#: extending/newtypes_tutorial.rst:240
msgid "This version of the module has a number of changes."
msgstr "Cette version du module comporte un certain nombre de modifications."

#: extending/newtypes_tutorial.rst:242
msgid "We've added an extra include::"
msgstr "Nous avons ajouté un nouvel *include* ::"

#: extending/newtypes_tutorial.rst:246
msgid ""
"This include provides declarations that we use to handle attributes, as "
"described a bit later."
msgstr ""
"Cet *include* fournit des déclarations que nous utilisons pour gérer les "
"attributs, comme décrit un peu plus loin."

#: extending/newtypes_tutorial.rst:249
msgid ""
"The  :class:`Custom` type now has three data attributes in its C struct, "
"*first*, *last*, and *number*.  The *first* and *last* variables are Python "
"strings containing first and last names.  The *number* attribute is a C "
"integer."
msgstr ""
"Le type :class:`Custom` a maintenant trois attributs de données dans sa "
"structure C, *first*, *last* et *number*. Les variables *first* et *last* "
"sont des chaînes Python contenant les noms et prénoms. L'attribut *number* "
"est un entier C."

#: extending/newtypes_tutorial.rst:253
msgid "The object structure is updated accordingly::"
msgstr "La structure de l'objet est mise à jour en conséquence ::"

#: extending/newtypes_tutorial.rst:262
msgid ""
"Because we now have data to manage, we have to be more careful about object "
"allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr ""
"Comme nous avons maintenant des données à gérer, nous devons faire plus "
"attention à l'allocation et à la libération d'objets. Au minimum, nous avons "
"besoin d'une méthode de dés-allocation ::"

#: extending/newtypes_tutorial.rst:273
msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr "qui est assignée au membre :c:member:`~PyTypeObject.tp_dealloc` ::"

#: extending/newtypes_tutorial.rst:277
msgid ""
"This method first clears the reference counts of the two Python attributes. :"
"c:func:`Py_XDECREF` correctly handles the case where its argument is "
"``NULL`` (which might happen here if ``tp_new`` failed midway).  It then "
"calls the :c:member:`~PyTypeObject.tp_free` member of the object's type "
"(computed by ``Py_TYPE(self)``) to free the object's memory.  Note that the "
"object's type might not be :class:`CustomType`, because the object may be an "
"instance of a subclass."
msgstr ""
"Cette méthode efface d'abord le nombre de références des deux attributs "
"Python. :c:func:`Py_XDECREF` gère correctement le cas où son argument est "
"``NULL`` (ce qui peut arriver ici si ``tp_new`` échoue à mi-chemin). Elle "
"appelle ensuite le membre :c:member:`~PyTypeObject.tp_free` du type de "
"l'objet (calculé par ``Py_TYPE(self)``) pour libérer la mémoire de l'objet. "
"Notez que le type de l'objet peut ne pas être :class:`CustomType`, car "
"l'objet peut être une instance d'une sous-classe."

#: extending/newtypes_tutorial.rst:286
msgid ""
"The explicit cast to ``destructor`` above is needed because we defined "
"``Custom_dealloc`` to take a ``CustomObject *`` argument, but the "
"``tp_dealloc`` function pointer expects to receive a ``PyObject *`` "
"argument.  Otherwise, the compiler will emit a warning.  This is object-"
"oriented polymorphism, in C!"
msgstr ""
"La conversion explicite en ``destructor`` ci-dessus est nécessaire car nous "
"avons défini ``Custom_dealloc`` pour prendre un argument ``CustomObject *``, "
"mais le pointeur de fonction ``tp_dealloc`` s'attend à recevoir un argument "
"``PyObject *``. Sinon, le compilateur émet un avertissement. C'est du "
"polymorphisme orienté objet, en C !"

#: extending/newtypes_tutorial.rst:292
msgid ""
"We want to make sure that the first and last names are initialized to empty "
"strings, so we provide a ``tp_new`` implementation::"
msgstr ""
"Nous voulons nous assurer que le prénom et le nom sont initialisés avec des "
"chaînes vides, nous fournissons donc une implémentation ``tp_new`` ::"

#: extending/newtypes_tutorial.rst:316
msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr "et installez-le dans le membre :c:member:`~PyTypeObject.tp_new` ::"

#: extending/newtypes_tutorial.rst:320
msgid ""
"The ``tp_new`` handler is responsible for creating (as opposed to "
"initializing) objects of the type.  It is exposed in Python as the :meth:"
"`__new__` method. It is not required to define a ``tp_new`` member, and "
"indeed many extension types will simply reuse :c:func:`PyType_GenericNew` as "
"done in the first version of the ``Custom`` type above.  In this case, we "
"use the ``tp_new`` handler to initialize the ``first`` and ``last`` "
"attributes to non-``NULL`` default values."
msgstr ""
"Le gestionnaire ``tp_new`` est responsable de la création (par opposition à "
"l'initialisation) des objets du type. Il est exposé en Python en tant que "
"méthode :meth:`__new__`. Il n'est pas nécessaire de définir un membre "
"``tp_new``, et en effet de nombreux types d'extension réutiliseront "
"simplement :c:func:`PyType_GenericNew` comme cela a été fait dans la "
"première version du type ``Custom`` ci-dessus. Dans ce cas, nous utilisons "
"le gestionnaire ``tp_new`` pour initialiser les attributs ``first`` et "
"``last`` à des valeurs par défaut non ``NULL``."

#: extending/newtypes_tutorial.rst:328
msgid ""
"``tp_new`` is passed the type being instantiated (not necessarily "
"``CustomType``, if a subclass is instantiated) and any arguments passed when "
"the type was called, and is expected to return the instance created.  "
"``tp_new`` handlers always accept positional and keyword arguments, but they "
"often ignore the arguments, leaving the argument handling to initializer (a."
"k.a. ``tp_init`` in C or ``__init__`` in Python) methods."
msgstr ""
"``tp_new`` reçoit le type en cours d'instanciation (pas nécessairement "
"``CustomType``, si une sous-classe est instanciée) et tous les arguments "
"passés lorsque le type a été appelé, et devrait renvoyer l'instance créée. "
"Les gestionnaires ``tp_new`` acceptent toujours les arguments positionnels "
"et nommés, mais ils ignorent souvent les arguments, laissant la gestion des "
"arguments aux méthodes d'initialisation (alias ``tp_init`` en C ou "
"``__init__`` en Python)."

#: extending/newtypes_tutorial.rst:336
msgid ""
"``tp_new`` shouldn't call ``tp_init`` explicitly, as the interpreter will do "
"it itself."
msgstr ""
"``tp_new`` ne doit pas appeler ``tp_init`` explicitement, car l'interpréteur "
"le fera lui-même."

#: extending/newtypes_tutorial.rst:339
msgid ""
"The ``tp_new`` implementation calls the :c:member:`~PyTypeObject.tp_alloc` "
"slot to allocate memory::"
msgstr ""
"L'implémentation ``tp_new`` appelle l'emplacement :c:member:`~PyTypeObject."
"tp_alloc` pour allouer de la mémoire ::"

#: extending/newtypes_tutorial.rst:344
msgid ""
"Since memory allocation may fail, we must check the :c:member:`~PyTypeObject."
"tp_alloc` result against ``NULL`` before proceeding."
msgstr ""
"Puisque l'allocation de mémoire peut échouer, nous devons vérifier le "
"résultat :c:member:`~PyTypeObject.tp_alloc` par rapport à ``NULL`` avant de "
"continuer."

#: extending/newtypes_tutorial.rst:348
msgid ""
"We didn't fill the :c:member:`~PyTypeObject.tp_alloc` slot ourselves. "
"Rather :c:func:`PyType_Ready` fills it for us by inheriting it from our base "
"class, which is :class:`object` by default.  Most types use the default "
"allocation strategy."
msgstr ""
"Nous n'avons pas rempli l'emplacement :c:member:`~PyTypeObject.tp_alloc` "
"nous-mêmes. C'est :c:func:`PyType_Ready` qui le remplit pour nous car il en "
"hérite de notre classe mère, qui est :class:`object` par défaut. La plupart "
"des types utilisent la stratégie d'allocation par défaut."

#: extending/newtypes_tutorial.rst:354
msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:"
"`__new__`), you must *not* try to determine what method to call using method "
"resolution order at runtime.  Always statically determine what type you are "
"going to call, and call its :c:member:`~PyTypeObject.tp_new` directly, or "
"via ``type->tp_base->tp_new``.  If you do not do this, Python subclasses of "
"your type that also inherit from other Python-defined classes may not work "
"correctly. (Specifically, you may not be able to create instances of such "
"subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"Si vous créez une :c:member:`~PyTypeObject.tp_new` coopérative (qui appelle :"
"c:member:`~PyTypeObject.tp_new` ou :meth:`__new__` d'un type de base), vous "
"ne devez *pas* essayer de déterminer quelle méthode appeler en utilisant "
"l'ordre de résolution des méthodes au moment de l'exécution. Déterminez "
"toujours statiquement quel type vous allez appeler, et appelez son :c:member:"
"`~PyTypeObject.tp_new` directement, ou via ``type->tp_base->tp_new``. Si "
"vous ne le faites pas, les sous-classes Python de votre type qui héritent "
"également d'autres classes définies par Python risquent de ne pas "
"fonctionner correctement. (Plus précisément, vous ne pourrez peut-être pas "
"créer d'instances de telles sous-classes sans obtenir une :exc:`TypeError`.)"

#: extending/newtypes_tutorial.rst:364
msgid ""
"We also define an initialization function which accepts arguments to provide "
"initial values for our instance::"
msgstr ""
"Nous définissons également une fonction d'initialisation qui accepte des "
"arguments pour fournir des valeurs initiales pour notre instance ::"

#: extending/newtypes_tutorial.rst:393
msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "en remplissant l'emplacement :c:member:`~PyTypeObject.tp_init`. ::"

#: extending/newtypes_tutorial.rst:397
msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the :meth:"
"`__init__` method.  It is used to initialize an object after it's created.  "
"Initializers always accept positional and keyword arguments, and they should "
"return either ``0`` on success or ``-1`` on error."
msgstr ""
"L'emplacement :c:member:`~PyTypeObject.tp_init` est exposé en Python en tant "
"que méthode :meth:`__init__`. Il est utilisé pour initialiser un objet après "
"sa création. Les constructeurs acceptent toujours les arguments positionnels "
"et nommés, et ils doivent renvoyer soit ``0`` en cas de succès, soit ``-1`` "
"en cas d'erreur."

#: extending/newtypes_tutorial.rst:402
msgid ""
"Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init`` is "
"called at all (for example, the :mod:`pickle` module by default doesn't "
"call :meth:`__init__` on unpickled instances).  It can also be called "
"multiple times.  Anyone can call the :meth:`__init__` method on our "
"objects.  For this reason, we have to be extra careful when assigning the "
"new attribute values.  We might be tempted, for example to assign the "
"``first`` member like this::"
msgstr ""
"Contrairement au gestionnaire ``tp_new``, il n'y a aucune garantie que "
"``tp_init`` soit appelé (par exemple, le module :mod:`pickle` par défaut "
"n'appelle pas :meth:`__init__` sur les instances *unpickled*). Il peut "
"également être appelé plusieurs fois. N'importe qui peut appeler la méthode :"
"meth:`__init__` sur nos objets. Pour cette raison, nous devons être très "
"prudents lors de l'attribution des nouvelles valeurs d'attribut. On pourrait "
"être tenté, par exemple, d'affecter le membre ``first`` comme ceci ::"

#: extending/newtypes_tutorial.rst:416
msgid ""
"But this would be risky.  Our type doesn't restrict the type of the "
"``first`` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the "
"``first`` member; or that destructor could release the :term:`Global "
"interpreter Lock <GIL>` and let arbitrary code run in other threads that "
"accesses and modifies our object."
msgstr ""
"Mais ce serait risqué. Notre type ne limite pas le type du membre ``first``, "
"il peut donc s'agir de n'importe quel type d'objet. Il pourrait avoir un "
"destructeur qui provoque l'exécution de code essayant d'accéder au membre "
"``first`` ; ou ce destructeur pourrait libérer le :term:`Global interpreter "
"Lock <GIL>` et laisser du code arbitraire s'exécuter dans d'autres threads "
"qui accèdent et modifient notre objet."

#: extending/newtypes_tutorial.rst:423
msgid ""
"To be paranoid and protect ourselves against this possibility, we almost "
"always reassign members before decrementing their reference counts.  When "
"don't we have to do this?"
msgstr ""
"Dans une optique paranoïaque et se prémunir contre cette éventualité, on "
"réaffecte presque toujours les membres avant de décrémenter leur compteur de "
"références. Quand ne devons-nous pas faire cela ?"

#: extending/newtypes_tutorial.rst:427
msgid "when we absolutely know that the reference count is greater than 1;"
msgstr "lorsque l'on est sûr que le compteur de références est supérieur à 1 ;"

#: extending/newtypes_tutorial.rst:429
msgid ""
"when we know that deallocation of the object [#]_ will neither release the :"
"term:`GIL` nor cause any calls back into our type's code;"
msgstr ""
"lorsque nous savons que la libération de la mémoire de l'objet [#]_ ne "
"libérera pas le :term:`GIL` ni ne provoquera de rappel dans le code de notre "
"type ;"

#: extending/newtypes_tutorial.rst:432
msgid ""
"when decrementing a reference count in a :c:member:`~PyTypeObject."
"tp_dealloc` handler on a type which doesn't support cyclic garbage "
"collection [#]_."
msgstr ""
"lors de la décrémentation d'un compteur de références dans un gestionnaire :"
"c:member:`~PyTypeObject.tp_dealloc` sur un type qui ne prend pas en charge "
"le ramasse-miettes cyclique [#]_."

#: extending/newtypes_tutorial.rst:435
msgid ""
"We want to expose our instance variables as attributes. There are a number "
"of ways to do that. The simplest way is to define member definitions::"
msgstr ""
"Nous voulons exposer nos variables d'instance en tant qu'attributs. Il "
"existe plusieurs façons de le faire. Le moyen le plus simple consiste à "
"définir des définitions de membres ::"

#: extending/newtypes_tutorial.rst:448
msgid ""
"and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr ""
"et placer les définitions dans l'emplacement :c:member:`~PyTypeObject."
"tp_members` ::"

#: extending/newtypes_tutorial.rst:452
msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string.  See the :ref:`Generic-Attribute-Management` section "
"below for details."
msgstr ""
"Chaque définition de membre possède un nom, un type, un décalage, des "
"indicateurs d'accès et une chaîne de documentation. Voir la section :ref:"
"`Generic-Attribute-Management` ci-dessous pour plus de détails."

#: extending/newtypes_tutorial.rst:456
msgid ""
"A disadvantage of this approach is that it doesn't provide a way to restrict "
"the types of objects that can be assigned to the Python attributes.  We "
"expect the first and last names to be strings, but any Python objects can be "
"assigned. Further, the attributes can be deleted, setting the C pointers to "
"``NULL``.  Even though we can make sure the members are initialized to non-"
"``NULL`` values, the members can be set to ``NULL`` if the attributes are "
"deleted."
msgstr ""
"Un inconvénient de cette approche est qu'elle ne permet pas de restreindre "
"les types d'objets pouvant être affectés aux attributs Python. Nous nous "
"attendons à ce que le prénom et le nom soient des chaînes, mais tous les "
"objets Python peuvent être affectés. De plus, les attributs peuvent être "
"supprimés, en définissant les pointeurs C sur ``NULL``. Même si nous pouvons "
"nous assurer que les membres sont initialisés avec des valeurs non ``NULL``, "
"les membres peuvent être définis sur ``NULL`` si les attributs sont "
"supprimés."

#: extending/newtypes_tutorial.rst:463
msgid ""
"We define a single method, :meth:`Custom.name()`, that outputs the objects "
"name as the concatenation of the first and last names. ::"
msgstr ""
"Nous définissons une seule méthode, :meth:`Custom.name()`, qui génère le nom "
"des objets sous la forme de la concaténation des prénom et nom. ::"

#: extending/newtypes_tutorial.rst:480
msgid ""
"The method is implemented as a C function that takes a :class:`Custom` (or :"
"class:`Custom` subclass) instance as the first argument.  Methods always "
"take an instance as the first argument. Methods often take positional and "
"keyword arguments as well, but in this case we don't take any and don't need "
"to accept a positional argument tuple or keyword argument dictionary. This "
"method is equivalent to the Python method:"
msgstr ""
"La méthode est implémentée comme une fonction C qui prend une instance :"
"class:`Custom` (ou une sous-classe de :class:`Custom`) comme premier "
"argument. Les méthodes prennent toujours une instance comme premier "
"argument. Les méthodes prennent souvent aussi des arguments positionnels et "
"nommés, mais dans ce cas nous n'en prenons aucun et n'avons pas besoin "
"d'accepter un *n*-uplet d'arguments positionnels ou un dictionnaire en "
"argument nommé. Cette méthode est équivalente à la méthode Python :"

#: extending/newtypes_tutorial.rst:492
msgid ""
"Note that we have to check for the possibility that our :attr:`first` and :"
"attr:`last` members are ``NULL``.  This is because they can be deleted, in "
"which case they are set to ``NULL``.  It would be better to prevent deletion "
"of these attributes and to restrict the attribute values to be strings.  "
"We'll see how to do that in the next section."
msgstr ""
"Notez que nous devons vérifier la possibilité que nos membres :attr:`first` "
"et :attr:`last` soient ``NULL``. En effet, ils peuvent être supprimés, "
"auquel cas ils sont définis sur ``NULL``. Il serait préférable d'empêcher la "
"suppression de ces attributs et de limiter les valeurs d'attribut à des "
"chaînes. Nous verrons comment procéder dans la section suivante."

#: extending/newtypes_tutorial.rst:498
msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr ""
"Maintenant que nous avons défini la méthode, nous devons créer un tableau de "
"définitions de méthode ::"

#: extending/newtypes_tutorial.rst:508
msgid ""
"(note that we used the :c:macro:`METH_NOARGS` flag to indicate that the "
"method is expecting no arguments other than *self*)"
msgstr ""
"(notez que nous avons utilisé le drapeau :c:macro:`METH_NOARGS` pour "
"indiquer que la méthode n'attend aucun argument autre que *self*)"

#: extending/newtypes_tutorial.rst:511
msgid "and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr ""
"et assignons-le à l'emplacement :c:member:`~PyTypeObject.tp_methods` ::"

#: extending/newtypes_tutorial.rst:515
msgid ""
"Finally, we'll make our type usable as a base class for subclassing.  We've "
"written our methods carefully so far so that they don't make any assumptions "
"about the type of the object being created or used, so all we need to do is "
"to add the :c:macro:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr ""
"Enfin, nous rendons notre type utilisable comme classe de base pour le sous-"
"classement. Nous avons écrit nos méthodes avec soin jusqu'à présent afin "
"qu'elles ne fassent aucune hypothèse sur le type de l'objet créé ou utilisé, "
"donc tout ce que nous avons à faire est d'ajouter la macro :c:macro:"
"`Py_TPFLAGS_BASETYPE` à notre définition d'indicateur de classe ::"

#: extending/newtypes_tutorial.rst:522
msgid ""
"We rename :c:func:`PyInit_custom` to :c:func:`PyInit_custom2`, update the "
"module name in the :c:type:`PyModuleDef` struct, and update the full class "
"name in the :c:type:`PyTypeObject` struct."
msgstr ""
"Nous renommons :c:func:`PyInit_custom` en :c:func:`PyInit_custom2`, mettons "
"à jour le nom du module dans la structure :c:type:`PyModuleDef` et mettons à "
"jour le nom complet de la classe dans la structure :c:type:`PyTypeObject`."

#: extending/newtypes_tutorial.rst:526
msgid "Finally, we update our :file:`setup.py` file to build the new module:"
msgstr ""
"Enfin, nous mettons à jour notre fichier :file:`setup.py` pour construire le "
"nouveau module :"

#: extending/newtypes_tutorial.rst:539
msgid "Providing finer control over data attributes"
msgstr "Contrôle précis sur les attributs de données"

#: extending/newtypes_tutorial.rst:541
msgid ""
"In this section, we'll provide finer control over how the :attr:`first` and :"
"attr:`last` attributes are set in the :class:`Custom` example. In the "
"previous version of our module, the instance variables :attr:`first` and :"
"attr:`last` could be set to non-string values or even deleted. We want to "
"make sure that these attributes always contain strings."
msgstr ""
"Dans cette section, nous assurons un contrôle plus précis sur la façon dont "
"les attributs :attr:`first` et :attr:`last` sont définis dans l'exemple :"
"class:`Custom`. Dans la version précédente de notre module, les variables "
"d'instance :attr:`first` et :attr:`last` pouvaient être définies sur des "
"valeurs autres que des chaînes ou même supprimées. Nous voulons nous assurer "
"que ces attributs contiennent toujours des chaînes."

#: extending/newtypes_tutorial.rst:550
msgid ""
"To provide greater control, over the :attr:`first` and :attr:`last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`first` attribute::"
msgstr ""
"Pour avoir un meilleur contrôle sur les attributs :attr:`first` et :attr:"
"`last`, nous utilisons des fonctions accesseur (*getter*) et mutateur "
"(*setter*) personnalisées. Voici les fonctions pour obtenir et définir "
"l'attribut :attr:`first` ::"

#: extending/newtypes_tutorial.rst:581
msgid ""
"The getter function is passed a :class:`Custom` object and a \"closure\", "
"which is a void pointer.  In this case, the closure is ignored.  (The "
"closure supports an advanced usage in which definition data is passed to the "
"getter and setter. This could, for example, be used to allow a single set of "
"getter and setter functions that decide the attribute to get or set based on "
"data in the closure.)"
msgstr ""
"L'accesseur reçoit un objet :class:`Custom` et une fermeture qui est un "
"pointeur vide. Dans ce cas, la fermeture est ignorée. (La fermeture prend en "
"charge une utilisation avancée dans laquelle les données de définition sont "
"transmises à l'accesseur et au mutateur. Cela pourrait, par exemple, être "
"utilisé pour autoriser un seul ensemble de fonctions accesseur et mutateur "
"qui décident de l'attribut à obtenir ou à définir en fonction des données "
"dans la fermeture.)"

#: extending/newtypes_tutorial.rst:587
msgid ""
"The setter function is passed the :class:`Custom` object, the new value, and "
"the closure.  The new value may be ``NULL``, in which case the attribute is "
"being deleted.  In our setter, we raise an error if the attribute is deleted "
"or if its new value is not a string."
msgstr ""
"Le mutateur reçoit l'objet :class:`Custom`, la nouvelle valeur et la "
"fermeture. La nouvelle valeur peut être ``NULL``, auquel cas l'attribut est "
"supprimé. Dans notre mutateur, nous levons une erreur si l'attribut est "
"supprimé ou si sa nouvelle valeur n'est pas une chaîne."

#: extending/newtypes_tutorial.rst:592
msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr "Nous créons un tableau de structures :c:type:`PyGetSetDef` ::"

#: extending/newtypes_tutorial.rst:602
msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr ""
"et l'enregistrons dans l'emplacement :c:member:`~PyTypeObject.tp_getset` ::"

#: extending/newtypes_tutorial.rst:606
msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the \"closure\" "
"mentioned above.  In this case, we aren't using a closure, so we just pass "
"``NULL``."
msgstr ""
"Le dernier élément d'une structure :c:type:`PyGetSetDef` est la fermeture "
"mentionnée ci-dessus. Dans ce cas, nous n'utilisons pas de fermeture, nous "
"passons donc simplement ``NULL``."

#: extending/newtypes_tutorial.rst:609
msgid "We also remove the member definitions for these attributes::"
msgstr ""
"Nous supprimons également les définitions de membre pour ces attributs :"

#: extending/newtypes_tutorial.rst:617
msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only "
"allow strings [#]_ to be passed::"
msgstr ""
"Nous devons également mettre à jour le gestionnaire :c:member:`~PyTypeObject."
"tp_init` pour autoriser uniquement le passage des chaînes [#]_ ::"

#: extending/newtypes_tutorial.rst:646
msgid ""
"With these changes, we can assure that the ``first`` and ``last`` members "
"are never ``NULL`` so we can remove checks for ``NULL`` values in almost all "
"cases. This means that most of the :c:func:`Py_XDECREF` calls can be "
"converted to :c:func:`Py_DECREF` calls.  The only place we can't change "
"these calls is in the ``tp_dealloc`` implementation, where there is the "
"possibility that the initialization of these members failed in ``tp_new``."
msgstr ""
"Avec ces modifications, nous pouvons garantir que les membres ``first`` et "
"``last`` ne sont jamais ``NULL``, nous pouvons donc supprimer les "
"vérifications des valeurs ``NULL`` dans presque tous les cas. Cela signifie "
"que la plupart des appels :c:func:`Py_XDECREF` peuvent être convertis en "
"appels :c:func:`Py_DECREF`. Le seul endroit où nous ne pouvons pas modifier "
"ces appels est dans l'implémentation de ``tp_dealloc``, où il est possible "
"que l'initialisation de ces membres ait échoué dans ``tp_new``."

#: extending/newtypes_tutorial.rst:653
msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition to "
"the :file:`setup.py` file."
msgstr ""
"Nous renommons également la fonction d'initialisation du module et le nom du "
"module dans la fonction d'initialisation, comme nous l'avons fait "
"précédemment, et nous ajoutons une définition supplémentaire au fichier :"
"file:`setup.py`."

#: extending/newtypes_tutorial.rst:659
msgid "Supporting cyclic garbage collection"
msgstr "Prise en charge du ramasse-miettes cyclique"

#: extending/newtypes_tutorial.rst:661
msgid ""
"Python has a :term:`cyclic garbage collector (GC) <garbage collection>` that "
"can identify unneeded objects even when their reference counts are not zero. "
"This can happen when objects are involved in cycles.  For example, consider:"
msgstr ""
"Python a un :term:`ramasse-miettes cyclique <garbage collection>` qui peut "
"identifier les objets inutiles même lorsque leur compteur de références "
"n'est pas nul. Cela peut se produire lorsque des objets sont impliqués dans "
"des cycles. Par exemple, considérons :"

#: extending/newtypes_tutorial.rst:671
msgid ""
"In this example, we create a list that contains itself. When we delete it, "
"it still has a reference from itself. Its reference count doesn't drop to "
"zero. Fortunately, Python's cyclic garbage collector will eventually figure "
"out that the list is garbage and free it."
msgstr ""
"Dans cet exemple, nous créons une liste qui se contient elle-même. Lorsque "
"nous la supprimons, il existe toujours une référence à elle-même. Son "
"compteur de références ne tombe pas à zéro. Heureusement, le ramasse-miettes "
"cyclique de Python finira par comprendre que la liste est un déchet et la "
"libérera."

#: extending/newtypes_tutorial.rst:676
msgid ""
"In the second version of the :class:`Custom` example, we allowed any kind of "
"object to be stored in the :attr:`first` or :attr:`last` attributes [#]_. "
"Besides, in the second and third versions, we allowed subclassing :class:"
"`Custom`, and subclasses may add arbitrary attributes.  For any of those two "
"reasons, :class:`Custom` objects can participate in cycles:"
msgstr ""
"Dans la seconde version de l'exemple :class:`Custom`, nous avons autorisé le "
"stockage de n'importe quel type d'objet dans les attributs :attr:`first` ou :"
"attr:`last` [#]_. De plus, dans les deuxième et troisième versions, nous "
"avons autorisé le sous-classement de :class:`Custom`, et les sous-classes "
"peuvent ajouter des attributs arbitraires. Pour l'une de ces deux raisons, "
"les objets :class:`Custom` peuvent produire des cycles :"

#: extending/newtypes_tutorial.rst:690
msgid ""
"To allow a :class:`Custom` instance participating in a reference cycle to be "
"properly detected and collected by the cyclic GC, our :class:`Custom` type "
"needs to fill two additional slots and to enable a flag that enables these "
"slots:"
msgstr ""
"Pour permettre à une instance :class:`Custom` participant à des références "
"cycliques d'être correctement détectée et collectée par le ramasse-miettes "
"cyclique, notre type :class:`Custom` doit définir deux emplacements "
"supplémentaires et activer un drapeau qui active ces emplacements :"

#: extending/newtypes_tutorial.rst:697
msgid ""
"First, the traversal method lets the cyclic GC know about subobjects that "
"could participate in cycles::"
msgstr ""
"Tout d'abord, la méthode de parcours (*Custom_traverse*) permet au ramasse-"
"miettes cyclique de connaître les sous-objets qui pourraient conduire à des "
"cycles ::"

#: extending/newtypes_tutorial.rst:717
msgid ""
"For each subobject that can participate in cycles, we need to call the :c:"
"func:`visit` function, which is passed to the traversal method. The :c:func:"
"`visit` function takes as arguments the subobject and the extra argument "
"*arg* passed to the traversal method.  It returns an integer value that must "
"be returned if it is non-zero."
msgstr ""
"Pour chaque sous-objet pouvant conduire à des cycles, nous devons appeler la "
"fonction :c:func:`visit`, qui est passée à la méthode de parcours. La "
"fonction :c:func:`visit` prend comme arguments le sous-objet et l'argument "
"supplémentaire *arg* passé à la méthode de parcours. Elle renvoie une valeur "
"entière qui doit être renvoyée si elle est différente de zéro."

#: extending/newtypes_tutorial.rst:723
msgid ""
"Python provides a :c:func:`Py_VISIT` macro that automates calling visit "
"functions.  With :c:func:`Py_VISIT`, we can minimize the amount of "
"boilerplate in ``Custom_traverse``::"
msgstr ""
"Python fournit une macro :c:func:`Py_VISIT` qui automatise l'appel des "
"fonctions de visite. Avec :c:func:`Py_VISIT`, nous pouvons minimiser la "
"quantité de code générique dans ``Custom_traverse`` ::"

# suit un :
#: extending/newtypes_tutorial.rst:736
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` implementation must name its "
"arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`."
msgstr ""
"l'implémentation :c:member:`~PyTypeObject.tp_traverse` doit nommer ses "
"arguments exactement *visit* et *arg* afin d'utiliser :c:func:`Py_VISIT`."

#: extending/newtypes_tutorial.rst:739
msgid ""
"Second, we need to provide a method for clearing any subobjects that can "
"participate in cycles::"
msgstr ""
"Deuxièmement, nous devons fournir une méthode pour effacer tous les sous-"
"objets qui peuvent conduire à des cycles ::"

#: extending/newtypes_tutorial.rst:750
msgid ""
"Notice the use of the :c:func:`Py_CLEAR` macro.  It is the recommended and "
"safe way to clear data attributes of arbitrary types while decrementing "
"their reference counts.  If you were to call :c:func:`Py_XDECREF` instead on "
"the attribute before setting it to ``NULL``, there is a possibility that the "
"attribute's destructor would call back into code that reads the attribute "
"again (*especially* if there is a reference cycle)."
msgstr ""
"Notez l'utilisation de la macro :c:func:`Py_CLEAR`. C'est le moyen "
"recommandé et sûr d'effacer les attributs de données de types arbitraires "
"tout en décrémentant leur compteur de références. Si vous deviez appeler :c:"
"func:`Py_XDECREF` à la place sur l'attribut avant de le définir sur "
"``NULL``, il est possible que le destructeur de l'attribut appelle du code "
"qui lit à nouveau l'attribut (*surtout* s'il existe un cycle de références)."

# suit un :
#: extending/newtypes_tutorial.rst:758
msgid "You could emulate :c:func:`Py_CLEAR` by writing::"
msgstr "vous pouvez émuler :c:func:`Py_CLEAR` en écrivant ::"

#: extending/newtypes_tutorial.rst:765
msgid ""
"Nevertheless, it is much easier and less error-prone to always use :c:func:"
"`Py_CLEAR` when deleting an attribute.  Don't try to micro-optimize at the "
"expense of robustness!"
msgstr ""
"Néanmoins, il est beaucoup plus facile et moins sujet aux erreurs de "
"toujours utiliser :c:func:`Py_CLEAR` lors de la suppression d'un attribut. "
"N'essayez pas de micro-optimiser au détriment de la robustesse !"

#: extending/newtypes_tutorial.rst:769
msgid ""
"The deallocator ``Custom_dealloc`` may call arbitrary code when clearing "
"attributes.  It means the circular GC can be triggered inside the function. "
"Since the GC assumes reference count is not zero, we need to untrack the "
"object from the GC by calling :c:func:`PyObject_GC_UnTrack` before clearing "
"members. Here is our reimplemented deallocator using :c:func:"
"`PyObject_GC_UnTrack` and ``Custom_clear``::"
msgstr ""
"La fonction de libération de la mémoire ``Custom_dealloc`` peut appeler du "
"code arbitraire lors de la suppression des attributs. Cela signifie que le "
"ramasse-miettes cyclique peut être déclenché à l'intérieur de la fonction. "
"Étant donné que le ramasse-miettes suppose que le nombre de références n'est "
"pas nul, nous devons annuler le suivi de l'objet par le ramasse-miettes en "
"appelant :c:func:`PyObject_GC_UnTrack` avant d'effacer les membres. Voici "
"notre fonction de libération de la mémoire réimplémentée en utilisant :c:"
"func:`PyObject_GC_UnTrack` et ``Custom_clear`` ::"

#: extending/newtypes_tutorial.rst:784
msgid ""
"Finally, we add the :c:macro:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr ""
"Enfin, nous ajoutons le drapeau :c:macro:`Py_TPFLAGS_HAVE_GC` aux drapeaux "
"de la classe ::"

#: extending/newtypes_tutorial.rst:788
msgid ""
"That's pretty much it.  If we had written custom :c:member:`~PyTypeObject."
"tp_alloc` or :c:member:`~PyTypeObject.tp_free` handlers, we'd need to modify "
"them for cyclic garbage collection.  Most extensions will use the versions "
"automatically provided."
msgstr ""
"C'est à peu près tout. Si nous avions écrit des gestionnaires personnalisés :"
"c:member:`~PyTypeObject.tp_alloc` ou :c:member:`~PyTypeObject.tp_free`, nous "
"aurions besoin de les modifier pour le ramasse-miettes cyclique. La plupart "
"des extensions utilisent les versions fournies automatiquement."

#: extending/newtypes_tutorial.rst:794
msgid "Subclassing other types"
msgstr "Sous-classement d'autres types"

#: extending/newtypes_tutorial.rst:796
msgid ""
"It is possible to create new extension types that are derived from existing "
"types. It is easiest to inherit from the built in types, since an extension "
"can easily use the :c:type:`PyTypeObject` it needs. It can be difficult to "
"share these :c:type:`PyTypeObject` structures between extension modules."
msgstr ""
"Il est possible de créer de nouveaux types d'extension dérivés de types "
"existants. Il est plus facile d'hériter des types natifs, car une extension "
"peut facilement utiliser le :c:type:`PyTypeObject` dont elle a besoin. Il "
"peut être difficile de partager ces structures :c:type:`PyTypeObject` entre "
"modules d'extension."

#: extending/newtypes_tutorial.rst:801
msgid ""
"In this example we will create a :class:`SubList` type that inherits from "
"the built-in :class:`list` type. The new type will be completely compatible "
"with regular lists, but will have an additional :meth:`increment` method "
"that increases an internal counter:"
msgstr ""
"Dans cet exemple, nous allons créer un type :class:`SubList` qui hérite du "
"type intégré :class:`list`. Le nouveau type sera complètement compatible "
"avec les listes natives, mais aura une méthode supplémentaire :meth:"
"`increment` qui augmente un compteur interne :"

#: extending/newtypes_tutorial.rst:821
msgid ""
"As you can see, the source code closely resembles the :class:`Custom` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr ""
"Comme vous pouvez le voir, le code source ressemble beaucoup aux exemples :"
"class:`Custom` des sections précédentes. Analysons les principales "
"différences ::"

#: extending/newtypes_tutorial.rst:829
msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value.  The base type will already "
"include the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr ""
"La principale différence pour les objets d'un type dérivé est que la "
"structure d'objet du type père doit être la première valeur. Le type père "
"inclut déjà le :c:func:`PyObject_HEAD` au début de sa structure."

#: extending/newtypes_tutorial.rst:833
msgid ""
"When a Python object is a :class:`SubList` instance, its ``PyObject *`` "
"pointer can be safely cast to both ``PyListObject *`` and ``SubListObject "
"*``::"
msgstr ""
"Lorsqu'un objet Python est une instance de :class:`SubList`, son pointeur "
"``PyObject *`` peut être trans-typé en toute sécurité vers ``PyListObject "
"*`` et ``SubListObject *`` ::"

#: extending/newtypes_tutorial.rst:845
msgid ""
"We see above how to call through to the :attr:`__init__` method of the base "
"type."
msgstr ""
"Nous voyons ci-dessus comment appeler la méthode :attr:`__init__` du type "
"père."

#: extending/newtypes_tutorial.rst:848
msgid ""
"This pattern is important when writing a type with custom :c:member:"
"`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_dealloc` members.  "
"The :c:member:`~PyTypeObject.tp_new` handler should not actually create the "
"memory for the object with its :c:member:`~PyTypeObject.tp_alloc`, but let "
"the base class handle it by calling its own :c:member:`~PyTypeObject.tp_new`."
msgstr ""
"Ce modèle est important lors de l'écriture d'un type avec des membres "
"personnalisés :c:member:`~PyTypeObject.tp_new` et :c:member:`~PyTypeObject."
"tp_dealloc`. Le gestionnaire :c:member:`~PyTypeObject.tp_new` ne doit pas "
"réellement allouer la mémoire pour l'objet avec son :c:member:`~PyTypeObject."
"tp_alloc`, mais laisser la classe mère gérer ça en appelant sa propre :c:"
"member:`~PyTypeObject.tp_new`."

#: extending/newtypes_tutorial.rst:854
msgid ""
"The :c:type:`PyTypeObject` struct supports a :c:member:`~PyTypeObject."
"tp_base` specifying the type's concrete base class.  Due to cross-platform "
"compiler issues, you can't fill that field directly with a reference to :c:"
"type:`PyList_Type`; it should be done later in the module initialization "
"function::"
msgstr ""
"La structure :c:type:`PyTypeObject` prend en charge un :c:member:"
"`~PyTypeObject.tp_base` spécifiant la classe mère concrète du type. En "
"raison de problèmes de compilateur multiplateformes, vous ne pouvez pas "
"remplir ce champ directement avec une référence à :c:type:`PyList_Type` ; "
"cela doit être fait plus tard dans la fonction d'initialisation du module ::"

#: extending/newtypes_tutorial.rst:882
msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the :c:"
"member:`~PyTypeObject.tp_base` slot filled in.  When we are deriving an "
"existing type, it is not necessary to fill out the :c:member:`~PyTypeObject."
"tp_alloc` slot with :c:func:`PyType_GenericNew` -- the allocation function "
"from the base type will be inherited."
msgstr ""
"Avant d'appeler :c:func:`PyType_Ready`, la structure de type doit avoir "
"l'emplacement :c:member:`~PyTypeObject.tp_base` rempli. Lorsque nous "
"dérivons un type existant, il n'est pas nécessaire de remplir l'emplacement :"
"c:member:`~PyTypeObject.tp_alloc` avec :c:func:`PyType_GenericNew` – la "
"fonction d'allocation du type père sera héritée."

#: extending/newtypes_tutorial.rst:888
msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to the "
"module is the same as with the basic :class:`Custom` examples."
msgstr ""
"Ensuite, appeler :c:func:`PyType_Ready` et ajouter l'objet type au module se "
"fait de la même manière qu'avec les exemples de base :class:`Custom`."

#: extending/newtypes_tutorial.rst:893
msgid "Footnotes"
msgstr "Notes"

#: extending/newtypes_tutorial.rst:894
msgid ""
"This is true when we know that the object is a basic type, like a string or "
"a float."
msgstr ""
"C'est vrai lorsque nous savons que l'objet est un type de base, comme une "
"chaîne ou un flottant."

#: extending/newtypes_tutorial.rst:897
msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection."
msgstr ""
"Nous nous sommes appuyés sur le gestionnaire :c:member:`~PyTypeObject."
"tp_dealloc` dans cet exemple, car notre type ne prend pas en charge le "
"ramasse-miettes."

#: extending/newtypes_tutorial.rst:900
msgid ""
"We now know that the first and last members are strings, so perhaps we could "
"be less careful about decrementing their reference counts, however, we "
"accept instances of string subclasses.  Even though deallocating normal "
"strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr ""
"Nous savons maintenant que les premier et dernier membres sont des chaînes, "
"nous pourrions donc peut-être être moins prudents quant à la décrémentation "
"de leur nombre de références, cependant, nous acceptons les instances de "
"sous-classes de chaînes. Même si la libération de la mémoire des chaînes "
"normales ne rappellera pas nos objets, nous ne pouvons pas garantir que la "
"libération de mémoire d'une instance d'une sous-classe de chaîne ne "
"rappellera pas nos objets."

#: extending/newtypes_tutorial.rst:906
msgid ""
"Also, even with our attributes restricted to strings instances, the user "
"could pass arbitrary :class:`str` subclasses and therefore still create "
"reference cycles."
msgstr ""
"De plus, même avec nos attributs limités aux instances de chaînes, "
"l'utilisateur pourrait passer des sous-classes arbitraires :class:`str` et "
"donc encore créer des références cycliques."
