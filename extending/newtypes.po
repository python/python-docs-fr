# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2024-10-29 22:00+0100\n"
"Last-Translator: Christophe Nanteuil <christophe.nanteuil@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: extending/newtypes.rst:7
msgid "Defining Extension Types: Assorted Topics"
msgstr "Définir les types d'extension : divers sujets"

#: extending/newtypes.rst:11
msgid ""
"This section aims to give a quick fly-by on the various type methods you can "
"implement and what they do."
msgstr ""
"Cette section vise à donner un aperçu rapide des différentes méthodes de "
"type que vous pouvez implémenter et de ce qu'elles font."

#: extending/newtypes.rst:14
msgid ""
"Here is the definition of :c:type:`PyTypeObject`, with some fields only used "
"in :ref:`debug builds <debug-build>` omitted:"
msgstr ""
"Voici la définition de :c:type:`PyTypeObject`, après avoir enlevé certains "
"champs utilisés uniquement dans :ref:`debug builds <debug-build>` :"

#: extending/newtypes.rst:17
msgid ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* For printing, in format \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n"
"\n"
"    /* Methods to implement standard operations */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)\n"
"                                    or tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Method suites for standard classes */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* More standard operations (here for binary compatibility) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Functions to access object as input/output buffer */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags to define presence of optional/expanded features */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Documentation string */\n"
"\n"
"    /* Assigned meaning in release 2.0 */\n"
"    /* call function for all accessible objects */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* delete references to contained objects */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Assigned meaning in release 2.1 */\n"
"    /* rich comparisons */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* weak reference enabler */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iterators */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attribute descriptor and subclassing stuff */\n"
"    struct PyMethodDef *tp_methods;\n"
"    struct PyMemberDef *tp_members;\n"
"    struct PyGetSetDef *tp_getset;\n"
"    // Strong reference on a heap type, borrowed reference on a static type\n"
"    struct _typeobject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Low-level free-memory routine */\n"
"    inquiry tp_is_gc; /* For PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* method resolution order */\n"
"    PyObject *tp_cache;\n"
"    PyObject *tp_subclasses;\n"
"    PyObject *tp_weaklist;\n"
"    destructor tp_del;\n"
"\n"
"    /* Type attribute cache version tag. Added in version 2.6 */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset of which type-watchers care about this type */\n"
"    unsigned char tp_watched;\n"
"} PyTypeObject;\n"
msgstr ""

#: extending/newtypes.rst:20
msgid ""
"Now that's a *lot* of methods.  Don't worry too much though -- if you have a "
"type you want to define, the chances are very good that you will only "
"implement a handful of these."
msgstr ""
"Cela fait *beaucoup* de méthodes. Ne vous inquiétez pas trop cependant : si "
"vous souhaitez définir un type, il y a de fortes chances que vous "
"n'implémentiez qu'une petite partie d'entre elles."

#: extending/newtypes.rst:24
msgid ""
"As you probably expect by now, we're going to go over this and give more "
"information about the various handlers.  We won't go in the order they are "
"defined in the structure, because there is a lot of historical baggage that "
"impacts the ordering of the fields.  It's often easiest to find an example "
"that includes the fields you need and then change the values to suit your "
"new type. ::"
msgstr ""
"Comme vous vous en doutez probablement maintenant, nous allons passer en "
"revue cela et donner plus d'informations sur les différents gestionnaires. "
"Nous ne suivrons pas l'ordre dans lequel ils sont définis dans la structure, "
"car l'ordre des champs résulte d'un certain historique. Il est souvent plus "
"facile de trouver un exemple qui inclut les champs dont vous avez besoin, "
"puis de modifier les valeurs en fonction de votre nouveau type ::"

#: extending/newtypes.rst:31
msgid "const char *tp_name; /* For printing */"
msgstr ""

#: extending/newtypes.rst:33
msgid ""
"The name of the type -- as mentioned in the previous chapter, this will "
"appear in various places, almost entirely for diagnostic purposes. Try to "
"choose something that will be helpful in such a situation! ::"
msgstr ""
"Le nom du type – comme mentionné dans le chapitre précédent, cela apparaîtra "
"à divers endroits, presque entièrement à des fins de diagnostic. Essayez de "
"choisir quelque chose qui sera utile dans une telle situation ! ::"

#: extending/newtypes.rst:37
msgid "Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */"
msgstr ""

#: extending/newtypes.rst:39
msgid ""
"These fields tell the runtime how much memory to allocate when new objects "
"of this type are created.  Python has some built-in support for variable "
"length structures (think: strings, tuples) which is where the :c:member:"
"`~PyTypeObject.tp_itemsize` field comes in.  This will be dealt with "
"later. ::"
msgstr ""
"Ces champs indiquent la quantité de mémoire à allouer à l'exécution lorsque "
"de nouveaux objets de ce type sont créés. Python prend en charge nativement "
"des structures de longueur variable (pensez : chaînes, *n*-uplets), c'est là "
"que le champ :c:member:`~PyTypeObject.tp_itemsize` entre en jeu. Cela sera "
"traité plus tard. ::"

#: extending/newtypes.rst:44
msgid "const char *tp_doc;"
msgstr ""

#: extending/newtypes.rst:46
msgid ""
"Here you can put a string (or its address) that you want returned when the "
"Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr ""
"Ici vous pouvez mettre une chaîne (ou son adresse) que vous voulez renvoyer "
"lorsque le script Python référence ``obj.__doc__`` pour récupérer le "
"*docstring*."

#: extending/newtypes.rst:49
msgid ""
"Now we come to the basic type methods -- the ones most extension types will "
"implement."
msgstr ""
"Nous en arrivons maintenant aux méthodes de type basiques -- celles que la "
"plupart des types d'extension mettront en œuvre."

#: extending/newtypes.rst:54
msgid "Finalization and De-allocation"
msgstr "Finalisation et libération de mémoire"

#: extending/newtypes.rst:64
msgid "destructor tp_dealloc;"
msgstr ""

#: extending/newtypes.rst:66
msgid ""
"This function is called when the reference count of the instance of your "
"type is reduced to zero and the Python interpreter wants to reclaim it.  If "
"your type has memory to free or other clean-up to perform, you can put it "
"here.  The object itself needs to be freed here as well.  Here is an example "
"of this function::"
msgstr ""
"Cette fonction est appelée lorsque le compteur de références de l'instance "
"de votre type tombe à zéro et que l'interpréteur Python veut récupérer la "
"mémoire afférente. Si votre type a de la mémoire à libérer ou un autre "
"nettoyage à effectuer, vous pouvez le mettre ici. L'objet lui-même doit être "
"libéré ici aussi. Voici un exemple de cette fonction ::"

#: extending/newtypes.rst:72
msgid ""
"static void\n"
"newdatatype_dealloc(newdatatypeobject *obj)\n"
"{\n"
"    free(obj->obj_UnderlyingDatatypePtr);\n"
"    Py_TYPE(obj)->tp_free((PyObject *)obj);\n"
"}"
msgstr ""

#: extending/newtypes.rst:79
msgid ""
"If your type supports garbage collection, the destructor should call :c:func:"
"`PyObject_GC_UnTrack` before clearing any member fields::"
msgstr ""
"Si votre type prend en charge le ramasse-miettes, le destructeur doit "
"appeler :c:func:`PyObject_GC_UnTrack` avant d'effacer les champs membres ::"

#: extending/newtypes.rst:82
msgid ""
"static void\n"
"newdatatype_dealloc(newdatatypeobject *obj)\n"
"{\n"
"    PyObject_GC_UnTrack(obj);\n"
"    Py_CLEAR(obj->other_obj);\n"
"    ...\n"
"    Py_TYPE(obj)->tp_free((PyObject *)obj);\n"
"}"
msgstr ""

#: extending/newtypes.rst:95
msgid ""
"One important requirement of the deallocator function is that it leaves any "
"pending exceptions alone.  This is important since deallocators are "
"frequently called as the interpreter unwinds the Python stack; when the "
"stack is unwound due to an exception (rather than normal returns), nothing "
"is done to protect the deallocators from seeing that an exception has "
"already been set.  Any actions which a deallocator performs which may cause "
"additional Python code to be executed may detect that an exception has been "
"set.  This can lead to misleading errors from the interpreter.  The proper "
"way to protect against this is to save a pending exception before performing "
"the unsafe action, and restoring it when done.  This can be done using the :"
"c:func:`PyErr_Fetch` and :c:func:`PyErr_Restore` functions::"
msgstr ""
"Une exigence importante de la fonction de libération de la mémoire est de ne "
"pas s'occuper de toutes les exceptions en attente. C'est important car les "
"fonctions de libération de la mémoire sont fréquemment appelées lorsque "
"l'interpréteur remonte la pile d'appels Python ; lorsque la pile est "
"remontée à cause d'une exception (plutôt que de retours normaux), les "
"fonctions de libération peuvent voir qu'une exception a déjà été définie. "
"Toute action effectuée par une fonction de libération de la mémoire pouvant "
"entraîner l'exécution de code Python supplémentaire peut détecter qu'une "
"exception a été définie. Cela peut conduire l’interpréteur à se tromper sur "
"la nature de l'erreur. La bonne façon d'éviter cela est d'enregistrer une "
"exception en attente avant d'effectuer l'action non sécurisée et à la "
"restaurer une fois terminée. Cela peut être fait en utilisant les fonctions :"
"c:func:`PyErr_Fetch` et :c:func:`PyErr_Restore` ::"

#: extending/newtypes.rst:107
msgid ""
"static void\n"
"my_dealloc(PyObject *obj)\n"
"{\n"
"    MyObject *self = (MyObject *) obj;\n"
"    PyObject *cbresult;\n"
"\n"
"    if (self->my_callback != NULL) {\n"
"        PyObject *err_type, *err_value, *err_traceback;\n"
"\n"
"        /* This saves the current exception state */\n"
"        PyErr_Fetch(&err_type, &err_value, &err_traceback);\n"
"\n"
"        cbresult = PyObject_CallNoArgs(self->my_callback);\n"
"        if (cbresult == NULL)\n"
"            PyErr_WriteUnraisable(self->my_callback);\n"
"        else\n"
"            Py_DECREF(cbresult);\n"
"\n"
"        /* This restores the saved exception state */\n"
"        PyErr_Restore(err_type, err_value, err_traceback);\n"
"\n"
"        Py_DECREF(self->my_callback);\n"
"    }\n"
"    Py_TYPE(obj)->tp_free((PyObject*)self);\n"
"}"
msgstr ""

# suit un :
#: extending/newtypes.rst:134
msgid ""
"There are limitations to what you can safely do in a deallocator function. "
"First, if your type supports garbage collection (using :c:member:"
"`~PyTypeObject.tp_traverse` and/or :c:member:`~PyTypeObject.tp_clear`), some "
"of the object's members can have been cleared or finalized by the time :c:"
"member:`~PyTypeObject.tp_dealloc` is called.  Second, in :c:member:"
"`~PyTypeObject.tp_dealloc`, your object is in an unstable state: its "
"reference count is equal to zero.  Any call to a non-trivial object or API "
"(as in the example above) might end up calling :c:member:`~PyTypeObject."
"tp_dealloc` again, causing a double free and a crash."
msgstr ""
"des limites existent à ce que vous pouvez faire en toute sécurité dans une "
"fonction de libération de la mémoire. Tout d'abord, si votre type prend en "
"charge le ramasse-miettes (en utilisant :c:member:`~PyTypeObject."
"tp_traverse` et/ou :c:member:`~PyTypeObject.tp_clear`), certains membres de "
"l'objet peuvent avoir été effacés ou finalisés avant que :c:member:"
"`~PyTypeObject.tp_dealloc` ne soit appelé. Deuxièmement, dans :c:member:"
"`~PyTypeObject.tp_dealloc`, votre objet est dans un état instable : son "
"compteur de références est égal à zéro. Tout appel à un objet non trivial ou "
"à une API (comme dans l'exemple ci-dessus) peut finir par appeler :c:member:"
"`~PyTypeObject.tp_dealloc` à nouveau, provoquant une double libération et un "
"plantage."

#: extending/newtypes.rst:143
msgid ""
"Starting with Python 3.4, it is recommended not to put any complex "
"finalization code in :c:member:`~PyTypeObject.tp_dealloc`, and instead use "
"the new :c:member:`~PyTypeObject.tp_finalize` type method."
msgstr ""
"À partir de Python 3.4, il est recommandé de ne pas mettre de code de "
"finalisation complexe dans :c:member:`~PyTypeObject.tp_dealloc`, et "
"d'utiliser à la place la nouvelle méthode de type :c:member:`~PyTypeObject."
"tp_finalize`."

#: extending/newtypes.rst:148
msgid ":pep:`442` explains the new finalization scheme."
msgstr ":pep:`442` explique le nouveau schéma de finalisation."

#: extending/newtypes.rst:155
msgid "Object Presentation"
msgstr "Présentation de l'objet"

#: extending/newtypes.rst:157
msgid ""
"In Python, there are two ways to generate a textual representation of an "
"object: the :func:`repr` function, and the :func:`str` function.  (The :func:"
"`print` function just calls :func:`str`.)  These handlers are both optional."
msgstr ""
"En Python, il existe deux façons de générer une représentation textuelle "
"d'un objet : la fonction :func:`repr` et la fonction :func:`str` (la "
"fonction :func:`print` appelle simplement :func:`str`). Ces gestionnaires "
"sont tous deux facultatifs."

#: extending/newtypes.rst:163
msgid ""
"reprfunc tp_repr;\n"
"reprfunc tp_str;"
msgstr ""

#: extending/newtypes.rst:166
msgid ""
"The :c:member:`~PyTypeObject.tp_repr` handler should return a string object "
"containing a representation of the instance for which it is called.  Here is "
"a simple example::"
msgstr ""
"Le gestionnaire :c:member:`~PyTypeObject.tp_repr` doit renvoyer un objet "
"chaîne contenant une représentation de l'instance pour laquelle il est "
"appelé. Voici un exemple simple ::"

#: extending/newtypes.rst:170
msgid ""
"static PyObject *\n"
"newdatatype_repr(newdatatypeobject *obj)\n"
"{\n"
"    return PyUnicode_FromFormat(\"Repr-ified_newdatatype{{size:%d}}\",\n"
"                                obj->obj_UnderlyingDatatypePtr->size);\n"
"}"
msgstr ""

#: extending/newtypes.rst:177
msgid ""
"If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the "
"interpreter will supply a representation that uses the type's :c:member:"
"`~PyTypeObject.tp_name` and a uniquely identifying value for the object."
msgstr ""
"Si aucun gestionnaire :c:member:`~PyTypeObject.tp_repr` n'est spécifié, "
"l'interpréteur fournira une représentation qui utilise le type :c:member:"
"`~PyTypeObject.tp_name` et une valeur d'identification unique pour l'objet."

#: extending/newtypes.rst:181
msgid ""
"The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the :c:"
"member:`~PyTypeObject.tp_repr` handler described above is to :func:`repr`; "
"that is, it is called when Python code calls :func:`str` on an instance of "
"your object.  Its implementation is very similar to the :c:member:"
"`~PyTypeObject.tp_repr` function, but the resulting string is intended for "
"human consumption.  If :c:member:`~PyTypeObject.tp_str` is not specified, "
"the :c:member:`~PyTypeObject.tp_repr` handler is used instead."
msgstr ""
"Le gestionnaire :c:member:`~PyTypeObject.tp_str` est à :func:`str` ce que le "
"gestionnaire :c:member:`~PyTypeObject.tp_repr` décrit ci-dessus est à :func:"
"`repr` ; c'est-à-dire qu'il est appelé lorsque le code Python appelle :func:"
"`str` sur une instance de votre objet. Son implémentation est très similaire "
"à la fonction :c:member:`~PyTypeObject.tp_repr`, mais la chaîne résultante "
"est destinée à être lue par des utilisateurs. Si :c:member:`~PyTypeObject."
"tp_str` n'est pas spécifié, le gestionnaire :c:member:`~PyTypeObject."
"tp_repr` est utilisé à la place."

#: extending/newtypes.rst:188
msgid "Here is a simple example::"
msgstr "Voici un exemple simple ::"

#: extending/newtypes.rst:190
msgid ""
"static PyObject *\n"
"newdatatype_str(newdatatypeobject *obj)\n"
"{\n"
"    return PyUnicode_FromFormat(\"Stringified_newdatatype{{size:%d}}\",\n"
"                                obj->obj_UnderlyingDatatypePtr->size);\n"
"}"
msgstr ""

#: extending/newtypes.rst:200
msgid "Attribute Management"
msgstr "Gestion des attributs"

#: extending/newtypes.rst:202
msgid ""
"For every object which can support attributes, the corresponding type must "
"provide the functions that control how the attributes are resolved.  There "
"needs to be a function which can retrieve attributes (if any are defined), "
"and another to set attributes (if setting attributes is allowed).  Removing "
"an attribute is a special case, for which the new value passed to the "
"handler is ``NULL``."
msgstr ""
"Pour chaque objet pouvant prendre en charge des attributs, le type "
"correspondant doit fournir les fonctions qui contrôlent la façon dont les "
"attributs sont résolus. Il doit y avoir une fonction qui peut récupérer les "
"attributs (le cas échéant) et une autre pour définir les attributs (si la "
"définition des attributs est autorisée). La suppression d'un attribut est un "
"cas particulier, pour lequel la nouvelle valeur transmise au gestionnaire "
"est ``NULL``."

#: extending/newtypes.rst:208
msgid ""
"Python supports two pairs of attribute handlers; a type that supports "
"attributes only needs to implement the functions for one pair.  The "
"difference is that one pair takes the name of the attribute as a :c:expr:"
"`char\\*`, while the other accepts a :c:expr:`PyObject*`.  Each type can use "
"whichever pair makes more sense for the implementation's convenience. ::"
msgstr ""
"Python prend en charge deux paires de gestionnaires d'attributs ; un type "
"qui prend en charge les attributs n'a besoin d'implémenter les fonctions que "
"pour une paire. La différence est qu'une paire prend le nom de l'attribut en "
"tant que :c:expr:`char\\*`, tandis que l'autre accepte un :c:expr:"
"`PyObject*`. Chaque type peut utiliser la paire la plus logique pour la "
"commodité de l'implémentation. ::"

#: extending/newtypes.rst:214
msgid ""
"getattrfunc  tp_getattr;        /* char * version */\n"
"setattrfunc  tp_setattr;\n"
"/* ... */\n"
"getattrofunc tp_getattro;       /* PyObject * version */\n"
"setattrofunc tp_setattro;"
msgstr ""

#: extending/newtypes.rst:220
msgid ""
"If accessing attributes of an object is always a simple operation (this will "
"be explained shortly), there are generic implementations which can be used "
"to provide the :c:expr:`PyObject*` version of the attribute management "
"functions. The actual need for type-specific attribute handlers almost "
"completely disappeared starting with Python 2.2, though there are many "
"examples which have not been updated to use some of the new generic "
"mechanism that is available."
msgstr ""
"Si accéder aux attributs d'un objet est toujours une opération simple (ceci "
"sera expliqué brièvement), il existe des implémentations génériques qui "
"peuvent être utilisées pour fournir la version :c:expr:`PyObject*` des "
"fonctions de gestion des attributs. Le besoin réel de gestionnaires "
"d'attributs spécifiques au type a presque complètement disparu à partir de "
"Python 2.2, bien qu'il existe de nombreux exemples qui n'ont pas été mis à "
"jour pour utiliser certains des nouveaux mécanismes génériques disponibles."

#: extending/newtypes.rst:231
msgid "Generic Attribute Management"
msgstr "Gestion des attributs génériques"

#: extending/newtypes.rst:233
msgid ""
"Most extension types only use *simple* attributes.  So, what makes the "
"attributes simple?  There are only a couple of conditions that must be met:"
msgstr ""
"La plupart des types d'extensions n'utilisent que des attributs *simples*. "
"Alors, qu'est-ce qui rend les attributs simples ? Seules quelques conditions "
"doivent être remplies :"

# énumération
#: extending/newtypes.rst:236
msgid ""
"The name of the attributes must be known when :c:func:`PyType_Ready` is "
"called."
msgstr ""
"le nom des attributs doit être déjà connu lorsqu'on lance :c:func:"
"`PyType_Ready` ;"

# énumération
#: extending/newtypes.rst:239
msgid ""
"No special processing is needed to record that an attribute was looked up or "
"set, nor do actions need to be taken based on the value."
msgstr ""
"aucun traitement spécial n'est nécessaire pour enregistrer qu'un attribut a "
"été recherché ou défini, et aucune action ne doit être entreprise en "
"fonction de la valeur."

#: extending/newtypes.rst:242
msgid ""
"Note that this list does not place any restrictions on the values of the "
"attributes, when the values are computed, or how relevant data is stored."
msgstr ""
"Notez que cette liste n'impose aucune restriction sur les valeurs des "
"attributs, le moment où les valeurs sont calculées ou la manière dont les "
"données pertinentes sont stockées."

#: extending/newtypes.rst:245
msgid ""
"When :c:func:`PyType_Ready` is called, it uses three tables referenced by "
"the type object to create :term:`descriptor`\\s which are placed in the "
"dictionary of the type object.  Each descriptor controls access to one "
"attribute of the instance object.  Each of the tables is optional; if all "
"three are ``NULL``, instances of the type will only have attributes that are "
"inherited from their base type, and should leave the :c:member:"
"`~PyTypeObject.tp_getattro` and :c:member:`~PyTypeObject.tp_setattro` fields "
"``NULL`` as well, allowing the base type to handle attributes."
msgstr ""
"Lorsque :c:func:`PyType_Ready` est appelé, il utilise trois tableaux "
"référencés par l'objet type pour créer des :term:`descripteurs <descriptor>` "
"qui sont placés dans le dictionnaire de l'objet type. Chaque descripteur "
"contrôle l'accès à un attribut de l'objet instance. Chacun des tableaux est "
"facultatif ; si les trois sont ``NULL``, les instances du type n'auront que "
"des attributs hérités de leur type de base et doivent laisser les champs :c:"
"member:`~PyTypeObject.tp_getattro` et :c:member:`~PyTypeObject .tp_setattro` "
"à ``NULL`` également, permettant au type de base de gérer les attributs."

#: extending/newtypes.rst:253
msgid "The tables are declared as three fields of the type object::"
msgstr ""
"Les tableaux sont déclarés sous la forme de trois champs de type objet ::"

#: extending/newtypes.rst:255
msgid ""
"struct PyMethodDef *tp_methods;\n"
"struct PyMemberDef *tp_members;\n"
"struct PyGetSetDef *tp_getset;"
msgstr ""

#: extending/newtypes.rst:259
msgid ""
"If :c:member:`~PyTypeObject.tp_methods` is not ``NULL``, it must refer to an "
"array of :c:type:`PyMethodDef` structures.  Each entry in the table is an "
"instance of this structure::"
msgstr ""
"Si :c:member:`~PyTypeObject.tp_methods` n'est pas ``NULL``, il doit faire "
"référence à un tableau de structures :c:type:`PyMethodDef`. Chaque entrée du "
"tableau est une instance de cette structure ::"

#: extending/newtypes.rst:263
msgid ""
"typedef struct PyMethodDef {\n"
"    const char  *ml_name;       /* method name */\n"
"    PyCFunction  ml_meth;       /* implementation function */\n"
"    int          ml_flags;      /* flags */\n"
"    const char  *ml_doc;        /* docstring */\n"
"} PyMethodDef;"
msgstr ""

#: extending/newtypes.rst:270
#, fuzzy
msgid ""
"One entry should be defined for each method provided by the type; no entries "
"are needed for methods inherited from a base type.  One additional entry is "
"needed at the end; it is a sentinel that marks the end of the array.  The :c:"
"member:`~PyMethodDef.ml_name` field of the sentinel must be ``NULL``."
msgstr ""
"Une entrée doit être définie pour chaque méthode fournie par le type ; "
"aucune entrée n'est nécessaire pour les méthodes héritées d'un type ancêtre. "
"Une entrée supplémentaire est nécessaire à la fin ; c'est une sentinelle qui "
"marque la fin du tableau. Le champ :attr:`ml_name` de la sentinelle doit "
"être ``NULL``."

#: extending/newtypes.rst:275
msgid ""
"The second table is used to define attributes which map directly to data "
"stored in the instance.  A variety of primitive C types are supported, and "
"access may be read-only or read-write.  The structures in the table are "
"defined as::"
msgstr ""
"Le deuxième tableau est utilisé pour définir les attributs qui correspondent "
"directement aux données stockées dans l'instance. Divers types C natifs sont "
"pris en charge et l'accès peut être en lecture seule ou en lecture-écriture. "
"Les structures du tableau sont définies comme suit :"

#: extending/newtypes.rst:279
msgid ""
"typedef struct PyMemberDef {\n"
"    const char *name;\n"
"    int         type;\n"
"    int         offset;\n"
"    int         flags;\n"
"    const char *doc;\n"
"} PyMemberDef;"
msgstr ""

#: extending/newtypes.rst:287
#, fuzzy
msgid ""
"For each entry in the table, a :term:`descriptor` will be constructed and "
"added to the type which will be able to extract a value from the instance "
"structure.  The :c:member:`~PyMemberDef.type` field should contain a type "
"code like :c:macro:`Py_T_INT` or :c:macro:`Py_T_DOUBLE`; the value will be "
"used to determine how to convert Python values to and from C values.  The :c:"
"member:`~PyMemberDef.flags` field is used to store flags which control how "
"the attribute can be accessed: you can set it to :c:macro:`Py_READONLY` to "
"prevent Python code from setting it."
msgstr ""
"Pour chaque entrée du tableau, un :term:`descripteur <descriptor>` sera "
"construit et ajouté au type qui pourra extraire une valeur de la structure "
"de l'instance. Le champ :attr:`type` doit contenir l'un des codes de type "
"définis dans l'en-tête :file:`structmember.h` ; la valeur sera utilisée pour "
"déterminer comment convertir les valeurs Python vers et à partir des valeurs "
"C. Le champ :attr:`flags` est utilisé pour stocker les drapeaux qui "
"contrôlent l'accès à l'attribut."

#: extending/newtypes.rst:295
#, fuzzy
msgid ""
"An interesting advantage of using the :c:member:`~PyTypeObject.tp_members` "
"table to build descriptors that are used at runtime is that any attribute "
"defined this way can have an associated doc string simply by providing the "
"text in the table.  An application can use the introspection API to retrieve "
"the descriptor from the class object, and get the doc string using its :attr:"
"`~type.__doc__` attribute."
msgstr ""
"Un avantage intéressant de l'utilisation du tableau :c:member:`~PyTypeObject."
"tp_members` pour construire les descripteurs utilisés à l'exécution est que, "
"à tout attribut défini de cette façon, on peut associer une chaîne de "
"documentation (*docstring*), en écrivant simplement le texte dans le "
"tableau. Une application peut utiliser l'API d'introspection pour récupérer "
"le descripteur de l'objet de classe et utiliser son attribut :attr:`__doc__` "
"pour renvoyer la chaîne de documentation."

#: extending/newtypes.rst:301
#, fuzzy
msgid ""
"As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry "
"with a :c:member:`~PyMethodDef.ml_name` value of ``NULL`` is required."
msgstr ""
"Comme pour le tableau :c:member:`~PyTypeObject.tp_methods`, une entrée "
"sentinelle avec une valeur ``NULL`` pour :attr:`name` est requise."

#: extending/newtypes.rst:315
msgid "Type-specific Attribute Management"
msgstr "Gestion des attributs de type spécifiques"

#: extending/newtypes.rst:317
msgid ""
"For simplicity, only the :c:expr:`char\\*` version will be demonstrated "
"here; the type of the name parameter is the only difference between the :c:"
"expr:`char\\*` and :c:expr:`PyObject*` flavors of the interface. This "
"example effectively does the same thing as the generic example above, but "
"does not use the generic support added in Python 2.2.  It explains how the "
"handler functions are called, so that if you do need to extend their "
"functionality, you'll understand what needs to be done."
msgstr ""
"Pour plus de simplicité, seule la version :c:expr:`char\\*` est montrée "
"ici ; le type du paramètre *name* est la seule différence entre les "
"variations :c:expr:`char\\*` et :c:expr:`PyObject*` de l'interface. Cet "
"exemple fait effectivement la même chose que l'exemple générique ci-dessus, "
"mais n'utilise pas le support générique ajouté dans Python 2.2. Il explique "
"comment les fonctions de gestionnaire sont appelées, de sorte que si vous "
"avez besoin d'étendre leurs fonctionnalités, vous comprendrez ce qui doit "
"être fait."

#: extending/newtypes.rst:325
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_getattr` handler is called when the object "
"requires an attribute look-up.  It is called in the same situations where "
"the :meth:`~object.__getattr__` method of a class would be called."
msgstr ""
"Le gestionnaire :c:member:`~PyTypeObject.tp_getattr` est appelé lorsque "
"l'objet nécessite une recherche d'attribut. Il est appelé dans les mêmes "
"situations que l'appel à la méthode :meth:`__getattr__` d'une classe."

#: extending/newtypes.rst:329
msgid "Here is an example::"
msgstr "Voici un exemple ::"

#: extending/newtypes.rst:331
msgid ""
"static PyObject *\n"
"newdatatype_getattr(newdatatypeobject *obj, char *name)\n"
"{\n"
"    if (strcmp(name, \"data\") == 0)\n"
"    {\n"
"        return PyLong_FromLong(obj->data);\n"
"    }\n"
"\n"
"    PyErr_Format(PyExc_AttributeError,\n"
"                 \"'%.100s' object has no attribute '%.400s'\",\n"
"                 Py_TYPE(obj)->tp_name, name);\n"
"    return NULL;\n"
"}"
msgstr ""

#: extending/newtypes.rst:345
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_setattr` handler is called when the :meth:"
"`~object.__setattr__` or :meth:`~object.__delattr__` method of a class "
"instance would be called.  When an attribute should be deleted, the third "
"parameter will be ``NULL``.  Here is an example that simply raises an "
"exception; if this were really all you wanted, the :c:member:`~PyTypeObject."
"tp_setattr` handler should be set to ``NULL``. ::"
msgstr ""
"Le gestionnaire :c:member:`~PyTypeObject.tp_setattr` est appelé lorsque la "
"méthode :meth:`__setattr__` ou :meth:`__delattr__` d'une instance de classe "
"est appelée. Lorsqu'un attribut doit être supprimé, le troisième paramètre "
"est ``NULL``. Voici un exemple qui lève simplement une exception ; si "
"c'était vraiment tout ce que vous vouliez, le gestionnaire :c:member:"
"`~PyTypeObject.tp_setattr` devrait être défini sur ``NULL``. ::"

#: extending/newtypes.rst:351
msgid ""
"static int\n"
"newdatatype_setattr(newdatatypeobject *obj, char *name, PyObject *v)\n"
"{\n"
"    PyErr_Format(PyExc_RuntimeError, \"Read-only attribute: %s\", name);\n"
"    return -1;\n"
"}"
msgstr ""

#: extending/newtypes.rst:359
msgid "Object Comparison"
msgstr "Comparaison des objets"

#: extending/newtypes.rst:363
msgid "richcmpfunc tp_richcompare;"
msgstr ""

#: extending/newtypes.rst:365
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_richcompare` handler is called when "
"comparisons are needed.  It is analogous to the :ref:`rich comparison "
"methods <richcmpfuncs>`, like :meth:`!__lt__`, and also called by :c:func:"
"`PyObject_RichCompare` and :c:func:`PyObject_RichCompareBool`."
msgstr ""
"Le gestionnaire :c:member:`~PyTypeObject.tp_richcompare` est appelé lorsque "
"des comparaisons sont nécessaires. Il est analogue aux :ref:`méthodes de "
"comparaison riches <richcmpfuncs>`, comme :meth:`__lt__`, et est également "
"appelé par :c:func:`PyObject_RichCompare` et :c:func:"
"`PyObject_RichCompareBool`."

#: extending/newtypes.rst:370
msgid ""
"This function is called with two Python objects and the operator as "
"arguments, where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, "
"``Py_GE``, ``Py_LT`` or ``Py_GT``.  It should compare the two objects with "
"respect to the specified operator and return ``Py_True`` or ``Py_False`` if "
"the comparison is successful, ``Py_NotImplemented`` to indicate that "
"comparison is not implemented and the other object's comparison method "
"should be tried, or ``NULL`` if an exception was set."
msgstr ""
"Cette fonction est appelée avec deux objets Python et l'opérateur comme "
"arguments, où l'opérateur est ``Py_EQ``, ``Py_NE``, ``Py_LE``, ``Py_GE``, "
"``Py_LT`` ou ``Py_GT``. Elle doit comparer les deux objets conformément à "
"l'opérateur spécifié et renvoyer ``Py_True`` ou ``Py_False`` si la "
"comparaison a réussi, ``Py_NotImplemented`` pour indiquer que la comparaison "
"n'est pas implémentée et que la méthode de comparaison de l'autre objet doit "
"être essayée, ou ``NULL`` si une exception doit être levée."

#: extending/newtypes.rst:378
msgid ""
"Here is a sample implementation, for a datatype that is considered equal if "
"the size of an internal pointer is equal::"
msgstr ""
"Voici un exemple d'implémentation, pour un type de données où l'égalité "
"signifie que la taille d'un pointeur interne est égale :"

#: extending/newtypes.rst:381
msgid ""
"static PyObject *\n"
"newdatatype_richcmp(newdatatypeobject *obj1, newdatatypeobject *obj2, int "
"op)\n"
"{\n"
"    PyObject *result;\n"
"    int c, size1, size2;\n"
"\n"
"    /* code to make sure that both arguments are of type\n"
"       newdatatype omitted */\n"
"\n"
"    size1 = obj1->obj_UnderlyingDatatypePtr->size;\n"
"    size2 = obj2->obj_UnderlyingDatatypePtr->size;\n"
"\n"
"    switch (op) {\n"
"    case Py_LT: c = size1 <  size2; break;\n"
"    case Py_LE: c = size1 <= size2; break;\n"
"    case Py_EQ: c = size1 == size2; break;\n"
"    case Py_NE: c = size1 != size2; break;\n"
"    case Py_GT: c = size1 >  size2; break;\n"
"    case Py_GE: c = size1 >= size2; break;\n"
"    }\n"
"    result = c ? Py_True : Py_False;\n"
"    Py_INCREF(result);\n"
"    return result;\n"
" }"
msgstr ""

#: extending/newtypes.rst:408
msgid "Abstract Protocol Support"
msgstr "Gestion de protocoles abstraits"

#: extending/newtypes.rst:410
msgid ""
"Python supports a variety of *abstract* 'protocols;' the specific interfaces "
"provided to use these interfaces are documented in :ref:`abstract`."
msgstr ""
"Python prend en charge divers « protocoles » *abstraits* ; les interfaces "
"spécifiques fournies pour utiliser ces interfaces sont documentées dans :ref:"
"`abstract`."

#: extending/newtypes.rst:414
msgid ""
"A number of these abstract interfaces were defined early in the development "
"of the Python implementation.  In particular, the number, mapping, and "
"sequence protocols have been part of Python since the beginning.  Other "
"protocols have been added over time.  For protocols which depend on several "
"handler routines from the type implementation, the older protocols have been "
"defined as optional blocks of handlers referenced by the type object.  For "
"newer protocols there are additional slots in the main type object, with a "
"flag bit being set to indicate that the slots are present and should be "
"checked by the interpreter.  (The flag bit does not indicate that the slot "
"values are non-``NULL``. The flag may be set to indicate the presence of a "
"slot, but a slot may still be unfilled.) ::"
msgstr ""
"Un certain nombre de ces interfaces abstraites ont été définies au début du "
"développement de l'implémentation Python. En particulier, les protocoles de "
"nombre, de correspondance et de séquence font partie de Python depuis le "
"début. D'autres protocoles ont été ajoutés au fil du temps. Pour les "
"protocoles qui dépendent de plusieurs routines de gestionnaire de "
"l'implémentation du type, les anciens protocoles ont été définis comme des "
"blocs facultatifs de gestionnaires référencés par l'objet type. Pour les "
"protocoles plus récents, il existe des emplacements supplémentaires dans "
"l'objet de type principal, avec un bit d'indicateur défini pour indiquer que "
"les emplacements sont présents et doivent être vérifiés par l'interpréteur "
"(le bit d'indicateur n'indique pas que les valeurs d'emplacement ne sont pas "
"``NULL`` ; il peut être défini pour indiquer la présence d'un emplacement, "
"mais un emplacement peut toujours être vide). ::"

#: extending/newtypes.rst:425
msgid ""
"PyNumberMethods   *tp_as_number;\n"
"PySequenceMethods *tp_as_sequence;\n"
"PyMappingMethods  *tp_as_mapping;"
msgstr ""

#: extending/newtypes.rst:429
msgid ""
"If you wish your object to be able to act like a number, a sequence, or a "
"mapping object, then you place the address of a structure that implements "
"the C type :c:type:`PyNumberMethods`, :c:type:`PySequenceMethods`, or :c:"
"type:`PyMappingMethods`, respectively. It is up to you to fill in this "
"structure with appropriate values. You can find examples of the use of each "
"of these in the :file:`Objects` directory of the Python source "
"distribution. ::"
msgstr ""
"Si vous souhaitez que votre objet puisse agir comme un nombre, une séquence "
"ou un tableau de correspondances, placez l'adresse d'une structure qui "
"implémente le type C :c:type:`PyNumberMethods`, :c:type:`PySequenceMethods` "
"ou :c:type:`PyMappingMethods`, respectivement. C'est à vous de remplir cette "
"structure avec les valeurs appropriées. Vous pouvez trouver des exemples "
"d'utilisation de chacun d'entre eux dans le répertoire :file:`Objects` de la "
"distribution source de Python. ::"

#: extending/newtypes.rst:436
msgid "hashfunc tp_hash;"
msgstr ""

#: extending/newtypes.rst:438
msgid ""
"This function, if you choose to provide it, should return a hash number for "
"an instance of your data type. Here is a simple example::"
msgstr ""
"Cette fonction, si vous la fournissez, doit renvoyer un condensat pour une "
"instance de votre type de données. Voici un exemple simple ::"

#: extending/newtypes.rst:441
msgid ""
"static Py_hash_t\n"
"newdatatype_hash(newdatatypeobject *obj)\n"
"{\n"
"    Py_hash_t result;\n"
"    result = obj->some_size + 32767 * obj->some_number;\n"
"    if (result == -1)\n"
"       result = -2;\n"
"    return result;\n"
"}"
msgstr ""

#: extending/newtypes.rst:451
#, fuzzy
msgid ""
":c:type:`!Py_hash_t` is a signed integer type with a platform-varying width. "
"Returning ``-1`` from :c:member:`~PyTypeObject.tp_hash` indicates an error, "
"which is why you should be careful to avoid returning it when hash "
"computation is successful, as seen above."
msgstr ""
":c:type:`Py_hash_t` est un type entier signé avec une largeur variable selon "
"la plate-forme. Renvoyer ``-1`` pour :c:member:`~PyTypeObject.tp_hash` "
"indique une erreur, c'est pourquoi vous devez faire attention à ne pas le "
"renvoyer lorsque le calcul du hachage est réussi, comme vu ci-dessus."

#: extending/newtypes.rst:458
msgid "ternaryfunc tp_call;"
msgstr ""

#: extending/newtypes.rst:460
msgid ""
"This function is called when an instance of your data type is \"called\", "
"for example, if ``obj1`` is an instance of your data type and the Python "
"script contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call` "
"handler is invoked."
msgstr ""
"Cette fonction est appelée lorsqu'une instance de votre type de données est "
"« appelée », par exemple, si ``obj1`` est une instance de votre type de "
"données et que le script Python contient ``obj1('hello')``, le gestionnaire :"
"c:member:`~PyTypeObject.tp_call` est appelé."

#: extending/newtypes.rst:464
msgid "This function takes three arguments:"
msgstr "Cette fonction prend trois arguments :"

#: extending/newtypes.rst:466
msgid ""
"*self* is the instance of the data type which is the subject of the call. If "
"the call is ``obj1('hello')``, then *self* is ``obj1``."
msgstr ""
"*self* est l'instance du type de données qui fait l'objet de l'appel. Si "
"l'appel est ``obj1('hello')``, alors *self* est ``obj1``."

#: extending/newtypes.rst:469
msgid ""
"*args* is a tuple containing the arguments to the call.  You can use :c:func:"
"`PyArg_ParseTuple` to extract the arguments."
msgstr ""
"*args* est un *n*-uplet contenant les arguments de l'appel. Vous pouvez "
"utiliser :c:func:`PyArg_ParseTuple` pour extraire les arguments."

#: extending/newtypes.rst:472
msgid ""
"*kwds* is a dictionary of keyword arguments that were passed. If this is non-"
"``NULL`` and you support keyword arguments, use :c:func:"
"`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you do not want "
"to support keyword arguments and this is non-``NULL``, raise a :exc:"
"`TypeError` with a message saying that keyword arguments are not supported."
msgstr ""
"*kwds* est le dictionnaire d'arguments nommés qui ont été passés. Si ce "
"n'est pas ``NULL`` et que vous gérez les arguments nommés, utilisez :c:func:"
"`PyArg_ParseTupleAndKeywords` pour extraire les arguments. Si vous ne "
"souhaitez pas prendre en charge les arguments nommés et qu'il n'est pas "
"``NULL``, levez une :exc:`TypeError` avec un message indiquant que les "
"arguments nommés ne sont pas pris en charge."

#: extending/newtypes.rst:478
msgid "Here is a toy ``tp_call`` implementation::"
msgstr "Ceci est une implémentation ``tp_call`` très simple ::"

#: extending/newtypes.rst:480
msgid ""
"static PyObject *\n"
"newdatatype_call(newdatatypeobject *obj, PyObject *args, PyObject *kwds)\n"
"{\n"
"    PyObject *result;\n"
"    const char *arg1;\n"
"    const char *arg2;\n"
"    const char *arg3;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"sss:call\", &arg1, &arg2, &arg3)) {\n"
"        return NULL;\n"
"    }\n"
"    result = PyUnicode_FromFormat(\n"
"        \"Returning -- value: [%d] arg1: [%s] arg2: [%s] arg3: [%s]\\n\",\n"
"        obj->obj_UnderlyingDatatypePtr->size,\n"
"        arg1, arg2, arg3);\n"
"    return result;\n"
"}"
msgstr ""

#: extending/newtypes.rst:500
msgid ""
"/* Iterators */\n"
"getiterfunc tp_iter;\n"
"iternextfunc tp_iternext;"
msgstr ""

#: extending/newtypes.rst:504
#, fuzzy
msgid ""
"These functions provide support for the iterator protocol.  Both handlers "
"take exactly one parameter, the instance for which they are being called, "
"and return a new reference.  In the case of an error, they should set an "
"exception and return ``NULL``.  :c:member:`~PyTypeObject.tp_iter` "
"corresponds to the Python :meth:`~object.__iter__` method, while :c:member:"
"`~PyTypeObject.tp_iternext` corresponds to the Python :meth:`~iterator."
"__next__` method."
msgstr ""
"Ces fonctions prennent en charge le protocole itérateur. Les deux "
"gestionnaires prennent exactement un paramètre, l'instance pour laquelle ils "
"sont appelés, et renvoient une nouvelle référence. En cas d'erreur, ils "
"doivent définir une exception et renvoyer ``NULL``. :c:member:`~PyTypeObject."
"tp_iter` correspond à la méthode Python :meth:`__iter__`, tandis que :c:"
"member:`~PyTypeObject.tp_iternext` correspond à la méthode Python :meth:"
"`~iterator.__next__`."

#: extending/newtypes.rst:511
msgid ""
"Any :term:`iterable` object must implement the :c:member:`~PyTypeObject."
"tp_iter` handler, which must return an :term:`iterator` object.  Here the "
"same guidelines apply as for Python classes:"
msgstr ""
"Tout objet :term:`iterable` doit implémenter le gestionnaire :c:member:"
"`~PyTypeObject.tp_iter`, qui doit renvoyer un objet de type :term:"
"`iterator`.  Ici, les mêmes directives s'appliquent de la même façon que "
"pour les classes *Python* :"

#: extending/newtypes.rst:515
msgid ""
"For collections (such as lists and tuples) which can support multiple "
"independent iterators, a new iterator should be created and returned by each "
"call to :c:member:`~PyTypeObject.tp_iter`."
msgstr ""
"Pour les collections (telles que les listes et les n-uplets) qui peuvent "
"implémenter plusieurs itérateurs indépendants, un nouvel itérateur doit être "
"créé et renvoyé par chaque appel de type :c:member:`~PyTypeObject.tp_iter`."

#: extending/newtypes.rst:518
msgid ""
"Objects which can only be iterated over once (usually due to side effects of "
"iteration, such as file objects) can implement :c:member:`~PyTypeObject."
"tp_iter` by returning a new reference to themselves -- and should also "
"therefore implement the :c:member:`~PyTypeObject.tp_iternext`  handler."
msgstr ""
"Les objets qui ne peuvent être itérés qu'une seule fois (généralement en "
"raison d'effets de bord de l'itération, tels que les objets fichiers) "
"peuvent implémenter :c:member:`~PyTypeObject.tp_iter` en renvoyant une "
"nouvelle référence à eux-mêmes – et doivent donc également implémenter le "
"gestionnaire :c:member:`~PyTypeObject.tp_iternext`."

#: extending/newtypes.rst:523
msgid ""
"Any :term:`iterator` object should implement both :c:member:`~PyTypeObject."
"tp_iter` and :c:member:`~PyTypeObject.tp_iternext`.  An iterator's :c:member:"
"`~PyTypeObject.tp_iter` handler should return a new reference to the "
"iterator.  Its :c:member:`~PyTypeObject.tp_iternext` handler should return a "
"new reference to the next object in the iteration, if there is one. If the "
"iteration has reached the end, :c:member:`~PyTypeObject.tp_iternext` may "
"return ``NULL`` without setting an exception, or it may set :exc:"
"`StopIteration` *in addition* to returning ``NULL``; avoiding the exception "
"can yield slightly better performance.  If an actual error occurs, :c:member:"
"`~PyTypeObject.tp_iternext` should always set an exception and return "
"``NULL``."
msgstr ""
"Tout objet :term:`itérateur <iterator>` doit implémenter à la fois :c:member:"
"`~PyTypeObject.tp_iter` et :c:member:`~PyTypeObject.tp_iternext`. Le "
"gestionnaire :c:member:`~PyTypeObject.tp_iter` d'un itérateur doit renvoyer "
"une nouvelle référence de l'itérateur. Son gestionnaire :c:member:"
"`~PyTypeObject.tp_iternext` doit renvoyer une nouvelle référence à l'objet "
"suivant dans l'itération, s'il y en a un. Si l'itération a atteint la fin, :"
"c:member:`~PyTypeObject.tp_iternext` peut renvoyer ``NULL`` sans définir "
"d'exception, ou il peut définir :exc:`StopIteration` *en plus* de renvoyer "
"``NULL`` ; éviter de lever une exception peut donner des performances "
"légèrement meilleures. Si une erreur réelle se produit, :c:member:"
"`~PyTypeObject.tp_iternext` doit toujours définir une exception et renvoyer "
"``NULL``."

#: extending/newtypes.rst:539
msgid "Weak Reference Support"
msgstr "Prise en charge de la référence faible"

#: extending/newtypes.rst:541
msgid ""
"One of the goals of Python's weak reference implementation is to allow any "
"type to participate in the weak reference mechanism without incurring the "
"overhead on performance-critical objects (such as numbers)."
msgstr ""
"L'un des objectifs de l'implémentation de la référence faible de *Python* "
"est de permettre à tout type d'objet de participer au mécanisme de référence "
"faible sans avoir à supporter le surcoût de la performance critique des "
"certains objets, tels que les nombres."

# suit un :
#: extending/newtypes.rst:546
msgid "Documentation for the :mod:`weakref` module."
msgstr "documentation pour le module :mod:`weakref`."

#: extending/newtypes.rst:548
msgid ""
"For an object to be weakly referenceable, the extension type must set the "
"``Py_TPFLAGS_MANAGED_WEAKREF`` bit of the :c:member:`~PyTypeObject.tp_flags` "
"field. The legacy :c:member:`~PyTypeObject.tp_weaklistoffset` field should "
"be left as zero."
msgstr ""

#: extending/newtypes.rst:553
#, fuzzy
msgid ""
"Concretely, here is how the statically declared type object would look::"
msgstr ""
"Et le membre correspondant dans l'objet de type déclaré statiquement ::"

#: extending/newtypes.rst:555
msgid ""
"static PyTypeObject TrivialType = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    /* ... other members omitted for brevity ... */\n"
"    .tp_flags = Py_TPFLAGS_MANAGED_WEAKREF | ...,\n"
"};"
msgstr ""

#: extending/newtypes.rst:562
#, fuzzy
msgid ""
"The only further addition is that ``tp_dealloc`` needs to clear any weak "
"references (by calling :c:func:`PyObject_ClearWeakRefs`)::"
msgstr ""
"Le seul ajout supplémentaire est que ``tp_dealloc`` doit effacer toute "
"référence faible (en appelant :c:func:`PyObject_ClearWeakRefs`) si le champ "
"est non ``NULL`` ::"

#: extending/newtypes.rst:565
msgid ""
"static void\n"
"Trivial_dealloc(TrivialObject *self)\n"
"{\n"
"    /* Clear weakrefs first before calling any destructors */\n"
"    PyObject_ClearWeakRefs((PyObject *) self);\n"
"    /* ... remainder of destruction code omitted for brevity ... */\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}"
msgstr ""

#: extending/newtypes.rst:576
msgid "More Suggestions"
msgstr "Plus de suggestions"

#: extending/newtypes.rst:578
msgid ""
"In order to learn how to implement any specific method for your new data "
"type, get the :term:`CPython` source code.  Go to the :file:`Objects` "
"directory, then search the C source files for ``tp_`` plus the function you "
"want (for example, ``tp_richcompare``).  You will find examples of the "
"function you want to implement."
msgstr ""
"Pour savoir comment mettre en œuvre une méthode spécifique pour votre "
"nouveau type de données, téléchargez le code source :term:`CPython`. Allez "
"dans le répertoire :file:`Objects`, puis cherchez dans les fichiers sources "
"*C* la fonction ``tp_`` plus la fonction que vous voulez (par exemple, "
"``tp_richcompare``). Vous trouverez des exemples de la fonction que vous "
"voulez implémenter."

#: extending/newtypes.rst:584
msgid ""
"When you need to verify that an object is a concrete instance of the type "
"you are implementing, use the :c:func:`PyObject_TypeCheck` function.  A "
"sample of its use might be something like the following::"
msgstr ""
"Lorsque vous avez besoin de vérifier qu'un objet est une instance concrète "
"du type que vous implémentez, utilisez la fonction :c:func:"
"`PyObject_TypeCheck`. Voici un exemple de son utilisation ::"

#: extending/newtypes.rst:588
msgid ""
"if (!PyObject_TypeCheck(some_object, &MyType)) {\n"
"    PyErr_SetString(PyExc_TypeError, \"arg #1 not a mything\");\n"
"    return NULL;\n"
"}"
msgstr ""

#: extending/newtypes.rst:594
msgid "Download CPython source releases."
msgstr "Télécharger les versions sources de *CPython*."

#: extending/newtypes.rst:595
msgid "https://www.python.org/downloads/source/"
msgstr "https://www.python.org/downloads/source/"

#: extending/newtypes.rst:597
msgid ""
"The CPython project on GitHub, where the CPython source code is developed."
msgstr ""
"Le projet *CPython* sur *GitHub*, où se trouve le code source *CPython*."

#: extending/newtypes.rst:598
msgid "https://github.com/python/cpython"
msgstr "https://github.com/python/cpython"

#: extending/newtypes.rst:56
msgid "object"
msgstr "objet"

#: extending/newtypes.rst:56
msgid "deallocation"
msgstr "libération de mémoire"

#: extending/newtypes.rst:56
msgid "deallocation, object"
msgstr "libération de mémoire, objet"

#: extending/newtypes.rst:56
msgid "finalization"
msgstr "finalisation"

#: extending/newtypes.rst:56
msgid "finalization, of objects"
msgstr "finalisation, d'objets"

#: extending/newtypes.rst:91
msgid "PyErr_Fetch (C function)"
msgstr "PyErr_Fetch (C function)"

#: extending/newtypes.rst:91
msgid "PyErr_Restore (C function)"
msgstr "PyErr_Restore (C function)"

#: extending/newtypes.rst:150
msgid "string"
msgstr "chaîne"

#: extending/newtypes.rst:150
msgid "object representation"
msgstr "Représentation de l'objet"

#: extending/newtypes.rst:150
msgid "built-in function"
msgstr "fonction native"

#: extending/newtypes.rst:150
msgid "repr"
msgstr "repr"

#~ msgid ""
#~ "The following flag constants are defined in :file:`structmember.h`; they "
#~ "may be combined using bitwise-OR."
#~ msgstr ""
#~ "Les constantes de drapeaux suivantes sont définies dans :file:"
#~ "`structmember.h` ; elles peuvent être combinées à l'aide du *OU* binaire."

#~ msgid "Constant"
#~ msgstr "Constante"

#~ msgid "Meaning"
#~ msgstr "Signification"

#~ msgid ":const:`READONLY`"
#~ msgstr ":const:`READONLY`"

#~ msgid "Never writable."
#~ msgstr "Jamais disponible en écriture."

#~ msgid ":const:`PY_AUDIT_READ`"
#~ msgstr ":const:`PY_AUDIT_READ`"

#~ msgid ""
#~ "Emit an ``object.__getattr__`` :ref:`audit events <audit-events>` before "
#~ "reading."
#~ msgstr ""
#~ "Émet un :ref:`événement d'audit <audit-events>` ``object.__getattr__`` "
#~ "avant la lecture."

#~ msgid ""
#~ ":const:`RESTRICTED`, :const:`READ_RESTRICTED` and :const:"
#~ "`WRITE_RESTRICTED` are deprecated. However, :const:`READ_RESTRICTED` is "
#~ "an alias for :const:`PY_AUDIT_READ`, so fields that specify either :const:"
#~ "`RESTRICTED` or :const:`READ_RESTRICTED` will also raise an audit event."
#~ msgstr ""
#~ ":const:`RESTRICTED`, :const:`READ_RESTRICTED` et :const:"
#~ "`WRITE_RESTRICTED` sont obsolètes. Cependant, :const:`READ_RESTRICTED` "
#~ "est un alias pour :const:`PY_AUDIT_READ`, donc les champs qui spécifient :"
#~ "const:`RESTRICTED` ou :const:`READ_RESTRICTED` déclenchent également un "
#~ "événement d'audit."

#~ msgid ""
#~ "For an object to be weakly referencable, the extension type must do two "
#~ "things:"
#~ msgstr ""
#~ "Pour qu'un objet soit faiblement référençable, le type d'extension doit "
#~ "faire deux choses :"

# énumération
#~ msgid ""
#~ "Include a :c:expr:`PyObject*` field in the C object structure dedicated "
#~ "to the weak reference mechanism.  The object's constructor should leave "
#~ "it ``NULL`` (which is automatic when using the default :c:member:"
#~ "`~PyTypeObject.tp_alloc`)."
#~ msgstr ""
#~ "inclure un champ :c:expr:`PyObject*` dans la structure d'objet C dédiée "
#~ "au mécanisme de référence faible. Le constructeur de l'objet doit le "
#~ "laisser à la valeur ``NULL`` (ce qui est automatique lorsque l'on utilise "
#~ "le champ par défaut :c:member:`~PyTypeObject.tp_alloc`) ;"

# énumération
#~ msgid ""
#~ "Set the :c:member:`~PyTypeObject.tp_weaklistoffset` type member to the "
#~ "offset of the aforementioned field in the C object structure, so that the "
#~ "interpreter knows how to access and modify that field."
#~ msgstr ""
#~ "définir le membre de type :c:member:`~PyTypeObject.tp_weaklistoffset` à "
#~ "la valeur de décalage (*offset*) du champ susmentionné dans la structure "
#~ "de l'objet *C*, afin que l'interpréteur sache comment accéder à ce champ "
#~ "et le modifier."

#~ msgid ""
#~ "Concretely, here is how a trivial object structure would be augmented "
#~ "with the required field::"
#~ msgstr ""
#~ "Concrètement, voici comment une structure d'objet simple serait complétée "
#~ "par le champ requis ::"

#~ msgid "READONLY"
#~ msgstr ":const:`READONLY`"

#~ msgid "READ_RESTRICTED"
#~ msgstr ":const:`READ_RESTRICTED`"

#~ msgid "WRITE_RESTRICTED"
#~ msgstr ":const:`WRITE_RESTRICTED`"

#~ msgid "RESTRICTED"
#~ msgstr ":const:`RESTRICTED`"

#~ msgid "PY_AUDIT_READ"
#~ msgstr ":const:`PY_AUDIT_READ`"

#~ msgid "Not readable in restricted mode."
#~ msgstr "Non disponible en lecture, dans le mode restreint."

#~ msgid "Not writable in restricted mode."
#~ msgstr "Non disponible en écriture dans le mode restreint."

#~ msgid "Not readable or writable in restricted mode."
#~ msgstr "Non disponible en lecture ou écriture, en mode restreint."
