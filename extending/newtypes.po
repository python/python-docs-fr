# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-09-23 16:16+0200\n"
"PO-Revision-Date: 2021-02-07 20:03+0100\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.3\n"
"Last-Translator: \n"

#: extending/newtypes.rst:7
msgid "Defining Extension Types: Assorted Topics"
msgstr "Définir les types d'extension : divers sujets"

#: extending/newtypes.rst:11
msgid ""
"This section aims to give a quick fly-by on the various type methods you can "
"implement and what they do."
msgstr ""
"Cette section a pour but de donner un aperçu rapide des différentes méthodes "
"de type que vous pouvez mettre en œuvre et de ce qu'elles font."

#: extending/newtypes.rst:14
msgid ""
"Here is the definition of :c:type:`PyTypeObject`, with some fields only used "
"in :ref:`debug builds <debug-build>` omitted:"
msgstr ""
"Voici comment on définit :c:type:`PyTypeObject`, sans les champs spécifiques "
"aux compilations de débogage :"

#: extending/newtypes.rst:20
msgid ""
"Now that's a *lot* of methods.  Don't worry too much though -- if you have a "
"type you want to define, the chances are very good that you will only "
"implement a handful of these."
msgstr ""
"Il y a *beaucoup* de méthodes pré-définies. Mais ne vous inquiétez pas "
"trop : si vous avez besoin de définir un nouveau type, il y a de fortes "
"chances que vous ne mettiez en œuvre que très peu de méthodes spécifiques."

#: extending/newtypes.rst:24
msgid ""
"As you probably expect by now, we're going to go over this and give more "
"information about the various handlers.  We won't go in the order they are "
"defined in the structure, because there is a lot of historical baggage that "
"impacts the ordering of the fields.  It's often easiest to find an example "
"that includes the fields you need and then change the values to suit your "
"new type. ::"
msgstr ""
"Comme vous vous en doutez probablement maintenant, nous allons passer cela "
"en revue et vous donner plus d'informations sur les différentes méthodes. "
"Nous n'allons pas suivre l'ordre dans lequel elles sont définis dans la "
"structure, parce beaucoup d'informations préliminaires peuvent avoir un "
"impact sur l'ordre des champs. Il est souvent plus facile de trouver un "
"exemple qui inclut les champs dont vous avez besoin et de modifier les "
"valeurs en fonction de votre nouveau type. ::"

#: extending/newtypes.rst:33
msgid ""
"The name of the type -- as mentioned in the previous chapter, this will "
"appear in various places, almost entirely for diagnostic purposes. Try to "
"choose something that will be helpful in such a situation! ::"
msgstr ""
"Le nom du type -- comme mentionné dans le chapitre précédent, il apparaîtra "
"à divers endroits, dans la plupart de cas à des fins de diagnostic. Essayez "
"de choisir quelque chose qui vous sera utile dans une telle situation ! ::"

#: extending/newtypes.rst:39
msgid ""
"These fields tell the runtime how much memory to allocate when new objects "
"of this type are created.  Python has some built-in support for variable "
"length structures (think: strings, tuples) which is where the :c:member:"
"`~PyTypeObject.tp_itemsize` field comes in.  This will be dealt with "
"later. ::"
msgstr ""
"Ces champs indiquent au *runtime* la quantité de mémoire à allouer lorsque "
"de nouveaux objets de ce type sont créés. *Python* a une implémentation "
"intégrée pour les structures de longueur variable (par exemple les chaînes "
"de caractères ou les *n*-uplets), et c'est là qu'intervient le champ :c:member:"
"`~PyTypeObject.tp_itemsize`.  Ce sujet sera traité plus tard. ::"

#: extending/newtypes.rst:46
msgid ""
"Here you can put a string (or its address) that you want returned when the "
"Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr ""
"Ici vous pouvez mettre une chaîne (ou son adresse) que vous voulez renvoyer "
"lorsque le script Python référence ``obj.__doc__`` pour récupérer la "
"*docstring*."

#: extending/newtypes.rst:49
msgid ""
"Now we come to the basic type methods -- the ones most extension types will "
"implement."
msgstr ""
"Nous en arrivons maintenant aux méthodes de type basiques -- celles que la "
"plupart des types d'extension mettront en œuvre."

#: extending/newtypes.rst:54
msgid "Finalization and De-allocation"
msgstr "Finalisation et de-allocation"

#: extending/newtypes.rst:66
msgid ""
"This function is called when the reference count of the instance of your "
"type is reduced to zero and the Python interpreter wants to reclaim it.  If "
"your type has memory to free or other clean-up to perform, you can put it "
"here.  The object itself needs to be freed here as well.  Here is an example "
"of this function::"
msgstr ""
"Cette fonction est appelée lorsque le nombre de références de l'instance de "
"votre type est réduit à zéro et que l'interpréteur *Python* veut le "
"récupérer. Si votre type a de la mémoire à libérer ou un autre nettoyage à "
"effectuer, vous pouvez le mettre ici. L'objet lui-même doit être libéré ici "
"aussi. Voici un exemple de cette fonction ::"

#: extending/newtypes.rst:83
msgid ""
"One important requirement of the deallocator function is that it leaves any "
"pending exceptions alone.  This is important since deallocators are "
"frequently called as the interpreter unwinds the Python stack; when the "
"stack is unwound due to an exception (rather than normal returns), nothing "
"is done to protect the deallocators from seeing that an exception has "
"already been set.  Any actions which a deallocator performs which may cause "
"additional Python code to be executed may detect that an exception has been "
"set.  This can lead to misleading errors from the interpreter.  The proper "
"way to protect against this is to save a pending exception before performing "
"the unsafe action, and restoring it when done.  This can be done using the :"
"c:func:`PyErr_Fetch` and :c:func:`PyErr_Restore` functions::"
msgstr ""
"Une exigence importante de la fonction *deallocator* est qu'elle ignore "
"toute exception. Ceci est important, car les *deallocators* sont fréquemment "
"appelés lorsque l'interpréteur déroule la pile *Python* ; lorsque la pile "
"est déroulée en raison d'une exception (plutôt que des retours normaux), "
"rien n'est fait pour protéger les *deallocators* de voir qu'une exception a "
"déjà été définie. Toute action effectuée par un *deallocator* qui pourrait "
"entraîner l'exécution de code *Python* supplémentaire peut détecter qu'une "
"exception a été définie. Cela peut conduire à des erreurs trompeuses de la "
"part de l'interpréteur. La bonne façon de se protéger contre cela est de "
"sauvegarder une exception en attente avant d'exécuter l'action dangereuse, "
"et de la restaurer lorsqu'elle est terminée. Cela peut être fait en "
"utilisant les fonctions :c:func:`PyErr_Fetch` et :c:func:`PyErr_Restore` ::"

#: extending/newtypes.rst:122
msgid ""
"There are limitations to what you can safely do in a deallocator function. "
"First, if your type supports garbage collection (using :c:member:"
"`~PyTypeObject.tp_traverse` and/or :c:member:`~PyTypeObject.tp_clear`), some "
"of the object's members can have been cleared or finalized by the time :c:"
"member:`~PyTypeObject.tp_dealloc` is called.  Second, in :c:member:"
"`~PyTypeObject.tp_dealloc`, your object is in an unstable state: its "
"reference count is equal to zero.  Any call to a non-trivial object or API "
"(as in the example above) might end up calling :c:member:`~PyTypeObject."
"tp_dealloc` again, causing a double free and a crash."
msgstr ""
"Il y a des limites par rapport à ce qu'on peut faire en toute sécurité dans "
"une fonction de *deallocator*. Tout d'abord, si votre type implémente le "
"ramasse-miettes (en utilisant :c:member:`~PyTypeObject.tp_traverse` et/ou :c:"
"member:`~PyTypeObject.tp_clear`), certains des membres de l'objet peuvent "
"avoir été effacés ou finalisés au moment où :c:member:`~PyTypeObject."
"tp_dealloc` est appelé.  Ensuite, dans :c:member:`~PyTypeObject.tp_dealloc`, "
"votre objet est dans un état instable : son compte de référence est égal à "
"zéro. Tout appel à un objet ou à une API plus complexe (comme dans l'exemple "
"ci-dessus) pourrait finir par appeler à nouveau :c:member:`~PyTypeObject."
"tp_dealloc`, provoquant à la fois un *free* et une panne."

#: extending/newtypes.rst:131
msgid ""
"Starting with Python 3.4, it is recommended not to put any complex "
"finalization code in :c:member:`~PyTypeObject.tp_dealloc`, and instead use "
"the new :c:member:`~PyTypeObject.tp_finalize` type method."
msgstr ""
"À partir de *Python 3.4*, il est recommandé de ne pas mettre de code de "
"finalisation complexe dans :c:member:`~PyTypeObject.tp_dealloc`, et "
"d'utiliser à la place la nouvelle méthode de type :c:member:`~PyTypeObject."
"tp_finalize`."

#: extending/newtypes.rst:136
msgid ":pep:`442` explains the new finalization scheme."
msgstr ":pep:`442` explique le nouveau schéma de finalisation."

#: extending/newtypes.rst:143
msgid "Object Presentation"
msgstr "Présentation de l'objet"

#: extending/newtypes.rst:145
msgid ""
"In Python, there are two ways to generate a textual representation of an "
"object: the :func:`repr` function, and the :func:`str` function.  (The :func:"
"`print` function just calls :func:`str`.)  These handlers are both optional."
msgstr ""
"En *Python*, il y a deux façons de générer une représentation textuelle d'un "
"objet : la fonction :func:`repr` et la fonction :func:`str`.  (La fonction :"
"func:`print` appelle simplement :func:`str`.) Les deux gestionnaires sont "
"optionnels."

#: extending/newtypes.rst:154
msgid ""
"The :c:member:`~PyTypeObject.tp_repr` handler should return a string object "
"containing a representation of the instance for which it is called.  Here is "
"a simple example::"
msgstr ""
"Le gestionnaire :c:member:`~PyTypeObject.tp_repr` doit renvoyer un objet de "
"type chaîne de caractères contenant une représentation de l'instance pour "
"laquelle il est appelé. Voici un exemple simple ::"

#: extending/newtypes.rst:165
msgid ""
"If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the "
"interpreter will supply a representation that uses the type's :c:member:"
"`~PyTypeObject.tp_name` and a uniquely-identifying value for the object."
msgstr ""
"Si aucun gestionnaire :c:member:`~PyTypeObject.tp_repr` n'est spécifié, "
"l'interpréteur fournira une représentation qui utilise le type :c:member:"
"`~PyTypeObject.tp_name` et une valeur d'identification unique pour l'objet."

#: extending/newtypes.rst:169
msgid ""
"The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the :c:"
"member:`~PyTypeObject.tp_repr` handler described above is to :func:`repr`; "
"that is, it is called when Python code calls :func:`str` on an instance of "
"your object.  Its implementation is very similar to the :c:member:"
"`~PyTypeObject.tp_repr` function, but the resulting string is intended for "
"human consumption.  If :c:member:`~PyTypeObject.tp_str` is not specified, "
"the :c:member:`~PyTypeObject.tp_repr` handler is used instead."
msgstr ""
"Le gestionnaire :c:member:`~PyTypeObject.tp_str` est à :func:`str` ce que le "
"gestionnaire :c:member:`~PyTypeObject.tp_repr` décrit ci-dessus est à :func:"
"`repr`. C'est-à-dire qu'il est appelé lorsque du code *Python* appelle :func:"
"`str` sur une instance de votre objet. Son implémentation est très similaire "
"à la fonction :c:member:`~PyTypeObject.tp_repr`, mais la chaîne de "
"caractères résultante est destinée à la compréhension humaine. Si :c:member:"
"`~PyTypeObject.tp_str` n'est pas spécifié, le gestionnaire :c:member:"
"`~PyTypeObject.tp_repr` est utilisé à la place."

#: extending/newtypes.rst:176
msgid "Here is a simple example::"
msgstr "Voici un exemple simple ::"

#: extending/newtypes.rst:188
msgid "Attribute Management"
msgstr "Gestion des attributs"

#: extending/newtypes.rst:190
msgid ""
"For every object which can support attributes, the corresponding type must "
"provide the functions that control how the attributes are resolved.  There "
"needs to be a function which can retrieve attributes (if any are defined), "
"and another to set attributes (if setting attributes is allowed).  Removing "
"an attribute is a special case, for which the new value passed to the "
"handler is ``NULL``."
msgstr ""
"Pour chaque objet qui permet d'implémenter des attributs, le type "
"correspondant doit fournir les fonctions qui contrôlent la manière dont les "
"attributs soient résolus. Il doit y avoir une fonction qui peut récupérer "
"les attributs (s'ils sont définis), et une autre pour définir les attributs "
"(si la définition des attributs est autorisée). La suppression d'un attribut "
"est un cas particulier, pour lequel la nouvelle valeur transmise au "
"gestionnaire est ``NULL``."

#: extending/newtypes.rst:196
msgid ""
"Python supports two pairs of attribute handlers; a type that supports "
"attributes only needs to implement the functions for one pair.  The "
"difference is that one pair takes the name of the attribute as a :c:type:"
"`char\\*`, while the other accepts a :c:type:`PyObject\\*`.  Each type can "
"use whichever pair makes more sense for the implementation's convenience. ::"
msgstr ""
"*Python* implémente deux paires de gestionnaires d'attributs ; un type qui "
"implémente les attributs n'a besoin d'implémenter les fonctions que pour une "
"seule paire. La différence est qu'une paire prend le nom de l'attribut comme "
"un :c:type:`char\\*`, alors que l'autre accepte un :c:type:`PyObject\\*`. "
"Chaque type peut utiliser la paire la plus logique pour la facilité de "
"l'implémentation. ::"

#: extending/newtypes.rst:208
msgid ""
"If accessing attributes of an object is always a simple operation (this will "
"be explained shortly), there are generic implementations which can be used "
"to provide the :c:type:`PyObject\\*` version of the attribute management "
"functions. The actual need for type-specific attribute handlers almost "
"completely disappeared starting with Python 2.2, though there are many "
"examples which have not been updated to use some of the new generic "
"mechanism that is available."
msgstr ""
"Si l'accès aux attributs d'un objet est toujours une opération simple (ceci "
"sera expliqué prochainement), il existe des implémentations génériques qui "
"peuvent être utilisées pour fournir la version :c:type:`PyObject\\*` des "
"fonctions de gestion des attributs. Le besoin réel des gestionnaires "
"d'attributs spécifiques au type a presque complètement disparu à partir de "
"Python 2.2, bien qu'il existe de nombreux exemples qui n'ont pas été mis à "
"jour pour utiliser certains des nouveaux mécanismes génériques disponibles."

#: extending/newtypes.rst:219
msgid "Generic Attribute Management"
msgstr "Gestion des attributs génériques"

#: extending/newtypes.rst:221
msgid ""
"Most extension types only use *simple* attributes.  So, what makes the "
"attributes simple?  There are only a couple of conditions that must be met:"
msgstr ""
"La plupart des types d'extension n'utilisent que des attributs *simples*.  "
"Alors, qu'est-ce qui rend les attributs simples ?  Il y a seulement quelques "
"conditions qui doivent être remplies :"

#: extending/newtypes.rst:224
msgid ""
"The name of the attributes must be known when :c:func:`PyType_Ready` is "
"called."
msgstr ""
"Le nom des attributs doivent être déjà connus lorsqu'on lance :c:func:"
"`PyType_Ready`."

#: extending/newtypes.rst:227
msgid ""
"No special processing is needed to record that an attribute was looked up or "
"set, nor do actions need to be taken based on the value."
msgstr ""
"Aucun traitement spécial n'est nécessaire pour enregistrer qu'un attribut a "
"été recherché ou défini, et aucune action ne doit être entreprise sur la "
"base de la valeur."

#: extending/newtypes.rst:230
msgid ""
"Note that this list does not place any restrictions on the values of the "
"attributes, when the values are computed, or how relevant data is stored."
msgstr ""
"Notez que cette liste n'impose aucune restriction quant aux valeurs des "
"attributs, au moment où les valeurs sont calculées, ou à la manière dont les "
"données pertinentes sont stockées."

#: extending/newtypes.rst:233
msgid ""
"When :c:func:`PyType_Ready` is called, it uses three tables referenced by "
"the type object to create :term:`descriptor`\\s which are placed in the "
"dictionary of the type object.  Each descriptor controls access to one "
"attribute of the instance object.  Each of the tables is optional; if all "
"three are ``NULL``, instances of the type will only have attributes that are "
"inherited from their base type, and should leave the :c:member:"
"`~PyTypeObject.tp_getattro` and :c:member:`~PyTypeObject.tp_setattro` fields "
"``NULL`` as well, allowing the base type to handle attributes."
msgstr ""
"Lorsqu'elle est lancée, la fonction :c:func:`PyType_Ready` utilise trois "
"tables référencées par l'objet type qui soit être créé, notamment les "
"instances :term:`descriptor` stockés dans le dictionnaire de l'objet type. "
"Chaque descripteur contrôle l’accès vers un seul attribut de l'instance. "
"Chacune des tables sont optionnelles. Si toutes les trois ont des valeurs "
"``NULL``, les instances du type doivent avoir des attributs hérités de leur "
"type de base, et les champs :c:member:`~PyTypeObject.tp_getattro` et :c:"
"member:`~PyTypeObject.tp_setattro` doivent avoir la valeur  ``NULL`` "
"également, afin de permettre au type de base de gérer des attributs."

#: extending/newtypes.rst:241
msgid "The tables are declared as three fields of the type object::"
msgstr ""
"Les tables sont déclarées sous la forme de trois champs de type objet ::"

#: extending/newtypes.rst:247
msgid ""
"If :c:member:`~PyTypeObject.tp_methods` is not ``NULL``, it must refer to an "
"array of :c:type:`PyMethodDef` structures.  Each entry in the table is an "
"instance of this structure::"
msgstr ""
"Si :c:member:`~PyTypeObject.tp_methods` n'est pas ``NULL``, il doit faire "
"référence à un tableau de structures :c:type:`PyMethodDef`. Chaque entrée du "
"tableau est une instance de cette structure ::"

#: extending/newtypes.rst:258
msgid ""
"One entry should be defined for each method provided by the type; no entries "
"are needed for methods inherited from a base type.  One additional entry is "
"needed at the end; it is a sentinel that marks the end of the array.  The :"
"attr:`ml_name` field of the sentinel must be ``NULL``."
msgstr ""
"Une entrée doit être définie pour chaque méthode fournie par le type ; "
"aucune entrée n'est nécessaire pour les méthodes héritées d'un type de base. "
"Une entrée supplémentaire est nécessaire à la fin ; il s'agit d'une "
"sentinelle qui marque la fin du tableau. Le champ :attr:`ml_name` de la "
"sentinelle doit être ``NULL``."

#: extending/newtypes.rst:263
msgid ""
"The second table is used to define attributes which map directly to data "
"stored in the instance.  A variety of primitive C types are supported, and "
"access may be read-only or read-write.  The structures in the table are "
"defined as::"
msgstr ""
"Le second tableau sert à définir les attributs qui correspondent directement "
"aux données stockées dans l'instance. Une grande partie de types primitifs "
"*C* sont pris en charge, et l'accès peut être en lecture seule ou en lecture-"
"écriture. Les structures de la table sont définies comme suit ::"

#: extending/newtypes.rst:275
msgid ""
"For each entry in the table, a :term:`descriptor` will be constructed and "
"added to the type which will be able to extract a value from the instance "
"structure.  The :attr:`type` field should contain one of the type codes "
"defined in the :file:`structmember.h` header; the value will be used to "
"determine how to convert Python values to and from C values.  The :attr:"
"`flags` field is used to store flags which control how the attribute can be "
"accessed."
msgstr ""
"Pour chaque entrée du tableau, un :term:`descriptor` sera construit et "
"ajouté au type, qui pourra extraire une valeur de la structure d'instance. "
"Le champ :attr:`type` doit contenir un des codes de type définis dans l'en-"
"tête :file:`structmember.h` ; la valeur sera utilisée pour déterminer "
"comment convertir les valeurs de type *Python* en valeurs de type *C* et "
"inversement.  Le champ :attr:`flags` est utilisé pour stocker des drapeaux "
"qui contrôlent la manière dont l'attribut peut être accédé."

#: extending/newtypes.rst:282
msgid ""
"The following flag constants are defined in :file:`structmember.h`; they may "
"be combined using bitwise-OR."
msgstr ""
"Les constantes de drapeau suivantes sont définies dans :file:`structmember."
"h`. Elles peuvent être combinées à l'aide d'un OU logique."

#: extending/newtypes.rst:286
msgid "Constant"
msgstr "Constante"

#: extending/newtypes.rst:286
msgid "Meaning"
msgstr "Signification"

#: extending/newtypes.rst:288
msgid ":const:`READONLY`"
msgstr ":const:`READONLY`"

#: extending/newtypes.rst:288
msgid "Never writable."
msgstr "Jamais disponible en écriture."

#: extending/newtypes.rst:290
#, fuzzy
msgid ":const:`PY_AUDIT_READ`"
msgstr ":const:`READONLY`"

#: extending/newtypes.rst:290
msgid ""
"Emit an ``object.__getattr__`` :ref:`audit events <audit-events>` before "
"reading."
msgstr ""

#: extending/newtypes.rst:295
msgid ""
":const:`RESTRICTED`, :const:`READ_RESTRICTED` and :const:`WRITE_RESTRICTED` "
"are deprecated. However, :const:`READ_RESTRICTED` is an alias for :const:"
"`PY_AUDIT_READ`, so fields that specify either :const:`RESTRICTED` or :const:"
"`READ_RESTRICTED` will also raise an audit event."
msgstr ""

#: extending/newtypes.rst:308
msgid ""
"An interesting advantage of using the :c:member:`~PyTypeObject.tp_members` "
"table to build descriptors that are used at runtime is that any attribute "
"defined this way can have an associated doc string simply by providing the "
"text in the table.  An application can use the introspection API to retrieve "
"the descriptor from the class object, and get the doc string using its :attr:"
"`__doc__` attribute."
msgstr ""
"Un avantage intéressant de l'utilisation de la table :c:member:"
"`~PyTypeObject.tp_members` pour construire les descripteurs qui sont "
"utilisés à l'exécution, est que à tout attribut défini de cette façon on "
"peut associer une *docstring*, en écrivant simplement le texte dans la table. "
"Une application peut utiliser l'API d'introspection pour récupérer le "
"descripteur de l'objet de classe, et utiliser son attribut :attr:`__doc__` "
"pour renvoyer la *docstring*."

#: extending/newtypes.rst:314
msgid ""
"As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry "
"with a :attr:`name` value of ``NULL`` is required."
msgstr ""
"Comme pour la table :c:member:`~PyTypeObject.tp_methods`, une entrée "
"sentinelle avec une valeur :attr:`name` de ``NULL`` est requise."

#: extending/newtypes.rst:328
msgid "Type-specific Attribute Management"
msgstr "Gestion des attributs de type spécifiques"

#: extending/newtypes.rst:330
msgid ""
"For simplicity, only the :c:type:`char\\*` version will be demonstrated "
"here; the type of the name parameter is the only difference between the :c:"
"type:`char\\*` and :c:type:`PyObject\\*` flavors of the interface. This "
"example effectively does the same thing as the generic example above, but "
"does not use the generic support added in Python 2.2.  It explains how the "
"handler functions are called, so that if you do need to extend their "
"functionality, you'll understand what needs to be done."
msgstr ""
"Par souci de simplicité, seule la version :c:type:`char\\*` sera présentée "
"ici. Le type du paramètre nom est la seule différence entre les nuances :c:"
"type:`char\\*` et :c:type:`PyObject\\*` de l'interface. Cet exemple fait "
"effectivement la même chose que l'exemple générique ci-dessus, mais "
"n'utilise pas l'implémentation générique ajouté dans Python 2.2. Il explique "
"comment les fonctions du gestionnaire sont appelées, de sorte que si vous "
"avez besoin d'étendre leurs fonctionnalités, vous comprendrez ce qu'il faut "
"faire."

#: extending/newtypes.rst:338
msgid ""
"The :c:member:`~PyTypeObject.tp_getattr` handler is called when the object "
"requires an attribute look-up.  It is called in the same situations where "
"the :meth:`__getattr__` method of a class would be called."
msgstr ""
"Le gestionnaire :c:member:`~PyTypeObject.tp_getattr` est appelé lorsque "
"l'objet nécessite une recherche d'attributs.  Il est appelé dans les mêmes "
"situations où la méthode de classe :meth:`__getattr__` est appelée."

#: extending/newtypes.rst:342
msgid "Here is an example::"
msgstr "Voici un exemple ::"

#: extending/newtypes.rst:358
msgid ""
"The :c:member:`~PyTypeObject.tp_setattr` handler is called when the :meth:"
"`__setattr__` or :meth:`__delattr__` method of a class instance would be "
"called.  When an attribute should be deleted, the third parameter will be "
"``NULL``.  Here is an example that simply raises an exception; if this were "
"really all you wanted, the :c:member:`~PyTypeObject.tp_setattr` handler "
"should be set to ``NULL``. ::"
msgstr ""
"Le gestionnaire :c:member:`~PyTypeObject.tp_setattr` est appelé lorsque la "
"méthode :meth:`__setattr__` ou :meth:`__delattr__` d'une instance de classe "
"est appelée. Lorsqu'un attribut doit être supprimé, le troisième paramètre "
"doit être ``NULL``. Voici un exemple qui soulève simplement une exception ; "
"si c'était vraiment tout ce que vous vouliez, le gestionnaire :c:member:"
"`~PyTypeObject.tp_setattr` doit être instancié à ``NULL``. ::"

#: extending/newtypes.rst:372
msgid "Object Comparison"
msgstr "Comparaison des objets"

#: extending/newtypes.rst:378
msgid ""
"The :c:member:`~PyTypeObject.tp_richcompare` handler is called when "
"comparisons are needed.  It is analogous to the :ref:`rich comparison "
"methods <richcmpfuncs>`, like :meth:`__lt__`, and also called by :c:func:"
"`PyObject_RichCompare` and :c:func:`PyObject_RichCompareBool`."
msgstr ""
"Le gestionnaire :c:member:`~PyTypeObject.tp_richcompare` est appelé lorsque "
"des comparaisons sont nécessaires.  Il est analogue aux méthodes de "
"comparaison :ref:`rich <richcmpfuncs>`, comme :meth:`__lt__`, et également "
"appelé par :c:func:`PyObject_RichCompare` et :c:func:"
"`PyObject_RichCompareBool`."

#: extending/newtypes.rst:383
msgid ""
"This function is called with two Python objects and the operator as "
"arguments, where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, "
"``Py_GT``, ``Py_LT`` or ``Py_GT``.  It should compare the two objects with "
"respect to the specified operator and return ``Py_True`` or ``Py_False`` if "
"the comparison is successful, ``Py_NotImplemented`` to indicate that "
"comparison is not implemented and the other object's comparison method "
"should be tried, or ``NULL`` if an exception was set."
msgstr ""
"Cette fonction est appelée avec deux objets *Python* et l'opérateur comme "
"arguments, où l'opérateur est l'un des objets suivants : ``Py_EQ``, "
"``Py_NE``, ``Py_LE``, ``Py_GT``, ``Py_LT`` ou ``Py_GT``. Il doit comparer "
"les deux objets par rapport à l'opérateur spécifié et renvoyer ``Py_True`` "
"ou ``Py_False`` si la comparaison est réussie, ``Py_NotImplemented`` pour "
"indiquer que la comparaison n'est pas implémentée et que la méthode de "
"comparaison de l'autre objet doit être essayée, ou ``NULL`` si une exception "
"a été définie."

#: extending/newtypes.rst:391
msgid ""
"Here is a sample implementation, for a datatype that is considered equal if "
"the size of an internal pointer is equal::"
msgstr ""
"Voici un exemple d'implémentation, pour un type de données qui est considéré "
"comme égal si la taille d'un pointeur interne est égale ::"

#: extending/newtypes.rst:421
msgid "Abstract Protocol Support"
msgstr "Prise en charge du protocole abstrait"

#: extending/newtypes.rst:423
msgid ""
"Python supports a variety of *abstract* 'protocols;' the specific interfaces "
"provided to use these interfaces are documented in :ref:`abstract`."
msgstr ""
"Python implémente une multitude de 'protocoles' *abstraits* ; les interfaces "
"spécifiques fournies pour utiliser ces interfaces sont documentées dans :ref:"
"`abstract`."

#: extending/newtypes.rst:427
msgid ""
"A number of these abstract interfaces were defined early in the development "
"of the Python implementation.  In particular, the number, mapping, and "
"sequence protocols have been part of Python since the beginning.  Other "
"protocols have been added over time.  For protocols which depend on several "
"handler routines from the type implementation, the older protocols have been "
"defined as optional blocks of handlers referenced by the type object.  For "
"newer protocols there are additional slots in the main type object, with a "
"flag bit being set to indicate that the slots are present and should be "
"checked by the interpreter.  (The flag bit does not indicate that the slot "
"values are non-``NULL``. The flag may be set to indicate the presence of a "
"slot, but a slot may still be unfilled.) ::"
msgstr ""
"Un certain nombre de ces interfaces abstraites ont été définies au début du "
"développement de l'implémentation de *Python*. En particulier, le nombre, la "
"cartographie et les protocoles de séquence font partie de *Python* depuis le "
"début. D'autres protocoles ont été ajoutés au fil du temps. Pour les "
"protocoles qui dépendent de plusieurs routines de gestionnaires de "
"l'implémentation de type, les anciens protocoles ont été définis comme des "
"blocs optionnels de gestionnaires référencés par l'objet de type. Pour les "
"protocoles plus récents, il y a des emplacements supplémentaires dans "
"l'objet de type principal, avec un bit indicateur qui indique que les "
"emplacements sont présents et doivent être vérifiés par l'interpréteur. "
"(L'octet indicateur n'indique pas que les valeurs des *slots* ne sont pas "
"``NULL``. Le bit peut être positionné pour indiquer la présence d'un "
"*slot*, mais un *slot* peut toujours être non rempli). ::"

#: extending/newtypes.rst:442
msgid ""
"If you wish your object to be able to act like a number, a sequence, or a "
"mapping object, then you place the address of a structure that implements "
"the C type :c:type:`PyNumberMethods`, :c:type:`PySequenceMethods`, or :c:"
"type:`PyMappingMethods`, respectively. It is up to you to fill in this "
"structure with appropriate values. You can find examples of the use of each "
"of these in the :file:`Objects` directory of the Python source "
"distribution. ::"
msgstr ""
"Si vous souhaitez que votre objet puisse agir en tant que nombre, une "
"séquence ou un dictionnaire, vous placez alors l'adresse d'une structure "
"qui met en œuvre les méthodes de type *C* :c:type:`PyNumberMethods`, :c:type:"
"`PySequenceMethods`, ou :c:type:`PyMappingMethods`, respectivement. C'est à "
"vous de remplir cette structure avec des valeurs appropriées. Vous pouvez "
"trouver des exemples de l'utilisation de chacune de ces valeurs dans le "
"répertoire :file:`Objects` de la distribution source *Python*. ::"

#: extending/newtypes.rst:451
msgid ""
"This function, if you choose to provide it, should return a hash number for "
"an instance of your data type. Here is a simple example::"
msgstr ""
"Cette fonction, si vous choisissez de la fournir, doit renvoyer un condensat "
"pour une instance de votre type de données. Voici un exemple "
"simple ::"

#: extending/newtypes.rst:464
msgid ""
":c:type:`Py_hash_t` is a signed integer type with a platform-varying width. "
"Returning ``-1`` from :c:member:`~PyTypeObject.tp_hash` indicates an error, "
"which is why you should be careful to avoid returning it when hash "
"computation is successful, as seen above."
msgstr ""
":c:type:`Py_hash_t` est un type d'entier signé avec une largeur variable "
"selon la plateforme. Le renvoi ``-1`` lorsqu'on lance :c:member:"
"`~PyTypeObject.tp_hash` indique une erreur, c'est pourquoi vous devez "
"veiller à ne pas le renvoyer lorsque le calcul du hachage est réussi, comme "
"nous l'avons vu plus haut."

#: extending/newtypes.rst:473
msgid ""
"This function is called when an instance of your data type is \"called\", "
"for example, if ``obj1`` is an instance of your data type and the Python "
"script contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call` "
"handler is invoked."
msgstr ""
"Cette fonction est appelée lorsqu'une instance de votre type de données est "
"« appelée », par exemple, si ``obj1`` est une instance de votre type de "
"données et que le script Python contient ``obj1('hello')``, le gestionnaire :"
"c:member:`~PyTypeObject.tp_call` est invoqué."

#: extending/newtypes.rst:477
msgid "This function takes three arguments:"
msgstr "Cette fonction prend trois arguments :"

#: extending/newtypes.rst:479
msgid ""
"*self* is the instance of the data type which is the subject of the call. If "
"the call is ``obj1('hello')``, then *self* is ``obj1``."
msgstr ""
"*self* est l'instance du type de données qui fait l'objet de l'appel. Si "
"l'appel est ``obj1('hello')``, alors *self* est ``obj1``."

#: extending/newtypes.rst:482
msgid ""
"*args* is a tuple containing the arguments to the call.  You can use :c:func:"
"`PyArg_ParseTuple` to extract the arguments."
msgstr ""
"*args* est un n-uplet qui contient les arguments pour le lancement. Vous "
"pouvez utiliser :c:func:`PyArg_ParseTuple` pour extraire ces arguments."

#: extending/newtypes.rst:485
msgid ""
"*kwds* is a dictionary of keyword arguments that were passed. If this is non-"
"``NULL`` and you support keyword arguments, use :c:func:"
"`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you do not want "
"to support keyword arguments and this is non-``NULL``, raise a :exc:"
"`TypeError` with a message saying that keyword arguments are not supported."
msgstr ""
"*kwds* est un dictionnaire d'arguments de mots-clés. S'il s'agit d'un "
"dictionnaire non ``NULL`` et que vous implémentez les arguments de mots-"
"clés, utilisez :c:func:`PyArg_ParseTupleAndKeywords` pour extraire les "
"arguments. Si vous ne voulez pas implémenter les arguments de mots-clés et "
"que c'est non ``NULL``, levez une exception :exc:`TypeError` avec un message "
"d'erreur indiquant que les arguments de mots-clés ne sont pas supportés."

#: extending/newtypes.rst:491
msgid "Here is a toy ``tp_call`` implementation::"
msgstr "Ceci est une implémentation ``tp_call`` très simple ::"

#: extending/newtypes.rst:517
msgid ""
"These functions provide support for the iterator protocol.  Both handlers "
"take exactly one parameter, the instance for which they are being called, "
"and return a new reference.  In the case of an error, they should set an "
"exception and return ``NULL``.  :c:member:`~PyTypeObject.tp_iter` "
"corresponds to the Python :meth:`__iter__` method, while :c:member:"
"`~PyTypeObject.tp_iternext` corresponds to the Python :meth:`~iterator."
"__next__` method."
msgstr ""
"Ces fonctions fournissent une implémentation pour le protocole d'itération. "
"Les deux gestionnaires prennent un seul paramètre, notamment l'instance pour "
"laquelle ils sont appelés, et renvoient une nouvelle référence. En cas "
"d'erreur, ils doivent définir une exception et renvoyer ``NULL``. :c:member:"
"`~PyTypeObject.tp_iter` correspond à la méthode Python :meth:`__iter__`, "
"tandis que :c:member:`~PyTypeObject.tp_iternext` correspond à la méthode "
"*Python* :meth:`~iterator.__next__`."

#: extending/newtypes.rst:524
msgid ""
"Any :term:`iterable` object must implement the :c:member:`~PyTypeObject."
"tp_iter` handler, which must return an :term:`iterator` object.  Here the "
"same guidelines apply as for Python classes:"
msgstr ""
"Tout objet :term:`iterable` doit implémenter le gestionnaire :c:member:"
"`~PyTypeObject.tp_iter`, qui doit renvoyer un objet de type :term:"
"`iterator`. Ici, les mêmes directives s'appliquent que pour les classes "
"*Python* :"

#: extending/newtypes.rst:528
msgid ""
"For collections (such as lists and tuples) which can support multiple "
"independent iterators, a new iterator should be created and returned by each "
"call to :c:member:`~PyTypeObject.tp_iter`."
msgstr ""
"Pour les collections (telles que les listes et les n-uplets) qui peuvent "
"implémenter plusieurs itérateurs indépendants, un nouvel itérateur doit être "
"créé et renvoyé par chaque appel de type :c:member:`~PyTypeObject.tp_iter`."

#: extending/newtypes.rst:531
msgid ""
"Objects which can only be iterated over once (usually due to side effects of "
"iteration, such as file objects) can implement :c:member:`~PyTypeObject."
"tp_iter` by returning a new reference to themselves -- and should also "
"therefore implement the :c:member:`~PyTypeObject.tp_iternext`  handler."
msgstr ""
"Les objets qui ne peuvent être itérés qu'une seule fois (généralement en "
"raison des effets secondaires de l'itération, tels que les objets fichiers) "
"peuvent implémenter  :c:member:`~PyTypeObject.tp_iter` en  renvoyant une "
"nouvelle référence — et devraient donc également implémenter le pointeur  :c:"
"member:`~PyTypeObject.tp_iternext`."

#: extending/newtypes.rst:536
msgid ""
"Any :term:`iterator` object should implement both :c:member:`~PyTypeObject."
"tp_iter` and :c:member:`~PyTypeObject.tp_iternext`.  An iterator's :c:member:"
"`~PyTypeObject.tp_iter` handler should return a new reference to the "
"iterator.  Its :c:member:`~PyTypeObject.tp_iternext` handler should return a "
"new reference to the next object in the iteration, if there is one. If the "
"iteration has reached the end, :c:member:`~PyTypeObject.tp_iternext` may "
"return ``NULL`` without setting an exception, or it may set :exc:"
"`StopIteration` *in addition* to returning ``NULL``; avoiding the exception "
"can yield slightly better performance.  If an actual error occurs, :c:member:"
"`~PyTypeObject.tp_iternext` should always set an exception and return "
"``NULL``."
msgstr ""
"Tout objet :term:`iterator` doit implémenter à la fois :c:member:"
"`~PyTypeObject.tp_iter` et :c:member:`~PyTypeObject.tp_iternext`. Le "
"gestionnaire :c:member:`~PyTypeObject.tp_iter` d'un itérateur doit renvoyer "
"une nouvelle référence à l'itérateur. Son gestionnaire :c:member:"
"`~PyTypeObject.tp_iternext` doit renvoyer une nouvelle référence à l'objet "
"suivant dans l'itération, s'il y en a un. Si l'itération a atteint la fin, :"
"c:member:`~PyTypeObject.tp_iternext` peut renvoyer ``NULL`` sans définir "
"d'exception, ou il peut définir :exc:`StopIteration` *en plus* de renvoyer "
"``NULL`` ; contourner l'exception peut donner des performances légèrement "
"meilleures. Si une erreur réelle se produit, :c:member:`~PyTypeObject."
"tp_iternext` doit toujours définir une exception et renvoyer ``NULL``."

#: extending/newtypes.rst:552
msgid "Weak Reference Support"
msgstr "Prise en charge de la référence faible"

#: extending/newtypes.rst:554
msgid ""
"One of the goals of Python's weak reference implementation is to allow any "
"type to participate in the weak reference mechanism without incurring the "
"overhead on performance-critical objects (such as numbers)."
msgstr ""
"L'un des objectifs de l'implémentation de la référence faible de *Python* "
"est de permettre à tout type d'objet de participer au mécanisme de référence "
"faible sans avoir à supporter le surcoût des objets à performance critique "
"(tels que les nombres)."

#: extending/newtypes.rst:559
msgid "Documentation for the :mod:`weakref` module."
msgstr "Documentation pour le module :mod:`weakref`."

#: extending/newtypes.rst:561
msgid ""
"For an object to be weakly referencable, the extension type must do two "
"things:"
msgstr ""
"Pour qu'un objet soit faiblement référençable, le type d'extension doit "
"faire deux choses :"

#: extending/newtypes.rst:563
msgid ""
"Include a :c:type:`PyObject\\*` field in the C object structure dedicated to "
"the weak reference mechanism.  The object's constructor should leave it "
"``NULL`` (which is automatic when using the default :c:member:`~PyTypeObject."
"tp_alloc`)."
msgstr ""
"Inclure un champ :c:type:`PyObject\\*` dans la structure d'objet C dédiée au "
"mécanisme de référence faible. Le constructeur de l'objet doit le laisser à "
"la valeur ``NULL`` (ce qui est automatique lorsque l'on utilise le champ par "
"défaut :c:member:`~PyTypeObject.tp_alloc`)."

#: extending/newtypes.rst:568
msgid ""
"Set the :c:member:`~PyTypeObject.tp_weaklistoffset` type member to the "
"offset of the aforementioned field in the C object structure, so that the "
"interpreter knows how to access and modify that field."
msgstr ""
"Définissez le membre de type :c:member:`~PyTypeObject.tp_weaklistoffset` à "
"la valeur de décalage (*offset*) du champ susmentionné dans la structure de "
"l'objet *C*, afin que l'interpréteur sache comment accéder à ce champ et le "
"modifier."

#: extending/newtypes.rst:572
msgid ""
"Concretely, here is how a trivial object structure would be augmented with "
"the required field::"
msgstr ""
"Concrètement, voici comment une structure d'objet simple serait complétée "
"par le champ requis ::"

#: extending/newtypes.rst:580
msgid "And the corresponding member in the statically-declared type object::"
msgstr ""
"Et le membre correspondant dans l'objet de type déclaré statiquement ::"

#: extending/newtypes.rst:588
msgid ""
"The only further addition is that ``tp_dealloc`` needs to clear any weak "
"references (by calling :c:func:`PyObject_ClearWeakRefs`) if the field is non-"
"``NULL``::"
msgstr ""
"Le seul ajout supplémentaire est que ``tp_dealloc`` doit effacer toute "
"référence faible (en appelant :c:func:`PyObject_ClearWeakRefs`) si le champ "
"est non ``NULL`` ::"

#: extending/newtypes.rst:604
msgid "More Suggestions"
msgstr "Plus de suggestions"

#: extending/newtypes.rst:606
msgid ""
"In order to learn how to implement any specific method for your new data "
"type, get the :term:`CPython` source code.  Go to the :file:`Objects` "
"directory, then search the C source files for ``tp_`` plus the function you "
"want (for example, ``tp_richcompare``).  You will find examples of the "
"function you want to implement."
msgstr ""
"Pour savoir comment mettre en œuvre une méthode spécifique pour votre "
"nouveau type de données, téléchargez le code source :term:`CPython`. Allez "
"dans le répertoire :file:`Objects`, puis cherchez dans les fichiers sources "
"*C* la fonction ``tp_`` plus la fonction que vous voulez (par exemple, "
"``tp_richcompare``). Vous trouverez des exemples de la fonction que vous "
"voulez implémenter."

#: extending/newtypes.rst:612
msgid ""
"When you need to verify that an object is a concrete instance of the type "
"you are implementing, use the :c:func:`PyObject_TypeCheck` function.  A "
"sample of its use might be something like the following::"
msgstr ""
"Lorsque vous avez besoin de vérifier qu'un objet est une instance concrète "
"du type que vous implémentez, utilisez la fonction :c:func:"
"`PyObject_TypeCheck`. Voici un exemple de son utilisation ::"

#: extending/newtypes.rst:623
msgid "Download CPython source releases."
msgstr "Télécharger les versions sources de *CPython*."

#: extending/newtypes.rst:623
msgid "https://www.python.org/downloads/source/"
msgstr "https://www.python.org/downloads/source/"

#: extending/newtypes.rst:625
msgid ""
"The CPython project on GitHub, where the CPython source code is developed."
msgstr ""
"Le projet *CPython* sur *GitHub*, où se trouve le code source *CPython*."

#: extending/newtypes.rst:626
msgid "https://github.com/python/cpython"
msgstr "https://github.com/python/cpython"

#~ msgid ":const:`READ_RESTRICTED`"
#~ msgstr ":const:`READ_RESTRICTED`"

#~ msgid "Not readable in restricted mode."
#~ msgstr "Non disponible en lecture, dans le mode restreint."

#~ msgid ":const:`WRITE_RESTRICTED`"
#~ msgstr ":const:`WRITE_RESTRICTED`"

#~ msgid "Not writable in restricted mode."
#~ msgstr "Non disponible en écriture dans le mode restreint."

#~ msgid ":const:`RESTRICTED`"
#~ msgstr ":const:`RESTRICTED`"

#~ msgid "Not readable or writable in restricted mode."
#~ msgstr "Non disponible en lecture ou écriture, en mode restreint."
