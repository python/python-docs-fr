# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-09-21 09:15+0200\n"
"PO-Revision-Date: 2019-06-01 23:38+0200\n"
"Last-Translator: Julien Palard <julien@palard.fr>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/extending/windows.rst:8
msgid "Building C and C++ Extensions on Windows"
msgstr "Construire des extensions C et C++ sur Windows"

#: ../Doc/extending/windows.rst:10
msgid ""
"This chapter briefly explains how to create a Windows extension module for "
"Python using Microsoft Visual C++, and follows with more detailed background "
"information on how it works.  The explanatory material is useful for both "
"the Windows programmer learning to build Python extensions and the Unix "
"programmer interested in producing software which can be successfully built "
"on both Unix and Windows."
msgstr ""
"Cette page explique rapidement comment créer un module d'extension Windows "
"pour Python en utilisant Microsoft Visual C++, et donne plus d'informations "
"contextuelles sur son fonctionnement. Le texte explicatif est utile tant "
"pour le développeur Windows qui apprend à construire des extensions Python "
"que pour le développeur Unix souhaitant produire des logiciels pouvant être "
"construits sur Unix et Windows."

#: ../Doc/extending/windows.rst:17
msgid ""
"Module authors are encouraged to use the distutils approach for building "
"extension modules, instead of the one described in this section. You will "
"still need the C compiler that was used to build Python; typically Microsoft "
"Visual C++."
msgstr ""
"Les auteurs de modules sont invités à utiliser l'approche *distutils* pour "
"construire des modules d'extension, au lieu de celle décrite dans cette "
"section. Vous aurez toujours besoin du compilateur C utilisé pour construire "
"Python ; typiquement Microsoft Visual C++."

#: ../Doc/extending/windows.rst:24
msgid ""
"This chapter mentions a number of filenames that include an encoded Python "
"version number.  These filenames are represented with the version number "
"shown as ``XY``; in practice, ``'X'`` will be the major version number and "
"``'Y'`` will be the minor version number of the Python release you're "
"working with.  For example, if you are using Python 2.2.1, ``XY`` will "
"actually be ``22``."
msgstr ""
"Cette page mentionne plusieurs noms de fichiers comprenant un numéro de "
"version Python encodé. Ces noms de fichiers sont construits sous le format "
"de version ``XY`` ; en pratique, ``'X'`` représente le numéro de version "
"majeure et ``'Y'`` représente le numéro de version mineure de la version "
"Python avec laquelle vous travaillez. Par exemple, si vous utilisez Python "
"2.2.1, ``XY`` correspond à ``22``."

#: ../Doc/extending/windows.rst:34
msgid "A Cookbook Approach"
msgstr "Une approche \"recette de cuisine\""

#: ../Doc/extending/windows.rst:36
msgid ""
"There are two approaches to building extension modules on Windows, just as "
"there are on Unix: use the :mod:`distutils` package to control the build "
"process, or do things manually.  The distutils approach works well for most "
"extensions; documentation on using :mod:`distutils` to build and package "
"extension modules is available in :ref:`distutils-index`.  If you find you "
"really need to do things manually, it may be instructive to study the "
"project file for the :source:`winsound <PCbuild/winsound.vcxproj>` standard "
"library module."
msgstr ""
"Il y a deux approches lorsque l'on construit des modules d'extension sur "
"Windows, tout comme sur Unix : utiliser le paquet :mod:`distutils` pour "
"contrôler le processus de construction, ou faire les choses manuellement. "
"L'approche *distutils* fonctionne bien pour la plupart des extensions ; la "
"documentation pour utiliser :mod:`distutils` pour construire et empaqueter "
"les modules d'extension est disponible dans :ref:`distutils-index`. Si vous "
"considérez que vous avez réellement besoin de faire les choses manuellement, "
"il pourrait être enrichissant d'étudier le fichier de projet :source:"
"`winsound <PCbuild/winsound.vcxproj>` pour le module de la bibliothèque "
"standard."

#: ../Doc/extending/windows.rst:48
msgid "Differences Between Unix and Windows"
msgstr "Différences entre Unix et Windows"

#: ../Doc/extending/windows.rst:53
msgid ""
"Unix and Windows use completely different paradigms for run-time loading of "
"code.  Before you try to build a module that can be dynamically loaded, be "
"aware of how your system works."
msgstr ""
"\\ Unix et Windows utilisent des paradigmes complètement différents pour le "
"chargement du code pendant l'exécution. Avant d'essayer de construire un "
"module qui puisse être chargé dynamiquement, soyez conscient du mode de "
"fonctionnement du système."

#: ../Doc/extending/windows.rst:57
msgid ""
"In Unix, a shared object (:file:`.so`) file contains code to be used by the "
"program, and also the names of functions and data that it expects to find in "
"the program.  When the file is joined to the program, all references to "
"those functions and data in the file's code are changed to point to the "
"actual locations in the program where the functions and data are placed in "
"memory. This is basically a link operation."
msgstr ""
"Sur Unix, un fichier objet partagé (:file:`.so`) contient du code servant au "
"programme, ainsi que les noms des fonctions et les données que l'on "
"s'attend  à trouver dans le programme. Quand le fichier est attaché au "
"programme, toutes les références à ces fonctions et données dans le code du "
"fichier sont modifiées pour pointer vers les localisations actuelles dans le "
"programme où sont désormais placées les fonctions et données dans la "
"mémoire. C'est tout simplement une opération de liaison."

#: ../Doc/extending/windows.rst:64
msgid ""
"In Windows, a dynamic-link library (:file:`.dll`) file has no dangling "
"references.  Instead, an access to functions or data goes through a lookup "
"table.  So the DLL code does not have to be fixed up at runtime to refer to "
"the program's memory; instead, the code already uses the DLL's lookup table, "
"and the lookup table is modified at runtime to point to the functions and "
"data."
msgstr ""
"Sur Windows, un fichier bibliothèque de liens dynamiques (:file:`.dll`) n'a "
"pas de références paresseuses. A la place, un accès aux fonctions ou données "
"passe par une table de conversion. Cela est fait pour que le code DLL ne "
"doive pas être réarrangé à l'exécution pour renvoyer à la mémoire du "
"programme ; à la place, le code utilise déjà la table de conversion DLL, et "
"cette table est modifiée à l'exécution pour pointer vers les fonctions et "
"données."

#: ../Doc/extending/windows.rst:70
msgid ""
"In Unix, there is only one type of library file (:file:`.a`) which contains "
"code from several object files (:file:`.o`).  During the link step to create "
"a shared object file (:file:`.so`), the linker may find that it doesn't know "
"where an identifier is defined.  The linker will look for it in the object "
"files in the libraries; if it finds it, it will include all the code from "
"that object file."
msgstr ""
"Sur Unix, il n'y a qu'un type de bibliothèque de fichier (:file:`.a`) qui "
"contient du code venant de plusieurs fichiers objets (:file:`.o`). Durant "
"l'étape de liaison pour créer un fichier objet partagé (:file:`.so`), le "
"lieur peut informer qu'il ne sait pas où un identificateur est défini. Le "
"lieur le cherchera dans les fichiers objet dans les bibliothèques ; s'il le "
"trouve, il inclura tout le code provenant de ce fichier objet."

#: ../Doc/extending/windows.rst:76
msgid ""
"In Windows, there are two types of library, a static library and an import "
"library (both called :file:`.lib`).  A static library is like a Unix :file:`."
"a` file; it contains code to be included as necessary. An import library is "
"basically used only to reassure the linker that a certain identifier is "
"legal, and will be present in the program when the DLL is loaded.  So the "
"linker uses the information from the import library to build the lookup "
"table for using identifiers that are not included in the DLL.  When an "
"application or a DLL is linked, an import library may be generated, which "
"will need to be used for all future DLLs that depend on the symbols in the "
"application or DLL."
msgstr ""
"Sur Windows, il y a deux types de bibliothèques, une bibliothèque statique "
"et une bibliothèque d'importation (toutes deux appelées :file:`.lib`). Une "
"bibliothèque statique est comme un fichier Unix :file:`.a` ; elle contient "
"du code pouvant être inclus si nécessaire. Une bibliothèque d'importation "
"est uniquement utilisée pour rassurer le lieur qu'un certain identificateur "
"est légal, et sera présent dans le programme quand la DLL est chargée. Comme "
"ça le lieur utilise les informations provenant de la bibliothèque "
"d'importation pour construire la table de conversion pour utiliser les "
"identificateurs qui ne sont pas inclus dans la DLL. Quand une application ou "
"une DLL est liée, une bibliothèque d'importation peut être générée, qui "
"devra être utilisée pour toutes les futures DLL dépendantes aux symboles "
"provenant de l'application ou de la DLL."

#: ../Doc/extending/windows.rst:86
msgid ""
"Suppose you are building two dynamic-load modules, B and C, which should "
"share another block of code A.  On Unix, you would *not* pass :file:`A.a` to "
"the linker for :file:`B.so` and :file:`C.so`; that would cause it to be "
"included twice, so that B and C would each have their own copy.  In Windows, "
"building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass :file:"
"`A.lib` to the linker for B and C.  :file:`A.lib` does not contain code; it "
"just contains information which will be used at runtime to access A's code."
msgstr ""
"Supposons que vous construisez deux modules de chargement dynamiques, B et "
"C, qui ne devraient pas partager un autre bloc de code avec A. Sur Unix, "
"vous ne transmettrez pas :file:`A.a` au lieur pour :file:`B.so` et :file:`C."
"so` ; cela le ferait être inclus deux fois, pour que B et C aient chacun "
"leur propre copie. Sur Windows, construire :file:`A.dll` construira aussi :"
"file:`A.lib`. Vous transmettez :file:`A.lib` au lieur pour B et C. :file:`A."
"lib` ne contient pas de code ; il contient uniquement des informations qui "
"seront utilisées lors de l'exécution pour accéder au code de A."

#: ../Doc/extending/windows.rst:94
msgid ""
"In Windows, using an import library is sort of like using ``import spam``; "
"it gives you access to spam's names, but does not create a separate copy.  "
"On Unix, linking with a library is more like ``from spam import *``; it does "
"create a separate copy."
msgstr ""
"Sur Windows, utiliser une bibliothèque d'importation est comme utiliser "
"``import spam``; cela vous donne accès aux noms des spams, mais ne crée par "
"de copie séparée. Sur Unix, se lier à une bibliothèque est plus comme ``from "
"spam import *`` ; cela crée une copie séparée."

#: ../Doc/extending/windows.rst:103
msgid "Using DLLs in Practice"
msgstr "Utiliser les DLL en pratique"

#: ../Doc/extending/windows.rst:108
msgid ""
"Windows Python is built in Microsoft Visual C++; using other compilers may "
"or may not work (though Borland seems to).  The rest of this section is MSVC+"
"+ specific."
msgstr ""
"Le Python de Windows est construit en Microsoft Visual C++ ; utiliser "
"d'autres compilateurs pourrait fonctionner, ou pas (cependant Borland a "
"l'air de fonctionner). Le reste de cette section est spécifique à MSVC++."

#: ../Doc/extending/windows.rst:112
msgid ""
"When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the "
"linker. To build two DLLs, spam and ni (which uses C functions found in "
"spam), you could use these commands::"
msgstr ""
"Lorsque vous créez des DLL sur Windows, vous devez transmettre :file:"
"`pythonXY.lib` au lieur. Pour construire deux DLL, spam et ni (qui utilisent "
"des fonctions C trouvées dans spam), vous pouvez utiliser ces commandes ::"

#: ../Doc/extending/windows.rst:119
msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll` "
"and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to find "
"the Python code thanks to :file:`pythonXY.lib`."
msgstr ""
"La première commande a créé trois fichiers : :file:`spam.obj`, :file:`spam."
"dll` et :file:`spam.lib`. :file:`Spam.dll` ne contient pas de fonctions "
"Python (telles que :c:func:`PyArg_ParseTuple`), mais il sait comment trouver "
"le code Python grâce à :file:`pythonXY.lib`."

#: ../Doc/extending/windows.rst:124
msgid ""
"The second command created :file:`ni.dll` (and :file:`.obj` and :file:`."
"lib`), which knows how to find the necessary functions from spam, and also "
"from the Python executable."
msgstr ""
"La seconde commande a créé :file:`ni.dll` (et :file:`.obj` et :file:`.lib`), "
"qui sait comment trouver les fonctions nécessaires dans spam, ainsi qu'à "
"partir de l'exécutable Python."

#: ../Doc/extending/windows.rst:128
msgid ""
"Not every identifier is exported to the lookup table.  If you want any other "
"modules (including Python) to be able to see your identifiers, you have to "
"say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) "
"initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."
msgstr ""
"Chaque identificateur n'est pas exporté vers la table de conversion. Si vous "
"voulez que tout autre module (y compris Python) soit capable de voir vos "
"identificateurs, vous devez préciser ``_declspec(dllexport)``, comme dans "
"``void _declspec(dllexport) initspam(void)`` ou ``PyObject "
"_declspec(dllexport) *NiGetSpamData(void)``."

#: ../Doc/extending/windows.rst:133
msgid ""
"Developer Studio will throw in a lot of import libraries that you do not "
"really need, adding about 100K to your executable.  To get rid of them, use "
"the Project Settings dialog, Link tab, to specify *ignore default "
"libraries*.  Add the correct :file:`msvcrtxx.lib` to the list of libraries."
msgstr ""
"\\ Developer Studio apportera beaucoup de bibliothèques d'importation dont "
"vous n'avez pas vraiment besoin, augmentant d'environ 100ko votre "
"exécutable. Pour s'en débarrasser, allez dans les Paramètres du Projet, "
"onglet Lien, pour préciser *ignorer les bibliothèques par défaut*. Et la :"
"file:`msvcrtxx.lib` correcte à la liste des bibliothèques."
