# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-04 10:00+0100\n"
"PO-Revision-Date: 2019-10-31 17:05+0100\n"
"Last-Translator: Jules Lasne <jules.lasne@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.1\n"

#: ../Doc/tutorial/classes.rst:5
msgid "Classes"
msgstr "Classes"

#: ../Doc/tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"Les classes sont un moyen de réunir des données et des fonctionnalités. "
"Créer une nouvelle classe crée un nouveau *type* d'objet et ainsi de "
"nouvelles *instances* de ce type peuvent être construites. Chaque instance "
"peut avoir ses propres attributs, ce qui définit son état. Une instance peut "
"aussi avoir des méthodes (définies par la classe de l'instance) pour "
"modifier son état."

#: ../Doc/tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"La notion de classes en Python s'inscrit dans le langage avec un minimum de "
"syntaxe et de sémantique nouvelles. C'est un mélange des mécanismes "
"rencontrés dans C++ et Modula-3. Les classes fournissent toutes les "
"fonctionnalités standards de la programmation orientée objet : l'héritage de "
"classes autorise les héritages multiples, une classe dérivée peut surcharger "
"les méthodes de sa ou ses classes de base et une méthode peut appeler la "
"méthode d'une classe de base qui possède le même nom. Les objets peuvent "
"contenir n'importe quel nombre ou type de données. De la même manière que "
"les modules, les classes participent à la nature dynamique de Python : elles "
"sont créées pendant l'exécution et peuvent être modifiées après leur "
"création."

#: ../Doc/tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"Dans la terminologie C++, les membres des classes (y compris les données) "
"sont *publics* (sauf exception, voir :ref:`tut-private`) et toutes les "
"fonctions membres sont *virtuelles*. Comme avec Modula-3, il n'y a aucune "
"façon d'accéder aux membres d'un objet à partir de ses méthodes : une "
"méthode est déclarée avec un premier argument explicite représentant l'objet "
"et cet argument est transmis de manière implicite lors de l'appel. Comme "
"avec Smalltalk, les classes elles-mêmes sont des objets. Il existe ainsi une "
"sémantique pour les importer et les renommer. Au contraire de C++ et "
"Modula-3, les types natifs peuvent être utilisés comme classes de base pour "
"être étendus par l'utilisateur. Enfin, comme en C++, la plupart des "
"opérateurs natifs avec une syntaxe spéciale (opérateurs arithmétiques, "
"indiçage, etc.) peuvent être redéfinis pour les instances de classes."

#: ../Doc/tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"En l'absence d'une terminologie communément admise pour parler des classes, "
"nous utilisons parfois des termes de Smalltalk et C++. Nous voulions "
"utiliser les termes de Modula-3 puisque sa sémantique orientée objet est "
"plus proche de celle de Python que C++, mais il est probable que seul un "
"petit nombre de lecteurs les connaissent."

#: ../Doc/tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "Objets et noms : préambule"

#: ../Doc/tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Les objets possèdent une existence propre et plusieurs noms peuvent être "
"utilisés (dans divers contextes) pour faire référence à un même objet. Ce "
"concept est connu sous le nom d'alias dans d'autres langages. Il n'apparaît "
"pas au premier coup d'œil en Python et il peut être ignoré tant qu'on "
"travaille avec des types de base immuables (nombres, chaînes, tuples). "
"Cependant, les alias peuvent produire des effets surprenants sur la "
"sémantique d'un code Python mettant en jeu des objets muables comme les "
"listes, les dictionnaires et la plupart des autres types. En général, leur "
"utilisation est bénéfique au programme car les alias se comportent, d'un "
"certain point de vue, comme des pointeurs. Par exemple, transmettre un objet "
"n'a aucun coût car c'est simplement un pointeur qui est transmis par "
"l'implémentation ; et si une fonction modifie un objet passé en argument, le "
"code à l'origine de l'appel voit le changement. Ceci élimine le besoin "
"d'avoir deux mécanismes de transmission d'arguments comme en Pascal."

#: ../Doc/tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Portées et espaces de nommage en Python"

#: ../Doc/tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Avant de présenter les classes, nous devons aborder la notion de portée en "
"Python. Les définitions de classes font d'habiles manipulations avec les "
"espaces de nommage, vous devez donc savoir comment les portées et les "
"espaces de nommage fonctionnent. Soit dit en passant, la connaissance de ce "
"sujet est aussi utile aux développeurs Python expérimentés."

#: ../Doc/tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "Commençons par quelques définitions."

#: ../Doc/tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"Un *espace de nommage* est une table de correspondance entre des noms et des "
"objets. La plupart des espaces de nommage sont actuellement implémentés sous "
"forme de dictionnaires Python, mais ceci n'est normalement pas visible (sauf "
"pour les performances) et peut changer dans le futur. Comme exemples "
"d'espaces de nommage, nous pouvons citer les primitives (fonctions comme :"
"func:`abs` et les noms des exceptions de base) ; les noms globaux dans un "
"module ; et les noms locaux lors d'un appel de fonction. D'une certaine "
"manière, l'ensemble des attributs d'un objet forme lui-même un espace de "
"nommage. L'important à retenir concernant les espaces de nommage est qu'il "
"n'y a absolument aucun lien entre les noms de différents espaces de "
"nommage ; par exemple, deux modules différents peuvent définir une fonction "
"``maximize`` sans qu'il n'y ait de confusion. Les utilisateurs des modules "
"doivent préfixer le nom de la fonction avec celui du module."

#: ../Doc/tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"À ce propos, nous utilisons le mot *attribut* pour tout nom suivant un "
"point. Par exemple, dans l'expression ``z.real``, ``real`` est un attribut "
"de l'objet ``z``. Rigoureusement parlant, les références à des noms dans des "
"modules sont des références d'attributs : dans l'expression ``nommodule."
"nomfonction``, ``nommodule`` est un objet module et ``nomfonction`` est un "
"attribut de cet objet. Dans ces conditions, il existe une correspondance "
"directe entre les attributs du module et les noms globaux définis dans le "
"module : ils partagent le même espace de nommage [#]_ !"

#: ../Doc/tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`the_answer` from the object named by ``modname``."
msgstr ""
"Les attributs peuvent être en lecture seule ou modifiables. S'ils sont "
"modifiables, l'affectation à un attribut est possible. Les attributs de "
"modules sont modifiables : vous pouvez écrire ``nommodule.la_reponse = 42``. "
"Les attributs modifiables peuvent aussi être effacés avec l'instruction :"
"keyword:`del`. Par exemple, ``del nommodule.la_reponse`` supprime "
"l'attribut :attr:`la_reponse` de l'objet nommé ``nommodule``."

#: ../Doc/tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"Les espaces de nommage sont créés à différents moments et ont différentes "
"durées de vie. L'espace de nommage contenant les primitives est créé au "
"démarrage de l'interpréteur Python et n'est jamais effacé. L'espace de "
"nommage globaux pour un module est créé lorsque la définition du module est "
"lue. Habituellement, les espaces de nommage des modules durent aussi jusqu'à "
"l'arrêt de l'interpréteur. Les instructions exécutées par la première "
"invocation de l'interpréteur, qu'elles soient lues depuis un fichier de "
"script ou de manière interactive, sont considérées comme faisant partie d'un "
"module appelé :mod:`__main__`, de façon qu'elles possèdent leur propre "
"espace de nommage (les primitives vivent elles-mêmes dans un module, appelé :"
"mod:`builtins`)."

#: ../Doc/tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"L'espace des noms locaux d'une fonction est créé lors de son appel, puis "
"effacé lorsqu'elle renvoie un résultat ou lève une exception non prise en "
"charge (en fait, « oublié » serait une meilleure façon de décrire ce qui se "
"passe réellement). Bien sûr, des invocations récursives ont chacune leur "
"propre espace de nommage."

#: ../Doc/tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"La *portée* est la zone textuelle d'un programme Python où un espace de "
"nommage est directement accessible. « Directement accessible » signifie ici "
"qu'une référence non qualifiée à un nom est cherchée dans l'espace de "
"nommage."

#: ../Doc/tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are at least three nested scopes whose "
"namespaces are directly accessible:"
msgstr ""
"Bien que les portées soient déterminées de manière statique, elles sont "
"utilisées de manière dynamique. À n'importe quel moment de l'exécution, il y "
"a au minimum trois portées imbriquées dont les espaces de nommage sont "
"directement accessibles :"

#: ../Doc/tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr ""
"la portée la plus au centre, celle qui est consultée en premier, contient "
"les noms locaux ;"

#: ../Doc/tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contains non-local, but also non-global names"
msgstr ""
"les portées des fonctions englobantes, qui sont consultées en commençant "
"avec la portée englobante la plus proche, contiennent des noms non-locaux "
"mais aussi non-globaux ;"

#: ../Doc/tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "l'avant-dernière portée contient les noms globaux du module courant ;"

#: ../Doc/tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"la portée englobante, consultée en dernier, est l'espace de nommage "
"contenant les primitives."

#: ../Doc/tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the middle scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"Si un nom est déclaré comme global, alors toutes les références et "
"affectations vont directement dans la portée intermédiaire contenant les "
"noms globaux du module. Pour pointer une variable qui se trouve en dehors de "
"la portée la plus locale, vous pouvez utiliser l'instruction :keyword:"
"`nonlocal`. Si une telle variable n'est pas déclarée *nonlocal*, elle est en "
"lecture seule (toute tentative de la modifier crée simplement une *nouvelle* "
"variable dans la portée la plus locale, en laissant inchangée la variable du "
"même nom dans sa portée d'origine)."

#: ../Doc/tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Habituellement, la portée locale référence les noms locaux de la fonction "
"courante. En dehors des fonctions, la portée locale référence le même espace "
"de nommage que la portée globale : l'espace de nommage du module. Les "
"définitions de classes créent un nouvel espace de nommage dans la portée "
"locale."

#: ../Doc/tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"Il est important de réaliser que les portées sont déterminées de manière "
"textuelle : la portée globale d'une fonction définie dans un module est "
"l'espace de nommage de ce module, quelle que soit la provenance de l'appel à "
"la fonction. En revanche, la recherche réelle des noms est faite "
"dynamiquement au moment de l'exécution. Cependant la définition du langage "
"est en train d'évoluer vers une résolution statique des noms au moment de la "
"« compilation », donc ne vous basez pas sur une résolution dynamique (en "
"réalité, les variables locales sont déjà déterminées de manière statique) !"

#: ../Doc/tutorial/classes.rst:146
#, fuzzy
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""
"Une particularité de Python est que, si aucune instruction :keyword:`global` "
"n'est active, les affectations de noms vont toujours dans la portée la plus "
"proche. Les affectations ne copient aucune donnée : elles se contentent de "
"lier des noms à des objets. Ceci est également vrai pour l'effacement : "
"l'instruction ``del x`` supprime la liaison de ``x`` dans l'espace de "
"nommage référencé par la portée locale. En réalité, toutes les opérations "
"qui impliquent des nouveaux noms utilisent la portée locale : en "
"particulier, les instructions :keyword:`import` et les définitions de "
"fonctions effectuent une liaison du module ou du nom de fonction dans la "
"portée locale."

#: ../Doc/tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"L'instruction :keyword:`global` peut être utilisée pour indiquer que "
"certaines variables existent dans la portée globale et doivent être reliées "
"en local ; l'instruction :keyword:`nonlocal` indique que certaines variables "
"existent dans une portée supérieure et doivent être reliées en local."

#: ../Doc/tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "Exemple de portées et d'espaces de nommage"

#: ../Doc/tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Ceci est un exemple montrant comment utiliser les différentes portées et "
"espaces de nommage, et comment :keyword:`global` et :keyword:`nonlocal` "
"modifient l'affectation de variable ::"

#: ../Doc/tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "Ce code donne le résultat suivant :"

#: ../Doc/tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change *scope_test*"
"\\'s binding of *spam*.  The :keyword:`nonlocal` assignment changed "
"*scope_test*\\'s binding of *spam*, and the :keyword:`global` assignment "
"changed the module-level binding."
msgstr ""
"Vous pouvez constater que l'affectation *locale* (qui est effectuée par "
"défaut) n'a pas modifié la liaison de *spam* dans *scope_test*. "
"L'affectation :keyword:`nonlocal` a changé la liaison de *spam* dans "
"*scope_test* et l'affectation :keyword:`global` a changé la liaison au "
"niveau du module."

#: ../Doc/tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"Vous pouvez également voir qu'aucune liaison pour *spam* n'a été faite avant "
"l'affectation :keyword:`global`."

#: ../Doc/tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "Une première approche des classes"

#: ../Doc/tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Le concept de classe introduit un peu de syntaxe nouvelle, trois nouveaux "
"types d'objets ainsi que quelques nouveaux éléments de sémantique."

#: ../Doc/tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "Syntaxe de définition des classes"

#: ../Doc/tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "La forme la plus simple de définition d'une classe est la suivante ::"

#: ../Doc/tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Les définitions de classes, comme les définitions de fonctions (définitions :"
"keyword:`def`), doivent être exécutées avant d'avoir un effet. Vous pouvez "
"tout à fait placer une définition de classe dans une branche d'une "
"instruction conditionnelle :keyword:`if` ou encore à l'intérieur d'une "
"fonction."

#: ../Doc/tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"Dans la pratique, les déclarations dans une définition de classe sont "
"généralement des définitions de fonctions mais d'autres déclarations sont "
"permises et parfois utiles (nous revenons sur ce point plus tard). Les "
"définitions de fonction à l'intérieur d'une classe ont normalement une forme "
"particulière de liste d'arguments, dictée par les conventions d'appel aux "
"méthodes (à nouveau, tout ceci est expliqué plus loin)."

#: ../Doc/tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"Quand une classe est définie, un nouvel espace de nommage est créé et "
"utilisé comme portée locale --- Ainsi, toutes les affectations de variables "
"locales entrent dans ce nouvel espace de nommage. En particulier, les "
"définitions de fonctions y lient le nom de la nouvelle fonction."

#: ../Doc/tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:"
"`ClassName` in the example)."
msgstr ""
"À la fin de la définition d'une classe, un *objet classe* est créé. C'est, "
"pour simplifier, une encapsulation du contenu de l'espace de nommage créé "
"par la définition de classe. Nous revoyons les objets classes dans la "
"prochaine section. La portée locale initiale (celle qui prévaut avant le "
"début de la définition de la classe) est ré-instanciée et l'objet de classe "
"est lié ici au nom de classe donné dans l'en-tête de définition de classe (:"
"class:`ClassName` dans l'exemple)."

#: ../Doc/tutorial/classes.rst:259
msgid "Class Objects"
msgstr "Objets classes"

#: ../Doc/tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Les objets classes prennent en charge deux types d'opérations : des "
"références à des attributs et l'instanciation."

#: ../Doc/tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"Les *références d'attributs* utilisent la syntaxe standard utilisée pour "
"toutes les références d'attributs en Python : ``obj.nom``. Les noms "
"d'attribut valides sont tous les noms qui se trouvaient dans l'espace de "
"nommage de la classe quand l'objet classe a été créé. Donc, si la définition "
"de classe est de cette forme ::"

#: ../Doc/tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"alors ``MyClass.i`` et ``MyClass.f`` sont des références valides à des "
"attributs, renvoyant respectivement un entier et un objet fonction. Les "
"attributs de classes peuvent également être affectés, de sorte que vous "
"pouvez modifier la valeur de ``MyClass.i`` par affectation. :attr:`__doc__` "
"est aussi un attribut valide, renvoyant la *docstring* appartenant à la "
"classe : ``\"A simple example class\"``."

# Apostrophe transformée en guillemets car devant une astérisque.
#: ../Doc/tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"L'*instanciation* de classes utilise la notation des fonctions. Considérez "
"simplement que l'objet classe est une fonction sans paramètre qui renvoie "
"une nouvelle instance de la classe. Par exemple (en considérant la classe "
"définie ci-dessus) ::"

#: ../Doc/tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"crée une nouvelle *instance* de la classe et affecte cet objet à la variable "
"locale ``x``."

#: ../Doc/tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`__init__`, like this::"
msgstr ""
"L'opération d'instanciation (en \"appelant\" un objet classe) crée un objet "
"vide. De nombreuses classes aiment créer des instances personnalisées "
"correspondant à un état initial spécifique. À cet effet, une classe peut "
"définir une méthode spéciale nommée :meth:`__init__`, comme ceci ::"

#: ../Doc/tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`__init__` method, class instantiation "
"automatically invokes :meth:`__init__` for the newly-created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"Quand une classe définit une méthode :meth:`__init__`, l'instanciation de la "
"classe appelle automatiquement :meth:`__init__` pour la nouvelle instance de "
"la classe. Donc, dans cet exemple, l'initialisation d'une nouvelle instance "
"peut être obtenue par ::"

#: ../Doc/tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`__init__` method may have arguments for greater "
"flexibility.  In that case, arguments given to the class instantiation "
"operator are passed on to :meth:`__init__`.  For example, ::"
msgstr ""
"Bien sûr, la méthode :meth:`__init__` peut avoir des arguments pour une plus "
"grande flexibilité. Dans ce cas, les arguments donnés à l'opérateur "
"d'instanciation de classe sont transmis à :meth:`__init__`. Par exemple ::"

#: ../Doc/tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "Objets instances"

#: ../Doc/tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names, data attributes and methods."
msgstr ""
"Maintenant, que pouvons-nous faire avec des objets instances ? Les seules "
"opérations comprises par les objets instances sont des références "
"d'attributs. Il y a deux sortes de noms d'attributs valides, les attributs "
"'données' et les méthodes."

#: ../Doc/tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"Les *attributs 'données'* correspondent à des \"variables d'instance\" en "
"Smalltalk et aux \"membres de données\" en C++. Les attributs 'données' "
"n'ont pas à être déclarés. Comme les variables locales, ils existent dès "
"lors qu'ils sont assignés une première fois. Par exemple, si ``x`` est "
"l'instance de :class:`MyClass` créée ci-dessus, le code suivant affiche la "
"valeur ``16``, sans laisser de trace ::"

#: ../Doc/tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For "
"example, list objects have methods called append, insert, remove, sort, and "
"so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"L'autre type de référence à un attribut d'instance est une *méthode*. Une "
"méthode est une fonction qui \"appartient à\" un objet (en Python, le terme "
"de méthode n'est pas unique aux instances de classes : d'autres types "
"d'objets peuvent aussi avoir des méthodes. Par exemple, les objets listes "
"ont des méthodes appelées ``append``, ``insert``, ``remove``, ``sort`` et "
"ainsi de suite. Toutefois, dans la discussion qui suit, sauf indication "
"contraire, nous utilisons le terme de méthode exclusivement en référence à "
"des méthodes d'objets instances de classe)."

#: ../Doc/tutorial/classes.rst:349
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Les noms de méthodes valides d'un objet instance dépendent de sa classe. Par "
"définition, tous les attributs d'une classe qui sont des objets fonctions "
"définissent les méthodes correspondantes de ses instances. Donc, dans notre "
"exemple, ``x.f`` est une référence valide à une méthode car ``MyClass.f`` "
"est une fonction, mais pas ``x.i`` car ``MyClass.i`` n'en est pas une. "
"Attention cependant, ``x.f`` n'est pas la même chose que ``MyClass.f`` --- "
"Il s'agit d'un *objet méthode*, pas d'un objet fonction."

#: ../Doc/tutorial/classes.rst:360
msgid "Method Objects"
msgstr "Objets méthode"

#: ../Doc/tutorial/classes.rst:362
msgid "Usually, a method is called right after it is bound::"
msgstr "Le plus souvent, une méthode est appelée juste après avoir été liée ::"

#: ../Doc/tutorial/classes.rst:366
msgid ""
"In the :class:`MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"Dans l'exemple de la classe :class:`MyClass`, cela renvoie la chaîne de "
"caractères ``hello world``. Toutefois, il n'est pas nécessaire d'appeler la "
"méthode directement : ``x.f`` est un objet méthode, il peut être gardé de "
"côté et être appelé plus tard. Par exemple ::"

#: ../Doc/tutorial/classes.rst:374
msgid "will continue to print ``hello world`` until the end of time."
msgstr "affiche ``hello world`` jusqu'à la fin des temps."

#: ../Doc/tutorial/classes.rst:376
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"Que se passe-t-il exactement quand une méthode est appelée ? Vous avez dû "
"remarquer que ``x.f()`` a été appelée dans le code ci-dessus sans argument, "
"alors que la définition de la méthode :meth:`f` spécifie bien qu'elle prend "
"un argument. Qu'est-il arrivé à l'argument ? Python doit sûrement lever une "
"exception lorsqu'une fonction qui requiert un argument est appelée sans -- "
"même si l'argument n'est pas utilisé…"

#: ../Doc/tutorial/classes.rst:382
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"En fait, vous avez peut-être deviné la réponse : la particularité des "
"méthodes est que l'objet est passé comme premier argument de la fonction. "
"Dans notre exemple, l'appel ``x.f()`` est exactement équivalent à ``MyClass."
"f(x)``. En général, appeler une méthode avec une liste de *n* arguments est "
"équivalent à appeler la fonction correspondante avec une liste d'arguments "
"créée en ajoutant l'instance de l'objet de la méthode avant le premier "
"argument."

#: ../Doc/tutorial/classes.rst:389
msgid ""
"If you still don't understand how methods work, a look at the implementation "
"can perhaps clarify matters.  When a non-data attribute of an instance is "
"referenced, the instance's class is searched.  If the name denotes a valid "
"class attribute that is a function object, a method object is created by "
"packing (pointers to) the instance object and the function object just found "
"together in an abstract object: this is the method object.  When the method "
"object is called with an argument list, a new argument list is constructed "
"from the instance object and the argument list, and the function object is "
"called with this new argument list."
msgstr ""
"Si vous ne comprenez toujours pas comment les méthodes fonctionnent, un coup "
"d'œil à l'implémentation vous aidera peut-être. Lorsque un attribut d'une "
"instance est référencé et que ce n'est pas un attribut 'données', sa classe "
"est recherchée. Si le nom correspond à un attribut valide et que c'est un "
"objet fonction, un objet méthode est créé en générant un objet abstrait qui "
"regroupe (des pointeurs vers) l'objet instance et l'objet fonction qui vient "
"d'être trouvé : c'est l'objet méthode. Quand l'objet méthode est appelé avec "
"une liste d'arguments, une nouvelle liste d'arguments est construite à "
"partir de l'objet instance et de la liste des arguments. L'objet fonction "
"est alors appelé avec cette nouvelle liste d'arguments."

#: ../Doc/tutorial/classes.rst:403
msgid "Class and Instance Variables"
msgstr "Classes et variables d'instance"

#: ../Doc/tutorial/classes.rst:405
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"En général, les variables d'instance stockent des informations relatives à "
"chaque instance alors que les variables de classe servent à stocker les "
"attributs et méthodes communes à toutes les instances de la classe ::"

#: ../Doc/tutorial/classes.rst:427
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Comme nous l'avons vu dans :ref:`tut-object`, les données partagées :term:"
"`muable <muable>` (telles que les listes, dictionnaires, etc.) peuvent avoir "
"des effets surprenants. Par exemple, la liste *tricks* dans le code suivant "
"ne devrait pas être utilisée en tant que variable de classe car, dans ce "
"cas, une seule liste est partagée par toutes les instances de *Dog* ::"

#: ../Doc/tutorial/classes.rst:450
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"Une conception correcte de la classe est d'utiliser une variable d'instance "
"à la place ::"

#: ../Doc/tutorial/classes.rst:474
msgid "Random Remarks"
msgstr "Remarques diverses"

#: ../Doc/tutorial/classes.rst:478
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"Si le même nom d'attribut apparaît à la fois dans une instance et dans une "
"classe, alors la recherche d'attribut donne la priorité à l'instance ::"

#: ../Doc/tutorial/classes.rst:493
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"Les attributs 'données' peuvent être référencés par des méthodes comme par "
"des utilisateurs ordinaires (\"clients\") d'un objet. En d'autres termes, "
"les classes ne sont pas utilisables pour implémenter des types de données "
"purement abstraits. En fait, il n'est pas possible en Python d'imposer de "
"masquer des données — tout est basé sur des conventions (d'un autre côté, "
"l'implémentation de Python, écrite en C, peut complètement masquer les "
"détails d'implémentation et contrôler l'accès à un objet si nécessaire ; "
"ceci peut être utilisé par des extensions de Python écrites en C)."

#: ../Doc/tutorial/classes.rst:501
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Les clients doivent utiliser les attributs 'données' avec précaution --- ils "
"pourraient mettre le désordre dans les invariants gérés par les méthodes "
"avec leurs propres valeurs d'attributs. Remarquez que les clients peuvent "
"ajouter leurs propres attributs 'données' à une instance d'objet sans "
"altérer la validité des méthodes, pour autant que les noms n'entrent pas en "
"conflit --- là aussi, adopter une convention de nommage peut éviter bien des "
"problèmes."

#: ../Doc/tutorial/classes.rst:507
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Il n'y a pas de notation abrégée pour référencer des attributs 'données' (ou "
"les autres méthodes !) depuis les méthodes. Nous pensons que ceci améliore "
"en fait la lisibilité des méthodes : il n'y a aucune chance de confondre "
"variables locales et variables d'instances quand on regarde le code d'une "
"méthode."

#: ../Doc/tutorial/classes.rst:512
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Souvent, le premier argument d'une méthode est nommé ``self``. Ce n'est "
"qu'une convention : le nom ``self`` n'a aucune signification particulière en "
"Python. Notez cependant que si vous ne suivez pas cette convention, votre "
"code risque d'être moins lisible pour d'autres programmeurs Python et il est "
"aussi possible qu'un programme qui fasse l'introspection de classes repose "
"sur une telle convention."

#: ../Doc/tutorial/classes.rst:518
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Tout objet fonction qui est un attribut de classe définit une méthode pour "
"des instances de cette classe. Il n'est pas nécessaire que le texte de "
"définition de la fonction soit dans la définition de la classe : il est "
"possible d'affecter un objet fonction à une variable locale de la classe. "
"Par exemple ::"

#: ../Doc/tutorial/classes.rst:535
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`C` that refer "
"to function objects, and consequently they are all methods of instances of :"
"class:`C` --- ``h`` being exactly equivalent to ``g``.  Note that this "
"practice usually only serves to confuse the reader of a program."
msgstr ""
"Maintenant, ``f``, ``g`` et ``h`` sont toutes des attributs de la classe :"
"class:`C` et font référence à des fonctions objets. Par conséquent, ce sont "
"toutes des méthodes des instances de :class:`C` --- ``h`` est exactement "
"identique à ``g``. Remarquez qu'en pratique, ceci ne sert qu'à embrouiller "
"le lecteur d'un programme."

#: ../Doc/tutorial/classes.rst:540
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Les méthodes peuvent appeler d'autres méthodes en utilisant des méthodes qui "
"sont des attributs de l'argument ``self`` ::"

#: ../Doc/tutorial/classes.rst:554
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"Les méthodes peuvent faire référence à des noms globaux de la même manière "
"que les fonctions. La portée globale associée à une méthode est le module "
"contenant la définition de la classe (la classe elle-même n'est jamais "
"utilisée en tant que portée globale). Alors qu'il est rare d'avoir une bonne "
"raison d'utiliser des données globales dans une méthode, il y a de "
"nombreuses utilisations légitimes de la portée globale : par exemple, les "
"fonctions et modules importés dans une portée globale peuvent être utilisés "
"par des méthodes, de même que les fonctions et classes définies dans cette "
"même portée. Habituellement, la classe contenant la méthode est elle-même "
"définie dans cette portée globale et, dans la section suivante, nous verrons "
"de bonnes raisons pour qu'une méthode référence sa propre classe."

#: ../Doc/tutorial/classes.rst:564
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Toute valeur est un objet et a donc une *classe* (appelée aussi son *type*). "
"Elle est stockée dans ``objet.__class__``."

#: ../Doc/tutorial/classes.rst:571
msgid "Inheritance"
msgstr "Héritage"

#: ../Doc/tutorial/classes.rst:573
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Bien sûr, ce terme de \"classe\" ne serait pas utilisé s'il n'y avait pas "
"d'héritage. La syntaxe pour définir une sous-classe est de cette forme ::"

#: ../Doc/tutorial/classes.rst:584
msgid ""
"The name :class:`BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""
"Le nom :class:`BaseClassName` doit être défini dans une portée contenant la "
"définition de la classe dérivée. À la place du nom d'une classe de base, une "
"expression est aussi autorisée. Ceci peut être utile, par exemple, lorsque "
"la classe est définie dans un autre module ::"

#: ../Doc/tutorial/classes.rst:591
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"L'exécution d'une définition de classe dérivée se déroule comme pour une "
"classe de base. Quand l'objet de la classe est construit, la classe de base "
"est mémorisée. Elle est utilisée pour la résolution des références "
"d'attributs : si un attribut n'est pas trouvé dans la classe, la recherche "
"se poursuit en regardant dans la classe de base. Cette règle est appliquée "
"récursivement si la classe de base est elle-même dérivée d'une autre classe."

#: ../Doc/tutorial/classes.rst:597
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"Il n'y a rien de particulier dans l'instanciation des classes dérivées : "
"``DerivedClassName()`` crée une nouvelle instance de la classe. Les "
"références aux méthodes sont résolues comme suit : l'attribut correspondant "
"de la classe est recherché, en remontant la hiérarchie des classes de base "
"si nécessaire, et la référence de méthode est valide si cela conduit à une "
"fonction."

#: ../Doc/tutorial/classes.rst:603
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Les classes dérivées peuvent surcharger des méthodes de leurs classes de "
"base. Comme les méthodes n'ont aucun privilège particulier quand elles "
"appellent d'autres méthodes d'un même objet, une méthode d'une classe de "
"base qui appelle une autre méthode définie dans la même classe peut en fait "
"appeler une méthode d'une classe dérivée qui la surcharge (pour les "
"programmeurs C++ : toutes les méthodes de Python sont en effet \"virtuelles"
"\")."

#: ../Doc/tutorial/classes.rst:609
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"Une méthode dans une classe dérivée peut aussi, en fait, vouloir étendre "
"plutôt que simplement remplacer la méthode du même nom de sa classe de base. "
"L'appel direct à la méthode de la classe de base s'écrit simplement "
"``BaseClassName.nomMethode(self, arguments)``. C'est parfois utile également "
"aux clients (notez bien que ceci ne fonctionne que si la classe de base est "
"accessible en tant que ``BaseClassName`` dans la portée globale)."

#: ../Doc/tutorial/classes.rst:616
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python définit deux fonctions primitives pour gérer l'héritage :"

#: ../Doc/tutorial/classes.rst:618
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"utilisez :func:`isinstance` pour tester le type d'une instance : "
"``isinstance(obj, int)`` renvoie ``True`` seulement si ``obj.__class__`` est "
"égal à :class:`int` ou à une autre classe dérivée de :class:`int` ;"

#: ../Doc/tutorial/classes.rst:622
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"utilisez :func:`issubclass` pour tester l'héritage d'une classe : "
"``issubclass(bool, int)`` renvoie ``True`` car la classe :class:`bool` est "
"une sous-classe de :class:`int`. Cependant, ``issubclass(float, int)`` "
"renvoie ``False`` car :class:`float` n'est pas une sous-classe de :class:"
"`int`."

#: ../Doc/tutorial/classes.rst:632
msgid "Multiple Inheritance"
msgstr "Héritage multiple"

#: ../Doc/tutorial/classes.rst:634
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Python gère également une forme d'héritage multiple. Une définition de "
"classe ayant plusieurs classes de base est de cette forme ::"

#: ../Doc/tutorial/classes.rst:644
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`DerivedClassName`, "
"it is searched for in :class:`Base1`, then (recursively) in the base classes "
"of :class:`Base1`, and if it was not found there, it was searched for in :"
"class:`Base2`, and so on."
msgstr ""
"Dans la plupart des cas, vous pouvez vous représenter la recherche "
"d'attributs dans les classes parentes comme étant : le plus profond d'abord, "
"de gauche à droite, sans chercher deux fois dans la même classe si elle "
"apparaît plusieurs fois dans la hiérarchie. Ainsi, si un attribut n'est pas "
"trouvé dans :class:`DerivedClassName`, il est recherché dans :class:`Base1`, "
"puis (récursivement) dans les classes de base de :class:`Base1` ; s'il n'y "
"est pas trouvé, il est recherché dans :class:`Base2` et ses classes de base, "
"et ainsi de suite."

#: ../Doc/tutorial/classes.rst:651
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"Dans les faits, c'est un peu plus complexe que ça ; l'ordre de la recherche "
"(*method resolution order, ou MRO* en anglais) change dynamiquement pour "
"gérer des appels coopératifs à :func:`super`. Cette approche est connue sous "
"le nom de la \"appel de la méthode la plus proche\" (*call-next-method* en "
"anglais) dans d'autres langages avec héritage multiple. Elle est plus "
"puissante que le simple appel à super que l'on trouve dans les langages à "
"héritage simple."

#: ../Doc/tutorial/classes.rst:657
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see https://www.python.org/download/"
"releases/2.3/mro/."
msgstr ""
"L'ordre défini dynamiquement est nécessaire car tous les cas d'héritage "
"multiple comportent une ou plusieurs relations en losange (où au moins une "
"classe peut être accédée à partir de plusieurs chemins en partant de la "
"classe la plus basse). Par exemple, puisque toutes les classes héritent de :"
"class:`object`, tout héritage multiple ouvre plusieurs chemins pour "
"atteindre :class:`object`. Pour qu'une classe de base ne soit pas appelée "
"plusieurs fois, l'algorithme dynamique linéarise l'ordre de recherche d'une "
"façon qui préserve l'ordre d'héritage, de la gauche vers la droite, spécifié "
"dans chaque classe, qui appelle chaque classe parente une seule fois, qui "
"est monotone (ce qui signifie qu'une classe peut être sous-classée sans "
"affecter l'ordre d'héritage de ses parents). Prises ensemble, ces propriétés "
"permettent de concevoir des classes de façon fiable et extensible dans un "
"contexte d'héritage multiple. Pour plus de détails, consultez http://www."
"python.org/download/releases/2.3/mro/."

#: ../Doc/tutorial/classes.rst:674
msgid "Private Variables"
msgstr "Variables privées"

#: ../Doc/tutorial/classes.rst:676
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"Les membres \"privés\", qui ne peuvent être accédés que depuis l'intérieur "
"d'un objet, n'existent pas en Python. Toutefois, il existe une convention "
"respectée par la majorité du code Python : un nom préfixé par un tiret bas "
"(comme ``_spam``) doit être considéré comme une partie non publique de l'API "
"(qu'il s'agisse d'une fonction, d'une méthode ou d'un attribut 'données'). "
"Il doit être vu comme un détail d'implémentation pouvant faire l'objet de "
"modifications futures sans préavis."

#: ../Doc/tutorial/classes.rst:686
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Dès lors qu'il y a un cas d'utilisation valable pour avoir des attributs "
"privés aux classes (notamment pour éviter des conflits avec des noms définis "
"dans des sous-classes), il existe un support (certes limité) pour un tel "
"mécanisme, appelé :dfn:`name mangling`. Tout identifiant de la forme "
"``__spam`` (avec au moins deux tirets bas en tête et au plus un à la fin) "
"est remplacé textuellement par ``_classname__spam``, où ``classname`` est le "
"nom de la classe sans le ou les premiers tirets-bas. Ce \"découpage\" est "
"effectué sans tenir compte de la position syntaxique de l'identifiant, tant "
"qu'il est présent dans la définition d'une classe."

#: ../Doc/tutorial/classes.rst:695
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"Ce changement de nom est utile pour permettre à des sous-classes de "
"surcharger des méthodes sans casser les appels de méthodes à l'intérieur "
"d'une classe. Par exemple ::"

#: ../Doc/tutorial/classes.rst:717
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"L'exemple si dessus fonctionnerait même si ``MappingSubclass`` introduisait "
"un identifieur ``__update`` puisqu'il a été remplacé avec "
"``_Mapping__update`` dans la classe ``Mapping`` et "
"``_MappingSubclass__update`` dans la classe ``MappingSubclass`` "
"respectivement."

#: ../Doc/tutorial/classes.rst:722
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Notez que ces règles sont conçues avant tout pour éviter les accidents ; il "
"reste possible d'accéder ou de modifier une variable considérée comme "
"privée. Ceci peut même être utile dans certaines circonstances, comme au "
"sein du débogueur."

#: ../Doc/tutorial/classes.rst:726
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Remarquez que le code que vous passez à ``exec()``, ``eval()`` ne considère "
"pas le nom de la classe appelante comme étant la classe courante ; le même "
"effet s'applique à la directive ``global`` dont l'effet est, de la même "
"façon, restreint au code compilé dans le même ensemble de byte-code. Les "
"mêmes restrictions s'appliquent à ``getattr()``, ``setattr()`` et "
"``delattr()``, ainsi qu'aux références directes à ``__dict__``."

#: ../Doc/tutorial/classes.rst:737
msgid "Odds and Ends"
msgstr "Trucs et astuces"

#: ../Doc/tutorial/classes.rst:739
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items.  An empty class "
"definition will do nicely::"
msgstr ""
"Il est parfois utile d'avoir un type de donnée similaire au \"record\" du "
"Pascal ou au *struct* du C, qui regroupent ensemble quelques attributs "
"'données' nommés. La définition d'une classe vide remplit parfaitement ce "
"besoin ::"

#: ../Doc/tutorial/classes.rst:753
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`read` and :meth:`!"
"readline` that get the data from a string buffer instead, and pass it as an "
"argument."
msgstr ""
"À du code Python qui s'attend à recevoir un type de donnée abstrait "
"spécifique, on peut souvent fournir une classe qui simule les méthodes de ce "
"type. Par exemple, à une fonction qui formate des données extraites d'un "
"objet fichier, vous pouvez lui passer comme argument une instance d'une "
"classe qui implémente les méthodes :meth:`read` et :meth:`!readline` en "
"puisant ses données à partir d'un tampon de chaînes de caractères."

#: ../Doc/tutorial/classes.rst:764
msgid ""
"Instance method objects have attributes, too: ``m.__self__`` is the instance "
"object with the method :meth:`m`, and ``m.__func__`` is the function object "
"corresponding to the method."
msgstr ""
"Les objets méthodes d'instances ont aussi des attributs : ``m.__self__`` est "
"l'instance d'objet avec la méthode :meth:`m` et ``m.__func__`` est l'objet "
"fonction correspondant à la méthode."

#: ../Doc/tutorial/classes.rst:772
msgid "Iterators"
msgstr "Itérateurs"

#: ../Doc/tutorial/classes.rst:774
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Vous avez maintenant certainement remarqué que l'on peut itérer sur la "
"plupart des objets conteneurs en utilisant une instruction :keyword:`for` ::"

#: ../Doc/tutorial/classes.rst:788
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""
"Ce style est simple, concis et pratique. L'utilisation d'itérateurs imprègne "
"et unifie Python. En arrière plan, l'instruction :keyword:`for` appelle la "
"fonction :func:`iter` sur l'objet conteneur. Cette fonction renvoie un objet "
"itérateur qui définit la méthode :meth:`~iterator.__next__`, laquelle accède "
"aux éléments du conteneur un par un. Lorsqu'il n'y a plus d'élément, :meth:"
"`~iterator.__next__` lève une exception :exc:`StopIteration` qui indique à "
"la boucle de l'instruction :keyword:`!for` de se terminer. Vous pouvez "
"appeler la méthode :meth:`~iterator.__next__` en utilisant la fonction "
"native :func:`next`. Cet exemple montre comment tout cela fonctionne ::"

#: ../Doc/tutorial/classes.rst:813
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`__iter__` method which "
"returns an object with a :meth:`~iterator.__next__` method.  If the class "
"defines :meth:`__next__`, then :meth:`__iter__` can just return ``self``::"
msgstr ""
"Une fois compris les mécanismes de gestion des itérateurs, il est simple "
"d'ajouter ce comportement à vos classes. Définissez une méthode :meth:"
"`__iter__` qui renvoie un objet disposant d'une méthode :meth:`~iterator."
"__next__`. Si la classe définit elle-même la méthode :meth:`__next__`, "
"alors :meth:`__iter__` peut simplement renvoyer ``self`` ::"

#: ../Doc/tutorial/classes.rst:850
msgid "Generators"
msgstr "Générateurs"

#: ../Doc/tutorial/classes.rst:852
msgid ""
":term:`Generator`\\s are a simple and powerful tool for creating iterators.  "
"They are written like regular functions but use the :keyword:`yield` "
"statement whenever they want to return data.  Each time :func:`next` is "
"called on it, the generator resumes where it left off (it remembers all the "
"data values and which statement was last executed).  An example shows that "
"generators can be trivially easy to create::"
msgstr ""
"Les :term:`générateurs <generator>` sont des outils simples et puissants "
"pour créer des itérateurs. Ils sont écrits comme des fonctions classiques "
"mais utilisent l'instruction :keyword:`yield` lorsqu'ils veulent renvoyer "
"des données. À chaque fois qu'il est appelé par :func:`next`, le générateur "
"reprend son exécution là où il s'était arrêté (en conservant tout son "
"contexte d'exécution). Un exemple montre très bien combien les générateurs "
"sont simples à créer ::"

#: ../Doc/tutorial/classes.rst:873
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`__iter__` and :meth:`~generator.__next__` methods "
"are created automatically."
msgstr ""
"Tout ce qui peut être fait avec des générateurs peut également être fait "
"avec des itérateurs basés sur des classes, comme décrit dans le paragraphe "
"précédent. Ce qui rend les générateurs si compacts, c'est que les méthodes :"
"meth:`__iter__` et :meth:`~generator.__next__` sont créées automatiquement."

#: ../Doc/tutorial/classes.rst:878
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Une autre fonctionnalité clé est que les variables locales ainsi que le "
"contexte d'exécution sont sauvegardés automatiquement entre les appels. Cela "
"simplifie d'autant plus l'écriture de ces fonctions et rend leur code "
"beaucoup plus lisible qu'avec une approche utilisant des variables "
"d'instance telles que ``self.index`` et ``self.data``."

#: ../Doc/tutorial/classes.rst:883
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"En plus de la création automatique de méthodes et de la sauvegarde du "
"contexte d'exécution, les générateurs lèvent automatiquement une exception :"
"exc:`StopIteration` lorsqu'ils terminent leur exécution. La combinaison de "
"ces fonctionnalités rend très simple la création d'itérateurs, sans plus "
"d'effort que l'écriture d'une fonction classique."

#: ../Doc/tutorial/classes.rst:892
msgid "Generator Expressions"
msgstr "Expressions et générateurs"

#: ../Doc/tutorial/classes.rst:894
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"Des générateurs simples peuvent être codés très rapidement avec des "
"expressions utilisant la même syntaxe que les compréhensions de listes, mais "
"en utilisant des parenthèses à la place des crochets. Ces expressions sont "
"conçues pour des situations où le générateur est utilisé tout de suite dans "
"une fonction. Ces expressions sont plus compactes mais moins souples que des "
"définitions complètes de générateurs et ont tendance à être plus économes en "
"mémoire que leur équivalent en compréhension de listes."

#: ../Doc/tutorial/classes.rst:901
msgid "Examples::"
msgstr "Exemples ::"

#: ../Doc/tutorial/classes.rst:922
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/tutorial/classes.rst:923
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
"Il existe une exception : les modules disposent d'un attribut secret en "
"lecture seule appelé :attr:`~object.__dict__` qui renvoie le dictionnaire "
"utilisé pour implémenter l'espace de nommage du module ; le nom :attr:"
"`~object.__dict__` est un attribut mais pas un nom global. Évidemment, si "
"vous l'utilisez, vous brisez l'abstraction de l'implémentation des espaces "
"de nommage. Il est donc réservé à des choses comme les débogueurs post-"
"mortem."

#~ msgid ""
#~ "Data attributes override method attributes with the same name; to avoid "
#~ "accidental name conflicts, which may cause hard-to-find bugs in large "
#~ "programs, it is wise to use some kind of convention that minimizes the "
#~ "chance of conflicts.  Possible conventions include capitalizing method "
#~ "names, prefixing data attribute names with a small unique string (perhaps "
#~ "just an underscore), or using verbs for methods and nouns for data "
#~ "attributes."
#~ msgstr ""
#~ "Les attributs 'données' surchargent les méthodes avec le même nom ; pour "
#~ "éviter des conflits de nommage, qui peuvent causer des bugs difficiles à "
#~ "trouver dans de grands programmes, il est sage d'adopter certaines "
#~ "conventions qui minimisent les risques de conflits. Parmi les conventions "
#~ "possibles, on peut citer la mise en majuscule des noms de méthodes, le "
#~ "préfixe des noms d'attributs 'données' par une chaîne courte et unique "
#~ "(parfois juste la caractère souligné) ou l'utilisation de verbes pour les "
#~ "méthodes et de noms pour les attributs 'données'."

#~ msgid "Exceptions Are Classes Too"
#~ msgstr "Les exceptions sont aussi des classes"

#~ msgid ""
#~ "User-defined exceptions are identified by classes as well.  Using this "
#~ "mechanism it is possible to create extensible hierarchies of exceptions."
#~ msgstr ""
#~ "Les exceptions définies par l'utilisateur sont également définies par des "
#~ "classes. En utilisant ce mécanisme, il est possible de créer des "
#~ "hiérarchies d'exceptions extensibles."

#~ msgid ""
#~ "There are two new valid (semantic) forms for the :keyword:`raise` "
#~ "statement::"
#~ msgstr ""
#~ "Il y a deux nouvelles formes (sémantiques) pour l'instruction :keyword:"
#~ "`raise` ::"

#~ msgid ""
#~ "In the first form, ``Class`` must be an instance of :class:`type` or of a "
#~ "class derived from it.  The first form is a shorthand for::"
#~ msgstr ""
#~ "Dans la première forme, ``Class`` doit être une instance de :class:`type` "
#~ "ou d'une classe dérivée. La seconde forme est un raccourci pour ::"

#~ msgid ""
#~ "A class in an :keyword:`except` clause is compatible with an exception if "
#~ "it is the same class or a base class thereof (but not the other way "
#~ "around --- an except clause listing a derived class is not compatible "
#~ "with a base class).  For example, the following code will print B, C, D "
#~ "in that order::"
#~ msgstr ""
#~ "Une classe dans une clause :keyword:`except` est compatible avec une "
#~ "exception si elle est de la même classe ou d'une de ses classes dérivées. "
#~ "Mais l'inverse n'est pas vrai, une clause ``except`` spécifiant une "
#~ "classe dérivée n'est pas compatible avec une classe de base. Par exemple, "
#~ "le code suivant affiche B, C et D dans cet ordre ::"

#~ msgid ""
#~ "Note that if the except clauses were reversed (with ``except B`` first), "
#~ "it would have printed B, B, B --- the first matching except clause is "
#~ "triggered."
#~ msgstr ""
#~ "Notez que si les clauses ``except`` avaient été inversées (avec ``except "
#~ "B`` en premier), il aurait affiché B, B, B --- la première clause "
#~ "``except`` correspondante étant déclenchée."

#~ msgid ""
#~ "When an error message is printed for an unhandled exception, the "
#~ "exception's class name is printed, then a colon and a space, and finally "
#~ "the instance converted to a string using the built-in function :func:"
#~ "`str`."
#~ msgstr ""
#~ "Quand un message d'erreur est imprimé pour une exception non traitée, la "
#~ "classe de l'exception est indiquée, suivie de deux points, d'un espace et "
#~ "de l'instance convertie en chaîne de caractères via la fonction :func:"
#~ "`str`."
