# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/tutorial/classes.rst:5
msgid "Classes"
msgstr "Classes"

#: ../Doc/tutorial/classes.rst:7
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Le mécanisme des classes Python ajoute au langage la notion de classes avec "
"un minimum de syntaxe et de sémantique nouvelles. C'est un mélange des "
"mécanismes rencontrés dans C++ et Modula-3. De la même manière que pour les "
"modules, les classes Python ne posent pas de barrière rigide entre leur "
"définition et l'utilisateur, mais s'appuient sur le respect de l'utilisateur "
"à ne pas causer d'effraction dans la définition. Cependant, les "
"fonctionnalités les plus importantes des classes sont conservées avec toutes "
"leur puissance : le mécanisme d'héritage autorise d'avoir plusieurs classes "
"de base, une classe dérivée peut surcharger toutes les méthodes de sa (ou "
"ses) classe(s) de base et une méthode peut faire appel à la méthode d'une "
"classe de base portant le même nom. Les objets peuvent contenir un nombre "
"arbitraire de données."

#: ../Doc/tutorial/classes.rst:17
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"Dans la terminologie C++, les membres des classes (y compris les données) "
"sont *publics* (sauf exception, voir :ref:`tut-private`) et toutes les "
"fonctions membres sont *virtuelles*. Comme avec Modulo-3, il n'y a aucune "
"façon d'accéder aux membres d'un objet à partir de ses méthodes : une "
"méthode est déclarée avec un premier argument explicite représentant "
"l'objet, et cet argument est transmis de manière implicite lors de l'appel. "
"Comme avec Smalltalk, les classes elles-mêmes sont des objets. Il existe "
"ainsi une sémantique pour les importer et les renommer. Au contraire de C++ "
"et Modulo-3, les types de base peuvent être utilisés comme classes de base "
"pour que l'utilisateur puisse les étendre. Enfin, comme en C++, la plupart "
"des opérateurs de base avec une syntaxe spéciale (opérateurs arithmétiques, "
"sous-indiçage, etc.) peuvent être redéfinis pour les instances de classes."

#: ../Doc/tutorial/classes.rst:28
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Par manque d'une terminologie universellement acceptée pour parler des "
"classes, nous ferons un usage occasionnel des termes de Smalltalk et C++. "
"Nous voulions utiliser les termes de Modula-3 puisque sa sémantique orientée "
"objet est plus proche de celle de Python que de C++, mais il est probable "
"que seul un petit nombre de lecteurs soit susceptibles de les connaître.)"

#: ../Doc/tutorial/classes.rst:37
msgid "A Word About Names and Objects"
msgstr "Quelques mots au sujet des noms et objets"

#: ../Doc/tutorial/classes.rst:39
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Les objets possèdent une existence propre et plusieurs noms peuvent être "
"utilisés (dans divers contextes) pour faire référence au même objet. Ceux-ci "
"sont connus sous le nom d'alias dans d'autres langages. Ceci est "
"habituellement peu apprécié lors d'un premier coup d'œil à Python et peut "
"être ignoré lorsqu'on travaille avec des types de base non mutables "
"(nombres, chaînes, tuples). Cependant, les alias ont éventuellement des "
"effets surprenants sur la sémantique d'un code Python mettant en jeu des "
"objets mutables comme les listes, les dictionnaires et la plupart des autres "
"types. C'est généralement utilisé au bénéfice du programme car les alias se "
"comportent, d'un certain point de vue, comme des pointeurs. Par exemple, "
"transmettre un objet n'a aucun coût car c'est simplement un pointeur qui est "
"transmis par l'implémentation ; et si une fonction modifie un objet passé en "
"argument, le code à l'origine de l'appel verra le changement. Ceci élimine "
"le besoin d'avoir deux mécanismes de transmission d'arguments comme en "
"Pascal."

#: ../Doc/tutorial/classes.rst:55
msgid "Python Scopes and Namespaces"
msgstr "Portées et espaces de noms en Python"

#: ../Doc/tutorial/classes.rst:57
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Avant de présenter les classes, nous devons parler un peu de la notion de "
"portée en Python. Les définitions de classes font d'habiles manipulations "
"avec les espaces de noms, et vous devez savoir comment les portées et les "
"espaces de noms fonctionnent. Soit dit en passant, toute connaissance sur ce "
"sujet est aussi utile aux développeurs Python expérimentés."

#: ../Doc/tutorial/classes.rst:63
msgid "Let's begin with some definitions."
msgstr "Tout d'abord, quelques définitions."

#: ../Doc/tutorial/classes.rst:65
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"Un *espace de nom* est une table de correspondance entre des noms et des "
"objets. La plupart des espaces de noms sont actuellement implémentés sous "
"forme de dictionnaires Python, mais ceci n'est normalement pas visible (sauf "
"pour les performances) et peut changer dans le futur. Comme exemples "
"d'espaces de noms, nous pouvons citer les primitives (fonctions comme :func:"
"`abs`, et les noms des exceptions de base) ; les noms globaux dans un "
"module ; et les noms locaux lors d'un appel de fonction. D'une certaine "
"manière, l'ensemble des attributs d'un objet forme lui-même un espace de "
"noms. La chose importante à retenir à propos des espaces de noms est qu'il "
"n'y a absolument aucun lien entre les noms de plusieurs espaces de noms ; "
"par exemple, deux modules différents peuvent définir une fonction "
"``maximize`` sans qu'il y ait de confusion. Les utilisateurs des modules "
"doivent préfixer le nom de la fonction avec celui du module."

#: ../Doc/tutorial/classes.rst:76
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"À ce propos, nous utilisons le mot *attribut* pour tout nom suivant un "
"point. Par exemple, dans l'expression ``z.real``, ``real`` est un attribut "
"de l'objet ``z``. Rigoureusement parlant, les références à des noms dans des "
"modules sont des références d'attributs : dans l'expression ``modname."
"funcname``, ``modname`` est un objet module et ``funcname`` est un attribut "
"de cet objet. Dans ces conditions, il existe une correspondance directe "
"entre les attributs du module et les noms globaux définis dans le module : "
"ils partagent le même espace de noms ! [#]_"

#: ../Doc/tutorial/classes.rst:84
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`the_answer` from the object named by ``modname``."
msgstr ""
"Les attributs peuvent être seulement lisibles ou aussi modifiables. S'ils "
"sont modifiables, l'affectation à un attribut est possible. Les attributs de "
"modules sont modifiables : vous pouvez écrire ``modname.the_answer = 42``. "
"Les attributs modifiables peuvent aussi être effacés avec l'instruction :"
"keyword:`del`. Par exemple, ``del modname.the_answer`` supprime l'attribut :"
"attr:`the_answer` de l'objet nommé ``modname``."

#: ../Doc/tutorial/classes.rst:90
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`__builtin__`.)"
msgstr ""
"Les espaces de noms sont créés à différents moments et ont différentes "
"durées de vie. L'espace de noms contenant les primitives est créé au "
"démarrage de l'interpréteur Python et n'est jamais effacé. L'espace de nom "
"global pour un module est créé lorsque la définition du module est lue. "
"Habituellement, les espaces de noms des modules durent aussi jusqu'à l'arrêt "
"de l'interpréteur. Les instructions exécutées par la première invocation de "
"l'interpréteur, qu'ils soient lus depuis un fichier de script ou de manière "
"interactive, sont considérés comme faisant partie d'un module appelé :mod:"
"`__main__`, de façon qu'elles possèdent leur propre espace de noms. (les "
"primitives vivent elles-mêmes dans un module, appelé :mod:`builtins`.)"

#: ../Doc/tutorial/classes.rst:100
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"L'espace de noms local d'une fonction est créé lors de son appel, puis "
"effacé lorsqu'elle renvoie un résultat ou lève une exception non prise en "
"charge. (En fait, « oublié » serait une meilleure façon de décrire ce qui se "
"passe réellement). Bien sûr, des invocations récursives ont chacune leur "
"propre espace de noms."

#: ../Doc/tutorial/classes.rst:106
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"Une *portée* est une zone textuelle d'un programme Python où un espace de "
"noms est directement accessible. « Directement accessible » signifie ici "
"qu'une référence non qualifée à un nom sera recherchée dans l'espace de noms."

#: ../Doc/tutorial/classes.rst:110
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are at least three nested scopes whose "
"namespaces are directly accessible:"
msgstr ""
"Bien que les portées soient déterminées de manière statique, elles sont "
"utilisées de manière dynamique. À n'importe quel moment de l'exécution, il y "
"a au minimum trois portées imbriquées dont les espaces de noms sont "
"directement accessibles :"

#: ../Doc/tutorial/classes.rst:114
msgid "the innermost scope, which is searched first, contains the local names"
msgstr ""
"La portée la plus au centre, celle qui est consultée en premier, contient "
"les noms locaux"

#: ../Doc/tutorial/classes.rst:115
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contains non-local, but also non-global names"
msgstr ""
"les portées des fonctions englobantes, qui sont consultées en commençant "
"avec la portée englobante la plus proche, contiennent des noms non-locaux "
"mais aussi non-globaux"

#: ../Doc/tutorial/classes.rst:117
msgid "the next-to-last scope contains the current module's global names"
msgstr "l'avant dernière portée contient les noms globaux du module courant"

#: ../Doc/tutorial/classes.rst:118
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"la portée englobante, consultée en dernier, est l'espace de noms contenant "
"les primitives"

#: ../Doc/tutorial/classes.rst:120
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the middle scope containing the module's global names. "
"Otherwise, all variables found outside of the innermost scope are read-only "
"(an attempt to write to such a variable will simply create a *new* local "
"variable in the innermost scope, leaving the identically named outer "
"variable unchanged)."
msgstr ""
"Si un nom est déclaré global, toutes les références et affectations vont "
"directement dans la portée intermédiaire contenant les noms globaux du "
"module. Dans les autres scas, toutes les variables trouvées au dehors du "
"scope le plus proche seront en lecture seule (toute tentative de modifier "
"une telle variable créera simplement une *nouvelle* variable locale dans la "
"portée la plus au centre, en laissant inchangée la variable du même nom dans "
"la portée englobante)."

#: ../Doc/tutorial/classes.rst:126
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Habituellement, la portée locale référence les noms locaux de la fonction "
"courante. En dehors des fonctions, la portée locale référence le même espace "
"de noms que la portée globale : l'espace de noms du module. Les définitions "
"de classes créent un nouvel espace de noms dans la portée locale."

#: ../Doc/tutorial/classes.rst:131
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"Il est important de réaliser que les portées sont déterminées de manière "
"textuelle : la portée globale d'une fonction définie dans un module est "
"l'espace de nom de ce module, quel que soit la provenance de cet appel. Par "
"contre, la recherche réelle des noms est faite dynamiquement au moment de "
"l'exécution. Cependant la définition du langage est en train d'évoluer vers "
"une résolution statique des noms au moment de la « compilation », donc sans "
"se baser sur une résolution dynamique ! (En réalité, les variables locales "
"sont déjà déterminées de manière statique)."

#: ../Doc/tutorial/classes.rst:139
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` statement is in "
"effect -- assignments to names always go into the innermost scope.  "
"Assignments do not copy data --- they just bind names to objects.  The same "
"is true for deletions: the statement ``del x`` removes the binding of ``x`` "
"from the namespace referenced by the local scope.  In fact, all operations "
"that introduce new names use the local scope: in particular, :keyword:"
"`import` statements and function definitions bind the module or function "
"name in the local scope.  (The :keyword:`global` statement can be used to "
"indicate that particular variables live in the global scope.)"
msgstr ""
"Une particularité de Python est que si aucune instruction :keyword:`global` "
"n'est active, les affectations de noms vont toujours dans la portée la plus "
"proche. Les affectations ne copient aucune donnée : elles se contentent de "
"lier des noms à des objets. Ceci est également vrai pour l'effacement : "
"l'instruction ``del x`` supprime la liaison de ``x`` dans l'espace de noms "
"référencé par la portée locale. En réalité, toutes les opérations qui "
"impliquent des nouveaux noms utilisent la portée locale : en particulier, "
"les instructions :keyword:`import` et les définitions de fonctions "
"effectuent une liaison du module ou du nom de fonction dans la portée "
"locale. (L'instruction :keyword:`global` peut être utilisée pour indiquer "
"qu'une variable particulière doit être dans l'espace de noms global.)"

#: ../Doc/tutorial/classes.rst:153
msgid "A First Look at Classes"
msgstr "Une première approche des classes"

#: ../Doc/tutorial/classes.rst:155
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Le concept de classes introduit quelques nouveau éléments de syntaxe, trois "
"nouveaux types d'objets ainsi que de nouveaux éléments de sémantique"

#: ../Doc/tutorial/classes.rst:162
msgid "Class Definition Syntax"
msgstr "Syntaxe de définition des classes"

#: ../Doc/tutorial/classes.rst:164
msgid "The simplest form of class definition looks like this::"
msgstr "La forme la plus simple de définition de classe ressemble à ceci : ::"

#: ../Doc/tutorial/classes.rst:173
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Les définitions de classes, comme les définitions de fonctions (définitions :"
"keyword:`def`) doivent être exécutées avant d'avoir un effet. (Vous pouvez "
"tout à fait placer une définition de classe dans une branche d'une "
"instruction conditionnelle :keyword:`if` ou encore à l'intérieur d'une "
"fonction.)"

#: ../Doc/tutorial/classes.rst:177
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"Dans la pratique, les déclarations dans une définition de classe seront "
"généralement des définitions de fonctions, mais d'autres déclarations sont "
"permises, et parfois utiles --- Nous reviendrons sur ce point plus tard. Les "
"définitions de fonction à l'intérieur d'une classe ont normalement une forme "
"particulière de liste d'arguments, dictée par les conventions d'appel aux "
"méthodes --- À nouveau, tout ceci sera expliqué plus tard."

#: ../Doc/tutorial/classes.rst:183
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"Quand une classe est définie, un nouvel espace de noms est créé et utilisé "
"comme portée locale --- Ainsi, toutes les affectations de variables locales "
"entrent dans ce nouvel espace de noms. En particulier, les définitions de "
"fonctions y lient le nom de la nouvelle fonction."

#: ../Doc/tutorial/classes.rst:188
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:"
"`ClassName` in the example)."
msgstr ""
"A la fin de la définition d'une classe, un *objet classe* est créé. C'est, "
"pour simplifier, une encapsulation du contenu de l'espace de noms créé par "
"la définition de classe. Nous reparlerons des objets classes dans la "
"prochaine section. La portée locale initiale (celle qui prévaut avant le "
"début de la définition de la classe) est réinstanciée, et l'objet de classe "
"est lié ici au nom de classe donné dans l'en-tête de définition de classe (:"
"class:`NomDeLaClasse` dans l'exemple)."

#: ../Doc/tutorial/classes.rst:200
msgid "Class Objects"
msgstr "Les objets classe"

#: ../Doc/tutorial/classes.rst:202
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Les objets classes prennent en charge deux types d'opérations : des "
"références à des attributs et l'instanciation."

#: ../Doc/tutorial/classes.rst:205
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"Les *références d'attributs* utilisent la syntaxe standard utilisée pour "
"toutes les références d'attributs en Python : ``obj.nom``. Les noms "
"d'attribut valides sont tous les noms qui se trouvaient dans l'espace de "
"noms de la classe quand l'objet classe a été créé. Donc, si la définition de "
"classe ressemble à ceci : ::"

#: ../Doc/tutorial/classes.rst:217
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"alors ``MaClasse.i`` et ``MaClasse.f`` sont des références valides à des "
"attributs, renvoyant respectivement un entier et un objet fonction. Les "
"attributs de classes peuvent également être affectés, de sorte que vous "
"pouvez modifier la valeur de ``MaClasse.i`` par affectation. :attr:`__doc__` "
"est aussi un attribut valide, renvoyant la docstring appartenant à la "
"classe : ``\"Une simple classe d'exemple\"``."

#: ../Doc/tutorial/classes.rst:223
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"L'*instanciation* de classes utilise la notation des fonctions. Considérez "
"simplement que l'objet classe est une fonction sans paramètre qui renvoie "
"une nouvelle instance de la classe. Par exemple (en considérant la classe "
"définie ci-dessus) ::"

#: ../Doc/tutorial/classes.rst:229
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"crée une nouvelle *instance* de la classe et affecte cet objet à la variable "
"locale ``x``."

#: ../Doc/tutorial/classes.rst:232
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`__init__`, like this::"
msgstr ""
"L'opération d'instanciation (en \"appelant\" un objet classe) crée un objet "
"vide. De nombreuses classes aiment créer des objets personnalisés avec des "
"instances personnalisées en fonction d'un état initial spécifique. Ainsi une "
"classe peut définir une méthode spéciale nommée: :meth:`__init__`, comme "
"ceci : ::"

#: ../Doc/tutorial/classes.rst:240
msgid ""
"When a class defines an :meth:`__init__` method, class instantiation "
"automatically invokes :meth:`__init__` for the newly-created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"Quand une classe définit une méthode :meth:`__init__`, l'instanciation de la "
"classe appelle automatiquement :meth:`__init__` pour la nouvelle instance de "
"la classe. Donc, dans cet exemple, l'initialisation d'une nouvelle instance "
"peut être obtenue par : ::"

#: ../Doc/tutorial/classes.rst:246
msgid ""
"Of course, the :meth:`__init__` method may have arguments for greater "
"flexibility.  In that case, arguments given to the class instantiation "
"operator are passed on to :meth:`__init__`.  For example, ::"
msgstr ""
"Bien sûr, la méthode :meth:`__init__` peut avoir des arguments pour une plus "
"grande flexibilité. Dans ce cas, les arguments donnés à l'opérateur "
"d'instanciation de classe sont transmis à :meth:`__init__`. Par exemple, ::"

#: ../Doc/tutorial/classes.rst:263
msgid "Instance Objects"
msgstr "Objets instance"

#: ../Doc/tutorial/classes.rst:265
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names, data attributes and methods."
msgstr ""
"Maintenant, que pouvons-nous faire avec des objets instance ? Les seules "
"opérations comprises par les objets instances sont des références "
"d'attributs. Il y a deux sortes de noms d'attributs valides, les attributs "
"données et les méthodes."

#: ../Doc/tutorial/classes.rst:269
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"Les *attributs données* correspondent à des \"variables d'instance\" en "
"Smalltalk, et aux \"membres de données\" en C++. Les attributs données n'ont "
"pas à être déclarés. Comme les variables locales, ils existent dès lors "
"qu'ils sont attribués une première fois. Par exemple, si ``x`` est "
"l'instance de :class:`MyClass` créée ci-dessus, le code suivant affiche la "
"valeur ``16``, sans laisser de traces : ::"

#: ../Doc/tutorial/classes.rst:281
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For "
"example, list objects have methods called append, insert, remove, sort, and "
"so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"L'autre type de référence à un attribut d'instance est une *méthode*. Une "
"méthode est une fonction qui \"appartient à\" un objet (en Python, le terme "
"de méthode n'est pas unique aux instances de classes : d'autres types "
"d'objets peuvent aussi avoir des méthodes. Par exemple, les objets listes "
"ont des méthodes appelées append, insert, remove, sort, et ainsi de suite. "
"Toutefois, dans la discussion qui suit, sauf indication contraire, nous "
"allons utiliser le terme de méthode exclusivement en référence à des "
"méthodes d'objets instances de classe)."

#: ../Doc/tutorial/classes.rst:290
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Les noms de méthodes valides d'un objet instance dépendent de sa classe. Par "
"définition, tous les attributs d'une classe qui sont des objets  fonction "
"définissent les méthodes correspondantes de ses instances. Donc, dans notre "
"exemple, ``x.f`` est une méthode de référence valide, car ``MaClasse.f`` est "
"une fonction, mais pas ``x.i`` car ``MaClasse.i`` n'en est pas une. "
"Attention cependant, ``x.f`` n'est pas la même chose que ``MaClasse.f`` --- "
"Il s'agit d'un *objet méthode*, pas d'un objet fonction."

#: ../Doc/tutorial/classes.rst:301
msgid "Method Objects"
msgstr "Les objets méthode"

#: ../Doc/tutorial/classes.rst:303
msgid "Usually, a method is called right after it is bound::"
msgstr "Le plus souvent, une méthode est appelée juste après avoir été liée::"

#: ../Doc/tutorial/classes.rst:307
msgid ""
"In the :class:`MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"Dans l'exemple de la class :class:`MaClass`, cela va retourner la chaîne de "
"caractères ``hello world``. Toutefois, il n'est pas nécessaire d'appeler la "
"méthode directement: ``x.f`` est un objet méthode, il peut être gardé de "
"coté et être appelé plus tard. Par exemple::"

#: ../Doc/tutorial/classes.rst:315
msgid "will continue to print ``hello world`` until the end of time."
msgstr "va afficher ``hello world`` jusqu'à la fin des temps."

#: ../Doc/tutorial/classes.rst:317
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"Que ce passe-t-il exactement quand une méthode est appelée ? Vous avez dû "
"remarquer que ``x.f()`` a été appelée dans le code ci-dessus sans argument, "
"alors que la définition de la méthode :meth:`f` spécifie bien qu'elle prend "
"un argument. Qu'est-il arrivé à l'argument ? Python doit sûrement lever une "
"exception lorsqu'une fonction qui requiert un argument est appelée sans -- "
"même si l'argument n'est pas utilisé..."

#: ../Doc/tutorial/classes.rst:323
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the object is passed as the first argument of the function.  In our "
"example, the call ``x.f()`` is exactly equivalent to ``MyClass.f(x)``.  In "
"general, calling a method with a list of *n* arguments is equivalent to "
"calling the corresponding function with an argument list that is created by "
"inserting the method's object before the first argument."
msgstr ""
"En fait, vous aurez peut-être deviné la réponse : la particularité des "
"méthodes est que l'objet est passé comme premier argument de la fonction. "
"Dans notre exemple, l'appel ``x.f ()`` est exactement équivalent à "
"``MaClasse.f(x)``. En général, appeler une méthode avec une liste "
"d'arguments *n* est équivalent à appeler la fonction correspondante avec "
"cette liste d'arguments modulo l'insertion de l'objet de la méthode avant le "
"premier argument."

#: ../Doc/tutorial/classes.rst:330
msgid ""
"If you still don't understand how methods work, a look at the implementation "
"can perhaps clarify matters.  When an instance attribute is referenced that "
"isn't a data attribute, its class is searched.  If the name denotes a valid "
"class attribute that is a function object, a method object is created by "
"packing (pointers to) the instance object and the function object just found "
"together in an abstract object: this is the method object.  When the method "
"object is called with an argument list, a new argument list is constructed "
"from the instance object and the argument list, and the function object is "
"called with this new argument list."
msgstr ""
"Si vous ne comprenez toujours pas comment les méthodes fonctionnent, un coup "
"d'œil à l'implémentation vous aidera peut être. Lorsque l'instance d'un "
"attribut est référencé qui n'est pas un attribut donnée, sa classe est "
"recherchée. Si le nom correspond à un attribut valide qui est une fonction, "
"un objet méthode est créé en associant (via leurs pointeurs) l'objet "
"instance et l'objet fonction trouvé ensemble dans un nouvel objet abstrait : "
"c'est l'objet méthode. Lorsque l'objet méthode est appelé avec une liste "
"d'arguments, une nouvelle liste d'arguments est construite à partir de "
"l'objet méthode et de la liste des arguments. L'objet fonction est appelé "
"avec cette nouvelle liste d'arguments."

#: ../Doc/tutorial/classes.rst:344
msgid "Class and Instance Variables"
msgstr "Classes et variables d'instance"

#: ../Doc/tutorial/classes.rst:346
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"En général, les variables d'instance stockent des informations relatives à "
"chaque instance alors que les variables de classe servent à stocker les "
"attributs et méthodes communes à toutes les instances de la classe::"

#: ../Doc/tutorial/classes.rst:368
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Comme vu dans :ref:`tut-object`, les données partagées :term:`modifiables "
"<mutable>` (tel que les listes, dictionnaires, etc...) peuvent avoir des "
"effets surprenants. Part exemple, la liste *tricks* dans le code suivant ne "
"devrait pas être une variable de classe, car jiate une seule liste serait "
"partagées par toutes les instances de *Dog*::"

#: ../Doc/tutorial/classes.rst:391
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"Une conception correcte de la classe serait d'utiliser une variable "
"d'instance à la place : :"

#: ../Doc/tutorial/classes.rst:415
msgid "Random Remarks"
msgstr "Remarques diverses"

#: ../Doc/tutorial/classes.rst:419
msgid ""
"Data attributes override method attributes with the same name; to avoid "
"accidental name conflicts, which may cause hard-to-find bugs in large "
"programs, it is wise to use some kind of convention that minimizes the "
"chance of conflicts.  Possible conventions include capitalizing method "
"names, prefixing data attribute names with a small unique string (perhaps "
"just an underscore), or using verbs for methods and nouns for data "
"attributes."
msgstr ""
"Les attributs de données surchargent les méthodes avec le même nom ; pour "
"éviter des conflits de nommage, qui peuvent causer des bugs difficiles à "
"trouver dans de grands programmes, il est sage d'adopter certaines "
"conventions qui minimisent les risques de conflits. Les conventions "
"possibles comprennent la mise en majuscule des noms de méthodes, le préfixe "
"des noms d'attributs de données par une chaîne courte et unique (parfois "
"juste la caractère souligné), ou l'utilisation de verbes pour les méthodes "
"et de noms pour les attributs de données."

#: ../Doc/tutorial/classes.rst:426
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"Les attributs de données peuvent être référencés par des méthodes comme par "
"des utilisateurs ordinaires (\"clients\") d'un objet. En d'autres termes, "
"les classes ne sont pas utilisables pour implémenter des types de données "
"purement abstraits. En fait, rien en Python ne rend possible d'imposer de "
"masquer des données --- tout est basé sur des conventions (d'un autre coté, "
"l'implémentation Python, écrite en C, peut complètement masquer les détails "
"d'implémentation et contrôler l'accès à un objet si nécessaire ; ceci peut "
"être utilisé par des extensions de Python écrites en C)."

#: ../Doc/tutorial/classes.rst:434
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Les clients doivent utiliser les attributs de données avec précaution --- "
"ils pourraient mettre le désordre dans les invariants gérés par les méthodes "
"avec leurs propres valeurs d'attributs. Remarquez que les clients peuvent "
"ajouter leurs propres attributs de données à une instance d'objet sans "
"altérer la validité des méthodes, pour autant que les noms n'entrent pas en "
"conflit --- aussi, adopter une convention de nommage peut éviter bien des "
"problèmes."

#: ../Doc/tutorial/classes.rst:440
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Il n'y a pas de notation abrégée pour référencer des attributs de données "
"(ou d'autres méthodes !) depuis les méthodes. Nous pensons que ceci améliore "
"en fait la lisibilité des méthodes : il n'y a aucune chance de confondre "
"variables locales et variables d'instances quand on regarde le code d'une "
"méthode."

#: ../Doc/tutorial/classes.rst:445
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Souvent, le premier argument d'une méthode est nommé ``self``. Ce n'est "
"qu'une convention : le nom ``self`` n'a aucune signification particulière en "
"Python. Notez cependant que si vous ne suivez pas cette convention, votre "
"code risque d'être moins lisible pour d'autres programmeurs Python, et il "
"est aussi possible qu'un programme qui fasse l'introspection de classes "
"repose sur une telle convention."

#: ../Doc/tutorial/classes.rst:451
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Tout objet fonction qui est un attribut de classe définit une méthode pour "
"des instances de cette classe. Il n'est pas nécessaire que le texte de "
"définition de la fonction soit dans la définition de la classe : il est "
"possible d'affecter un objet fonction à une variable locale de la classe. "
"Par exemple : ::"

#: ../Doc/tutorial/classes.rst:468
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`C` that refer "
"to function objects, and consequently they are all methods of instances of :"
"class:`C` --- ``h`` being exactly equivalent to ``g``.  Note that this "
"practice usually only serves to confuse the reader of a program."
msgstr ""
"Maintenant, ``f``, ``g`` et ``h`` sont tous des attributs des classes :class:"
"`C` faisant référence aux fonctions objets, et par conséquent sont toutes "
"des méthodes des instances de :class:`C` --- ``h`` est exactement identique "
"à ``g``. Remarquez qu'en pratique, ceci ne sert qu'à embrouiller le lecteur "
"d'un programme."

#: ../Doc/tutorial/classes.rst:473
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Les méthodes peuvent appeler d'autres méthodes en utilisant des méthodes qui "
"sont des attributs de l'argument ``self`` ::"

#: ../Doc/tutorial/classes.rst:487
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"Les méthodes peuvent faire référence à des noms globaux de la même manière "
"que les fonctions. La portée globale associée à une méthode est le module "
"contenant la définition de la classe (la classe elle même n'est jamais "
"utilisée en tant que portée globale). Alors qu'on rencontre rarement une "
"bonne raison d'utiliser des données globales dans une méthode, il y a de "
"nombreuses utilisations légitimes d'une portée globale : par exemple, les "
"fonctions et modules importés dans une portée globale peuvent être utilisés "
"par des méthodes, de même que les fonctions et classes définies dans cette "
"même portée. Habituellement, la classe contenant la méthode est elle même "
"définie dans cette portée globale, et dans la section suivante, nous verrons "
"de bonnes raisons pour qu'une méthode référence sa propre classe."

#: ../Doc/tutorial/classes.rst:497
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Toute valeur est un objet, et a donc une *classe* (appelé aussi son *type*). "
"Elle est stockée dans ``objet.__class__``."

#: ../Doc/tutorial/classes.rst:504
msgid "Inheritance"
msgstr "L'héritage"

#: ../Doc/tutorial/classes.rst:506
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Bien sûr, ce terme de «classe» ne serait pas utilisé s'il n'y avait pas "
"l'héritage. La syntaxe pour définir une sous-classe ressemble à ceci : ::"

#: ../Doc/tutorial/classes.rst:517
msgid ""
"The name :class:`BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""
"Le nom :class:`ClasseDeBase` doit être défini dans un espace contenant la "
"définition de la classe dérivée. A la place du nom d'une classe de base, une "
"expression est aussi autorisée. Ceci peut être utile, par exemple, lorsque "
"la classe est définie dans un autre module : ::"

#: ../Doc/tutorial/classes.rst:524
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"L'exécution d'une définition de classe dérivée se déroule comme pour une "
"classe de base. Quand l'objet de la classe est construit, la classe de base "
"est mémorisée. Elle est utilisée pour la résolution des références "
"d'attributs : si un attribut n'est pas trouvé dans la classe, la recherche "
"procède en regardant dans la classe de base. Cette règle est appliquée "
"récursivement si la classe de base est elle-même dérivée d'une autre classe."

#: ../Doc/tutorial/classes.rst:530
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"Il n'y a rien de particulier dans l'instantiation des classes dérivées : "
"``DerivedClassName()`` crée une nouvelle instance de la classe. Les "
"références aux méthodes sont résolues comme suit : l'attribut correspondant "
"de la classe est recherché, en remontant la hiérarchie des classes de base "
"si nécessaire, et la référence de méthode est valide si cela conduit à une "
"fonction."

#: ../Doc/tutorial/classes.rst:536
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Les classes dérivées peuvent surcharger des méthodes de leurs classes de "
"base. Comme les méthodes n'ont aucun privilège particulier quand elles "
"appellent d'autres méthodes d'un même objet, une méthode d'une classe de "
"base qui appelle une autre méthode définie dans la même classe peut en fait "
"appeler une méthode d'une classe dérivée qui la surcharge (pour les "
"programmeurs C++ : toutes les méthodes de Python sont en effet ``virtual``)."

#: ../Doc/tutorial/classes.rst:542
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"Une méthode surchargée dans une classe dérivée peut en fait vouloir étendre "
"plutôt que simplement remplacer la méthode du même nom de sa classe de base. "
"Il y a une façon simple d'appeler la méthode de la classe de base "
"directement : appelez simplement ``BaseClassName.methodname(self, "
"arguments)``. Ceci est parfois utile également aux clients (notez bien que "
"ceci ne fonctionne que si la classe de base est accessible en tant que "
"``ClasseDeBase`` dans la portée globale)."

#: ../Doc/tutorial/classes.rst:549
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python a deux fonctions primitives qui gèrent l'héritage :"

#: ../Doc/tutorial/classes.rst:551
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"Utilisez :func:`isinstance` pour tester le type d'une instance : "
"``isinstance(obj, int)`` renverra ``True`` seulement si ``obj.__class__`` "
"est égal à :class:`int` ou à une autre classe dérivée de :class:`int`."

#: ../Doc/tutorial/classes.rst:555
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(unicode, str)`` is ``False`` since :class:`unicode` is not a "
"subclass of :class:`str` (they only share a common ancestor, :class:"
"`basestring`)."
msgstr ""
"Utilisez :func:`issubclass` pour tester l'héritage d'une class : "
"``issubclass(bool, int)`` renvoie ``True`` car la class :class:`bool` est "
"une sous-classe de :class:`int`. Par contre, ``issubclass(unicode, str)`` "
"renvoie ``False`` car :class:`unicode` n'est pas une sous-classe de :class:"
"`str` (ils partagent seulement un ancêtre commun, :class:`basestring`)."

#: ../Doc/tutorial/classes.rst:566
msgid "Multiple Inheritance"
msgstr "L'héritage multiple"

#: ../Doc/tutorial/classes.rst:568
msgid ""
"Python supports a limited form of multiple inheritance as well.  A class "
"definition with multiple base classes looks like this::"
msgstr ""
"Python propose également une forme d'héritage multiple. Une définition de "
"classe ayant plusieurs classes de base ressemble à : ::"

#: ../Doc/tutorial/classes.rst:578
msgid ""
"For old-style classes, the only rule is depth-first, left-to-right.  Thus, "
"if an attribute is not found in :class:`DerivedClassName`, it is searched "
"in :class:`Base1`, then (recursively) in the base classes of :class:`Base1`, "
"and only if it is not found there, it is searched in :class:`Base2`, and so "
"on."
msgstr ""
"Pour les anciennes classes, la seule règle est : en profondeur, de gauche à "
"droite. Ainsi, si un attribut n'est pas trouvé dans :class:"
"`NomDeLaClasseDerivee`, il est recherché dans :class:`Base1`, puis "
"(récursivement) dans les classes de base de :class:`Base1` ; s'il n'y est "
"pas trouvé, il est recherché dans :class:`Base2` et ses classes de base, et "
"ainsi de suite."

#: ../Doc/tutorial/classes.rst:583
msgid ""
"(To some people breadth first --- searching :class:`Base2` and :class:"
"`Base3` before the base classes of :class:`Base1` --- looks more natural.  "
"However, this would require you to know whether a particular attribute of :"
"class:`Base1` is actually defined in :class:`Base1` or in one of its base "
"classes before you can figure out the consequences of a name conflict with "
"an attribute of :class:`Base2`.  The depth-first rule makes no differences "
"between direct and inherited attributes of :class:`Base1`.)"
msgstr ""
"(Pour certaines personnes, commencer la recherche \"en largeur\" --- "
"chercher dans :class:`Base2` et :class:`Base3` avant d'aller dans les "
"classes de base de :class:`Base1` --- peut sembler plus naturel. Toutefois, "
"ceci nécessiterait de savoir si un attribut particulier de :class:`Base1` "
"est actuellement défini dans :class:`Base1` ou dans l'une de ses classes de "
"base avant de pouvoir envisager les conséquences d'un conflit de nom avec un "
"attribut de :class:`Base2`. La règle qui consiste à rechercher d'abord en "
"profondeur ne fait aucune différence entre des attributs définis localement "
"et des attributs hérités de :class:`Base1`)."

#: ../Doc/tutorial/classes.rst:591
msgid ""
"For :term:`new-style class`\\es, the method resolution order changes "
"dynamically to support cooperative calls to :func:`super`.  This approach is "
"known in some other multiple-inheritance languages as call-next-method and "
"is more powerful than the super call found in single-inheritance languages."
msgstr ""
"Pour les :term:`nouvelles classes <new-style class>`, l'ordre de résolution "
"des méthodes change dynamiquement pour gérer les appels coopératifs de la "
"fonction :func:`super`. Cette approche est connue dans certains langages "
"supportant l'héritage multiple sous le nom de la \"méthode la plus proche"
"\" (\"call-next-method\"), et est plus puissante que le seul appel de la "
"méthode \"super\" que l'on trouve dans les langages ne gérant que l'héritage "
"simple."

#: ../Doc/tutorial/classes.rst:596
msgid ""
"With new-style classes, dynamic ordering is necessary because all  cases of "
"multiple inheritance exhibit one or more diamond relationships (where at "
"least one of the parent classes can be accessed through multiple paths from "
"the bottommost class).  For example, all new-style classes inherit from :"
"class:`object`, so any case of multiple inheritance provides more than one "
"path to reach :class:`object`.  To keep the base classes from being accessed "
"more than once, the dynamic algorithm linearizes the search order in a way "
"that preserves the left-to-right ordering specified in each class, that "
"calls each parent only once, and that is monotonic (meaning that a class can "
"be subclassed without affecting the precedence order of its parents).  Taken "
"together, these properties make it possible to design reliable and "
"extensible classes with multiple inheritance.  For more detail, see https://"
"www.python.org/download/releases/2.3/mro/."
msgstr ""
"Avec les nouvelles classes, l'ordre défini dynamiquement est nécessaire car "
"tous les cas d'héritage multiple comportent un arbre d'héritage en losange "
"(au moins l'une des classes parentes peut être accédée via plusieurs chemins "
"à partir d'une même sous-classe). Par exemple, toutes les nouvelles classes "
"héritent de :class:`object`, donc n'importe quel arbre d'héritage multiple "
"fournit plus d'un chemin pour atteindre :class:`object`. Pour qu'une classe "
"de base ne soit pas appelée plusieurs fois, l'algorithme dynamique linéarise "
"l'ordre de recherche d'une façon qui préserve l'ordre d'héritage, de la "
"gauche vers la droite, spécifié dans chaque classe, qui appelle chaque "
"classe parente une seule fois, qui est monotone (ce qui signifie qu'une "
"classe peut être sous-classée sans affecter l'ordre d'héritage de ses "
"parents). Prises ensemble, ces propriétés permettent de concevoir des "
"classes de façon fiable et extensible dans un contexte d'héritage multiple. "
"Pour plus de détail, consultez http://www.python.org/download/releases/2.3/"
"mro/."

#: ../Doc/tutorial/classes.rst:614
msgid "Private Variables and Class-local References"
msgstr "Variables privées et références locales aux classes"

#: ../Doc/tutorial/classes.rst:616
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"Les membres \"privés\", qui ne peuvent être accédés en dehors d'un objet, "
"n'existent pas en Python. Toutefois, il existe une convention respectée par "
"la majorité du code Python : un nom préfixé par un tiret bas (comme "
"``_spam``) doit être vu comme une partie non publique de l'API (qu'il "
"s'agisse d'une fonction, d'une méthode ou d'une variable membre). Il doit "
"être considéré comme un détail d'implémentation pouvant faire l'objet de "
"modification futures sans préavis."

#: ../Doc/tutorial/classes.rst:623
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Dès lors qu'il y a un cas d'utilisation valable pour avoir des membres "
"privés (notamment pour éviter des conflits avec des noms définis dans des "
"sous-classes), il existe un support (certes limité) pour un tel mécanisme, "
"appelé :dfn:`name mangling`. Tout identifiant sous la forme ``__spam`` (avec "
"au moins deux underscores en tête, et au plus un à la fin) est remplacé "
"textuellement par ``_classname__spam``, où ``classname`` est le nom de la "
"classe sans le(s) premier(s) underscore(s). Ce \"bricolage\" est effectué "
"sans tenir compte de la position syntaxique de l'identifiant, tant qu'il est "
"présent dans la définition d'une classe."

#: ../Doc/tutorial/classes.rst:632
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"Ce changement de nom est utile pour permettre à des sous-classes de "
"surcharger des méthodes sans interrompre les appels de méthodes intra-"
"classes. Par exemple : ::"

#: ../Doc/tutorial/classes.rst:654
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Notez que ces règles sont conçues avant tout pour éviter les accidents ; il "
"reste possible d'accéder ou de modifier une variable considérée comme "
"privée. Ceci peut même être utile dans certaines circonstances, comme au "
"sein du débogueur."

#: ../Doc/tutorial/classes.rst:658
msgid ""
"Notice that code passed to ``exec``, ``eval()`` or ``execfile()`` does not "
"consider the classname of the invoking  class to be the current class; this "
"is similar to the effect of the  ``global`` statement, the effect of which "
"is likewise restricted to  code that is byte-compiled together.  The same "
"restriction applies to ``getattr()``, ``setattr()`` and ``delattr()``, as "
"well as when referencing ``__dict__`` directly."
msgstr ""
"Notez que le code passé à ``exec()``, ``eval()`` ou ``execfile()`` ne "
"considère pas le nom de la classe appelante comme étant la classe courante ; "
"le même effet s'applique à la directive ``gloabl``, dont l'effet est de la "
"même façon restreint au code compilé dans le même ensemble de byte-code. Les "
"mêmes restrictions s'appliquent à ``getattr()``, ``setattr()`` et "
"``delattr()``, ainsi qu'aux références directes à ``__dict__``."

#: ../Doc/tutorial/classes.rst:669
msgid "Odds and Ends"
msgstr "Trucs et astuces"

#: ../Doc/tutorial/classes.rst:671
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items.  An empty class "
"definition will do nicely::"
msgstr ""
"Il est parfois utile d'avoir un type de donnée similaire au \"record\" du "
"Pascal ou au \"struct\" du C, qui regroupent ensemble quelques attributs "
"nommés. La définition d'une classe vide remplit parfaitement ce besoin : ::"

#: ../Doc/tutorial/classes.rst:685
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`read` and :meth:`!"
"readline` that get the data from a string buffer instead, and pass it as an "
"argument."
msgstr ""
"On peut souvent fournir, à du code Python qui s'attend à recevoir un type de "
"donnée abstrait spécifique, une classe qui simule les méthodes de ce type. "
"Par exemple, si vous avez une fonction qui formate des données extraites "
"d'un objet fichier, vous pouvez définir une classe avec des méthodes :meth:"
"`read` et :meth:`!readline` qui extrait ses données d'un tampon de chaînes "
"de caractères à la place, et lui passer une instance comme argument."

#: ../Doc/tutorial/classes.rst:696
msgid ""
"Instance method objects have attributes, too: ``m.im_self`` is the instance "
"object with the method :meth:`m`, and ``m.im_func`` is the function object "
"corresponding to the method."
msgstr ""
"Les objets méthodes d'instances ont également des attributs : ``m.im_self`` "
"est l'instance d'objet avec la méthode :meth:`m`, et ``m.im_func`` est "
"l'objet fonction correspondant à la méthode."

#: ../Doc/tutorial/classes.rst:704
msgid "Exceptions Are Classes Too"
msgstr "Les exceptions sont aussi des classes"

#: ../Doc/tutorial/classes.rst:706
msgid ""
"User-defined exceptions are identified by classes as well.  Using this "
"mechanism it is possible to create extensible hierarchies of exceptions."
msgstr ""
"Les exceptions définies par l'utilisateur sont également définies par des "
"classes. En utilisant ce mécanisme, il est possible de créer des hiérarchies "
"d'exceptions extensibles."

#: ../Doc/tutorial/classes.rst:709
msgid ""
"There are two new valid (semantic) forms for the :keyword:`raise` statement::"
msgstr ""
"Il y a deux nouvelles formes (sémantiques) pour l'instruction :keyword:"
"`raise` ::"

#: ../Doc/tutorial/classes.rst:715
msgid ""
"In the first form, ``instance`` must be an instance of :class:`Class` or of "
"a class derived from it.  The second form is a shorthand for::"
msgstr ""
"Dans la première forme, ``instance`` doit être une instance de :class:"
"`Class` ou d'une classe dérivée. La seconde forme est un raccourci pour : ::"

#: ../Doc/tutorial/classes.rst:720
msgid ""
"A class in an :keyword:`except` clause is compatible with an exception if it "
"is the same class or a base class thereof (but not the other way around --- "
"an except clause listing a derived class is not compatible with a base "
"class).  For example, the following code will print B, C, D in that order::"
msgstr ""
"Une classe dans une clause :keyword:`except` est compatible avec une "
"exception si elle est de la même classe ou d'une de ses classes dérivées "
"(mais l'inverse n'est pas vrai --- une clause except spécifiant une classe "
"dérivée n'est pas compatible avec une classe de base.) Par exemple, le code "
"suivant imprimera B, C et D dans cet ordre : ::"

#: ../Doc/tutorial/classes.rst:742
msgid ""
"Note that if the except clauses were reversed (with ``except B`` first), it "
"would have printed B, B, B --- the first matching except clause is triggered."
msgstr ""
"Notez que si les clauses except avaient été inversées (avec ``except B`` en "
"premier), il aurait imprimé B, B, B --- la première clause except "
"correspondante étant déclenchée."

#: ../Doc/tutorial/classes.rst:745
msgid ""
"When an error message is printed for an unhandled exception, the exception's "
"class name is printed, then a colon and a space, and finally the instance "
"converted to a string using the built-in function :func:`str`."
msgstr ""
"Quand un message d'erreur est imprimé pour une exception non traitée, la "
"classe de l'exception est indiquée, suivie de deux points, d'un espace et de "
"l'instance convertie en chaîne de caractères via la fonction :func:`str`."

#: ../Doc/tutorial/classes.rst:753
msgid "Iterators"
msgstr "Itérateurs"

#: ../Doc/tutorial/classes.rst:755
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Vous avez maintenant certainement remarqué que l'on peut itérer sur la "
"plupart des objets conteneurs en utilisant une instruction :keyword:`for` ::"

#: ../Doc/tutorial/classes.rst:769
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator.next` "
"which accesses elements in the container one at a time.  When there are no "
"more elements, :meth:`~iterator.next` raises a :exc:`StopIteration` "
"exception which tells the :keyword:`for` loop to terminate. This example "
"shows how it all works::"
msgstr ""
"Ce mode d'accès est simple, concis et pratique. L'utilisation d'itérateurs "
"imprègne et unifie Python. En arrière plan, l'instruction :keyword:`for` "
"appelle la fonction :func:`iter` sur l'objet conteneur. Cette fonction "
"renvoie un itérateur qui définit la méthode :meth:`~iterator.next`, laquelle "
"accède aux éléments du conteneur un par un. Lorsqu'il n'y a plus d'élément, :"
"meth:`~iterator.next` lève une exception :exc:`StopIteration` qui indique à "
"la boucle de l'instruction :keyword:`for` de se terminer. Cet exemple montre "
"comment tout cela fonctionne : ::"

#: ../Doc/tutorial/classes.rst:794
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`__iter__` method which "
"returns an object with a :meth:`~iterator.next` method.  If the class "
"defines :meth:`~iterator.next`, then :meth:`__iter__` can just return "
"``self``::"
msgstr ""
"Une fois compris les mécanismes de gestion des itérateurs, il est simple "
"d'ajouter ce comportement à vos classes. Définissez une méthode :meth:"
"`__iter__`, qui retourne un objet disposant d'une méthode :meth:`~iterator."
"next`. Si la classe définit elle-même la méthode :meth:`~iterator.next`, "
"alors :meth:`__iter__` peut simplement renvoyer ``self`` ::"

#: ../Doc/tutorial/classes.rst:831
msgid "Generators"
msgstr "Générateurs"

#: ../Doc/tutorial/classes.rst:833
msgid ""
":term:`Generator`\\s are a simple and powerful tool for creating iterators.  "
"They are written like regular functions but use the :keyword:`yield` "
"statement whenever they want to return data.  Each time :func:`next` is "
"called on it, the generator resumes where it left off (it remembers all the "
"data values and which statement was last executed).  An example shows that "
"generators can be trivially easy to create::"
msgstr ""
"Les :term:`générateur`\\s sont des outils simples et puissants pour créer "
"des itérateurs. Ils sont écrits comme des fonctions classiques mais "
"utilisent l'instruction :keyword:`yield` lorsqu'ils veulent renvoyer des "
"données. À chaque fois que :func:`next` est appelée, le générateur reprend "
"son exécution là où il s'était arrété (en conservant tout son contexte "
"d'exécution). Un exemple montre très bien combien les générateurs sont "
"simples à créer : ::"

#: ../Doc/tutorial/classes.rst:854
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`__iter__` and :meth:`~generator.next` methods are "
"created automatically."
msgstr ""
"Tout ce qui peut être fait avec des générateurs peut également être fait "
"avec des itérateurs basés sur des classes, comme décrit dans le paragraphe "
"précédent. Si qui fait que les générateurs sont si compacts est que les "
"méthodes :meth:`__iter__` et :meth:`~generator.next` sont créées "
"automatiquement."

#: ../Doc/tutorial/classes.rst:859
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Une autre fonctionnalité clé est que les variables locales ainsi que le "
"contexte d'exécution sont sauvegardés automatiquement entre les appels. Cela "
"simplifie d'autant plus l'écriture de ces fonctions, et rend leur code "
"beaucoup plus lisible qu'avec une approche utilisant des variables "
"d'instance telles que ``self.index`` et ``self.data``."

#: ../Doc/tutorial/classes.rst:864
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"En plus de la création automatique de méthodes et de la sauvegarde du "
"contexte d'exécution, les générateurs lèvent automatiquement une exception :"
"exc:`StopIteration` lorsqu'ils terminent leur exécution. Combinées, ces "
"fonctionnalités rendent très simple la création d'itérateurs sans plus "
"d'effort que l'écriture d'une fonction classique."

#: ../Doc/tutorial/classes.rst:873
msgid "Generator Expressions"
msgstr "Expressions et générateurs"

#: ../Doc/tutorial/classes.rst:875
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of brackets.  "
"These expressions are designed for situations where the generator is used "
"right away by an enclosing function.  Generator expressions are more compact "
"but less versatile than full generator definitions and tend to be more "
"memory friendly than equivalent list comprehensions."
msgstr ""
"Des générateurs simples peuvent être codés très rapidement avec des "
"expressions utilisant la même syntaxe que les compréhensions de listes, mais "
"en utilisant des parenthèses à la place des crochets. Ces expressions sont "
"conçues pour des situations où le générateur est utilisé tout de suite dans "
"une fonction. Ces expressions sont plus compactes mais moins souples que des "
"définitions complètes de générateurs, et ont tendance à être plus économes "
"en mémoire que leur équivalent en compréhension de listes."

#: ../Doc/tutorial/classes.rst:882
msgid "Examples::"
msgstr "Exemples : ::"

#: ../Doc/tutorial/classes.rst:906
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/tutorial/classes.rst:907
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
"Sauf pour une chose. Les modules disposent d'un attribut secret en lecture "
"seule appelé :attr:`~object.__dict__`, qui renvoie le dictionnaire utilisé "
"pour implémenter l'espace de noms du module ; le nom :attr:`~object."
"__dict__` est un attribut mais pas un nom global. Évidemment, son "
"utilisation brise l'abstraction de l'implémentation des espaces de noms, et "
"ne doit être restreinte qu'à des choses comme des debogueurs post-mortem."
