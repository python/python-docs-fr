# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-29 21:40+0100\n"
"PO-Revision-Date: 2023-02-04 14:16+0100\n"
"Last-Translator: Jean-Michel Laprise <jmichel.dev@gmail.com>\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.1\n"

#: tutorial/controlflow.rst:5
msgid "More Control Flow Tools"
msgstr "D'autres outils de contrôle de flux"

#: tutorial/controlflow.rst:7
#, fuzzy
msgid ""
"As well as the :keyword:`while` statement just introduced, Python uses a few "
"more that we will encounter in this chapter."
msgstr ""
"En plus de l'instruction :keyword:`while` qui vient d'être présentée, Python "
"dispose des instructions de contrôle de flux classiques que l'on trouve dans "
"d'autres langages, mais toujours avec ses propres tournures."

#: tutorial/controlflow.rst:14
msgid ":keyword:`!if` Statements"
msgstr "L'instruction :keyword:`!if`"

#: tutorial/controlflow.rst:16
msgid ""
"Perhaps the most well-known statement type is the :keyword:`if` statement.  "
"For example::"
msgstr ""
"L'instruction :keyword:`if` est sans doute la plus connue. Par exemple ::"

#: tutorial/controlflow.rst:19
msgid ""
">>> x = int(input(\"Please enter an integer: \"))\n"
"Please enter an integer: 42\n"
">>> if x < 0:\n"
"...     x = 0\n"
"...     print('Negative changed to zero')\n"
"... elif x == 0:\n"
"...     print('Zero')\n"
"... elif x == 1:\n"
"...     print('Single')\n"
"... else:\n"
"...     print('More')\n"
"...\n"
"More"
msgstr ""

#: tutorial/controlflow.rst:33
msgid ""
"There can be zero or more :keyword:`elif` parts, and the :keyword:`else` "
"part is optional.  The keyword ':keyword:`!elif`' is short for 'else if', "
"and is useful to avoid excessive indentation.  An  :keyword:`!if` ... :"
"keyword:`!elif` ... :keyword:`!elif` ... sequence is a substitute for the "
"``switch`` or ``case`` statements found in other languages."
msgstr ""
"Il peut y avoir un nombre quelconque de parties :keyword:`elif` et la "
"partie :keyword:`else` est facultative. Le mot clé :keyword:`!elif` est un "
"raccourci pour *else if*, et permet de gagner un niveau d'indentation. Une "
"séquence :keyword:`!if` ... :keyword:`!elif` ... :keyword:`!elif` ... est "
"par ailleurs équivalente aux instructions ``switch`` ou ``case`` disponibles "
"dans d'autres langages."

#: tutorial/controlflow.rst:39
msgid ""
"If you're comparing the same value to several constants, or checking for "
"specific types or attributes, you may also find the :keyword:`!match` "
"statement useful. For more details see :ref:`tut-match`."
msgstr ""
"Pour les comparaisons avec beaucoup de constantes, ainsi que les tests "
"d'appartenance à un type ou de forme d'un attribut, l'instruction :keyword:`!"
"match` décrite plus bas peut se révéler utile (voir :ref:`tut-match`)."

#: tutorial/controlflow.rst:46
msgid ":keyword:`!for` Statements"
msgstr "L'instruction :keyword:`!for`"

#: tutorial/controlflow.rst:51
msgid ""
"The :keyword:`for` statement in Python differs a bit from what you may be "
"used to in C or Pascal.  Rather than always iterating over an arithmetic "
"progression of numbers (like in Pascal), or giving the user the ability to "
"define both the iteration step and halting condition (as C), Python's :"
"keyword:`!for` statement iterates over the items of any sequence (a list or "
"a string), in the order that they appear in the sequence.  For example (no "
"pun intended):"
msgstr ""
"L'instruction :keyword:`for` que propose Python est un peu différente de "
"celle que l'on peut trouver en C ou en Pascal. Au lieu de toujours itérer "
"sur une suite arithmétique de nombres (comme en Pascal), ou de donner à "
"l'utilisateur la possibilité de définir le pas d'itération et la condition "
"de fin (comme en C), l'instruction :keyword:`!for` en Python itère sur les "
"éléments d'une séquence (qui peut être une liste, une chaîne de "
"caractères…), dans l'ordre dans lequel ils apparaissent dans la séquence. "
"Par exemple :"

#: tutorial/controlflow.rst:63
msgid ""
">>> # Measure some strings:\n"
">>> words = ['cat', 'window', 'defenestrate']\n"
">>> for w in words:\n"
"...     print(w, len(w))\n"
"...\n"
"cat 3\n"
"window 6\n"
"defenestrate 12"
msgstr ""

#: tutorial/controlflow.rst:72
msgid ""
"Code that modifies a collection while iterating over that same collection "
"can be tricky to get right.  Instead, it is usually more straight-forward to "
"loop over a copy of the collection or to create a new collection::"
msgstr ""
"Écrire du code qui modifie une collection tout en itérant dessus peut "
"s'avérer délicat. Il est généralement plus simple de boucler sur une copie "
"de la collection ou de créer une nouvelle collection ::"

#: tutorial/controlflow.rst:76
msgid ""
"# Create a sample collection\n"
"users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}\n"
"\n"
"# Strategy:  Iterate over a copy\n"
"for user, status in users.copy().items():\n"
"    if status == 'inactive':\n"
"        del users[user]\n"
"\n"
"# Strategy:  Create a new collection\n"
"active_users = {}\n"
"for user, status in users.items():\n"
"    if status == 'active':\n"
"        active_users[user] = status"
msgstr ""

#: tutorial/controlflow.rst:94
msgid "The :func:`range` Function"
msgstr "La fonction :func:`range`"

#: tutorial/controlflow.rst:96
msgid ""
"If you do need to iterate over a sequence of numbers, the built-in function :"
"func:`range` comes in handy.  It generates arithmetic progressions::"
msgstr ""
"Si vous devez itérer sur une suite de nombres, la fonction native :func:"
"`range` est faite pour cela. Elle génère des suites arithmétiques ::"

#: tutorial/controlflow.rst:99
msgid ""
">>> for i in range(5):\n"
"...     print(i)\n"
"...\n"
"0\n"
"1\n"
"2\n"
"3\n"
"4"
msgstr ""

#: tutorial/controlflow.rst:108
msgid ""
"The given end point is never part of the generated sequence; ``range(10)`` "
"generates 10 values, the legal indices for items of a sequence of length "
"10.  It is possible to let the range start at another number, or to specify "
"a different increment (even negative; sometimes this is called the 'step')::"
msgstr ""
"Le dernier élément fourni en paramètre ne fait jamais partie de la liste "
"générée ; ``range(10)`` génère une liste de 10 valeurs, dont les valeurs "
"vont de 0 à 9. Il est possible de spécifier une valeur de début et une "
"valeur d'incrément différentes (y compris négative pour cette dernière, que "
"l'on appelle également parfois le « pas ») ::"

#: tutorial/controlflow.rst:113
msgid ""
">>> list(range(5, 10))\n"
"[5, 6, 7, 8, 9]\n"
"\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
"\n"
">>> list(range(-10, -100, -30))\n"
"[-10, -40, -70]"
msgstr ""

#: tutorial/controlflow.rst:122
msgid ""
"To iterate over the indices of a sequence, you can combine :func:`range` "
"and :func:`len` as follows::"
msgstr ""
"Pour itérer sur les indices d'une séquence, on peut combiner les fonctions :"
"func:`range` et :func:`len` ::"

#: tutorial/controlflow.rst:125
msgid ""
">>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n"
">>> for i in range(len(a)):\n"
"...     print(i, a[i])\n"
"...\n"
"0 Mary\n"
"1 had\n"
"2 a\n"
"3 little\n"
"4 lamb"
msgstr ""

#: tutorial/controlflow.rst:135
msgid ""
"In most such cases, however, it is convenient to use the :func:`enumerate` "
"function, see :ref:`tut-loopidioms`."
msgstr ""
"Cependant, dans la plupart des cas, il est plus pratique d'utiliser la "
"fonction :func:`enumerate`. Voyez pour cela :ref:`tut-loopidioms`."

#: tutorial/controlflow.rst:138
msgid "A strange thing happens if you just print a range::"
msgstr "Une chose étrange se produit lorsqu'on affiche un *range* ::"

#: tutorial/controlflow.rst:140
msgid ""
">>> range(10)\n"
"range(0, 10)"
msgstr ""

#: tutorial/controlflow.rst:143
msgid ""
"In many ways the object returned by :func:`range` behaves as if it is a "
"list, but in fact it isn't. It is an object which returns the successive "
"items of the desired sequence when you iterate over it, but it doesn't "
"really make the list, thus saving space."
msgstr ""
"L'objet renvoyé par :func:`range` se comporte presque comme une liste, mais "
"ce n'en est pas une. Cet objet génère les éléments de la séquence au fur et "
"à mesure de l'itération, sans réellement produire la liste en tant que "
"telle, économisant ainsi de l'espace."

#: tutorial/controlflow.rst:148
msgid ""
"We say such an object is :term:`iterable`, that is, suitable as a target for "
"functions and constructs that expect something from which they can obtain "
"successive items until the supply is exhausted.  We have seen that the :"
"keyword:`for` statement is such a construct, while an example of a function "
"that takes an iterable is :func:`sum`::"
msgstr ""
"On appelle de tels objets des :term:`itérables <iterable>`, c'est-à-dire des "
"objets qui conviennent à des fonctions ou constructions qui s'attendent à "
"quelque chose duquel elles peuvent tirer des éléments, successivement, "
"jusqu'à épuisement. Nous avons vu que l'instruction :keyword:`for` est une "
"de ces constructions, et un exemple de fonction qui prend un itérable en "
"paramètre est :func:`sum` ::"

#: tutorial/controlflow.rst:154
msgid ""
">>> sum(range(4))  # 0 + 1 + 2 + 3\n"
"6"
msgstr ""

#: tutorial/controlflow.rst:157
msgid ""
"Later we will see more functions that return iterables and take iterables as "
"arguments.  In chapter :ref:`tut-structures`, we will discuss in more detail "
"about :func:`list`."
msgstr ""
"Plus loin nous voyons d'autres fonctions qui donnent des itérables ou en "
"prennent en paramètre. De plus amples détails sur :func:`list` sont donnés "
"dans :ref:`tut-structures`."

#: tutorial/controlflow.rst:164
#, fuzzy
msgid ":keyword:`!break` and :keyword:`!continue` Statements"
msgstr ""
"Les instructions :keyword:`!break`, :keyword:`!continue` et les clauses :"
"keyword:`!else` au sein des boucles"

#: tutorial/controlflow.rst:166
#, fuzzy
msgid ""
"The :keyword:`break` statement breaks out of the innermost enclosing :"
"keyword:`for` or :keyword:`while` loop::"
msgstr ""
"L'instruction :keyword:`break`, comme en C, interrompt la boucle :keyword:"
"`for` ou :keyword:`while` la plus profonde."

#: tutorial/controlflow.rst:169
msgid ""
">>> for n in range(2, 10):\n"
"...     for x in range(2, n):\n"
"...         if n % x == 0:\n"
"...             print(f\"{n} equals {x} * {n//x}\")\n"
"...             break\n"
"...\n"
"4 equals 2 * 2\n"
"6 equals 2 * 3\n"
"8 equals 2 * 4\n"
"9 equals 3 * 3"
msgstr ""

#: tutorial/controlflow.rst:180
#, fuzzy
msgid ""
"The :keyword:`continue` statement continues with the next iteration of the "
"loop::"
msgstr ""
"L'instruction :keyword:`continue`, également empruntée au C, fait passer la "
"boucle à son itération suivante ::"

#: tutorial/controlflow.rst:183
msgid ""
">>> for num in range(2, 10):\n"
"...     if num % 2 == 0:\n"
"...         print(f\"Found an even number {num}\")\n"
"...         continue\n"
"...     print(f\"Found an odd number {num}\")\n"
"...\n"
"Found an even number 2\n"
"Found an odd number 3\n"
"Found an even number 4\n"
"Found an odd number 5\n"
"Found an even number 6\n"
"Found an odd number 7\n"
"Found an even number 8\n"
"Found an odd number 9"
msgstr ""

#: tutorial/controlflow.rst:201
#, fuzzy
msgid ":keyword:`!else` Clauses on Loops"
msgstr "L'instruction :keyword:`!pass`"

#: tutorial/controlflow.rst:203
msgid ""
"In a :keyword:`!for` or :keyword:`!while` loop the :keyword:`!break` "
"statement may be paired with an :keyword:`!else` clause.  If the loop "
"finishes without executing the :keyword:`!break`, the :keyword:`!else` "
"clause executes."
msgstr ""

#: tutorial/controlflow.rst:207
msgid ""
"In a :keyword:`for` loop, the :keyword:`!else` clause is executed after the "
"loop finishes its final iteration, that is, if no break occurred."
msgstr ""

#: tutorial/controlflow.rst:210
msgid ""
"In a :keyword:`while` loop, it's executed after the loop's condition becomes "
"false."
msgstr ""

#: tutorial/controlflow.rst:212
msgid ""
"In either kind of loop, the :keyword:`!else` clause is **not** executed if "
"the loop was terminated by a :keyword:`break`.  Of course, other ways of "
"ending the loop early, such as a :keyword:`return` or a raised exception, "
"will also skip execution of the :keyword:`else` clause."
msgstr ""

#: tutorial/controlflow.rst:217
msgid ""
"This is exemplified in the following :keyword:`!for` loop, which searches "
"for prime numbers::"
msgstr ""

#: tutorial/controlflow.rst:220
msgid ""
">>> for n in range(2, 10):\n"
"...     for x in range(2, n):\n"
"...         if n % x == 0:\n"
"...             print(n, 'equals', x, '*', n//x)\n"
"...             break\n"
"...     else:\n"
"...         # loop fell through without finding a factor\n"
"...         print(n, 'is a prime number')\n"
"...\n"
"2 is a prime number\n"
"3 is a prime number\n"
"4 equals 2 * 2\n"
"5 is a prime number\n"
"6 equals 2 * 3\n"
"7 is a prime number\n"
"8 equals 2 * 4\n"
"9 equals 3 * 3"
msgstr ""

#: tutorial/controlflow.rst:238
#, fuzzy
msgid ""
"(Yes, this is the correct code.  Look closely: the ``else`` clause belongs "
"to the ``for`` loop, **not** the ``if`` statement.)"
msgstr ""
"(Oui, ce code est correct. Regardez attentivement : l'instruction ``else`` "
"est rattachée à la boucle :keyword:`for`, et **non** à l'instruction :"
"keyword:`if`.)"

#: tutorial/controlflow.rst:241
msgid ""
"One way to think of the else clause is to imagine it paired with the ``if`` "
"inside the loop.  As the loop executes, it will run a sequence like if/if/if/"
"else. The ``if`` is inside the loop, encountered a number of times. If the "
"condition is ever true, a ``break`` will happen. If the condition is never "
"true, the ``else`` clause outside the loop will execute."
msgstr ""

#: tutorial/controlflow.rst:247
#, fuzzy
msgid ""
"When used with a loop, the ``else`` clause has more in common with the "
"``else`` clause of a :keyword:`try` statement than it does with that of "
"``if`` statements: a ``try`` statement's ``else`` clause runs when no "
"exception occurs, and a loop's ``else`` clause runs when no ``break`` "
"occurs. For more on the ``try`` statement and exceptions, see :ref:`tut-"
"handling`."
msgstr ""
"Lorsqu'elle utilisée dans une boucle, la clause ``else`` est donc plus "
"proche de celle associée à une instruction :keyword:`try` que de celle "
"associée à une instruction :keyword:`if` : la clause ``else`` d'une "
"instruction :keyword:`try` s'exécute lorsqu'aucune exception n'est "
"déclenchée, et celle d'une boucle lorsqu'aucun ``break`` n'intervient. Pour "
"plus d'informations sur l'instruction :keyword:`!try` et le traitement des "
"exceptions, consultez la section :ref:`tut-handling`."

#: tutorial/controlflow.rst:256
msgid ":keyword:`!pass` Statements"
msgstr "L'instruction :keyword:`!pass`"

#: tutorial/controlflow.rst:258
msgid ""
"The :keyword:`pass` statement does nothing. It can be used when a statement "
"is required syntactically but the program requires no action. For example::"
msgstr ""
"L'instruction :keyword:`pass` ne fait rien. Elle peut être utilisée "
"lorsqu'une instruction est nécessaire pour fournir une syntaxe correcte, "
"mais qu'aucune action ne doit être effectuée. Par exemple ::"

#: tutorial/controlflow.rst:261
msgid ""
">>> while True:\n"
"...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n"
"..."
msgstr ""

#: tutorial/controlflow.rst:265
msgid "This is commonly used for creating minimal classes::"
msgstr ""
"On utilise couramment cette instruction pour créer des classes minimales ::"

#: tutorial/controlflow.rst:267
msgid ""
">>> class MyEmptyClass:\n"
"...     pass\n"
"..."
msgstr ""

#: tutorial/controlflow.rst:271
msgid ""
"Another place :keyword:`pass` can be used is as a place-holder for a "
"function or conditional body when you are working on new code, allowing you "
"to keep thinking at a more abstract level.  The :keyword:`!pass` is silently "
"ignored::"
msgstr ""
"Un autre cas d'utilisation du :keyword:`pass` est de réserver un espace en "
"phase de développement pour une fonction ou un traitement conditionnel, vous "
"permettant ainsi de construire votre code à un niveau plus abstrait. "
"L'instruction :keyword:`!pass` est alors ignorée silencieusement ::"

#: tutorial/controlflow.rst:275
msgid ""
">>> def initlog(*args):\n"
"...     pass   # Remember to implement this!\n"
"..."
msgstr ""

#: tutorial/controlflow.rst:283
msgid ":keyword:`!match` Statements"
msgstr "L'instruction :keyword:`!match`"

#: tutorial/controlflow.rst:285
msgid ""
"A :keyword:`match` statement takes an expression and compares its value to "
"successive patterns given as one or more case blocks.  This is superficially "
"similar to a switch statement in C, Java or JavaScript (and many other "
"languages), but it's more similar to pattern matching in languages like Rust "
"or Haskell. Only the first pattern that matches gets executed and it can "
"also extract components (sequence elements or object attributes) from the "
"value into variables."
msgstr ""
"L'instruction :keyword:`match` confronte la valeur d'une expression à "
"plusieurs filtres successifs donnés par les instructions ``case``. "
"L’instruction ``match`` peut faire penser au ``switch`` que l'on trouve dans "
"les langages C, Java, JavaScript et autres, mais elle ressemble plus au "
"filtrage par motif des langages Rust et Haskell. Seul le premier filtre qui "
"correspond est exécuté et elle permet aussi d'extraire dans des variables "
"des composantes de la valeur, comme les éléments d'une séquence ou les "
"attributs d'un objet."

#: tutorial/controlflow.rst:293
msgid ""
"The simplest form compares a subject value against one or more literals::"
msgstr ""
"Dans sa plus simple expression, une instruction ``match`` compare une valeur "
"à des littéraux ::"

#: tutorial/controlflow.rst:295
msgid ""
"def http_error(status):\n"
"    match status:\n"
"        case 400:\n"
"            return \"Bad request\"\n"
"        case 404:\n"
"            return \"Not found\"\n"
"        case 418:\n"
"            return \"I'm a teapot\"\n"
"        case _:\n"
"            return \"Something's wrong with the internet\""
msgstr ""

#: tutorial/controlflow.rst:306
msgid ""
"Note the last block: the \"variable name\" ``_`` acts as a *wildcard* and "
"never fails to match. If no case matches, none of the branches is executed."
msgstr ""
"Remarquez l'emploi du signe souligné ``_`` dans le dernier bloc, qui est "
"normalement un nom de variable spécial. Ici, c'est un filtre *attrape-tout*, "
"c'est-à-dire qu'il accepte toutes les valeurs. Si aucun des filtres dans les "
"``case`` ne fonctionne, aucune des branches indentées sous les ``case`` "
"n'est exécutée."

#: tutorial/controlflow.rst:309
msgid ""
"You can combine several literals in a single pattern using ``|`` (\"or\")::"
msgstr ""
"On peut combiner plusieurs littéraux en un seul filtre avec le signe ``|``, "
"qui se lit OU ::"

#: tutorial/controlflow.rst:311
msgid ""
"case 401 | 403 | 404:\n"
"    return \"Not allowed\""
msgstr ""

#: tutorial/controlflow.rst:314
msgid ""
"Patterns can look like unpacking assignments, and can be used to bind "
"variables::"
msgstr ""
"Les filtres peuvent prendre une forme similaire aux affectations multiples, "
"et provoquer la liaison de variables ::"

#: tutorial/controlflow.rst:317
msgid ""
"# point is an (x, y) tuple\n"
"match point:\n"
"    case (0, 0):\n"
"        print(\"Origin\")\n"
"    case (0, y):\n"
"        print(f\"Y={y}\")\n"
"    case (x, 0):\n"
"        print(f\"X={x}\")\n"
"    case (x, y):\n"
"        print(f\"X={x}, Y={y}\")\n"
"    case _:\n"
"        raise ValueError(\"Not a point\")"
msgstr ""

#: tutorial/controlflow.rst:330
msgid ""
"Study that one carefully!  The first pattern has two literals, and can be "
"thought of as an extension of the literal pattern shown above.  But the next "
"two patterns combine a literal and a variable, and the variable *binds* a "
"value from the subject (``point``).  The fourth pattern captures two values, "
"which makes it conceptually similar to the unpacking assignment ``(x, y) = "
"point``."
msgstr ""
"Observez bien cet exemple ! Le premier filtre contient simplement deux "
"littéraux. C'est une sorte d'extension des filtres littéraux. Mais les deux "
"filtres suivants mélangent un littéral et un nom de variable. Si un tel "
"filtre réussit, il provoque l'affectation à la variable. Le quatrième filtre "
"est constitué de deux variables, ce qui le fait beaucoup ressembler à "
"l'affectation multiple ``(x, y) = point``."

#: tutorial/controlflow.rst:337
msgid ""
"If you are using classes to structure your data you can use the class name "
"followed by an argument list resembling a constructor, but with the ability "
"to capture attributes into variables::"
msgstr ""
"Si vous structurez vos données par l'utilisation de classes, vous pouvez "
"former des filtres avec le nom de la classe suivi d'une liste d'arguments. "
"Ces filtres sont semblables à l'appel d'un constructeur, et permettent de "
"capturer des attributs ::"

#: tutorial/controlflow.rst:341
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"def where_is(point):\n"
"    match point:\n"
"        case Point(x=0, y=0):\n"
"            print(\"Origin\")\n"
"        case Point(x=0, y=y):\n"
"            print(f\"Y={y}\")\n"
"        case Point(x=x, y=0):\n"
"            print(f\"X={x}\")\n"
"        case Point():\n"
"            print(\"Somewhere else\")\n"
"        case _:\n"
"            print(\"Not a point\")"
msgstr ""

#: tutorial/controlflow.rst:359
msgid ""
"You can use positional parameters with some builtin classes that provide an "
"ordering for their attributes (e.g. dataclasses). You can also define a "
"specific position for attributes in patterns by setting the "
"``__match_args__`` special attribute in your classes. If it's set to (\"x\", "
"\"y\"), the following patterns are all equivalent (and all bind the ``y`` "
"attribute to the ``var`` variable)::"
msgstr ""
"Un certain nombre de classes natives, notamment les classes de données, "
"prennent en charge le filtrage par arguments positionnels en définissant un "
"ordre des attributs. Vous pouvez ajouter cette possibilité à vos propres "
"classes en y définissant l'attribut spécial ``__match_args__``. Par exemple, "
"le mettre à ``(\"x\", \"y\")`` rend tous les filtres ci-dessous équivalents "
"(en particulier, tous provoquent la liaison de l'attribut ``y`` à la "
"variable ``var``) ::"

#: tutorial/controlflow.rst:365
msgid ""
"Point(1, var)\n"
"Point(1, y=var)\n"
"Point(x=1, y=var)\n"
"Point(y=var, x=1)"
msgstr ""

#: tutorial/controlflow.rst:370
msgid ""
"A recommended way to read patterns is to look at them as an extended form of "
"what you would put on the left of an assignment, to understand which "
"variables would be set to what. Only the standalone names (like ``var`` "
"above) are assigned to by a match statement. Dotted names (like ``foo."
"bar``), attribute names (the ``x=`` and ``y=`` above) or class names "
"(recognized by the \"(...)\" next to them like ``Point`` above) are never "
"assigned to."
msgstr ""
"Une méthode préconisée pour lire les filtres est de les voir comme une "
"extension de ce que l'on peut placer à gauche du signe ``=`` dans une "
"affectation. Cela permet de visualiser quelles variables sont liées à quoi. "
"Seuls les noms simples, comme ``var`` ci-dessus, sont des variables "
"susceptibles d'être liées à une valeur. Il n'y a jamais de liaison pour les "
"noms qualifiés (avec un point, comme dans ``truc.machin``), les noms "
"d'attributs (tels que ``x=`` et ``y=`` dans l'exemple précédent) et les noms "
"de classes (identifiés par les parenthèses à leur droite, comme ``Point``)."

#: tutorial/controlflow.rst:377
#, fuzzy
msgid ""
"Patterns can be arbitrarily nested.  For example, if we have a short list of "
"Points, with ``__match_args__`` added, we could match it like this::"
msgstr ""
"On peut imbriquer les filtres autant que de besoin. Ainsi, on peut lire une "
"courte liste de points comme ceci ::"

#: tutorial/controlflow.rst:380
msgid ""
"class Point:\n"
"    __match_args__ = ('x', 'y')\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"match points:\n"
"    case []:\n"
"        print(\"No points\")\n"
"    case [Point(0, 0)]:\n"
"        print(\"The origin\")\n"
"    case [Point(x, y)]:\n"
"        print(f\"Single point {x}, {y}\")\n"
"    case [Point(0, y1), Point(0, y2)]:\n"
"        print(f\"Two on the Y axis at {y1}, {y2}\")\n"
"    case _:\n"
"        print(\"Something else\")"
msgstr ""

#: tutorial/controlflow.rst:398
msgid ""
"We can add an ``if`` clause to a pattern, known as a \"guard\".  If the "
"guard is false, ``match`` goes on to try the next case block.  Note that "
"value capture happens before the guard is evaluated::"
msgstr ""
"Un filtre peut comporter un ``if``, qui introduit ce que l'on appelle une "
"garde. Si le filtre réussit, la garde est alors testée et, si elle s'évalue "
"à une valeur fausse, l'exécution continue au bloc ``case`` suivant. Les "
"variables sont liées avant l'évaluation de la garde, et peuvent être "
"utilisées à l'intérieur ::"

#: tutorial/controlflow.rst:402
msgid ""
"match point:\n"
"    case Point(x, y) if x == y:\n"
"        print(f\"Y=X at {x}\")\n"
"    case Point(x, y):\n"
"        print(f\"Not on the diagonal\")"
msgstr ""

#: tutorial/controlflow.rst:408
msgid "Several other key features of this statement:"
msgstr "Voici d’autres caractéristiques importantes de cette instruction :"

#: tutorial/controlflow.rst:410
msgid ""
"Like unpacking assignments, tuple and list patterns have exactly the same "
"meaning and actually match arbitrary sequences.  An important exception is "
"that they don't match iterators or strings."
msgstr ""
"comme dans les affectations multiples, les filtres de *n*-uplet et de liste "
"sont totalement équivalents et autorisent tous les types de séquences. "
"Exception importante, ils n'autorisent pas les itérateurs ni les chaînes de "
"caractères ;"

#: tutorial/controlflow.rst:414
msgid ""
"Sequence patterns support extended unpacking: ``[x, y, *rest]`` and ``(x, y, "
"*rest)`` work similar to unpacking assignments.  The name after ``*`` may "
"also be ``_``, so ``(x, y, *_)`` matches a sequence of at least two items "
"without binding the remaining items."
msgstr ""
"les filtres de séquence peuvent faire intervenir l'affectation étoilée : "
"``[x, y, *reste]`` ou ``(x, y, *reste)`` ont le même sens que dans une "
"affectation avec ``=``. Le nom de variable après l'étoile peut aussi être "
"l'attrape-tout ``_``. Ainsi, ``(x, y, *_)`` est un filtre qui reconnaît les "
"séquences à deux éléments ou plus, en capturant les deux premiers et en "
"ignorant le reste ;"

#: tutorial/controlflow.rst:419
msgid ""
"Mapping patterns: ``{\"bandwidth\": b, \"latency\": l}`` captures the "
"``\"bandwidth\"`` and ``\"latency\"`` values from a dictionary.  Unlike "
"sequence patterns, extra keys are ignored.  An unpacking like ``**rest`` is "
"also supported.  (But ``**_`` would be redundant, so it is not allowed.)"
msgstr ""
"Il existe des filtres d'association. Par exemple, le filtre "
"``{\"bande_passante\": b, \"latence\": l}`` extrait les valeurs des clés "
"``\"bande_passante\"`` et ``\"latence\"`` dans un dictionnaire. "
"Contrairement aux filtres de séquence, les clés absentes du filtre sont "
"ignorées. L'affectation double-étoilée (``**reste``) fonctionne aussi "
"(cependant, ``**_`` serait redondant et n'est donc pas permis) ;"

#: tutorial/controlflow.rst:424
msgid "Subpatterns may be captured using the ``as`` keyword::"
msgstr ""
"on peut capturer la valeur d'une partie d'un filtre avec le mot-clé ``as``, "
"par exemple ::"

#: tutorial/controlflow.rst:426
msgid "case (Point(x1, y1), Point(x2, y2) as p2): ..."
msgstr ""

#: tutorial/controlflow.rst:428
msgid ""
"will capture the second element of the input as ``p2`` (as long as the input "
"is a sequence of two points)"
msgstr ""
"Ce filtre, lorsqu'il est comparé à une séquence de deux points, réussit et "
"capture le second dans la variable ``p2`` ;"

#: tutorial/controlflow.rst:431
msgid ""
"Most literals are compared by equality, however the singletons ``True``, "
"``False`` and ``None`` are compared by identity."
msgstr ""
"la plupart des littéraux sont comparés par égalité. Néanmoins, les "
"singletons ``True``, ``False`` et ``None`` sont comparés par identité ;"

#: tutorial/controlflow.rst:434
msgid ""
"Patterns may use named constants.  These must be dotted names to prevent "
"them from being interpreted as capture variable::"
msgstr ""
"les filtres peuvent contenir des noms qui se réfèrent à des constantes. Ces "
"noms doivent impérativement être qualifiés (contenir un point) pour ne pas "
"être interprétés comme des variables de capture ::"

#: tutorial/controlflow.rst:437
msgid ""
"from enum import Enum\n"
"class Color(Enum):\n"
"    RED = 'red'\n"
"    GREEN = 'green'\n"
"    BLUE = 'blue'\n"
"\n"
"color = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\n"
"\n"
"match color:\n"
"    case Color.RED:\n"
"        print(\"I see red!\")\n"
"    case Color.GREEN:\n"
"        print(\"Grass is green\")\n"
"    case Color.BLUE:\n"
"        print(\"I'm feeling the blues :(\")"
msgstr ""

#: tutorial/controlflow.rst:453
msgid ""
"For a more detailed explanation and additional examples, you can look into :"
"pep:`636` which is written in a tutorial format."
msgstr ""
"Pour plus d'explications et d'exemples, lire la :pep:`636` (en anglais), qui "
"est écrite sous forme de tutoriel."

#: tutorial/controlflow.rst:459
msgid "Defining Functions"
msgstr "Définir des fonctions"

#: tutorial/controlflow.rst:461
msgid ""
"We can create a function that writes the Fibonacci series to an arbitrary "
"boundary::"
msgstr ""
"On peut créer une fonction qui écrit la suite de Fibonacci jusqu'à une "
"limite imposée ::"

#: tutorial/controlflow.rst:464
msgid ""
">>> def fib(n):    # write Fibonacci series less than n\n"
"...     \"\"\"Print a Fibonacci series less than n.\"\"\"\n"
"...     a, b = 0, 1\n"
"...     while a < n:\n"
"...         print(a, end=' ')\n"
"...         a, b = b, a+b\n"
"...     print()\n"
"...\n"
">>> # Now call the function we just defined:\n"
">>> fib(2000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597"
msgstr ""

#: tutorial/controlflow.rst:481
msgid ""
"The keyword :keyword:`def` introduces a function *definition*.  It must be "
"followed by the function name and the parenthesized list of formal "
"parameters. The statements that form the body of the function start at the "
"next line, and must be indented."
msgstr ""
"Le mot-clé :keyword:`def` introduit une *définition* de fonction. Il doit "
"être suivi du nom de la fonction et d'une liste, entre parenthèses, de ses "
"paramètres. L'instruction qui constitue le corps de la fonction débute à la "
"ligne suivante et doit être indentée."

#: tutorial/controlflow.rst:486
msgid ""
"The first statement of the function body can optionally be a string literal; "
"this string literal is the function's documentation string, or :dfn:"
"`docstring`. (More about docstrings can be found in the section :ref:`tut-"
"docstrings`.) There are tools which use docstrings to automatically produce "
"online or printed documentation, or to let the user interactively browse "
"through code; it's good practice to include docstrings in code that you "
"write, so make a habit of it."
msgstr ""
"La première instruction d'une fonction peut, de façon facultative, être une "
"chaîne de caractères littérale ; cette chaîne de caractères sera alors la "
"chaîne de documentation de la fonction, appelée :dfn:`docstring` (consultez "
"la section :ref:`tut-docstrings` pour en savoir plus). Il existe des outils "
"qui utilisent ces chaînes de documentation pour générer automatiquement une "
"documentation en ligne ou imprimée, ou pour permettre à l'utilisateur de "
"naviguer de façon interactive dans le code ; prenez-en l'habitude, c'est une "
"bonne pratique que de documenter le code que vous écrivez."

#: tutorial/controlflow.rst:493
msgid ""
"The *execution* of a function introduces a new symbol table used for the "
"local variables of the function.  More precisely, all variable assignments "
"in a function store the value in the local symbol table; whereas variable "
"references first look in the local symbol table, then in the local symbol "
"tables of enclosing functions, then in the global symbol table, and finally "
"in the table of built-in names. Thus, global variables and variables of "
"enclosing functions cannot be directly assigned a value within a function "
"(unless, for global variables, named in a :keyword:`global` statement, or, "
"for variables of enclosing functions, named in a :keyword:`nonlocal` "
"statement), although they may be referenced."
msgstr ""
"*L'exécution* d'une fonction introduit une nouvelle table de symboles "
"utilisée par les variables locales de la fonction. Plus précisément, toutes "
"les affectations de variables effectuées au sein d'une fonction stockent les "
"valeurs dans la table des symboles locaux ; en revanche, les références de "
"variables sont recherchées dans la table des symboles locaux, puis dans les "
"tables des symboles locaux des fonctions englobantes, puis dans la table des "
"symboles globaux et finalement dans la table des noms des primitives. Par "
"conséquent, bien qu'elles puissent être référencées, il est impossible "
"d'affecter une valeur à une variable globale ou à une variable d'une "
"fonction englobante (sauf pour les variables globales désignées dans une "
"instruction :keyword:`global` et, pour les variables des fonctions "
"englobantes, désignées dans une instruction :keyword:`nonlocal`)."

#: tutorial/controlflow.rst:504
msgid ""
"The actual parameters (arguments) to a function call are introduced in the "
"local symbol table of the called function when it is called; thus, arguments "
"are passed using *call by value* (where the *value* is always an object "
"*reference*, not the value of the object). [#]_ When a function calls "
"another function, or calls itself recursively, a new local symbol table is "
"created for that call."
msgstr ""
"Les paramètres effectifs (arguments) d'une fonction sont introduits dans la "
"table des symboles locaux de la fonction appelée, au moment où elle est "
"appelée ; par conséquent, les passages de paramètres se font *par valeur*, "
"la *valeur* étant toujours une *référence* à un objet et non la valeur de "
"l'objet lui-même [#]_. Lorsqu'une fonction appelle une autre fonction, ou "
"s'appelle elle-même par récursion, une nouvelle table de symboles locaux est "
"créée pour cet appel."

#: tutorial/controlflow.rst:511
msgid ""
"A function definition associates the function name with the function object "
"in the current symbol table.  The interpreter recognizes the object pointed "
"to by that name as a user-defined function.  Other names can also point to "
"that same function object and can also be used to access the function::"
msgstr ""
"Une définition de fonction associe un nom de fonction à un objet fonction "
"dans l'espace de noms actuel. Pour l'interpréteur, l'objet référencé par ce "
"nom est une fonction définie par l'utilisateur. Plusieurs noms peuvent faire "
"référence à une même fonction, ils peuvent alors tous être utilisés pour "
"appeler la fonction ::"

#: tutorial/controlflow.rst:516
msgid ""
">>> fib\n"
"<function fib at 10042ed0>\n"
">>> f = fib\n"
">>> f(100)\n"
"0 1 1 2 3 5 8 13 21 34 55 89"
msgstr ""

#: tutorial/controlflow.rst:522
msgid ""
"Coming from other languages, you might object that ``fib`` is not a function "
"but a procedure since it doesn't return a value.  In fact, even functions "
"without a :keyword:`return` statement do return a value, albeit a rather "
"boring one.  This value is called ``None`` (it's a built-in name).  Writing "
"the value ``None`` is normally suppressed by the interpreter if it would be "
"the only value written. You can see it if you really want to using :func:"
"`print`::"
msgstr ""
"Si vous venez d'autres langages, vous pouvez penser que ``fib`` n'est pas "
"une fonction mais une procédure, puisqu'elle ne renvoie pas de résultat. En "
"fait, même les fonctions sans instruction :keyword:`return` renvoient une "
"valeur, quoique ennuyeuse. Cette valeur est appelée ``None`` (c'est le nom "
"d'une primitive). Écrire la valeur ``None`` est normalement supprimé par "
"l'interpréteur lorsqu'il s'agit de la seule valeur qui doit être écrite. "
"Vous pouvez le constater, si vous y tenez vraiment, en utilisant :func:"
"`print` ::"

#: tutorial/controlflow.rst:529
msgid ""
">>> fib(0)\n"
">>> print(fib(0))\n"
"None"
msgstr ""

#: tutorial/controlflow.rst:533
msgid ""
"It is simple to write a function that returns a list of the numbers of the "
"Fibonacci series, instead of printing it::"
msgstr ""
"Il est facile d'écrire une fonction qui renvoie une liste de la série de "
"Fibonacci au lieu de l'afficher ::"

#: tutorial/controlflow.rst:536
msgid ""
">>> def fib2(n):  # return Fibonacci series up to n\n"
"...     \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n"
"...     result = []\n"
"...     a, b = 0, 1\n"
"...     while a < n:\n"
"...         result.append(a)    # see below\n"
"...         a, b = b, a+b\n"
"...     return result\n"
"...\n"
">>> f100 = fib2(100)    # call it\n"
">>> f100                # write the result\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]"
msgstr ""

#: tutorial/controlflow.rst:549
msgid "This example, as usual, demonstrates some new Python features:"
msgstr ""
"Cet exemple, comme d'habitude, illustre de nouvelles fonctionnalités de "
"Python :"

# énumération --> pas de majuscule et point-virgule en fin de proposition.
#: tutorial/controlflow.rst:551
msgid ""
"The :keyword:`return` statement returns with a value from a function. :"
"keyword:`!return` without an expression argument returns ``None``. Falling "
"off the end of a function also returns ``None``."
msgstr ""
"l'instruction :keyword:`return` provoque la sortie de la fonction en "
"renvoyant une valeur. :keyword:`!return` sans expression en paramètre "
"renvoie ``None``. Arriver à la fin d'une fonction renvoie également "
"``None`` ;"

# fin d'énumération --> pas de majuscule et point final.
#: tutorial/controlflow.rst:555
#, fuzzy
msgid ""
"The statement ``result.append(a)`` calls a *method* of the list object "
"``result``.  A method is a function that 'belongs' to an object and is named "
"``obj.methodname``, where ``obj`` is some object (this may be an "
"expression), and ``methodname`` is the name of a method that is defined by "
"the object's type. Different types define different methods.  Methods of "
"different types may have the same name without causing ambiguity.  (It is "
"possible to define your own object types and methods, using *classes*, see :"
"ref:`tut-classes`) The method :meth:`!append` shown in the example is "
"defined for list objects; it adds a new element at the end of the list.  In "
"this example it is equivalent to ``result = result + [a]``, but more "
"efficient."
msgstr ""
"l'instruction ``result.append(a)`` appelle une *méthode* de l'objet "
"``result`` qui est une liste. Une méthode est une fonction qui "
"« appartient » à un objet et qui est nommée ``obj.methodname``, où ``obj`` "
"est un objet (il peut également s'agir d'une expression) et ``methodname`` "
"est le nom d'une méthode que le type de l'objet définit. Différents types "
"définissent différentes méthodes. Des méthodes de différents types peuvent "
"porter le même nom sans qu'il n'y ait d'ambigüité (vous pouvez définir vos "
"propres types d'objets et leurs méthodes en utilisant des *classes*, voir :"
"ref:`tut-classes`). La méthode :meth:`append` utilisée dans cet exemple est "
"définie pour les listes ; elle ajoute un nouvel élément à la fin de la "
"liste. Dans cet exemple, elle est l'équivalent de ``result = result + [a]``, "
"en plus efficace."

#: tutorial/controlflow.rst:570
msgid "More on Defining Functions"
msgstr "Davantage sur la définition des fonctions"

#: tutorial/controlflow.rst:572
msgid ""
"It is also possible to define functions with a variable number of arguments. "
"There are three forms, which can be combined."
msgstr ""
"Il est également possible de définir des fonctions avec un nombre variable "
"d'arguments. Trois syntaxes peuvent être utilisées, éventuellement combinées."

#: tutorial/controlflow.rst:579
msgid "Default Argument Values"
msgstr "Valeur par défaut des arguments"

#: tutorial/controlflow.rst:581
msgid ""
"The most useful form is to specify a default value for one or more "
"arguments. This creates a function that can be called with fewer arguments "
"than it is defined to allow.  For example::"
msgstr ""
"La forme la plus utile consiste à indiquer une valeur par défaut pour "
"certains arguments. Ceci crée une fonction qui peut être appelée avec moins "
"d'arguments que ceux présents dans sa définition. Par exemple ::"

#: tutorial/controlflow.rst:585
msgid ""
"def ask_ok(prompt, retries=4, reminder='Please try again!'):\n"
"    while True:\n"
"        reply = input(prompt)\n"
"        if reply in {'y', 'ye', 'yes'}:\n"
"            return True\n"
"        if reply in {'n', 'no', 'nop', 'nope'}:\n"
"            return False\n"
"        retries = retries - 1\n"
"        if retries < 0:\n"
"            raise ValueError('invalid user response')\n"
"        print(reminder)"
msgstr ""

#: tutorial/controlflow.rst:597
msgid "This function can be called in several ways:"
msgstr "Cette fonction peut être appelée de plusieurs façons :"

# énumération --> pas de majuscule
#: tutorial/controlflow.rst:599
msgid ""
"giving only the mandatory argument: ``ask_ok('Do you really want to quit?')``"
msgstr ""
"en ne fournissant que les arguments obligatoires : ``ask_ok('Do you really "
"want to quit?')`` ;"

# énumération --> pas de majuscule et point-virgule en fin de proposition.
#: tutorial/controlflow.rst:601
msgid ""
"giving one of the optional arguments: ``ask_ok('OK to overwrite the file?', "
"2)``"
msgstr ""
"en fournissant une partie des arguments facultatifs : ``ask_ok('OK to "
"overwrite the file?', 2)`` ;"

# fin d'énumération --> pas de majuscule et point final.
#: tutorial/controlflow.rst:603
msgid ""
"or even giving all arguments: ``ask_ok('OK to overwrite the file?', 2, 'Come "
"on, only yes or no!')``"
msgstr ""
"en fournissant tous les arguments : ``ask_ok('OK to overwrite the file?', 2, "
"'Come on, only yes or no!')``."

#: tutorial/controlflow.rst:606
msgid ""
"This example also introduces the :keyword:`in` keyword. This tests whether "
"or not a sequence contains a certain value."
msgstr ""
"Cet exemple présente également le mot-clé :keyword:`in`. Celui-ci permet de "
"tester si une séquence contient une certaine valeur."

#: tutorial/controlflow.rst:609
msgid ""
"The default values are evaluated at the point of function definition in the "
"*defining* scope, so that ::"
msgstr ""
"Les valeurs par défaut sont évaluées lors de la définition de la fonction "
"dans la portée de la *définition*, de telle sorte que ::"

#: tutorial/controlflow.rst:612
msgid ""
"i = 5\n"
"\n"
"def f(arg=i):\n"
"    print(arg)\n"
"\n"
"i = 6\n"
"f()"
msgstr ""

#: tutorial/controlflow.rst:620
msgid "will print ``5``."
msgstr "affiche ``5``."

#: tutorial/controlflow.rst:622
msgid ""
"**Important warning:**  The default value is evaluated only once. This makes "
"a difference when the default is a mutable object such as a list, "
"dictionary, or instances of most classes.  For example, the following "
"function accumulates the arguments passed to it on subsequent calls::"
msgstr ""
"**Avertissement important :** la valeur par défaut n'est évaluée qu'une "
"seule fois. Ceci fait une différence lorsque cette valeur par défaut est un "
"objet mutable tel qu'une liste, un dictionnaire ou des instances de la "
"plupart des classes. Par exemple, la fonction suivante accumule les "
"arguments qui lui sont passés au fil des appels successifs ::"

#: tutorial/controlflow.rst:627
msgid ""
"def f(a, L=[]):\n"
"    L.append(a)\n"
"    return L\n"
"\n"
"print(f(1))\n"
"print(f(2))\n"
"print(f(3))"
msgstr ""

# pas de majuscule : ok
#: tutorial/controlflow.rst:635
msgid "This will print ::"
msgstr "affiche ::"

#: tutorial/controlflow.rst:637
msgid ""
"[1]\n"
"[1, 2]\n"
"[1, 2, 3]"
msgstr ""

#: tutorial/controlflow.rst:641
msgid ""
"If you don't want the default to be shared between subsequent calls, you can "
"write the function like this instead::"
msgstr ""
"Si vous ne voulez pas que cette valeur par défaut soit partagée entre des "
"appels successifs, vous pouvez écrire la fonction de cette façon ::"

#: tutorial/controlflow.rst:644
msgid ""
"def f(a, L=None):\n"
"    if L is None:\n"
"        L = []\n"
"    L.append(a)\n"
"    return L"
msgstr ""

#: tutorial/controlflow.rst:654
msgid "Keyword Arguments"
msgstr "Les arguments nommés"

#: tutorial/controlflow.rst:656
msgid ""
"Functions can also be called using :term:`keyword arguments <keyword "
"argument>` of the form ``kwarg=value``.  For instance, the following "
"function::"
msgstr ""
"Les fonctions peuvent également être appelées en utilisant des :term:"
"`arguments nommés <keyword argument>` sous la forme ``kwarg=value``. Par "
"exemple, la fonction suivante ::"

#: tutorial/controlflow.rst:659
msgid ""
"def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\n"
"    print(\"-- This parrot wouldn't\", action, end=' ')\n"
"    print(\"if you put\", voltage, \"volts through it.\")\n"
"    print(\"-- Lovely plumage, the\", type)\n"
"    print(\"-- It's\", state, \"!\")"
msgstr ""

#: tutorial/controlflow.rst:665
msgid ""
"accepts one required argument (``voltage``) and three optional arguments "
"(``state``, ``action``, and ``type``).  This function can be called in any "
"of the following ways::"
msgstr ""
"accepte un argument obligatoire (``voltage``) et trois arguments facultatifs "
"(``state``, ``action`` et ``type``). Cette fonction peut être appelée de "
"n'importe laquelle des façons suivantes ::"

#: tutorial/controlflow.rst:669
msgid ""
"parrot(1000)                                          # 1 positional "
"argument\n"
"parrot(voltage=1000)                                  # 1 keyword argument\n"
"parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\n"
"parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\n"
"parrot('a million', 'bereft of life', 'jump')         # 3 positional "
"arguments\n"
"parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 "
"keyword"
msgstr ""

#: tutorial/controlflow.rst:676
msgid "but all the following calls would be invalid::"
msgstr "mais tous les appels qui suivent sont incorrects ::"

#: tutorial/controlflow.rst:678
msgid ""
"parrot()                     # required argument missing\n"
"parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword "
"argument\n"
"parrot(110, voltage=220)     # duplicate value for the same argument\n"
"parrot(actor='John Cleese')  # unknown keyword argument"
msgstr ""

#: tutorial/controlflow.rst:683
msgid ""
"In a function call, keyword arguments must follow positional arguments. All "
"the keyword arguments passed must match one of the arguments accepted by the "
"function (e.g. ``actor`` is not a valid argument for the ``parrot`` "
"function), and their order is not important.  This also includes non-"
"optional arguments (e.g. ``parrot(voltage=1000)`` is valid too). No argument "
"may receive a value more than once. Here's an example that fails due to this "
"restriction::"
msgstr ""
"Dans un appel de fonction, les arguments nommés doivent suivre les arguments "
"positionnés. Tous les arguments nommés doivent correspondre à l'un des "
"arguments acceptés par la fonction (par exemple, ``actor`` n'est pas un "
"argument accepté par la fonction ``parrot``), mais leur ordre n'est pas "
"important. Ceci inclut également les arguments obligatoires "
"(``parrot(voltage=1000)`` est également correct). Aucun argument ne peut "
"recevoir une valeur plus d'une fois, comme l'illustre cet exemple incorrect "
"du fait de cette restriction ::"

#: tutorial/controlflow.rst:691
msgid ""
">>> def function(a):\n"
"...     pass\n"
"...\n"
">>> function(0, a=0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: function() got multiple values for argument 'a'"
msgstr ""

#: tutorial/controlflow.rst:699
msgid ""
"When a final formal parameter of the form ``**name`` is present, it receives "
"a dictionary (see :ref:`typesmapping`) containing all keyword arguments "
"except for those corresponding to a formal parameter.  This may be combined "
"with a formal parameter of the form ``*name`` (described in the next "
"subsection) which receives a :ref:`tuple <tut-tuples>` containing the "
"positional arguments beyond the formal parameter list.  (``*name`` must "
"occur before ``**name``.) For example, if we define a function like this::"
msgstr ""
"Quand un dernier paramètre formel est présent sous la forme ``**name``, il "
"reçoit un dictionnaire (voir :ref:`typesmapping`) contenant tous les "
"arguments nommés à l'exception de ceux correspondant à un paramètre formel. "
"Ceci peut être combiné à un paramètre formel sous la forme ``*name`` (décrit "
"dans la section suivante) qui lui reçoit un :ref:`n-uplet <tut-tuples>` "
"contenant les arguments positionnés au-delà de la liste des paramètres "
"formels (``*name`` doit être présent avant ``**name``). Par exemple, si vous "
"définissez une fonction comme ceci ::"

#: tutorial/controlflow.rst:707
msgid ""
"def cheeseshop(kind, *arguments, **keywords):\n"
"    print(\"-- Do you have any\", kind, \"?\")\n"
"    print(\"-- I'm sorry, we're all out of\", kind)\n"
"    for arg in arguments:\n"
"        print(arg)\n"
"    print(\"-\" * 40)\n"
"    for kw in keywords:\n"
"        print(kw, \":\", keywords[kw])"
msgstr ""

#: tutorial/controlflow.rst:716
msgid "It could be called like this::"
msgstr "Elle pourrait être appelée comme ceci ::"

#: tutorial/controlflow.rst:718
msgid ""
"cheeseshop(\"Limburger\", \"It's very runny, sir.\",\n"
"           \"It's really very, VERY runny, sir.\",\n"
"           shopkeeper=\"Michael Palin\",\n"
"           client=\"John Cleese\",\n"
"           sketch=\"Cheese Shop Sketch\")"
msgstr ""

#: tutorial/controlflow.rst:724
msgid "and of course it would print:"
msgstr "et, bien sûr, elle affiche :"

#: tutorial/controlflow.rst:726
msgid ""
"-- Do you have any Limburger ?\n"
"-- I'm sorry, we're all out of Limburger\n"
"It's very runny, sir.\n"
"It's really very, VERY runny, sir.\n"
"----------------------------------------\n"
"shopkeeper : Michael Palin\n"
"client : John Cleese\n"
"sketch : Cheese Shop Sketch"
msgstr ""

#: tutorial/controlflow.rst:737
msgid ""
"Note that the order in which the keyword arguments are printed is guaranteed "
"to match the order in which they were provided in the function call."
msgstr ""
"Notez que Python garantit que l'ordre d'affichage des arguments est le même "
"que l'ordre dans lesquels ils sont fournis lors de l'appel à la fonction."

#: tutorial/controlflow.rst:741
msgid "Special parameters"
msgstr "Paramètres spéciaux"

#: tutorial/controlflow.rst:743
msgid ""
"By default, arguments may be passed to a Python function either by position "
"or explicitly by keyword. For readability and performance, it makes sense to "
"restrict the way arguments can be passed so that a developer need only look "
"at the function definition to determine if items are passed by position, by "
"position or keyword, or by keyword."
msgstr ""
"Par défaut, les arguments peuvent être passés à une fonction Python par "
"position, ou explicitement en les nommant. Pour la lisibilité et la "
"performance, il est logique de restreindre la façon dont les arguments "
"peuvent être transmis afin qu'un développeur n'ait qu'à regarder la "
"définition de la fonction pour déterminer si les éléments sont transmis par "
"position seule, par position ou nommé, ou seulement nommé."

#: tutorial/controlflow.rst:749
msgid "A function definition may look like:"
msgstr "Voici à quoi ressemble une définition de fonction :"

#: tutorial/controlflow.rst:751
msgid ""
"def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n"
"      -----------    ----------     ----------\n"
"        |             |                  |\n"
"        |        Positional or keyword   |\n"
"        |                                - Keyword only\n"
"         -- Positional only"
msgstr ""

#: tutorial/controlflow.rst:760
msgid ""
"where ``/`` and ``*`` are optional. If used, these symbols indicate the kind "
"of parameter by how the arguments may be passed to the function: positional-"
"only, positional-or-keyword, and keyword-only. Keyword parameters are also "
"referred to as named parameters."
msgstr ""
"où ``/`` et ``*`` sont facultatifs. S'ils sont utilisés, ces symboles "
"indiquent par quel type de paramètre un argument peut être transmis à la "
"fonction : position seule, position ou nommé, et seulement nommé. Les "
"paramètres par mot-clé sont aussi appelés paramètres nommés."

#: tutorial/controlflow.rst:767
msgid "Positional-or-Keyword Arguments"
msgstr "Les arguments positionnels-ou-nommés"

#: tutorial/controlflow.rst:769
msgid ""
"If ``/`` and ``*`` are not present in the function definition, arguments may "
"be passed to a function by position or by keyword."
msgstr ""
"Si ``/`` et ``*`` ne sont pas présents dans la définition de fonction, les "
"arguments peuvent être passés à une fonction par position ou par nommés."

#: tutorial/controlflow.rst:774
msgid "Positional-Only Parameters"
msgstr "Paramètres positionnels uniquement"

#: tutorial/controlflow.rst:776
msgid ""
"Looking at this in a bit more detail, it is possible to mark certain "
"parameters as *positional-only*. If *positional-only*, the parameters' order "
"matters, and the parameters cannot be passed by keyword. Positional-only "
"parameters are placed before a ``/`` (forward-slash). The ``/`` is used to "
"logically separate the positional-only parameters from the rest of the "
"parameters. If there is no ``/`` in the function definition, there are no "
"positional-only parameters."
msgstr ""
"En y regardant de plus près, il est possible de marquer certains paramètres "
"comme *positionnels uniquement*. S'ils sont marqués comme *positionnels "
"uniquement*, l'ordre des paramètres est important, et les paramètres ne "
"peuvent pas être transmis en tant que « arguments nommés ». Les paramètres "
"« positionnels uniquement » sont placés avant un ``/``. Le ``/`` est utilisé "
"pour séparer logiquement les paramètres « positionnels uniquement » du reste "
"des paramètres. S'il n'y a pas de ``/`` dans la définition de fonction, il "
"n'y a pas de paramètres « positionnels uniquement »."

#: tutorial/controlflow.rst:784
msgid ""
"Parameters following the ``/`` may be *positional-or-keyword* or *keyword-"
"only*."
msgstr ""
"Les paramètres qui suivent le ``/`` peuvent être *positionnels-ou-nommés* ou "
"*nommés-uniquement*."

#: tutorial/controlflow.rst:788
msgid "Keyword-Only Arguments"
msgstr "Arguments nommés uniquement"

#: tutorial/controlflow.rst:790
msgid ""
"To mark parameters as *keyword-only*, indicating the parameters must be "
"passed by keyword argument, place an ``*`` in the arguments list just before "
"the first *keyword-only* parameter."
msgstr ""
"Pour marquer les paramètres comme *uniquement nommés*, indiquant que les "
"paramètres doivent être passés avec l'argument comme mot-clé, placez un "
"``*`` dans la liste des arguments juste avant le premier paramètre "
"*uniquement nommé*."

#: tutorial/controlflow.rst:796
msgid "Function Examples"
msgstr "Exemples de fonctions"

#: tutorial/controlflow.rst:798
msgid ""
"Consider the following example function definitions paying close attention "
"to the markers ``/`` and ``*``::"
msgstr ""
"Considérons l'exemple suivant de définitions de fonctions en portant une "
"attention particulière aux marqueurs ``/`` et ``*`` ::"

#: tutorial/controlflow.rst:801
msgid ""
">>> def standard_arg(arg):\n"
"...     print(arg)\n"
"...\n"
">>> def pos_only_arg(arg, /):\n"
"...     print(arg)\n"
"...\n"
">>> def kwd_only_arg(*, arg):\n"
"...     print(arg)\n"
"...\n"
">>> def combined_example(pos_only, /, standard, *, kwd_only):\n"
"...     print(pos_only, standard, kwd_only)"
msgstr ""

#: tutorial/controlflow.rst:814
msgid ""
"The first function definition, ``standard_arg``, the most familiar form, "
"places no restrictions on the calling convention and arguments may be passed "
"by position or keyword::"
msgstr ""
"La première définition de fonction, ``standard_arg``, la forme la plus "
"familière, n'impose aucune restriction sur la convention d'appel et les "
"arguments peuvent être passés par position ou nommés ::"

#: tutorial/controlflow.rst:818
msgid ""
">>> standard_arg(2)\n"
"2\n"
"\n"
">>> standard_arg(arg=2)\n"
"2"
msgstr ""

#: tutorial/controlflow.rst:824
msgid ""
"The second function ``pos_only_arg`` is restricted to only use positional "
"parameters as there is a ``/`` in the function definition::"
msgstr ""
"La deuxième fonction ``pos_only_arg`` restreint le passage aux seuls "
"arguments par position car il y a un ``/`` dans la définition de fonction ::"

#: tutorial/controlflow.rst:827
msgid ""
">>> pos_only_arg(1)\n"
"1\n"
"\n"
">>> pos_only_arg(arg=1)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: pos_only_arg() got some positional-only arguments passed as "
"keyword arguments: 'arg'"
msgstr ""

#: tutorial/controlflow.rst:835
#, fuzzy
msgid ""
"The third function ``kwd_only_arg`` only allows keyword arguments as "
"indicated by a ``*`` in the function definition::"
msgstr ""
"La troisième fonction ``kwd_only_args`` n'autorise que les arguments nommés "
"comme l'indique le ``*`` dans la définition de fonction ::"

#: tutorial/controlflow.rst:838
msgid ""
">>> kwd_only_arg(3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n"
"\n"
">>> kwd_only_arg(arg=3)\n"
"3"
msgstr ""

#: tutorial/controlflow.rst:846
msgid ""
"And the last uses all three calling conventions in the same function "
"definition::"
msgstr ""
"Et la dernière utilise les trois conventions d'appel dans la même définition "
"de fonction ::"

#: tutorial/controlflow.rst:849
msgid ""
">>> combined_example(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: combined_example() takes 2 positional arguments but 3 were given\n"
"\n"
">>> combined_example(1, 2, kwd_only=3)\n"
"1 2 3\n"
"\n"
">>> combined_example(1, standard=2, kwd_only=3)\n"
"1 2 3\n"
"\n"
">>> combined_example(pos_only=1, standard=2, kwd_only=3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: combined_example() got some positional-only arguments passed as "
"keyword arguments: 'pos_only'"
msgstr ""

#: tutorial/controlflow.rst:866
msgid ""
"Finally, consider this function definition which has a potential collision "
"between the positional argument ``name``  and ``**kwds`` which has ``name`` "
"as a key::"
msgstr ""
"Enfin, considérons cette définition de fonction qui a une collision "
"potentielle entre l'argument positionnel ``name`` et ``**kwds`` qui a "
"``name`` comme mot-clé ::"

#: tutorial/controlflow.rst:868
msgid ""
"def foo(name, **kwds):\n"
"    return 'name' in kwds"
msgstr ""

#: tutorial/controlflow.rst:871
msgid ""
"There is no possible call that will make it return ``True`` as the keyword "
"``'name'`` will always bind to the first parameter. For example::"
msgstr ""
"Il n'y a pas d'appel possible qui renvoie ``True`` car le mot-clé ``'name'`` "
"est toujours lié au premier paramètre. Par exemple ::"

#: tutorial/controlflow.rst:874
msgid ""
">>> foo(1, **{'name': 2})\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: foo() got multiple values for argument 'name'\n"
">>>"
msgstr ""

#: tutorial/controlflow.rst:880
msgid ""
"But using ``/`` (positional only arguments), it is possible since it allows "
"``name`` as a positional argument and ``'name'`` as a key in the keyword "
"arguments::"
msgstr ""
"Mais en utilisant ``/`` (arguments positionnels seulement), c'est possible "
"puisqu'il permet d'utiliser ``name`` comme argument positionnel et "
"``'name'`` comme mot-clé dans les arguments nommés ::"

#: tutorial/controlflow.rst:882
msgid ""
">>> def foo(name, /, **kwds):\n"
"...     return 'name' in kwds\n"
"...\n"
">>> foo(1, **{'name': 2})\n"
"True"
msgstr ""

#: tutorial/controlflow.rst:888
msgid ""
"In other words, the names of positional-only parameters can be used in "
"``**kwds`` without ambiguity."
msgstr ""
"En d'autres termes, les noms des paramètres seulement positionnels peuvent "
"être utilisés sans ambiguïté dans ``**kwds``."

#: tutorial/controlflow.rst:893
msgid "Recap"
msgstr "Récapitulatif"

#: tutorial/controlflow.rst:895
msgid ""
"The use case will determine which parameters to use in the function "
"definition::"
msgstr ""
"Le cas d'utilisation détermine les paramètres à utiliser dans la définition "
"de fonction ::"

#: tutorial/controlflow.rst:897
msgid "def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):"
msgstr ""

#: tutorial/controlflow.rst:899
msgid "As guidance:"
msgstr "Quelques conseils :"

# énumération --> pas de majuscule et point-virgule en fin de proposition.
#: tutorial/controlflow.rst:901
msgid ""
"Use positional-only if you want the name of the parameters to not be "
"available to the user. This is useful when parameter names have no real "
"meaning, if you want to enforce the order of the arguments when the function "
"is called or if you need to take some positional parameters and arbitrary "
"keywords."
msgstr ""
"utilisez les paramètres positionnels si vous voulez que le nom des "
"paramètres soit masqué à l'utilisateur. Ceci est utile lorsque les noms de "
"paramètres n'ont pas de signification réelle, si vous voulez faire respecter "
"l'ordre des arguments lorsque la fonction est appelée ou si vous avez besoin "
"de prendre certains paramètres positionnels et mots-clés arbitraires ;"

# énumération --> pas de majuscule et point-virgule en fin de proposition.
#: tutorial/controlflow.rst:906
msgid ""
"Use keyword-only when names have meaning and the function definition is more "
"understandable by being explicit with names or you want to prevent users "
"relying on the position of the argument being passed."
msgstr ""
"utilisez les paramètres nommés lorsque les noms ont un sens et que la "
"définition de la fonction est plus compréhensible avec des noms explicites "
"ou si vous voulez empêcher les utilisateurs de se fier à la position de "
"l'argument qui est passé ;"

# fin d'énumération
#: tutorial/controlflow.rst:909
msgid ""
"For an API, use positional-only to prevent breaking API changes if the "
"parameter's name is modified in the future."
msgstr ""
"dans le cas d'une API, utilisez les paramètres seulement positionnels pour "
"éviter de casser l'API si le nom du paramètre est modifié dans l'avenir."

#: tutorial/controlflow.rst:915
msgid "Arbitrary Argument Lists"
msgstr "Listes d'arguments arbitraires"

#: tutorial/controlflow.rst:920
msgid ""
"Finally, the least frequently used option is to specify that a function can "
"be called with an arbitrary number of arguments.  These arguments will be "
"wrapped up in a tuple (see :ref:`tut-tuples`).  Before the variable number "
"of arguments, zero or more normal arguments may occur. ::"
msgstr ""
"Pour terminer, l'option la moins fréquente consiste à indiquer qu'une "
"fonction peut être appelée avec un nombre arbitraire d'arguments. Ces "
"arguments sont intégrés dans un *n*-uplet (voir :ref:`tut-tuples`). Avant le "
"nombre variable d'arguments, zéro ou plus arguments normaux peuvent "
"apparaître ::"

#: tutorial/controlflow.rst:925
msgid ""
"def write_multiple_items(file, separator, *args):\n"
"    file.write(separator.join(args))"
msgstr ""

#: tutorial/controlflow.rst:929
msgid ""
"Normally, these *variadic* arguments will be last in the list of formal "
"parameters, because they scoop up all remaining input arguments that are "
"passed to the function. Any formal parameters which occur after the "
"``*args`` parameter are 'keyword-only' arguments, meaning that they can only "
"be used as keywords rather than positional arguments. ::"
msgstr ""
"Normalement, ces arguments ``variadiques`` sont les derniers paramètres, "
"parce qu'ils agrègent toutes les valeurs suivantes. Tout paramètre placé "
"après le paramètre ``*arg`` ne pourra être utilisé que comme argument nommé, "
"pas comme argument positionnel ::"

#: tutorial/controlflow.rst:935
msgid ""
">>> def concat(*args, sep=\"/\"):\n"
"...     return sep.join(args)\n"
"...\n"
">>> concat(\"earth\", \"mars\", \"venus\")\n"
"'earth/mars/venus'\n"
">>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n"
"'earth.mars.venus'"
msgstr ""

#: tutorial/controlflow.rst:946
msgid "Unpacking Argument Lists"
msgstr "Séparation des listes d'arguments"

#: tutorial/controlflow.rst:948
msgid ""
"The reverse situation occurs when the arguments are already in a list or "
"tuple but need to be unpacked for a function call requiring separate "
"positional arguments.  For instance, the built-in :func:`range` function "
"expects separate *start* and *stop* arguments.  If they are not available "
"separately, write the function call with the  ``*``\\ -operator to unpack "
"the arguments out of a list or tuple::"
msgstr ""
"La situation inverse intervient lorsque les arguments sont déjà dans une "
"liste ou un *n*-uplet mais doivent être séparés pour un appel de fonction "
"nécessitant des arguments positionnés séparés. Par exemple, la primitive :"
"func:`range` attend des arguments *start* et *stop* distincts. S'ils ne sont "
"pas disponibles séparément, écrivez l'appel de fonction en utilisant "
"l'opérateur ``*`` pour séparer les arguments présents dans une liste ou un "
"*n*-uplet ::"

#: tutorial/controlflow.rst:955
msgid ""
">>> list(range(3, 6))            # normal call with separate arguments\n"
"[3, 4, 5]\n"
">>> args = [3, 6]\n"
">>> list(range(*args))            # call with arguments unpacked from a "
"list\n"
"[3, 4, 5]"
msgstr ""

#: tutorial/controlflow.rst:964
msgid ""
"In the same fashion, dictionaries can deliver keyword arguments with the "
"``**``\\ -operator::"
msgstr ""
"De la même façon, les dictionnaires peuvent fournir des arguments nommés en "
"utilisant l'opérateur ``**`` ::"

#: tutorial/controlflow.rst:967
msgid ""
">>> def parrot(voltage, state='a stiff', action='voom'):\n"
"...     print(\"-- This parrot wouldn't\", action, end=' ')\n"
"...     print(\"if you put\", voltage, \"volts through it.\", end=' ')\n"
"...     print(\"E's\", state, \"!\")\n"
"...\n"
">>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", "
"\"action\": \"VOOM\"}\n"
">>> parrot(**d)\n"
"-- This parrot wouldn't VOOM if you put four million volts through it. E's "
"bleedin' demised !"
msgstr ""

#: tutorial/controlflow.rst:980
msgid "Lambda Expressions"
msgstr "Fonctions anonymes"

#: tutorial/controlflow.rst:982
msgid ""
"Small anonymous functions can be created with the :keyword:`lambda` keyword. "
"This function returns the sum of its two arguments: ``lambda a, b: a+b``. "
"Lambda functions can be used wherever function objects are required.  They "
"are syntactically restricted to a single expression.  Semantically, they are "
"just syntactic sugar for a normal function definition.  Like nested function "
"definitions, lambda functions can reference variables from the containing "
"scope::"
msgstr ""
"Avec le mot-clé :keyword:`lambda`, vous pouvez créer de petites fonctions "
"anonymes. En voici une qui renvoie la somme de ses deux arguments : ``lambda "
"a, b: a+b``. Les fonctions lambda peuvent être utilisées partout où un objet "
"fonction est attendu. Elles sont syntaxiquement restreintes à une seule "
"expression. Sémantiquement, elles ne sont que du sucre syntaxique pour une "
"définition de fonction normale. Comme les fonctions imbriquées, les "
"fonctions lambda peuvent référencer des variables de la portée englobante ::"

#: tutorial/controlflow.rst:990
msgid ""
">>> def make_incrementor(n):\n"
"...     return lambda x: x + n\n"
"...\n"
">>> f = make_incrementor(42)\n"
">>> f(0)\n"
"42\n"
">>> f(1)\n"
"43"
msgstr ""

#: tutorial/controlflow.rst:999
msgid ""
"The above example uses a lambda expression to return a function.  Another "
"use is to pass a small function as an argument::"
msgstr ""
"L'exemple précédent utilise une fonction anonyme pour renvoyer une fonction. "
"Une autre utilisation classique est de donner une fonction minimaliste "
"directement en tant que paramètre ::"

#: tutorial/controlflow.rst:1002
msgid ""
">>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n"
">>> pairs.sort(key=lambda pair: pair[1])\n"
">>> pairs\n"
"[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]"
msgstr ""

#: tutorial/controlflow.rst:1011
msgid "Documentation Strings"
msgstr "Chaînes de documentation"

#: tutorial/controlflow.rst:1018
msgid ""
"Here are some conventions about the content and formatting of documentation "
"strings."
msgstr ""
"Voici quelques conventions concernant le contenu et le format des chaînes de "
"documentation."

#: tutorial/controlflow.rst:1021
msgid ""
"The first line should always be a short, concise summary of the object's "
"purpose.  For brevity, it should not explicitly state the object's name or "
"type, since these are available by other means (except if the name happens "
"to be a verb describing a function's operation).  This line should begin "
"with a capital letter and end with a period."
msgstr ""
"Il convient que la première ligne soit toujours courte et résume de manière "
"concise l'utilité de l'objet. Afin d'être bref, nul besoin de rappeler le "
"nom de l'objet ou son type, qui sont accessibles par d'autres moyens (sauf "
"si le nom est un verbe qui décrit une opération). La convention veut que la "
"ligne commence par une majuscule et se termine par un point."

#: tutorial/controlflow.rst:1027
msgid ""
"If there are more lines in the documentation string, the second line should "
"be blank, visually separating the summary from the rest of the description.  "
"The following lines should be one or more paragraphs describing the object's "
"calling conventions, its side effects, etc."
msgstr ""
"S'il y a d'autres lignes dans la chaîne de documentation, la deuxième ligne "
"devrait être vide, pour la séparer visuellement du reste de la description. "
"Les autres lignes peuvent alors constituer un ou plusieurs paragraphes "
"décrivant le mode d'utilisation de l'objet, ses effets de bord, etc."

#: tutorial/controlflow.rst:1032
msgid ""
"The Python parser does not strip indentation from multi-line string literals "
"in Python, so tools that process documentation have to strip indentation if "
"desired.  This is done using the following convention. The first non-blank "
"line *after* the first line of the string determines the amount of "
"indentation for the entire documentation string.  (We can't use the first "
"line since it is generally adjacent to the string's opening quotes so its "
"indentation is not apparent in the string literal.)  Whitespace "
"\"equivalent\" to this indentation is then stripped from the start of all "
"lines of the string.  Lines that are indented less should not occur, but if "
"they occur all their leading whitespace should be stripped.  Equivalence of "
"whitespace should be tested after expansion of tabs (to 8 spaces, normally)."
msgstr ""
"L'analyseur de code Python ne supprime pas l'indentation des chaînes de "
"caractères littérales multi-lignes, donc les outils qui utilisent la "
"documentation doivent si besoin faire cette opération eux-mêmes. La "
"convention suivante s'applique : la première ligne non vide *après* la "
"première détermine la profondeur d'indentation de l'ensemble de la chaîne de "
"documentation (on ne peut pas utiliser la première ligne qui est "
"généralement accolée aux guillemets d'ouverture de la chaîne de caractères "
"et dont l'indentation n'est donc pas visible). Les espaces « correspondant » "
"à cette profondeur d'indentation sont alors supprimées du début de chacune "
"des lignes de la chaîne. Aucune ligne ne devrait présenter un niveau "
"d'indentation inférieur mais, si cela arrive, toutes les espaces situées en "
"début de ligne doivent être supprimées. L'équivalent des espaces doit être "
"testé après expansion des tabulations (normalement remplacées par 8 espaces)."

#: tutorial/controlflow.rst:1044
msgid "Here is an example of a multi-line docstring::"
msgstr "Voici un exemple de chaîne de documentation multi-lignes ::"

#: tutorial/controlflow.rst:1046
msgid ""
">>> def my_function():\n"
"...     \"\"\"Do nothing, but document it.\n"
"...\n"
"...     No, really, it doesn't do anything.\n"
"...     \"\"\"\n"
"...     pass\n"
"...\n"
">>> print(my_function.__doc__)\n"
"Do nothing, but document it.\n"
"\n"
"    No, really, it doesn't do anything."
msgstr ""

#: tutorial/controlflow.rst:1062
msgid "Function Annotations"
msgstr "Annotations de fonctions"

#: tutorial/controlflow.rst:1070
msgid ""
":ref:`Function annotations <function>` are completely optional metadata "
"information about the types used by user-defined functions (see :pep:`3107` "
"and :pep:`484` for more information)."
msgstr ""
":ref:`Les annotations de fonction <function>` sont des métadonnées "
"optionnelles décrivant les types utilisés par une fonction définie par "
"l'utilisateur (voir les :pep:`3107` et :pep:`484` pour plus d'informations)."

#: tutorial/controlflow.rst:1074
#, fuzzy
msgid ""
":term:`Annotations <function annotation>` are stored in the :attr:`!"
"__annotations__` attribute of the function as a dictionary and have no "
"effect on any other part of the function.  Parameter annotations are defined "
"by a colon after the parameter name, followed by an expression evaluating to "
"the value of the annotation.  Return annotations are defined by a literal ``-"
">``, followed by an expression, between the parameter list and the colon "
"denoting the end of the :keyword:`def` statement.  The following example has "
"a required argument, an optional argument, and the return value annotated::"
msgstr ""
"Les :term:`annotations <function annotation>` sont stockées dans l'attribut :"
"attr:`__annotations__` de la fonction, sous la forme d'un dictionnaire, et "
"n'ont aucun autre effet. Les annotations sur les paramètres sont définies "
"par deux points (``:``) après le nom du paramètre suivi d'une expression "
"donnant la valeur de l'annotation. Les annotations de retour sont définies "
"par ``->`` suivi d'une expression, entre la liste des paramètres et les deux "
"points de fin de l'instruction :keyword:`def`. L'exemple suivant a un "
"paramètre requis, un paramètre optionnel et la valeur de retour annotés ::"

#: tutorial/controlflow.rst:1083
msgid ""
">>> def f(ham: str, eggs: str = 'eggs') -> str:\n"
"...     print(\"Annotations:\", f.__annotations__)\n"
"...     print(\"Arguments:\", ham, eggs)\n"
"...     return ham + ' and ' + eggs\n"
"...\n"
">>> f('spam')\n"
"Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class "
"'str'>}\n"
"Arguments: spam eggs\n"
"'spam and eggs'"
msgstr ""

#: tutorial/controlflow.rst:1096
msgid "Intermezzo: Coding Style"
msgstr "Aparté : le style de codage"

#: tutorial/controlflow.rst:1101
msgid ""
"Now that you are about to write longer, more complex pieces of Python, it is "
"a good time to talk about *coding style*.  Most languages can be written (or "
"more concise, *formatted*) in different styles; some are more readable than "
"others. Making it easy for others to read your code is always a good idea, "
"and adopting a nice coding style helps tremendously for that."
msgstr ""
"Maintenant que vous êtes prêt à écrire des programmes plus longs et plus "
"complexes, il est temps de parler du *style de codage*. La plupart des "
"langages peuvent être écrits (ou plutôt *formatés*) selon différents "
"styles ; certains sont plus lisibles que d'autres. Rendre la lecture de "
"votre code plus facile aux autres est toujours une bonne idée et adopter un "
"bon style de codage peut énormément vous y aider."

#: tutorial/controlflow.rst:1107
msgid ""
"For Python, :pep:`8` has emerged as the style guide that most projects "
"adhere to; it promotes a very readable and eye-pleasing coding style.  Every "
"Python developer should read it at some point; here are the most important "
"points extracted for you:"
msgstr ""
"En Python, la plupart des projets adhèrent au style défini dans la :pep:"
"`8` ; elle met en avant un style de codage très lisible et agréable à l’œil. "
"Chaque développeur Python se doit donc de la lire et de s'en inspirer autant "
"que possible ; voici ses principaux points notables :"

#: tutorial/controlflow.rst:1112
msgid "Use 4-space indentation, and no tabs."
msgstr "utilisez des indentations de 4 espaces et pas de tabulation."

#: tutorial/controlflow.rst:1114
msgid ""
"4 spaces are a good compromise between small indentation (allows greater "
"nesting depth) and large indentation (easier to read).  Tabs introduce "
"confusion, and are best left out."
msgstr ""
"4 espaces constituent un bon compromis entre une indentation courte (qui "
"permet une profondeur d'imbrication plus importante) et une longue (qui rend "
"le code plus facile à lire). Les tabulations introduisent de la confusion et "
"doivent être proscrites autant que possible ;"

#: tutorial/controlflow.rst:1118
msgid "Wrap lines so that they don't exceed 79 characters."
msgstr ""
"faites en sorte que les lignes ne dépassent pas 79 caractères, au besoin en "
"insérant des retours à la ligne."

#: tutorial/controlflow.rst:1120
msgid ""
"This helps users with small displays and makes it possible to have several "
"code files side-by-side on larger displays."
msgstr ""
"Vous facilitez ainsi la lecture pour les utilisateurs qui n'ont qu'un petit "
"écran et, pour les autres, cela leur permet de visualiser plusieurs fichiers "
"côte à côte ;"

#: tutorial/controlflow.rst:1123
msgid ""
"Use blank lines to separate functions and classes, and larger blocks of code "
"inside functions."
msgstr ""
"utilisez des lignes vides pour séparer les fonctions et les classes, ou pour "
"scinder de gros blocs de code à l'intérieur de fonctions ;"

#: tutorial/controlflow.rst:1126
msgid "When possible, put comments on a line of their own."
msgstr ""
"lorsque c'est possible, placez les commentaires sur leurs propres lignes ;"

#: tutorial/controlflow.rst:1128
msgid "Use docstrings."
msgstr "utilisez les chaînes de documentation ;"

#: tutorial/controlflow.rst:1130
msgid ""
"Use spaces around operators and after commas, but not directly inside "
"bracketing constructs: ``a = f(1, 2) + g(3, 4)``."
msgstr ""
"utilisez des espaces autour des opérateurs et après les virgules, mais pas "
"juste à l'intérieur des parenthèses : ``a = f(1, 2) + g(3, 4)`` ;"

#: tutorial/controlflow.rst:1133
msgid ""
"Name your classes and functions consistently; the convention is to use "
"``UpperCamelCase`` for classes and ``lowercase_with_underscores`` for "
"functions and methods.  Always use ``self`` as the name for the first method "
"argument (see :ref:`tut-firstclasses` for more on classes and methods)."
msgstr ""
"nommez toujours vos classes et fonctions de la même manière ; la convention "
"est d'utiliser une notation ``UpperCamelCase`` pour les classes, et "
"``minuscules_avec_trait_bas`` pour les fonctions et méthodes. Utilisez "
"toujours ``self`` comme nom du premier argument des méthodes (voyez :ref:"
"`tut-firstclasses` pour en savoir plus sur les classes et les méthodes) ;"

#: tutorial/controlflow.rst:1138
msgid ""
"Don't use fancy encodings if your code is meant to be used in international "
"environments.  Python's default, UTF-8, or even plain ASCII work best in any "
"case."
msgstr ""
"n’utilisez pas d'encodage exotique dès lors que votre code est censé être "
"utilisé dans des environnements internationaux. Par défaut, Python travaille "
"en UTF-8. Pour couvrir tous les cas, préférez le simple ASCII ;"

#: tutorial/controlflow.rst:1142
msgid ""
"Likewise, don't use non-ASCII characters in identifiers if there is only the "
"slightest chance people speaking a different language will read or maintain "
"the code."
msgstr ""
"de la même manière, n'utilisez que des caractères ASCII pour vos noms de "
"variables s'il est envisageable qu'une personne parlant une autre langue "
"lise ou doive modifier votre code."

#: tutorial/controlflow.rst:1148
msgid "Footnotes"
msgstr "Notes"

#: tutorial/controlflow.rst:1149
msgid ""
"Actually, *call by object reference* would be a better description, since if "
"a mutable object is passed, the caller will see any changes the callee makes "
"to it (items inserted into a list)."
msgstr ""
"En fait, *appels par référence d'objets* serait sans doute une description "
"plus juste dans la mesure où, si un objet mutable est passé en argument, "
"l'appelant verra toutes les modifications qui lui auront été apportées par "
"l'appelé (insertion d'éléments dans une liste…)."

#: tutorial/controlflow.rst:48
msgid "statement"
msgstr ""

#: tutorial/controlflow.rst:48
msgid "for"
msgstr ""

#: tutorial/controlflow.rst:1013
#, fuzzy
msgid "documentation strings"
msgstr "Chaînes de documentation"

#: tutorial/controlflow.rst:1013
#, fuzzy
msgid "docstrings"
msgstr "utilisez les chaînes de documentation ;"

#: tutorial/controlflow.rst:1013
msgid "strings, documentation"
msgstr ""

#: tutorial/controlflow.rst:917
msgid "* (asterisk)"
msgstr ""

#: tutorial/controlflow.rst:961
#, fuzzy
msgid "in function calls"
msgstr "Exemples de fonctions"

#: tutorial/controlflow.rst:961
msgid "**"
msgstr ""

#: tutorial/controlflow.rst:1065
#, fuzzy
msgid "function"
msgstr "Définir des fonctions"

#: tutorial/controlflow.rst:1065
#, fuzzy
msgid "annotations"
msgstr "Annotations de fonctions"

#: tutorial/controlflow.rst:1065
msgid "->"
msgstr ""

#: tutorial/controlflow.rst:1065
#, fuzzy
msgid "function annotations"
msgstr "Annotations de fonctions"

#: tutorial/controlflow.rst:1065
msgid ": (colon)"
msgstr ""

#: tutorial/controlflow.rst:1099
msgid "coding"
msgstr ""

#: tutorial/controlflow.rst:1099
msgid "style"
msgstr ""

#, fuzzy
#~ msgid ""
#~ "A :keyword:`!for` or :keyword:`!while` loop can include an :keyword:`!"
#~ "else` clause."
#~ msgstr ""
#~ "Les instructions :keyword:`!break`, :keyword:`!continue` et les clauses :"
#~ "keyword:`!else` au sein des boucles"

#~ msgid ""
#~ "Loop statements may have an :keyword:`!else` clause; it is executed when "
#~ "the loop terminates through exhaustion of the iterable (with :keyword:"
#~ "`for`) or when the condition becomes false (with :keyword:`while`), but "
#~ "not when the loop is terminated by a :keyword:`break` statement.  This is "
#~ "exemplified by the following loop, which searches for prime numbers::"
#~ msgstr ""
#~ "Les boucles peuvent également disposer d'une instruction :keyword:`!"
#~ "else` ; celle-ci est exécutée lorsqu'une boucle se termine alors que tous "
#~ "ses éléments ont été traités (dans le cas d'un :keyword:`for`) ou que la "
#~ "condition devient fausse (dans le cas d'un :keyword:`while`), mais pas "
#~ "lorsque la boucle est interrompue par une instruction :keyword:`break`. "
#~ "L'exemple suivant, qui effectue une recherche de nombres premiers, en est "
#~ "une démonstration ::"

#~ msgid ""
#~ "In chapter :ref:`tut-structures`, we will discuss in more detail about :"
#~ "func:`list`."
#~ msgstr ""
#~ "Dans le chapitre :ref:`tut-structures`, nous discuterons plus en détail "
#~ "sur :func:`list`."
